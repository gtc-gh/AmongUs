Number,Signature,Early_Version,Late_Version,Early_Signature,Late_Signature,Diff_Signature,Early_Implementation,Late_Implementation,Diff_Implementation,Early_Comment,Late_Comment,Diff_Comment,Early_Annotation,Late_Annotation,Diff_Annotation,Early_Callback,Late_Callback,Diff_Callback,GT_CI_ControlFlow,GT_CI_Type,pred_change,pred_CI,change_description,CI_description
1,"<android.provider.Settings.Secure: long getLong(ContentResolver,String)>",27,28,"<android.provider.Settings.Secure: long getLong(ContentResolver,String)>","<android.provider.Settings.Secure: long getLong(ContentResolver,String)>",0,"{
    return getLongForUser(cr, name, UserHandle.myUserId());
}","{
    return getLongForUser(cr, name, cr.getUserId());
}",1,"/**
 * Convenience function for retrieving a single secure settings value
 * as a {@code long}.  Note that internally setting values are always
 * stored as strings; this function converts the string to a {@code long}
 * for you.
 * <p>
 * This version does not take a default value.  If the setting has not
 * been set, or the string value is not a number,
 * it throws {@link SettingNotFoundException}.
 *
 * @param cr The ContentResolver to access.
 * @param name The name of the setting to retrieve.
 *
 * @return The setting's current value.
 * @throws SettingNotFoundException Thrown if a setting by the given
 * name can't be found or the setting value is not an integer.
 */
","/**
 * Convenience function for retrieving a single secure settings value
 * as a {@code long}.  Note that internally setting values are always
 * stored as strings; this function converts the string to a {@code long}
 * for you.
 * <p>
 * This version does not take a default value.  If the setting has not
 * been set, or the string value is not a number,
 * it throws {@link SettingNotFoundException}.
 *
 * @param cr The ContentResolver to access.
 * @param name The name of the setting to retrieve.
 *
 * @return The setting's current value.
 * @throws SettingNotFoundException Thrown if a setting by the given
 * name can't be found or the setting value is not an integer.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",1,"The implementation has changed to use a different method to get the user ID (from UserHandle.myUserId() to cr.getUserId()), therefore the code change type is 4,5 (Other statement changed and Dependent API changed).","Since the way the user ID is retrieved has changed, this could potentially affect the return value of the getLong method if the methods return different user IDs in certain contexts. Therefore, there is a Compatibility Issue due to the potential different return values, and the CI type is 1."
2,"<android.widget.Editor.TextActionModeCallback: void onGetContentRect(ActionMode,View,Rect)>",27,28,"<android.widget.Editor.TextActionModeCallback: void onGetContentRect(ActionMode,View,Rect)>","<android.widget.Editor.TextActionModeCallback: void onGetContentRect(ActionMode,View,Rect)>",0,"{
    if (!view.equals(mTextView) || mTextView.getLayout() == null) {
        super.onGetContentRect(mode, view, outRect);
        return;
    }
    if (mTextView.getSelectionStart() != mTextView.getSelectionEnd()) {
        // We have a selection.
        mSelectionPath.reset();
        mTextView.getLayout().getSelectionPath(mTextView.getSelectionStart(), mTextView.getSelectionEnd(), mSelectionPath);
        mSelectionPath.computeBounds(mSelectionBounds, true);
        mSelectionBounds.bottom += mHandleHeight;
    } else if (mCursorCount == 2) {
        // We have a split cursor. In this case, we take the rectangle that includes both
        // parts of the cursor to ensure we don't obscure either of them.
        Rect firstCursorBounds = mCursorDrawable[0].getBounds();
        Rect secondCursorBounds = mCursorDrawable[1].getBounds();
        mSelectionBounds.set(Math.min(firstCursorBounds.left, secondCursorBounds.left), Math.min(firstCursorBounds.top, secondCursorBounds.top), Math.max(firstCursorBounds.right, secondCursorBounds.right), Math.max(firstCursorBounds.bottom, secondCursorBounds.bottom) + mHandleHeight);
    } else {
        // We have a single cursor.
        Layout layout = mTextView.getLayout();
        int line = layout.getLineForOffset(mTextView.getSelectionStart());
        float primaryHorizontal = clampHorizontalPosition(null, layout.getPrimaryHorizontal(mTextView.getSelectionStart()));
        mSelectionBounds.set(primaryHorizontal, layout.getLineTop(line), primaryHorizontal, layout.getLineTop(line + 1) + mHandleHeight);
    }
    // Take TextView's padding and scroll into account.
    int textHorizontalOffset = mTextView.viewportToContentHorizontalOffset();
    int textVerticalOffset = mTextView.viewportToContentVerticalOffset();
    outRect.set((int) Math.floor(mSelectionBounds.left + textHorizontalOffset), (int) Math.floor(mSelectionBounds.top + textVerticalOffset), (int) Math.ceil(mSelectionBounds.right + textHorizontalOffset), (int) Math.ceil(mSelectionBounds.bottom + textVerticalOffset));
}","{
    if (!view.equals(mTextView) || mTextView.getLayout() == null) {
        super.onGetContentRect(mode, view, outRect);
        return;
    }
    if (mTextView.getSelectionStart() != mTextView.getSelectionEnd()) {
        // We have a selection.
        mSelectionPath.reset();
        mTextView.getLayout().getSelectionPath(mTextView.getSelectionStart(), mTextView.getSelectionEnd(), mSelectionPath);
        mSelectionPath.computeBounds(mSelectionBounds, true);
        mSelectionBounds.bottom += mHandleHeight;
    } else {
        // We have a cursor.
        Layout layout = mTextView.getLayout();
        int line = layout.getLineForOffset(mTextView.getSelectionStart());
        float primaryHorizontal = clampHorizontalPosition(null, layout.getPrimaryHorizontal(mTextView.getSelectionStart()));
        mSelectionBounds.set(primaryHorizontal, layout.getLineTop(line), primaryHorizontal, layout.getLineBottom(line) + mHandleHeight);
    }
    // Take TextView's padding and scroll into account.
    int textHorizontalOffset = mTextView.viewportToContentHorizontalOffset();
    int textVerticalOffset = mTextView.viewportToContentVerticalOffset();
    outRect.set((int) Math.floor(mSelectionBounds.left + textHorizontalOffset), (int) Math.floor(mSelectionBounds.top + textVerticalOffset), (int) Math.ceil(mSelectionBounds.right + textHorizontalOffset), (int) Math.ceil(mSelectionBounds.bottom + textVerticalOffset));
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,3,0,"The only change is in the 'else' control block, where the condition ""mCursorCount == 2"" has been removed and the else block for handling a single cursor is always executed instead of checking for split cursor. This is a control dependency change, so the code change type is 3.","There is no compatibility issue because the behavior is consistent for both cases where there is a selection or a single cursor. The special handling for a split cursor (mCursorCount == 2) has been removed, which means this code path will no longer be taken. However, clients who do not have a split cursor will see no change in behavior. For those who have the split cursor case, the code will now default to the single cursor handling, which can be seen as an adjustment in handling edge cases rather than a compatibility issue, especially if the ""split cursor"" was a non-standard or unsupported feature. Thus, there is no CI caused by potential different return values or exceptions (CI type 0)."
3,"<android.view.View: boolean startDragAndDrop(ClipData,DragShadowBuilder,Object,int)>",27,28,"<android.view.View: boolean startDragAndDrop(ClipData,DragShadowBuilder,Object,int)>","<android.view.View: boolean startDragAndDrop(ClipData,DragShadowBuilder,Object,int)>",0,"{
    if (ViewDebug.DEBUG_DRAG) {
        Log.d(VIEW_LOG_TAG, ""startDragAndDrop: data="" + data + "" flags="" + flags);
    }
    if (mAttachInfo == null) {
        Log.w(VIEW_LOG_TAG, ""startDragAndDrop called on a detached view."");
        return false;
    }
    if (data != null) {
        data.prepareToLeaveProcess((flags & View.DRAG_FLAG_GLOBAL) != 0);
    }
    boolean okay = false;
    Point shadowSize = new Point();
    Point shadowTouchPoint = new Point();
    shadowBuilder.onProvideShadowMetrics(shadowSize, shadowTouchPoint);
    if ((shadowSize.x < 0) || (shadowSize.y < 0) || (shadowTouchPoint.x < 0) || (shadowTouchPoint.y < 0)) {
        throw new IllegalStateException(""Drag shadow dimensions must not be negative"");
    }
    if (ViewDebug.DEBUG_DRAG) {
        Log.d(VIEW_LOG_TAG, ""drag shadow: width="" + shadowSize.x + "" height="" + shadowSize.y + "" shadowX="" + shadowTouchPoint.x + "" shadowY="" + shadowTouchPoint.y);
    }
    if (mAttachInfo.mDragSurface != null) {
        mAttachInfo.mDragSurface.release();
    }
    mAttachInfo.mDragSurface = new Surface();
    try {
        mAttachInfo.mDragToken = mAttachInfo.mSession.prepareDrag(mAttachInfo.mWindow, flags, shadowSize.x, shadowSize.y, mAttachInfo.mDragSurface);
        if (ViewDebug.DEBUG_DRAG)
            Log.d(VIEW_LOG_TAG, ""prepareDrag returned token="" + mAttachInfo.mDragToken + "" surface="" + mAttachInfo.mDragSurface);
        if (mAttachInfo.mDragToken != null) {
            Canvas canvas = mAttachInfo.mDragSurface.lockCanvas(null);
            try {
                canvas.drawColor(0, PorterDuff.Mode.CLEAR);
                shadowBuilder.onDrawShadow(canvas);
            } finally {
                mAttachInfo.mDragSurface.unlockCanvasAndPost(canvas);
            }
            final ViewRootImpl root = getViewRootImpl();
            // Cache the local state object for delivery with DragEvents
            root.setLocalDragState(myLocalState);
            // repurpose 'shadowSize' for the last touch point
            root.getLastTouchPoint(shadowSize);
            okay = mAttachInfo.mSession.performDrag(mAttachInfo.mWindow, mAttachInfo.mDragToken, root.getLastTouchSource(), shadowSize.x, shadowSize.y, shadowTouchPoint.x, shadowTouchPoint.y, data);
            if (ViewDebug.DEBUG_DRAG)
                Log.d(VIEW_LOG_TAG, ""performDrag returned "" + okay);
        }
    } catch (Exception e) {
        Log.e(VIEW_LOG_TAG, ""Unable to initiate drag"", e);
        mAttachInfo.mDragSurface.destroy();
        mAttachInfo.mDragSurface = null;
    }
    return okay;
}","{
    if (ViewDebug.DEBUG_DRAG) {
        Log.d(VIEW_LOG_TAG, ""startDragAndDrop: data="" + data + "" flags="" + flags);
    }
    if (mAttachInfo == null) {
        Log.w(VIEW_LOG_TAG, ""startDragAndDrop called on a detached view."");
        return false;
    }
    if (data != null) {
        data.prepareToLeaveProcess((flags & View.DRAG_FLAG_GLOBAL) != 0);
    }
    Point shadowSize = new Point();
    Point shadowTouchPoint = new Point();
    shadowBuilder.onProvideShadowMetrics(shadowSize, shadowTouchPoint);
    if ((shadowSize.x < 0) || (shadowSize.y < 0) || (shadowTouchPoint.x < 0) || (shadowTouchPoint.y < 0)) {
        throw new IllegalStateException(""Drag shadow dimensions must not be negative"");
    }
    // does not accept zero size surface.
    if (shadowSize.x == 0 || shadowSize.y == 0) {
        if (!sAcceptZeroSizeDragShadow) {
            throw new IllegalStateException(""Drag shadow dimensions must be positive"");
        }
        shadowSize.x = 1;
        shadowSize.y = 1;
    }
    if (ViewDebug.DEBUG_DRAG) {
        Log.d(VIEW_LOG_TAG, ""drag shadow: width="" + shadowSize.x + "" height="" + shadowSize.y + "" shadowX="" + shadowTouchPoint.x + "" shadowY="" + shadowTouchPoint.y);
    }
    if (mAttachInfo.mDragSurface != null) {
        mAttachInfo.mDragSurface.release();
    }
    mAttachInfo.mDragSurface = new Surface();
    mAttachInfo.mDragToken = null;
    final ViewRootImpl root = mAttachInfo.mViewRootImpl;
    final SurfaceSession session = new SurfaceSession(root.mSurface);
    final SurfaceControl surface = new SurfaceControl.Builder(session).setName(""drag surface"").setSize(shadowSize.x, shadowSize.y).setFormat(PixelFormat.TRANSLUCENT).build();
    try {
        mAttachInfo.mDragSurface.copyFrom(surface);
        final Canvas canvas = mAttachInfo.mDragSurface.lockCanvas(null);
        try {
            canvas.drawColor(0, PorterDuff.Mode.CLEAR);
            shadowBuilder.onDrawShadow(canvas);
        } finally {
            mAttachInfo.mDragSurface.unlockCanvasAndPost(canvas);
        }
        // Cache the local state object for delivery with DragEvents
        root.setLocalDragState(myLocalState);
        // repurpose 'shadowSize' for the last touch point
        root.getLastTouchPoint(shadowSize);
        mAttachInfo.mDragToken = mAttachInfo.mSession.performDrag(mAttachInfo.mWindow, flags, surface, root.getLastTouchSource(), shadowSize.x, shadowSize.y, shadowTouchPoint.x, shadowTouchPoint.y, data);
        if (ViewDebug.DEBUG_DRAG) {
            Log.d(VIEW_LOG_TAG, ""performDrag returned "" + mAttachInfo.mDragToken);
        }
        return mAttachInfo.mDragToken != null;
    } catch (Exception e) {
        Log.e(VIEW_LOG_TAG, ""Unable to initiate drag"", e);
        return false;
    } finally {
        if (mAttachInfo.mDragToken == null) {
            mAttachInfo.mDragSurface.destroy();
            mAttachInfo.mDragSurface = null;
            root.setLocalDragState(null);
        }
        session.kill();
    }
}",1,"/**
 * Starts a drag and drop operation. When your application calls this method, it passes a
 * {@link android.view.View.DragShadowBuilder} object to the system. The
 * system calls this object's {@link DragShadowBuilder#onProvideShadowMetrics(Point, Point)}
 * to get metrics for the drag shadow, and then calls the object's
 * {@link DragShadowBuilder#onDrawShadow(Canvas)} to draw the drag shadow itself.
 * <p>
 * Once the system has the drag shadow, it begins the drag and drop operation by sending
 * drag events to all the View objects in your application that are currently visible. It does
 * this either by calling the View object's drag listener (an implementation of
 * {@link android.view.View.OnDragListener#onDrag(View,DragEvent) onDrag()} or by calling the
 * View object's {@link android.view.View#onDragEvent(DragEvent) onDragEvent()} method.
 * Both are passed a {@link android.view.DragEvent} object that has a
 * {@link android.view.DragEvent#getAction()} value of
 * {@link android.view.DragEvent#ACTION_DRAG_STARTED}.
 * </p>
 * <p>
 * Your application can invoke {@link #startDragAndDrop(ClipData, DragShadowBuilder, Object,
 * int) startDragAndDrop()} on any attached View object. The View object does not need to be
 * the one used in {@link android.view.View.DragShadowBuilder}, nor does it need to be related
 * to the View the user selected for dragging.
 * </p>
 * @param data A {@link android.content.ClipData} object pointing to the data to be
 * transferred by the drag and drop operation.
 * @param shadowBuilder A {@link android.view.View.DragShadowBuilder} object for building the
 * drag shadow.
 * @param myLocalState An {@link java.lang.Object} containing local data about the drag and
 * drop operation. When dispatching drag events to views in the same activity this object
 * will be available through {@link android.view.DragEvent#getLocalState()}. Views in other
 * activities will not have access to this data ({@link android.view.DragEvent#getLocalState()}
 * will return null).
 * <p>
 * myLocalState is a lightweight mechanism for the sending information from the dragged View
 * to the target Views. For example, it can contain flags that differentiate between a
 * a copy operation and a move operation.
 * </p>
 * @param flags Flags that control the drag and drop operation. This can be set to 0 for no
 * flags, or any combination of the following:
 * <ul>
 * <li>{@link #DRAG_FLAG_GLOBAL}</li>
 * <li>{@link #DRAG_FLAG_GLOBAL_PERSISTABLE_URI_PERMISSION}</li>
 * <li>{@link #DRAG_FLAG_GLOBAL_PREFIX_URI_PERMISSION}</li>
 * <li>{@link #DRAG_FLAG_GLOBAL_URI_READ}</li>
 * <li>{@link #DRAG_FLAG_GLOBAL_URI_WRITE}</li>
 * <li>{@link #DRAG_FLAG_OPAQUE}</li>
 * </ul>
 * @return {@code true} if the method completes successfully, or
 * {@code false} if it fails anywhere. Returning {@code false} means the system was unable to
 * do a drag, and so no drag operation is in progress.
 */
","/**
 * Starts a drag and drop operation. When your application calls this method, it passes a
 * {@link android.view.View.DragShadowBuilder} object to the system. The
 * system calls this object's {@link DragShadowBuilder#onProvideShadowMetrics(Point, Point)}
 * to get metrics for the drag shadow, and then calls the object's
 * {@link DragShadowBuilder#onDrawShadow(Canvas)} to draw the drag shadow itself.
 * <p>
 * Once the system has the drag shadow, it begins the drag and drop operation by sending
 * drag events to all the View objects in your application that are currently visible. It does
 * this either by calling the View object's drag listener (an implementation of
 * {@link android.view.View.OnDragListener#onDrag(View,DragEvent) onDrag()} or by calling the
 * View object's {@link android.view.View#onDragEvent(DragEvent) onDragEvent()} method.
 * Both are passed a {@link android.view.DragEvent} object that has a
 * {@link android.view.DragEvent#getAction()} value of
 * {@link android.view.DragEvent#ACTION_DRAG_STARTED}.
 * </p>
 * <p>
 * Your application can invoke {@link #startDragAndDrop(ClipData, DragShadowBuilder, Object,
 * int) startDragAndDrop()} on any attached View object. The View object does not need to be
 * the one used in {@link android.view.View.DragShadowBuilder}, nor does it need to be related
 * to the View the user selected for dragging.
 * </p>
 * @param data A {@link android.content.ClipData} object pointing to the data to be
 * transferred by the drag and drop operation.
 * @param shadowBuilder A {@link android.view.View.DragShadowBuilder} object for building the
 * drag shadow.
 * @param myLocalState An {@link java.lang.Object} containing local data about the drag and
 * drop operation. When dispatching drag events to views in the same activity this object
 * will be available through {@link android.view.DragEvent#getLocalState()}. Views in other
 * activities will not have access to this data ({@link android.view.DragEvent#getLocalState()}
 * will return null).
 * <p>
 * myLocalState is a lightweight mechanism for the sending information from the dragged View
 * to the target Views. For example, it can contain flags that differentiate between a
 * a copy operation and a move operation.
 * </p>
 * @param flags Flags that control the drag and drop operation. This can be set to 0 for no
 * flags, or any combination of the following:
 * <ul>
 * <li>{@link #DRAG_FLAG_GLOBAL}</li>
 * <li>{@link #DRAG_FLAG_GLOBAL_PERSISTABLE_URI_PERMISSION}</li>
 * <li>{@link #DRAG_FLAG_GLOBAL_PREFIX_URI_PERMISSION}</li>
 * <li>{@link #DRAG_FLAG_GLOBAL_URI_READ}</li>
 * <li>{@link #DRAG_FLAG_GLOBAL_URI_WRITE}</li>
 * <li>{@link #DRAG_FLAG_OPAQUE}</li>
 * </ul>
 * @return {@code true} if the method completes successfully, or
 * {@code false} if it fails anywhere. Returning {@code false} means the system was unable to
 * do a drag, and so no drag operation is in progress.
 */
",-1,,,-1,-1,-1,-1,-1,-1,,,,
4,<android.service.autofill.Dataset.Builder: Dataset build()>,27,28,<android.service.autofill.Dataset.Builder: Dataset build()>,<android.service.autofill.Dataset.Builder: Dataset build()>,0,"{
    throwIfDestroyed();
    mDestroyed = true;
    if (mFieldIds == null) {
        throw new IllegalArgumentException(""at least one value must be set"");
    }
    return new Dataset(this);
}","{
    throwIfDestroyed();
    mDestroyed = true;
    if (mFieldIds == null) {
        throw new IllegalStateException(""at least one value must be set"");
    }
    return new Dataset(this);
}",1,"/**
 * Creates a new {@link Dataset} instance.
 *
 * <p>You should not interact with this builder once this method is called.
 *
 * <p>It is required that you specify at least one field before calling this method. It's
 * also mandatory to provide a presentation view to visualize the data set in the UI.
 *
 * @return The built dataset.
 */
","/**
 * Creates a new {@link Dataset} instance.
 *
 * <p>You should not interact with this builder once this method is called.
 *
 * @throws IllegalStateException if no field was set (through
 * {@link #setValue(AutofillId, AutofillValue)} or
 * {@link #setValue(AutofillId, AutofillValue, RemoteViews)}).
 *
 * @return The built dataset.
 */
",-1,[@NonNull],[@NonNull],-1,-1,-1,-1,-1,-1,2,2,"The exception thrown for the same condition has changed from IllegalArgumentException to IllegalStateException, so the change type is 2.","Because there is a change in the type of exception thrown, this could lead to a different behavior when handling this exception in the code that calls this API. Therefore, the CI type is 2."
5,<android.net.TrafficStats: long getMobileRxPackets()>,27,28,<android.net.TrafficStats: long getMobileRxPackets()>,<android.net.TrafficStats: long getMobileRxPackets()>,0,"{
    long total = 0;
    for (String iface : getMobileIfaces()) {
        total += getRxPackets(iface);
    }
    return total;
}","{
    long total = 0;
    for (String iface : getMobileIfaces()) {
        total += addIfSupported(getRxPackets(iface));
    }
    return total;
}",1,"/**
 * Return number of packets received across mobile networks since device
 * boot. Counts packets across all mobile network interfaces, and always
 * increases monotonically since device boot. Statistics are measured at the
 * network layer, so they include both TCP and UDP usage.
 * <p>
 * Before {@link android.os.Build.VERSION_CODES#JELLY_BEAN_MR2}, this may
 * return {@link #UNSUPPORTED} on devices where statistics aren't available.
 */
","/**
 * Return number of packets received across mobile networks since device
 * boot. Counts packets across all mobile network interfaces, and always
 * increases monotonically since device boot. Statistics are measured at the
 * network layer, so they include both TCP and UDP usage.
 * <p>
 * Before {@link android.os.Build.VERSION_CODES#JELLY_BEAN_MR2}, this may
 * return {@link #UNSUPPORTED} on devices where statistics aren't available.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",1,"The method `addIfSupported()` is added to modify the value added to `total` within the 'for' loop, and `getRxPackets(iface)` is now passed as a parameter to `addIfSupported()`. This represents a change in an internal statement which is neither a return, exception handling, nor control dependency change. Additionally, it is a change to the usage of the dependent API (`getRxPackets()` now being used with another method `addIfSupported()`), so the code change types are 4 and 5.","Since `addIfSupported()` could potentially alter the value being added to `total`, this could result in a different return value for the API, which is why CI type is 1."
6,<android.content.pm.VersionedPackage: int getVersionCode()>,27,28,<android.content.pm.VersionedPackage: int getVersionCode()>,<android.content.pm.VersionedPackage: int getVersionCode()>,0,"{
    return mVersionCode;
}","{
    return (int) (mVersionCode & 0x7fffffff);
}",1,"/**
 * Gets the version code.
 *
 * @return The version code.
 */
","/**
 * @deprecated use {@link #getLongVersionCode()} instead.
 */
",-1,[@VersionCode],"[@Deprecated, @VersionCode]",-1,-1,-1,-1,-1,-1,"1,4",1,"The implementation of the method has changed, adding a bitmask operation to the return statement. Additionally, deprecation annotation is added, so the code change is of types 1 and 4.","The bitmask operation in the return statement could potentially lead to a different return value, particularly affecting the sign of the version code, so the CI type is 1."
7,<android.bluetooth.le.AdvertisingSet: void setPeriodicAdvertisingEnabled(boolean)>,27,28,<android.bluetooth.le.AdvertisingSet: void setPeriodicAdvertisingEnabled(boolean)>,<android.bluetooth.le.AdvertisingSet: void setPeriodicAdvertisingEnabled(boolean)>,0,"{
    try {
        gatt.setPeriodicAdvertisingEnable(this.advertiserId, enable);
    } catch (RemoteException e) {
        Log.e(TAG, ""remote exception - "", e);
    }
}","{
    try {
        mGatt.setPeriodicAdvertisingEnable(mAdvertiserId, enable);
    } catch (RemoteException e) {
        Log.e(TAG, ""remote exception - "", e);
    }
}",1,"/**
 * Used to enable/disable periodic advertising. This method returns immediately, the operation
 * status is delivered through {@code callback.onPeriodicAdvertisingEnable()}.
 *
 * @param enable whether the periodic advertising should be enabled (true), or disabled (false).
 */
","/**
 * Used to enable/disable periodic advertising. This method returns immediately, the operation
 * status is delivered through {@code callback.onPeriodicAdvertisingEnable()}.
 *
 * @param enable whether the periodic advertising should be enabled (true), or disabled
 * (false).
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The change is in the variable names used; `gatt` to `mGatt` and `advertiserId` to `mAdvertiserId`. This is a refactoring change which does not alter the behavior of the method, therefore, the code change type is 4.","Since the change is solely in the naming of internal variables and does not affect the functionality, behavior, control flow, or output of the method, there is no Compatibility Issue. Hence, there will be no difference in behavior for the end user, and the method's contract remains the same."
9,<android.os.Parcel: void writeException(Exception)>,27,28,<android.os.Parcel: void writeException(Exception)>,<android.os.Parcel: void writeException(Exception)>,0,"{
    int code = 0;
    if (e instanceof Parcelable && (e.getClass().getClassLoader() == Parcelable.class.getClassLoader())) {
        // We only send Parcelable exceptions that are in the
        // BootClassLoader to ensure that the receiver can unpack them
        code = EX_PARCELABLE;
    } else if (e instanceof SecurityException) {
        code = EX_SECURITY;
    } else if (e instanceof BadParcelableException) {
        code = EX_BAD_PARCELABLE;
    } else if (e instanceof IllegalArgumentException) {
        code = EX_ILLEGAL_ARGUMENT;
    } else if (e instanceof NullPointerException) {
        code = EX_NULL_POINTER;
    } else if (e instanceof IllegalStateException) {
        code = EX_ILLEGAL_STATE;
    } else if (e instanceof NetworkOnMainThreadException) {
        code = EX_NETWORK_MAIN_THREAD;
    } else if (e instanceof UnsupportedOperationException) {
        code = EX_UNSUPPORTED_OPERATION;
    } else if (e instanceof ServiceSpecificException) {
        code = EX_SERVICE_SPECIFIC;
    }
    writeInt(code);
    StrictMode.clearGatheredViolations();
    if (code == 0) {
        if (e instanceof RuntimeException) {
            throw (RuntimeException) e;
        }
        throw new RuntimeException(e);
    }
    writeString(e.getMessage());
    switch(code) {
        case EX_SERVICE_SPECIFIC:
            writeInt(((ServiceSpecificException) e).errorCode);
            break;
        case EX_PARCELABLE:
            // Write parceled exception prefixed by length
            final int sizePosition = dataPosition();
            writeInt(0);
            writeParcelable((Parcelable) e, Parcelable.PARCELABLE_WRITE_RETURN_VALUE);
            final int payloadPosition = dataPosition();
            setDataPosition(sizePosition);
            writeInt(payloadPosition - sizePosition);
            setDataPosition(payloadPosition);
            break;
    }
}","{
    int code = 0;
    if (e instanceof Parcelable && (e.getClass().getClassLoader() == Parcelable.class.getClassLoader())) {
        // We only send Parcelable exceptions that are in the
        // BootClassLoader to ensure that the receiver can unpack them
        code = EX_PARCELABLE;
    } else if (e instanceof SecurityException) {
        code = EX_SECURITY;
    } else if (e instanceof BadParcelableException) {
        code = EX_BAD_PARCELABLE;
    } else if (e instanceof IllegalArgumentException) {
        code = EX_ILLEGAL_ARGUMENT;
    } else if (e instanceof NullPointerException) {
        code = EX_NULL_POINTER;
    } else if (e instanceof IllegalStateException) {
        code = EX_ILLEGAL_STATE;
    } else if (e instanceof NetworkOnMainThreadException) {
        code = EX_NETWORK_MAIN_THREAD;
    } else if (e instanceof UnsupportedOperationException) {
        code = EX_UNSUPPORTED_OPERATION;
    } else if (e instanceof ServiceSpecificException) {
        code = EX_SERVICE_SPECIFIC;
    }
    writeInt(code);
    StrictMode.clearGatheredViolations();
    if (code == 0) {
        if (e instanceof RuntimeException) {
            throw (RuntimeException) e;
        }
        throw new RuntimeException(e);
    }
    writeString(e.getMessage());
    final long timeNow = sParcelExceptionStackTrace ? SystemClock.elapsedRealtime() : 0;
    if (sParcelExceptionStackTrace && (timeNow - sLastWriteExceptionStackTrace > WRITE_EXCEPTION_STACK_TRACE_THRESHOLD_MS)) {
        sLastWriteExceptionStackTrace = timeNow;
        final int sizePosition = dataPosition();
        // Header size will be filled in later
        writeInt(0);
        StackTraceElement[] stackTrace = e.getStackTrace();
        final int truncatedSize = Math.min(stackTrace.length, 5);
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < truncatedSize; i++) {
            sb.append(""\tat "").append(stackTrace[i]).append('\n');
        }
        writeString(sb.toString());
        final int payloadPosition = dataPosition();
        setDataPosition(sizePosition);
        // Write stack trace header size. Used in native side to skip the header
        writeInt(payloadPosition - sizePosition);
        setDataPosition(payloadPosition);
    } else {
        writeInt(0);
    }
    switch(code) {
        case EX_SERVICE_SPECIFIC:
            writeInt(((ServiceSpecificException) e).errorCode);
            break;
        case EX_PARCELABLE:
            // Write parceled exception prefixed by length
            final int sizePosition = dataPosition();
            writeInt(0);
            writeParcelable((Parcelable) e, Parcelable.PARCELABLE_WRITE_RETURN_VALUE);
            final int payloadPosition = dataPosition();
            setDataPosition(sizePosition);
            writeInt(payloadPosition - sizePosition);
            setDataPosition(payloadPosition);
            break;
    }
}",1,"/**
 * Special function for writing an exception result at the header of
 * a parcel, to be used when returning an exception from a transaction.
 * Note that this currently only supports a few exception types; any other
 * exception will be re-thrown by this function as a RuntimeException
 * (to be caught by the system's last-resort exception handling when
 * dispatching a transaction).
 *
 * <p>The supported exception types are:
 * <ul>
 * <li>{@link BadParcelableException}
 * <li>{@link IllegalArgumentException}
 * <li>{@link IllegalStateException}
 * <li>{@link NullPointerException}
 * <li>{@link SecurityException}
 * <li>{@link UnsupportedOperationException}
 * <li>{@link NetworkOnMainThreadException}
 * </ul>
 *
 * @param e The Exception to be written.
 *
 * @see #writeNoException
 * @see #readException
 */
","/**
 * Special function for writing an exception result at the header of
 * a parcel, to be used when returning an exception from a transaction.
 * Note that this currently only supports a few exception types; any other
 * exception will be re-thrown by this function as a RuntimeException
 * (to be caught by the system's last-resort exception handling when
 * dispatching a transaction).
 *
 * <p>The supported exception types are:
 * <ul>
 * <li>{@link BadParcelableException}
 * <li>{@link IllegalArgumentException}
 * <li>{@link IllegalStateException}
 * <li>{@link NullPointerException}
 * <li>{@link SecurityException}
 * <li>{@link UnsupportedOperationException}
 * <li>{@link NetworkOnMainThreadException}
 * </ul>
 *
 * @param e The Exception to be written.
 *
 * @see #writeNoException
 * @see #readException
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,3,4",2,"The new code introduces additional logic for stack trace handling, captures the current system time, and writes a truncated stack trace string if certain conditions are met. This change represents a combination of control dependency changes (introduction of new if statement with conditions) and other statement changes (addition of new variables and methods for stack trace handling). Additionally, an exception handling change exists because in the late version, the RuntimeException(e) thrown is no longer wrapped in a 'throw new RuntimeException(e);', but instead, a stack trace header size is written into the Parcel which changes the exception handling mechanism.","There is a Compatibility Issue related to potential different exception handlings (CI type 2) because the late version adds logic that could affect how exceptions are handled or wrapped, which includes additional stack trace information that wasn't provided before. This added information is not explicitly thrown, but it alters the contents of the Parcel that is being written in the case of an exception, potentially affecting how exceptions are processed or rethrown by the receiving side."
11,<android.bluetooth.BluetoothGatt: boolean writeCharacteristic(BluetoothGattCharacteristic)>,27,28,<android.bluetooth.BluetoothGatt: boolean writeCharacteristic(BluetoothGattCharacteristic)>,<android.bluetooth.BluetoothGatt: boolean writeCharacteristic(BluetoothGattCharacteristic)>,0,"{
    if ((characteristic.getProperties() & BluetoothGattCharacteristic.PROPERTY_WRITE) == 0 && (characteristic.getProperties() & BluetoothGattCharacteristic.PROPERTY_WRITE_NO_RESPONSE) == 0)
        return false;
    if (VDBG)
        Log.d(TAG, ""writeCharacteristic() - uuid: "" + characteristic.getUuid());
    if (mService == null || mClientIf == 0 || characteristic.getValue() == null)
        return false;
    BluetoothGattService service = characteristic.getService();
    if (service == null)
        return false;
    BluetoothDevice device = service.getDevice();
    if (device == null)
        return false;
    synchronized (mDeviceBusy) {
        if (mDeviceBusy)
            return false;
        mDeviceBusy = true;
    }
    try {
        mService.writeCharacteristic(mClientIf, device.getAddress(), characteristic.getInstanceId(), characteristic.getWriteType(), AUTHENTICATION_NONE, characteristic.getValue());
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
        mDeviceBusy = false;
        return false;
    }
    return true;
}","{
    if ((characteristic.getProperties() & BluetoothGattCharacteristic.PROPERTY_WRITE) == 0 && (characteristic.getProperties() & BluetoothGattCharacteristic.PROPERTY_WRITE_NO_RESPONSE) == 0) {
        return false;
    }
    if (VDBG)
        Log.d(TAG, ""writeCharacteristic() - uuid: "" + characteristic.getUuid());
    if (mService == null || mClientIf == 0 || characteristic.getValue() == null)
        return false;
    BluetoothGattService service = characteristic.getService();
    if (service == null)
        return false;
    BluetoothDevice device = service.getDevice();
    if (device == null)
        return false;
    synchronized (mDeviceBusy) {
        if (mDeviceBusy)
            return false;
        mDeviceBusy = true;
    }
    try {
        mService.writeCharacteristic(mClientIf, device.getAddress(), characteristic.getInstanceId(), characteristic.getWriteType(), AUTHENTICATION_NONE, characteristic.getValue());
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
        mDeviceBusy = false;
        return false;
    }
    return true;
}",1,"/**
 * Writes a given characteristic and its values to the associated remote device.
 *
 * <p>Once the write operation has been completed, the
 * {@link BluetoothGattCallback#onCharacteristicWrite} callback is invoked,
 * reporting the result of the operation.
 *
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH} permission.
 *
 * @param characteristic Characteristic to write on the remote device
 * @return true, if the write operation was initiated successfully
 */
","/**
 * Writes a given characteristic and its values to the associated remote device.
 *
 * <p>Once the write operation has been completed, the
 * {@link BluetoothGattCallback#onCharacteristicWrite} callback is invoked,
 * reporting the result of the operation.
 *
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH} permission.
 *
 * @param characteristic Characteristic to write on the remote device
 * @return true, if the write operation was initiated successfully
 */
",-1,,,-1,-1,-1,-1,-1,-1,0,0,"There is no actual change in the implementation of the method between the two versions. The same checks and operations are performed, and the structure of the method remains unchanged.","Since there are no changes in the implementation, there is no Compatibility Issue between the two versions."
12,<android.app.job.JobInfo: long getInitialBackoffMillis()>,27,28,<android.app.job.JobInfo: long getInitialBackoffMillis()>,<android.app.job.JobInfo: long getInitialBackoffMillis()>,0,"{
    final long minBackoff = getMinBackoffMillis();
    return initialBackoffMillis >= minBackoff ? initialBackoffMillis : minBackoff;
}","{
    return initialBackoffMillis;
}",1,"/**
 * The amount of time the JobScheduler will wait before rescheduling a failed job. This value
 * will be increased depending on the backoff policy specified at job creation time. Defaults
 * to 30 seconds, minimum is currently 10 seconds.
 */
","/**
 * The amount of time the JobScheduler will wait before rescheduling a failed job. This value
 * will be increased depending on the backoff policy specified at job creation time. Defaults
 * to 30 seconds, minimum is currently 10 seconds.
 * @see JobInfo.Builder#setBackoffCriteria(long, int)
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The method body in the early version includes a minimum backoff check, which has been removed in the late version. This is a return statement change and a change in the dependent API due to the removal of getMinBackoffMillis() method call, so the code change type is 1,5.","As the condition that ensures the initial backoff is not below a certain threshold has been removed, the late version of the API could potentially return a different value than the early version if initialBackoffMillis is less than the previously defined minimum. This constitutes a compatibility issue due to potential different return values, so the CI type is 1."
13,<android.net.LocalSocketImpl.SocketInputStream: int available()>,27,28,<android.net.LocalSocketImpl.SocketInputStream: int available()>,<android.net.LocalSocketImpl.SocketInputStream: int available()>,0,"{
    FileDescriptor myFd = fd;
    if (myFd == null)
        throw new IOException(""socket closed"");
    MutableInt avail = new MutableInt(0);
    try {
        Os.ioctlInt(myFd, OsConstants.FIONREAD, avail);
    } catch (ErrnoException e) {
        throw e.rethrowAsIOException();
    }
    return avail.value;
}","{
    FileDescriptor myFd = fd;
    if (myFd == null)
        throw new IOException(""socket closed"");
    Int32Ref avail = new Int32Ref(0);
    try {
        Os.ioctlInt(myFd, OsConstants.FIONREAD, avail);
    } catch (ErrnoException e) {
        throw e.rethrowAsIOException();
    }
    return avail.value;
}",1,"/**
 * {@inheritDoc}
 */
","/**
 * {@inheritDoc}
 */
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"4,5",0,"The type used to capture the available bytes has changed from MutableInt to Int32Ref, marking an Other statement changed, type number 4. Also, since the constructor for Int32Ref takes an int as well, which is the same type passed to the MutableInt constructor previously, it's considered a Dependent API changed, type number 5.","There is no Compatibility Issue detected because the modification does not affect the behavior of the method in terms of its return value or the exceptions it might throw. The type used to hold the available bytes has been changed internally to a different class, but since both appear to be used in the same way (being containers for an integer value) and no behavior outside is evidently altered, no different return values or exceptions are expected by these changes alone."
14,"<android.provider.Settings.Secure: String getString(ContentResolver,String)>",27,28,"<android.provider.Settings.Secure: String getString(ContentResolver,String)>","<android.provider.Settings.Secure: String getString(ContentResolver,String)>",0,"{
    return getStringForUser(resolver, name, UserHandle.myUserId());
}","{
    return getStringForUser(resolver, name, resolver.getUserId());
}",1,"/**
 * Look up a name in the database.
 * @param resolver to access the database with
 * @param name to look up in the table
 * @return the corresponding value, or null if not present
 */
","/**
 * Look up a name in the database.
 * @param resolver to access the database with
 * @param name to look up in the table
 * @return the corresponding value, or null if not present
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"There is a change in a method call within the return statement from UserHandle.myUserId() to resolver.getUserId(), so the code change is of type 4 and 5 (Other statement changed, Dependent API changed).","There is no Compatibility Issue detected as the behavior of the API remains consistent across the change. The method still returns the same type of result, a string value associated with the provided name parameter. The underlying user ID is an implementation detail that should not affect the outward behavior of the method. It is fetching the same user-specific information, just using a different mechanism to determine the user ID."
15,<android.view.inputmethod.InputMethodManager: boolean shouldOfferSwitchingToNextInputMethod(IBinder)>,27,28,<android.view.inputmethod.InputMethodManager: boolean shouldOfferSwitchingToNextInputMethod(IBinder)>,<android.view.inputmethod.InputMethodManager: boolean shouldOfferSwitchingToNextInputMethod(IBinder)>,0,"{
    synchronized (mH) {
        try {
            return mService.shouldOfferSwitchingToNextInputMethod(imeToken);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }
}","{
    return shouldOfferSwitchingToNextInputMethodInternal(imeToken);
}",1,"/**
 * Returns true if the current IME needs to offer the users ways to switch to a next input
 * method (e.g. a globe key.).
 * When an IME sets supportsSwitchingToNextInputMethod and this method returns true,
 * the IME has to offer ways to to invoke {@link #switchToNextInputMethod} accordingly.
 * <p> Note that the system determines the most appropriate next input method
 * and subtype in order to provide the consistent user experience in switching
 * between IMEs and subtypes.
 * @param imeToken Supplies the identifying token given to an input method when it was started,
 * which allows it to perform this operation on itself.
 */
","/**
 * Returns true if the current IME needs to offer the users ways to switch to a next input
 * method (e.g. a globe key.).
 * When an IME sets supportsSwitchingToNextInputMethod and this method returns true,
 * the IME has to offer ways to to invoke {@link #switchToNextInputMethod} accordingly.
 * <p> Note that the system determines the most appropriate next input method
 * and subtype in order to provide the consistent user experience in switching
 * between IMEs and subtypes.
 * @param imeToken Supplies the identifying token given to an input method when it was started,
 * which allows it to perform this operation on itself.
 * @deprecated Use {@link InputMethodService#shouldOfferSwitchingToNextInputMethod()}
 * instead. This method was intended for IME developers who should be accessing APIs through
 * the service. APIs in this class are intended for app developers interacting with the IME.
 */
",-1,,[@Deprecated],-1,-1,-1,-1,-1,-1,5,0,"The implementation has changed to invoke a different method, shouldOfferSwitchingToNextInputMethodInternal(imeToken), instead of directly using mService.shouldOfferSwitchingToNextInputMethod(imeToken). This change indicates that the code change type is 5, due to the reliance on a different (presumably internal) API method.","There is no evidence based on the given information that the behavior of the API would differ; if shouldOfferSwitchingToNextInputMethodInternal(imeToken) is designed to maintain the same contract as the previous implementation, the API will behave the same from the caller's perspective. Hence, there is no detected Compatibility Issue. However, without knowing the implementation of shouldOfferSwitchingToNextInputMethodInternal, we cannot definitively know if the behavior is exactly the same."
16,<android.os.BatteryManager: int getIntProperty(int)>,27,28,<android.os.BatteryManager: int getIntProperty(int)>,<android.os.BatteryManager: int getIntProperty(int)>,0,"{
    return (int) queryProperty(id);
}","{
    long value = queryProperty(id);
    if (value == Long.MIN_VALUE && mContext != null && mContext.getApplicationInfo().targetSdkVersion >= android.os.Build.VERSION_CODES.P) {
        return Integer.MIN_VALUE;
    }
    return (int) value;
}",1,"/**
 * Return the value of a battery property of integer type.  If the
 * platform does not provide the property queried, this value will
 * be Integer.MIN_VALUE.
 *
 * @param id identifier of the requested property
 *
 * @return the property value, or Integer.MIN_VALUE if not supported.
 */
","/**
 * Return the value of a battery property of integer type.
 *
 * @param id identifier of the requested property
 *
 * @return the property value. If the property is not supported or there is any other error,
 * return (a) 0 if {@code targetSdkVersion < VERSION_CODES.P} or (b) Integer.MIN_VALUE
 * if {@code targetSdkVersion >= VERSION_CODES.P}.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3",1,"In the late version implementation, a new code block with an 'if' statement was introduced that checks the value returned from queryProperty(id) and compares it to Long.MIN_VALUE and also involves a check on the application's targetSdkVersion. Based on this check, there's the potential to return Integer.MIN_VALUE. This alters the previous simple typecasting from the early version to conditionally returning a different value. Hence, the change type includes 1 for the return statement and 3 for the control dependency change.","Due to the control dependency change, the API now potentially returns a different value, specifically Integer.MIN_VALUE, under certain conditions. This behavior would differ from the earlier version, which indiscriminately typecasted the queryProperty result to an int. Thus, there's a potential Compatibility Issue stemming from different return values, so the CI type is 1."
17,"<android.view.autofill.AutofillManager: void notifyValueChanged(View,int,AutofillValue)>",27,28,"<android.view.autofill.AutofillManager: void notifyValueChanged(View,int,AutofillValue)>","<android.view.autofill.AutofillManager: void notifyValueChanged(View,int,AutofillValue)>",0,"{
    if (!hasAutofillFeature()) {
        return;
    }
    synchronized (mLock) {
        if (!mEnabled || !isActiveLocked()) {
            return;
        }
        final AutofillId id = getAutofillId(view, virtualId);
        updateSessionLocked(id, null, value, ACTION_VALUE_CHANGED, 0);
    }
}","{
    if (!hasAutofillFeature()) {
        return;
    }
    synchronized (mLock) {
        if (!mEnabled || !isActiveLocked()) {
            if (sVerbose) {
                Log.v(TAG, ""notifyValueChanged("" + view.getAutofillId() + "":"" + virtualId + ""): ignoring on state "" + getStateAsStringLocked());
            }
            return;
        }
        final AutofillId id = getAutofillId(view, virtualId);
        updateSessionLocked(id, null, value, ACTION_VALUE_CHANGED, 0);
    }
}",1,"/**
 * Called to indicate the value of an autofillable virtual view has changed.
 *
 * @param view the virtual view parent.
 * @param virtualId id identifying the virtual child inside the parent view.
 * @param value new value of the child.
 */
","/**
 * Called to indicate the value of an autofillable virtual view has changed.
 *
 * @param view the virtual view parent.
 * @param virtualId id identifying the virtual child inside the parent view.
 * @param value new value of the child.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The modification involves adding a logging statement within a conditional block. This constitutes as an ""Other statement changed"" type, since it's not affecting return statements, exception handling, or control flow.","Because the added code only logs additional information and does not alter execution flow, return values, or exception handling, no compatibility issue arises from this change."
18,"<android.nfc.cardemulation.CardEmulation: boolean removeAidsForService(ComponentName,String)>",27,28,"<android.nfc.cardemulation.CardEmulation: boolean removeAidsForService(ComponentName,String)>","<android.nfc.cardemulation.CardEmulation: boolean removeAidsForService(ComponentName,String)>",0,"{
    try {
        return sService.removeAidGroupForService(UserHandle.myUserId(), service, category);
    } catch (RemoteException e) {
        // Try one more time
        recoverService();
        if (sService == null) {
            Log.e(TAG, ""Failed to recover CardEmulationService."");
            return false;
        }
        try {
            return sService.removeAidGroupForService(UserHandle.myUserId(), service, category);
        } catch (RemoteException ee) {
            Log.e(TAG, ""Failed to reach CardEmulationService."");
            return false;
        }
    }
}","{
    try {
        return sService.removeAidGroupForService(mContext.getUserId(), service, category);
    } catch (RemoteException e) {
        // Try one more time
        recoverService();
        if (sService == null) {
            Log.e(TAG, ""Failed to recover CardEmulationService."");
            return false;
        }
        try {
            return sService.removeAidGroupForService(mContext.getUserId(), service, category);
        } catch (RemoteException ee) {
            Log.e(TAG, ""Failed to reach CardEmulationService."");
            return false;
        }
    }
}",1,"/**
 * Removes a previously registered list of AIDs for the specified category for the
 * service provided.
 *
 * <p>Note that this will only remove AIDs that were dynamically
 * registered using the {@link #registerAidsForService(ComponentName, String, List)}
 * method. It will *not* remove AIDs that were statically registered in
 * the manifest. If dynamically registered AIDs are removed using
 * this method, and a statically registered AID group for the same category
 * exists in the manifest, the static AID group will become active again.
 *
 * @param service The component name of the service
 * @param category The category of the AIDs to be removed, e.g. {@link #CATEGORY_PAYMENT}
 * @return whether the group was successfully removed.
 */
","/**
 * Removes a previously registered list of AIDs for the specified category for the
 * service provided.
 *
 * <p>Note that this will only remove AIDs that were dynamically
 * registered using the {@link #registerAidsForService(ComponentName, String, List)}
 * method. It will *not* remove AIDs that were statically registered in
 * the manifest. If dynamically registered AIDs are removed using
 * this method, and a statically registered AID group for the same category
 * exists in the manifest, the static AID group will become active again.
 *
 * @param service The component name of the service
 * @param category The category of the AIDs to be removed, e.g. {@link #CATEGORY_PAYMENT}
 * @return whether the group was successfully removed.
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The method signature remains the same, but the way the user ID is obtained has changed from `UserHandle.myUserId()` to `mContext.getUserId()`. This is a call to a different method which is a change in the dependent API, so the code change type is 5.","Even though a different method is used to obtain the user ID, this change is internal and doesn't affect the behavior of the API visible to the caller. Both methods should return the same user ID for the context in which this method is called, so no Compatibility Issue is expected to arise from this change. Therefore, the CI type is 0."
19,<android.view.Surface: Canvas lockHardwareCanvas()>,27,28,<android.view.Surface: Canvas lockHardwareCanvas()>,<android.view.Surface: Canvas lockHardwareCanvas()>,0,"{
    synchronized (mLock) {
        checkNotReleasedLocked();
        if (mHwuiContext == null) {
            mHwuiContext = new HwuiContext();
        }
        return mHwuiContext.lockCanvas(nativeGetWidth(mNativeObject), nativeGetHeight(mNativeObject));
    }
}","{
    synchronized (mLock) {
        checkNotReleasedLocked();
        if (mHwuiContext == null) {
            mHwuiContext = new HwuiContext(false);
        }
        return mHwuiContext.lockCanvas(nativeGetWidth(mNativeObject), nativeGetHeight(mNativeObject));
    }
}",1,"/**
 * Gets a {@link Canvas} for drawing into this surface.
 *
 * After drawing into the provided {@link Canvas}, the caller must
 * invoke {@link #unlockCanvasAndPost} to post the new contents to the surface.
 *
 * Unlike {@link #lockCanvas(Rect)} this will return a hardware-accelerated
 * canvas. See the <a href=""{@docRoot}guide/topics/graphics/hardware-accel.html#unsupported"">
 * unsupported drawing operations</a> for a list of what is and isn't
 * supported in a hardware-accelerated canvas. It is also required to
 * fully cover the surface every time {@link #lockHardwareCanvas()} is
 * called as the buffer is not preserved between frames. Partial updates
 * are not supported.
 *
 * @return A canvas for drawing into the surface.
 *
 * @throws IllegalStateException If the canvas cannot be locked.
 */
","/**
 * Gets a {@link Canvas} for drawing into this surface.
 *
 * After drawing into the provided {@link Canvas}, the caller must
 * invoke {@link #unlockCanvasAndPost} to post the new contents to the surface.
 *
 * Unlike {@link #lockCanvas(Rect)} this will return a hardware-accelerated
 * canvas. See the <a href=""{@docRoot}guide/topics/graphics/hardware-accel.html#unsupported"">
 * unsupported drawing operations</a> for a list of what is and isn't
 * supported in a hardware-accelerated canvas. It is also required to
 * fully cover the surface every time {@link #lockHardwareCanvas()} is
 * called as the buffer is not preserved between frames. Partial updates
 * are not supported.
 *
 * @return A canvas for drawing into the surface.
 *
 * @throws IllegalStateException If the canvas cannot be locked.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"The code change includes the instantiation of 'HwuiContext' with different parameters: in the early version there's no argument, while in the late version it is instantiated with 'false' as an argument. This indicates a change in the implementation details of the HwuiContext constructor that the developer cannot see directly from this change. As such, it is considered as a change in other statement and dependent API.",There is no compatibility issue detected as the change appears to only affect the internal state of the 'HwuiContext' object without altering the return type nor the thrown exceptions of the API.
22,<android.app.Activity: void recreate()>,27,28,<android.app.Activity: void recreate()>,<android.app.Activity: void recreate()>,0,"{
    if (mParent != null) {
        throw new IllegalStateException(""Can only be called on top-level activity"");
    }
    if (Looper.myLooper() != mMainThread.getLooper()) {
        throw new IllegalStateException(""Must be called from main thread"");
    }
    try {
        ActivityManager.getService().requestActivityRelaunch(mToken);
    } catch (RemoteException e) {
    }
}","{
    if (mParent != null) {
        throw new IllegalStateException(""Can only be called on top-level activity"");
    }
    if (Looper.myLooper() != mMainThread.getLooper()) {
        throw new IllegalStateException(""Must be called from main thread"");
    }
    mMainThread.scheduleRelaunchActivity(mToken);
}",1,"/**
 * Cause this Activity to be recreated with a new instance.  This results
 * in essentially the same flow as when the Activity is created due to
 * a configuration change -- the current instance will go through its
 * lifecycle to {@link #onDestroy} and a new instance then created after it.
 */
","/**
 * Cause this Activity to be recreated with a new instance.  This results
 * in essentially the same flow as when the Activity is created due to
 * a configuration change -- the current instance will go through its
 * lifecycle to {@link #onDestroy} and a new instance then created after it.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,5",2,"The code change includes the removal of the try-catch block for the RemoteException and changes the called method from ActivityManager.getService().requestActivityRelaunch(mToken) to mMainThread.scheduleRelaunchActivity(mToken), hence, it involves both exception handling statement and dependent API changes, corresponding to types 2 and 5.","Since the method call inside the try block has changed from ActivityManager.getService().requestActivityRelaunch(mToken) to mMainThread.scheduleRelaunchActivity(mToken), and there is no longer a catch block for RemoteException, two potential compatibility issues could arise. First, there might be an unhandled RemoteException where previously there was a handling mechanism, which leads to a CI type 2. Second, the behavior could change depending on the internal implementation of the new method (mMainThread.scheduleRelaunchActivity(mToken)), also potentially causing a CI, but this is captured under type 2 because the new method may throw an exception that is not caught, changing the exception handling behavior."
23,<android.app.NotificationChannelGroup: boolean equals(Object)>,27,28,<android.app.NotificationChannelGroup: boolean equals(Object)>,<android.app.NotificationChannelGroup: boolean equals(Object)>,0,"{
    if (this == o)
        return true;
    if (o == null || getClass() != o.getClass())
        return false;
    NotificationChannelGroup that = (NotificationChannelGroup) o;
    if (getId() != null ? !getId().equals(that.getId()) : that.getId() != null)
        return false;
    if (getName() != null ? !getName().equals(that.getName()) : that.getName() != null) {
        return false;
    }
    return true;
}","{
    if (this == o)
        return true;
    if (o == null || getClass() != o.getClass())
        return false;
    NotificationChannelGroup that = (NotificationChannelGroup) o;
    if (isBlocked() != that.isBlocked())
        return false;
    if (getId() != null ? !getId().equals(that.getId()) : that.getId() != null)
        return false;
    if (getName() != null ? !getName().equals(that.getName()) : that.getName() != null) {
        return false;
    }
    if (getDescription() != null ? !getDescription().equals(that.getDescription()) : that.getDescription() != null) {
        return false;
    }
    return getChannels() != null ? getChannels().equals(that.getChannels()) : that.getChannels() == null;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,3,4",1,"The change involves adding new condition checks (isBlocked() and getDescription()) and adding the comparison of getChannels() in the late version. These are control dependency changes (3) and other statement changes (4), and there is a potential change in the return statement (1) because these new checks could lead to different return values.","The late version of API adds additional checks, potentially leading to a different return value due to the new logic for comparing isBlocked, getDescription, and getChannels. The late version of the API may return 'false' where the early version would have returned 'true', which is a CI caused by a potentially different return value (1)."
24,<android.view.autofill.AutofillManager: void cancel()>,27,28,<android.view.autofill.AutofillManager: void cancel()>,<android.view.autofill.AutofillManager: void cancel()>,0,"{
    if (!hasAutofillFeature()) {
        return;
    }
    synchronized (mLock) {
        if (!mEnabled && !isActiveLocked()) {
            return;
        }
        cancelSessionLocked();
    }
}","{
    if (sVerbose)
        Log.v(TAG, ""cancel() called by app"");
    if (!hasAutofillFeature()) {
        return;
    }
    synchronized (mLock) {
        cancelLocked();
    }
}",1,"/**
 * Called to indicate the current autofill context should be cancelled.
 *
 * <p>This method is typically called by {@link View Views} that manage virtual views; for
 * example, when the view is rendering an {@code HTML} page with a form and virtual views
 * that represent the HTML elements, it should call this method if the user does not post the
 * form but moves to another form in this page.
 *
 * <p><b>Note:</b> This method does not need to be called on regular application lifecycle
 * methods such as {@link android.app.Activity#finish()}.
 */
","/**
 * Called to indicate the current autofill context should be cancelled.
 *
 * <p>This method is typically called by {@link View Views} that manage virtual views; for
 * example, when the view is rendering an {@code HTML} page with a form and virtual views
 * that represent the HTML elements, it should call this method if the user does not post the
 * form but moves to another form in this page.
 *
 * <p><b>Note:</b> This method does not need to be called on regular application lifecycle
 * methods such as {@link android.app.Activity#finish()}.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",0,"The changes include: a new logging statement is introduced and the old check for `mEnabled` and `isActiveLocked()` has been removed. Also, the `cancelSessionLocked()` method call has been replaced with `cancelLocked()`. Therefore, the code change types are 3 (control dependency change due to removal of the `if` check) and 4 (other statement changed, the addition of a logging statement and the change of the method called within the synchronized block).","There is no Compatibility Issue because the method's signature and return type haven't changed, and the logging statement will not affect the output. The removal of the condition `if (!mEnabled && !isActiveLocked())` may change the internal behavior, but it does not manifest as a CI, because it does not affect the output of the method (`void` does not produce a value) nor introduces a new exception (the method is still completed normally). The change from `cancelSessionLocked()` to `cancelLocked()` is internal and is not evident in terms of compatibility unless `cancelLocked()` behaves differently than `cancelSessionLocked()` in terms of API output or exceptions, which is not indicated by the given information."
25,"<android.content.res.AssetManager: CharSequence getPooledStringForCookie(int,int)>",27,28,"<android.content.res.AssetManager: CharSequence getPooledStringForCookie(int,int)>","<android.content.res.AssetManager: CharSequence getPooledStringForCookie(int,int)>",0,"{
    synchronized (this) {
        // Cookies map to string blocks starting at 1.
        return mStringBlocks[cookie - 1].get(id);
    }
}","{
    // Cookies map to ApkAssets starting at 1.
    return getApkAssets()[cookie - 1].getStringFromPool(id);
}",1,"/*package*/
",,-1,,,-1,-1,-1,-1,-1,-1,"3, 5",1,"The implementation has changed from using a synchronized block and accessing ""mStringBlocks"" to not using synchronization and directly calling ""getApkAssets()[cookie - 1].getStringFromPool(id)"". This implicates a control dependency change by removing the synchronized block (3) and a change in the method from which the string is retrieved, indicating a dependent API change (5).","The removal of the synchronization construct and the use of a different method to retrieve the string could potentially lead to different return values depending on the state of the ""getApkAssets()"" as well as concurrency issues, as the earlier version was thread-safe due to the synchronized block. This introduces a potential Compatibility Issue with different return values, therefore, classifying it as type 1."
26,<android.service.autofill.FillResponse.Builder: Builder setClientState(Bundle)>,27,28,<android.service.autofill.FillResponse.Builder: Builder setClientState(Bundle)>,<android.service.autofill.FillResponse.Builder: Builder setClientState(Bundle)>,0,"{
    throwIfDestroyed();
    mCLientState = clientState;
    return this;
}","{
    throwIfDestroyed();
    throwIfDisableAutofillCalled();
    mClientState = clientState;
    return this;
}",1,"/**
 * Sets a {@link Bundle state} that will be passed to subsequent APIs that
 * manipulate this response. For example, they are passed to subsequent
 * calls to {@link AutofillService#onFillRequest(FillRequest, android.os.CancellationSignal,
 * FillCallback)} and {@link AutofillService#onSaveRequest(SaveRequest, SaveCallback)}.
 * You can use this to store intermediate state that is persistent across multiple
 * fill requests and the subsequent save request.
 *
 * <p>If this method is called on multiple {@link FillResponse} objects for the same
 * screen, just the latest bundle is passed back to the service.
 *
 * <p>Once a {@link AutofillService#onSaveRequest(SaveRequest, SaveCallback)
 * save request} is made the client state is cleared.
 *
 * @param clientState The custom client state.
 * @return This builder.
 */
","/**
 * Sets a bundle with state that is passed to subsequent APIs that manipulate this response.
 *
 * <p>You can use this bundle to store intermediate state that is passed to subsequent calls
 * to {@link AutofillService#onFillRequest(FillRequest, android.os.CancellationSignal,
 * FillCallback)} and {@link AutofillService#onSaveRequest(SaveRequest, SaveCallback)}, and
 * you can also retrieve it by calling {@link FillEventHistory.Event#getClientState()}.
 *
 * <p>If this method is called on multiple {@link FillResponse} objects for the same
 * screen, just the latest bundle is passed back to the service.
 *
 * @param clientState The custom client state.
 * @return This builder.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,2,"The late implementation introduces an additional throw statement, throwIfDisableAutofillCalled(), which is not present in the early implementation, so the code change type is 4.",The newly introduced throw statement could potentially result in a different exception being thrown when the setClientState(Bundle) method is called. This constitutes a CI of type 2 (Compatibility Issue caused by potential different exception handlings).
28,<android.app.Notification.MessagingStyle: CharSequence getUserDisplayName()>,27,28,<android.app.Notification.MessagingStyle: CharSequence getUserDisplayName()>,<android.app.Notification.MessagingStyle: CharSequence getUserDisplayName()>,0,"{
    return mUserDisplayName;
}","{
    return mUser.getName();
}",1,"/**
 * Returns the name to be displayed for any replies sent by the user
 */
","/**
 * Returns the name to be displayed for any replies sent by the user
 *
 * @deprecated use {@link #getUser()} instead
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The method itself has not changed, but the source of the returned value has changed from directly returning the mUserDisplayName member variable to calling the getName() method on the mUser object, indicating that a dependent API has changed. Therefore, the code change type is 1,5.","This code change could potentially return a different value since it now relies on the method getName() of mUser object rather than the direct member variable mUserDisplayName. If the getName() method's behavior is different from the direct access to mUserDisplayName, it could cause the API to return a different value. Hence, the CI type is 1."
29,<android.widget.TextView: boolean onTextContextMenuItem(int)>,27,28,<android.widget.TextView: boolean onTextContextMenuItem(int)>,<android.widget.TextView: boolean onTextContextMenuItem(int)>,0,"{
    int min = 0;
    int max = mText.length();
    if (isFocused()) {
        final int selStart = getSelectionStart();
        final int selEnd = getSelectionEnd();
        min = Math.max(0, Math.min(selStart, selEnd));
        max = Math.max(0, Math.max(selStart, selEnd));
    }
    switch(id) {
        case ID_SELECT_ALL:
            final boolean hadSelection = hasSelection();
            selectAllText();
            if (mEditor != null && hadSelection) {
                mEditor.invalidateActionModeAsync();
            }
            return true;
        case ID_UNDO:
            if (mEditor != null) {
                mEditor.undo();
            }
            // Returns true even if nothing was undone.
            return true;
        case ID_REDO:
            if (mEditor != null) {
                mEditor.redo();
            }
            // Returns true even if nothing was undone.
            return true;
        case ID_PASTE:
            paste(min, max, true);
            return true;
        case ID_PASTE_AS_PLAIN_TEXT:
            paste(min, max, false);
            return true;
        case ID_CUT:
            setPrimaryClip(ClipData.newPlainText(null, getTransformedText(min, max)));
            deleteText_internal(min, max);
            return true;
        case ID_COPY:
            setPrimaryClip(ClipData.newPlainText(null, getTransformedText(min, max)));
            stopTextActionMode();
            return true;
        case ID_REPLACE:
            if (mEditor != null) {
                mEditor.replace();
            }
            return true;
        case ID_SHARE:
            shareSelectedText();
            return true;
        case ID_AUTOFILL:
            requestAutofill();
            stopTextActionMode();
            return true;
    }
    return false;
}","{
    int min = 0;
    int max = mText.length();
    if (isFocused()) {
        final int selStart = getSelectionStart();
        final int selEnd = getSelectionEnd();
        min = Math.max(0, Math.min(selStart, selEnd));
        max = Math.max(0, Math.max(selStart, selEnd));
    }
    switch(id) {
        case ID_SELECT_ALL:
            final boolean hadSelection = hasSelection();
            selectAllText();
            if (mEditor != null && hadSelection) {
                mEditor.invalidateActionModeAsync();
            }
            return true;
        case ID_UNDO:
            if (mEditor != null) {
                mEditor.undo();
            }
            // Returns true even if nothing was undone.
            return true;
        case ID_REDO:
            if (mEditor != null) {
                mEditor.redo();
            }
            // Returns true even if nothing was undone.
            return true;
        case ID_PASTE:
            paste(min, max, true);
            return true;
        case ID_PASTE_AS_PLAIN_TEXT:
            paste(min, max, false);
            return true;
        case ID_CUT:
            final ClipData cutData = ClipData.newPlainText(null, getTransformedText(min, max));
            if (setPrimaryClip(cutData)) {
                deleteText_internal(min, max);
            } else {
                Toast.makeText(getContext(), com.android.internal.R.string.failed_to_copy_to_clipboard, Toast.LENGTH_SHORT).show();
            }
            return true;
        case ID_COPY:
            // For link action mode in a non-selectable/non-focusable TextView,
            // make sure that we set the appropriate min/max.
            final int selStart = getSelectionStart();
            final int selEnd = getSelectionEnd();
            min = Math.max(0, Math.min(selStart, selEnd));
            max = Math.max(0, Math.max(selStart, selEnd));
            final ClipData copyData = ClipData.newPlainText(null, getTransformedText(min, max));
            if (setPrimaryClip(copyData)) {
                stopTextActionMode();
            } else {
                Toast.makeText(getContext(), com.android.internal.R.string.failed_to_copy_to_clipboard, Toast.LENGTH_SHORT).show();
            }
            return true;
        case ID_REPLACE:
            if (mEditor != null) {
                mEditor.replace();
            }
            return true;
        case ID_SHARE:
            shareSelectedText();
            return true;
        case ID_AUTOFILL:
            requestAutofill();
            stopTextActionMode();
            return true;
    }
    return false;
}",1,"/**
 * Called when a context menu option for the text view is selected.  Currently
 * this will be one of {@link android.R.id#selectAll}, {@link android.R.id#cut},
 * {@link android.R.id#copy}, {@link android.R.id#paste} or {@link android.R.id#shareText}.
 *
 * @return true if the context menu item action was performed.
 */
","/**
 * Called when a context menu option for the text view is selected.  Currently
 * this will be one of {@link android.R.id#selectAll}, {@link android.R.id#cut},
 * {@link android.R.id#copy}, {@link android.R.id#paste} or {@link android.R.id#shareText}.
 *
 * @return true if the context menu item action was performed.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3,4",1,The implementation has multiple changes: ,"- In the case ID_COPY, new local variables `selStart` and `selEnd` were added, a new conditional check for setPrimaryClip, and a new Toast message. This could potentially lead to a different return value if the setPrimaryClip method fails, as the previous version did not handle this scenario."
32,<android.content.ContentResolver: SyncAdapterType[] getSyncAdapterTypes()>,27,28,<android.content.ContentResolver: SyncAdapterType[] getSyncAdapterTypes()>,<android.content.ContentResolver: SyncAdapterType[] getSyncAdapterTypes()>,0,"{
    try {
        return getContentService().getSyncAdapterTypes();
    } catch (RemoteException e) {
        throw new RuntimeException(""the ContentService should always be reachable"", e);
    }
}","{
    try {
        return getContentService().getSyncAdapterTypes();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Get information about the SyncAdapters that are known to the system.
 * @return an array of SyncAdapters that have registered with the system
 */
","/**
 * Get information about the SyncAdapters that are known to the system.
 * @return an array of SyncAdapters that have registered with the system
 */
",-1,,,-1,-1,-1,-1,-1,-1,2,2,"The exception handling statement has changed from throwing a RuntimeException to throwing the exception from the system server with e.rethrowFromSystemServer(), so the code change type is 2.","The change in the exception handling may lead to a different type of exception being thrown when a RemoteException occurs, causing a potential compatibility issue with exception handling, and the CI type is 2."
33,"<android.provider.Settings.Global: String getString(ContentResolver,String)>",27,28,"<android.provider.Settings.Global: String getString(ContentResolver,String)>","<android.provider.Settings.Global: String getString(ContentResolver,String)>",0,"{
    return getStringForUser(resolver, name, UserHandle.myUserId());
}","{
    return getStringForUser(resolver, name, resolver.getUserId());
}",1,"/**
 * Look up a name in the database.
 * @param resolver to access the database with
 * @param name to look up in the table
 * @return the corresponding value, or null if not present
 */
","/**
 * Look up a name in the database.
 * @param resolver to access the database with
 * @param name to look up in the table
 * @return the corresponding value, or null if not present
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,1,"The code change consists of replacing UserHandle.myUserId() with resolver.getUserId() in the getStringForUser() method call, which is a change in the dependent API, so the change type is 5.","The change in how the user ID is retrieved (from UserHandle.myUserId() to resolver.getUserId()) potentially leads to a situation where the method may return different values for the same input parameters in different user contexts, which would be a compatibility issue of type 1."
35,"<android.bluetooth.BluetoothGatt: boolean connect(Boolean,BluetoothGattCallback,Handler)>",27,28,"<android.bluetooth.BluetoothGatt: boolean connect(Boolean,BluetoothGattCallback,Handler)>","<android.bluetooth.BluetoothGatt: boolean connect(Boolean,BluetoothGattCallback,Handler)>",0,"{
    if (DBG)
        Log.d(TAG, ""connect() - device: "" + mDevice.getAddress() + "", auto: "" + autoConnect);
    synchronized (mStateLock) {
        if (mConnState != CONN_STATE_IDLE) {
            throw new IllegalStateException(""Not idle"");
        }
        mConnState = CONN_STATE_CONNECTING;
    }
    mAutoConnect = autoConnect;
    if (!registerApp(callback, handler)) {
        synchronized (mStateLock) {
            mConnState = CONN_STATE_IDLE;
        }
        Log.e(TAG, ""Failed to register callback"");
        return false;
    }
    // The connection will continue in the onClientRegistered callback
    return true;
}","{
    if (DBG) {
        Log.d(TAG, ""connect() - device: "" + mDevice.getAddress() + "", auto: "" + autoConnect);
    }
    synchronized (mStateLock) {
        if (mConnState != CONN_STATE_IDLE) {
            throw new IllegalStateException(""Not idle"");
        }
        mConnState = CONN_STATE_CONNECTING;
    }
    mAutoConnect = autoConnect;
    if (!registerApp(callback, handler)) {
        synchronized (mStateLock) {
            mConnState = CONN_STATE_IDLE;
        }
        Log.e(TAG, ""Failed to register callback"");
        return false;
    }
    // The connection will continue in the onClientRegistered callback
    return true;
}",1,"/*package*/
","/*package*/
",-1,,,-1,-1,-1,-1,-1,-1,0,0,"The implementation of the method did not change, only some stylistic formatting was modified with the placement of braces.","As there are no actual changes to the behavior or logic of the code, there is no Compatibility Issue between the two versions."
36,"<android.text.StaticLayout: void generate(Builder,boolean,boolean)>",27,28,"<android.text.StaticLayout: void generate(Builder,boolean,boolean)>","<android.text.StaticLayout: void generate(Builder,boolean,boolean)>",0,"{
    CharSequence source = b.mText;
    int bufStart = b.mStart;
    int bufEnd = b.mEnd;
    TextPaint paint = b.mPaint;
    int outerWidth = b.mWidth;
    TextDirectionHeuristic textDir = b.mTextDir;
    float spacingmult = b.mSpacingMult;
    float spacingadd = b.mSpacingAdd;
    float ellipsizedWidth = b.mEllipsizedWidth;
    TextUtils.TruncateAt ellipsize = b.mEllipsize;
    // TODO: move to builder to avoid allocation costs
    LineBreaks lineBreaks = new LineBreaks();
    // store span end locations
    int[] spanEndCache = new int[4];
    // store fontMetrics per span range
    // must be a multiple of 4 (and > 0) (store top, bottom, ascent, and descent per range)
    int[] fmCache = new int[4 * 4];
    b.setLocales(paint.getTextLocales());
    mLineCount = 0;
    mEllipsized = false;
    mMaxLineHeight = mMaximumVisibleLineCount < 1 ? 0 : DEFAULT_MAX_LINE_HEIGHT;
    int v = 0;
    boolean needMultiply = (spacingmult != 1 || spacingadd != 0);
    Paint.FontMetricsInt fm = b.mFontMetricsInt;
    int[] chooseHtv = null;
    MeasuredText measured = b.mMeasuredText;
    Spanned spanned = null;
    if (source instanceof Spanned)
        spanned = (Spanned) source;
    int paraEnd;
    for (int paraStart = bufStart; paraStart <= bufEnd; paraStart = paraEnd) {
        paraEnd = TextUtils.indexOf(source, CHAR_NEW_LINE, paraStart, bufEnd);
        if (paraEnd < 0)
            paraEnd = bufEnd;
        else
            paraEnd++;
        int firstWidthLineCount = 1;
        int firstWidth = outerWidth;
        int restWidth = outerWidth;
        LineHeightSpan[] chooseHt = null;
        if (spanned != null) {
            LeadingMarginSpan[] sp = getParagraphSpans(spanned, paraStart, paraEnd, LeadingMarginSpan.class);
            for (int i = 0; i < sp.length; i++) {
                LeadingMarginSpan lms = sp[i];
                firstWidth -= sp[i].getLeadingMargin(true);
                restWidth -= sp[i].getLeadingMargin(false);
                // leading margin spans, not just this particular one
                if (lms instanceof LeadingMarginSpan2) {
                    LeadingMarginSpan2 lms2 = (LeadingMarginSpan2) lms;
                    firstWidthLineCount = Math.max(firstWidthLineCount, lms2.getLeadingMarginLineCount());
                }
            }
            chooseHt = getParagraphSpans(spanned, paraStart, paraEnd, LineHeightSpan.class);
            if (chooseHt.length == 0) {
                // So that out() would not assume it has any contents
                chooseHt = null;
            } else {
                if (chooseHtv == null || chooseHtv.length < chooseHt.length) {
                    chooseHtv = ArrayUtils.newUnpaddedIntArray(chooseHt.length);
                }
                for (int i = 0; i < chooseHt.length; i++) {
                    int o = spanned.getSpanStart(chooseHt[i]);
                    if (o < paraStart) {
                        // starts in this layout, before the
                        // current paragraph
                        chooseHtv[i] = getLineTop(getLineForOffset(o));
                    } else {
                        // starts in this paragraph
                        chooseHtv[i] = v;
                    }
                }
            }
        }
        measured.setPara(source, paraStart, paraEnd, textDir, b);
        char[] chs = measured.mChars;
        float[] widths = measured.mWidths;
        byte[] chdirs = measured.mLevels;
        int dir = measured.mDir;
        boolean easy = measured.mEasy;
        // tab stop locations
        int[] variableTabStops = null;
        if (spanned != null) {
            TabStopSpan[] spans = getParagraphSpans(spanned, paraStart, paraEnd, TabStopSpan.class);
            if (spans.length > 0) {
                int[] stops = new int[spans.length];
                for (int i = 0; i < spans.length; i++) {
                    stops[i] = spans[i].getTabStop();
                }
                Arrays.sort(stops, 0, stops.length);
                variableTabStops = stops;
            }
        }
        nSetupParagraph(b.mNativePtr, chs, paraEnd - paraStart, firstWidth, firstWidthLineCount, restWidth, variableTabStops, TAB_INCREMENT, b.mBreakStrategy, b.mHyphenationFrequency, // TODO: Support more justification mode, e.g. letter spacing, stretching.
        b.mJustificationMode != Layout.JUSTIFICATION_MODE_NONE);
        if (mLeftIndents != null || mRightIndents != null) {
            // TODO(raph) performance: it would be better to do this once per layout rather
            // than once per paragraph, but that would require a change to the native
            // interface.
            int leftLen = mLeftIndents == null ? 0 : mLeftIndents.length;
            int rightLen = mRightIndents == null ? 0 : mRightIndents.length;
            int indentsLen = Math.max(1, Math.max(leftLen, rightLen) - mLineCount);
            int[] indents = new int[indentsLen];
            for (int i = 0; i < indentsLen; i++) {
                int leftMargin = mLeftIndents == null ? 0 : mLeftIndents[Math.min(i + mLineCount, leftLen - 1)];
                int rightMargin = mRightIndents == null ? 0 : mRightIndents[Math.min(i + mLineCount, rightLen - 1)];
                indents[i] = leftMargin + rightMargin;
            }
            nSetIndents(b.mNativePtr, indents);
        }
        // measurement has to be done before performing line breaking
        // but we don't want to recompute fontmetrics or span ranges the
        // second time, so we cache those and then use those stored values
        int fmCacheCount = 0;
        int spanEndCacheCount = 0;
        for (int spanStart = paraStart, spanEnd; spanStart < paraEnd; spanStart = spanEnd) {
            if (fmCacheCount * 4 >= fmCache.length) {
                int[] grow = new int[fmCacheCount * 4 * 2];
                System.arraycopy(fmCache, 0, grow, 0, fmCacheCount * 4);
                fmCache = grow;
            }
            if (spanEndCacheCount >= spanEndCache.length) {
                int[] grow = new int[spanEndCacheCount * 2];
                System.arraycopy(spanEndCache, 0, grow, 0, spanEndCacheCount);
                spanEndCache = grow;
            }
            if (spanned == null) {
                spanEnd = paraEnd;
                int spanLen = spanEnd - spanStart;
                measured.addStyleRun(paint, spanLen, fm);
            } else {
                spanEnd = spanned.nextSpanTransition(spanStart, paraEnd, MetricAffectingSpan.class);
                int spanLen = spanEnd - spanStart;
                MetricAffectingSpan[] spans = spanned.getSpans(spanStart, spanEnd, MetricAffectingSpan.class);
                spans = TextUtils.removeEmptySpans(spans, spanned, MetricAffectingSpan.class);
                measured.addStyleRun(paint, spans, spanLen, fm);
            }
            // the order of storage here (top, bottom, ascent, descent) has to match the code below
            // where these values are retrieved
            fmCache[fmCacheCount * 4 + 0] = fm.top;
            fmCache[fmCacheCount * 4 + 1] = fm.bottom;
            fmCache[fmCacheCount * 4 + 2] = fm.ascent;
            fmCache[fmCacheCount * 4 + 3] = fm.descent;
            fmCacheCount++;
            spanEndCache[spanEndCacheCount] = spanEnd;
            spanEndCacheCount++;
        }
        nGetWidths(b.mNativePtr, widths);
        int breakCount = nComputeLineBreaks(b.mNativePtr, lineBreaks, lineBreaks.breaks, lineBreaks.widths, lineBreaks.flags, lineBreaks.breaks.length);
        int[] breaks = lineBreaks.breaks;
        float[] lineWidths = lineBreaks.widths;
        int[] flags = lineBreaks.flags;
        final int remainingLineCount = mMaximumVisibleLineCount - mLineCount;
        final boolean ellipsisMayBeApplied = ellipsize != null && (ellipsize == TextUtils.TruncateAt.END || (mMaximumVisibleLineCount == 1 && ellipsize != TextUtils.TruncateAt.MARQUEE));
        if (remainingLineCount > 0 && remainingLineCount < breakCount && ellipsisMayBeApplied) {
            // Calculate width and flag.
            float width = 0;
            int flag = 0;
            for (int i = remainingLineCount - 1; i < breakCount; i++) {
                if (i == breakCount - 1) {
                    width += lineWidths[i];
                } else {
                    for (int j = (i == 0 ? 0 : breaks[i - 1]); j < breaks[i]; j++) {
                        width += widths[j];
                    }
                }
                flag |= flags[i] & TAB_MASK;
            }
            // Treat the last line and overflowed lines as a single line.
            breaks[remainingLineCount - 1] = breaks[breakCount - 1];
            lineWidths[remainingLineCount - 1] = width;
            flags[remainingLineCount - 1] = flag;
            breakCount = remainingLineCount;
        }
        // here is the offset of the starting character of the line we are currently measuring
        int here = paraStart;
        int fmTop = 0, fmBottom = 0, fmAscent = 0, fmDescent = 0;
        int fmCacheIndex = 0;
        int spanEndCacheIndex = 0;
        int breakIndex = 0;
        for (int spanStart = paraStart, spanEnd; spanStart < paraEnd; spanStart = spanEnd) {
            // retrieve end of span
            spanEnd = spanEndCache[spanEndCacheIndex++];
            // retrieve cached metrics, order matches above
            fm.top = fmCache[fmCacheIndex * 4 + 0];
            fm.bottom = fmCache[fmCacheIndex * 4 + 1];
            fm.ascent = fmCache[fmCacheIndex * 4 + 2];
            fm.descent = fmCache[fmCacheIndex * 4 + 3];
            fmCacheIndex++;
            if (fm.top < fmTop) {
                fmTop = fm.top;
            }
            if (fm.ascent < fmAscent) {
                fmAscent = fm.ascent;
            }
            if (fm.descent > fmDescent) {
                fmDescent = fm.descent;
            }
            if (fm.bottom > fmBottom) {
                fmBottom = fm.bottom;
            }
            // skip breaks ending before current span range
            while (breakIndex < breakCount && paraStart + breaks[breakIndex] < spanStart) {
                breakIndex++;
            }
            while (breakIndex < breakCount && paraStart + breaks[breakIndex] <= spanEnd) {
                int endPos = paraStart + breaks[breakIndex];
                boolean moreChars = (endPos < bufEnd);
                v = out(source, here, endPos, fmAscent, fmDescent, fmTop, fmBottom, v, spacingmult, spacingadd, chooseHt, chooseHtv, fm, flags[breakIndex], needMultiply, chdirs, dir, easy, bufEnd, includepad, trackpad, chs, widths, paraStart, ellipsize, ellipsizedWidth, lineWidths[breakIndex], paint, moreChars);
                if (endPos < spanEnd) {
                    // preserve metrics for current span
                    fmTop = fm.top;
                    fmBottom = fm.bottom;
                    fmAscent = fm.ascent;
                    fmDescent = fm.descent;
                } else {
                    fmTop = fmBottom = fmAscent = fmDescent = 0;
                }
                here = endPos;
                breakIndex++;
                if (mLineCount >= mMaximumVisibleLineCount && mEllipsized) {
                    return;
                }
            }
        }
        if (paraEnd == bufEnd)
            break;
    }
    if ((bufEnd == bufStart || source.charAt(bufEnd - 1) == CHAR_NEW_LINE) && mLineCount < mMaximumVisibleLineCount) {
        // Log.e(""text"", ""output last "" + bufEnd);
        measured.setPara(source, bufEnd, bufEnd, textDir, b);
        paint.getFontMetricsInt(fm);
        v = out(source, bufEnd, bufEnd, fm.ascent, fm.descent, fm.top, fm.bottom, v, spacingmult, spacingadd, null, null, fm, 0, needMultiply, measured.mLevels, measured.mDir, measured.mEasy, bufEnd, includepad, trackpad, null, null, bufStart, ellipsize, ellipsizedWidth, 0, paint, false);
    }
}","{
    final CharSequence source = b.mText;
    final int bufStart = b.mStart;
    final int bufEnd = b.mEnd;
    TextPaint paint = b.mPaint;
    int outerWidth = b.mWidth;
    TextDirectionHeuristic textDir = b.mTextDir;
    final boolean fallbackLineSpacing = b.mFallbackLineSpacing;
    float spacingmult = b.mSpacingMult;
    float spacingadd = b.mSpacingAdd;
    float ellipsizedWidth = b.mEllipsizedWidth;
    TextUtils.TruncateAt ellipsize = b.mEllipsize;
    final boolean addLastLineSpacing = b.mAddLastLineLineSpacing;
    // TODO: move to builder to avoid allocation costs
    LineBreaks lineBreaks = new LineBreaks();
    FloatArray widths = new FloatArray();
    mLineCount = 0;
    mEllipsized = false;
    mMaxLineHeight = mMaximumVisibleLineCount < 1 ? 0 : DEFAULT_MAX_LINE_HEIGHT;
    int v = 0;
    boolean needMultiply = (spacingmult != 1 || spacingadd != 0);
    Paint.FontMetricsInt fm = b.mFontMetricsInt;
    int[] chooseHtv = null;
    final int[] indents;
    if (mLeftIndents != null || mRightIndents != null) {
        final int leftLen = mLeftIndents == null ? 0 : mLeftIndents.length;
        final int rightLen = mRightIndents == null ? 0 : mRightIndents.length;
        final int indentsLen = Math.max(leftLen, rightLen);
        indents = new int[indentsLen];
        for (int i = 0; i < leftLen; i++) {
            indents[i] = mLeftIndents[i];
        }
        for (int i = 0; i < rightLen; i++) {
            indents[i] += mRightIndents[i];
        }
    } else {
        indents = null;
    }
    final long nativePtr = nInit(b.mBreakStrategy, b.mHyphenationFrequency, // TODO: Support more justification mode, e.g. letter spacing, stretching.
    b.mJustificationMode != Layout.JUSTIFICATION_MODE_NONE, indents, mLeftPaddings, mRightPaddings);
    PrecomputedText.ParagraphInfo[] paragraphInfo = null;
    final Spanned spanned = (source instanceof Spanned) ? (Spanned) source : null;
    if (source instanceof PrecomputedText) {
        PrecomputedText precomputed = (PrecomputedText) source;
        if (precomputed.canUseMeasuredResult(bufStart, bufEnd, textDir, paint, b.mBreakStrategy, b.mHyphenationFrequency)) {
            // Some parameters are different from the ones when measured text is created.
            paragraphInfo = precomputed.getParagraphInfo();
        }
    }
    if (paragraphInfo == null) {
        final PrecomputedText.Params param = new PrecomputedText.Params(paint, textDir, b.mBreakStrategy, b.mHyphenationFrequency);
        paragraphInfo = PrecomputedText.createMeasuredParagraphs(source, param, bufStart, bufEnd, false);
    }
    try {
        for (int paraIndex = 0; paraIndex < paragraphInfo.length; paraIndex++) {
            final int paraStart = paraIndex == 0 ? bufStart : paragraphInfo[paraIndex - 1].paragraphEnd;
            final int paraEnd = paragraphInfo[paraIndex].paragraphEnd;
            int firstWidthLineCount = 1;
            int firstWidth = outerWidth;
            int restWidth = outerWidth;
            LineHeightSpan[] chooseHt = null;
            if (spanned != null) {
                LeadingMarginSpan[] sp = getParagraphSpans(spanned, paraStart, paraEnd, LeadingMarginSpan.class);
                for (int i = 0; i < sp.length; i++) {
                    LeadingMarginSpan lms = sp[i];
                    firstWidth -= sp[i].getLeadingMargin(true);
                    restWidth -= sp[i].getLeadingMargin(false);
                    // leading margin spans, not just this particular one
                    if (lms instanceof LeadingMarginSpan2) {
                        LeadingMarginSpan2 lms2 = (LeadingMarginSpan2) lms;
                        firstWidthLineCount = Math.max(firstWidthLineCount, lms2.getLeadingMarginLineCount());
                    }
                }
                chooseHt = getParagraphSpans(spanned, paraStart, paraEnd, LineHeightSpan.class);
                if (chooseHt.length == 0) {
                    // So that out() would not assume it has any contents
                    chooseHt = null;
                } else {
                    if (chooseHtv == null || chooseHtv.length < chooseHt.length) {
                        chooseHtv = ArrayUtils.newUnpaddedIntArray(chooseHt.length);
                    }
                    for (int i = 0; i < chooseHt.length; i++) {
                        int o = spanned.getSpanStart(chooseHt[i]);
                        if (o < paraStart) {
                            // starts in this layout, before the
                            // current paragraph
                            chooseHtv[i] = getLineTop(getLineForOffset(o));
                        } else {
                            // starts in this paragraph
                            chooseHtv[i] = v;
                        }
                    }
                }
            }
            // tab stop locations
            int[] variableTabStops = null;
            if (spanned != null) {
                TabStopSpan[] spans = getParagraphSpans(spanned, paraStart, paraEnd, TabStopSpan.class);
                if (spans.length > 0) {
                    int[] stops = new int[spans.length];
                    for (int i = 0; i < spans.length; i++) {
                        stops[i] = spans[i].getTabStop();
                    }
                    Arrays.sort(stops, 0, stops.length);
                    variableTabStops = stops;
                }
            }
            final MeasuredParagraph measuredPara = paragraphInfo[paraIndex].measured;
            final char[] chs = measuredPara.getChars();
            final int[] spanEndCache = measuredPara.getSpanEndCache().getRawArray();
            final int[] fmCache = measuredPara.getFontMetrics().getRawArray();
            // TODO: Stop keeping duplicated width copy in native and Java.
            widths.resize(chs.length);
            // measurement has to be done before performing line breaking
            // but we don't want to recompute fontmetrics or span ranges the
            // second time, so we cache those and then use those stored values
            int breakCount = nComputeLineBreaks(nativePtr, // Inputs
            chs, measuredPara.getNativePtr(), paraEnd - paraStart, firstWidth, firstWidthLineCount, restWidth, variableTabStops, TAB_INCREMENT, mLineCount, // Outputs
            lineBreaks, lineBreaks.breaks.length, lineBreaks.breaks, lineBreaks.widths, lineBreaks.ascents, lineBreaks.descents, lineBreaks.flags, widths.getRawArray());
            final int[] breaks = lineBreaks.breaks;
            final float[] lineWidths = lineBreaks.widths;
            final float[] ascents = lineBreaks.ascents;
            final float[] descents = lineBreaks.descents;
            final int[] flags = lineBreaks.flags;
            final int remainingLineCount = mMaximumVisibleLineCount - mLineCount;
            final boolean ellipsisMayBeApplied = ellipsize != null && (ellipsize == TextUtils.TruncateAt.END || (mMaximumVisibleLineCount == 1 && ellipsize != TextUtils.TruncateAt.MARQUEE));
            if (0 < remainingLineCount && remainingLineCount < breakCount && ellipsisMayBeApplied) {
                // Calculate width and flag.
                float width = 0;
                // XXX May need to also have starting hyphen edit
                int flag = 0;
                for (int i = remainingLineCount - 1; i < breakCount; i++) {
                    if (i == breakCount - 1) {
                        width += lineWidths[i];
                    } else {
                        for (int j = (i == 0 ? 0 : breaks[i - 1]); j < breaks[i]; j++) {
                            width += widths.get(j);
                        }
                    }
                    flag |= flags[i] & TAB_MASK;
                }
                // Treat the last line and overflowed lines as a single line.
                breaks[remainingLineCount - 1] = breaks[breakCount - 1];
                lineWidths[remainingLineCount - 1] = width;
                flags[remainingLineCount - 1] = flag;
                breakCount = remainingLineCount;
            }
            // here is the offset of the starting character of the line we are currently
            // measuring
            int here = paraStart;
            int fmTop = 0, fmBottom = 0, fmAscent = 0, fmDescent = 0;
            int fmCacheIndex = 0;
            int spanEndCacheIndex = 0;
            int breakIndex = 0;
            for (int spanStart = paraStart, spanEnd; spanStart < paraEnd; spanStart = spanEnd) {
                // retrieve end of span
                spanEnd = spanEndCache[spanEndCacheIndex++];
                // retrieve cached metrics, order matches above
                fm.top = fmCache[fmCacheIndex * 4 + 0];
                fm.bottom = fmCache[fmCacheIndex * 4 + 1];
                fm.ascent = fmCache[fmCacheIndex * 4 + 2];
                fm.descent = fmCache[fmCacheIndex * 4 + 3];
                fmCacheIndex++;
                if (fm.top < fmTop) {
                    fmTop = fm.top;
                }
                if (fm.ascent < fmAscent) {
                    fmAscent = fm.ascent;
                }
                if (fm.descent > fmDescent) {
                    fmDescent = fm.descent;
                }
                if (fm.bottom > fmBottom) {
                    fmBottom = fm.bottom;
                }
                // skip breaks ending before current span range
                while (breakIndex < breakCount && paraStart + breaks[breakIndex] < spanStart) {
                    breakIndex++;
                }
                while (breakIndex < breakCount && paraStart + breaks[breakIndex] <= spanEnd) {
                    int endPos = paraStart + breaks[breakIndex];
                    boolean moreChars = (endPos < bufEnd);
                    final int ascent = fallbackLineSpacing ? Math.min(fmAscent, Math.round(ascents[breakIndex])) : fmAscent;
                    final int descent = fallbackLineSpacing ? Math.max(fmDescent, Math.round(descents[breakIndex])) : fmDescent;
                    v = out(source, here, endPos, ascent, descent, fmTop, fmBottom, v, spacingmult, spacingadd, chooseHt, chooseHtv, fm, flags[breakIndex], needMultiply, measuredPara, bufEnd, includepad, trackpad, addLastLineSpacing, chs, widths.getRawArray(), paraStart, ellipsize, ellipsizedWidth, lineWidths[breakIndex], paint, moreChars);
                    if (endPos < spanEnd) {
                        // preserve metrics for current span
                        fmTop = fm.top;
                        fmBottom = fm.bottom;
                        fmAscent = fm.ascent;
                        fmDescent = fm.descent;
                    } else {
                        fmTop = fmBottom = fmAscent = fmDescent = 0;
                    }
                    here = endPos;
                    breakIndex++;
                    if (mLineCount >= mMaximumVisibleLineCount && mEllipsized) {
                        return;
                    }
                }
            }
            if (paraEnd == bufEnd) {
                break;
            }
        }
        if ((bufEnd == bufStart || source.charAt(bufEnd - 1) == CHAR_NEW_LINE) && mLineCount < mMaximumVisibleLineCount) {
            final MeasuredParagraph measuredPara = MeasuredParagraph.buildForBidi(source, bufEnd, bufEnd, textDir, null);
            paint.getFontMetricsInt(fm);
            v = out(source, bufEnd, bufEnd, fm.ascent, fm.descent, fm.top, fm.bottom, v, spacingmult, spacingadd, null, null, fm, 0, needMultiply, measuredPara, bufEnd, includepad, trackpad, addLastLineSpacing, null, null, bufStart, ellipsize, ellipsizedWidth, 0, paint, false);
        }
    } finally {
        nFinish(nativePtr);
    }
}",1,"/* package */
","/* package */
",-1,,,-1,-1,-1,-1,-1,-1,,,,
37,"<android.content.ContentResolver: boolean getSyncAutomatically(Account,String)>",27,28,"<android.content.ContentResolver: boolean getSyncAutomatically(Account,String)>","<android.content.ContentResolver: boolean getSyncAutomatically(Account,String)>",0,"{
    try {
        return getContentService().getSyncAutomatically(account, authority);
    } catch (RemoteException e) {
        throw new RuntimeException(""the ContentService should always be reachable"", e);
    }
}","{
    try {
        return getContentService().getSyncAutomatically(account, authority);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Check if the provider should be synced when a network tickle is received
 * <p>This method requires the caller to hold the permission
 * {@link android.Manifest.permission#READ_SYNC_SETTINGS}.
 *
 * @param account the account whose setting we are querying
 * @param authority the provider whose setting we are querying
 * @return true if the provider should be synced when a network tickle is received
 */
","/**
 * Check if the provider should be synced when a network tickle is received
 * <p>This method requires the caller to hold the permission
 * {@link android.Manifest.permission#READ_SYNC_SETTINGS}.
 *
 * @param account the account whose setting we are querying
 * @param authority the provider whose setting we are querying
 * @return true if the provider should be synced when a network tickle is received
 */
",-1,,,-1,-1,-1,-1,-1,-1,2,2,"The exception handling statement has changed from throwing a new RuntimeException to throwing the result of e.rethrowFromSystemServer(), so the change type is 2.","As the method of exception handling has been altered, this could potentially lead to the API throwing a different exception in the late version. Therefore the CI type is 2."
38,"<android.view.accessibility.AccessibilityNodeInfo: void writeToParcel(Parcel,int)>",27,28,"<android.view.accessibility.AccessibilityNodeInfo: void writeToParcel(Parcel,int)>","<android.view.accessibility.AccessibilityNodeInfo: void writeToParcel(Parcel,int)>",0,"{
    // Write bit set of indices of fields with values differing from default
    long nonDefaultFields = 0;
    // index of the current field
    int fieldIndex = 0;
    if (isSealed() != DEFAULT.isSealed())
        nonDefaultFields |= bitAt(fieldIndex);
    fieldIndex++;
    if (mSourceNodeId != DEFAULT.mSourceNodeId)
        nonDefaultFields |= bitAt(fieldIndex);
    fieldIndex++;
    if (mWindowId != DEFAULT.mWindowId)
        nonDefaultFields |= bitAt(fieldIndex);
    fieldIndex++;
    if (mParentNodeId != DEFAULT.mParentNodeId)
        nonDefaultFields |= bitAt(fieldIndex);
    fieldIndex++;
    if (mLabelForId != DEFAULT.mLabelForId)
        nonDefaultFields |= bitAt(fieldIndex);
    fieldIndex++;
    if (mLabeledById != DEFAULT.mLabeledById)
        nonDefaultFields |= bitAt(fieldIndex);
    fieldIndex++;
    if (mTraversalBefore != DEFAULT.mTraversalBefore)
        nonDefaultFields |= bitAt(fieldIndex);
    fieldIndex++;
    if (mTraversalAfter != DEFAULT.mTraversalAfter)
        nonDefaultFields |= bitAt(fieldIndex);
    fieldIndex++;
    if (mConnectionId != DEFAULT.mConnectionId)
        nonDefaultFields |= bitAt(fieldIndex);
    fieldIndex++;
    if (!Objects.equals(mChildNodeIds, DEFAULT.mChildNodeIds)) {
        nonDefaultFields |= bitAt(fieldIndex);
    }
    fieldIndex++;
    if (!Objects.equals(mBoundsInParent, DEFAULT.mBoundsInParent)) {
        nonDefaultFields |= bitAt(fieldIndex);
    }
    fieldIndex++;
    if (!Objects.equals(mBoundsInScreen, DEFAULT.mBoundsInScreen)) {
        nonDefaultFields |= bitAt(fieldIndex);
    }
    fieldIndex++;
    if (!Objects.equals(mActions, DEFAULT.mActions))
        nonDefaultFields |= bitAt(fieldIndex);
    fieldIndex++;
    if (mMaxTextLength != DEFAULT.mMaxTextLength)
        nonDefaultFields |= bitAt(fieldIndex);
    fieldIndex++;
    if (mMovementGranularities != DEFAULT.mMovementGranularities) {
        nonDefaultFields |= bitAt(fieldIndex);
    }
    fieldIndex++;
    if (mBooleanProperties != DEFAULT.mBooleanProperties)
        nonDefaultFields |= bitAt(fieldIndex);
    fieldIndex++;
    if (!Objects.equals(mPackageName, DEFAULT.mPackageName)) {
        nonDefaultFields |= bitAt(fieldIndex);
    }
    fieldIndex++;
    if (!Objects.equals(mClassName, DEFAULT.mClassName))
        nonDefaultFields |= bitAt(fieldIndex);
    fieldIndex++;
    if (!Objects.equals(mText, DEFAULT.mText))
        nonDefaultFields |= bitAt(fieldIndex);
    fieldIndex++;
    if (!Objects.equals(mHintText, DEFAULT.mHintText)) {
        nonDefaultFields |= bitAt(fieldIndex);
    }
    fieldIndex++;
    if (!Objects.equals(mError, DEFAULT.mError))
        nonDefaultFields |= bitAt(fieldIndex);
    fieldIndex++;
    if (!Objects.equals(mContentDescription, DEFAULT.mContentDescription)) {
        nonDefaultFields |= bitAt(fieldIndex);
    }
    fieldIndex++;
    if (!Objects.equals(mViewIdResourceName, DEFAULT.mViewIdResourceName)) {
        nonDefaultFields |= bitAt(fieldIndex);
    }
    fieldIndex++;
    if (mTextSelectionStart != DEFAULT.mTextSelectionStart) {
        nonDefaultFields |= bitAt(fieldIndex);
    }
    fieldIndex++;
    if (mTextSelectionEnd != DEFAULT.mTextSelectionEnd) {
        nonDefaultFields |= bitAt(fieldIndex);
    }
    fieldIndex++;
    if (mInputType != DEFAULT.mInputType)
        nonDefaultFields |= bitAt(fieldIndex);
    fieldIndex++;
    if (mLiveRegion != DEFAULT.mLiveRegion)
        nonDefaultFields |= bitAt(fieldIndex);
    fieldIndex++;
    if (mDrawingOrderInParent != DEFAULT.mDrawingOrderInParent) {
        nonDefaultFields |= bitAt(fieldIndex);
    }
    fieldIndex++;
    if (!Objects.equals(mExtraDataKeys, DEFAULT.mExtraDataKeys)) {
        nonDefaultFields |= bitAt(fieldIndex);
    }
    fieldIndex++;
    if (!Objects.equals(mExtras, DEFAULT.mExtras))
        nonDefaultFields |= bitAt(fieldIndex);
    fieldIndex++;
    if (!Objects.equals(mRangeInfo, DEFAULT.mRangeInfo))
        nonDefaultFields |= bitAt(fieldIndex);
    fieldIndex++;
    if (!Objects.equals(mCollectionInfo, DEFAULT.mCollectionInfo)) {
        nonDefaultFields |= bitAt(fieldIndex);
    }
    fieldIndex++;
    if (!Objects.equals(mCollectionItemInfo, DEFAULT.mCollectionItemInfo)) {
        nonDefaultFields |= bitAt(fieldIndex);
    }
    int totalFields = fieldIndex;
    parcel.writeLong(nonDefaultFields);
    fieldIndex = 0;
    if (isBitSet(nonDefaultFields, fieldIndex++))
        parcel.writeInt(isSealed() ? 1 : 0);
    if (isBitSet(nonDefaultFields, fieldIndex++))
        parcel.writeLong(mSourceNodeId);
    if (isBitSet(nonDefaultFields, fieldIndex++))
        parcel.writeInt(mWindowId);
    if (isBitSet(nonDefaultFields, fieldIndex++))
        parcel.writeLong(mParentNodeId);
    if (isBitSet(nonDefaultFields, fieldIndex++))
        parcel.writeLong(mLabelForId);
    if (isBitSet(nonDefaultFields, fieldIndex++))
        parcel.writeLong(mLabeledById);
    if (isBitSet(nonDefaultFields, fieldIndex++))
        parcel.writeLong(mTraversalBefore);
    if (isBitSet(nonDefaultFields, fieldIndex++))
        parcel.writeLong(mTraversalAfter);
    if (isBitSet(nonDefaultFields, fieldIndex++))
        parcel.writeInt(mConnectionId);
    if (isBitSet(nonDefaultFields, fieldIndex++)) {
        final LongArray childIds = mChildNodeIds;
        if (childIds == null) {
            parcel.writeInt(0);
        } else {
            final int childIdsSize = childIds.size();
            parcel.writeInt(childIdsSize);
            for (int i = 0; i < childIdsSize; i++) {
                parcel.writeLong(childIds.get(i));
            }
        }
    }
    if (isBitSet(nonDefaultFields, fieldIndex++)) {
        parcel.writeInt(mBoundsInParent.top);
        parcel.writeInt(mBoundsInParent.bottom);
        parcel.writeInt(mBoundsInParent.left);
        parcel.writeInt(mBoundsInParent.right);
    }
    if (isBitSet(nonDefaultFields, fieldIndex++)) {
        parcel.writeInt(mBoundsInScreen.top);
        parcel.writeInt(mBoundsInScreen.bottom);
        parcel.writeInt(mBoundsInScreen.left);
        parcel.writeInt(mBoundsInScreen.right);
    }
    if (isBitSet(nonDefaultFields, fieldIndex++)) {
        if (mActions != null && !mActions.isEmpty()) {
            final int actionCount = mActions.size();
            int nonStandardActionCount = 0;
            int defaultStandardActions = 0;
            for (int i = 0; i < actionCount; i++) {
                AccessibilityAction action = mActions.get(i);
                if (isDefaultStandardAction(action)) {
                    defaultStandardActions |= action.mSerializationFlag;
                } else {
                    nonStandardActionCount++;
                }
            }
            parcel.writeInt(defaultStandardActions);
            parcel.writeInt(nonStandardActionCount);
            for (int i = 0; i < actionCount; i++) {
                AccessibilityAction action = mActions.get(i);
                if (!isDefaultStandardAction(action)) {
                    parcel.writeInt(action.getId());
                    parcel.writeCharSequence(action.getLabel());
                }
            }
        } else {
            parcel.writeInt(0);
            parcel.writeInt(0);
        }
    }
    if (isBitSet(nonDefaultFields, fieldIndex++))
        parcel.writeInt(mMaxTextLength);
    if (isBitSet(nonDefaultFields, fieldIndex++))
        parcel.writeInt(mMovementGranularities);
    if (isBitSet(nonDefaultFields, fieldIndex++))
        parcel.writeInt(mBooleanProperties);
    if (isBitSet(nonDefaultFields, fieldIndex++))
        parcel.writeCharSequence(mPackageName);
    if (isBitSet(nonDefaultFields, fieldIndex++))
        parcel.writeCharSequence(mClassName);
    if (isBitSet(nonDefaultFields, fieldIndex++))
        parcel.writeCharSequence(mText);
    if (isBitSet(nonDefaultFields, fieldIndex++))
        parcel.writeCharSequence(mHintText);
    if (isBitSet(nonDefaultFields, fieldIndex++))
        parcel.writeCharSequence(mError);
    if (isBitSet(nonDefaultFields, fieldIndex++)) {
        parcel.writeCharSequence(mContentDescription);
    }
    if (isBitSet(nonDefaultFields, fieldIndex++))
        parcel.writeString(mViewIdResourceName);
    if (isBitSet(nonDefaultFields, fieldIndex++))
        parcel.writeInt(mTextSelectionStart);
    if (isBitSet(nonDefaultFields, fieldIndex++))
        parcel.writeInt(mTextSelectionEnd);
    if (isBitSet(nonDefaultFields, fieldIndex++))
        parcel.writeInt(mInputType);
    if (isBitSet(nonDefaultFields, fieldIndex++))
        parcel.writeInt(mLiveRegion);
    if (isBitSet(nonDefaultFields, fieldIndex++))
        parcel.writeInt(mDrawingOrderInParent);
    if (isBitSet(nonDefaultFields, fieldIndex++))
        parcel.writeStringList(mExtraDataKeys);
    if (isBitSet(nonDefaultFields, fieldIndex++))
        parcel.writeBundle(mExtras);
    if (isBitSet(nonDefaultFields, fieldIndex++)) {
        parcel.writeInt(mRangeInfo.getType());
        parcel.writeFloat(mRangeInfo.getMin());
        parcel.writeFloat(mRangeInfo.getMax());
        parcel.writeFloat(mRangeInfo.getCurrent());
    }
    if (isBitSet(nonDefaultFields, fieldIndex++)) {
        parcel.writeInt(mCollectionInfo.getRowCount());
        parcel.writeInt(mCollectionInfo.getColumnCount());
        parcel.writeInt(mCollectionInfo.isHierarchical() ? 1 : 0);
        parcel.writeInt(mCollectionInfo.getSelectionMode());
    }
    if (isBitSet(nonDefaultFields, fieldIndex++)) {
        parcel.writeInt(mCollectionItemInfo.getRowIndex());
        parcel.writeInt(mCollectionItemInfo.getRowSpan());
        parcel.writeInt(mCollectionItemInfo.getColumnIndex());
        parcel.writeInt(mCollectionItemInfo.getColumnSpan());
        parcel.writeInt(mCollectionItemInfo.isHeading() ? 1 : 0);
        parcel.writeInt(mCollectionItemInfo.isSelected() ? 1 : 0);
    }
    if (DEBUG) {
        fieldIndex--;
        if (totalFields != fieldIndex) {
            throw new IllegalStateException(""Number of fields mismatch: "" + totalFields + "" vs "" + fieldIndex);
        }
    }
    // Since instances of this class are fetched via synchronous i.e. blocking
    // calls in IPCs we always recycle as soon as the instance is marshaled.
    recycle();
}","{
    writeToParcelNoRecycle(parcel, flags);
    // Since instances of this class are fetched via synchronous i.e. blocking
    // calls in IPCs we always recycle as soon as the instance is marshaled.
    recycle();
}",1,"/**
 * {@inheritDoc}
 * <p>
 * <strong>Note:</strong> After the instance is written to a parcel it
 * is recycled. You must not touch the object after calling this function.
 * </p>
 */
","/**
 * {@inheritDoc}
 * <p>
 * <strong>Note:</strong> After the instance is written to a parcel it
 * is recycled. You must not touch the object after calling this function.
 * </p>
 */
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,,,,
39,<android.app.usage.UsageStatsManager: boolean isAppInactive(String)>,27,28,<android.app.usage.UsageStatsManager: boolean isAppInactive(String)>,<android.app.usage.UsageStatsManager: boolean isAppInactive(String)>,0,"{
    try {
        return mService.isAppInactive(packageName, UserHandle.myUserId());
    } catch (RemoteException e) {
    // fall through and return default
    }
    return false;
}","{
    try {
        return mService.isAppInactive(packageName, mContext.getUserId());
    } catch (RemoteException e) {
    // fall through and return default
    }
    return false;
}",1,"/**
 * Returns whether the specified app is currently considered inactive. This will be true if the
 * app hasn't been used directly or indirectly for a period of time defined by the system. This
 * could be of the order of several hours or days.
 * @param packageName The package name of the app to query
 * @return whether the app is currently considered inactive
 */
","/**
 * Returns whether the specified app is currently considered inactive. This will be true if the
 * app hasn't been used directly or indirectly for a period of time defined by the system. This
 * could be of the order of several hours or days.
 * @param packageName The package name of the app to query
 * @return whether the app is currently considered inactive
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The code change is the replacement of UserHandle.myUserId() with mContext.getUserId() within the isAppInactive method call. This indicates a change in how the user ID is obtained, but given the context, both are expected to return the same user ID for the calling context. Thus, this change type is 5 (Dependent API changed).","There is no Compatibility Issue because the return value and behavior of the method isAppInactive remain the same given that whichever method is used for obtaining the user ID should consistently return the correct ID for the current user. Hence, both the early and late versions should behave the same way for the same input."
41,<android.hardware.radio.RadioManager.ProgramInfo: boolean isTuned()>,27,28,<android.hardware.radio.RadioManager.ProgramInfo: boolean isTuned()>,<android.hardware.radio.RadioManager.ProgramInfo: boolean isTuned()>,0,"{
    return mTuned;
}","{
    return (mInfoFlags & FLAG_TUNED) != 0;
}",1,"/**
 * {@code true} if the tuner is currently tuned on a valid station
 * @return {@code true} if currently tuned, {@code false} otherwise.
 */
","/**
 * {@code true} if the tuner is currently tuned on a valid station
 * @return {@code true} if currently tuned, {@code false} otherwise.
 */
",-1,,,-1,-1,-1,-1,-1,-1,1,1,"The return statement's logic has been modified. In the early version, it simply returns the value of mTuned, but in the late version, it returns a boolean result of a bit-wise operation with mInfoFlags and FLAG_TUNED, which indicates a different logic for determining if the program is tuned. This qualifies as a change type 1.","Since the return condition has been significantly changed, this could lead to the method potentially returning a different value even under the same circumstances as before. Hence, the CI type is 1, indicating that there could be a compatibility issue due to the potential for different return values."
42,<android.bluetooth.le.AdvertisingSetParameters.Builder: Builder setAnonymous(boolean)>,27,28,<android.bluetooth.le.AdvertisingSetParameters.Builder: Builder setAnonymous(boolean)>,<android.bluetooth.le.AdvertisingSetParameters.Builder: Builder setAnonymous(boolean)>,0,"{
    this.isAnonymous = isAnonymous;
    return this;
}","{
    mIsAnonymous = isAnonymous;
    return this;
}",1,"/**
 * Set whether advertiser address should be ommited from all packets. If this
 * mode is used, periodic advertising can't be enabled for this set.
 *
 * This is used only if legacy mode is not used.
 *
 * @param isAnonymous whether anonymous advertising should be used.
 */
","/**
 * Set whether advertiser address should be ommited from all packets. If this
 * mode is used, periodic advertising can't be enabled for this set.
 *
 * This is used only if legacy mode is not used.
 *
 * @param isAnonymous whether anonymous advertising should be used.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The field assignment has changed from this.isAnonymous to mIsAnonymous. There is no change to the behavior of the return statement or logic of the method, only the internal variable name has been altered, which is an internal implementation detail. Therefore, the change type is 4 (Other statement changed).","There is no Compatibility Issue because the assignment change does not alter the external behavior of the method. The method still sets a boolean flag and returns the same Builder object, so the API's contract remains intact."
46,<android.hardware.display.DisplayManagerInternal.DisplayPowerRequest: String toString()>,27,28,<android.hardware.display.DisplayManagerInternal.DisplayPowerRequest: String toString()>,<android.hardware.display.DisplayManagerInternal.DisplayPowerRequest: String toString()>,0,"{
    return ""policy="" + policyToString(policy) + "", useProximitySensor="" + useProximitySensor + "", screenBrightness="" + screenBrightness + "", screenAutoBrightnessAdjustment="" + screenAutoBrightnessAdjustment + "", screenLowPowerBrightnessFactor="" + screenLowPowerBrightnessFactor + "", brightnessSetByUser="" + brightnessSetByUser + "", useAutoBrightness="" + useAutoBrightness + "", blockScreenOn="" + blockScreenOn + "", lowPowerMode="" + lowPowerMode + "", boostScreenBrightness="" + boostScreenBrightness + "", dozeScreenBrightness="" + dozeScreenBrightness + "", dozeScreenState="" + Display.stateToString(dozeScreenState);
}","{
    return ""policy="" + policyToString(policy) + "", useProximitySensor="" + useProximitySensor + "", screenBrightnessOverride="" + screenBrightnessOverride + "", useAutoBrightness="" + useAutoBrightness + "", screenAutoBrightnessAdjustmentOverride="" + screenAutoBrightnessAdjustmentOverride + "", screenLowPowerBrightnessFactor="" + screenLowPowerBrightnessFactor + "", blockScreenOn="" + blockScreenOn + "", lowPowerMode="" + lowPowerMode + "", boostScreenBrightness="" + boostScreenBrightness + "", dozeScreenBrightness="" + dozeScreenBrightness + "", dozeScreenState="" + Display.stateToString(dozeScreenState);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,4",1,"The method's return statement is changed, with some variable names changed from 'screenBrightness' to 'screenBrightnessOverride' and 'screenAutoBrightnessAdjustment' to 'screenAutoBrightnessAdjustmentOverride', and 'brightnessSetByUser' is removed, so the code change types are 1 and 4.","The return value of the method has been modified, which can cause the API to return a different string value when the method is invoked, as such, the CI type is 1."
48,<android.os.storage.StorageManager: List<StorageVolume> getStorageVolumes()>,27,28,<android.os.storage.StorageManager: List<StorageVolume> getStorageVolumes()>,<android.os.storage.StorageManager: List<StorageVolume> getStorageVolumes()>,0,"{
    final ArrayList<StorageVolume> res = new ArrayList<>();
    Collections.addAll(res, getVolumeList(UserHandle.myUserId(), FLAG_REAL_STATE | FLAG_INCLUDE_INVISIBLE));
    return res;
}","{
    final ArrayList<StorageVolume> res = new ArrayList<>();
    Collections.addAll(res, getVolumeList(mContext.getUserId(), FLAG_REAL_STATE | FLAG_INCLUDE_INVISIBLE));
    return res;
}",1,"/**
 * Return the list of shared/external storage volumes available to the
 * current user. This includes both the primary shared storage device and
 * any attached external volumes including SD cards and USB drives.
 *
 * @see Environment#getExternalStorageDirectory()
 * @see StorageVolume#createAccessIntent(String)
 */
","/**
 * Return the list of shared/external storage volumes available to the
 * current user. This includes both the primary shared storage device and
 * any attached external volumes including SD cards and USB drives.
 *
 * @see Environment#getExternalStorageDirectory()
 * @see StorageVolume#createAccessIntent(String)
 */
",-1,[@NonNull],[@NonNull],-1,-1,-1,-1,-1,-1,5,0,"The change is in the method call getVolumeList() where the parameter has changed from UserHandle.myUserId() to mContext.getUserId(). This indicates a change in the dependent API, so the change type is 5.","The change in the method parameter does not necessarily indicate a compatibility issue because it's not clear whether mContext.getUserId() and UserHandle.myUserId() return different user IDs, which would affect the outcome. Without further information indicating that the behavior of the userID retrieval has been altered leading to different return values, we cannot conclude that there is a compatibility issue."
49,<android.content.res.AssetManager: void close()>,27,28,<android.content.res.AssetManager: void close()>,<android.content.res.AssetManager: void close()>,0,"{
    synchronized (this) {
        // + "", released="" + mReleased);
        if (mOpen) {
            mOpen = false;
            decRefsLocked(this.hashCode());
        }
    }
}","{
    synchronized (this) {
        if (!mOpen) {
            return;
        }
        mOpen = false;
        decRefsLocked(hashCode());
    }
}",1,"/**
 * Close this asset manager.
 */
","/**
 * Close this asset manager.
 */
",-1,,[@Override],-1,-1,-1,-1,-1,-1,4,0,The code change includes the addition of an early return statement if `mOpen` is false. The change can be classified as 4 since it is an addition of a new statement that is not a control dependency or exception handling change.,"There is no Compatibility Issue because the addition of the early return statement does not affect the behavior of the API when it is called. If `mOpen` is false, the method effectively does nothing in both versions, so the outcome remains unchanged. Therefore, the API would behave identically in terms of how it affects the calling code, preserving compatibility across versions 27 and 28."
50,<android.hardware.fingerprint.FingerprintManager: boolean hasEnrolledFingerprints()>,27,28,<android.hardware.fingerprint.FingerprintManager: boolean hasEnrolledFingerprints()>,<android.hardware.fingerprint.FingerprintManager: boolean hasEnrolledFingerprints()>,0,"{
    if (mService != null)
        try {
            return mService.hasEnrolledFingerprints(UserHandle.myUserId(), mContext.getOpPackageName());
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    return false;
}","{
    if (mService != null)
        try {
            return mService.hasEnrolledFingerprints(mContext.getUserId(), mContext.getOpPackageName());
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    return false;
}",1,"/**
 * Determine if there is at least one fingerprint enrolled.
 *
 * @return true if at least one fingerprint is enrolled, false otherwise
 */
","/**
 * Determine if there is at least one fingerprint enrolled.
 *
 * @return true if at least one fingerprint is enrolled, false otherwise
 * @deprecated See {@link BiometricPrompt} and
 * {@link FingerprintManager#FINGERPRINT_ERROR_NO_FINGERPRINTS}
 */
",-1,[@RequiresPermission(USE_FINGERPRINT)],"[@Deprecated, @RequiresPermission(USE_FINGERPRINT)]",-1,-1,-1,-1,-1,-1,5,0,The only change in the code is the method call from `UserHandle.myUserId()` to `mContext.getUserId()`. This indicates that there is a change in the dependent API being called to determine the user ID.,"No Compatibility Issue has been detected because the change in the method of obtaining the user ID likely does not alter the behavior of the `hasEnrolledFingerprints()` method with respect to its return value or the exceptions it may throw. The method still returns a boolean indicating whether there are enrolled fingerprints for the user, and the exception handling remains unchanged. The replacement method for obtaining the user ID should be providing equivalent user identification necessary for checking if fingerprints are enrolled."
53,"<android.content.ContentResolver: List<PeriodicSync> getPeriodicSyncs(Account,String)>",27,28,"<android.content.ContentResolver: List<PeriodicSync> getPeriodicSyncs(Account,String)>","<android.content.ContentResolver: List<PeriodicSync> getPeriodicSyncs(Account,String)>",0,"{
    try {
        return getContentService().getPeriodicSyncs(account, authority, null);
    } catch (RemoteException e) {
        throw new RuntimeException(""the ContentService should always be reachable"", e);
    }
}","{
    try {
        return getContentService().getPeriodicSyncs(account, authority, null);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Get the list of information about the periodic syncs for the given account and authority.
 * <p>This method requires the caller to hold the permission
 * {@link android.Manifest.permission#READ_SYNC_SETTINGS}.
 *
 * @param account the account whose periodic syncs we are querying
 * @param authority the provider whose periodic syncs we are querying
 * @return a list of PeriodicSync objects. This list may be empty but will never be null.
 */
","/**
 * Get the list of information about the periodic syncs for the given account and authority.
 * <p>This method requires the caller to hold the permission
 * {@link android.Manifest.permission#READ_SYNC_SETTINGS}.
 *
 * @param account the account whose periodic syncs we are querying
 * @param authority the provider whose periodic syncs we are querying
 * @return a list of PeriodicSync objects. This list may be empty but will never be null.
 */
",-1,,,-1,-1,-1,-1,-1,-1,2,2,"The exception handling statement has been changed from throwing a new RuntimeException to calling e.rethrowFromSystemServer(), so the code change type is 2.","This update to the exception handling will potentially cause the method to throw a different exception than it did before, hence the Compatibility Issue type is 2."
54,"<android.provider.Settings.System: boolean putInt(ContentResolver,String,int)>",27,28,"<android.provider.Settings.System: boolean putInt(ContentResolver,String,int)>","<android.provider.Settings.System: boolean putInt(ContentResolver,String,int)>",0,"{
    return putIntForUser(cr, name, value, UserHandle.myUserId());
}","{
    return putIntForUser(cr, name, value, cr.getUserId());
}",1,"/**
 * Convenience function for updating a single settings value as an
 * integer. This will either create a new entry in the table if the
 * given name does not exist, or modify the value of the existing row
 * with that name.  Note that internally setting values are always
 * stored as strings, so this function converts the given value to a
 * string before storing it.
 *
 * @param cr The ContentResolver to access.
 * @param name The name of the setting to modify.
 * @param value The new value for the setting.
 * @return true if the value was set, false on database errors
 */
","/**
 * Convenience function for updating a single settings value as an
 * integer. This will either create a new entry in the table if the
 * given name does not exist, or modify the value of the existing row
 * with that name.  Note that internally setting values are always
 * stored as strings, so this function converts the given value to a
 * string before storing it.
 *
 * @param cr The ContentResolver to access.
 * @param name The name of the setting to modify.
 * @param value The new value for the setting.
 * @return true if the value was set, false on database errors
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The code change is in the argument of the `putIntForUser` call, from `UserHandle.myUserId()` to `cr.getUserId()`. This indicates a change to a dependent API, so the code change type is 5.","The difference in how the user ID is obtained should not affect the return type or exception handling of the `putInt` method, assuming that `UserHandle.myUserId()` and `cr.getUserId()` return the correct user ID within the context they are called. Thus, no Compatibility Issue is expected, and the CI type is 0."
57,<android.app.ActivityManager.TaskDescription: String toString()>,27,28,<android.app.ActivityManager.TaskDescription: String toString()>,<android.app.ActivityManager.TaskDescription: String toString()>,0,"{
    return ""TaskDescription Label: "" + mLabel + "" Icon: "" + mIcon + "" IconFilename: "" + mIconFilename + "" colorPrimary: "" + mColorPrimary + "" colorBackground: "" + mColorBackground + "" statusBarColor: "" + mColorBackground + "" navigationBarColor: "" + mNavigationBarColor;
}","{
    return ""TaskDescription Label: "" + mLabel + "" Icon: "" + mIcon + "" IconRes: "" + mIconRes + "" IconFilename: "" + mIconFilename + "" colorPrimary: "" + mColorPrimary + "" colorBackground: "" + mColorBackground + "" statusBarColor: "" + mColorBackground + "" navigationBarColor: "" + mNavigationBarColor;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"The string concatenation in the return statement has been slightly modified to include ""mIconRes"" in the late version which differs from the early version. This change is an other statement changed (type 4).","Since the method simply returns a string representation and the change does not affect the return type nor does it create a situation where an exception could be thrown differently, it does not introduce a Compatibility Issue (CI type 0)."
58,<android.app.NotificationManager: void cancelAll()>,27,28,<android.app.NotificationManager: void cancelAll()>,<android.app.NotificationManager: void cancelAll()>,0,"{
    INotificationManager service = getService();
    String pkg = mContext.getPackageName();
    if (localLOGV)
        Log.v(TAG, pkg + "": cancelAll()"");
    try {
        service.cancelAllNotifications(pkg, UserHandle.myUserId());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}","{
    INotificationManager service = getService();
    String pkg = mContext.getPackageName();
    if (localLOGV)
        Log.v(TAG, pkg + "": cancelAll()"");
    try {
        service.cancelAllNotifications(pkg, mContext.getUserId());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Cancel all previously shown notifications. See {@link #cancel} for the
 * detailed behavior.
 */
","/**
 * Cancel all previously shown notifications. See {@link #cancel} for the
 * detailed behavior.
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The method call within the try block has changed from `service.cancelAllNotifications(pkg, UserHandle.myUserId())` to `service.cancelAllNotifications(pkg, mContext.getUserId())`. This change is in the arguments of the method `cancelAllNotifications`, indicating that the dependent API has changed in how the user ID is obtained. This is type 5.",There is no compatibility issue detected since the change affects only how the user ID is obtained and does not alter the method's control flow or how service.cancelAllNotifications is invoked with respect to its behaviour in the API itself.
61,<android.view.autofill.AutofillManager: boolean isEnabled()>,27,28,<android.view.autofill.AutofillManager: boolean isEnabled()>,<android.view.autofill.AutofillManager: boolean isEnabled()>,0,"{
    if (!hasAutofillFeature()) {
        return false;
    }
    synchronized (mLock) {
        ensureServiceClientAddedIfNeededLocked();
        return mEnabled;
    }
}","{
    if (!hasAutofillFeature()) {
        return false;
    }
    synchronized (mLock) {
        if (isDisabledByServiceLocked()) {
            return false;
        }
        ensureServiceClientAddedIfNeededLocked();
        return mEnabled;
    }
}",1,"/**
 * Checks whether autofill is enabled for the current user.
 *
 * <p>Typically used to determine whether the option to explicitly request autofill should
 * be offered - see {@link #requestAutofill(View)}.
 *
 * @return whether autofill is enabled for the current user.
 */
","/**
 * Checks whether autofill is enabled for the current user.
 *
 * <p>Typically used to determine whether the option to explicitly request autofill should
 * be offered - see {@link #requestAutofill(View)}.
 *
 * @return whether autofill is enabled for the current user.
 */
",-1,,,-1,-1,-1,-1,-1,-1,3,1,"The introduction of a new if statement (if (isDisabledByServiceLocked())) that checks whether something is disabled by the service and potentially returns false changes the control flow, so the code change type is 3.","Due to the added if statement that could return a different boolean value, the API behavior has changed. This potentially causes the API to return different results, so the CI type is 1."
62,<android.app.InstantAppResolverService.ServiceHandler: void handleMessage(Message)>,27,28,<android.app.InstantAppResolverService.ServiceHandler: void handleMessage(Message)>,<android.app.InstantAppResolverService.ServiceHandler: void handleMessage(Message)>,0,"{
    final int action = message.what;
    switch(action) {
        case MSG_GET_INSTANT_APP_RESOLVE_INFO:
            {
                final SomeArgs args = (SomeArgs) message.obj;
                final IRemoteCallback callback = (IRemoteCallback) args.arg1;
                final int[] digestPrefix = (int[]) args.arg2;
                final String token = (String) args.arg3;
                final int sequence = message.arg1;
                _onGetInstantAppResolveInfo(digestPrefix, token, new InstantAppResolutionCallback(sequence, callback));
            }
            break;
        case MSG_GET_INSTANT_APP_INTENT_FILTER:
            {
                final SomeArgs args = (SomeArgs) message.obj;
                final IRemoteCallback callback = (IRemoteCallback) args.arg1;
                final int[] digestPrefix = (int[]) args.arg2;
                final String token = (String) args.arg3;
                final String hostName = (String) args.arg4;
                _onGetInstantAppIntentFilter(digestPrefix, token, hostName, new InstantAppResolutionCallback(-1, /*sequence*/
                callback));
            }
            break;
        default:
            {
                throw new IllegalArgumentException(""Unknown message: "" + action);
            }
    }
}","{
    final int action = message.what;
    switch(action) {
        case MSG_GET_INSTANT_APP_RESOLVE_INFO:
            {
                final SomeArgs args = (SomeArgs) message.obj;
                final IRemoteCallback callback = (IRemoteCallback) args.arg1;
                final int[] digestPrefix = (int[]) args.arg2;
                final String token = (String) args.arg3;
                final Intent intent = (Intent) args.arg4;
                final int sequence = message.arg1;
                if (DEBUG_INSTANT) {
                    Slog.d(TAG, ""["" + token + ""] Phase1 request;"" + "" prefix: "" + Arrays.toString(digestPrefix));
                }
                onGetInstantAppResolveInfo(intent, digestPrefix, token, new InstantAppResolutionCallback(sequence, callback));
            }
            break;
        case MSG_GET_INSTANT_APP_INTENT_FILTER:
            {
                final SomeArgs args = (SomeArgs) message.obj;
                final IRemoteCallback callback = (IRemoteCallback) args.arg1;
                final int[] digestPrefix = (int[]) args.arg2;
                final String token = (String) args.arg3;
                final Intent intent = (Intent) args.arg4;
                if (DEBUG_INSTANT) {
                    Slog.d(TAG, ""["" + token + ""] Phase2 request;"" + "" prefix: "" + Arrays.toString(digestPrefix));
                }
                onGetInstantAppIntentFilter(intent, digestPrefix, token, new InstantAppResolutionCallback(-1, /*sequence*/
                callback));
            }
            break;
        default:
            {
                throw new IllegalArgumentException(""Unknown message: "" + action);
            }
    }
}",1,,,-1,"[@Override, @SuppressWarnings(""unchecked"")]","[@Override, @SuppressWarnings(""unchecked"")]",-1,-1,-1,-1,-1,-1,"3,4,5",0,"There is an addition of new local variables (Intent intent) inside both MSG_GET_INSTANT_APP_RESOLVE_INFO and MSG_GET_INSTANT_APP_INTENT_FILTER cases, additional debug log statements with condition (if DEBUG_INSTANT) inside both cases, and the dependent APIs (_onGetInstantAppResolveInfo and _onGetInstantAppIntentFilter in the early version and onGetInstantAppResolveInfo and onGetInstantAppIntentFilter in the late version) have changed both in name and parameters. This results in changes associated with control dependency change due to the addition of the debug log condition, other statement changed due to the additional local variables and the debug logs, and dependent API changed due to the changes in the method invocations and their parameters.","There is no Compatibility Issue because the handleMessage method is void and the only potential external side effect from these changes is additional log output. The method's invocations to resolve Instant App information (either _onGetInstantAppResolveInfo / onGetInstantAppResolveInfo or _onGetInstantAppIntentFilter / onGetInstantAppIntentFilter) would still functionally trigger the same sequences with the same parameters it needs to, and the log statements are conditioned on DEBUG_INSTANT, so it will not affect the API's behavior unless debugging is intentionally enabled."
63,"<android.content.res.AssetManager: boolean getThemeValue(long,int,TypedValue,boolean)>",27,28,"<android.content.res.AssetManager: boolean getThemeValue(long,int,TypedValue,boolean)>","<android.content.res.AssetManager: boolean getThemeValue(long,int,TypedValue,boolean)>",0,"{
    final int block = loadThemeAttributeValue(theme, resId, outValue, resolveRefs);
    if (block < 0) {
        return false;
    }
    // Convert the changing configurations flags populated by native code.
    outValue.changingConfigurations = ActivityInfo.activityInfoConfigNativeToJava(outValue.changingConfigurations);
    if (outValue.type == TypedValue.TYPE_STRING) {
        final StringBlock[] blocks = ensureStringBlocks();
        outValue.string = blocks[block].get(outValue.data);
    }
    return true;
}","{
    Preconditions.checkNotNull(outValue, ""outValue"");
    synchronized (this) {
        ensureValidLocked();
        final int cookie = nativeThemeGetAttributeValue(mObject, theme, resId, outValue, resolveRefs);
        if (cookie <= 0) {
            return false;
        }
        // Convert the changing configurations flags populated by native code.
        outValue.changingConfigurations = ActivityInfo.activityInfoConfigNativeToJava(outValue.changingConfigurations);
        if (outValue.type == TypedValue.TYPE_STRING) {
            outValue.string = mApkAssets[cookie - 1].getStringFromPool(outValue.data);
        }
        return true;
    }
}",1,"/**
 * Populates {@code outValue} with the data associated with a particular
 * resource identifier for the current configuration. Resolves theme
 * attributes against the specified theme.
 *
 * @param theme the native pointer of the theme
 * @param resId the resource identifier to load
 * @param outValue the typed value in which to put the data
 * @param resolveRefs {@code true} to resolve references, {@code false}
 * to leave them unresolved
 * @return {@code true} if the data was loaded into {@code outValue},
 * {@code false} otherwise
 */
","/**
 * Populates {@code outValue} with the data associated with a particular
 * resource identifier for the current configuration. Resolves theme
 * attributes against the specified theme.
 *
 * @param theme the native pointer of the theme
 * @param resId the resource identifier to load
 * @param outValue the typed value in which to put the data
 * @param resolveRefs {@code true} to resolve references, {@code false}
 * to leave them unresolved
 * @return {@code true} if the data was loaded into {@code outValue},
 * {@code false} otherwise
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3,4,5",1,The code change involves multiple aspects:,"- The variable 'block' and method 'loadThemeAttributeValue' are replaced with 'cookie' and 'nativeThemeGetAttributeValue' which indicates a ""Dependent API changed""."
64,<android.os.StrictMode.VmPolicy.Builder: Builder detectAll()>,27,28,<android.os.StrictMode.VmPolicy.Builder: Builder detectAll()>,<android.os.StrictMode.VmPolicy.Builder: Builder detectAll()>,0,"{
    detectLeakedSqlLiteObjects();
    final int targetSdk = VMRuntime.getRuntime().getTargetSdkVersion();
    if (targetSdk >= Build.VERSION_CODES.HONEYCOMB) {
        detectActivityLeaks();
        detectLeakedClosableObjects();
    }
    if (targetSdk >= Build.VERSION_CODES.JELLY_BEAN) {
        detectLeakedRegistrationObjects();
    }
    if (targetSdk >= Build.VERSION_CODES.JELLY_BEAN_MR2) {
        detectFileUriExposure();
    }
    if (targetSdk >= Build.VERSION_CODES.M) {
        // facility for apps to mark sockets that should be ignored
        if (SystemProperties.getBoolean(CLEARTEXT_PROPERTY, false)) {
            detectCleartextNetwork();
        }
    }
    if (targetSdk >= Build.VERSION_CODES.O) {
        detectContentUriWithoutPermission();
        detectUntaggedSockets();
    }
    return this;
}","{
    detectLeakedSqlLiteObjects();
    final int targetSdk = VMRuntime.getRuntime().getTargetSdkVersion();
    if (targetSdk >= Build.VERSION_CODES.HONEYCOMB) {
        detectActivityLeaks();
        detectLeakedClosableObjects();
    }
    if (targetSdk >= Build.VERSION_CODES.JELLY_BEAN) {
        detectLeakedRegistrationObjects();
    }
    if (targetSdk >= Build.VERSION_CODES.JELLY_BEAN_MR2) {
        detectFileUriExposure();
    }
    if (targetSdk >= Build.VERSION_CODES.M) {
        // facility for apps to mark sockets that should be ignored
        if (SystemProperties.getBoolean(CLEARTEXT_PROPERTY, false)) {
            detectCleartextNetwork();
        }
    }
    if (targetSdk >= Build.VERSION_CODES.O) {
        detectContentUriWithoutPermission();
        detectUntaggedSockets();
    }
    // TODO: Decide whether to detect non SDK API usage beyond a certain API level.
    return this;
}",1,"/**
 * Detect everything that's potentially suspect.
 *
 * <p>In the Honeycomb release this includes leaks of
 * SQLite cursors, Activities, and other closable objects
 * but will likely expand in future releases.
 */
","/**
 * Detect everything that's potentially suspect.
 *
 * <p>In the Honeycomb release this includes leaks of SQLite cursors, Activities, and
 * other closable objects but will likely expand in future releases.
 */
",-1,,,-1,-1,-1,-1,-1,-1,0,0,"There is no change in method behavior or implementation, only a comment is added.","A comment does not impact the execution or behavior of the code, thus there is no compatibility issue."
65,<android.webkit.WebView: PackageInfo getCurrentWebViewPackage()>,27,28,<android.webkit.WebView: PackageInfo getCurrentWebViewPackage()>,<android.webkit.WebView: PackageInfo getCurrentWebViewPackage()>,0,"{
    PackageInfo webviewPackage = WebViewFactory.getLoadedPackageInfo();
    if (webviewPackage != null) {
        return webviewPackage;
    }
    try {
        return WebViewFactory.getUpdateService().getCurrentWebViewPackage();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}","{
    PackageInfo webviewPackage = WebViewFactory.getLoadedPackageInfo();
    if (webviewPackage != null) {
        return webviewPackage;
    }
    IWebViewUpdateService service = WebViewFactory.getUpdateService();
    if (service == null) {
        return null;
    }
    try {
        return service.getCurrentWebViewPackage();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * If WebView has already been loaded into the current process this method will return the
 * package that was used to load it. Otherwise, the package that would be used if the WebView
 * was loaded right now will be returned; this does not cause WebView to be loaded, so this
 * information may become outdated at any time.
 * The WebView package changes either when the current WebView package is updated, disabled, or
 * uninstalled. It can also be changed through a Developer Setting.
 * If the WebView package changes, any app process that has loaded WebView will be killed. The
 * next time the app starts and loads WebView it will use the new WebView package instead.
 * @return the current WebView package, or null if there is none.
 */
","/**
 * If WebView has already been loaded into the current process this method will return the
 * package that was used to load it. Otherwise, the package that would be used if the WebView
 * was loaded right now will be returned; this does not cause WebView to be loaded, so this
 * information may become outdated at any time.
 * The WebView package changes either when the current WebView package is updated, disabled, or
 * uninstalled. It can also be changed through a Developer Setting.
 * If the WebView package changes, any app process that has loaded WebView will be killed. The
 * next time the app starts and loads WebView it will use the new WebView package instead.
 * @return the current WebView package, or {@code null} if there is none.
 */
",-1,,[@Nullable],-1,-1,-1,-1,-1,-1,"1,3,4","0,1","The change is in the late version implementation where a new control dependency, a null check on service (`if (service == null) { return null; }`), is added and the calling pattern for service.getCurrentWebViewPackage() for the late implementation was modified to account for service being null. Furthermore, a new return statement (`return null;`) is introduced when the service is null. These are classified as 1 for the return statement change, 3 for the control dependency change, and 4 for the other statement change as well.","There is a control dependency change that can lead to a new behavior: if `service` is null, the method will return null without attempting to invoke `getCurrentWebViewPackage()`. This introduces a new potential return value (null) in the flow, representing a Compatibility Issue type 1. However, since the null possibility for `service` is a new check and does not cover the entire return space nor does it introduce new types of objects being returned, there is a possibility that the behavior could be perceived as not introducing an issue. It depends on whether clients are prepared for a `null` return value, which is indicated by the new `@Nullable` annotation in the late version."
67,<android.view.accessibility.AccessibilityNodeInfo: String toString()>,27,28,<android.view.accessibility.AccessibilityNodeInfo: String toString()>,<android.view.accessibility.AccessibilityNodeInfo: String toString()>,0,"{
    StringBuilder builder = new StringBuilder();
    builder.append(super.toString());
    if (DEBUG) {
        builder.append(""; sourceNodeId: "" + mSourceNodeId);
        builder.append(""; accessibilityViewId: "" + getAccessibilityViewId(mSourceNodeId));
        builder.append(""; virtualDescendantId: "" + getVirtualDescendantId(mSourceNodeId));
        builder.append(""; mParentNodeId: "" + mParentNodeId);
        builder.append(""; traversalBefore: "").append(mTraversalBefore);
        builder.append(""; traversalAfter: "").append(mTraversalAfter);
        int granularities = mMovementGranularities;
        builder.append(""; MovementGranularities: ["");
        while (granularities != 0) {
            final int granularity = 1 << Integer.numberOfTrailingZeros(granularities);
            granularities &= ~granularity;
            builder.append(getMovementGranularitySymbolicName(granularity));
            if (granularities != 0) {
                builder.append("", "");
            }
        }
        builder.append(""]"");
        builder.append(""; childAccessibilityIds: ["");
        final LongArray childIds = mChildNodeIds;
        if (childIds != null) {
            for (int i = 0, count = childIds.size(); i < count; i++) {
                builder.append(childIds.get(i));
                if (i < count - 1) {
                    builder.append("", "");
                }
            }
        }
        builder.append(""]"");
    }
    builder.append(""; boundsInParent: "" + mBoundsInParent);
    builder.append(""; boundsInScreen: "" + mBoundsInScreen);
    builder.append(""; packageName: "").append(mPackageName);
    builder.append(""; className: "").append(mClassName);
    builder.append(""; text: "").append(mText);
    builder.append(""; error: "").append(mError);
    builder.append(""; maxTextLength: "").append(mMaxTextLength);
    builder.append(""; contentDescription: "").append(mContentDescription);
    builder.append(""; viewIdResName: "").append(mViewIdResourceName);
    builder.append(""; checkable: "").append(isCheckable());
    builder.append(""; checked: "").append(isChecked());
    builder.append(""; focusable: "").append(isFocusable());
    builder.append(""; focused: "").append(isFocused());
    builder.append(""; selected: "").append(isSelected());
    builder.append(""; clickable: "").append(isClickable());
    builder.append(""; longClickable: "").append(isLongClickable());
    builder.append(""; contextClickable: "").append(isContextClickable());
    builder.append(""; enabled: "").append(isEnabled());
    builder.append(""; password: "").append(isPassword());
    builder.append(""; scrollable: "").append(isScrollable());
    builder.append(""; importantForAccessibility: "").append(isImportantForAccessibility());
    builder.append(""; actions: "").append(mActions);
    return builder.toString();
}","{
    StringBuilder builder = new StringBuilder();
    builder.append(super.toString());
    if (DEBUG) {
        builder.append(""; sourceNodeId: "" + mSourceNodeId);
        builder.append(""; windowId: "" + mWindowId);
        builder.append(""; accessibilityViewId: "").append(getAccessibilityViewId(mSourceNodeId));
        builder.append(""; virtualDescendantId: "").append(getVirtualDescendantId(mSourceNodeId));
        builder.append(""; mParentNodeId: "" + mParentNodeId);
        builder.append(""; traversalBefore: "").append(mTraversalBefore);
        builder.append(""; traversalAfter: "").append(mTraversalAfter);
        int granularities = mMovementGranularities;
        builder.append(""; MovementGranularities: ["");
        while (granularities != 0) {
            final int granularity = 1 << Integer.numberOfTrailingZeros(granularities);
            granularities &= ~granularity;
            builder.append(getMovementGranularitySymbolicName(granularity));
            if (granularities != 0) {
                builder.append("", "");
            }
        }
        builder.append(""]"");
        builder.append(""; childAccessibilityIds: ["");
        final LongArray childIds = mChildNodeIds;
        if (childIds != null) {
            for (int i = 0, count = childIds.size(); i < count; i++) {
                builder.append(childIds.get(i));
                if (i < count - 1) {
                    builder.append("", "");
                }
            }
        }
        builder.append(""]"");
    }
    builder.append(""; boundsInParent: "").append(mBoundsInParent);
    builder.append(""; boundsInScreen: "").append(mBoundsInScreen);
    builder.append(""; packageName: "").append(mPackageName);
    builder.append(""; className: "").append(mClassName);
    builder.append(""; text: "").append(mText);
    builder.append(""; error: "").append(mError);
    builder.append(""; maxTextLength: "").append(mMaxTextLength);
    builder.append(""; contentDescription: "").append(mContentDescription);
    builder.append(""; tooltipText: "").append(mTooltipText);
    builder.append(""; viewIdResName: "").append(mViewIdResourceName);
    builder.append(""; checkable: "").append(isCheckable());
    builder.append(""; checked: "").append(isChecked());
    builder.append(""; focusable: "").append(isFocusable());
    builder.append(""; focused: "").append(isFocused());
    builder.append(""; selected: "").append(isSelected());
    builder.append(""; clickable: "").append(isClickable());
    builder.append(""; longClickable: "").append(isLongClickable());
    builder.append(""; contextClickable: "").append(isContextClickable());
    builder.append(""; enabled: "").append(isEnabled());
    builder.append(""; password: "").append(isPassword());
    builder.append(""; scrollable: "").append(isScrollable());
    builder.append(""; importantForAccessibility: "").append(isImportantForAccessibility());
    builder.append(""; visible: "").append(isVisibleToUser());
    builder.append(""; actions: "").append(mActions);
    return builder.toString();
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,,,,
68,"<android.bluetooth.BluetoothAdapter: boolean getProfileProxy(Context,ServiceListener,int)>",27,28,"<android.bluetooth.BluetoothAdapter: boolean getProfileProxy(Context,ServiceListener,int)>","<android.bluetooth.BluetoothAdapter: boolean getProfileProxy(Context,ServiceListener,int)>",0,"{
    if (context == null || listener == null)
        return false;
    if (profile == BluetoothProfile.HEADSET) {
        BluetoothHeadset headset = new BluetoothHeadset(context, listener);
        return true;
    } else if (profile == BluetoothProfile.A2DP) {
        BluetoothA2dp a2dp = new BluetoothA2dp(context, listener);
        return true;
    } else if (profile == BluetoothProfile.A2DP_SINK) {
        BluetoothA2dpSink a2dpSink = new BluetoothA2dpSink(context, listener);
        return true;
    } else if (profile == BluetoothProfile.AVRCP_CONTROLLER) {
        BluetoothAvrcpController avrcp = new BluetoothAvrcpController(context, listener);
        return true;
    } else if (profile == BluetoothProfile.INPUT_DEVICE) {
        BluetoothInputDevice iDev = new BluetoothInputDevice(context, listener);
        return true;
    } else if (profile == BluetoothProfile.PAN) {
        BluetoothPan pan = new BluetoothPan(context, listener);
        return true;
    } else if (profile == BluetoothProfile.HEALTH) {
        BluetoothHealth health = new BluetoothHealth(context, listener);
        return true;
    } else if (profile == BluetoothProfile.MAP) {
        BluetoothMap map = new BluetoothMap(context, listener);
        return true;
    } else if (profile == BluetoothProfile.HEADSET_CLIENT) {
        BluetoothHeadsetClient headsetClient = new BluetoothHeadsetClient(context, listener);
        return true;
    } else if (profile == BluetoothProfile.SAP) {
        BluetoothSap sap = new BluetoothSap(context, listener);
        return true;
    } else if (profile == BluetoothProfile.PBAP_CLIENT) {
        BluetoothPbapClient pbapClient = new BluetoothPbapClient(context, listener);
        return true;
    } else if (profile == BluetoothProfile.MAP_CLIENT) {
        BluetoothMapClient mapClient = new BluetoothMapClient(context, listener);
        return true;
    } else if (profile == BluetoothProfile.INPUT_HOST) {
        BluetoothInputHost iHost = new BluetoothInputHost(context, listener);
        return true;
    } else {
        return false;
    }
}","{
    if (context == null || listener == null) {
        return false;
    }
    if (profile == BluetoothProfile.HEADSET) {
        BluetoothHeadset headset = new BluetoothHeadset(context, listener);
        return true;
    } else if (profile == BluetoothProfile.A2DP) {
        BluetoothA2dp a2dp = new BluetoothA2dp(context, listener);
        return true;
    } else if (profile == BluetoothProfile.A2DP_SINK) {
        BluetoothA2dpSink a2dpSink = new BluetoothA2dpSink(context, listener);
        return true;
    } else if (profile == BluetoothProfile.AVRCP_CONTROLLER) {
        BluetoothAvrcpController avrcp = new BluetoothAvrcpController(context, listener);
        return true;
    } else if (profile == BluetoothProfile.HID_HOST) {
        BluetoothHidHost iDev = new BluetoothHidHost(context, listener);
        return true;
    } else if (profile == BluetoothProfile.PAN) {
        BluetoothPan pan = new BluetoothPan(context, listener);
        return true;
    } else if (profile == BluetoothProfile.HEALTH) {
        BluetoothHealth health = new BluetoothHealth(context, listener);
        return true;
    } else if (profile == BluetoothProfile.MAP) {
        BluetoothMap map = new BluetoothMap(context, listener);
        return true;
    } else if (profile == BluetoothProfile.HEADSET_CLIENT) {
        BluetoothHeadsetClient headsetClient = new BluetoothHeadsetClient(context, listener);
        return true;
    } else if (profile == BluetoothProfile.SAP) {
        BluetoothSap sap = new BluetoothSap(context, listener);
        return true;
    } else if (profile == BluetoothProfile.PBAP_CLIENT) {
        BluetoothPbapClient pbapClient = new BluetoothPbapClient(context, listener);
        return true;
    } else if (profile == BluetoothProfile.MAP_CLIENT) {
        BluetoothMapClient mapClient = new BluetoothMapClient(context, listener);
        return true;
    } else if (profile == BluetoothProfile.HID_DEVICE) {
        BluetoothHidDevice hidDevice = new BluetoothHidDevice(context, listener);
        return true;
    } else if (profile == BluetoothProfile.HEARING_AID) {
        BluetoothHearingAid hearingAid = new BluetoothHearingAid(context, listener);
        return true;
    } else {
        return false;
    }
}",1,"/**
 * Get the profile proxy object associated with the profile.
 *
 * <p>Profile can be one of {@link BluetoothProfile#HEALTH}, {@link BluetoothProfile#HEADSET},
 * {@link BluetoothProfile#A2DP}, {@link BluetoothProfile#GATT}, or
 * {@link BluetoothProfile#GATT_SERVER}. Clients must implement
 * {@link BluetoothProfile.ServiceListener} to get notified of
 * the connection status and to get the proxy object.
 *
 * @param context Context of the application
 * @param listener The service Listener for connection callbacks.
 * @param profile The Bluetooth profile; either {@link BluetoothProfile#HEALTH},
 * {@link BluetoothProfile#HEADSET}, {@link BluetoothProfile#A2DP}.
 * {@link BluetoothProfile#GATT} or {@link BluetoothProfile#GATT_SERVER}.
 * @return true on success, false on error
 */
","/**
 * Get the profile proxy object associated with the profile.
 *
 * <p>Profile can be one of {@link BluetoothProfile#HEALTH}, {@link BluetoothProfile#HEADSET},
 * {@link BluetoothProfile#A2DP}, {@link BluetoothProfile#GATT}, or
 * {@link BluetoothProfile#GATT_SERVER}. Clients must implement
 * {@link BluetoothProfile.ServiceListener} to get notified of
 * the connection status and to get the proxy object.
 *
 * @param context Context of the application
 * @param listener The service Listener for connection callbacks.
 * @param profile The Bluetooth profile; either {@link BluetoothProfile#HEALTH}, {@link
 * BluetoothProfile#HEADSET}, {@link BluetoothProfile#A2DP}. {@link BluetoothProfile#GATT} or
 * {@link BluetoothProfile#GATT_SERVER}.
 * @return true on success, false on error
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The implementation changed by removal, addition, and substitution of several instance creation lines corresponding to different `BluetoothProfile` values. These changes indicate that the dependent APIs are altered; the constructors for specific BluetoothProfile implementations (BluetoothInputDevice to BluetoothHidHost, and the addition of BluetoothHidDevice and BluetoothHearingAid, while removing BluetoothInputHost), which the current API relies upon, are adjusted. Therefore, this is a type 5 change.","There is no compatibility issue in terms of the behavior of the `getProfileProxy` method itself because it still returns a boolean value consistently and no new or different exceptions are thrown. The behavior of the method in terms of returning `true` for successfully getting a proxy to the given Bluetooth profile or `false` otherwise has not changed, despite the modification in the underlying profile implementations, which are handled within the method and do not alter its contract. Thus, the method does not cause a compatibility issue based on the criteria provided."
69,<android.app.AlarmManager: AlarmClockInfo getNextAlarmClock()>,27,28,<android.app.AlarmManager: AlarmClockInfo getNextAlarmClock()>,<android.app.AlarmManager: AlarmClockInfo getNextAlarmClock()>,0,"{
    return getNextAlarmClock(UserHandle.myUserId());
}","{
    return getNextAlarmClock(mContext.getUserId());
}",1,"/**
 * Gets information about the next alarm clock currently scheduled.
 *
 * The alarm clocks considered are those scheduled by any application
 * using the {@link #setAlarmClock} method.
 *
 * @return An {@link AlarmClockInfo} object describing the next upcoming alarm
 * clock event that will occur.  If there are no alarm clock events currently
 * scheduled, this method will return {@code null}.
 *
 * @see #setAlarmClock
 * @see AlarmClockInfo
 * @see #ACTION_NEXT_ALARM_CLOCK_CHANGED
 */
","/**
 * Gets information about the next alarm clock currently scheduled.
 *
 * The alarm clocks considered are those scheduled by any application
 * using the {@link #setAlarmClock} method.
 *
 * @return An {@link AlarmClockInfo} object describing the next upcoming alarm
 * clock event that will occur.  If there are no alarm clock events currently
 * scheduled, this method will return {@code null}.
 *
 * @see #setAlarmClock
 * @see AlarmClockInfo
 * @see #ACTION_NEXT_ALARM_CLOCK_CHANGED
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,The method getNextAlarmClock() is called with a different argument (UserHandle.myUserId() vs mContext.getUserId()). The change type is 5.,"There is no Compatibility Issue detected since the implementation is inherently dependent on the user ID context, and such changes are typically made to reflect internal API updates to manage user-related information consistently. This change does not indicate a difference in the behavior of the method's outward contract but rather an update in how the user context is acquired internally."
70,<android.bluetooth.BluetoothGattServer: BluetoothGattDescriptor getDescriptorByHandle(int)>,27,28,<android.bluetooth.BluetoothGattServer: BluetoothGattDescriptor getDescriptorByHandle(int)>,<android.bluetooth.BluetoothGattServer: BluetoothGattDescriptor getDescriptorByHandle(int)>,0,"{
    for (BluetoothGattService svc : mServices) {
        for (BluetoothGattCharacteristic charac : svc.getCharacteristics()) {
            for (BluetoothGattDescriptor desc : charac.getDescriptors()) {
                if (desc.getInstanceId() == handle)
                    return desc;
            }
        }
    }
    return null;
}","{
    for (BluetoothGattService svc : mServices) {
        for (BluetoothGattCharacteristic charac : svc.getCharacteristics()) {
            for (BluetoothGattDescriptor desc : charac.getDescriptors()) {
                if (desc.getInstanceId() == handle) {
                    return desc;
                }
            }
        }
    }
    return null;
}",1,"/*package*/
","/*package*/
",-1,,,-1,-1,-1,-1,-1,-1,0,0,"There are no changes in the code other than formatting, specifically the addition of braces around the return statement within the 'if' block.",There is no Compatibility Issue since only the code format has changed but the logic and behavior of the code remain the same.
71,<android.content.ContentResolver: void removeStatusChangeListener(Object)>,27,28,<android.content.ContentResolver: void removeStatusChangeListener(Object)>,<android.content.ContentResolver: void removeStatusChangeListener(Object)>,0,"{
    if (handle == null) {
        throw new IllegalArgumentException(""you passed in a null handle"");
    }
    try {
        getContentService().removeStatusChangeListener((ISyncStatusObserver.Stub) handle);
    } catch (RemoteException e) {
    // exception ignored; if this is thrown then it means the runtime is in the midst of
    // being restarted
    }
}","{
    if (handle == null) {
        throw new IllegalArgumentException(""you passed in a null handle"");
    }
    try {
        getContentService().removeStatusChangeListener((ISyncStatusObserver.Stub) handle);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Remove a previously registered status change listener.
 * @param handle the handle that was returned by {@link #addStatusChangeListener}
 */
","/**
 * Remove a previously registered status change listener.
 * @param handle the handle that was returned by {@link #addStatusChangeListener}
 */
",-1,,,-1,-1,-1,-1,-1,-1,2,2,"The exception handling statement has changed: in the late version, an exception is now thrown where previously it was ignored, so the change type is 2.","As the late version of the API now throws a `RemoteException` wrapped with `rethrowFromSystemServer()` where previously it silently ignored the exception, there is a possibility that the late version will behave differently under the same conditions. This change could potentially lead to different exception handlings, constituting a CI of type 2."
72,<android.view.WindowInsets: boolean isConsumed()>,27,28,<android.view.WindowInsets: boolean isConsumed()>,<android.view.WindowInsets: boolean isConsumed()>,0,"{
    return mSystemWindowInsetsConsumed && mWindowDecorInsetsConsumed && mStableInsetsConsumed;
}","{
    return mSystemWindowInsetsConsumed && mWindowDecorInsetsConsumed && mStableInsetsConsumed && mDisplayCutoutConsumed;
}",1,"/**
 * Check if these insets have been fully consumed.
 *
 * <p>Insets are considered ""consumed"" if the applicable <code>consume*</code> methods
 * have been called such that all insets have been set to zero. This affects propagation of
 * insets through the view hierarchy; insets that have not been fully consumed will continue
 * to propagate down to child views.</p>
 *
 * <p>The result of this method is equivalent to the return value of
 * {@link View#fitSystemWindows(android.graphics.Rect)}.</p>
 *
 * @return true if the insets have been fully consumed.
 */
","/**
 * Check if these insets have been fully consumed.
 *
 * <p>Insets are considered ""consumed"" if the applicable <code>consume*</code> methods
 * have been called such that all insets have been set to zero. This affects propagation of
 * insets through the view hierarchy; insets that have not been fully consumed will continue
 * to propagate down to child views.</p>
 *
 * <p>The result of this method is equivalent to the return value of
 * {@link View#fitSystemWindows(android.graphics.Rect)}.</p>
 *
 * @return true if the insets have been fully consumed.
 */
",-1,,,-1,-1,-1,-1,-1,-1,1,1,"The return statement's logic has been extended by adding an additional condition, thus changing the composition of the boolean value returned, so the code change type is 1.","As the additional boolean condition can alter the output of the API (returning true or false), this could lead to a Compatibility Issue where the API might return a different value, so the CI type is 1."
74,"<android.content.res.AssetManager: XmlResourceParser openXmlResourceParser(int,String)>",27,28,"<android.content.res.AssetManager: XmlResourceParser openXmlResourceParser(int,String)>","<android.content.res.AssetManager: XmlResourceParser openXmlResourceParser(int,String)>",0,"{
    XmlBlock block = openXmlBlockAsset(cookie, fileName);
    XmlResourceParser rp = block.newParser();
    block.close();
    return rp;
}","{
    try (XmlBlock block = openXmlBlockAsset(cookie, fileName)) {
        XmlResourceParser parser = block.newParser();
        // be paranoid.
        if (parser == null) {
            throw new AssertionError(""block.newParser() returned a null parser"");
        }
        return parser;
    }
}",1,"/**
 * Retrieve a parser for a compiled XML file.
 *
 * @param cookie Identifier of the package to be opened.
 * @param fileName The name of the file to retrieve.
 */
","/**
 * Retrieve a parser for a compiled XML file.
 *
 * @param cookie Identifier of the package to be opened.
 * @param fileName The name of the file to retrieve.
 */
",-1,,[@NonNull],-1,-1,-1,-1,-1,-1,"1,3,4","1,2","The late implementation introduces a try-with-resources block which creates an implicit 'finally' block that ensures the 'XmlBlock' resource is closed, an additional null check with a throw statement for 'parser', and a removal of the explicit 'block.close()' statement. Therefore, the code change types are 1, 3, and 4.","The additional check for the 'parser' being null could throw an AssertionError which was not present in the early version. This constitutes a change in exception handling, thus causing a CI type 2. Furthermore, the usage of try-with-resources could potentially result in different behavior if the 'close()' method of 'XmlBlock' has side effects that affect the 'parser', resulting in a CI type 1."
75,<android.net.IpSecManager.SecurityParameterIndex: void close()>,27,28,<android.net.IpSecManager.SecurityParameterIndex: void close()>,<android.net.IpSecManager.SecurityParameterIndex: void close()>,0,"{
    try {
        mService.releaseSecurityParameterIndex(mResourceId);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
    mCloseGuard.close();
}","{
    try {
        mService.releaseSecurityParameterIndex(mResourceId);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    } catch (Exception e) {
        // On close we swallow all random exceptions since failure to close is not
        // actionable by the user.
        Log.e(TAG, ""Failed to close "" + this + "", Exception="" + e);
    } finally {
        mResourceId = INVALID_RESOURCE_ID;
        mCloseGuard.close();
    }
}",1,"/**
 * Release an SPI that was previously reserved.
 *
 * <p>Release an SPI for use by other users in the system. If a SecurityParameterIndex is
 * applied to an IpSecTransform, it will become unusable for future transforms but should
 * still be closed to ensure system resources are released.
 */
","/**
 * Release an SPI that was previously reserved.
 *
 * <p>Release an SPI for use by other users in the system. If a SecurityParameterIndex is
 * applied to an IpSecTransform, it will become unusable for future transforms but should
 * still be closed to ensure system resources are released.
 */
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"2,3,4",0,"An additional catch block for generic Exception has been added and a new finally block is introduced to set mResourceId to INVALID_RESOURCE_ID and call mCloseGuard.close(). The change types are 2 (for the new exception handling), 3 (for the new control structure), and 4 (for other changes in the finally block).","The addition of a generic Exception catch block and the finally block do not lead to a different behavior with respect to what the API returns or the exceptions it throws under normal operation (the finally block will always execute, but the setting of the mResourceId to INVALID_RESOURCE_ID is an internal state change and does not affect the functionality of the close() method as seen by the caller). As such, the new catch block is designed specifically to log and swallow exceptions (not change exception throwing behavior) and the finally block ensures the internal state is cleaned up properly. As a result, these changes do not cause any Compatibility Issue."
76,<android.view.TextureView: Bitmap getBitmap(Bitmap)>,27,28,<android.view.TextureView: Bitmap getBitmap(Bitmap)>,<android.view.TextureView: Bitmap getBitmap(Bitmap)>,0,"{
    if (bitmap != null && isAvailable()) {
        applyUpdate();
        applyTransformMatrix();
        // this method
        if (mLayer == null && mUpdateSurface) {
            getHardwareLayer();
        }
        if (mLayer != null) {
            mLayer.copyInto(bitmap);
        }
    }
    return bitmap;
}","{
    if (bitmap != null && isAvailable()) {
        applyUpdate();
        applyTransformMatrix();
        // this method
        if (mLayer == null && mUpdateSurface) {
            getTextureLayer();
        }
        if (mLayer != null) {
            mLayer.copyInto(bitmap);
        }
    }
    return bitmap;
}",1,"/**
 * <p>Copies the content of this view's surface texture into the specified
 * bitmap. If the surface texture is not available, the copy is not executed.
 * The content of the surface texture will be scaled to fit exactly inside
 * the specified bitmap.</p>
 *
 * <p><strong>Do not</strong> invoke this method from a drawing method
 * ({@link #onDraw(android.graphics.Canvas)} for instance).</p>
 *
 * <p>If an error occurs, the bitmap is left unchanged.</p>
 *
 * @param bitmap The bitmap to copy the content of the surface texture into,
 * cannot be null, all configurations are supported
 *
 * @return The bitmap specified as a parameter
 *
 * @see #isAvailable()
 * @see #getBitmap(int, int)
 * @see #getBitmap()
 *
 * @throws IllegalStateException if the hardware rendering context cannot be
 * acquired to capture the bitmap
 */
","/**
 * <p>Copies the content of this view's surface texture into the specified
 * bitmap. If the surface texture is not available, the copy is not executed.
 * The content of the surface texture will be scaled to fit exactly inside
 * the specified bitmap.</p>
 *
 * <p><strong>Do not</strong> invoke this method from a drawing method
 * ({@link #onDraw(android.graphics.Canvas)} for instance).</p>
 *
 * <p>If an error occurs, the bitmap is left unchanged.</p>
 *
 * @param bitmap The bitmap to copy the content of the surface texture into,
 * cannot be null, all configurations are supported
 *
 * @return The bitmap specified as a parameter
 *
 * @see #isAvailable()
 * @see #getBitmap(int, int)
 * @see #getBitmap()
 *
 * @throws IllegalStateException if the hardware rendering context cannot be
 * acquired to capture the bitmap
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"The only change between the two versions is the call to a different method: early implementation calls getHardwareLayer(), while the late implementation calls getTextureLayer(). This means there's a change to a dependent API, which is change type 5. Aside from the method name change, there are no other statement changes that could be classified as 1, 2, or 3. However, since the return value has not changed, and no new control statements or exception handling code is introduced, nor is there any evidence provided that the changed method would affect the return value of getBitmap, this is also an example of change type 4 (Other statement changed).","Because the code change does not alter the return type or value of the method, nor does it introduce different exceptions that should be thrown, there is no compatibility issue identified, contributing to classification 0 (No Compatibility Issue). Remember that even if a dependent API changes or there's an update to a method call, this does not automatically imply a compatibility issue unless it is evident that the new behavior would result in a change in the return value or a change in exceptions thrown by the method."
77,<android.app.ActivityThread.ActivityClientRecord: String getStateString()>,27,28,<android.app.ActivityThread.ActivityClientRecord: String getStateString()>,<android.app.ActivityThread.ActivityClientRecord: String getStateString()>,0,"{
    StringBuilder sb = new StringBuilder();
    sb.append(""ActivityClientRecord{"");
    sb.append(""paused="").append(paused);
    sb.append("", stopped="").append(stopped);
    sb.append("", hideForNow="").append(hideForNow);
    sb.append("", startsNotResumed="").append(startsNotResumed);
    sb.append("", isForward="").append(isForward);
    sb.append("", pendingConfigChanges="").append(pendingConfigChanges);
    sb.append("", onlyLocalRequest="").append(onlyLocalRequest);
    sb.append("", preserveWindow="").append(mPreserveWindow);
    if (activity != null) {
        sb.append("", Activity{"");
        sb.append(""resumed="").append(activity.mResumed);
        sb.append("", stopped="").append(activity.mStopped);
        sb.append("", finished="").append(activity.isFinishing());
        sb.append("", destroyed="").append(activity.isDestroyed());
        sb.append("", startedActivity="").append(activity.mStartedActivity);
        sb.append("", temporaryPause="").append(activity.mTemporaryPause);
        sb.append("", changingConfigurations="").append(activity.mChangingConfigurations);
        sb.append(""}"");
    }
    sb.append(""}"");
    return sb.toString();
}","{
    StringBuilder sb = new StringBuilder();
    sb.append(""ActivityClientRecord{"");
    sb.append(""paused="").append(paused);
    sb.append("", stopped="").append(stopped);
    sb.append("", hideForNow="").append(hideForNow);
    sb.append("", startsNotResumed="").append(startsNotResumed);
    sb.append("", isForward="").append(isForward);
    sb.append("", pendingConfigChanges="").append(pendingConfigChanges);
    sb.append("", preserveWindow="").append(mPreserveWindow);
    if (activity != null) {
        sb.append("", Activity{"");
        sb.append(""resumed="").append(activity.mResumed);
        sb.append("", stopped="").append(activity.mStopped);
        sb.append("", finished="").append(activity.isFinishing());
        sb.append("", destroyed="").append(activity.isDestroyed());
        sb.append("", startedActivity="").append(activity.mStartedActivity);
        sb.append("", temporaryPause="").append(activity.mTemporaryPause);
        sb.append("", changingConfigurations="").append(activity.mChangingConfigurations);
        sb.append(""}"");
    }
    sb.append(""}"");
    return sb.toString();
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,0,0,There is no change between the early and late version of the code implementation.,There is no Compatibility Issue since there are no changes in the code.
78,<android.text.SpannableStringInternal: void removeSpan(Object)>,27,28,<android.text.SpannableStringInternal: void removeSpan(Object)>,<android.text.SpannableStringInternal: void removeSpan(Object)>,0,"{
    int count = mSpanCount;
    Object[] spans = mSpans;
    int[] data = mSpanData;
    for (int i = count - 1; i >= 0; i--) {
        if (spans[i] == what) {
            int ostart = data[i * COLUMNS + START];
            int oend = data[i * COLUMNS + END];
            int c = count - (i + 1);
            System.arraycopy(spans, i + 1, spans, i, c);
            System.arraycopy(data, (i + 1) * COLUMNS, data, i * COLUMNS, c * COLUMNS);
            mSpanCount--;
            sendSpanRemoved(what, ostart, oend);
            return;
        }
    }
}","{
    removeSpan(what, 0);
}",1,"/* package */
","/* package */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"The entire body of the method has been replaced by a call to a new method with an additional parameter, so the code change type is 4,5.","The change delegates the logic to a newly overloaded method removeSpan(Object, int), as long as the new method preserves the behavior of the original method when called with the correct arguments, there should be no Compatibility Issue in terms of return values or exception handlings. The internal implementation change does not affect the API's external contract; therefore, the CI type is 0."
79,<android.hardware.radio.RadioManager.ProgramInfo: boolean isStereo()>,27,28,<android.hardware.radio.RadioManager.ProgramInfo: boolean isStereo()>,<android.hardware.radio.RadioManager.ProgramInfo: boolean isStereo()>,0,"{
    return mStereo;
}","{
    return (mInfoFlags & FLAG_STEREO) != 0;
}",1,"/**
 * {@code true} if the received program is stereo
 * @return {@code true} if stereo, {@code false} otherwise.
 */
","/**
 * {@code true} if the received program is stereo
 * @return {@code true} if stereo, {@code false} otherwise.
 */
",-1,,,-1,-1,-1,-1,-1,-1,1,1,"The implementation of the method has changed from returning a simple boolean member 'mStereo' to evaluating an expression involving a bitwise AND operation with 'mInfoFlags' and 'FLAG_STEREO', therefore the code change type is 1.","The method could potentially return a different value because the logic for determining if the program is stereo has changed, hence the compatibility issue is of type 1."
80,<android.hardware.radio.RadioManager.ModuleProperties: int hashCode()>,27,28,<android.hardware.radio.RadioManager.ModuleProperties: int hashCode()>,<android.hardware.radio.RadioManager.ModuleProperties: int hashCode()>,0,"{
    final int prime = 31;
    int result = 1;
    result = prime * result + mId;
    result = prime * result + mServiceName.hashCode();
    result = prime * result + mClassId;
    result = prime * result + ((mImplementor == null) ? 0 : mImplementor.hashCode());
    result = prime * result + ((mProduct == null) ? 0 : mProduct.hashCode());
    result = prime * result + ((mVersion == null) ? 0 : mVersion.hashCode());
    result = prime * result + ((mSerial == null) ? 0 : mSerial.hashCode());
    result = prime * result + mNumTuners;
    result = prime * result + mNumAudioSources;
    result = prime * result + (mIsCaptureSupported ? 1 : 0);
    result = prime * result + Arrays.hashCode(mBands);
    result = prime * result + (mIsBgScanSupported ? 1 : 0);
    result = prime * result + mVendorInfo.hashCode();
    return result;
}","{
    return Objects.hash(mId, mServiceName, mClassId, mImplementor, mProduct, mVersion, mSerial, mNumTuners, mNumAudioSources, mIsInitializationRequired, mIsCaptureSupported, mBands, mIsBgScanSupported, mDabFrequencyTable, mVendorInfo);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,5",1,"The implementation of the hashCode method has been completely changed from a manual computation of the hash code to using the Objects.hash method and new fields (mIsInitializationRequired, mDabFrequencyTable) are added. This constitutes a change in the dependent API from Arrays.hashCode to Objects.hash along with the new fields added to the hash computation. Therefore, the change types are 1 and 5.","As the hashCode computation logic has been modified and is now incorporating additional fields that were not present before, objects of ModuleProperties class could have different hash codes between the two versions. This change will potentially lead to different return values when compared with hash codes generated by the earlier implementation, hence the Compatibility Issue type is 1."
81,<android.view.textclassifier.TextClassification.Builder: Builder setOnClickListener(OnClickListener)>,27,28,<android.view.textclassifier.TextClassification.Builder: Builder setOnClickListener(OnClickListener)>,<android.view.textclassifier.TextClassification.Builder: Builder setOnClickListener(OnClickListener)>,0,"{
    mOnClickListener = onClickListener;
    return this;
}","{
    mLegacyOnClickListener = onClickListener;
    return this;
}",1,"/**
 * Sets an OnClickListener that may be triggered to act on the classified text.
 */
","/**
 * Sets the OnClickListener for the <i>primary</i> action that may be triggered to act on
 * the classified text.
 *
 * <p><strong>NOTE: </strong>This field is not parcelable. If read from a parcel, the
 * returned OnClickListener represents the first {@link RemoteAction} (if one exists).
 *
 * @deprecated Use {@link #addAction(RemoteAction)} instead.
 */
",-1,,"[@Deprecated, @NonNull]",-1,-1,-1,-1,-1,-1,4,0,"The field where the onClickListener is set has changed from mOnClickListener to mLegacyOnClickListener. There is no change in the method's control flow, return type, or exception handling, hence the change type is 4.","The change does not affect the return type or value, nor does it introduce any new exception handling. It is an internal change that assigns the provided listener to a different field. Assuming that the method's contract and behavior remain as expected, there is no compatibility issue, despite the field being changed, so the CI type is 0."
82,<android.app.ActivityManager: List<RunningTaskInfo> getRunningTasks(int)>,27,28,<android.app.ActivityManager: List<RunningTaskInfo> getRunningTasks(int)>,<android.app.ActivityManager: List<RunningTaskInfo> getRunningTasks(int)>,0,"{
    try {
        return getService().getTasks(maxNum, 0);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}","{
    try {
        return getService().getTasks(maxNum);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Return a list of the tasks that are currently running, with
 * the most recent being first and older ones after in order.  Note that
 * ""running"" does not mean any of the task's code is currently loaded or
 * activity -- the task may have been frozen by the system, so that it
 * can be restarted in its previous state when next brought to the
 * foreground.
 *
 * <p><b>Note: this method is only intended for debugging and presenting
 * task management user interfaces</b>.  This should never be used for
 * core logic in an application, such as deciding between different
 * behaviors based on the information found here.  Such uses are
 * <em>not</em> supported, and will likely break in the future.  For
 * example, if multiple applications can be actively running at the
 * same time, assumptions made about the meaning of the data here for
 * purposes of control flow will be incorrect.</p>
 *
 * @deprecated As of {@link android.os.Build.VERSION_CODES#LOLLIPOP}, this method
 * is no longer available to third party
 * applications: the introduction of document-centric recents means
 * it can leak person information to the caller.  For backwards compatibility,
 * it will still retu rn a small subset of its data: at least the caller's
 * own tasks, and possibly some other tasks
 * such as home that are known to not be sensitive.
 *
 * @param maxNum The maximum number of entries to return in the list.  The
 * actual number returned may be smaller, depending on how many tasks the
 * user has started.
 *
 * @return Returns a list of RunningTaskInfo records describing each of
 * the running tasks.
 */
","/**
 * Return a list of the tasks that are currently running, with
 * the most recent being first and older ones after in order.  Note that
 * ""running"" does not mean any of the task's code is currently loaded or
 * activity -- the task may have been frozen by the system, so that it
 * can be restarted in its previous state when next brought to the
 * foreground.
 *
 * <p><b>Note: this method is only intended for debugging and presenting
 * task management user interfaces</b>.  This should never be used for
 * core logic in an application, such as deciding between different
 * behaviors based on the information found here.  Such uses are
 * <em>not</em> supported, and will likely break in the future.  For
 * example, if multiple applications can be actively running at the
 * same time, assumptions made about the meaning of the data here for
 * purposes of control flow will be incorrect.</p>
 *
 * @deprecated As of {@link android.os.Build.VERSION_CODES#LOLLIPOP}, this method
 * is no longer available to third party
 * applications: the introduction of document-centric recents means
 * it can leak person information to the caller.  For backwards compatibility,
 * it will still return a small subset of its data: at least the caller's
 * own tasks, and possibly some other tasks
 * such as home that are known to not be sensitive.
 *
 * @param maxNum The maximum number of entries to return in the list.  The
 * actual number returned may be smaller, depending on how many tasks the
 * user has started.
 *
 * @return Returns a list of RunningTaskInfo records describing each of
 * the running tasks.
 */
",-1,[@Deprecated],[@Deprecated],-1,-1,-1,-1,-1,-1,5,0,"The number of parameters in the call to getService().getTasks() is reduced from two to one, indicating a change in a dependent API, therefore the code change type is 5.","There is no indication that the behavior of the API has changed aside from the change in the dependent API's parameters. The exception handling remains the same, and there is no change to the return statement itself, hence there's no Compatibility Issue, so the CI type is 0."
84,<android.app.UiAutomation: ParcelFileDescriptor executeShellCommand(String)>,27,28,<android.app.UiAutomation: ParcelFileDescriptor executeShellCommand(String)>,<android.app.UiAutomation: ParcelFileDescriptor executeShellCommand(String)>,0,"{
    synchronized (mLock) {
        throwIfNotConnectedLocked();
    }
    ParcelFileDescriptor source = null;
    ParcelFileDescriptor sink = null;
    try {
        ParcelFileDescriptor[] pipe = ParcelFileDescriptor.createPipe();
        source = pipe[0];
        sink = pipe[1];
        // Calling out without a lock held.
        mUiAutomationConnection.executeShellCommand(command, sink, null);
    } catch (IOException ioe) {
        Log.e(LOG_TAG, ""Error executing shell command!"", ioe);
    } catch (RemoteException re) {
        Log.e(LOG_TAG, ""Error executing shell command!"", re);
    } finally {
        IoUtils.closeQuietly(sink);
    }
    return source;
}","{
    synchronized (mLock) {
        throwIfNotConnectedLocked();
    }
    warnIfBetterCommand(command);
    ParcelFileDescriptor source = null;
    ParcelFileDescriptor sink = null;
    try {
        ParcelFileDescriptor[] pipe = ParcelFileDescriptor.createPipe();
        source = pipe[0];
        sink = pipe[1];
        // Calling out without a lock held.
        mUiAutomationConnection.executeShellCommand(command, sink, null);
    } catch (IOException ioe) {
        Log.e(LOG_TAG, ""Error executing shell command!"", ioe);
    } catch (RemoteException re) {
        Log.e(LOG_TAG, ""Error executing shell command!"", re);
    } finally {
        IoUtils.closeQuietly(sink);
    }
    return source;
}",1,"/**
 * Executes a shell command. This method returns a file descriptor that points
 * to the standard output stream. The command execution is similar to running
 * ""adb shell <command>"" from a host connected to the device.
 * <p>
 * <strong>Note:</strong> It is your responsibility to close the returned file
 * descriptor once you are done reading.
 * </p>
 *
 * @param command The command to execute.
 * @return A file descriptor to the standard output stream.
 */
","/**
 * Executes a shell command. This method returns a file descriptor that points
 * to the standard output stream. The command execution is similar to running
 * ""adb shell <command>"" from a host connected to the device.
 * <p>
 * <strong>Note:</strong> It is your responsibility to close the returned file
 * descriptor once you are done reading.
 * </p>
 *
 * @param command The command to execute.
 * @return A file descriptor to the standard output stream.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The method warnIfBetterCommand(command); is added before trying to create and use a 'pipe', which is a new statement not altering the original flow of control, return values, or exception handling. Therefore, the code change type is 4.",The addition of the warnIfBetterCommand(command); method call does not introduce a change in the APIs behavior regarding what it returns or the exceptions it throws. It appears to be a simple warning check that does not affect the output of the existing code; thus there is no Compatibility Issue in this change.
85,"<android.widget.Editor.TextActionModeCallback: boolean onActionItemClicked(ActionMode,MenuItem)>",27,28,"<android.widget.Editor.TextActionModeCallback: boolean onActionItemClicked(ActionMode,MenuItem)>","<android.widget.Editor.TextActionModeCallback: boolean onActionItemClicked(ActionMode,MenuItem)>",0,"{
    getSelectionActionModeHelper().onSelectionAction(item.getItemId());
    if (mProcessTextIntentActionsHandler.performMenuItemAction(item)) {
        return true;
    }
    Callback customCallback = getCustomCallback();
    if (customCallback != null && customCallback.onActionItemClicked(mode, item)) {
        return true;
    }
    final TextClassification textClassification = getSelectionActionModeHelper().getTextClassification();
    if (TextView.ID_ASSIST == item.getItemId() && textClassification != null) {
        final OnClickListener onClickListener = textClassification.getOnClickListener();
        if (onClickListener != null) {
            onClickListener.onClick(mTextView);
        } else {
            final Intent intent = textClassification.getIntent();
            if (intent != null) {
                TextClassification.createStartActivityOnClickListener(mTextView.getContext(), intent).onClick(mTextView);
            }
        }
        mMetricsLogger.action(MetricsEvent.ACTION_TEXT_SELECTION_MENU_ITEM_ASSIST, textClassification.getLogType());
        stopTextActionMode();
        return true;
    }
    return mTextView.onTextContextMenuItem(item.getItemId());
}","{
    getSelectionActionModeHelper().onSelectionAction(item.getItemId());
    if (mProcessTextIntentActionsHandler.performMenuItemAction(item)) {
        return true;
    }
    Callback customCallback = getCustomCallback();
    if (customCallback != null && customCallback.onActionItemClicked(mode, item)) {
        return true;
    }
    if (item.getGroupId() == TextView.ID_ASSIST && onAssistMenuItemClicked(item)) {
        return true;
    }
    return mTextView.onTextContextMenuItem(item.getItemId());
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,3",1,"The control dependency related to checking TextView.ID_ASSIST and the handling of the action after that has been encapsulated within a method call onAssistMenuItemClicked(item). The body of the conditional block associated with TextView.ID_ASSIST has been removed and the call to a new method with a different control structure suggest a change type of 1,3.","As the method for handling the assist action has been extracted to a separate method call and the condition to check the `item.getGroupId()` has changed, the behavior of what happens when an assist menu item is clicked could be altered. This constitutes a return statement change since it can return a different outcome based on the newly introduced method, leading to CI type 1."
87,<android.bluetooth.BluetoothDevice: BluetoothSocket createInsecureRfcommSocketToServiceRecord(UUID)>,27,28,<android.bluetooth.BluetoothDevice: BluetoothSocket createInsecureRfcommSocketToServiceRecord(UUID)>,<android.bluetooth.BluetoothDevice: BluetoothSocket createInsecureRfcommSocketToServiceRecord(UUID)>,0,"{
    if (isBluetoothEnabled() == false) {
        Log.e(TAG, ""Bluetooth is not enabled"");
        throw new IOException();
    }
    return new BluetoothSocket(BluetoothSocket.TYPE_RFCOMM, -1, false, false, this, -1, new ParcelUuid(uuid));
}","{
    if (!isBluetoothEnabled()) {
        Log.e(TAG, ""Bluetooth is not enabled"");
        throw new IOException();
    }
    return new BluetoothSocket(BluetoothSocket.TYPE_RFCOMM, -1, false, false, this, -1, new ParcelUuid(uuid));
}",1,"/**
 * Create an RFCOMM {@link BluetoothSocket} socket ready to start an insecure
 * outgoing connection to this remote device using SDP lookup of uuid.
 * <p> The communication channel will not have an authenticated link key
 * i.e it will be subject to man-in-the-middle attacks. For Bluetooth 2.1
 * devices, the link key will be encrypted, as encryption is mandatory.
 * For legacy devices (pre Bluetooth 2.1 devices) the link key will
 * be not be encrypted. Use {@link #createRfcommSocketToServiceRecord} if an
 * encrypted and authenticated communication channel is desired.
 * <p>This is designed to be used with {@link
 * BluetoothAdapter#listenUsingInsecureRfcommWithServiceRecord} for peer-peer
 * Bluetooth applications.
 * <p>Use {@link BluetoothSocket#connect} to initiate the outgoing
 * connection. This will also perform an SDP lookup of the given uuid to
 * determine which channel to connect to.
 * <p>The remote device will be authenticated and communication on this
 * socket will be encrypted.
 * <p>Hint: If you are connecting to a Bluetooth serial board then try
 * using the well-known SPP UUID 00001101-0000-1000-8000-00805F9B34FB.
 * However if you are connecting to an Android peer then please generate
 * your own unique UUID.
 *
 * @param uuid service record uuid to lookup RFCOMM channel
 * @return a RFCOMM BluetoothServerSocket ready for an outgoing connection
 * @throws IOException on error, for example Bluetooth not available, or
 * insufficient permissions
 */
","/**
 * Create an RFCOMM {@link BluetoothSocket} socket ready to start an insecure
 * outgoing connection to this remote device using SDP lookup of uuid.
 * <p> The communication channel will not have an authenticated link key
 * i.e it will be subject to man-in-the-middle attacks. For Bluetooth 2.1
 * devices, the link key will be encrypted, as encryption is mandatory.
 * For legacy devices (pre Bluetooth 2.1 devices) the link key will
 * be not be encrypted. Use {@link #createRfcommSocketToServiceRecord} if an
 * encrypted and authenticated communication channel is desired.
 * <p>This is designed to be used with {@link
 * BluetoothAdapter#listenUsingInsecureRfcommWithServiceRecord} for peer-peer
 * Bluetooth applications.
 * <p>Use {@link BluetoothSocket#connect} to initiate the outgoing
 * connection. This will also perform an SDP lookup of the given uuid to
 * determine which channel to connect to.
 * <p>The remote device will be authenticated and communication on this
 * socket will be encrypted.
 * <p>Hint: If you are connecting to a Bluetooth serial board then try
 * using the well-known SPP UUID 00001101-0000-1000-8000-00805F9B34FB.
 * However if you are connecting to an Android peer then please generate
 * your own unique UUID.
 *
 * @param uuid service record uuid to lookup RFCOMM channel
 * @return a RFCOMM BluetoothServerSocket ready for an outgoing connection
 * @throws IOException on error, for example Bluetooth not available, or insufficient
 * permissions
 */
",-1,[@RequiresPermission(Manifest.permission.BLUETOOTH)],[@RequiresPermission(Manifest.permission.BLUETOOTH)],-1,-1,-1,-1,-1,-1,0,0,"The implementation is essentially the same between the two versions, with only a change in the syntax of the condition (`if (isBluetoothEnabled() == false)` changed to `if (!isBluetoothEnabled())`). This does not result in any change in behavior.","No Compatibility Issue exists because there's no change in the method signature, return type, thrown exceptions, or any functional part of the implementation. The change doesn't result in any different behavior when executing the API."
88,<android.view.View: void autofill(SparseArray<AutofillValue>)>,27,28,<android.view.View: void autofill(SparseArray<AutofillValue>)>,<android.view.View: void autofill(SparseArray<AutofillValue>)>,0,"{
}","{
    if (!mContext.isAutofillCompatibilityEnabled()) {
        return;
    }
    final AccessibilityNodeProvider provider = getAccessibilityNodeProvider();
    if (provider == null) {
        return;
    }
    final int valueCount = values.size();
    for (int i = 0; i < valueCount; i++) {
        final AutofillValue value = values.valueAt(i);
        if (value.isText()) {
            final int virtualId = values.keyAt(i);
            final CharSequence text = value.getTextValue();
            final Bundle arguments = new Bundle();
            arguments.putCharSequence(AccessibilityNodeInfo.ACTION_ARGUMENT_SET_TEXT_CHARSEQUENCE, text);
            provider.performAction(virtualId, AccessibilityNodeInfo.ACTION_SET_TEXT, arguments);
        }
    }
}",1,"/**
 * Automatically fills the content of the virtual children within this view.
 *
 * <p>Views with virtual children support the Autofill Framework mainly by:
 * <ul>
 * <li>Providing the metadata defining what the virtual children mean and how they can be
 * autofilled.
 * <li>Implementing the methods that autofill the virtual children.
 * </ul>
 * <p>{@link #onProvideAutofillVirtualStructure(ViewStructure, int)} is responsible for the
 * former, this method is responsible for the latter - see {@link #autofill(AutofillValue)} and
 * {@link #onProvideAutofillVirtualStructure(ViewStructure, int)} for more info about autofill.
 *
 * <p>If a child value is updated asynchronously, the next call to
 * {@link AutofillManager#notifyValueChanged(View, int, AutofillValue)} must happen
 * <b>after</b> the value was changed to the autofilled value. If not, the child will not be
 * considered autofilled.
 *
 * <p><b>Note:</b> To indicate that a virtual view was autofilled,
 * <code>?android:attr/autofilledHighlight</code> should be drawn over it until the data
 * changes.
 *
 * @param values map of values to be autofilled, keyed by virtual child id.
 *
 * @attr ref android.R.styleable#Theme_autofilledHighlight
 */
","/**
 * Automatically fills the content of the virtual children within this view.
 *
 * <p>Views with virtual children support the Autofill Framework mainly by:
 * <ul>
 * <li>Providing the metadata defining what the virtual children mean and how they can be
 * autofilled.
 * <li>Implementing the methods that autofill the virtual children.
 * </ul>
 * <p>{@link #onProvideAutofillVirtualStructure(ViewStructure, int)} is responsible for the
 * former, this method is responsible for the latter - see {@link #autofill(AutofillValue)} and
 * {@link #onProvideAutofillVirtualStructure(ViewStructure, int)} for more info about autofill.
 *
 * <p>If a child value is updated asynchronously, the next call to
 * {@link AutofillManager#notifyValueChanged(View, int, AutofillValue)} must happen
 * <b>after</b> the value was changed to the autofilled value. If not, the child will not be
 * considered autofilled.
 *
 * <p><b>Note:</b> To indicate that a virtual view was autofilled,
 * <code>?android:attr/autofilledHighlight</code> should be drawn over it until the data
 * changes.
 *
 * @param values map of values to be autofilled, keyed by virtual child id.
 *
 * @attr ref android.R.styleable#Theme_autofilledHighlight
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",1,"The late version introduces new control structures (an if-statement and a for-loop), and adds method calls inside the loop. Matching with the given classification, we see that there is a control dependency change (control statements have been introduced), as well as an other statement change (additional statements inside the for-loop), resulting in a code change type of 3,4.","The early version of the method is empty, not performing any actions, while the late version introduces checks and operations that can modify the state of the object. This leads to a potential difference in behavior, since the early version effectively does nothing, and the late version can perform autofill actions on the object, indicating that a compatibility issue arises due to potentially different return values or types, so the CI type is 1."
90,<android.bluetooth.BluetoothAdapter: void stopLeScan(LeScanCallback)>,27,28,<android.bluetooth.BluetoothAdapter: void stopLeScan(LeScanCallback)>,<android.bluetooth.BluetoothAdapter: void stopLeScan(LeScanCallback)>,0,"{
    if (DBG)
        Log.d(TAG, ""stopLeScan()"");
    BluetoothLeScanner scanner = getBluetoothLeScanner();
    if (scanner == null) {
        return;
    }
    synchronized (mLeScanClients) {
        ScanCallback scanCallback = mLeScanClients.remove(callback);
        if (scanCallback == null) {
            if (DBG)
                Log.d(TAG, ""scan not started yet"");
            return;
        }
        scanner.stopScan(scanCallback);
    }
}","{
    if (DBG) {
        Log.d(TAG, ""stopLeScan()"");
    }
    BluetoothLeScanner scanner = getBluetoothLeScanner();
    if (scanner == null) {
        return;
    }
    synchronized (mLeScanClients) {
        ScanCallback scanCallback = mLeScanClients.remove(callback);
        if (scanCallback == null) {
            if (DBG) {
                Log.d(TAG, ""scan not started yet"");
            }
            return;
        }
        scanner.stopScan(scanCallback);
    }
}",1,"/**
 * Stops an ongoing Bluetooth LE device scan.
 *
 * @param callback used to identify which scan to stop
 * must be the same handle used to start the scan
 * @deprecated Use {@link BluetoothLeScanner#stopScan(ScanCallback)} instead.
 */
","/**
 * Stops an ongoing Bluetooth LE device scan.
 *
 * @param callback used to identify which scan to stop must be the same handle used to start the
 * scan
 * @deprecated Use {@link BluetoothLeScanner#stopScan(ScanCallback)} instead.
 */
",-1,"[@Deprecated, @RequiresPermission(Manifest.permission.BLUETOOTH_ADMIN)]","[@Deprecated, @RequiresPermission(Manifest.permission.BLUETOOTH_ADMIN)]",-1,-1,-1,-1,-1,-1,0,0,"No actual code change is present between the two versions; the only difference is the placement of braces for better readability. Method functionality, return statements, exception handling, control dependencies, and dependent APIs remain unchanged.",No compatibility issue is detected since there is no change in the logic or the functionality of the code.
92,"<android.view.ThreadedRenderer.ProcessInitializer: void init(Context,long)>",27,28,"<android.view.ThreadedRenderer.ProcessInitializer: void init(Context,long)>","<android.view.ThreadedRenderer.ProcessInitializer: void init(Context,long)>",0,"{
    if (mInitialized)
        return;
    mInitialized = true;
    mAppContext = context.getApplicationContext();
    initSched(renderProxy);
    initGraphicsStats();
}","{
    if (mInitialized)
        return;
    mInitialized = true;
    mAppContext = context.getApplicationContext();
    initSched(renderProxy);
    if (mAppContext != null) {
        initGraphicsStats();
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,3,0,"The control dependency for the method initGraphicsStats() has changed, with the addition of the 'if' statement checking if mAppContext is not null, so the code change type is 3.","Since the new control dependency ensures that initGraphicsStats() is only called when mAppContext is not null, this change does not result in a compatibility issue because it prevents a potential NullPointerException that might have occurred in the early version if mAppContext were null. This change is an added safety check and does not alter the successful execution flow of the method; therefore, it does not lead to a CI."
93,<android.service.autofill.FillResponse.Builder: Builder addDataset(Dataset)>,27,28,<android.service.autofill.FillResponse.Builder: Builder addDataset(Dataset)>,<android.service.autofill.FillResponse.Builder: Builder addDataset(Dataset)>,0,"{
    throwIfDestroyed();
    if (dataset == null) {
        return this;
    }
    if (mDatasets == null) {
        mDatasets = new ArrayList<>();
    }
    if (!mDatasets.add(dataset)) {
        return this;
    }
    return this;
}","{
    throwIfDestroyed();
    throwIfDisableAutofillCalled();
    if (dataset == null) {
        return this;
    }
    if (mDatasets == null) {
        mDatasets = new ArrayList<>();
    }
    if (!mDatasets.add(dataset)) {
        return this;
    }
    return this;
}",1,"/**
 * Adds a new {@link Dataset} to this response.
 *
 * <p><b>Note: </b> on Android {@link android.os.Build.VERSION_CODES#O}, the total number of
 * datasets is limited by the Binder transaction size, so it's recommended to keep it
 * small (in the range of 10-20 at most) and use pagination by adding a fake
 * {@link Dataset.Builder#setAuthentication(IntentSender) authenticated dataset} at the end
 * with a presentation string like ""Next 10"" that would return a new {@link FillResponse}
 * with the next 10 datasets, and so on. This limitation was lifted on
 * Android {@link android.os.Build.VERSION_CODES#O_MR1}, although the Binder transaction
 * size can still be reached if each dataset itself is too big.
 *
 * @return This builder.
 */
","/**
 * Adds a new {@link Dataset} to this response.
 *
 * <p><b>Note: </b> on Android {@link android.os.Build.VERSION_CODES#O}, the total number of
 * datasets is limited by the Binder transaction size, so it's recommended to keep it
 * small (in the range of 10-20 at most) and use pagination by adding a fake
 * {@link Dataset.Builder#setAuthentication(IntentSender) authenticated dataset} at the end
 * with a presentation string like ""Next 10"" that would return a new {@link FillResponse}
 * with the next 10 datasets, and so on. This limitation was lifted on
 * Android {@link android.os.Build.VERSION_CODES#O_MR1}, although the Binder transaction
 * size can still be reached if each dataset itself is too big.
 *
 * @return This builder.
 */
",-1,[@NonNull],[@NonNull],-1,-1,-1,-1,-1,-1,4,0,"In the late implementation, there is an additional method call (throwIfDisableAutofillCalled()) before the pre-existing checks, so the code change type is 4 (Other statement changed).","Since the new method throwIfDisableAutofillCalled() throws an exception if the condition it checks is met, it doesn't change the return value or type of the method, and it does not cause the method to throw a different exception than in the previous version - the throwIfDestroyed() method was already capable of throwing an exception related to the destroyed state. Therefore, the Compatibility Issue is 0 (No Compatibility Issue)."
94,<android.bluetooth.BluetoothSocket: BluetoothSocket accept(int)>,27,28,<android.bluetooth.BluetoothSocket: BluetoothSocket accept(int)>,<android.bluetooth.BluetoothSocket: BluetoothSocket accept(int)>,0,"{
    BluetoothSocket acceptedSocket;
    if (mSocketState != SocketState.LISTENING)
        throw new IOException(""bt socket is not in listen state"");
    if (timeout > 0) {
        Log.d(TAG, ""accept() set timeout (ms):"" + timeout);
        mSocket.setSoTimeout(timeout);
    }
    String RemoteAddr = waitSocketSignal(mSocketIS);
    if (timeout > 0)
        mSocket.setSoTimeout(0);
    synchronized (this) {
        if (mSocketState != SocketState.LISTENING)
            throw new IOException(""bt socket is not in listen state"");
        acceptedSocket = acceptSocket(RemoteAddr);
    // quick drop the reference of the file handle
    }
    return acceptedSocket;
}","{
    BluetoothSocket acceptedSocket;
    if (mSocketState != SocketState.LISTENING) {
        throw new IOException(""bt socket is not in listen state"");
    }
    if (timeout > 0) {
        Log.d(TAG, ""accept() set timeout (ms):"" + timeout);
        mSocket.setSoTimeout(timeout);
    }
    String RemoteAddr = waitSocketSignal(mSocketIS);
    if (timeout > 0) {
        mSocket.setSoTimeout(0);
    }
    synchronized (this) {
        if (mSocketState != SocketState.LISTENING) {
            throw new IOException(""bt socket is not in listen state"");
        }
        acceptedSocket = acceptSocket(RemoteAddr);
    // quick drop the reference of the file handle
    }
    return acceptedSocket;
}",1,"/*package*/
","/*package*/
",-1,,,-1,-1,-1,-1,-1,-1,0,0,There is no change between the early and late versions of the method implementation.,There is no compatibility issue since there were no changes made between the versions.
98,"<android.hardware.radio.TunerAdapter: ProgramInfo> getProgramList(Map<String, String>)>",27,28,"<android.hardware.radio.TunerAdapter: ProgramInfo> getProgramList(Map<String, String>)>","<android.hardware.radio.TunerAdapter: ProgramInfo> getProgramList(Map<String, String>)>",0,"{
    try {
        return mTuner.getProgramList(vendorFilter);
    } catch (RemoteException e) {
        throw new RuntimeException(""service died"", e);
    }
}","{
    synchronized (mTuner) {
        if (mLegacyListProxy == null || !Objects.equals(mLegacyListFilter, vendorFilter)) {
            Log.i(TAG, ""Program list filter has changed, requesting new list"");
            mLegacyListProxy = new ProgramList();
            mLegacyListFilter = vendorFilter;
            mCallback.clearLastCompleteList();
            mCallback.setProgramListObserver(mLegacyListProxy, () -> {
            });
            try {
                mTuner.startProgramListUpdates(new ProgramList.Filter(vendorFilter));
            } catch (RemoteException ex) {
                throw new RuntimeException(""service died"", ex);
            }
        }
        List<RadioManager.ProgramInfo> list = mCallback.getLastCompleteList();
        if (list == null)
            throw new IllegalStateException(""Program list is not ready yet"");
        return list;
    }
}",1,,,-1,"[@Override, @NonNull]","[@Override, @NonNull]",-1,-1,-1,-1,-1,-1,"1,2,3,4","1,2","The control flow has changed due to the addition of synchronization and the conditional logic to recreate the `ProgramList` only if necessary, and there is a change in exception handling where a new IllegalStateException is thrown. The new implementation also involves several other statements, such as logging, setting up a callback, and starting program list updates, so the code change includes all kinds except for dependent API changes, resulting in 1,2,3,4.","The early version method always makes a call to `mTuner.getProgramList(vendorFilter)` and throws a wrapped RemoteException if `mTuner.getProgramList(vendorFilter)` throws the same. The later version introduces a new control block with synchronization and additional logic. The method may now throw an IllegalStateException and therefore potentially returns a different value because of the new list creation and program list update logic. Additionally, the behavior related to RemoteExceptions changed, where previously a RuntimeException was thrown and now instead there is a code path that may lead to IllegalStateException. Therefore, the CI types are 1,2."
100,<android.content.pm.LauncherApps.CallbackMessageHandler: void handleMessage(Message)>,27,28,<android.content.pm.LauncherApps.CallbackMessageHandler: void handleMessage(Message)>,<android.content.pm.LauncherApps.CallbackMessageHandler: void handleMessage(Message)>,0,"{
    if (mCallback == null || !(msg.obj instanceof CallbackInfo)) {
        return;
    }
    CallbackInfo info = (CallbackInfo) msg.obj;
    switch(msg.what) {
        case MSG_ADDED:
            mCallback.onPackageAdded(info.packageName, info.user);
            break;
        case MSG_REMOVED:
            mCallback.onPackageRemoved(info.packageName, info.user);
            break;
        case MSG_CHANGED:
            mCallback.onPackageChanged(info.packageName, info.user);
            break;
        case MSG_AVAILABLE:
            mCallback.onPackagesAvailable(info.packageNames, info.user, info.replacing);
            break;
        case MSG_UNAVAILABLE:
            mCallback.onPackagesUnavailable(info.packageNames, info.user, info.replacing);
            break;
        case MSG_SUSPENDED:
            mCallback.onPackagesSuspended(info.packageNames, info.user);
            break;
        case MSG_UNSUSPENDED:
            mCallback.onPackagesUnsuspended(info.packageNames, info.user);
            break;
        case MSG_SHORTCUT_CHANGED:
            mCallback.onShortcutsChanged(info.packageName, info.shortcuts, info.user);
            break;
    }
}","{
    if (mCallback == null || !(msg.obj instanceof CallbackInfo)) {
        return;
    }
    CallbackInfo info = (CallbackInfo) msg.obj;
    switch(msg.what) {
        case MSG_ADDED:
            mCallback.onPackageAdded(info.packageName, info.user);
            break;
        case MSG_REMOVED:
            mCallback.onPackageRemoved(info.packageName, info.user);
            break;
        case MSG_CHANGED:
            mCallback.onPackageChanged(info.packageName, info.user);
            break;
        case MSG_AVAILABLE:
            mCallback.onPackagesAvailable(info.packageNames, info.user, info.replacing);
            break;
        case MSG_UNAVAILABLE:
            mCallback.onPackagesUnavailable(info.packageNames, info.user, info.replacing);
            break;
        case MSG_SUSPENDED:
            mCallback.onPackagesSuspended(info.packageNames, info.user, info.launcherExtras);
            break;
        case MSG_UNSUSPENDED:
            mCallback.onPackagesUnsuspended(info.packageNames, info.user);
            break;
        case MSG_SHORTCUT_CHANGED:
            mCallback.onShortcutsChanged(info.packageName, info.shortcuts, info.user);
            break;
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"The code change is in one of the case statements within the switch statement; the method `onPackagesSuspended` has an additional parameter `info.launcherExtras` in the late version. Thus, the change type is 4 (Other statement changed).","The added parameter `info.launcherExtras` to the `onPackagesSuspended` callback does not affect the return value or exception handling of this method. The method's signature remains unchanged, and it continues to return void without any change in exception handling. There is no Compatibility Issue as the change is internal to the method implementation and does not affect how it is called or what it returns."
101,<android.app.Notification.Builder: Builder addPerson(String)>,27,28,<android.app.Notification.Builder: Builder addPerson(String)>,<android.app.Notification.Builder: Builder addPerson(String)>,0,"{
    mPersonList.add(uri);
    return this;
}","{
    addPerson(new Person.Builder().setUri(uri).build());
    return this;
}",1,"/**
 * Add a person that is relevant to this notification.
 *
 * <P>
 * Depending on user preferences, this annotation may allow the notification to pass
 * through interruption filters, if this notification is of category {@link #CATEGORY_CALL}
 * or {@link #CATEGORY_MESSAGE}. The addition of people may also cause this notification to
 * appear more prominently in the user interface.
 * </P>
 *
 * <P>
 * The person should be specified by the {@code String} representation of a
 * {@link android.provider.ContactsContract.Contacts#CONTENT_LOOKUP_URI}.
 * </P>
 *
 * <P>The system will also attempt to resolve {@code mailto:} and {@code tel:} schema
 * URIs.  The path part of these URIs must exist in the contacts database, in the
 * appropriate column, or the reference will be discarded as invalid. Telephone schema
 * URIs will be resolved by {@link android.provider.ContactsContract.PhoneLookup}.
 * </P>
 *
 * @param uri A URI for the person.
 * @see Notification#EXTRA_PEOPLE
 */
","/**
 * Add a person that is relevant to this notification.
 *
 * <P>
 * Depending on user preferences, this annotation may allow the notification to pass
 * through interruption filters, if this notification is of category {@link #CATEGORY_CALL}
 * or {@link #CATEGORY_MESSAGE}. The addition of people may also cause this notification to
 * appear more prominently in the user interface.
 * </P>
 *
 * <P>
 * The person should be specified by the {@code String} representation of a
 * {@link android.provider.ContactsContract.Contacts#CONTENT_LOOKUP_URI}.
 * </P>
 *
 * <P>The system will also attempt to resolve {@code mailto:} and {@code tel:} schema
 * URIs.  The path part of these URIs must exist in the contacts database, in the
 * appropriate column, or the reference will be discarded as invalid. Telephone schema
 * URIs will be resolved by {@link android.provider.ContactsContract.PhoneLookup}.
 * It is also possible to provide a URI with the schema {@code name:} in order to uniquely
 * identify a person without an entry in the contacts database.
 * </P>
 *
 * @param uri A URI for the person.
 * @see Notification#EXTRA_PEOPLE
 * @deprecated use {@link #addPerson(Person)}
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"The implementation of the method to add a person has changed from directly adding the 'uri' String to the 'mPersonList' to creating a new Person object using 'uri' and then triggering a method call `addPerson(Person person)`. This indicates that there may be an overload of the `addPerson` method that takes a Person object instead of a String. However, this does not necessarily mean that the behavior has changed, as the Person object is constructed with the provided URI. So, the change types are 4 (Other statement changed) and 5 (Dependent API changed).","Despite the change in the implementation, there would be no Compatibility Issue as long as the new `addPerson` method that takes a Person object preserves the expected behavior of adding a person using the provided URI. Both versions of the method ultimately add a person to the notification and then return 'this' for chaining. Therefore, there should be no change in behavior observable to the client code calling this method, and so there is no Compatibility Issue."
102,"<android.widget.TextView: void setTextAppearance(Context,int)>",27,28,"<android.widget.TextView: void setTextAppearance(Context,int)>","<android.widget.TextView: void setTextAppearance(Context,int)>",0,"{
    final TypedArray ta = context.obtainStyledAttributes(resId, R.styleable.TextAppearance);
    final int textColorHighlight = ta.getColor(R.styleable.TextAppearance_textColorHighlight, 0);
    if (textColorHighlight != 0) {
        setHighlightColor(textColorHighlight);
    }
    final ColorStateList textColor = ta.getColorStateList(R.styleable.TextAppearance_textColor);
    if (textColor != null) {
        setTextColor(textColor);
    }
    final int textSize = ta.getDimensionPixelSize(R.styleable.TextAppearance_textSize, 0);
    if (textSize != 0) {
        setRawTextSize(textSize, true);
    }
    final ColorStateList textColorHint = ta.getColorStateList(R.styleable.TextAppearance_textColorHint);
    if (textColorHint != null) {
        setHintTextColor(textColorHint);
    }
    final ColorStateList textColorLink = ta.getColorStateList(R.styleable.TextAppearance_textColorLink);
    if (textColorLink != null) {
        setLinkTextColor(textColorLink);
    }
    Typeface fontTypeface = null;
    String fontFamily = null;
    if (!context.isRestricted() && context.canLoadUnsafeResources()) {
        try {
            fontTypeface = ta.getFont(R.styleable.TextAppearance_fontFamily);
        } catch (UnsupportedOperationException | Resources.NotFoundException e) {
        // Expected if it is not a font resource.
        }
    }
    if (fontTypeface == null) {
        fontFamily = ta.getString(R.styleable.TextAppearance_fontFamily);
    }
    final int typefaceIndex = ta.getInt(R.styleable.TextAppearance_typeface, -1);
    final int styleIndex = ta.getInt(R.styleable.TextAppearance_textStyle, -1);
    setTypefaceFromAttrs(fontTypeface, fontFamily, typefaceIndex, styleIndex);
    final int shadowColor = ta.getInt(R.styleable.TextAppearance_shadowColor, 0);
    if (shadowColor != 0) {
        final float dx = ta.getFloat(R.styleable.TextAppearance_shadowDx, 0);
        final float dy = ta.getFloat(R.styleable.TextAppearance_shadowDy, 0);
        final float r = ta.getFloat(R.styleable.TextAppearance_shadowRadius, 0);
        setShadowLayer(r, dx, dy, shadowColor);
    }
    if (ta.getBoolean(R.styleable.TextAppearance_textAllCaps, false)) {
        setTransformationMethod(new AllCapsTransformationMethod(getContext()));
    }
    if (ta.hasValue(R.styleable.TextAppearance_elegantTextHeight)) {
        setElegantTextHeight(ta.getBoolean(R.styleable.TextAppearance_elegantTextHeight, false));
    }
    if (ta.hasValue(R.styleable.TextAppearance_letterSpacing)) {
        setLetterSpacing(ta.getFloat(R.styleable.TextAppearance_letterSpacing, 0));
    }
    if (ta.hasValue(R.styleable.TextAppearance_fontFeatureSettings)) {
        setFontFeatureSettings(ta.getString(R.styleable.TextAppearance_fontFeatureSettings));
    }
    ta.recycle();
}","{
    final TypedArray ta = context.obtainStyledAttributes(resId, R.styleable.TextAppearance);
    final TextAppearanceAttributes attributes = new TextAppearanceAttributes();
    readTextAppearance(context, ta, attributes, false);
    ta.recycle();
    applyTextAppearance(attributes);
}",1,"/**
 * Sets the text color, size, style, hint color, and highlight color
 * from the specified TextAppearance resource.
 *
 * @deprecated Use {@link #setTextAppearance(int)} instead.
 */
","/**
 * Sets the text color, size, style, hint color, and highlight color
 * from the specified TextAppearance resource.
 *
 * @deprecated Use {@link #setTextAppearance(int)} instead.
 */
",-1,[@Deprecated],[@Deprecated],-1,-1,-1,-1,-1,-1,"4,5",0,"The method implementation has drastically changed as it no longer directly sets text appearance attributes and instead uses helper methods `readTextAppearance` and `applyTextAppearance` to set these attributes. Additionally, a new class `TextAppearanceAttributes` is used to encapsulate text appearance attributes. Thus, the changes are classified under types 4 and 5 because new method calls and a new class construction are introduced.","Despite the changes in implementation, the API signature and its contract seem to remain the same. As long as the methods `readTextAppearance` and `applyTextAppearance` correctly encapsulate the old functionality respecting the same logic, there should be no compatibility issues with different return values or exceptions. Therefore, the prediction is that there is no compatibility issue (0)."
103,"<android.app.SharedPreferencesImpl.EditorImpl: Editor putFloat(String,float)>",27,28,"<android.app.SharedPreferencesImpl.EditorImpl: Editor putFloat(String,float)>","<android.app.SharedPreferencesImpl.EditorImpl: Editor putFloat(String,float)>",0,"{
    synchronized (mLock) {
        mModified.put(key, value);
        return this;
    }
}","{
    synchronized (mEditorLock) {
        mModified.put(key, value);
        return this;
    }
}",1,,,-1,,[@Override],-1,-1,-1,-1,-1,-1,0,0,"There has been no functional change in the implementation of the method. Only the lock object name used for synchronization has changed from mLock to mEditorLock, which will not affect the behavior of the method as used by external callers.","There is no Compatibility Issue as the methods signature, return type, and behavior have not changed. The renaming of the lock object is an internal change and does not impact the API's external behavior."
104,<android.view.WindowId: String toString()>,27,28,<android.view.WindowId: String toString()>,<android.view.WindowId: String toString()>,0,"{
    StringBuilder sb = new StringBuilder(128);
    sb.append(""IntentSender{"");
    sb.append(Integer.toHexString(System.identityHashCode(this)));
    sb.append("": "");
    sb.append(mToken != null ? mToken.asBinder() : null);
    sb.append('}');
    return sb.toString();
}","{
    StringBuilder sb = new StringBuilder(128);
    sb.append(""IntentSender{"");
    sb.append(Integer.toHexString(System.identityHashCode(this)));
    sb.append("": "");
    sb.append(mToken.asBinder());
    sb.append('}');
    return sb.toString();
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,4",1,"The only change is in the way the 'mToken' object is appended to the StringBuilder. In the early version, there is a null check on 'mToken' before calling 'mToken.asBinder()', while in the late version, 'mToken.asBinder()' is called directly without a null check. This means an Other statement (null check removal) has changed. Also, the removal of null check impacts the return statement as it may now return a different value if 'mToken' is null (it will throw a NullPointerException instead of appending 'null'), so the code change type is 1,4.","Due to the removal of the null check for 'mToken', if 'mToken' is null, the early version would append ""null"" to the string, whereas the late version would throw a NullPointerException when attempting to call 'asBinder()' on a null object. Therefore, the API in the late version may throw an exception where the early version would not, which constitutes a Compatibility Issue caused by a different return value or behavior, hence marked as CI type 1."
105,<android.content.res.TypedArray: int getType(int)>,27,28,<android.content.res.TypedArray: int getType(int)>,<android.content.res.TypedArray: int getType(int)>,0,"{
    if (mRecycled) {
        throw new RuntimeException(""Cannot make calls to a recycled instance!"");
    }
    index *= AssetManager.STYLE_NUM_ENTRIES;
    return mData[index + AssetManager.STYLE_TYPE];
}","{
    if (mRecycled) {
        throw new RuntimeException(""Cannot make calls to a recycled instance!"");
    }
    index *= STYLE_NUM_ENTRIES;
    return mData[index + STYLE_TYPE];
}",1,"/**
 * Returns the type of attribute at the specified index.
 *
 * @param index Index of attribute whose type to retrieve.
 *
 * @return Attribute type.
 * @throws RuntimeException if the TypedArray has already been recycled.
 */
","/**
 * Returns the type of attribute at the specified index.
 *
 * @param index Index of attribute whose type to retrieve.
 *
 * @return Attribute type.
 * @throws RuntimeException if the TypedArray has already been recycled.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The constants `AssetManager.STYLE_NUM_ENTRIES` and `AssetManager.STYLE_TYPE` are replaced with `STYLE_NUM_ENTRIES` and `STYLE_TYPE`. Given that the values they reference are the same, this change is related to a simplification of the reference to constants within the class scope. Hence, it's only an ""Other statement changed"" in the categorization.","As there is no indication of the constants' values being changed, and assuming that these constants (STYLE_NUM_ENTRIES and STYLE_TYPE) are holding the same values as before, there is no change in behavior of the API. Therefore, no Compatibility Issue should occur from this alteration."
108,<android.widget.TextView: CharSequence removeSuggestionSpans(CharSequence)>,27,28,<android.widget.TextView: CharSequence removeSuggestionSpans(CharSequence)>,<android.widget.TextView: CharSequence removeSuggestionSpans(CharSequence)>,0,"{
    if (text instanceof Spanned) {
        Spannable spannable;
        if (text instanceof Spannable) {
            spannable = (Spannable) text;
        } else {
            spannable = mSpannableFactory.newSpannable(text);
            text = spannable;
        }
        SuggestionSpan[] spans = spannable.getSpans(0, text.length(), SuggestionSpan.class);
        for (int i = 0; i < spans.length; i++) {
            spannable.removeSpan(spans[i]);
        }
    }
    return text;
}","{
    if (text instanceof Spanned) {
        Spannable spannable;
        if (text instanceof Spannable) {
            spannable = (Spannable) text;
        } else {
            spannable = mSpannableFactory.newSpannable(text);
        }
        SuggestionSpan[] spans = spannable.getSpans(0, text.length(), SuggestionSpan.class);
        if (spans.length == 0) {
            return text;
        } else {
            text = spannable;
        }
        for (int i = 0; i < spans.length; i++) {
            spannable.removeSpan(spans[i]);
        }
    }
    return text;
}",1,"/**
 * Removes the suggestion spans.
 */
","/**
 * Removes the suggestion spans.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3",1,"The control dependency changed within the 'if (text instanceof Spanned)' block, where a check for 'spans.length == 0' has been added, and the assignment 'text = spannable;' has been moved inside an 'else' clause. A return statement inside the if block is also introduced. These changes represent both a control dependency change (3) and a return statement change (1).","The new check for 'spans.length == 0' could lead to an early return with the original 'text' without converting it to a Spannable when there are no SuggestionSpan objects to remove. This is a potential return value change since in the previous implementation, the 'text' was always set to a Spannable even if there were no spans to remove, so the CI type is 1."
109,<android.app.backup.BackupAgent: void onFullBackup(FullBackupDataOutput)>,27,28,<android.app.backup.BackupAgent: void onFullBackup(FullBackupDataOutput)>,<android.app.backup.BackupAgent: void onFullBackup(FullBackupDataOutput)>,0,"{
    FullBackup.BackupScheme backupScheme = FullBackup.getBackupScheme(this);
    if (!backupScheme.isFullBackupContentEnabled()) {
        return;
    }
    Map<String, Set<String>> manifestIncludeMap;
    ArraySet<String> manifestExcludeSet;
    try {
        manifestIncludeMap = backupScheme.maybeParseAndGetCanonicalIncludePaths();
        manifestExcludeSet = backupScheme.maybeParseAndGetCanonicalExcludePaths();
    } catch (IOException | XmlPullParserException e) {
        if (Log.isLoggable(FullBackup.TAG_XML_PARSER, Log.VERBOSE)) {
            Log.v(FullBackup.TAG_XML_PARSER, ""Exception trying to parse fullBackupContent xml file!"" + "" Aborting full backup."", e);
        }
        return;
    }
    final String packageName = getPackageName();
    final ApplicationInfo appInfo = getApplicationInfo();
    // System apps have control over where their default storage context
    // is pointed, so we're always explicit when building paths.
    final Context ceContext = createCredentialProtectedStorageContext();
    final String rootDir = ceContext.getDataDir().getCanonicalPath();
    final String filesDir = ceContext.getFilesDir().getCanonicalPath();
    final String noBackupDir = ceContext.getNoBackupFilesDir().getCanonicalPath();
    final String databaseDir = ceContext.getDatabasePath(""foo"").getParentFile().getCanonicalPath();
    final String sharedPrefsDir = ceContext.getSharedPreferencesPath(""foo"").getParentFile().getCanonicalPath();
    final String cacheDir = ceContext.getCacheDir().getCanonicalPath();
    final String codeCacheDir = ceContext.getCodeCacheDir().getCanonicalPath();
    final Context deContext = createDeviceProtectedStorageContext();
    final String deviceRootDir = deContext.getDataDir().getCanonicalPath();
    final String deviceFilesDir = deContext.getFilesDir().getCanonicalPath();
    final String deviceNoBackupDir = deContext.getNoBackupFilesDir().getCanonicalPath();
    final String deviceDatabaseDir = deContext.getDatabasePath(""foo"").getParentFile().getCanonicalPath();
    final String deviceSharedPrefsDir = deContext.getSharedPreferencesPath(""foo"").getParentFile().getCanonicalPath();
    final String deviceCacheDir = deContext.getCacheDir().getCanonicalPath();
    final String deviceCodeCacheDir = deContext.getCodeCacheDir().getCanonicalPath();
    final String libDir = (appInfo.nativeLibraryDir != null) ? new File(appInfo.nativeLibraryDir).getCanonicalPath() : null;
    // Maintain a set of excluded directories so that as we traverse the tree we know we're not
    // going places we don't expect, and so the manifest includes can't take precedence over
    // what the framework decides is not to be included.
    final ArraySet<String> traversalExcludeSet = new ArraySet<String>();
    // Add the directories we always exclude.
    traversalExcludeSet.add(filesDir);
    traversalExcludeSet.add(noBackupDir);
    traversalExcludeSet.add(databaseDir);
    traversalExcludeSet.add(sharedPrefsDir);
    traversalExcludeSet.add(cacheDir);
    traversalExcludeSet.add(codeCacheDir);
    traversalExcludeSet.add(deviceFilesDir);
    traversalExcludeSet.add(deviceNoBackupDir);
    traversalExcludeSet.add(deviceDatabaseDir);
    traversalExcludeSet.add(deviceSharedPrefsDir);
    traversalExcludeSet.add(deviceCacheDir);
    traversalExcludeSet.add(deviceCodeCacheDir);
    if (libDir != null) {
        traversalExcludeSet.add(libDir);
    }
    // Root dir first.
    applyXmlFiltersAndDoFullBackupForDomain(packageName, FullBackup.ROOT_TREE_TOKEN, manifestIncludeMap, manifestExcludeSet, traversalExcludeSet, data);
    traversalExcludeSet.add(rootDir);
    applyXmlFiltersAndDoFullBackupForDomain(packageName, FullBackup.DEVICE_ROOT_TREE_TOKEN, manifestIncludeMap, manifestExcludeSet, traversalExcludeSet, data);
    traversalExcludeSet.add(deviceRootDir);
    // Data dir next.
    traversalExcludeSet.remove(filesDir);
    applyXmlFiltersAndDoFullBackupForDomain(packageName, FullBackup.FILES_TREE_TOKEN, manifestIncludeMap, manifestExcludeSet, traversalExcludeSet, data);
    traversalExcludeSet.add(filesDir);
    traversalExcludeSet.remove(deviceFilesDir);
    applyXmlFiltersAndDoFullBackupForDomain(packageName, FullBackup.DEVICE_FILES_TREE_TOKEN, manifestIncludeMap, manifestExcludeSet, traversalExcludeSet, data);
    traversalExcludeSet.add(deviceFilesDir);
    // Database directory.
    traversalExcludeSet.remove(databaseDir);
    applyXmlFiltersAndDoFullBackupForDomain(packageName, FullBackup.DATABASE_TREE_TOKEN, manifestIncludeMap, manifestExcludeSet, traversalExcludeSet, data);
    traversalExcludeSet.add(databaseDir);
    traversalExcludeSet.remove(deviceDatabaseDir);
    applyXmlFiltersAndDoFullBackupForDomain(packageName, FullBackup.DEVICE_DATABASE_TREE_TOKEN, manifestIncludeMap, manifestExcludeSet, traversalExcludeSet, data);
    traversalExcludeSet.add(deviceDatabaseDir);
    // SharedPrefs.
    traversalExcludeSet.remove(sharedPrefsDir);
    applyXmlFiltersAndDoFullBackupForDomain(packageName, FullBackup.SHAREDPREFS_TREE_TOKEN, manifestIncludeMap, manifestExcludeSet, traversalExcludeSet, data);
    traversalExcludeSet.add(sharedPrefsDir);
    traversalExcludeSet.remove(deviceSharedPrefsDir);
    applyXmlFiltersAndDoFullBackupForDomain(packageName, FullBackup.DEVICE_SHAREDPREFS_TREE_TOKEN, manifestIncludeMap, manifestExcludeSet, traversalExcludeSet, data);
    traversalExcludeSet.add(deviceSharedPrefsDir);
    // the log.
    if (Process.myUid() != Process.SYSTEM_UID) {
        File efLocation = getExternalFilesDir(null);
        if (efLocation != null) {
            applyXmlFiltersAndDoFullBackupForDomain(packageName, FullBackup.MANAGED_EXTERNAL_TREE_TOKEN, manifestIncludeMap, manifestExcludeSet, traversalExcludeSet, data);
        }
    }
}","{
    FullBackup.BackupScheme backupScheme = FullBackup.getBackupScheme(this);
    if (!backupScheme.isFullBackupContentEnabled()) {
        return;
    }
    Map<String, Set<PathWithRequiredFlags>> manifestIncludeMap;
    ArraySet<PathWithRequiredFlags> manifestExcludeSet;
    try {
        manifestIncludeMap = backupScheme.maybeParseAndGetCanonicalIncludePaths();
        manifestExcludeSet = backupScheme.maybeParseAndGetCanonicalExcludePaths();
    } catch (IOException | XmlPullParserException e) {
        if (Log.isLoggable(FullBackup.TAG_XML_PARSER, Log.VERBOSE)) {
            Log.v(FullBackup.TAG_XML_PARSER, ""Exception trying to parse fullBackupContent xml file!"" + "" Aborting full backup."", e);
        }
        return;
    }
    final String packageName = getPackageName();
    final ApplicationInfo appInfo = getApplicationInfo();
    // System apps have control over where their default storage context
    // is pointed, so we're always explicit when building paths.
    final Context ceContext = createCredentialProtectedStorageContext();
    final String rootDir = ceContext.getDataDir().getCanonicalPath();
    final String filesDir = ceContext.getFilesDir().getCanonicalPath();
    final String noBackupDir = ceContext.getNoBackupFilesDir().getCanonicalPath();
    final String databaseDir = ceContext.getDatabasePath(""foo"").getParentFile().getCanonicalPath();
    final String sharedPrefsDir = ceContext.getSharedPreferencesPath(""foo"").getParentFile().getCanonicalPath();
    final String cacheDir = ceContext.getCacheDir().getCanonicalPath();
    final String codeCacheDir = ceContext.getCodeCacheDir().getCanonicalPath();
    final Context deContext = createDeviceProtectedStorageContext();
    final String deviceRootDir = deContext.getDataDir().getCanonicalPath();
    final String deviceFilesDir = deContext.getFilesDir().getCanonicalPath();
    final String deviceNoBackupDir = deContext.getNoBackupFilesDir().getCanonicalPath();
    final String deviceDatabaseDir = deContext.getDatabasePath(""foo"").getParentFile().getCanonicalPath();
    final String deviceSharedPrefsDir = deContext.getSharedPreferencesPath(""foo"").getParentFile().getCanonicalPath();
    final String deviceCacheDir = deContext.getCacheDir().getCanonicalPath();
    final String deviceCodeCacheDir = deContext.getCodeCacheDir().getCanonicalPath();
    final String libDir = (appInfo.nativeLibraryDir != null) ? new File(appInfo.nativeLibraryDir).getCanonicalPath() : null;
    // Maintain a set of excluded directories so that as we traverse the tree we know we're not
    // going places we don't expect, and so the manifest includes can't take precedence over
    // what the framework decides is not to be included.
    final ArraySet<String> traversalExcludeSet = new ArraySet<String>();
    // Add the directories we always exclude.
    traversalExcludeSet.add(filesDir);
    traversalExcludeSet.add(noBackupDir);
    traversalExcludeSet.add(databaseDir);
    traversalExcludeSet.add(sharedPrefsDir);
    traversalExcludeSet.add(cacheDir);
    traversalExcludeSet.add(codeCacheDir);
    traversalExcludeSet.add(deviceFilesDir);
    traversalExcludeSet.add(deviceNoBackupDir);
    traversalExcludeSet.add(deviceDatabaseDir);
    traversalExcludeSet.add(deviceSharedPrefsDir);
    traversalExcludeSet.add(deviceCacheDir);
    traversalExcludeSet.add(deviceCodeCacheDir);
    if (libDir != null) {
        traversalExcludeSet.add(libDir);
    }
    // Root dir first.
    applyXmlFiltersAndDoFullBackupForDomain(packageName, FullBackup.ROOT_TREE_TOKEN, manifestIncludeMap, manifestExcludeSet, traversalExcludeSet, data);
    traversalExcludeSet.add(rootDir);
    applyXmlFiltersAndDoFullBackupForDomain(packageName, FullBackup.DEVICE_ROOT_TREE_TOKEN, manifestIncludeMap, manifestExcludeSet, traversalExcludeSet, data);
    traversalExcludeSet.add(deviceRootDir);
    // Data dir next.
    traversalExcludeSet.remove(filesDir);
    applyXmlFiltersAndDoFullBackupForDomain(packageName, FullBackup.FILES_TREE_TOKEN, manifestIncludeMap, manifestExcludeSet, traversalExcludeSet, data);
    traversalExcludeSet.add(filesDir);
    traversalExcludeSet.remove(deviceFilesDir);
    applyXmlFiltersAndDoFullBackupForDomain(packageName, FullBackup.DEVICE_FILES_TREE_TOKEN, manifestIncludeMap, manifestExcludeSet, traversalExcludeSet, data);
    traversalExcludeSet.add(deviceFilesDir);
    // Database directory.
    traversalExcludeSet.remove(databaseDir);
    applyXmlFiltersAndDoFullBackupForDomain(packageName, FullBackup.DATABASE_TREE_TOKEN, manifestIncludeMap, manifestExcludeSet, traversalExcludeSet, data);
    traversalExcludeSet.add(databaseDir);
    traversalExcludeSet.remove(deviceDatabaseDir);
    applyXmlFiltersAndDoFullBackupForDomain(packageName, FullBackup.DEVICE_DATABASE_TREE_TOKEN, manifestIncludeMap, manifestExcludeSet, traversalExcludeSet, data);
    traversalExcludeSet.add(deviceDatabaseDir);
    // SharedPrefs.
    traversalExcludeSet.remove(sharedPrefsDir);
    applyXmlFiltersAndDoFullBackupForDomain(packageName, FullBackup.SHAREDPREFS_TREE_TOKEN, manifestIncludeMap, manifestExcludeSet, traversalExcludeSet, data);
    traversalExcludeSet.add(sharedPrefsDir);
    traversalExcludeSet.remove(deviceSharedPrefsDir);
    applyXmlFiltersAndDoFullBackupForDomain(packageName, FullBackup.DEVICE_SHAREDPREFS_TREE_TOKEN, manifestIncludeMap, manifestExcludeSet, traversalExcludeSet, data);
    traversalExcludeSet.add(deviceSharedPrefsDir);
    // the log.
    if (Process.myUid() != Process.SYSTEM_UID) {
        File efLocation = getExternalFilesDir(null);
        if (efLocation != null) {
            applyXmlFiltersAndDoFullBackupForDomain(packageName, FullBackup.MANAGED_EXTERNAL_TREE_TOKEN, manifestIncludeMap, manifestExcludeSet, traversalExcludeSet, data);
        }
    }
}",1,"/**
 * The application is having its entire file system contents backed up.  {@code data}
 * points to the backup destination, and the app has the opportunity to choose which
 * files are to be stored.  To commit a file as part of the backup, call the
 * {@link #fullBackupFile(File, FullBackupDataOutput)} helper method.  After all file
 * data is written to the output, the agent returns from this method and the backup
 * operation concludes.
 *
 * <p>Certain parts of the app's data are never backed up even if the app explicitly
 * sends them to the output:
 *
 * <ul>
 * <li>The contents of the {@link #getCacheDir()} directory</li>
 * <li>The contents of the {@link #getCodeCacheDir()} directory</li>
 * <li>The contents of the {@link #getNoBackupFilesDir()} directory</li>
 * <li>The contents of the app's shared library directory</li>
 * </ul>
 *
 * <p>The default implementation of this method backs up the entirety of the
 * application's ""owned"" file system trees to the output other than the few exceptions
 * listed above.  Apps only need to override this method if they need to impose special
 * limitations on which files are being stored beyond the control that
 * {@link #getNoBackupFilesDir()} offers.
 * Alternatively they can provide an xml resource to specify what data to include or exclude.
 *
 * @param data A structured wrapper pointing to the backup destination.
 * @throws IOException
 *
 * @see Context#getNoBackupFilesDir()
 * @see ApplicationInfo#fullBackupContent
 * @see #fullBackupFile(File, FullBackupDataOutput)
 * @see #onRestoreFile(ParcelFileDescriptor, long, File, int, long, long)
 */
","/**
 * The application is having its entire file system contents backed up.  {@code data}
 * points to the backup destination, and the app has the opportunity to choose which
 * files are to be stored.  To commit a file as part of the backup, call the
 * {@link #fullBackupFile(File, FullBackupDataOutput)} helper method.  After all file
 * data is written to the output, the agent returns from this method and the backup
 * operation concludes.
 *
 * <p>Certain parts of the app's data are never backed up even if the app explicitly
 * sends them to the output:
 *
 * <ul>
 * <li>The contents of the {@link #getCacheDir()} directory</li>
 * <li>The contents of the {@link #getCodeCacheDir()} directory</li>
 * <li>The contents of the {@link #getNoBackupFilesDir()} directory</li>
 * <li>The contents of the app's shared library directory</li>
 * </ul>
 *
 * <p>The default implementation of this method backs up the entirety of the
 * application's ""owned"" file system trees to the output other than the few exceptions
 * listed above.  Apps only need to override this method if they need to impose special
 * limitations on which files are being stored beyond the control that
 * {@link #getNoBackupFilesDir()} offers.
 * Alternatively they can provide an xml resource to specify what data to include or exclude.
 *
 * @param data A structured wrapper pointing to the backup destination.
 * @throws IOException
 *
 * @see Context#getNoBackupFilesDir()
 * @see ApplicationInfo#fullBackupContent
 * @see #fullBackupFile(File, FullBackupDataOutput)
 * @see #onRestoreFile(ParcelFileDescriptor, long, File, int, long, long)
 */
",-1,,,-1,-1,-1,-1,-1,-1,,,,
110,<android.bluetooth.BluetoothAdapter: boolean isOffloadedScanBatchingSupported()>,27,28,<android.bluetooth.BluetoothAdapter: boolean isOffloadedScanBatchingSupported()>,<android.bluetooth.BluetoothAdapter: boolean isOffloadedScanBatchingSupported()>,0,"{
    if (!getLeAccess())
        return false;
    try {
        mServiceLock.readLock().lock();
        if (mService != null)
            return mService.isOffloadedScanBatchingSupported();
    } catch (RemoteException e) {
        Log.e(TAG, ""failed to get isOffloadedScanBatchingSupported, error: "", e);
    } finally {
        mServiceLock.readLock().unlock();
    }
    return false;
}","{
    if (!getLeAccess()) {
        return false;
    }
    try {
        mServiceLock.readLock().lock();
        if (mService != null) {
            return mService.isOffloadedScanBatchingSupported();
        }
    } catch (RemoteException e) {
        Log.e(TAG, ""failed to get isOffloadedScanBatchingSupported, error: "", e);
    } finally {
        mServiceLock.readLock().unlock();
    }
    return false;
}",1,"/**
 * Return true if offloaded scan batching is supported
 *
 * @return true if chipset supports on-chip scan batching
 */
","/**
 * Return true if offloaded scan batching is supported
 *
 * @return true if chipset supports on-chip scan batching
 */
",-1,,,-1,-1,-1,-1,-1,-1,0,0,"There is no functional change in the code other than the addition of braces for better readability, so the code change type is 0.","There is no change in the API behavior, so there is no Compatibility Issue; the CI type is 0."
111,<android.app.RemoteAction: RemoteAction clone()>,27,28,<android.app.RemoteAction: RemoteAction clone()>,<android.app.RemoteAction: RemoteAction clone()>,0,"{
    RemoteAction action = new RemoteAction(mIcon, mTitle, mContentDescription, mActionIntent);
    action.setEnabled(mEnabled);
    return action;
}","{
    RemoteAction action = new RemoteAction(mIcon, mTitle, mContentDescription, mActionIntent);
    action.setEnabled(mEnabled);
    action.setShouldShowIcon(mShouldShowIcon);
    return action;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"A new statement, action.setShouldShowIcon(mShouldShowIcon), is added to the late version, which is not related to the return statement or exception handling, so the change type is 4.","The added statement sets an additional property on the `RemoteAction` object but doesn't affect the variable type or value being returned, it also doesn't introduce any new exceptional conditions, so there is no compatibility issue, and the CI type is 0."
112,<android.inputmethodservice.IInputMethodWrapper: void executeMessage(Message)>,27,28,<android.inputmethodservice.IInputMethodWrapper: void executeMessage(Message)>,<android.inputmethodservice.IInputMethodWrapper: void executeMessage(Message)>,0,"{
    InputMethod inputMethod = mInputMethod.get();
    // Need a valid reference to the inputMethod for everything except a dump.
    if (inputMethod == null && msg.what != DO_DUMP) {
        Log.w(TAG, ""Input method reference was null, ignoring message: "" + msg.what);
        return;
    }
    switch(msg.what) {
        case DO_DUMP:
            {
                AbstractInputMethodService target = mTarget.get();
                if (target == null) {
                    return;
                }
                SomeArgs args = (SomeArgs) msg.obj;
                try {
                    target.dump((FileDescriptor) args.arg1, (PrintWriter) args.arg2, (String[]) args.arg3);
                } catch (RuntimeException e) {
                    ((PrintWriter) args.arg2).println(""Exception: "" + e);
                }
                synchronized (args.arg4) {
                    ((CountDownLatch) args.arg4).countDown();
                }
                args.recycle();
                return;
            }
        case DO_ATTACH_TOKEN:
            {
                inputMethod.attachToken((IBinder) msg.obj);
                return;
            }
        case DO_SET_INPUT_CONTEXT:
            {
                inputMethod.bindInput((InputBinding) msg.obj);
                return;
            }
        case DO_UNSET_INPUT_CONTEXT:
            inputMethod.unbindInput();
            return;
        case DO_START_INPUT:
            {
                final SomeArgs args = (SomeArgs) msg.obj;
                final int missingMethods = msg.arg1;
                final boolean restarting = msg.arg2 != 0;
                final IBinder startInputToken = (IBinder) args.arg1;
                final IInputContext inputContext = (IInputContext) args.arg2;
                final EditorInfo info = (EditorInfo) args.arg3;
                final InputConnection ic = inputContext != null ? new InputConnectionWrapper(mTarget, inputContext, missingMethods) : null;
                info.makeCompatible(mTargetSdkVersion);
                inputMethod.dispatchStartInputWithToken(ic, info, restarting, /* restarting */
                startInputToken);
                args.recycle();
                return;
            }
        case DO_CREATE_SESSION:
            {
                SomeArgs args = (SomeArgs) msg.obj;
                inputMethod.createSession(new InputMethodSessionCallbackWrapper(mContext, (InputChannel) args.arg1, (IInputSessionCallback) args.arg2));
                args.recycle();
                return;
            }
        case DO_SET_SESSION_ENABLED:
            inputMethod.setSessionEnabled((InputMethodSession) msg.obj, msg.arg1 != 0);
            return;
        case DO_REVOKE_SESSION:
            inputMethod.revokeSession((InputMethodSession) msg.obj);
            return;
        case DO_SHOW_SOFT_INPUT:
            inputMethod.showSoftInput(msg.arg1, (ResultReceiver) msg.obj);
            return;
        case DO_HIDE_SOFT_INPUT:
            inputMethod.hideSoftInput(msg.arg1, (ResultReceiver) msg.obj);
            return;
        case DO_CHANGE_INPUTMETHOD_SUBTYPE:
            inputMethod.changeInputMethodSubtype((InputMethodSubtype) msg.obj);
            return;
    }
    Log.w(TAG, ""Unhandled message code: "" + msg.what);
}","{
    InputMethod inputMethod = mInputMethod.get();
    // Need a valid reference to the inputMethod for everything except a dump.
    if (inputMethod == null && msg.what != DO_DUMP) {
        Log.w(TAG, ""Input method reference was null, ignoring message: "" + msg.what);
        return;
    }
    switch(msg.what) {
        case DO_DUMP:
            {
                AbstractInputMethodService target = mTarget.get();
                if (target == null) {
                    return;
                }
                SomeArgs args = (SomeArgs) msg.obj;
                try {
                    target.dump((FileDescriptor) args.arg1, (PrintWriter) args.arg2, (String[]) args.arg3);
                } catch (RuntimeException e) {
                    ((PrintWriter) args.arg2).println(""Exception: "" + e);
                }
                synchronized (args.arg4) {
                    ((CountDownLatch) args.arg4).countDown();
                }
                args.recycle();
                return;
            }
        case DO_ATTACH_TOKEN:
            {
                inputMethod.attachToken((IBinder) msg.obj);
                return;
            }
        case DO_SET_INPUT_CONTEXT:
            {
                inputMethod.bindInput((InputBinding) msg.obj);
                return;
            }
        case DO_UNSET_INPUT_CONTEXT:
            inputMethod.unbindInput();
            return;
        case DO_START_INPUT:
            {
                final SomeArgs args = (SomeArgs) msg.obj;
                final int missingMethods = msg.arg1;
                final boolean restarting = msg.arg2 != 0;
                final IBinder startInputToken = (IBinder) args.arg1;
                final IInputContext inputContext = (IInputContext) args.arg2;
                final EditorInfo info = (EditorInfo) args.arg3;
                final AtomicBoolean isUnbindIssued = (AtomicBoolean) args.arg4;
                final InputConnection ic = inputContext != null ? new InputConnectionWrapper(mTarget, inputContext, missingMethods, isUnbindIssued) : null;
                info.makeCompatible(mTargetSdkVersion);
                inputMethod.dispatchStartInputWithToken(ic, info, restarting, /* restarting */
                startInputToken);
                args.recycle();
                return;
            }
        case DO_CREATE_SESSION:
            {
                SomeArgs args = (SomeArgs) msg.obj;
                inputMethod.createSession(new InputMethodSessionCallbackWrapper(mContext, (InputChannel) args.arg1, (IInputSessionCallback) args.arg2));
                args.recycle();
                return;
            }
        case DO_SET_SESSION_ENABLED:
            inputMethod.setSessionEnabled((InputMethodSession) msg.obj, msg.arg1 != 0);
            return;
        case DO_REVOKE_SESSION:
            inputMethod.revokeSession((InputMethodSession) msg.obj);
            return;
        case DO_SHOW_SOFT_INPUT:
            inputMethod.showSoftInput(msg.arg1, (ResultReceiver) msg.obj);
            return;
        case DO_HIDE_SOFT_INPUT:
            inputMethod.hideSoftInput(msg.arg1, (ResultReceiver) msg.obj);
            return;
        case DO_CHANGE_INPUTMETHOD_SUBTYPE:
            inputMethod.changeInputMethodSubtype((InputMethodSubtype) msg.obj);
            return;
    }
    Log.w(TAG, ""Unhandled message code: "" + msg.what);
}",1,,,-1,[@Override],"[@MainThread, @Override]",-1,-1,-1,-1,-1,-1,,,,
113,"<android.text.format.DateFormat: CharSequence format(CharSequence,Calendar)>",27,28,"<android.text.format.DateFormat: CharSequence format(CharSequence,Calendar)>","<android.text.format.DateFormat: CharSequence format(CharSequence,Calendar)>",0,"{
    SpannableStringBuilder s = new SpannableStringBuilder(inFormat);
    int count;
    LocaleData localeData = LocaleData.get(Locale.getDefault());
    int len = inFormat.length();
    for (int i = 0; i < len; i += count) {
        count = 1;
        int c = s.charAt(i);
        if (c == QUOTE) {
            count = appendQuotedText(s, i, len);
            len = s.length();
            continue;
        }
        while ((i + count < len) && (s.charAt(i + count) == c)) {
            count++;
        }
        String replacement;
        switch(c) {
            case 'A':
            case 'a':
                replacement = localeData.amPm[inDate.get(Calendar.AM_PM) - Calendar.AM];
                break;
            case 'd':
                replacement = zeroPad(inDate.get(Calendar.DATE), count);
                break;
            case 'c':
            case 'E':
                replacement = getDayOfWeekString(localeData, inDate.get(Calendar.DAY_OF_WEEK), count, c);
                break;
            // hour in am/pm (0-11)
            case 'K':
            case // hour in am/pm (1-12)
            'h':
                {
                    int hour = inDate.get(Calendar.HOUR);
                    if (c == 'h' && hour == 0) {
                        hour = 12;
                    }
                    replacement = zeroPad(hour, count);
                }
                break;
            // hour in day (0-23)
            case 'H':
            case // hour in day (1-24) [but see note below]
            'k':
                {
                    int hour = inDate.get(Calendar.HOUR_OF_DAY);
                    // times are abusing 'k'. http://b/8359981.
                    if (false && c == 'k' && hour == 0) {
                        hour = 24;
                    }
                    replacement = zeroPad(hour, count);
                }
                break;
            case 'L':
            case 'M':
                replacement = getMonthString(localeData, inDate.get(Calendar.MONTH), count, c);
                break;
            case 'm':
                replacement = zeroPad(inDate.get(Calendar.MINUTE), count);
                break;
            case 's':
                replacement = zeroPad(inDate.get(Calendar.SECOND), count);
                break;
            case 'y':
                replacement = getYearString(inDate.get(Calendar.YEAR), count);
                break;
            case 'z':
                replacement = getTimeZoneString(inDate, count);
                break;
            default:
                replacement = null;
                break;
        }
        if (replacement != null) {
            s.replace(i, i + count, replacement);
            // CARE: count is used in the for loop above
            count = replacement.length();
            len = s.length();
        }
    }
    if (inFormat instanceof Spanned) {
        return new SpannedString(s);
    } else {
        return s.toString();
    }
}","{
    SpannableStringBuilder s = new SpannableStringBuilder(inFormat);
    int count;
    LocaleData localeData = LocaleData.get(Locale.getDefault());
    int len = inFormat.length();
    for (int i = 0; i < len; i += count) {
        count = 1;
        int c = s.charAt(i);
        if (c == QUOTE) {
            count = appendQuotedText(s, i);
            len = s.length();
            continue;
        }
        while ((i + count < len) && (s.charAt(i + count) == c)) {
            count++;
        }
        String replacement;
        switch(c) {
            case 'A':
            case 'a':
                replacement = localeData.amPm[inDate.get(Calendar.AM_PM) - Calendar.AM];
                break;
            case 'd':
                replacement = zeroPad(inDate.get(Calendar.DATE), count);
                break;
            case 'c':
            case 'E':
                replacement = getDayOfWeekString(localeData, inDate.get(Calendar.DAY_OF_WEEK), count, c);
                break;
            // hour in am/pm (0-11)
            case 'K':
            case // hour in am/pm (1-12)
            'h':
                {
                    int hour = inDate.get(Calendar.HOUR);
                    if (c == 'h' && hour == 0) {
                        hour = 12;
                    }
                    replacement = zeroPad(hour, count);
                }
                break;
            // hour in day (0-23)
            case 'H':
            case // hour in day (1-24) [but see note below]
            'k':
                {
                    int hour = inDate.get(Calendar.HOUR_OF_DAY);
                    // times are abusing 'k'. http://b/8359981.
                    if (false && c == 'k' && hour == 0) {
                        hour = 24;
                    }
                    replacement = zeroPad(hour, count);
                }
                break;
            case 'L':
            case 'M':
                replacement = getMonthString(localeData, inDate.get(Calendar.MONTH), count, c);
                break;
            case 'm':
                replacement = zeroPad(inDate.get(Calendar.MINUTE), count);
                break;
            case 's':
                replacement = zeroPad(inDate.get(Calendar.SECOND), count);
                break;
            case 'y':
                replacement = getYearString(inDate.get(Calendar.YEAR), count);
                break;
            case 'z':
                replacement = getTimeZoneString(inDate, count);
                break;
            default:
                replacement = null;
                break;
        }
        if (replacement != null) {
            s.replace(i, i + count, replacement);
            // CARE: count is used in the for loop above
            count = replacement.length();
            len = s.length();
        }
    }
    if (inFormat instanceof Spanned) {
        return new SpannedString(s);
    } else {
        return s.toString();
    }
}",1,"/**
 * Given a format string and a {@link java.util.Calendar} object, returns a CharSequence
 * containing the requested date.
 * @param inFormat the format string, as described in {@link android.text.format.DateFormat}
 * @param inDate the date to format
 * @return a {@link CharSequence} containing the requested text
 */
","/**
 * Given a format string and a {@link java.util.Calendar} object, returns a CharSequence
 * containing the requested date.
 * @param inFormat the format string, as described in {@link android.text.format.DateFormat}
 * @param inDate the date to format
 * @return a {@link CharSequence} containing the requested text
 */
",-1,,,-1,-1,-1,-1,-1,-1,,,,
114,"<android.content.pm.LauncherApps: void startMainActivity(ComponentName,UserHandle,Rect,Bundle)>",27,28,"<android.content.pm.LauncherApps: void startMainActivity(ComponentName,UserHandle,Rect,Bundle)>","<android.content.pm.LauncherApps: void startMainActivity(ComponentName,UserHandle,Rect,Bundle)>",0,"{
    logErrorForInvalidProfileAccess(user);
    if (DEBUG) {
        Log.i(TAG, ""StartMainActivity "" + component + "" "" + user.getIdentifier());
    }
    try {
        mService.startActivityAsUser(mContext.getPackageName(), component, sourceBounds, opts, user);
    } catch (RemoteException re) {
        throw re.rethrowFromSystemServer();
    }
}","{
    logErrorForInvalidProfileAccess(user);
    if (DEBUG) {
        Log.i(TAG, ""StartMainActivity "" + component + "" "" + user.getIdentifier());
    }
    try {
        mService.startActivityAsUser(mContext.getIApplicationThread(), mContext.getPackageName(), component, sourceBounds, opts, user);
    } catch (RemoteException re) {
        throw re.rethrowFromSystemServer();
    }
}",1,"/**
 * Starts a Main activity in the specified profile.
 *
 * @param component The ComponentName of the activity to launch
 * @param user The UserHandle of the profile
 * @param sourceBounds The Rect containing the source bounds of the clicked icon
 * @param opts Options to pass to startActivity
 */
","/**
 * Starts a Main activity in the specified profile.
 *
 * @param component The ComponentName of the activity to launch
 * @param user The UserHandle of the profile
 * @param sourceBounds The Rect containing the source bounds of the clicked icon
 * @param opts Options to pass to startActivity
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The change in the code is in the call mService.startActivityAsUser, where an additional parameter mContext.getIApplicationThread() has been added in the method parameters. This indicates that the dependent API has changed, so the code change type is 5.","There is no Compatibility Issue here as the method's signature remains unchanged, it continues to not return a value (void return type), and there are no changes to exception handling or control flow that would affect the client's use of the method. Hence, the CI type is 0."
115,<android.inputmethodservice.InputMethodService: void showWindow(boolean)>,27,28,<android.inputmethodservice.InputMethodService: void showWindow(boolean)>,<android.inputmethodservice.InputMethodService: void showWindow(boolean)>,0,"{
    if (DEBUG)
        Log.v(TAG, ""Showing window: showInput="" + showInput + "" mShowInputRequested="" + mShowInputRequested + "" mWindowAdded="" + mWindowAdded + "" mWindowCreated="" + mWindowCreated + "" mWindowVisible="" + mWindowVisible + "" mInputStarted="" + mInputStarted + "" mShowInputFlags="" + mShowInputFlags);
    if (mInShowWindow) {
        Log.w(TAG, ""Re-entrance in to showWindow"");
        return;
    }
    try {
        mWindowWasVisible = mWindowVisible;
        mInShowWindow = true;
        showWindowInner(showInput);
    } catch (BadTokenException e) {
        // while there is a DO_SHOW_SOFT_INPUT message in the IIMethodWrapper queue.
        if (DEBUG)
            Log.v(TAG, ""BadTokenException: IME is done."");
        mWindowVisible = false;
        mWindowAdded = false;
        // InputMethodManager#showSoftInputFromInputMethod() should always be used instead.
        throw e;
    } finally {
        // TODO: Is it OK to set true when we get BadTokenException?
        mWindowWasVisible = true;
        mInShowWindow = false;
    }
}","{
    if (DEBUG)
        Log.v(TAG, ""Showing window: showInput="" + showInput + "" mShowInputRequested="" + mShowInputRequested + "" mWindowAdded="" + mWindowAdded + "" mWindowCreated="" + mWindowCreated + "" mWindowVisible="" + mWindowVisible + "" mInputStarted="" + mInputStarted + "" mShowInputFlags="" + mShowInputFlags);
    if (mInShowWindow) {
        Log.w(TAG, ""Re-entrance in to showWindow"");
        return;
    }
    try {
        mWindowWasVisible = mWindowVisible;
        mInShowWindow = true;
        showWindowInner(showInput);
    } catch (BadTokenException e) {
        // while there is a DO_SHOW_SOFT_INPUT message in the IIMethodWrapper queue.
        if (DEBUG)
            Log.v(TAG, ""BadTokenException: IME is done."");
        mWindowVisible = false;
        mWindowAdded = false;
        // InputMethodService#requestShowSelf(int) should always be used instead.
        throw e;
    } finally {
        // TODO: Is it OK to set true when we get BadTokenException?
        mWindowWasVisible = true;
        mInShowWindow = false;
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,4,0,"The change from ""InputMethodManager#showSoftInputFromInputMethod()"" in the comment to ""InputMethodService#requestShowSelf(int)"" does not affect the codes behavior at runtime since it is only a comment change, so the code change type is 4.","The modified comment does not lead to different return values, exceptions, or execution paths. Comments do not affect the execution of the program; therefore, there is no Compatibility Issue, so the CI type is 0."
116,<android.content.res.TypedArray: int getChangingConfigurations()>,27,28,<android.content.res.TypedArray: int getChangingConfigurations()>,<android.content.res.TypedArray: int getChangingConfigurations()>,0,"{
    if (mRecycled) {
        throw new RuntimeException(""Cannot make calls to a recycled instance!"");
    }
    @Config int changingConfig = 0;
    final int[] data = mData;
    final int N = length();
    for (int i = 0; i < N; i++) {
        final int index = i * AssetManager.STYLE_NUM_ENTRIES;
        final int type = data[index + AssetManager.STYLE_TYPE];
        if (type == TypedValue.TYPE_NULL) {
            continue;
        }
        changingConfig |= ActivityInfo.activityInfoConfigNativeToJava(data[index + AssetManager.STYLE_CHANGING_CONFIGURATIONS]);
    }
    return changingConfig;
}","{
    if (mRecycled) {
        throw new RuntimeException(""Cannot make calls to a recycled instance!"");
    }
    @Config int changingConfig = 0;
    final int[] data = mData;
    final int N = length();
    for (int i = 0; i < N; i++) {
        final int index = i * STYLE_NUM_ENTRIES;
        final int type = data[index + STYLE_TYPE];
        if (type == TypedValue.TYPE_NULL) {
            continue;
        }
        changingConfig |= ActivityInfo.activityInfoConfigNativeToJava(data[index + STYLE_CHANGING_CONFIGURATIONS]);
    }
    return changingConfig;
}",1,"/**
 * Return a mask of the configuration parameters for which the values in
 * this typed array may change.
 *
 * @return Returns a mask of the changing configuration parameters, as
 * defined by {@link android.content.pm.ActivityInfo}.
 * @throws RuntimeException if the TypedArray has already been recycled.
 * @see android.content.pm.ActivityInfo
 */
","/**
 * Return a mask of the configuration parameters for which the values in
 * this typed array may change.
 *
 * @return Returns a mask of the changing configuration parameters, as
 * defined by {@link android.content.pm.ActivityInfo}.
 * @throws RuntimeException if the TypedArray has already been recycled.
 * @see android.content.pm.ActivityInfo
 */
",-1,[@Config],[@Config],-1,-1,-1,-1,-1,-1,0,0,"No code has been changed between the two versions, only the static member access format is different (direct class name vs. classname.variable). It does not affect the functionality of the method as no functional changes have been made to the implementation.",There is no compatibility issue between the two versions because there is no actual change in the behavior or output of the method.
119,<android.widget.TextView: boolean onTouchEvent(MotionEvent)>,27,28,<android.widget.TextView: boolean onTouchEvent(MotionEvent)>,<android.widget.TextView: boolean onTouchEvent(MotionEvent)>,0,"{
    final int action = event.getActionMasked();
    if (mEditor != null) {
        mEditor.onTouchEvent(event);
        if (mEditor.mSelectionModifierCursorController != null && mEditor.mSelectionModifierCursorController.isDragAcceleratorActive()) {
            return true;
        }
    }
    final boolean superResult = super.onTouchEvent(event);
    /*
         * Don't handle the release after a long press, because it will move the selection away from
         * whatever the menu action was trying to affect. If the long press should have triggered an
         * insertion action mode, we can now actually show it.
         */
    if (mEditor != null && mEditor.mDiscardNextActionUp && action == MotionEvent.ACTION_UP) {
        mEditor.mDiscardNextActionUp = false;
        if (mEditor.mIsInsertionActionModeStartPending) {
            mEditor.startInsertionActionMode();
            mEditor.mIsInsertionActionModeStartPending = false;
        }
        return superResult;
    }
    final boolean touchIsFinished = (action == MotionEvent.ACTION_UP) && (mEditor == null || !mEditor.mIgnoreActionUpEvent) && isFocused();
    if ((mMovement != null || onCheckIsTextEditor()) && isEnabled() && mText instanceof Spannable && mLayout != null) {
        boolean handled = false;
        if (mMovement != null) {
            handled |= mMovement.onTouchEvent(this, (Spannable) mText, event);
        }
        final boolean textIsSelectable = isTextSelectable();
        if (touchIsFinished && mLinksClickable && mAutoLinkMask != 0 && textIsSelectable) {
            // The LinkMovementMethod which should handle taps on links has not been installed
            // on non editable text that support text selection.
            // We reproduce its behavior here to open links for these.
            ClickableSpan[] links = ((Spannable) mText).getSpans(getSelectionStart(), getSelectionEnd(), ClickableSpan.class);
            if (links.length > 0) {
                links[0].onClick(this);
                handled = true;
            }
        }
        if (touchIsFinished && (isTextEditable() || textIsSelectable)) {
            // Show the IME, except when selecting in read-only text.
            final InputMethodManager imm = InputMethodManager.peekInstance();
            viewClicked(imm);
            if (isTextEditable() && mEditor.mShowSoftInputOnFocus && imm != null) {
                imm.showSoftInput(this, 0);
            }
            // The above condition ensures that the mEditor is not null
            mEditor.onTouchUpEvent(event);
            handled = true;
        }
        if (handled) {
            return true;
        }
    }
    return superResult;
}","{
    final int action = event.getActionMasked();
    if (mEditor != null) {
        mEditor.onTouchEvent(event);
        if (mEditor.mSelectionModifierCursorController != null && mEditor.mSelectionModifierCursorController.isDragAcceleratorActive()) {
            return true;
        }
    }
    final boolean superResult = super.onTouchEvent(event);
    /*
         * Don't handle the release after a long press, because it will move the selection away from
         * whatever the menu action was trying to affect. If the long press should have triggered an
         * insertion action mode, we can now actually show it.
         */
    if (mEditor != null && mEditor.mDiscardNextActionUp && action == MotionEvent.ACTION_UP) {
        mEditor.mDiscardNextActionUp = false;
        if (mEditor.mIsInsertionActionModeStartPending) {
            mEditor.startInsertionActionMode();
            mEditor.mIsInsertionActionModeStartPending = false;
        }
        return superResult;
    }
    final boolean touchIsFinished = (action == MotionEvent.ACTION_UP) && (mEditor == null || !mEditor.mIgnoreActionUpEvent) && isFocused();
    if ((mMovement != null || onCheckIsTextEditor()) && isEnabled() && mText instanceof Spannable && mLayout != null) {
        boolean handled = false;
        if (mMovement != null) {
            handled |= mMovement.onTouchEvent(this, mSpannable, event);
        }
        final boolean textIsSelectable = isTextSelectable();
        if (touchIsFinished && mLinksClickable && mAutoLinkMask != 0 && textIsSelectable) {
            // The LinkMovementMethod which should handle taps on links has not been installed
            // on non editable text that support text selection.
            // We reproduce its behavior here to open links for these.
            ClickableSpan[] links = mSpannable.getSpans(getSelectionStart(), getSelectionEnd(), ClickableSpan.class);
            if (links.length > 0) {
                links[0].onClick(this);
                handled = true;
            }
        }
        if (touchIsFinished && (isTextEditable() || textIsSelectable)) {
            // Show the IME, except when selecting in read-only text.
            final InputMethodManager imm = InputMethodManager.peekInstance();
            viewClicked(imm);
            if (isTextEditable() && mEditor.mShowSoftInputOnFocus && imm != null) {
                imm.showSoftInput(this, 0);
            }
            // The above condition ensures that the mEditor is not null
            mEditor.onTouchUpEvent(event);
            handled = true;
        }
        if (handled) {
            return true;
        }
    }
    return superResult;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,,,,
121,<android.os.WorkSource: String toString()>,27,28,<android.os.WorkSource: String toString()>,<android.os.WorkSource: String toString()>,0,"{
    StringBuilder result = new StringBuilder();
    result.append(""WorkSource{"");
    for (int i = 0; i < mNum; i++) {
        if (i != 0) {
            result.append("", "");
        }
        result.append(mUids[i]);
        if (mNames != null) {
            result.append("" "");
            result.append(mNames[i]);
        }
    }
    result.append(""}"");
    return result.toString();
}","{
    StringBuilder result = new StringBuilder();
    result.append(""WorkSource{"");
    for (int i = 0; i < mNum; i++) {
        if (i != 0) {
            result.append("", "");
        }
        result.append(mUids[i]);
        if (mNames != null) {
            result.append("" "");
            result.append(mNames[i]);
        }
    }
    if (mChains != null) {
        result.append("" chains="");
        for (int i = 0; i < mChains.size(); ++i) {
            if (i != 0) {
                result.append("", "");
            }
            result.append(mChains.get(i));
        }
    }
    result.append(""}"");
    return result.toString();
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,4",1,"There's an additional block of code that appends information from `mChains` to the `StringBuilder` in the late version, and this modifies the outcome of the `toString()` method, so the code change type is 1,4 because of the addition of new return data and other statements.","The addition to the `toString()` representation affects the return value by potentially adding "" chains="" and the chains data to the output, which is not present in the early version. Hence, the API potentially returns a different value (the string representation), leading to a CI type of 1."
122,<android.bluetooth.BluetoothGatt: boolean requestMtu(int)>,27,28,<android.bluetooth.BluetoothGatt: boolean requestMtu(int)>,<android.bluetooth.BluetoothGatt: boolean requestMtu(int)>,0,"{
    if (DBG)
        Log.d(TAG, ""configureMTU() - device: "" + mDevice.getAddress() + "" mtu: "" + mtu);
    if (mService == null || mClientIf == 0)
        return false;
    try {
        mService.configureMTU(mClientIf, mDevice.getAddress(), mtu);
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
        return false;
    }
    return true;
}","{
    if (DBG) {
        Log.d(TAG, ""configureMTU() - device: "" + mDevice.getAddress() + "" mtu: "" + mtu);
    }
    if (mService == null || mClientIf == 0)
        return false;
    try {
        mService.configureMTU(mClientIf, mDevice.getAddress(), mtu);
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
        return false;
    }
    return true;
}",1,"/**
 * Request an MTU size used for a given connection.
 *
 * <p>When performing a write request operation (write without response),
 * the data sent is truncated to the MTU size. This function may be used
 * to request a larger MTU size to be able to send more data at once.
 *
 * <p>A {@link BluetoothGattCallback#onMtuChanged} callback will indicate
 * whether this operation was successful.
 *
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH} permission.
 *
 * @return true, if the new MTU value has been requested successfully
 */
","/**
 * Request an MTU size used for a given connection.
 *
 * <p>When performing a write request operation (write without response),
 * the data sent is truncated to the MTU size. This function may be used
 * to request a larger MTU size to be able to send more data at once.
 *
 * <p>A {@link BluetoothGattCallback#onMtuChanged} callback will indicate
 * whether this operation was successful.
 *
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH} permission.
 *
 * @return true, if the new MTU value has been requested successfully
 */
",-1,,,-1,-1,-1,-1,-1,-1,0,0,"There is only a stylistic change in how the if (DBG) conditional block is formatted, with no change to the actual code execution or logic.","There is no Compatibility Issue because the modifications between versions do not affect the functionality or behavior of the method; there are no changes to the return values, exceptions thrown, control flow, or dependent APIs."
123,<android.content.res.AssetManager: AssetFileDescriptor openFd(String)>,27,28,<android.content.res.AssetManager: AssetFileDescriptor openFd(String)>,<android.content.res.AssetManager: AssetFileDescriptor openFd(String)>,0,"{
    synchronized (this) {
        if (!mOpen) {
            throw new RuntimeException(""Assetmanager has been closed"");
        }
        ParcelFileDescriptor pfd = openAssetFd(fileName, mOffsets);
        if (pfd != null) {
            return new AssetFileDescriptor(pfd, mOffsets[0], mOffsets[1]);
        }
    }
    throw new FileNotFoundException(""Asset file: "" + fileName);
}","{
    Preconditions.checkNotNull(fileName, ""fileName"");
    synchronized (this) {
        ensureOpenLocked();
        final ParcelFileDescriptor pfd = nativeOpenAssetFd(mObject, fileName, mOffsets);
        if (pfd == null) {
            throw new FileNotFoundException(""Asset file: "" + fileName);
        }
        return new AssetFileDescriptor(pfd, mOffsets[0], mOffsets[1]);
    }
}",1,,"/**
 * Open an uncompressed asset by mmapping it and returning an {@link AssetFileDescriptor}.
 * This provides access to files that have been bundled with an application as assets -- that
 * is, files placed in to the ""assets"" directory.
 *
 * The asset must be uncompressed, or an exception will be thrown.
 *
 * @param fileName The name of the asset to open.  This name can be hierarchical.
 * @return An open AssetFileDescriptor.
 */
",-1,,[@NonNull],-1,-1,-1,-1,-1,-1,"2,3,4,5",2,"The implementation has introduced a new method call (Preconditions.checkNotNull), modified a control statement (the if condition inside synchronized block has been replaced with ensureOpenLocked()), introduced a new throw statement for FileNotFoundException inside the synchronized block, and changed the method called for opening asset file descriptor (from openAssetFd to nativeOpenAssetFd). Thus, the change types are 2,3,4,5.","Since a new throw statement for FileNotFoundException has been added within the synchronized block and the way the file descriptor is obtained has changed (which could potentially throw a different exception), there is a Compatibility Issue of type 2 due to potential different exception handling."
126,<android.app.admin.DevicePolicyManager: void wipeData(int)>,27,28,<android.app.admin.DevicePolicyManager: void wipeData(int)>,<android.app.admin.DevicePolicyManager: void wipeData(int)>,0,"{
    throwIfParentInstance(""wipeData"");
    if (mService != null) {
        try {
            mService.wipeData(flags);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }
}","{
    throwIfParentInstance(""wipeData"");
    final String wipeReasonForUser = mContext.getString(R.string.work_profile_deleted_description_dpm_wipe);
    wipeDataInternal(flags, wipeReasonForUser);
}",1,"/**
 * Ask that all user data be wiped. If called as a secondary user, the user will be removed and
 * other users will remain unaffected. Calling from the primary user will cause the device to
 * reboot, erasing all device data - including all the secondary users and their data - while
 * booting up.
 * <p>
 * The calling device admin must have requested {@link DeviceAdminInfo#USES_POLICY_WIPE_DATA} to
 * be able to call this method; if it has not, a security exception will be thrown.
 *
 * @param flags Bit mask of additional options: currently supported flags are
 * {@link #WIPE_EXTERNAL_STORAGE} and {@link #WIPE_RESET_PROTECTION_DATA}.
 * @throws SecurityException if the calling application does not own an active administrator
 * that uses {@link DeviceAdminInfo#USES_POLICY_WIPE_DATA}
 */
","/**
 * Ask that all user data be wiped. If called as a secondary user, the user will be removed and
 * other users will remain unaffected. Calling from the primary user will cause the device to
 * reboot, erasing all device data - including all the secondary users and their data - while
 * booting up.
 * <p>
 * The calling device admin must have requested {@link DeviceAdminInfo#USES_POLICY_WIPE_DATA} to
 * be able to call this method; if it has not, a security exception will be thrown.
 *
 * @param flags Bit mask of additional options: currently supported flags are
 * {@link #WIPE_EXTERNAL_STORAGE} and {@link #WIPE_RESET_PROTECTION_DATA}.
 * @throws SecurityException if the calling application does not own an active administrator
 * that uses {@link DeviceAdminInfo#USES_POLICY_WIPE_DATA}
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"The early version code directly calls `mService.wipeData(flags)` inside an if-check, which can throw a `RemoteException`. In the late version, it calls a new function `wipeDataInternal(flags, wipeReasonForUser)` and passes new local string value `wipeReasonForUser` as a parameter. There's no visible change in how exceptions are handled or return statements, so the code change involves other statements changed (4) and dependent APIs changed (5).",There is no compatibility issue because the method signature remains void and there are no changes in the exception signature.
127,"<android.view.textclassifier.TextClassifier: TextClassification classifyText(CharSequence,int,int,LocaleList)>",27,28,"<android.view.textclassifier.TextClassifier: TextClassification classifyText(CharSequence,int,int,LocaleList)>","<android.view.textclassifier.TextClassifier: TextClassification classifyText(CharSequence,int,int,LocaleList)>",0,,"{
    final TextClassification.Request request = new TextClassification.Request.Builder(text, startIndex, endIndex).setDefaultLocales(defaultLocales).build();
    return classifyText(request);
}",1,"/**
 * Classifies the specified text and returns a {@link TextClassification} object that can be
 * used to generate a widget for handling the classified text.
 *
 * @param text text providing context for the text to classify (which is specified
 * by the sub sequence starting at startIndex and ending at endIndex)
 * @param startIndex start index of the text to classify
 * @param endIndex end index of the text to classify
 * @param defaultLocales ordered list of locale preferences that can be used to disambiguate
 * the provided text. If no locale preferences exist, set this to null or an empty locale
 * list in which case the classifier will decide whether to use no locale information, use
 * a default locale, or use the system default.
 *
 * @throws IllegalArgumentException if text is null; startIndex is negative;
 * endIndex is greater than text.length() or not greater than startIndex
 */
","/**
 * Classifies the specified text and returns a {@link TextClassification} object that can be
 * used to generate a widget for handling the classified text.
 *
 * <p><strong>NOTE: </strong>Call on a worker thread.
 *
 * <p><b>NOTE:</b> Do not implement. The default implementation of this method calls
 * {@link #classifyText(TextClassification.Request)}. If that method calls this method,
 * a stack overflow error will happen.
 *
 * <strong>NOTE: </strong>If a TextClassifier has been destroyed, calls to this method should
 * throw an {@link IllegalStateException}. See {@link #isDestroyed()}.
 *
 * @param text text providing context for the text to classify (which is specified
 * by the sub sequence starting at startIndex and ending at endIndex)
 * @param startIndex start index of the text to classify
 * @param endIndex end index of the text to classify
 * @param defaultLocales ordered list of locale preferences that may be used to
 * disambiguate the provided text. If no locale preferences exist, set this to null
 * or an empty locale list.
 *
 * @throws IllegalArgumentException if text is null; startIndex is negative;
 * endIndex is greater than text.length() or not greater than startIndex
 *
 * @see #classifyText(TextClassification.Request)
 */
",-1,"[@WorkerThread, @NonNull]","[@WorkerThread, @NonNull]",-1,-1,-1,-1,-1,-1,4,0,"The early version does not have an implemented method body (it's marked as 'nan'), therefore, the addition of the method body in the late version qualifies as 'Other statement changed', which is code change type 4.",There is no Compatibility Issue since we are transitioning from a non-existing implementation ('nan') to an actual implementation. This is generally considered an addition of a new method rather than a change that could break existing functionality.
128,"<android.app.LoadedApk.ServiceDispatcher: void doConnected(ComponentName,IBinder,boolean)>",27,28,"<android.app.LoadedApk.ServiceDispatcher: void doConnected(ComponentName,IBinder,boolean)>","<android.app.LoadedApk.ServiceDispatcher: void doConnected(ComponentName,IBinder,boolean)>",0,"{
    ServiceDispatcher.ConnectionInfo old;
    ServiceDispatcher.ConnectionInfo info;
    synchronized (this) {
        if (mForgotten) {
            // any connection received.
            return;
        }
        old = mActiveConnections.get(name);
        if (old != null && old.binder == service) {
            // Huh, already have this one.  Oh well!
            return;
        }
        if (service != null) {
            // A new service is being connected... set it all up.
            info = new ConnectionInfo();
            info.binder = service;
            info.deathMonitor = new DeathMonitor(name, service);
            try {
                service.linkToDeath(info.deathMonitor, 0);
                mActiveConnections.put(name, info);
            } catch (RemoteException e) {
                // This service was dead before we got it...  just
                // don't do anything with it.
                mActiveConnections.remove(name);
                return;
            }
        } else {
            // The named service is being disconnected... clean up.
            mActiveConnections.remove(name);
        }
        if (old != null) {
            old.binder.unlinkToDeath(old.deathMonitor, 0);
        }
    }
    // If there was an old service, it is now disconnected.
    if (old != null) {
        mConnection.onServiceDisconnected(name);
    }
    if (dead) {
        mConnection.onBindingDied(name);
    }
    // If there is a new service, it is now connected.
    if (service != null) {
        mConnection.onServiceConnected(name, service);
    }
}","{
    ServiceDispatcher.ConnectionInfo old;
    ServiceDispatcher.ConnectionInfo info;
    synchronized (this) {
        if (mForgotten) {
            // any connection received.
            return;
        }
        old = mActiveConnections.get(name);
        if (old != null && old.binder == service) {
            // Huh, already have this one.  Oh well!
            return;
        }
        if (service != null) {
            // A new service is being connected... set it all up.
            info = new ConnectionInfo();
            info.binder = service;
            info.deathMonitor = new DeathMonitor(name, service);
            try {
                service.linkToDeath(info.deathMonitor, 0);
                mActiveConnections.put(name, info);
            } catch (RemoteException e) {
                // This service was dead before we got it...  just
                // don't do anything with it.
                mActiveConnections.remove(name);
                return;
            }
        } else {
            // The named service is being disconnected... clean up.
            mActiveConnections.remove(name);
        }
        if (old != null) {
            old.binder.unlinkToDeath(old.deathMonitor, 0);
        }
    }
    // If there was an old service, it is now disconnected.
    if (old != null) {
        mConnection.onServiceDisconnected(name);
    }
    if (dead) {
        mConnection.onBindingDied(name);
    }
    // If there is a new viable service, it is now connected.
    if (service != null) {
        mConnection.onServiceConnected(name, service);
    } else {
        // The binding machinery worked, but the remote returned null from onBind().
        mConnection.onNullBinding(name);
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"3,4",0,"There is a new 'else' clause added after checking if the service is not null, which introduces a new method call (mConnection.onNullBinding(name)). The addition can be classified as a code change type 4, due to the new else block (adding another branch to the control-flow, hence it is also a change in control dependencies, type 3).","Even with the addition of the new method call in the 'else' block for the scenario when 'service' is null, it doesn't introduce a potential Compatibility Issue because this method call is executed in a situation which the previous version would have left unhandled. The handling of other conditions and return values has remained unchanged, meaning this change does not affect the existing contract of the method and will not cause returning a different variable or throwing a new exception when called with the same parameters and state as before. Therefore, it is classified as 0, indicating no Compatibility Issue."
129,<android.os.Environment: boolean isExternalStorageEmulated()>,27,28,<android.os.Environment: boolean isExternalStorageEmulated()>,<android.os.Environment: boolean isExternalStorageEmulated()>,0,"{
    if (isStorageDisabled())
        return false;
    final File externalDir = sCurrentUser.getExternalDirs()[0];
    return isExternalStorageEmulated(externalDir);
}","{
    final File externalDir = sCurrentUser.getExternalDirs()[0];
    return isExternalStorageEmulated(externalDir);
}",1,"/**
 * Returns whether the primary shared/external storage media is emulated.
 * <p>
 * The contents of emulated storage devices are backed by a private user
 * data partition, which means there is little benefit to apps storing data
 * here instead of the private directories returned by
 * {@link Context#getFilesDir()}, etc.
 * <p>
 * This returns true when emulated storage is backed by either internal
 * storage or an adopted storage device.
 *
 * @see DevicePolicyManager#setStorageEncryption(android.content.ComponentName,
 * boolean)
 */
","/**
 * Returns whether the primary shared/external storage media is emulated.
 * <p>
 * The contents of emulated storage devices are backed by a private user
 * data partition, which means there is little benefit to apps storing data
 * here instead of the private directories returned by
 * {@link Context#getFilesDir()}, etc.
 * <p>
 * This returns true when emulated storage is backed by either internal
 * storage or an adopted storage device.
 *
 * @see DevicePolicyManager#setStorageEncryption(android.content.ComponentName,
 * boolean)
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,1,"The control dependency has changed as the 'if' statement has been removed from the early implementation to the late implementation, therefore, this is an 'Other statement changed' (code change type is 4).","Because the control dependency to check 'isStorageDisabled()' has been removed, it means that in the late version, this method will no longer potentially return 'false' in the case when storage is disabled. This constitutes a CI because the API can return a different value due to the removal of this conditional check (CI type 1)."
132,<android.speech.tts.TextToSpeechService.SynthHandler: int stopAll()>,27,28,<android.speech.tts.TextToSpeechService.SynthHandler: int stopAll()>,<android.speech.tts.TextToSpeechService.SynthHandler: int stopAll()>,0,"{
    // Order to flush pending messages
    startFlushingSpeechItems(null);
    // Stop the current speech item unconditionally .
    SpeechItem current = setCurrentSpeechItem(null);
    if (current != null) {
        current.stop();
    }
    // Remove all pending playback as well.
    mAudioPlaybackHandler.stop();
    // Message to stop flushing pending messages
    Runnable runnable = new Runnable() {

        @Override
        public void run() {
            endFlushingSpeechItems(null);
        }
    };
    sendMessage(Message.obtain(this, runnable));
    return TextToSpeech.SUCCESS;
}","{
    // Order to flush pending messages
    startFlushingSpeechItems(null);
    // Stop the current speech item unconditionally .
    SpeechItem current = removeCurrentSpeechItem();
    if (current != null) {
        current.stop();
    }
    // Remove all pending playback as well.
    mAudioPlaybackHandler.stop();
    // Message to stop flushing pending messages
    Runnable runnable = new Runnable() {

        @Override
        public void run() {
            endFlushingSpeechItems(null);
        }
    };
    sendMessage(Message.obtain(this, runnable));
    return TextToSpeech.SUCCESS;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"The change is in the method call from setCurrentSpeechItem(null) to removeCurrentSpeechItem(). This change is a modification to a method invocation, which implies the dependent API has changed, so the code change types are 4, 5.","Although there is a change in the method invocation, there is no indication that this change leads to a different return value or a different exception handling pattern, because the returned value from the method is not directly linked to the return statement of the API, and the method call itself doesn't involve any try-catch blocks that could throw a different exception. Thus, there is no compatibility issue, and the CI type is 0."
134,<android.view.ViewRootImpl.SendWindowContentChangedAccessibilityEvent: void run()>,27,28,<android.view.ViewRootImpl.SendWindowContentChangedAccessibilityEvent: void run()>,<android.view.ViewRootImpl.SendWindowContentChangedAccessibilityEvent: void run()>,0,"{
    // Protect against re-entrant code and attempt to do the right thing in the case that
    // we're multithreaded.
    View source = mSource;
    mSource = null;
    if (source == null) {
        Log.e(TAG, ""Accessibility content change has no source"");
        return;
    }
    // The accessibility may be turned off while we were waiting so check again.
    if (AccessibilityManager.getInstance(mContext).isEnabled()) {
        mLastEventTimeMillis = SystemClock.uptimeMillis();
        AccessibilityEvent event = AccessibilityEvent.obtain();
        event.setEventType(AccessibilityEvent.TYPE_WINDOW_CONTENT_CHANGED);
        event.setContentChangeTypes(mChangeTypes);
        source.sendAccessibilityEventUnchecked(event);
    } else {
        mLastEventTimeMillis = 0;
    }
    // In any case reset to initial state.
    source.resetSubtreeAccessibilityStateChanged();
    mChangeTypes = 0;
}","{
    // Protect against re-entrant code and attempt to do the right thing in the case that
    // we're multithreaded.
    View source = mSource;
    mSource = null;
    if (source == null) {
        Log.e(TAG, ""Accessibility content change has no source"");
        return;
    }
    // The accessibility may be turned off while we were waiting so check again.
    if (AccessibilityManager.getInstance(mContext).isEnabled()) {
        mLastEventTimeMillis = SystemClock.uptimeMillis();
        AccessibilityEvent event = AccessibilityEvent.obtain();
        event.setEventType(AccessibilityEvent.TYPE_WINDOW_CONTENT_CHANGED);
        event.setContentChangeTypes(mChangeTypes);
        if (AccessibilityEvent.DEBUG_ORIGIN)
            event.originStackTrace = mOrigin;
        source.sendAccessibilityEventUnchecked(event);
    } else {
        mLastEventTimeMillis = 0;
    }
    // In any case reset to initial state.
    source.resetSubtreeAccessibilityStateChanged();
    mChangeTypes = 0;
    if (AccessibilityEvent.DEBUG_ORIGIN)
        mOrigin = null;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"There is a conditional block that assigns a value to 'event.originStackTrace' and another that sets 'mOrigin' to null, but both are conditioned on 'AccessibilityEvent.DEBUG_ORIGIN'. These additions represent a change in type 4 (Other statement changed).","These changes do not result in a compatibility issue. The setting of 'event.originStackTrace' and resetting of 'mOrigin' are dependent on a debug flag 'AccessibilityEvent.DEBUG_ORIGIN'. Unless this debug flag is enabled, the behavior of the method remains the same as the early version, and the flag is typically not enabled in production builds. Therefore, this change should not affect API users and does not lead to different return values or exceptions being thrown. Hence, there is no compatibility issue."
135,"<android.view.inputmethod.InputMethodManager: void showStatusIcon(IBinder,String,int)>",27,28,"<android.view.inputmethod.InputMethodManager: void showStatusIcon(IBinder,String,int)>","<android.view.inputmethod.InputMethodManager: void showStatusIcon(IBinder,String,int)>",0,"{
    try {
        mService.updateStatusIcon(imeToken, packageName, iconId);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}","{
    showStatusIconInternal(imeToken, packageName, iconId);
}",1,,"/**
 * @deprecated Use {@link InputMethodService#showStatusIcon(int)} instead. This method was
 * intended for IME developers who should be accessing APIs through the service. APIs in this
 * class are intended for app developers interacting with the IME.
 */
",-1,,[@Deprecated],-1,-1,-1,-1,-1,-1,5,0,"The early version of the implementation directly calls `mService.updateStatusIcon(imeToken, packageName, iconId)`, while the late version introduces a new internal method `showStatusIconInternal(imeToken, packageName, iconId)`. The actual implementation logic is replaced with a method call to a new internal method, so the code change type is 5, Dependent API changed.","There is no direct indication that the behavior of the API has been altered because the internal method could simply be a refactoring that does not change the outward behavior of `showStatusIcon`. Without further information about the internal workings of `showStatusIconInternal`, we cannot confirm a change in return value/type or exception handling and hence, should indicate No Compatibility Issue."
137,<android.app.job.JobInfo: long getIntervalMillis()>,27,28,<android.app.job.JobInfo: long getIntervalMillis()>,<android.app.job.JobInfo: long getIntervalMillis()>,0,"{
    final long minInterval = getMinPeriodMillis();
    return intervalMillis >= minInterval ? intervalMillis : minInterval;
}","{
    return intervalMillis;
}",1,"/**
 * Set to the interval between occurrences of this job. This value is <b>not</b> set if the
 * job does not recur periodically.
 */
","/**
 * Set to the interval between occurrences of this job. This value is <b>not</b> set if the
 * job does not recur periodically.
 * @see JobInfo.Builder#setPeriodic(long)
 * @see JobInfo.Builder#setPeriodic(long, long)
 */
",-1,,,-1,-1,-1,-1,-1,-1,1,1,"The early version involves a check against minInterval, while the late version simply returns intervalMillis, so the code change type is 1.","Due to the removal of the comparison against minInterval, the method might return different values now if intervalMillis is less than what was previously considered the minimum interval, hence the change could result in a different return value and the CI type is 1."
138,<android.widget.Editor.SuggestionsPopupWindow: int getVerticalLocalPosition(int)>,27,28,<android.widget.Editor.SuggestionsPopupWindow: int getVerticalLocalPosition(int)>,<android.widget.Editor.SuggestionsPopupWindow: int getVerticalLocalPosition(int)>,0,"{
    return mTextView.getLayout().getLineBottom(line) - mContainerMarginTop;
}","{
    final Layout layout = mTextView.getLayout();
    return layout.getLineBottomWithoutSpacing(line) - mContainerMarginTop;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,5",1,"The method called to obtain the line bottom position has changed from getLineBottom(line) to getLineBottomWithoutSpacing(line), which also implies the returned value could potentially be different due to the change in the dependent API. Therefore, the change type is 1 for return statement changed and 5 for dependent API changed.","The change in the method called to obtain the vertical local position potentially leads to a different return value, hence the CI type is 1 for potential different return values."
139,<android.content.ClipboardManager: void setPrimaryClip(ClipData)>,27,28,<android.content.ClipboardManager: void setPrimaryClip(ClipData)>,<android.content.ClipboardManager: void setPrimaryClip(ClipData)>,0,"{
    try {
        if (clip != null) {
            clip.prepareToLeaveProcess(true);
        }
        mService.setPrimaryClip(clip, mContext.getOpPackageName());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}","{
    try {
        Preconditions.checkNotNull(clip);
        clip.prepareToLeaveProcess(true);
        mService.setPrimaryClip(clip, mContext.getOpPackageName());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Sets the current primary clip on the clipboard.  This is the clip that
 * is involved in normal cut and paste operations.
 *
 * @param clip The clipped data item to set.
 */
","/**
 * Sets the current primary clip on the clipboard.  This is the clip that
 * is involved in normal cut and paste operations.
 *
 * @param clip The clipped data item to set.
 * @see #getPrimaryClip()
 * @see #clearPrimaryClip()
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",0,"The code change includes the introduction of a new method call to Preconditions.checkNotNull(clip), which is a control dependency change (type 3), and an explicit null check (type 4).","The use of Preconditions.checkNotNull(clip) will explicitly throw a NullPointerException if clip is null, which was previously allowed to pass through until the mService.setPrimaryClip(clip, mContext.getOpPackageName()) method potentially handled it. This is more of an assertion on the method's contract that the input should not be null. However, since this expression throws an unchecked exception (NullPointerException), this change does not constitute a compatibility issue related to exception handling because the prior behavior when passing a null would have led to a failure (NullPointerException) when calling clip.prepareToLeaveProcess(true). Thus, the API's contract appears to be stricter, but does not necessarily alter the API's behavior regarding compatibility as null input was not valid usage of the API. Therefore, there is no CI."
141,<android.net.ConnectivityManager.CallbackHandler: void handleMessage(Message)>,27,28,<android.net.ConnectivityManager.CallbackHandler: void handleMessage(Message)>,<android.net.ConnectivityManager.CallbackHandler: void handleMessage(Message)>,0,"{
    if (message.what == EXPIRE_LEGACY_REQUEST) {
        expireRequest((NetworkCapabilities) message.obj, message.arg1);
        return;
    }
    final NetworkRequest request = getObject(message, NetworkRequest.class);
    final Network network = getObject(message, Network.class);
    final NetworkCallback callback;
    synchronized (sCallbacks) {
        callback = sCallbacks.get(request);
    }
    if (DBG) {
        Log.d(TAG, getCallbackName(message.what) + "" for network "" + network);
    }
    if (callback == null) {
        Log.w(TAG, ""callback not found for "" + getCallbackName(message.what) + "" message"");
        return;
    }
    switch(message.what) {
        case CALLBACK_PRECHECK:
            {
                callback.onPreCheck(network);
                break;
            }
        case CALLBACK_AVAILABLE:
            {
                callback.onAvailable(network);
                break;
            }
        case CALLBACK_LOSING:
            {
                callback.onLosing(network, message.arg1);
                break;
            }
        case CALLBACK_LOST:
            {
                callback.onLost(network);
                break;
            }
        case CALLBACK_UNAVAIL:
            {
                callback.onUnavailable();
                break;
            }
        case CALLBACK_CAP_CHANGED:
            {
                NetworkCapabilities cap = getObject(message, NetworkCapabilities.class);
                callback.onCapabilitiesChanged(network, cap);
                break;
            }
        case CALLBACK_IP_CHANGED:
            {
                LinkProperties lp = getObject(message, LinkProperties.class);
                callback.onLinkPropertiesChanged(network, lp);
                break;
            }
        case CALLBACK_SUSPENDED:
            {
                callback.onNetworkSuspended(network);
                break;
            }
        case CALLBACK_RESUMED:
            {
                callback.onNetworkResumed(network);
                break;
            }
    }
}","{
    if (message.what == EXPIRE_LEGACY_REQUEST) {
        expireRequest((NetworkCapabilities) message.obj, message.arg1);
        return;
    }
    final NetworkRequest request = getObject(message, NetworkRequest.class);
    final Network network = getObject(message, Network.class);
    final NetworkCallback callback;
    synchronized (sCallbacks) {
        callback = sCallbacks.get(request);
    }
    if (DBG) {
        Log.d(TAG, getCallbackName(message.what) + "" for network "" + network);
    }
    if (callback == null) {
        Log.w(TAG, ""callback not found for "" + getCallbackName(message.what) + "" message"");
        return;
    }
    switch(message.what) {
        case CALLBACK_PRECHECK:
            {
                callback.onPreCheck(network);
                break;
            }
        case CALLBACK_AVAILABLE:
            {
                NetworkCapabilities cap = getObject(message, NetworkCapabilities.class);
                LinkProperties lp = getObject(message, LinkProperties.class);
                callback.onAvailable(network, cap, lp);
                break;
            }
        case CALLBACK_LOSING:
            {
                callback.onLosing(network, message.arg1);
                break;
            }
        case CALLBACK_LOST:
            {
                callback.onLost(network);
                break;
            }
        case CALLBACK_UNAVAIL:
            {
                callback.onUnavailable();
                break;
            }
        case CALLBACK_CAP_CHANGED:
            {
                NetworkCapabilities cap = getObject(message, NetworkCapabilities.class);
                callback.onCapabilitiesChanged(network, cap);
                break;
            }
        case CALLBACK_IP_CHANGED:
            {
                LinkProperties lp = getObject(message, LinkProperties.class);
                callback.onLinkPropertiesChanged(network, lp);
                break;
            }
        case CALLBACK_SUSPENDED:
            {
                callback.onNetworkSuspended(network);
                break;
            }
        case CALLBACK_RESUMED:
            {
                callback.onNetworkResumed(network);
                break;
            }
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,4,5",1,"The method CALLBACK_AVAILABLE has been significantly changed: it now calls the 'onAvailable' method with three parameters (network, cap, and lp) instead of one (network), which means that the implementation has changed, introducing new objects as parameters (cap and lp). Therefore, changes are affecting control dependency, other statements, and a dependent API, so the change types are 3,4,5.","The behavior of the 'onAvailable' method within CALLBACK_AVAILABLE case is altered because it now provides additional context regarding network capabilities and link properties to the callback. This means the API potentially returns different variables (as the callback now includes extra parameters), which indicates a Compatibility Issue, and the type is 1."
143,<android.hardware.camera2.impl.CameraDeviceImpl: void binderDied()>,27,28,<android.hardware.camera2.impl.CameraDeviceImpl: void binderDied()>,<android.hardware.camera2.impl.CameraDeviceImpl: void binderDied()>,0,"{
    Log.w(TAG, ""CameraDevice "" + mCameraId + "" died unexpectedly"");
    if (mRemoteDevice == null) {
        // Camera already closed
        return;
    }
    mInError = true;
    Runnable r = new Runnable() {

        @Override
        public void run() {
            if (!isClosed()) {
                mDeviceCallback.onError(CameraDeviceImpl.this, StateCallback.ERROR_CAMERA_SERVICE);
            }
        }
    };
    CameraDeviceImpl.this.mDeviceHandler.post(r);
}","{
    Log.w(TAG, ""CameraDevice "" + mCameraId + "" died unexpectedly"");
    if (mRemoteDevice == null) {
        // Camera already closed
        return;
    }
    mInError = true;
    Runnable r = new Runnable() {

        @Override
        public void run() {
            if (!isClosed()) {
                mDeviceCallback.onError(CameraDeviceImpl.this, StateCallback.ERROR_CAMERA_SERVICE);
            }
        }
    };
    final long ident = Binder.clearCallingIdentity();
    try {
        CameraDeviceImpl.this.mDeviceExecutor.execute(r);
    } finally {
        Binder.restoreCallingIdentity(ident);
    }
}",1,"/**
 * Listener for binder death.
 *
 * <p> Handle binder death for ICameraDeviceUser. Trigger onError.</p>
 */
","/**
 * Listener for binder death.
 *
 * <p> Handle binder death for ICameraDeviceUser. Trigger onError.</p>
 */
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"The code change involves the way the Runnable is executed with the handler changing from mDeviceHandler.post(r) to CameraDeviceImpl.this.mDeviceExecutor.execute(r); also, there's the addition of Binder.clearCallingIdentity and Binder.restoreCallingIdentity surrounding the execution. This is classified as another statement changed (4).","No Compatibility Issue is expected to arise based on this change, as the behavior of the Runnable remains unchanged, and the Runnable itself is not modified. The Runnable will be still executed in both versions, and will call the same onError method with the same arguments if the camera is not closed. Despite the change in the execution method and the identity clearing, these do not affect the API's observable behavior from a caller's perspective. Thus, no Compatibility Issue (0)."
145,"<android.bluetooth.BluetoothSocket: int read(byte[],int,int)>",27,28,"<android.bluetooth.BluetoothSocket: int read(byte[],int,int)>","<android.bluetooth.BluetoothSocket: int read(byte[],int,int)>",0,"{
    int ret = 0;
    if (VDBG)
        Log.d(TAG, ""read in:  "" + mSocketIS + "" len: "" + length);
    if (mType == TYPE_L2CAP) {
        int bytesToRead = length;
        if (VDBG)
            Log.v(TAG, ""l2cap: read(): offset: "" + offset + "" length:"" + length + ""mL2capBuffer= "" + mL2capBuffer);
        if (mL2capBuffer == null) {
            createL2capRxBuffer();
        }
        if (mL2capBuffer.remaining() == 0) {
            if (VDBG)
                Log.v(TAG, ""l2cap buffer empty, refilling..."");
            if (fillL2capRxBuffer() == -1) {
                return -1;
            }
        }
        if (bytesToRead > mL2capBuffer.remaining()) {
            bytesToRead = mL2capBuffer.remaining();
        }
        if (VDBG)
            Log.v(TAG, ""get(): offset: "" + offset + "" bytesToRead: "" + bytesToRead);
        mL2capBuffer.get(b, offset, bytesToRead);
        ret = bytesToRead;
    } else {
        if (VDBG)
            Log.v(TAG, ""default: read(): offset: "" + offset + "" length:"" + length);
        ret = mSocketIS.read(b, offset, length);
    }
    if (ret < 0)
        throw new IOException(""bt socket closed, read return: "" + ret);
    if (VDBG)
        Log.d(TAG, ""read out:  "" + mSocketIS + "" ret: "" + ret);
    return ret;
}","{
    int ret = 0;
    if (VDBG)
        Log.d(TAG, ""read in:  "" + mSocketIS + "" len: "" + length);
    if ((mType == TYPE_L2CAP) || (mType == TYPE_L2CAP_LE)) {
        int bytesToRead = length;
        if (VDBG) {
            Log.v(TAG, ""l2cap: read(): offset: "" + offset + "" length:"" + length + ""mL2capBuffer= "" + mL2capBuffer);
        }
        if (mL2capBuffer == null) {
            createL2capRxBuffer();
        }
        if (mL2capBuffer.remaining() == 0) {
            if (VDBG)
                Log.v(TAG, ""l2cap buffer empty, refilling..."");
            if (fillL2capRxBuffer() == -1) {
                return -1;
            }
        }
        if (bytesToRead > mL2capBuffer.remaining()) {
            bytesToRead = mL2capBuffer.remaining();
        }
        if (VDBG) {
            Log.v(TAG, ""get(): offset: "" + offset + "" bytesToRead: "" + bytesToRead);
        }
        mL2capBuffer.get(b, offset, bytesToRead);
        ret = bytesToRead;
    } else {
        if (VDBG)
            Log.v(TAG, ""default: read(): offset: "" + offset + "" length:"" + length);
        ret = mSocketIS.read(b, offset, length);
    }
    if (ret < 0) {
        throw new IOException(""bt socket closed, read return: "" + ret);
    }
    if (VDBG)
        Log.d(TAG, ""read out:  "" + mSocketIS + "" ret: "" + ret);
    return ret;
}",1,"/*package*/
","/*package*/
",-1,,,-1,-1,-1,-1,-1,-1,"3,5",1,"The condition statement in the first 'if' statement has changed, adding a check for `mType == TYPE_L2CAP_LE`. This is a change in the control dependency (3) and also a change in the dependent API as it newly includes the `TYPE_L2CAP_LE` type (5).","The inclusion of `TYPE_L2CAP_LE` in the condition may result in the `if` block being entered under different circumstances compared to the early version. This change could lead to a different return value when `mType == TYPE_L2CAP_LE`, thus causing a Compatibility Issue (1)."
146,<android.os.StrictMode.AndroidBlockGuardPolicy: void onReadFromDisk()>,27,28,<android.os.StrictMode.AndroidBlockGuardPolicy: void onReadFromDisk()>,<android.os.StrictMode.AndroidBlockGuardPolicy: void onReadFromDisk()>,0,"{
    if ((mPolicyMask & DETECT_DISK_READ) == 0) {
        return;
    }
    if (tooManyViolationsThisLoop()) {
        return;
    }
    BlockGuard.BlockGuardPolicyException e = new StrictModeDiskReadViolation(mPolicyMask);
    e.fillInStackTrace();
    startHandlingViolationException(e);
}","{
    if ((mPolicyMask & DETECT_DISK_READ) == 0) {
        return;
    }
    if (tooManyViolationsThisLoop()) {
        return;
    }
    startHandlingViolationException(new DiskReadViolation());
}",1,"// Part of BlockGuard.Policy interface:
","// Part of BlockGuard.Policy interface:
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",No Compatibility Issue,"The type of exception being created and passed to startHandlingViolationException() is changed from StrictModeDiskReadViolation to DiskReadViolation. This indicates that a dependent API has changed: BlockGuard.BlockGuardPolicyException has been replaced with DiskReadViolation. This qualifies as a change type 4,5.","There's no compatibility issue detected because the method's behavior in terms of control flow, returned values, and thrown exceptions remains consistent between the two versions. The way the violation is handled (logged or alerted) might internally be different due to the change in exception type, but from the perspective of this method's signature and its external contract, it still appropriately handles a disk read violation according to the current policy mask, and the external behavior (the API contract that involves throwing exceptions when the policy is violated) is identical. Thus, there's no change that would impact backward compatibility."
147,<android.view.accessibility.AccessibilityManager: List<AccessibilityServiceInfo> getEnabledAccessibilityServiceList(int)>,27,28,<android.view.accessibility.AccessibilityManager: List<AccessibilityServiceInfo> getEnabledAccessibilityServiceList(int)>,<android.view.accessibility.AccessibilityManager: List<AccessibilityServiceInfo> getEnabledAccessibilityServiceList(int)>,0,"{
    final IAccessibilityManager service;
    final int userId;
    synchronized (mLock) {
        service = getServiceLocked();
        if (service == null) {
            return Collections.emptyList();
        }
        userId = mUserId;
    }
    List<AccessibilityServiceInfo> services = null;
    try {
        services = service.getEnabledAccessibilityServiceList(feedbackTypeFlags, userId);
        if (DEBUG) {
            Log.i(LOG_TAG, ""Installed AccessibilityServices "" + services);
        }
    } catch (RemoteException re) {
        Log.e(LOG_TAG, ""Error while obtaining the installed AccessibilityServices. "", re);
    }
    if (services != null) {
        return Collections.unmodifiableList(services);
    } else {
        return Collections.emptyList();
    }
}","{
    final IAccessibilityManager service;
    final int userId;
    synchronized (mLock) {
        service = getServiceLocked();
        if (service == null) {
            return Collections.emptyList();
        }
        userId = mUserId;
    }
    List<AccessibilityServiceInfo> services = null;
    try {
        services = service.getEnabledAccessibilityServiceList(feedbackTypeFlags, userId);
        if (DEBUG) {
            Log.i(LOG_TAG, ""Installed AccessibilityServices "" + services);
        }
    } catch (RemoteException re) {
        Log.e(LOG_TAG, ""Error while obtaining the installed AccessibilityServices. "", re);
    }
    if (mAccessibilityPolicy != null) {
        services = mAccessibilityPolicy.getEnabledAccessibilityServiceList(feedbackTypeFlags, services);
    }
    if (services != null) {
        return Collections.unmodifiableList(services);
    } else {
        return Collections.emptyList();
    }
}",1,"/**
 * Returns the {@link AccessibilityServiceInfo}s of the enabled accessibility services
 * for a given feedback type.
 *
 * @param feedbackTypeFlags The feedback type flags.
 * @return An unmodifiable list with {@link AccessibilityServiceInfo}s.
 *
 * @see AccessibilityServiceInfo#FEEDBACK_AUDIBLE
 * @see AccessibilityServiceInfo#FEEDBACK_GENERIC
 * @see AccessibilityServiceInfo#FEEDBACK_HAPTIC
 * @see AccessibilityServiceInfo#FEEDBACK_SPOKEN
 * @see AccessibilityServiceInfo#FEEDBACK_VISUAL
 * @see AccessibilityServiceInfo#FEEDBACK_BRAILLE
 */
","/**
 * Returns the {@link AccessibilityServiceInfo}s of the enabled accessibility services
 * for a given feedback type.
 *
 * @param feedbackTypeFlags The feedback type flags.
 * @return An unmodifiable list with {@link AccessibilityServiceInfo}s.
 *
 * @see AccessibilityServiceInfo#FEEDBACK_AUDIBLE
 * @see AccessibilityServiceInfo#FEEDBACK_GENERIC
 * @see AccessibilityServiceInfo#FEEDBACK_HAPTIC
 * @see AccessibilityServiceInfo#FEEDBACK_SPOKEN
 * @see AccessibilityServiceInfo#FEEDBACK_VISUAL
 * @see AccessibilityServiceInfo#FEEDBACK_BRAILLE
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"A new if condition statement is added to potentially modify the list of services via mAccessibilityPolicy.getEnabledAccessibilityServiceList(), which does not change the method's signature or expected return type but could change the content of the returned list. This modification does not lead to a different return type nor does it introduce a new exception, therefore the code change type is 4.","No Compatibility Issue arises from this change because it does not alter the return type of the method and does not change the exception handling. The method still returns a list of AccessibilityServiceInfo objects and handles exceptions in the same way. The content of the list might change based on the policy, but this change aligns with the purpose of the method to provide a filtered list of enabled accessibility services."
148,<android.hardware.display.DisplayManagerInternal.DisplayPowerRequest: boolean equals(DisplayPowerRequest)>,27,28,<android.hardware.display.DisplayManagerInternal.DisplayPowerRequest: boolean equals(DisplayPowerRequest)>,<android.hardware.display.DisplayManagerInternal.DisplayPowerRequest: boolean equals(DisplayPowerRequest)>,0,"{
    return other != null && policy == other.policy && useProximitySensor == other.useProximitySensor && screenBrightness == other.screenBrightness && screenAutoBrightnessAdjustment == other.screenAutoBrightnessAdjustment && screenLowPowerBrightnessFactor == other.screenLowPowerBrightnessFactor && brightnessSetByUser == other.brightnessSetByUser && useAutoBrightness == other.useAutoBrightness && blockScreenOn == other.blockScreenOn && lowPowerMode == other.lowPowerMode && boostScreenBrightness == other.boostScreenBrightness && dozeScreenBrightness == other.dozeScreenBrightness && dozeScreenState == other.dozeScreenState;
}","{
    return other != null && policy == other.policy && useProximitySensor == other.useProximitySensor && screenBrightnessOverride == other.screenBrightnessOverride && useAutoBrightness == other.useAutoBrightness && floatEquals(screenAutoBrightnessAdjustmentOverride, other.screenAutoBrightnessAdjustmentOverride) && screenLowPowerBrightnessFactor == other.screenLowPowerBrightnessFactor && blockScreenOn == other.blockScreenOn && lowPowerMode == other.lowPowerMode && boostScreenBrightness == other.boostScreenBrightness && dozeScreenBrightness == other.dozeScreenBrightness && dozeScreenState == other.dozeScreenState;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"1,4",1,"The equality check logic in the return statement has changed with the addition of 'screenBrightnessOverride' and 'screenAutoBrightnessAdjustmentOverride', and the use of a new method 'floatEquals' to compare floating-point numbers. Additionally, 'screenBrightness' and 'screenAutoBrightnessAdjustment' comparison have been removed. These changes lead to a different set of checks being performed, thus other statements have changed, making the code change types 1,4.","Because the logic to determine equality between two DisplayPowerRequest objects has been altered, the 'equals' method might yield different results when comparing the current instance with another. This is a change that could result in a different return value, so the CI type is 1."
149,<android.hardware.radio.RadioManager.ProgramInfo: String toString()>,27,28,<android.hardware.radio.RadioManager.ProgramInfo: String toString()>,<android.hardware.radio.RadioManager.ProgramInfo: String toString()>,0,"{
    return ""ProgramInfo [mSelector="" + mSelector + "", mTuned="" + mTuned + "", mStereo="" + mStereo + "", mDigital="" + mDigital + "", mFlags="" + mFlags + "", mSignalStrength="" + mSignalStrength + ((mMetadata == null) ? """" : ("", mMetadata="" + mMetadata.toString())) + ""]"";
}","{
    return ""ProgramInfo"" + "" [selector="" + mSelector + "", logicallyTunedTo="" + Objects.toString(mLogicallyTunedTo) + "", physicallyTunedTo="" + Objects.toString(mPhysicallyTunedTo) + "", relatedContent="" + mRelatedContent.size() + "", infoFlags="" + mInfoFlags + "", mSignalQuality="" + mSignalQuality + "", mMetadata="" + Objects.toString(mMetadata) + ""]"";
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,4",0,"The implementation of the `toString()` method has changed its string concatenation, which implies a change in the content of the string being returned. It no longer includes `mTuned`, `mStereo`, `mDigital`, `mFlags`, and `mSignalStrength`. New fields like `mLogicallyTunedTo`, `mPhysicallyTunedTo`, `mRelatedContent.size()`, `mInfoFlags`, `mSignalQuality` are included in the string. This represents a change in other statements without control dependency changes or dependent API changes, so the change types are 1 and 4.","Even though there is a change in the content of the string returned by the `toString()` method, this would not typically be considered a Compatibility Issue, as `toString()` is generally used for human-readable output (e.g., debugging) rather than behavior that could affect program logic. It is unlikely to cause a compatibility problem unless an application incorrectly relies on parsing the output of `toString()`."
150,<android.util.proto.ProtoOutputStream: long startRepeatedObject(long)>,27,28,<android.util.proto.ProtoOutputStream: long startRepeatedObject(long)>,<android.util.proto.ProtoOutputStream: long startRepeatedObject(long)>,0,"{
    assertNotCompacted();
    final int id = checkFieldId(fieldId, FIELD_COUNT_REPEATED | FIELD_TYPE_OBJECT);
    return startObjectImpl(id, true);
}","{
    assertNotCompacted();
    final int id = checkFieldId(fieldId, FIELD_COUNT_REPEATED | FIELD_TYPE_MESSAGE);
    return startObjectImpl(id, true);
}",1,"/**
 * Start a repeated child object.
 *
 * Returns a token which should be passed to endObject.  Calls to endObject must be
 * nested properly.
 *
 * @deprecated Use #start() instead.
 */
","/**
 * Start a repeated child object.
 *
 * Returns a token which should be passed to endObject.  Calls to endObject must be
 * nested properly.
 *
 * @deprecated Use #start() instead.
 */
",-1,[@Deprecated],[@Deprecated],-1,-1,-1,-1,-1,-1,"4,5",0,"The constant used as the second argument in the checkFieldId method call has changed from FIELD_TYPE_OBJECT to FIELD_TYPE_MESSAGE. Therefore, the change is classified under 4 (Other statement changed). Despite the internal constant used in the second argument changing, the overall behavior and signature of the method remains the same. Additionally, since FIELD_TYPE_OBJECT and FIELD_TYPE_MESSAGE are constant values that pertain to the implementation details of the Protobuf encoding and DO NOT affect the outward contract of the API, the change in these constants should not introduce a Compatibility Issue on their own.",There is no Compatibility Issue since the change from FIELD_TYPE_OBJECT to FIELD_TYPE_MESSAGE does not alter the method's behavior from the perspective of an API consumer. The method's contract and signature remain constant and thus should behave consistently across both versions.
152,"<android.service.autofill.CharSequenceTransformation: void writeToParcel(Parcel,int)>",27,28,"<android.service.autofill.CharSequenceTransformation: void writeToParcel(Parcel,int)>","<android.service.autofill.CharSequenceTransformation: void writeToParcel(Parcel,int)>",0,"{
    final int size = mFields.size();
    final AutofillId[] ids = new AutofillId[size];
    final Pattern[] regexs = new Pattern[size];
    final String[] substs = new String[size];
    Pair<Pattern, String> pair;
    for (int i = 0; i < size; i++) {
        ids[i] = mFields.keyAt(i);
        pair = mFields.valueAt(i);
        regexs[i] = pair.first;
        substs[i] = pair.second;
    }
    parcel.writeParcelableArray(ids, flags);
    parcel.writeSerializable(regexs);
    parcel.writeStringArray(substs);
}","{
    final int size = mFields.size();
    final AutofillId[] ids = new AutofillId[size];
    final Pattern[] regexs = new Pattern[size];
    final String[] substs = new String[size];
    Pair<Pattern, String> pair;
    int i = 0;
    for (Entry<AutofillId, Pair<Pattern, String>> entry : mFields.entrySet()) {
        ids[i] = entry.getKey();
        pair = entry.getValue();
        regexs[i] = pair.first;
        substs[i] = pair.second;
        i++;
    }
    parcel.writeParcelableArray(ids, flags);
    parcel.writeSerializable(regexs);
    parcel.writeStringArray(substs);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"The loop structure for iterating through the entries in `mFields` has changed from index-based iteration to for-each loop using `Entry<AutofillId, Pair<Pattern, String>>`. However, this change does not affect the outcome of the iterations or the written data to the parcel, thus the change type is 4.","There is no Compatibility Issue because the sequence of operations and the data written to the `Parcel` remain the same. The iteration method has changed but it does not affect what is written to the `Parcel`. Hence, the change will not lead to different behavior for the API users."
153,<android.companion.CompanionDeviceManager.CallbackProxy: void onSuccess(PendingIntent)>,27,28,<android.companion.CompanionDeviceManager.CallbackProxy: void onSuccess(PendingIntent)>,<android.companion.CompanionDeviceManager.CallbackProxy: void onSuccess(PendingIntent)>,0,"{
    Handler handler = mHandler;
    if (handler == null)
        return;
    handler.post(() -> {
        Callback callback = mCallback;
        if (callback == null)
            return;
        callback.onDeviceFound(launcher.getIntentSender());
    });
}","{
    lockAndPost(Callback::onDeviceFound, launcher.getIntentSender());
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"4,5",0,"The method body has been refactored to call lockAndPost method with the appropriate parameters, and this is a change in the API's method body without changing the method signature or annotations, so the change type is 4. Moreover, since the implementation is now relying on the behavior of the lockAndPost method, which is likely another API (potentially an internal API not visible in the current context), the change type also includes 5.","There is no direct evidence that the behavior of onSuccess with the PendingIntent argument has changed, as this is a refactor that seems to preserve the intent of the original implementation. The use of lockAndPost is an abstraction that presumably takes care of posting to the handler and invoking the callback. If lockAndPost is correctly designed to be a drop-in replacement for the original logic, there shouldn't be any Compatibility Issue as a result of this change, hence the CI type is 0."
154,<android.service.autofill.CustomDescription.Builder: CustomDescription build()>,27,28,<android.service.autofill.CustomDescription.Builder: CustomDescription build()>,<android.service.autofill.CustomDescription.Builder: CustomDescription build()>,0,"{
    return new CustomDescription(this);
}","{
    throwIfDestroyed();
    mDestroyed = true;
    return new CustomDescription(this);
}",1,"/**
 * Creates a new {@link CustomDescription} instance.
 */
","/**
 * Creates a new {@link CustomDescription} instance.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,4",2,"An exception handling statement 'throwIfDestroyed()' and an assignment statement 'mDestroyed = true;' have been added before the return statement, which are not related to the 'return' itself. Therefore, the code change includes type 2 and type 4.","The added 'throwIfDestroyed()' method suggests a new potential exception might be thrown in the late version if the condition for 'destroyed' is met, hence the CI is categorized as type 2."
155,<android.content.res.AssetManager: String[] getResourceStringArray(int)>,27,28,<android.content.res.AssetManager: String[] getResourceStringArray(int)>,<android.content.res.AssetManager: String[] getResourceStringArray(int)>,0,"{
    return getArrayStringResource(resId);
}","{
    synchronized (this) {
        ensureValidLocked();
        return nativeGetResourceStringArray(mObject, resId);
    }
}",1,"/**
 * Retrieves the string array associated with a particular resource
 * identifier for the current configuration.
 *
 * @param resId the resource identifier of the string array
 * @return the string array, or {@code null}
 */
","/**
 * Retrieves the string array associated with a particular resource
 * identifier for the current configuration.
 *
 * @param resId the resource identifier of the string array
 * @return the string array, or {@code null}
 */
",-1,[@Nullable],[@Nullable],-1,-1,-1,-1,-1,-1,"3,4,5",5,"The code change includes enclosing the call in a synchronized block, changing the name of the method being called from getArrayStringResource to nativeGetResourceStringArray, and adding an additional call to ensureValidLocked(). This results in changes related to control dependency (3), other statements (4), and dependent API (5).","The switch from getArrayStringResource to nativeGetResourceStringArray shows that this API is now dependent on a different internal API, which could potentially affect behavior. The additional ensureValidLocked() call is not likely to cause compatibility issues unless it changes state or throws exceptions that would affect the output array. As there isn't enough information provided about the behaviors of ensureValidLocked() and nativeGetResourceStringArray(), we cautiously assume there could be a CI related to the method behavior change (5). No statements were explicitly added or removed that would indicate a change in return value or exception handling within the AssetManager method itself."
156,<android.app.ActivityThread.H: void handleMessage(Message)>,27,28,<android.app.ActivityThread.H: void handleMessage(Message)>,<android.app.ActivityThread.H: void handleMessage(Message)>,0,"{
    if (DEBUG_MESSAGES)
        Slog.v(TAG, "">>> handling: "" + codeToString(msg.what));
    switch(msg.what) {
        case LAUNCH_ACTIVITY:
            {
                Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""activityStart"");
                final ActivityClientRecord r = (ActivityClientRecord) msg.obj;
                r.packageInfo = getPackageInfoNoCheck(r.activityInfo.applicationInfo, r.compatInfo);
                handleLaunchActivity(r, null, ""LAUNCH_ACTIVITY"");
                Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            }
            break;
        case RELAUNCH_ACTIVITY:
            {
                Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""activityRestart"");
                ActivityClientRecord r = (ActivityClientRecord) msg.obj;
                handleRelaunchActivity(r);
                Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            }
            break;
        case PAUSE_ACTIVITY:
            {
                Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""activityPause"");
                SomeArgs args = (SomeArgs) msg.obj;
                handlePauseActivity((IBinder) args.arg1, false, (args.argi1 & USER_LEAVING) != 0, args.argi2, (args.argi1 & DONT_REPORT) != 0, args.argi3);
                Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            }
            break;
        case PAUSE_ACTIVITY_FINISHING:
            {
                Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""activityPause"");
                SomeArgs args = (SomeArgs) msg.obj;
                handlePauseActivity((IBinder) args.arg1, true, (args.argi1 & USER_LEAVING) != 0, args.argi2, (args.argi1 & DONT_REPORT) != 0, args.argi3);
                Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            }
            break;
        case STOP_ACTIVITY_SHOW:
            {
                Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""activityStop"");
                SomeArgs args = (SomeArgs) msg.obj;
                handleStopActivity((IBinder) args.arg1, true, args.argi2, args.argi3);
                Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            }
            break;
        case STOP_ACTIVITY_HIDE:
            {
                Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""activityStop"");
                SomeArgs args = (SomeArgs) msg.obj;
                handleStopActivity((IBinder) args.arg1, false, args.argi2, args.argi3);
                Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            }
            break;
        case SHOW_WINDOW:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""activityShowWindow"");
            handleWindowVisibility((IBinder) msg.obj, true);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case HIDE_WINDOW:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""activityHideWindow"");
            handleWindowVisibility((IBinder) msg.obj, false);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case RESUME_ACTIVITY:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""activityResume"");
            SomeArgs args = (SomeArgs) msg.obj;
            handleResumeActivity((IBinder) args.arg1, true, args.argi1 != 0, true, args.argi3, ""RESUME_ACTIVITY"");
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case SEND_RESULT:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""activityDeliverResult"");
            handleSendResult((ResultData) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case DESTROY_ACTIVITY:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""activityDestroy"");
            handleDestroyActivity((IBinder) msg.obj, msg.arg1 != 0, msg.arg2, false);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case BIND_APPLICATION:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""bindApplication"");
            AppBindData data = (AppBindData) msg.obj;
            handleBindApplication(data);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case EXIT_APPLICATION:
            if (mInitialApplication != null) {
                mInitialApplication.onTerminate();
            }
            Looper.myLooper().quit();
            break;
        case NEW_INTENT:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""activityNewIntent"");
            handleNewIntent((NewIntentData) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case RECEIVER:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""broadcastReceiveComp"");
            handleReceiver((ReceiverData) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case CREATE_SERVICE:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, (""serviceCreate: "" + String.valueOf(msg.obj)));
            handleCreateService((CreateServiceData) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case BIND_SERVICE:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""serviceBind"");
            handleBindService((BindServiceData) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case UNBIND_SERVICE:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""serviceUnbind"");
            handleUnbindService((BindServiceData) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case SERVICE_ARGS:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, (""serviceStart: "" + String.valueOf(msg.obj)));
            handleServiceArgs((ServiceArgsData) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case STOP_SERVICE:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""serviceStop"");
            handleStopService((IBinder) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case CONFIGURATION_CHANGED:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""configChanged"");
            mCurDefaultDisplayDpi = ((Configuration) msg.obj).densityDpi;
            mUpdatingSystemConfig = true;
            try {
                handleConfigurationChanged((Configuration) msg.obj, null);
            } finally {
                mUpdatingSystemConfig = false;
            }
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case CLEAN_UP_CONTEXT:
            ContextCleanupInfo cci = (ContextCleanupInfo) msg.obj;
            cci.context.performFinalCleanup(cci.who, cci.what);
            break;
        case GC_WHEN_IDLE:
            scheduleGcIdler();
            break;
        case DUMP_SERVICE:
            handleDumpService((DumpComponentInfo) msg.obj);
            break;
        case LOW_MEMORY:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""lowMemory"");
            handleLowMemory();
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case ACTIVITY_CONFIGURATION_CHANGED:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""activityConfigChanged"");
            handleActivityConfigurationChanged((ActivityConfigChangeData) msg.obj, INVALID_DISPLAY);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case ACTIVITY_MOVED_TO_DISPLAY:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""activityMovedToDisplay"");
            handleActivityConfigurationChanged((ActivityConfigChangeData) msg.obj, msg.arg1);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case PROFILER_CONTROL:
            handleProfilerControl(msg.arg1 != 0, (ProfilerInfo) msg.obj, msg.arg2);
            break;
        case CREATE_BACKUP_AGENT:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""backupCreateAgent"");
            handleCreateBackupAgent((CreateBackupAgentData) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case DESTROY_BACKUP_AGENT:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""backupDestroyAgent"");
            handleDestroyBackupAgent((CreateBackupAgentData) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case SUICIDE:
            Process.killProcess(Process.myPid());
            break;
        case REMOVE_PROVIDER:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""providerRemove"");
            completeRemoveProvider((ProviderRefCount) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case ENABLE_JIT:
            ensureJitEnabled();
            break;
        case DISPATCH_PACKAGE_BROADCAST:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""broadcastPackage"");
            handleDispatchPackageBroadcast(msg.arg1, (String[]) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case SCHEDULE_CRASH:
            throw new RemoteServiceException((String) msg.obj);
        case DUMP_HEAP:
            handleDumpHeap((DumpHeapData) msg.obj);
            break;
        case DUMP_ACTIVITY:
            handleDumpActivity((DumpComponentInfo) msg.obj);
            break;
        case DUMP_PROVIDER:
            handleDumpProvider((DumpComponentInfo) msg.obj);
            break;
        case SLEEPING:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""sleeping"");
            handleSleeping((IBinder) msg.obj, msg.arg1 != 0);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case SET_CORE_SETTINGS:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""setCoreSettings"");
            handleSetCoreSettings((Bundle) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case UPDATE_PACKAGE_COMPATIBILITY_INFO:
            handleUpdatePackageCompatibilityInfo((UpdateCompatibilityData) msg.obj);
            break;
        case TRIM_MEMORY:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""trimMemory"");
            handleTrimMemory(msg.arg1);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case UNSTABLE_PROVIDER_DIED:
            handleUnstableProviderDied((IBinder) msg.obj, false);
            break;
        case REQUEST_ASSIST_CONTEXT_EXTRAS:
            handleRequestAssistContextExtras((RequestAssistContextExtras) msg.obj);
            break;
        case TRANSLUCENT_CONVERSION_COMPLETE:
            handleTranslucentConversionComplete((IBinder) msg.obj, msg.arg1 == 1);
            break;
        case INSTALL_PROVIDER:
            handleInstallProvider((ProviderInfo) msg.obj);
            break;
        case ON_NEW_ACTIVITY_OPTIONS:
            Pair<IBinder, ActivityOptions> pair = (Pair<IBinder, ActivityOptions>) msg.obj;
            onNewActivityOptions(pair.first, pair.second);
            break;
        case ENTER_ANIMATION_COMPLETE:
            handleEnterAnimationComplete((IBinder) msg.obj);
            break;
        case START_BINDER_TRACKING:
            handleStartBinderTracking();
            break;
        case STOP_BINDER_TRACKING_AND_DUMP:
            handleStopBinderTrackingAndDump((ParcelFileDescriptor) msg.obj);
            break;
        case MULTI_WINDOW_MODE_CHANGED:
            handleMultiWindowModeChanged((IBinder) ((SomeArgs) msg.obj).arg1, ((SomeArgs) msg.obj).argi1 == 1, (Configuration) ((SomeArgs) msg.obj).arg2);
            break;
        case PICTURE_IN_PICTURE_MODE_CHANGED:
            handlePictureInPictureModeChanged((IBinder) ((SomeArgs) msg.obj).arg1, ((SomeArgs) msg.obj).argi1 == 1, (Configuration) ((SomeArgs) msg.obj).arg2);
            break;
        case LOCAL_VOICE_INTERACTION_STARTED:
            handleLocalVoiceInteractionStarted((IBinder) ((SomeArgs) msg.obj).arg1, (IVoiceInteractor) ((SomeArgs) msg.obj).arg2);
            break;
        case ATTACH_AGENT:
            handleAttachAgent((String) msg.obj);
            break;
        case APPLICATION_INFO_CHANGED:
            mUpdatingSystemConfig = true;
            try {
                handleApplicationInfoChanged((ApplicationInfo) msg.obj);
            } finally {
                mUpdatingSystemConfig = false;
            }
            break;
    }
    Object obj = msg.obj;
    if (obj instanceof SomeArgs) {
        ((SomeArgs) obj).recycle();
    }
    if (DEBUG_MESSAGES)
        Slog.v(TAG, ""<<< done: "" + codeToString(msg.what));
}","{
    if (DEBUG_MESSAGES)
        Slog.v(TAG, "">>> handling: "" + codeToString(msg.what));
    switch(msg.what) {
        case BIND_APPLICATION:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""bindApplication"");
            AppBindData data = (AppBindData) msg.obj;
            handleBindApplication(data);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case EXIT_APPLICATION:
            if (mInitialApplication != null) {
                mInitialApplication.onTerminate();
            }
            Looper.myLooper().quit();
            break;
        case RECEIVER:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""broadcastReceiveComp"");
            handleReceiver((ReceiverData) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case CREATE_SERVICE:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, (""serviceCreate: "" + String.valueOf(msg.obj)));
            handleCreateService((CreateServiceData) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case BIND_SERVICE:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""serviceBind"");
            handleBindService((BindServiceData) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case UNBIND_SERVICE:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""serviceUnbind"");
            handleUnbindService((BindServiceData) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case SERVICE_ARGS:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, (""serviceStart: "" + String.valueOf(msg.obj)));
            handleServiceArgs((ServiceArgsData) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case STOP_SERVICE:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""serviceStop"");
            handleStopService((IBinder) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case CONFIGURATION_CHANGED:
            handleConfigurationChanged((Configuration) msg.obj);
            break;
        case CLEAN_UP_CONTEXT:
            ContextCleanupInfo cci = (ContextCleanupInfo) msg.obj;
            cci.context.performFinalCleanup(cci.who, cci.what);
            break;
        case GC_WHEN_IDLE:
            scheduleGcIdler();
            break;
        case DUMP_SERVICE:
            handleDumpService((DumpComponentInfo) msg.obj);
            break;
        case LOW_MEMORY:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""lowMemory"");
            handleLowMemory();
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case PROFILER_CONTROL:
            handleProfilerControl(msg.arg1 != 0, (ProfilerInfo) msg.obj, msg.arg2);
            break;
        case CREATE_BACKUP_AGENT:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""backupCreateAgent"");
            handleCreateBackupAgent((CreateBackupAgentData) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case DESTROY_BACKUP_AGENT:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""backupDestroyAgent"");
            handleDestroyBackupAgent((CreateBackupAgentData) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case SUICIDE:
            Process.killProcess(Process.myPid());
            break;
        case REMOVE_PROVIDER:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""providerRemove"");
            completeRemoveProvider((ProviderRefCount) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case ENABLE_JIT:
            ensureJitEnabled();
            break;
        case DISPATCH_PACKAGE_BROADCAST:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""broadcastPackage"");
            handleDispatchPackageBroadcast(msg.arg1, (String[]) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case SCHEDULE_CRASH:
            throw new RemoteServiceException((String) msg.obj);
        case DUMP_HEAP:
            handleDumpHeap((DumpHeapData) msg.obj);
            break;
        case DUMP_ACTIVITY:
            handleDumpActivity((DumpComponentInfo) msg.obj);
            break;
        case DUMP_PROVIDER:
            handleDumpProvider((DumpComponentInfo) msg.obj);
            break;
        case SLEEPING:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""sleeping"");
            handleSleeping((IBinder) msg.obj, msg.arg1 != 0);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case SET_CORE_SETTINGS:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""setCoreSettings"");
            handleSetCoreSettings((Bundle) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case UPDATE_PACKAGE_COMPATIBILITY_INFO:
            handleUpdatePackageCompatibilityInfo((UpdateCompatibilityData) msg.obj);
            break;
        case UNSTABLE_PROVIDER_DIED:
            handleUnstableProviderDied((IBinder) msg.obj, false);
            break;
        case REQUEST_ASSIST_CONTEXT_EXTRAS:
            handleRequestAssistContextExtras((RequestAssistContextExtras) msg.obj);
            break;
        case TRANSLUCENT_CONVERSION_COMPLETE:
            handleTranslucentConversionComplete((IBinder) msg.obj, msg.arg1 == 1);
            break;
        case INSTALL_PROVIDER:
            handleInstallProvider((ProviderInfo) msg.obj);
            break;
        case ON_NEW_ACTIVITY_OPTIONS:
            Pair<IBinder, ActivityOptions> pair = (Pair<IBinder, ActivityOptions>) msg.obj;
            onNewActivityOptions(pair.first, pair.second);
            break;
        case ENTER_ANIMATION_COMPLETE:
            handleEnterAnimationComplete((IBinder) msg.obj);
            break;
        case START_BINDER_TRACKING:
            handleStartBinderTracking();
            break;
        case STOP_BINDER_TRACKING_AND_DUMP:
            handleStopBinderTrackingAndDump((ParcelFileDescriptor) msg.obj);
            break;
        case LOCAL_VOICE_INTERACTION_STARTED:
            handleLocalVoiceInteractionStarted((IBinder) ((SomeArgs) msg.obj).arg1, (IVoiceInteractor) ((SomeArgs) msg.obj).arg2);
            break;
        case ATTACH_AGENT:
            {
                Application app = getApplication();
                handleAttachAgent((String) msg.obj, app != null ? app.mLoadedApk : null);
                break;
            }
        case APPLICATION_INFO_CHANGED:
            mUpdatingSystemConfig = true;
            try {
                handleApplicationInfoChanged((ApplicationInfo) msg.obj);
            } finally {
                mUpdatingSystemConfig = false;
            }
            break;
        case RUN_ISOLATED_ENTRY_POINT:
            handleRunIsolatedEntryPoint((String) ((SomeArgs) msg.obj).arg1, (String[]) ((SomeArgs) msg.obj).arg2);
            break;
        case EXECUTE_TRANSACTION:
            final ClientTransaction transaction = (ClientTransaction) msg.obj;
            mTransactionExecutor.execute(transaction);
            if (isSystem()) {
                // Client transactions inside system process are recycled on the client side
                // instead of ClientLifecycleManager to avoid being cleared before this
                // message is handled.
                transaction.recycle();
            }
            // TODO(lifecycler): Recycle locally scheduled transactions.
            break;
        case RELAUNCH_ACTIVITY:
            handleRelaunchActivityLocally((IBinder) msg.obj);
            break;
    }
    Object obj = msg.obj;
    if (obj instanceof SomeArgs) {
        ((SomeArgs) obj).recycle();
    }
    if (DEBUG_MESSAGES)
        Slog.v(TAG, ""<<< done: "" + codeToString(msg.what));
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,,,,
157,<android.widget.EditText: Editable getText()>,27,28,<android.widget.EditText: Editable getText()>,<android.widget.EditText: Editable getText()>,0,"{
    return (Editable) super.getText();
}","{
    CharSequence text = super.getText();
    // This can only happen during construction.
    if (text == null) {
        return null;
    }
    if (text instanceof Editable) {
        return (Editable) super.getText();
    }
    super.setText(text, BufferType.EDITABLE);
    return (Editable) super.getText();
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,4",1,"There is a control dependency change with the addition of an if-statement to check if the 'text' is null, and then there is a logic change which involves checking if the 'text' is an instance of Editable. If not, it sets the 'text' with BufferType.EDITABLE and then returns it as an Editable. These changes fall under other statement changes and control dependency changes, so the code change type is 3,4.","The late version potentially returns a different variable. In the early version, it casts any value returned from super.getText() to Editable, even if it's null. However, in the late version, it checks if super.getText() returns null and, if so, returns null without a cast. Additionally, if the text is not an instance of Editable, it explicitly sets it to be one before returning. These changes can cause the method to behave differently: it now can return null where it previously could have thrown a ClassCastException, and it ensures an Editable is always returned where previously a potentially incorrect cast could have caused a runtime issue. So, the CI type is 1."
159,<android.content.pm.PackageInstaller: int createSession(SessionParams)>,27,28,<android.content.pm.PackageInstaller: int createSession(SessionParams)>,<android.content.pm.PackageInstaller: int createSession(SessionParams)>,0,"{
    try {
        return mInstaller.createSession(params, mInstallerPackageName, mUserId);
    } catch (RuntimeException e) {
        ExceptionUtils.maybeUnwrapIOException(e);
        throw e;
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}","{
    try {
        final String installerPackage;
        if (params.installerPackageName == null) {
            installerPackage = mInstallerPackageName;
        } else {
            installerPackage = params.installerPackageName;
        }
        return mInstaller.createSession(params, installerPackage, mUserId);
    } catch (RuntimeException e) {
        ExceptionUtils.maybeUnwrapIOException(e);
        throw e;
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Create a new session using the given parameters, returning a unique ID
 * that represents the session. Once created, the session can be opened
 * multiple times across multiple device boots.
 * <p>
 * The system may automatically destroy sessions that have not been
 * finalized (either committed or abandoned) within a reasonable period of
 * time, typically on the order of a day.
 *
 * @throws IOException if parameters were unsatisfiable, such as lack of
 * disk space or unavailable media.
 * @throws SecurityException when installation services are unavailable,
 * such as when called from a restricted user.
 * @throws IllegalArgumentException when {@link SessionParams} is invalid.
 * @return positive, non-zero unique ID that represents the created session.
 * This ID remains consistent across device reboots until the
 * session is finalized. IDs are not reused during a given boot.
 */
","/**
 * Create a new session using the given parameters, returning a unique ID
 * that represents the session. Once created, the session can be opened
 * multiple times across multiple device boots.
 * <p>
 * The system may automatically destroy sessions that have not been
 * finalized (either committed or abandoned) within a reasonable period of
 * time, typically on the order of a day.
 *
 * @throws IOException if parameters were unsatisfiable, such as lack of
 * disk space or unavailable media.
 * @throws SecurityException when installation services are unavailable,
 * such as when called from a restricted user.
 * @throws IllegalArgumentException when {@link SessionParams} is invalid.
 * @return positive, non-zero unique ID that represents the created session.
 * This ID remains consistent across device reboots until the
 * session is finalized. IDs are not reused during a given boot.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",0,"A new control structure was added to determine 'installerPackage', and an additional assignment statement for 'installerPackage' was introduced. This corresponds to change types 3 and 4.","Despite the added control flow and assignment statement, the functionality of the method remains consistent. The change in the code does not affect the behavior of the API in terms of returned values or exceptions thrown, because it still throws the same exceptions and the return value is based on the 'createSession' method regardless of how 'installerPackage' is determined. Therefore, there is no compatibility issue; the CI type is 0."
161,"<android.app.Dialog: boolean onKeyUp(int,KeyEvent)>",27,28,"<android.app.Dialog: boolean onKeyUp(int,KeyEvent)>","<android.app.Dialog: boolean onKeyUp(int,KeyEvent)>",0,"{
    if (keyCode == KeyEvent.KEYCODE_BACK && event.isTracking() && !event.isCanceled()) {
        onBackPressed();
        return true;
    }
    return false;
}","{
    if ((keyCode == KeyEvent.KEYCODE_BACK || keyCode == KeyEvent.KEYCODE_ESCAPE) && event.isTracking() && !event.isCanceled()) {
        onBackPressed();
        return true;
    }
    return false;
}",1,"/**
 * A key was released.
 *
 * <p>The default implementation handles KEYCODE_BACK to close the
 * dialog.
 *
 * @see #onKeyDown
 * @see KeyEvent
 */
","/**
 * A key was released.
 * <p>
 * Default implementation consumes {@link KeyEvent#KEYCODE_BACK KEYCODE_BACK}
 * and, as of {@link android.os.Build.VERSION_CODES#P P}, {@link KeyEvent#KEYCODE_ESCAPE
 * KEYCODE_ESCAPE} to close the dialog.
 *
 * @see #onKeyDown
 * @see android.view.KeyEvent
 */
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,3,1,"The condition in the if statement has changed because an additional condition checking for KeyEvent.KEYCODE_ESCAPE has been added. This is a change in the control dependency, so the code change type is 3.","The additional condition to detect the KeyEvent.KEYCODE_ESCAPE key means that there could be a new scenario where the method now returns true, where it previously would have returned false. This change could lead to a Compatibility Issue due to a potential different return value, so the CI type is 1."
164,"<android.app.Dialog: boolean onKeyDown(int,KeyEvent)>",27,28,"<android.app.Dialog: boolean onKeyDown(int,KeyEvent)>","<android.app.Dialog: boolean onKeyDown(int,KeyEvent)>",0,"{
    if (keyCode == KeyEvent.KEYCODE_BACK) {
        event.startTracking();
        return true;
    }
    return false;
}","{
    if (keyCode == KeyEvent.KEYCODE_BACK || keyCode == KeyEvent.KEYCODE_ESCAPE) {
        event.startTracking();
        return true;
    }
    return false;
}",1,"/**
 * A key was pressed down.
 *
 * <p>If the focused view didn't want this event, this method is called.
 *
 * <p>The default implementation consumed the KEYCODE_BACK to later
 * handle it in {@link #onKeyUp}.
 *
 * @see #onKeyUp
 * @see android.view.KeyEvent
 */
","/**
 * A key was pressed down.
 * <p>
 * If the focused view didn't want this event, this method is called.
 * <p>
 * Default implementation consumes {@link KeyEvent#KEYCODE_BACK KEYCODE_BACK}
 * and, as of {@link android.os.Build.VERSION_CODES#P P}, {@link KeyEvent#KEYCODE_ESCAPE
 * KEYCODE_ESCAPE} to later handle them in {@link #onKeyUp}.
 *
 * @see #onKeyUp
 * @see android.view.KeyEvent
 */
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,3,0,"The control dependency has changed by adding an additional condition check (keyCode == KeyEvent.KEYCODE_ESCAPE) to the 'if' statement, so the code change type is 3.","Although the control flow has changed, the method still returns a consistent boolean value of true or false based on a key event. The added condition just extends the range of keys that will result in true being returned, but it doesn't introduce a new behavior that could be backward incompatible for existing functionality, assuming developers aren't relying on onKeyDown to only respond to KEYCODE_BACK. Thus, there is no Compatibility Issue, and CI type is 0."
166,"<android.app.usage.UsageStatsManager: UsageEvents queryEvents(long,long)>",27,28,"<android.app.usage.UsageStatsManager: UsageEvents queryEvents(long,long)>","<android.app.usage.UsageStatsManager: UsageEvents queryEvents(long,long)>",0,"{
    try {
        UsageEvents iter = mService.queryEvents(beginTime, endTime, mContext.getOpPackageName());
        if (iter != null) {
            return iter;
        }
    } catch (RemoteException e) {
    // fallthrough and return null
    }
    return sEmptyResults;
}","{
    try {
        UsageEvents iter = mService.queryEvents(beginTime, endTime, mContext.getOpPackageName());
        if (iter != null) {
            return iter;
        }
    } catch (RemoteException e) {
    // fallthrough and return empty result.
    }
    return sEmptyResults;
}",1,"/**
 * Query for events in the given time range. Events are only kept by the system for a few
 * days.
 * <p />
 * <b>NOTE:</b> The last few minutes of the event log will be truncated to prevent abuse
 * by applications.
 *
 * @param beginTime The inclusive beginning of the range of events to include in the results.
 * @param endTime The exclusive end of the range of events to include in the results.
 * @return A {@link UsageEvents}.
 */
","/**
 * Query for events in the given time range. Events are only kept by the system for a few
 * days.
 * <p> The caller must have {@link android.Manifest.permission#PACKAGE_USAGE_STATS} </p>
 *
 * @param beginTime The inclusive beginning of the range of events to include in the results.
 * @param endTime The exclusive end of the range of events to include in the results.
 * @return A {@link UsageEvents}.
 */
",-1,,,-1,-1,-1,-1,-1,-1,0,0,"There are no changes in the implementation of the method between the two versions, only a comment was updated which does not affect the behavior of the code.","Since there is no actual code change but just a change in comments, there is no compatibility issue."
167,<android.bluetooth.BluetoothHealth: boolean doBind()>,27,28,<android.bluetooth.BluetoothHealth: boolean doBind()>,<android.bluetooth.BluetoothHealth: boolean doBind()>,0,"{
    Intent intent = new Intent(IBluetoothHealth.class.getName());
    ComponentName comp = intent.resolveSystemService(mContext.getPackageManager(), 0);
    intent.setComponent(comp);
    if (comp == null || !mContext.bindServiceAsUser(intent, mConnection, 0, android.os.Process.myUserHandle())) {
        Log.e(TAG, ""Could not bind to Bluetooth Health Service with "" + intent);
        return false;
    }
    return true;
}","{
    Intent intent = new Intent(IBluetoothHealth.class.getName());
    ComponentName comp = intent.resolveSystemService(mContext.getPackageManager(), 0);
    intent.setComponent(comp);
    if (comp == null || !mContext.bindServiceAsUser(intent, mConnection, 0, mContext.getUser())) {
        Log.e(TAG, ""Could not bind to Bluetooth Health Service with "" + intent);
        return false;
    }
    return true;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"The change is in the parameter of bindServiceAsUser method from android.os.Process.myUserHandle() to mContext.getUser(). The type of parameter has changed, there is no change in the return or exception handling statements and the method getName() has not been deprecated or changed. The control flow remains the same. So, the code change type is 4 and 5 due to the change in the dependent API which is a method parameter change.","There is no Compatibility Issue as the returned value (true or false) does not rely on the behavior of the changed dependent API, which is a method to obtain the user handle for binding (android.os.Process.myUserHandle() vs mContext.getUser()). This is just a parameter change and does not influence the behavior and the return type is still boolean, which remains consistent. Hence, the type of CI is 0 indicating no compatibility issue."
169,<android.app.job.JobInfo: int hashCode()>,27,28,<android.app.job.JobInfo: int hashCode()>,<android.app.job.JobInfo: int hashCode()>,0,"{
    int hashCode = jobId;
    if (extras != null) {
        hashCode = 31 * hashCode + extras.hashCode();
    }
    if (transientExtras != null) {
        hashCode = 31 * hashCode + transientExtras.hashCode();
    }
    if (clipData != null) {
        hashCode = 31 * hashCode + clipData.hashCode();
    }
    hashCode = 31 * hashCode + clipGrantFlags;
    if (service != null) {
        hashCode = 31 * hashCode + service.hashCode();
    }
    hashCode = 31 * hashCode + constraintFlags;
    if (triggerContentUris != null) {
        hashCode = 31 * hashCode + Arrays.hashCode(triggerContentUris);
    }
    hashCode = 31 * hashCode + Long.hashCode(triggerContentUpdateDelay);
    hashCode = 31 * hashCode + Long.hashCode(triggerContentMaxDelay);
    hashCode = 31 * hashCode + Boolean.hashCode(hasEarlyConstraint);
    hashCode = 31 * hashCode + Boolean.hashCode(hasLateConstraint);
    hashCode = 31 * hashCode + networkType;
    hashCode = 31 * hashCode + Long.hashCode(minLatencyMillis);
    hashCode = 31 * hashCode + Long.hashCode(maxExecutionDelayMillis);
    hashCode = 31 * hashCode + Boolean.hashCode(isPeriodic);
    hashCode = 31 * hashCode + Boolean.hashCode(isPersisted);
    hashCode = 31 * hashCode + Long.hashCode(intervalMillis);
    hashCode = 31 * hashCode + Long.hashCode(flexMillis);
    hashCode = 31 * hashCode + Long.hashCode(initialBackoffMillis);
    hashCode = 31 * hashCode + backoffPolicy;
    hashCode = 31 * hashCode + priority;
    hashCode = 31 * hashCode + flags;
    return hashCode;
}","{
    int hashCode = jobId;
    if (extras != null) {
        hashCode = 31 * hashCode + extras.hashCode();
    }
    if (transientExtras != null) {
        hashCode = 31 * hashCode + transientExtras.hashCode();
    }
    if (clipData != null) {
        hashCode = 31 * hashCode + clipData.hashCode();
    }
    hashCode = 31 * hashCode + clipGrantFlags;
    if (service != null) {
        hashCode = 31 * hashCode + service.hashCode();
    }
    hashCode = 31 * hashCode + constraintFlags;
    if (triggerContentUris != null) {
        hashCode = 31 * hashCode + Arrays.hashCode(triggerContentUris);
    }
    hashCode = 31 * hashCode + Long.hashCode(triggerContentUpdateDelay);
    hashCode = 31 * hashCode + Long.hashCode(triggerContentMaxDelay);
    hashCode = 31 * hashCode + Boolean.hashCode(hasEarlyConstraint);
    hashCode = 31 * hashCode + Boolean.hashCode(hasLateConstraint);
    if (networkRequest != null) {
        hashCode = 31 * hashCode + networkRequest.hashCode();
    }
    hashCode = 31 * hashCode + Long.hashCode(networkDownloadBytes);
    hashCode = 31 * hashCode + Long.hashCode(networkUploadBytes);
    hashCode = 31 * hashCode + Long.hashCode(minLatencyMillis);
    hashCode = 31 * hashCode + Long.hashCode(maxExecutionDelayMillis);
    hashCode = 31 * hashCode + Boolean.hashCode(isPeriodic);
    hashCode = 31 * hashCode + Boolean.hashCode(isPersisted);
    hashCode = 31 * hashCode + Long.hashCode(intervalMillis);
    hashCode = 31 * hashCode + Long.hashCode(flexMillis);
    hashCode = 31 * hashCode + Long.hashCode(initialBackoffMillis);
    hashCode = 31 * hashCode + backoffPolicy;
    hashCode = 31 * hashCode + priority;
    hashCode = 31 * hashCode + flags;
    return hashCode;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"4,5",1,"There is an addition of checks and calculations for 'networkRequest', 'networkDownloadBytes', and 'networkUploadBytes' in the Late Version. These changes are included in the hash code calculation and thus affect the return value, so the code change type is 4,5.","The changes lead to different hash codes being returned for the same object if these new fields ('networkRequest', 'networkDownloadBytes', 'networkUploadBytes') are different between the two instances being compared. Thus, it is a CI of type 1 where the object's hash code (return value) could potentially differ between versions."
170,"<android.nfc.cardemulation.CardEmulation: boolean isDefaultServiceForCategory(ComponentName,String)>",27,28,"<android.nfc.cardemulation.CardEmulation: boolean isDefaultServiceForCategory(ComponentName,String)>","<android.nfc.cardemulation.CardEmulation: boolean isDefaultServiceForCategory(ComponentName,String)>",0,"{
    try {
        return sService.isDefaultServiceForCategory(UserHandle.myUserId(), service, category);
    } catch (RemoteException e) {
        // Try one more time
        recoverService();
        if (sService == null) {
            Log.e(TAG, ""Failed to recover CardEmulationService."");
            return false;
        }
        try {
            return sService.isDefaultServiceForCategory(UserHandle.myUserId(), service, category);
        } catch (RemoteException ee) {
            Log.e(TAG, ""Failed to recover CardEmulationService."");
            return false;
        }
    }
}","{
    try {
        return sService.isDefaultServiceForCategory(mContext.getUserId(), service, category);
    } catch (RemoteException e) {
        // Try one more time
        recoverService();
        if (sService == null) {
            Log.e(TAG, ""Failed to recover CardEmulationService."");
            return false;
        }
        try {
            return sService.isDefaultServiceForCategory(mContext.getUserId(), service, category);
        } catch (RemoteException ee) {
            Log.e(TAG, ""Failed to recover CardEmulationService."");
            return false;
        }
    }
}",1,"/**
 * Allows an application to query whether a service is currently
 * the default service to handle a card emulation category.
 *
 * <p>Note that if {@link #getSelectionModeForCategory(String)}
 * returns {@link #SELECTION_MODE_ALWAYS_ASK} or {@link #SELECTION_MODE_ASK_IF_CONFLICT},
 * this method will always return false. That is because in these
 * selection modes a default can't be set at the category level. For categories where
 * the selection mode is {@link #SELECTION_MODE_ALWAYS_ASK} or
 * {@link #SELECTION_MODE_ASK_IF_CONFLICT}, use
 * {@link #isDefaultServiceForAid(ComponentName, String)} to determine whether a service
 * is the default for a specific AID.
 *
 * @param service The ComponentName of the service
 * @param category The category
 * @return whether service is currently the default service for the category.
 *
 * <p class=""note"">Requires the {@link android.Manifest.permission#NFC} permission.
 */
","/**
 * Allows an application to query whether a service is currently
 * the default service to handle a card emulation category.
 *
 * <p>Note that if {@link #getSelectionModeForCategory(String)}
 * returns {@link #SELECTION_MODE_ALWAYS_ASK} or {@link #SELECTION_MODE_ASK_IF_CONFLICT},
 * this method will always return false. That is because in these
 * selection modes a default can't be set at the category level. For categories where
 * the selection mode is {@link #SELECTION_MODE_ALWAYS_ASK} or
 * {@link #SELECTION_MODE_ASK_IF_CONFLICT}, use
 * {@link #isDefaultServiceForAid(ComponentName, String)} to determine whether a service
 * is the default for a specific AID.
 *
 * @param service The ComponentName of the service
 * @param category The category
 * @return whether service is currently the default service for the category.
 *
 * <p class=""note"">Requires the {@link android.Manifest.permission#NFC} permission.
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The code change involves calling mContext.getUserId() instead of UserHandle.myUserId() as the first argument of the isDefaultServiceForCategory method call. This is a dependent API change, thus the code change type is 5.","Since the change from UserHandle.myUserId() to mContext.getUserId() does not change the behavior of the isDefaultServiceForCategory method and both seems to retrieve the user ID which should result in the same value, there are no Compatibility Issues caused by this change. Thus, the CI type is 0."
171,<android.hardware.radio.RadioManager.ProgramInfo: boolean isDigital()>,27,28,<android.hardware.radio.RadioManager.ProgramInfo: boolean isDigital()>,<android.hardware.radio.RadioManager.ProgramInfo: boolean isDigital()>,0,"{
    return mDigital;
}","{
    ProgramSelector.Identifier id = mLogicallyTunedTo;
    if (id == null)
        id = mSelector.getPrimaryId();
    int type = id.getType();
    return (type != ProgramSelector.IDENTIFIER_TYPE_AMFM_FREQUENCY && type != ProgramSelector.IDENTIFIER_TYPE_RDS_PI);
}",1,"/**
 * {@code true} if the received program is digital (e.g HD radio)
 * @return {@code true} if digital, {@code false} otherwise.
 */
","/**
 * {@code true} if the received program is digital (e.g HD radio)
 * @return {@code true} if digital, {@code false} otherwise.
 * @deprecated Use {@link getLogicallyTunedTo()} instead.
 */
",-1,,[@Deprecated],-1,-1,-1,-1,-1,-1,"1,3,5",1,"The implementation has undergone significant changes. There is a change from a simple return of a Boolean field (mDigital) to computing the result based on the type of the program identifier. Also, new logic has been introduced to determine which identifier to use. This results in code changes classified as 1 (Return statement changed), 3 (Control dependency changed), and 5 (Dependent API changed - accessing new members of the ProgramSelector class).","The late version introduces new logic to determine whether the program is digital based on the type of identifier, which could potentially lead to a return value different from just returning the value of mDigital. Hence, this qualifies as a CI because of potential different return values. The CI type is 1."
172,<android.view.View: boolean dispatchTooltipHoverEvent(MotionEvent)>,27,28,<android.view.View: boolean dispatchTooltipHoverEvent(MotionEvent)>,<android.view.View: boolean dispatchTooltipHoverEvent(MotionEvent)>,0,"{
    if (mTooltipInfo == null) {
        return false;
    }
    switch(event.getAction()) {
        case MotionEvent.ACTION_HOVER_MOVE:
            if ((mViewFlags & TOOLTIP) != TOOLTIP || (mViewFlags & ENABLED_MASK) != ENABLED) {
                break;
            }
            if (!mTooltipInfo.mTooltipFromLongClick) {
                if (mTooltipInfo.mTooltipPopup == null) {
                    // Schedule showing the tooltip after a timeout.
                    mTooltipInfo.mAnchorX = (int) event.getX();
                    mTooltipInfo.mAnchorY = (int) event.getY();
                    removeCallbacks(mTooltipInfo.mShowTooltipRunnable);
                    postDelayed(mTooltipInfo.mShowTooltipRunnable, ViewConfiguration.getHoverTooltipShowTimeout());
                }
                // Hide hover-triggered tooltip after a period of inactivity.
                // Match the timeout used by NativeInputManager to hide the mouse pointer
                // (depends on SYSTEM_UI_FLAG_LOW_PROFILE being set).
                final int timeout;
                if ((getWindowSystemUiVisibility() & SYSTEM_UI_FLAG_LOW_PROFILE) == SYSTEM_UI_FLAG_LOW_PROFILE) {
                    timeout = ViewConfiguration.getHoverTooltipHideShortTimeout();
                } else {
                    timeout = ViewConfiguration.getHoverTooltipHideTimeout();
                }
                removeCallbacks(mTooltipInfo.mHideTooltipRunnable);
                postDelayed(mTooltipInfo.mHideTooltipRunnable, timeout);
            }
            return true;
        case MotionEvent.ACTION_HOVER_EXIT:
            if (!mTooltipInfo.mTooltipFromLongClick) {
                hideTooltip();
            }
            break;
    }
    return false;
}","{
    if (mTooltipInfo == null) {
        return false;
    }
    switch(event.getAction()) {
        case MotionEvent.ACTION_HOVER_MOVE:
            if ((mViewFlags & TOOLTIP) != TOOLTIP) {
                break;
            }
            if (!mTooltipInfo.mTooltipFromLongClick && mTooltipInfo.updateAnchorPos(event)) {
                if (mTooltipInfo.mTooltipPopup == null) {
                    // Schedule showing the tooltip after a timeout.
                    removeCallbacks(mTooltipInfo.mShowTooltipRunnable);
                    postDelayed(mTooltipInfo.mShowTooltipRunnable, ViewConfiguration.getHoverTooltipShowTimeout());
                }
                // Hide hover-triggered tooltip after a period of inactivity.
                // Match the timeout used by NativeInputManager to hide the mouse pointer
                // (depends on SYSTEM_UI_FLAG_LOW_PROFILE being set).
                final int timeout;
                if ((getWindowSystemUiVisibility() & SYSTEM_UI_FLAG_LOW_PROFILE) == SYSTEM_UI_FLAG_LOW_PROFILE) {
                    timeout = ViewConfiguration.getHoverTooltipHideShortTimeout();
                } else {
                    timeout = ViewConfiguration.getHoverTooltipHideTimeout();
                }
                removeCallbacks(mTooltipInfo.mHideTooltipRunnable);
                postDelayed(mTooltipInfo.mHideTooltipRunnable, timeout);
            }
            return true;
        case MotionEvent.ACTION_HOVER_EXIT:
            mTooltipInfo.clearAnchorPos();
            if (!mTooltipInfo.mTooltipFromLongClick) {
                hideTooltip();
            }
            break;
    }
    return false;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"1,3,4,5",1,The code change includes:,- Removal of setting `mTooltipInfo.mAnchorX` and `mTooltipInfo.mAnchorY` directly.
173,"<android.hardware.LegacySensorManager.LmsFilter: float filter(long,float)>",27,28,"<android.hardware.LegacySensorManager.LmsFilter: float filter(long,float)>","<android.hardware.LegacySensorManager.LmsFilter: float filter(long,float)>",0,"{
    float v = in;
    final float ns = 1.0f / 1000000000.0f;
    float v1 = mV[mIndex];
    if ((v - v1) > 180) {
        v -= 360;
    } else if ((v1 - v) > 180) {
        v += 360;
    }
    /* Manage the circular buffer, we write the data twice spaced
             * by COUNT values, so that we don't have to copy the array
             * when it's full
             */
    mIndex++;
    if (mIndex >= COUNT * 2)
        mIndex = COUNT;
    mV[mIndex] = v;
    mT[mIndex] = time;
    mV[mIndex - COUNT] = v;
    mT[mIndex - COUNT] = time;
    float A, B, C, D, E;
    float a, b;
    int i;
    A = B = C = D = E = 0;
    for (i = 0; i < COUNT - 1; i++) {
        final int j = mIndex - 1 - i;
        final float Z = mV[j];
        final float T = (mT[j] / 2 + mT[j + 1] / 2 - time) * ns;
        float dT = (mT[j] - mT[j + 1]) * ns;
        dT *= dT;
        A += Z * dT;
        B += T * (T * dT);
        C += (T * dT);
        D += Z * (T * dT);
        E += dT;
    }
    b = (A * B + C * D) / (E * B + C * C);
    a = (E * b - A) / C;
    float f = b + PREDICTION_TIME * a;
    // Normalize
    f *= (1.0f / 360.0f);
    if (((f >= 0) ? f : -f) >= 0.5f)
        f = f - (float) Math.ceil(f + 0.5f) + 1.0f;
    if (f < 0)
        f += 1.0f;
    f *= 360.0f;
    return f;
}","{
    float v = in;
    final float ns = 1.0f / 1000000000.0f;
    float v1 = mV[mIndex];
    if ((v - v1) > 180) {
        v -= 360;
    } else if ((v1 - v) > 180) {
        v += 360;
    }
    /* Manage the circular buffer, we write the data twice spaced
             * by COUNT values, so that we don't have to copy the array
             * when it's full
             */
    mIndex++;
    if (mIndex >= COUNT * 2) {
        mIndex = COUNT;
    }
    mV[mIndex] = v;
    mT[mIndex] = time;
    mV[mIndex - COUNT] = v;
    mT[mIndex - COUNT] = time;
    float A, B, C, D, E;
    float a, b;
    int i;
    A = B = C = D = E = 0;
    for (i = 0; i < COUNT - 1; i++) {
        final int j = mIndex - 1 - i;
        final float Z = mV[j];
        final float T = (mT[j] / 2 + mT[j + 1] / 2 - time) * ns;
        float dT = (mT[j] - mT[j + 1]) * ns;
        dT *= dT;
        A += Z * dT;
        B += T * (T * dT);
        C += (T * dT);
        D += Z * (T * dT);
        E += dT;
    }
    b = (A * B + C * D) / (E * B + C * C);
    a = (E * b - A) / C;
    float f = b + PREDICTION_TIME * a;
    // Normalize
    f *= (1.0f / 360.0f);
    if (((f >= 0) ? f : -f) >= 0.5f) {
        f = f - (float) Math.ceil(f + 0.5f) + 1.0f;
    }
    if (f < 0) {
        f += 1.0f;
    }
    f *= 360.0f;
    return f;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,,,,
174,"<android.widget.TextView: boolean onKeyMultiple(int,int,KeyEvent)>",27,28,"<android.widget.TextView: boolean onKeyMultiple(int,int,KeyEvent)>","<android.widget.TextView: boolean onKeyMultiple(int,int,KeyEvent)>",0,"{
    KeyEvent down = KeyEvent.changeAction(event, KeyEvent.ACTION_DOWN);
    final int which = doKeyDown(keyCode, down, event);
    if (which == KEY_EVENT_NOT_HANDLED) {
        // Go through default dispatching.
        return super.onKeyMultiple(keyCode, repeatCount, event);
    }
    if (which == KEY_EVENT_HANDLED) {
        // Consumed the whole thing.
        return true;
    }
    repeatCount--;
    // We are going to dispatch the remaining events to either the input
    // or movement method.  To do this, we will just send a repeated stream
    // of down and up events until we have done the complete repeatCount.
    // It would be nice if those interfaces had an onKeyMultiple() method,
    // but adding that is a more complicated change.
    KeyEvent up = KeyEvent.changeAction(event, KeyEvent.ACTION_UP);
    if (which == KEY_DOWN_HANDLED_BY_KEY_LISTENER) {
        // mEditor and mEditor.mInput are not null from doKeyDown
        mEditor.mKeyListener.onKeyUp(this, (Editable) mText, keyCode, up);
        while (--repeatCount > 0) {
            mEditor.mKeyListener.onKeyDown(this, (Editable) mText, keyCode, down);
            mEditor.mKeyListener.onKeyUp(this, (Editable) mText, keyCode, up);
        }
        hideErrorIfUnchanged();
    } else if (which == KEY_DOWN_HANDLED_BY_MOVEMENT_METHOD) {
        // mMovement is not null from doKeyDown
        mMovement.onKeyUp(this, (Spannable) mText, keyCode, up);
        while (--repeatCount > 0) {
            mMovement.onKeyDown(this, (Spannable) mText, keyCode, down);
            mMovement.onKeyUp(this, (Spannable) mText, keyCode, up);
        }
    }
    return true;
}","{
    KeyEvent down = KeyEvent.changeAction(event, KeyEvent.ACTION_DOWN);
    final int which = doKeyDown(keyCode, down, event);
    if (which == KEY_EVENT_NOT_HANDLED) {
        // Go through default dispatching.
        return super.onKeyMultiple(keyCode, repeatCount, event);
    }
    if (which == KEY_EVENT_HANDLED) {
        // Consumed the whole thing.
        return true;
    }
    repeatCount--;
    // We are going to dispatch the remaining events to either the input
    // or movement method.  To do this, we will just send a repeated stream
    // of down and up events until we have done the complete repeatCount.
    // It would be nice if those interfaces had an onKeyMultiple() method,
    // but adding that is a more complicated change.
    KeyEvent up = KeyEvent.changeAction(event, KeyEvent.ACTION_UP);
    if (which == KEY_DOWN_HANDLED_BY_KEY_LISTENER) {
        // mEditor and mEditor.mInput are not null from doKeyDown
        mEditor.mKeyListener.onKeyUp(this, (Editable) mText, keyCode, up);
        while (--repeatCount > 0) {
            mEditor.mKeyListener.onKeyDown(this, (Editable) mText, keyCode, down);
            mEditor.mKeyListener.onKeyUp(this, (Editable) mText, keyCode, up);
        }
        hideErrorIfUnchanged();
    } else if (which == KEY_DOWN_HANDLED_BY_MOVEMENT_METHOD) {
        // mMovement is not null from doKeyDown
        mMovement.onKeyUp(this, mSpannable, keyCode, up);
        while (--repeatCount > 0) {
            mMovement.onKeyDown(this, mSpannable, keyCode, down);
            mMovement.onKeyUp(this, mSpannable, keyCode, up);
        }
    }
    return true;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"The variable `mText` is replaced with `mSpannable` in the method calls to `mMovement.onKeyUp` and `mMovement.onKeyDown`. This change seems to be only in the variable name, not in its type or value, thus classified as 4 (Other statement changed).","Since the change is only in the variable name and presumes that the underlying type and value is unchanged, there is no Compatibility Issue caused by potential different return values, types, or exceptions."
175,"<android.app.usage.NetworkStatsManager: NetworkStats queryDetailsForUid(int,String,long,long,int)>",27,28,"<android.app.usage.NetworkStatsManager: NetworkStats queryDetailsForUid(int,String,long,long,int)>","<android.app.usage.NetworkStatsManager: NetworkStats queryDetailsForUid(int,String,long,long,int)>",0,"{
    return queryDetailsForUidTag(networkType, subscriberId, startTime, endTime, uid, NetworkStats.Bucket.TAG_NONE);
}","{
    return queryDetailsForUidTagState(networkType, subscriberId, startTime, endTime, uid, NetworkStats.Bucket.TAG_NONE, NetworkStats.Bucket.STATE_ALL);
}",1,"/**
 * Query network usage statistics details for a given uid.
 *
 * #see queryDetailsForUidTag(int, String, long, long, int, int)
 */
","/**
 * Query network usage statistics details for a given uid.
 *
 * #see queryDetailsForUidTagState(int, String, long, long, int, int, int)
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The method in the return statement has changed from queryDetailsForUidTag to queryDetailsForUidTagState, which likely has a different signature or implementation, and an additional constant NetworkStats.Bucket.STATE_ALL is passed into the new method. Hence, the code change type is 1,5.","The change in the dependent method and the additional parameter potentially lead to different return values from the API, indicating a CI type of 1."
176,<android.view.accessibility.AccessibilityManager: void interrupt()>,27,28,<android.view.accessibility.AccessibilityManager: void interrupt()>,<android.view.accessibility.AccessibilityManager: void interrupt()>,0,"{
    final IAccessibilityManager service;
    final int userId;
    synchronized (mLock) {
        service = getServiceLocked();
        if (service == null) {
            return;
        }
        if (!mIsEnabled) {
            Looper myLooper = Looper.myLooper();
            if (myLooper == Looper.getMainLooper()) {
                throw new IllegalStateException(""Accessibility off. Did you forget to check that?"");
            } else {
                // If we're not running on the thread with the main looper, it's possible for
                // the state of accessibility to change between checking isEnabled and
                // calling this method. So just log the error rather than throwing the
                // exception.
                Log.e(LOG_TAG, ""Interrupt called with accessibility disabled"");
                return;
            }
        }
        userId = mUserId;
    }
    try {
        service.interrupt(userId);
        if (DEBUG) {
            Log.i(LOG_TAG, ""Requested interrupt from all services"");
        }
    } catch (RemoteException re) {
        Log.e(LOG_TAG, ""Error while requesting interrupt from all services. "", re);
    }
}","{
    final IAccessibilityManager service;
    final int userId;
    synchronized (mLock) {
        service = getServiceLocked();
        if (service == null) {
            return;
        }
        if (!isEnabled()) {
            Looper myLooper = Looper.myLooper();
            if (myLooper == Looper.getMainLooper()) {
                throw new IllegalStateException(""Accessibility off. Did you forget to check that?"");
            } else {
                // If we're not running on the thread with the main looper, it's possible for
                // the state of accessibility to change between checking isEnabled and
                // calling this method. So just log the error rather than throwing the
                // exception.
                Log.e(LOG_TAG, ""Interrupt called with accessibility disabled"");
                return;
            }
        }
        userId = mUserId;
    }
    try {
        service.interrupt(userId);
        if (DEBUG) {
            Log.i(LOG_TAG, ""Requested interrupt from all services"");
        }
    } catch (RemoteException re) {
        Log.e(LOG_TAG, ""Error while requesting interrupt from all services. "", re);
    }
}",1,"/**
 * Requests feedback interruption from all accessibility services.
 */
","/**
 * Requests feedback interruption from all accessibility services.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The check for accessibility enabled has changed from referencing a field directly (`mIsEnabled`) to calling a method (`isEnabled()`), so the code change type is 4.","There is no Compatibility Issue here since the logic to check whether accessibility is enabled has not changed in terms of behavior. It's merely an internal change from a direct field access to a method call that presumably returns the same value, hence no difference in behavior for the user of the API."
177,"<android.view.textclassifier.TextSelection.Builder: Builder setEntityType(String,float)>",27,28,"<android.view.textclassifier.TextSelection.Builder: Builder setEntityType(String,float)>","<android.view.textclassifier.TextSelection.Builder: Builder setEntityType(String,float)>",0,"{
    mEntityConfidence.setEntityType(type, confidenceScore);
    return this;
}","{
    Preconditions.checkNotNull(type);
    mEntityConfidence.put(type, confidenceScore);
    return this;
}",1,"/**
 * Sets an entity type for the classified text and assigns a confidence score.
 *
 * @param confidenceScore a value from 0 (low confidence) to 1 (high confidence).
 * 0 implies the entity does not exist for the classified text.
 * Values greater than 1 are clamped to 1.
 */
","/**
 * Sets an entity type for the classified text and assigns a confidence score.
 *
 * @param confidenceScore a value from 0 (low confidence) to 1 (high confidence).
 * 0 implies the entity does not exist for the classified text.
 * Values greater than 1 are clamped to 1.
 */
",-1,,[@NonNull],-1,-1,-1,-1,-1,-1,"4,5",0,"The method has changed from using setEntityType to now using put for updating the mEntityConfidence. There's also an additional call to Preconditions.checkNotNull(type), which is a dependent API changed. The code change type is 4,5 because of the addition of a precondition check and change in the method used to update mEntityConfidence.","There's no Compatibility Issue detected, because the change does not affect the return value; it still returns 'this'. The addition of Preconditions.checkNotNull(type) would cause the method to throw an exception when 'type' is null, which aligns with the added @NonNull annotation, but since this parameter was always supposed to be non-null according to the annotation, this does not represent a new behavior but rather enforces the existing contract. Thus, it does not constitute a CI in terms of returning a different value or throwing a different exception than expected by the previous API signature."
178,<android.bluetooth.le.AdvertisingSetParameters.Builder: Builder setLegacyMode(boolean)>,27,28,<android.bluetooth.le.AdvertisingSetParameters.Builder: Builder setLegacyMode(boolean)>,<android.bluetooth.le.AdvertisingSetParameters.Builder: Builder setLegacyMode(boolean)>,0,"{
    this.isLegacy = isLegacy;
    return this;
}","{
    mIsLegacy = isLegacy;
    return this;
}",1,"/**
 * When set to true, advertising set will advertise 4.x Spec compliant
 * advertisements.
 *
 * @param isLegacy whether legacy advertising mode should be used.
 */
","/**
 * When set to true, advertising set will advertise 4.x Spec compliant
 * advertisements.
 *
 * @param isLegacy whether legacy advertising mode should be used.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The change in the instance variable name from 'this.isLegacy' to 'mIsLegacy' is purely internal and does not affect the API's external behavior or contract, so the code change type is 4.","There is no compatibility issue since the method's behavior and the return type remain the same, despite the internal variable name being changed. Therefore, the CI type is 0."
179,<android.widget.TextView: boolean moveCursorToVisibleOffset()>,27,28,<android.widget.TextView: boolean moveCursorToVisibleOffset()>,<android.widget.TextView: boolean moveCursorToVisibleOffset()>,0,"{
    if (!(mText instanceof Spannable)) {
        return false;
    }
    int start = getSelectionStart();
    int end = getSelectionEnd();
    if (start != end) {
        return false;
    }
    // First: make sure the line is visible on screen:
    int line = mLayout.getLineForOffset(start);
    final int top = mLayout.getLineTop(line);
    final int bottom = mLayout.getLineTop(line + 1);
    final int vspace = mBottom - mTop - getExtendedPaddingTop() - getExtendedPaddingBottom();
    int vslack = (bottom - top) / 2;
    if (vslack > vspace / 4) {
        vslack = vspace / 4;
    }
    final int vs = mScrollY;
    if (top < (vs + vslack)) {
        line = mLayout.getLineForVertical(vs + vslack + (bottom - top));
    } else if (bottom > (vspace + vs - vslack)) {
        line = mLayout.getLineForVertical(vspace + vs - vslack - (bottom - top));
    }
    // Next: make sure the character is visible on screen:
    final int hspace = mRight - mLeft - getCompoundPaddingLeft() - getCompoundPaddingRight();
    final int hs = mScrollX;
    final int leftChar = mLayout.getOffsetForHorizontal(line, hs);
    final int rightChar = mLayout.getOffsetForHorizontal(line, hspace + hs);
    // line might contain bidirectional text
    final int lowChar = leftChar < rightChar ? leftChar : rightChar;
    final int highChar = leftChar > rightChar ? leftChar : rightChar;
    int newStart = start;
    if (newStart < lowChar) {
        newStart = lowChar;
    } else if (newStart > highChar) {
        newStart = highChar;
    }
    if (newStart != start) {
        Selection.setSelection((Spannable) mText, newStart);
        return true;
    }
    return false;
}","{
    if (!(mText instanceof Spannable)) {
        return false;
    }
    int start = getSelectionStart();
    int end = getSelectionEnd();
    if (start != end) {
        return false;
    }
    // First: make sure the line is visible on screen:
    int line = mLayout.getLineForOffset(start);
    final int top = mLayout.getLineTop(line);
    final int bottom = mLayout.getLineTop(line + 1);
    final int vspace = mBottom - mTop - getExtendedPaddingTop() - getExtendedPaddingBottom();
    int vslack = (bottom - top) / 2;
    if (vslack > vspace / 4) {
        vslack = vspace / 4;
    }
    final int vs = mScrollY;
    if (top < (vs + vslack)) {
        line = mLayout.getLineForVertical(vs + vslack + (bottom - top));
    } else if (bottom > (vspace + vs - vslack)) {
        line = mLayout.getLineForVertical(vspace + vs - vslack - (bottom - top));
    }
    // Next: make sure the character is visible on screen:
    final int hspace = mRight - mLeft - getCompoundPaddingLeft() - getCompoundPaddingRight();
    final int hs = mScrollX;
    final int leftChar = mLayout.getOffsetForHorizontal(line, hs);
    final int rightChar = mLayout.getOffsetForHorizontal(line, hspace + hs);
    // line might contain bidirectional text
    final int lowChar = leftChar < rightChar ? leftChar : rightChar;
    final int highChar = leftChar > rightChar ? leftChar : rightChar;
    int newStart = start;
    if (newStart < lowChar) {
        newStart = lowChar;
    } else if (newStart > highChar) {
        newStart = highChar;
    }
    if (newStart != start) {
        Selection.setSelection(mSpannable, newStart);
        return true;
    }
    return false;
}",1,"/**
 * Move the cursor, if needed, so that it is at an offset that is visible
 * to the user.  This will not move the cursor if it represents more than
 * one character (a selection range).  This will only work if the
 * TextView contains spannable text; otherwise it will do nothing.
 *
 * @return True if the cursor was actually moved, false otherwise.
 */
","/**
 * Move the cursor, if needed, so that it is at an offset that is visible
 * to the user.  This will not move the cursor if it represents more than
 * one character (a selection range).  This will only work if the
 * TextView contains spannable text; otherwise it will do nothing.
 *
 * @return True if the cursor was actually moved, false otherwise.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The change is in the type cast of the mText variable: in the early version, it is cast to Spannable explicitly in Selection.setSelection((Spannable) mText, newStart), whereas in the late version, it simply uses mSpannable without casting. This implies that the same Spannable instance is being used in both cases, but in the late version it is a direct reference without casting. ","Although the explicit casting to Spannable has been removed, the logical flow of the method has not been altered. Therefore, this modification does not lead to a compatibility issue as the behavior of the method remains unchanged. The moveCursorToVisibleOffset() method should behave identically in both versions as long as the 'mText' variable is a Spannable instance, which is ensured by the earlier if statement."
180,"<android.text.format.Formatter: String formatShortFileSize(Context,long)>",27,28,"<android.text.format.Formatter: String formatShortFileSize(Context,long)>","<android.text.format.Formatter: String formatShortFileSize(Context,long)>",0,"{
    return formatFileSize(context, sizeBytes, FLAG_SHORTER);
}","{
    if (context == null) {
        return """";
    }
    final BytesResult res = formatBytes(context.getResources(), sizeBytes, FLAG_SI_UNITS | FLAG_SHORTER);
    return bidiWrap(context, context.getString(com.android.internal.R.string.fileSizeSuffix, res.value, res.units));
}",1,"/**
 * Like {@link #formatFileSize}, but trying to generate shorter numbers
 * (showing fewer digits of precision).
 */
","/**
 * Like {@link #formatFileSize}, but trying to generate shorter numbers
 * (showing fewer digits of precision).
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The early version calls formatFileSize method, while the late version uses a different approach introduced by an if statement and has modified the logic inside the method, including calling formatBytes and getting a string resource. Therefore, the change types are 1 (Return statement changed), as there's a new return expression `return """";`, and 5 (Dependent API changed), because there's a new dependency on formatBytes.","The late version adds a null check for the context and returns an empty string if the context is null, which is different from the early version's behavior. It also relies on formatBytes and other methods, potentially leading to a different result. This could lead to Compatibility Issues due to potential different return values or types, which classifies it as type 1."
181,<android.service.wallpaper.WallpaperService.IWallpaperEngineWrapper: void executeMessage(Message)>,27,28,<android.service.wallpaper.WallpaperService.IWallpaperEngineWrapper: void executeMessage(Message)>,<android.service.wallpaper.WallpaperService.IWallpaperEngineWrapper: void executeMessage(Message)>,0,"{
    switch(message.what) {
        case DO_ATTACH:
            {
                try {
                    mConnection.attachEngine(this);
                } catch (RemoteException e) {
                    Log.w(TAG, ""Wallpaper host disappeared"", e);
                    return;
                }
                Engine engine = onCreateEngine();
                mEngine = engine;
                mActiveEngines.add(engine);
                engine.attach(this);
                return;
            }
        case DO_DETACH:
            {
                mActiveEngines.remove(mEngine);
                mEngine.detach();
                return;
            }
        case DO_SET_DESIRED_SIZE:
            {
                mEngine.doDesiredSizeChanged(message.arg1, message.arg2);
                return;
            }
        case DO_SET_DISPLAY_PADDING:
            {
                mEngine.doDisplayPaddingChanged((Rect) message.obj);
            }
        case MSG_UPDATE_SURFACE:
            mEngine.updateSurface(true, false, false);
            break;
        case MSG_VISIBILITY_CHANGED:
            if (DEBUG)
                Log.v(TAG, ""Visibility change in "" + mEngine + "": "" + message.arg1);
            mEngine.doVisibilityChanged(message.arg1 != 0);
            break;
        case MSG_WALLPAPER_OFFSETS:
            {
                mEngine.doOffsetsChanged(true);
            }
            break;
        case MSG_WALLPAPER_COMMAND:
            {
                WallpaperCommand cmd = (WallpaperCommand) message.obj;
                mEngine.doCommand(cmd);
            }
            break;
        case MSG_WINDOW_RESIZED:
            {
                final boolean reportDraw = message.arg1 != 0;
                mEngine.mOutsets.set((Rect) message.obj);
                mEngine.updateSurface(true, false, reportDraw);
                mEngine.doOffsetsChanged(true);
            }
            break;
        case MSG_WINDOW_MOVED:
            {
            // Do nothing. What does it mean for a Wallpaper to move?
            }
            break;
        case MSG_TOUCH_EVENT:
            {
                boolean skip = false;
                MotionEvent ev = (MotionEvent) message.obj;
                if (ev.getAction() == MotionEvent.ACTION_MOVE) {
                    synchronized (mEngine.mLock) {
                        if (mEngine.mPendingMove == ev) {
                            mEngine.mPendingMove = null;
                        } else {
                            // this is not the motion event we are looking for....
                            skip = true;
                        }
                    }
                }
                if (!skip) {
                    if (DEBUG)
                        Log.v(TAG, ""Delivering touch event: "" + ev);
                    mEngine.onTouchEvent(ev);
                }
                ev.recycle();
            }
            break;
        case MSG_REQUEST_WALLPAPER_COLORS:
            {
                if (mConnection == null) {
                    break;
                }
                try {
                    mConnection.onWallpaperColorsChanged(mEngine.onComputeColors());
                } catch (RemoteException e) {
                // Connection went away, nothing to do in here.
                }
            }
            break;
        default:
            Log.w(TAG, ""Unknown message type "" + message.what);
    }
}","{
    switch(message.what) {
        case DO_ATTACH:
            {
                try {
                    mConnection.attachEngine(this);
                } catch (RemoteException e) {
                    Log.w(TAG, ""Wallpaper host disappeared"", e);
                    return;
                }
                Engine engine = onCreateEngine();
                mEngine = engine;
                mActiveEngines.add(engine);
                engine.attach(this);
                return;
            }
        case DO_DETACH:
            {
                mActiveEngines.remove(mEngine);
                mEngine.detach();
                return;
            }
        case DO_SET_DESIRED_SIZE:
            {
                mEngine.doDesiredSizeChanged(message.arg1, message.arg2);
                return;
            }
        case DO_SET_DISPLAY_PADDING:
            {
                mEngine.doDisplayPaddingChanged((Rect) message.obj);
                return;
            }
        case DO_IN_AMBIENT_MODE:
            {
                mEngine.doAmbientModeChanged(message.arg1 != 0, message.arg2 != 0);
                return;
            }
        case MSG_UPDATE_SURFACE:
            mEngine.updateSurface(true, false, false);
            break;
        case MSG_VISIBILITY_CHANGED:
            if (DEBUG)
                Log.v(TAG, ""Visibility change in "" + mEngine + "": "" + message.arg1);
            mEngine.doVisibilityChanged(message.arg1 != 0);
            break;
        case MSG_WALLPAPER_OFFSETS:
            {
                mEngine.doOffsetsChanged(true);
            }
            break;
        case MSG_WALLPAPER_COMMAND:
            {
                WallpaperCommand cmd = (WallpaperCommand) message.obj;
                mEngine.doCommand(cmd);
            }
            break;
        case MSG_WINDOW_RESIZED:
            {
                final boolean reportDraw = message.arg1 != 0;
                mEngine.mOutsets.set((Rect) message.obj);
                mEngine.updateSurface(true, false, reportDraw);
                mEngine.doOffsetsChanged(true);
            }
            break;
        case MSG_WINDOW_MOVED:
            {
            // Do nothing. What does it mean for a Wallpaper to move?
            }
            break;
        case MSG_TOUCH_EVENT:
            {
                boolean skip = false;
                MotionEvent ev = (MotionEvent) message.obj;
                if (ev.getAction() == MotionEvent.ACTION_MOVE) {
                    synchronized (mEngine.mLock) {
                        if (mEngine.mPendingMove == ev) {
                            mEngine.mPendingMove = null;
                        } else {
                            // this is not the motion event we are looking for....
                            skip = true;
                        }
                    }
                }
                if (!skip) {
                    if (DEBUG)
                        Log.v(TAG, ""Delivering touch event: "" + ev);
                    mEngine.onTouchEvent(ev);
                }
                ev.recycle();
            }
            break;
        case MSG_REQUEST_WALLPAPER_COLORS:
            {
                if (mConnection == null) {
                    break;
                }
                try {
                    mConnection.onWallpaperColorsChanged(mEngine.onComputeColors());
                } catch (RemoteException e) {
                // Connection went away, nothing to do in here.
                }
            }
            break;
        default:
            Log.w(TAG, ""Unknown message type "" + message.what);
    }
}",1,,,-1,,[@Override],-1,-1,-1,-1,-1,-1,,,,
182,<android.view.textclassifier.TextClassification: Intent getIntent()>,27,28,<android.view.textclassifier.TextClassification: Intent getIntent()>,<android.view.textclassifier.TextClassification: Intent getIntent()>,0,"{
    return mIntent;
}","{
    return mLegacyIntent;
}",1,"/**
 * Returns an intent that may be fired to act on the classified text.
 */
","/**
 * Returns an intent that may be fired to act on the classified text.
 *
 * <p><strong>NOTE: </strong>This field is not parcelled and will always return null when this
 * object is read from a parcel.
 *
 * @deprecated Use {@link #getActions()} instead.
 */
",-1,[@Nullable],"[@Deprecated, @Nullable]",-1,-1,-1,-1,-1,-1,1,1,"The return statement has changed from `return mIntent;` to `return mLegacyIntent;`, so the code change type is 1.","Because the return statement changed, which means it is returning a different variable, the API potentially returns a different value. Hence, the CI type is 1."
185,"<android.hardware.SensorManager: Sensor getDefaultSensor(int,boolean)>",27,28,"<android.hardware.SensorManager: Sensor getDefaultSensor(int,boolean)>","<android.hardware.SensorManager: Sensor getDefaultSensor(int,boolean)>",0,"{
    List<Sensor> l = getSensorList(type);
    for (Sensor sensor : l) {
        if (sensor.isWakeUpSensor() == wakeUp)
            return sensor;
    }
    return null;
}","{
    List<Sensor> l = getSensorList(type);
    for (Sensor sensor : l) {
        if (sensor.isWakeUpSensor() == wakeUp) {
            return sensor;
        }
    }
    return null;
}",1,"/**
 * Return a Sensor with the given type and wakeUp properties. If multiple sensors of this
 * type exist, any one of them may be returned.
 * <p>
 * For example,
 * <ul>
 * <li>getDefaultSensor({@link Sensor#TYPE_ACCELEROMETER}, true) returns a wake-up accelerometer
 * sensor if it exists. </li>
 * <li>getDefaultSensor({@link Sensor#TYPE_PROXIMITY}, false) returns a non wake-up proximity
 * sensor if it exists. </li>
 * <li>getDefaultSensor({@link Sensor#TYPE_PROXIMITY}, true) returns a wake-up proximity sensor
 * which is the same as the Sensor returned by {@link #getDefaultSensor(int)}. </li>
 * </ul>
 * </p>
 * <p class=""note"">
 * Note: Sensors like {@link Sensor#TYPE_PROXIMITY} and {@link Sensor#TYPE_SIGNIFICANT_MOTION}
 * are declared as wake-up sensors by default.
 * </p>
 * @param type
 * type of sensor requested
 * @param wakeUp
 * flag to indicate whether the Sensor is a wake-up or non wake-up sensor.
 * @return the default sensor matching the requested type and wakeUp properties if one exists
 * and the application has the necessary permissions, or null otherwise.
 * @see Sensor#isWakeUpSensor()
 */
","/**
 * Return a Sensor with the given type and wakeUp properties. If multiple sensors of this
 * type exist, any one of them may be returned.
 * <p>
 * For example,
 * <ul>
 * <li>getDefaultSensor({@link Sensor#TYPE_ACCELEROMETER}, true) returns a wake-up
 * accelerometer sensor if it exists. </li>
 * <li>getDefaultSensor({@link Sensor#TYPE_PROXIMITY}, false) returns a non wake-up
 * proximity sensor if it exists. </li>
 * <li>getDefaultSensor({@link Sensor#TYPE_PROXIMITY}, true) returns a wake-up proximity
 * sensor which is the same as the Sensor returned by {@link #getDefaultSensor(int)}. </li>
 * </ul>
 * </p>
 * <p class=""note"">
 * Note: Sensors like {@link Sensor#TYPE_PROXIMITY} and {@link Sensor#TYPE_SIGNIFICANT_MOTION}
 * are declared as wake-up sensors by default.
 * </p>
 * @param type
 * type of sensor requested
 * @param wakeUp
 * flag to indicate whether the Sensor is a wake-up or non wake-up sensor.
 * @return the default sensor matching the requested type and wakeUp properties if one exists
 * and the application has the necessary permissions, or null otherwise.
 * @see Sensor#isWakeUpSensor()
 */
",-1,,,-1,-1,-1,-1,-1,-1,0,0,There is no actual code change between the two versions; only the formatting is slightly different with the addition of curly braces for the if statement.,"Due to no changes in the logic or functionality of the implementation, there is no Compatibility Issue."
187,"<android.speech.tts.TextToSpeechService.SynthHandler: int enqueueSpeechItem(int,SpeechItem)>",27,28,"<android.speech.tts.TextToSpeechService.SynthHandler: int enqueueSpeechItem(int,SpeechItem)>","<android.speech.tts.TextToSpeechService.SynthHandler: int enqueueSpeechItem(int,SpeechItem)>",0,"{
    UtteranceProgressDispatcher utterenceProgress = null;
    if (speechItem instanceof UtteranceProgressDispatcher) {
        utterenceProgress = (UtteranceProgressDispatcher) speechItem;
    }
    if (!speechItem.isValid()) {
        if (utterenceProgress != null) {
            utterenceProgress.dispatchOnError(TextToSpeech.ERROR_INVALID_REQUEST);
        }
        return TextToSpeech.ERROR;
    }
    if (queueMode == TextToSpeech.QUEUE_FLUSH) {
        stopForApp(speechItem.getCallerIdentity());
    } else if (queueMode == TextToSpeech.QUEUE_DESTROY) {
        stopAll();
    }
    Runnable runnable = new Runnable() {

        @Override
        public void run() {
            if (isFlushed(speechItem)) {
                speechItem.stop();
            } else {
                setCurrentSpeechItem(speechItem);
                speechItem.play();
                setCurrentSpeechItem(null);
            }
        }
    };
    Message msg = Message.obtain(this, runnable);
    // The obj is used to remove all callbacks from the given app in
    // stopForApp(String).
    // 
    // Note that this string is interned, so the == comparison works.
    msg.obj = speechItem.getCallerIdentity();
    if (sendMessage(msg)) {
        return TextToSpeech.SUCCESS;
    } else {
        Log.w(TAG, ""SynthThread has quit"");
        if (utterenceProgress != null) {
            utterenceProgress.dispatchOnError(TextToSpeech.ERROR_SERVICE);
        }
        return TextToSpeech.ERROR;
    }
}","{
    UtteranceProgressDispatcher utterenceProgress = null;
    if (speechItem instanceof UtteranceProgressDispatcher) {
        utterenceProgress = (UtteranceProgressDispatcher) speechItem;
    }
    if (!speechItem.isValid()) {
        if (utterenceProgress != null) {
            utterenceProgress.dispatchOnError(TextToSpeech.ERROR_INVALID_REQUEST);
        }
        return TextToSpeech.ERROR;
    }
    if (queueMode == TextToSpeech.QUEUE_FLUSH) {
        stopForApp(speechItem.getCallerIdentity());
    } else if (queueMode == TextToSpeech.QUEUE_DESTROY) {
        stopAll();
    }
    Runnable runnable = new Runnable() {

        @Override
        public void run() {
            if (setCurrentSpeechItem(speechItem)) {
                speechItem.play();
                removeCurrentSpeechItem();
            } else {
                // The item is alreadly flushed. Stopping.
                speechItem.stop();
            }
        }
    };
    Message msg = Message.obtain(this, runnable);
    // The obj is used to remove all callbacks from the given app in
    // stopForApp(String).
    // 
    // Note that this string is interned, so the == comparison works.
    msg.obj = speechItem.getCallerIdentity();
    if (sendMessage(msg)) {
        return TextToSpeech.SUCCESS;
    } else {
        Log.w(TAG, ""SynthThread has quit"");
        if (utterenceProgress != null) {
            utterenceProgress.dispatchOnError(TextToSpeech.ERROR_SERVICE);
        }
        return TextToSpeech.ERROR;
    }
}",1,"/**
 * Adds a speech item to the queue.
 *
 * Called on a service binder thread.
 */
","/**
 * Adds a speech item to the queue.
 *
 * Called on a service binder thread.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",1,"The ""run()"" method's implementation of the ""Runnable runnable"" object is changed. In the early version, checking for ""isFlushed(speechItem)"" occurs first and then ""setCurrentSpeechItem(speechItem)"" is called. In contrast, the late version first calls ""setCurrentSpeechItem(speechItem)"" and decides to call ""speechItem.play()"" or ""speechItem.stop()"" based on the returned value. This change is classified as 3 since the sequence of method calls and their contingent behaviors have changed, and 4 due to changes in the internal logic of statements inside the ""run()"" method.","This internal change of behavior within the ""Runnable runnable"" object's ""run"" method could potentially lead to a different sequence of method calls, which could, in turn, produce different outcomes (play or stop actions on the speechItem). Therefore, the change could lead to the API returning different status values, indicated by ""TextToSpeech.SUCCESS"" or ""TextToSpeech.ERROR"", depending on whether ""sendMessage(msg)"" succeeds or fails, and the subsequent playing or stopping of the speechItem. Thus, the CI type is 1."
188,"<android.hardware.camera2.CaptureRequest: void writeToParcel(Parcel,int)>",27,28,"<android.hardware.camera2.CaptureRequest: void writeToParcel(Parcel,int)>","<android.hardware.camera2.CaptureRequest: void writeToParcel(Parcel,int)>",0,"{
    mSettings.writeToParcel(dest, flags);
    dest.writeParcelableArray(mSurfaceSet.toArray(new Surface[mSurfaceSet.size()]), flags);
    dest.writeInt(mIsReprocess ? 1 : 0);
}","{
    int physicalCameraCount = mPhysicalCameraSettings.size();
    dest.writeInt(physicalCameraCount);
    // Logical camera id and settings always come first.
    dest.writeString(mLogicalCameraId);
    mLogicalCameraSettings.writeToParcel(dest, flags);
    for (Map.Entry<String, CameraMetadataNative> entry : mPhysicalCameraSettings.entrySet()) {
        if (entry.getKey().equals(mLogicalCameraId)) {
            continue;
        }
        dest.writeString(entry.getKey());
        entry.getValue().writeToParcel(dest, flags);
    }
    dest.writeInt(mIsReprocess ? 1 : 0);
    synchronized (mSurfacesLock) {
        final ArraySet<Surface> surfaces = mSurfaceConverted ? mEmptySurfaceSet : mSurfaceSet;
        dest.writeParcelableArray(surfaces.toArray(new Surface[surfaces.size()]), flags);
        if (mSurfaceConverted) {
            dest.writeInt(mStreamIdxArray.length);
            for (int i = 0; i < mStreamIdxArray.length; i++) {
                dest.writeInt(mStreamIdxArray[i]);
                dest.writeInt(mSurfaceIdxArray[i]);
            }
        } else {
            dest.writeInt(0);
        }
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"4,5",1,"The implementation of the writeToParcel method has undergone significant changes. The entire block of logic related to writing the physicalCameraCount, the logical camera id, the logicalCameraSettings, and the block enclosed by the synchronized statement has been added, which is not present in the early version. Additionally, the key parts of writing the mSettings and mSurfaceSet were changed; mSettings was replaced with mLogicalCameraSettings and mPhysicalCameraSettings, while the writing of mSurfaceSet is now conditioned and includes additional data about mStreamIdxArray and mSurfaceIdxArray. Due to these added blocks and removal of the old logic, the change type includes both other statement changes (4) and dependent API changes (5) because we have new methods and properties introduced that the new implementation relies on.","Considering the method's functionality for marshalling (writing its contents to a Parcel), these substantial changes in the implementation between versions could result in different data being written to the Parcel. These differences include the possibility of writing physical camera IDs, logical camera settings, and stream indexes that were not present before. This impacts the structure of the Parcel, which could potentially lead to Compatibility Issues for any system expecting the Parcel to be structured the early version way. Therefore the CI type is 1."
189,<android.net.NetworkCapabilities: boolean equals(Object)>,27,28,<android.net.NetworkCapabilities: boolean equals(Object)>,<android.net.NetworkCapabilities: boolean equals(Object)>,0,"{
    if (obj == null || (obj instanceof NetworkCapabilities == false))
        return false;
    NetworkCapabilities that = (NetworkCapabilities) obj;
    return (equalsNetCapabilities(that) && equalsTransportTypes(that) && equalsLinkBandwidths(that) && equalsSignalStrength(that) && equalsSpecifier(that));
}","{
    if (obj == null || (obj instanceof NetworkCapabilities == false))
        return false;
    NetworkCapabilities that = (NetworkCapabilities) obj;
    return (equalsNetCapabilities(that) && equalsTransportTypes(that) && equalsLinkBandwidths(that) && equalsSignalStrength(that) && equalsSpecifier(that) && equalsUids(that) && equalsSSID(that));
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,1,1,"The return statement in the late implementation includes additional method calls (equalsUids(that) and equalsSSID(that)) compared to the early version, so the code change type is 1.","Because the added method calls could potentially cause the function to return different results than before (it adds more conditions for two NetworkCapabilities objects to be considered equal), this constitutes a CI type 1, which means there is a Compatibility Issue due to potential different return values."
191,<android.hardware.camera2.CaptureRequest: T get(Key<T>)>,27,28,<android.hardware.camera2.CaptureRequest: T get(Key<T>)>,<android.hardware.camera2.CaptureRequest: T get(Key<T>)>,0,"{
    return mSettings.get(key);
}","{
    return mLogicalCameraSettings.get(key);
}",1,"/**
 * Get a capture request field value.
 *
 * <p>The field definitions can be found in {@link CaptureRequest}.</p>
 *
 * <p>Querying the value for the same key more than once will return a value
 * which is equal to the previous queried value.</p>
 *
 * @throws IllegalArgumentException if the key was not valid
 *
 * @param key The result field to read.
 * @return The value of that key, or {@code null} if the field is not set.
 */
","/**
 * Get a capture request field value.
 *
 * <p>The field definitions can be found in {@link CaptureRequest}.</p>
 *
 * <p>Querying the value for the same key more than once will return a value
 * which is equal to the previous queried value.</p>
 *
 * @throws IllegalArgumentException if the key was not valid
 *
 * @param key The result field to read.
 * @return The value of that key, or {@code null} if the field is not set.
 */
",-1,[@Nullable],[@Nullable],-1,-1,-1,-1,-1,-1,"4,5",1,"Here, the implementation of the method has changed from using mSettings.get(key) to using mLogicalCameraSettings.get(key). The object from which the get method is being called has changed, indicating a change in the state or properties accessed by get. Thus, there is a change of type 4 (Other statement changed) and type 5 (Dependent API changed).","The change in the method from which 'get' is called (from mSettings to mLogicalCameraSettings) could potentially return a different value for the same key, as the underlying data structure has changed. Therefore, there is a Compatibility Issue of type 1 (Compatibility Issue caused by potential different return values)."
192,"<android.nfc.cardemulation.NfcFCardEmulation: boolean registerSystemCodeForService(ComponentName,String)>",27,28,"<android.nfc.cardemulation.NfcFCardEmulation: boolean registerSystemCodeForService(ComponentName,String)>","<android.nfc.cardemulation.NfcFCardEmulation: boolean registerSystemCodeForService(ComponentName,String)>",0,"{
    if (service == null || systemCode == null) {
        throw new NullPointerException(""service or systemCode is null"");
    }
    try {
        return sService.registerSystemCodeForService(UserHandle.myUserId(), service, systemCode);
    } catch (RemoteException e) {
        // Try one more time
        recoverService();
        if (sService == null) {
            Log.e(TAG, ""Failed to recover CardEmulationService."");
            return false;
        }
        try {
            return sService.registerSystemCodeForService(UserHandle.myUserId(), service, systemCode);
        } catch (RemoteException ee) {
            Log.e(TAG, ""Failed to reach CardEmulationService."");
            ee.rethrowAsRuntimeException();
            return false;
        }
    }
}","{
    if (service == null || systemCode == null) {
        throw new NullPointerException(""service or systemCode is null"");
    }
    try {
        return sService.registerSystemCodeForService(mContext.getUserId(), service, systemCode);
    } catch (RemoteException e) {
        // Try one more time
        recoverService();
        if (sService == null) {
            Log.e(TAG, ""Failed to recover CardEmulationService."");
            return false;
        }
        try {
            return sService.registerSystemCodeForService(mContext.getUserId(), service, systemCode);
        } catch (RemoteException ee) {
            Log.e(TAG, ""Failed to reach CardEmulationService."");
            ee.rethrowAsRuntimeException();
            return false;
        }
    }
}",1,"/**
 * Registers a System Code for the specified service.
 *
 * <p>The System Code must be in range from ""4000"" to ""4FFF"" (excluding ""4*FF"").
 *
 * <p>If a System Code was previously registered for this service
 * (either statically through the manifest, or dynamically by using this API),
 * it will be replaced with this one.
 *
 * <p>Even if the same System Code is already registered for another service,
 * this method succeeds in registering the System Code.
 *
 * <p>Note that you can only register a System Code for a service that
 * is running under the same UID as the caller of this API. Typically
 * this means you need to call this from the same
 * package as the service itself, though UIDs can also
 * be shared between packages using shared UIDs.
 *
 * @param service The component name of the service
 * @param systemCode The System Code to be registered
 * @return whether the registration was successful.
 */
","/**
 * Registers a System Code for the specified service.
 *
 * <p>The System Code must be in range from ""4000"" to ""4FFF"" (excluding ""4*FF"").
 *
 * <p>If a System Code was previously registered for this service
 * (either statically through the manifest, or dynamically by using this API),
 * it will be replaced with this one.
 *
 * <p>Even if the same System Code is already registered for another service,
 * this method succeeds in registering the System Code.
 *
 * <p>Note that you can only register a System Code for a service that
 * is running under the same UID as the caller of this API. Typically
 * this means you need to call this from the same
 * package as the service itself, though UIDs can also
 * be shared between packages using shared UIDs.
 *
 * @param service The component name of the service
 * @param systemCode The System Code to be registered
 * @return whether the registration was successful.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"The change is in the parameter passed from UserHandle.myUserId() to mContext.getUserId() when calling registerSystemCodeForService(). This is an internal change, and as both calls are meant to retrieve the current user ID, they should conceptually return the same value. Change type is therefore 4 due to the change within the code, and 5 because the implementation of how the user ID is fetched (a dependent API) changed.","There is no Compatibility Issue as the intent and contract of the API remain the same, and it is expected that both UserHandle.myUserId() and mContext.getUserId() methods return the user ID of the process calling it. The return statement and exception handling have not been changed in a way that would affect the callers of this API differently between versions."
193,<android.hardware.camera2.legacy.LegacyExceptionUtils: int throwOnError(int)>,27,28,<android.hardware.camera2.legacy.LegacyExceptionUtils: int throwOnError(int)>,<android.hardware.camera2.legacy.LegacyExceptionUtils: int throwOnError(int)>,0,"{
    if (errorFlag == NO_ERROR) {
        return NO_ERROR;
    } else if (errorFlag == -ENODEV) {
        throw new BufferQueueAbandonedException();
    }
    if (errorFlag < 0) {
        throw new UnsupportedOperationException(""Unknown error "" + errorFlag);
    }
    return errorFlag;
}","{
    if (errorFlag == NO_ERROR) {
        return NO_ERROR;
    } else if (errorFlag == BAD_VALUE) {
        throw new BufferQueueAbandonedException();
    }
    if (errorFlag < 0) {
        throw new UnsupportedOperationException(""Unknown error "" + errorFlag);
    }
    return errorFlag;
}",1,"/**
 * Throw error codes used by legacy device methods as exceptions.
 *
 * <p>Non-negative return values are passed through, negative return values are thrown as
 * exceptions.</p>
 *
 * @param errorFlag error to throw as an exception.
 * @throws {@link BufferQueueAbandonedException} for -ENODEV.
 * @throws {@link UnsupportedOperationException} for an unknown negative error code.
 * @return {@code errorFlag} if the value was non-negative, throws otherwise.
 */
","/**
 * Throw error codes used by legacy device methods as exceptions.
 *
 * <p>Non-negative return values are passed through, negative return values are thrown as
 * exceptions.</p>
 *
 * @param errorFlag error to throw as an exception.
 * @throws {@link BufferQueueAbandonedException} for BAD_VALUE.
 * @throws {@link UnsupportedOperationException} for an unknown negative error code.
 * @return {@code errorFlag} if the value was non-negative, throws otherwise.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,3","1,2","The condition in one of the if-else statements has been modified from 'errorFlag == -ENODEV' to 'errorFlag == BAD_VALUE', and consequently, the exception thrown for a specific error value has changed. This means a change in control dependency (3) and exception handling statement (2).","Because the exception thrown for a specific error condition has changed (BufferQueueAbandonedException will be thrown for BAD_VALUE instead of -ENODEV), the API's behavior in terms of exception handling has been modified, which can cause a compatibility issue for clients that rely on specific exceptions being thrown for specific error codes. Therefore, the CI type is 1 caused by different return values (as no other return value cases changed) and 2 caused by different exception handling."
194,<android.hardware.camera2.impl.CameraDeviceImpl: void setRemoteDevice(ICameraDeviceUser)>,27,28,<android.hardware.camera2.impl.CameraDeviceImpl: void setRemoteDevice(ICameraDeviceUser)>,<android.hardware.camera2.impl.CameraDeviceImpl: void setRemoteDevice(ICameraDeviceUser)>,0,"{
    synchronized (mInterfaceLock) {
        // If setRemoteFailure already called, do nothing
        if (mInError)
            return;
        mRemoteDevice = new ICameraDeviceUserWrapper(remoteDevice);
        IBinder remoteDeviceBinder = remoteDevice.asBinder();
        // asBinder returns NULL.
        if (remoteDeviceBinder != null) {
            try {
                remoteDeviceBinder.linkToDeath(this, /*flag*/
                0);
            } catch (RemoteException e) {
                CameraDeviceImpl.this.mDeviceHandler.post(mCallOnDisconnected);
                throw new CameraAccessException(CameraAccessException.CAMERA_DISCONNECTED, ""The camera device has encountered a serious error"");
            }
        }
        mDeviceHandler.post(mCallOnOpened);
        mDeviceHandler.post(mCallOnUnconfigured);
    }
}","{
    synchronized (mInterfaceLock) {
        // If setRemoteFailure already called, do nothing
        if (mInError)
            return;
        mRemoteDevice = new ICameraDeviceUserWrapper(remoteDevice);
        IBinder remoteDeviceBinder = remoteDevice.asBinder();
        // asBinder returns NULL.
        if (remoteDeviceBinder != null) {
            try {
                remoteDeviceBinder.linkToDeath(this, /*flag*/
                0);
            } catch (RemoteException e) {
                CameraDeviceImpl.this.mDeviceExecutor.execute(mCallOnDisconnected);
                throw new CameraAccessException(CameraAccessException.CAMERA_DISCONNECTED, ""The camera device has encountered a serious error"");
            }
        }
        mDeviceExecutor.execute(mCallOnOpened);
        mDeviceExecutor.execute(mCallOnUnconfigured);
    }
}",1,"/**
 * Set remote device, which triggers initial onOpened/onUnconfigured callbacks
 *
 * <p>This function may post onDisconnected and throw CAMERA_DISCONNECTED if remoteDevice dies
 * during setup.</p>
 */
","/**
 * Set remote device, which triggers initial onOpened/onUnconfigured callbacks
 *
 * <p>This function may post onDisconnected and throw CAMERA_DISCONNECTED if remoteDevice dies
 * during setup.</p>
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The code change involves replacing `mDeviceHandler.post` calls with `mDeviceExecutor.execute`. However, this change affects only the mechanism of how callbacks are executed and not the behavior of the `setRemoteDevice` method itself, so the code change type is 4.","There is no Compatibility Issue caused by the code change because the change does not directly affect the return value, nor does it change exception handling. The callbacks are still scheduled for execution; just the executor for the callbacks has changed. Therefore, the behavior of `setRemoteDevice` remains consistent between the two API versions."
195,<android.app.job.JobInfo: boolean equals(Object)>,27,28,<android.app.job.JobInfo: boolean equals(Object)>,<android.app.job.JobInfo: boolean equals(Object)>,0,"{
    if (!(o instanceof JobInfo)) {
        return false;
    }
    JobInfo j = (JobInfo) o;
    if (jobId != j.jobId) {
        return false;
    }
    // XXX won't be correct if one is parcelled and the other not.
    if (!kindofEqualsBundle(extras, j.extras)) {
        return false;
    }
    // XXX won't be correct if one is parcelled and the other not.
    if (!kindofEqualsBundle(transientExtras, j.transientExtras)) {
        return false;
    }
    // regardless of whether their contents are the same.
    if (clipData != j.clipData) {
        return false;
    }
    if (clipGrantFlags != j.clipGrantFlags) {
        return false;
    }
    if (!Objects.equals(service, j.service)) {
        return false;
    }
    if (constraintFlags != j.constraintFlags) {
        return false;
    }
    if (!Arrays.equals(triggerContentUris, j.triggerContentUris)) {
        return false;
    }
    if (triggerContentUpdateDelay != j.triggerContentUpdateDelay) {
        return false;
    }
    if (triggerContentMaxDelay != j.triggerContentMaxDelay) {
        return false;
    }
    if (hasEarlyConstraint != j.hasEarlyConstraint) {
        return false;
    }
    if (hasLateConstraint != j.hasLateConstraint) {
        return false;
    }
    if (networkType != j.networkType) {
        return false;
    }
    if (minLatencyMillis != j.minLatencyMillis) {
        return false;
    }
    if (maxExecutionDelayMillis != j.maxExecutionDelayMillis) {
        return false;
    }
    if (isPeriodic != j.isPeriodic) {
        return false;
    }
    if (isPersisted != j.isPersisted) {
        return false;
    }
    if (intervalMillis != j.intervalMillis) {
        return false;
    }
    if (flexMillis != j.flexMillis) {
        return false;
    }
    if (initialBackoffMillis != j.initialBackoffMillis) {
        return false;
    }
    if (backoffPolicy != j.backoffPolicy) {
        return false;
    }
    if (priority != j.priority) {
        return false;
    }
    if (flags != j.flags) {
        return false;
    }
    return true;
}","{
    if (!(o instanceof JobInfo)) {
        return false;
    }
    JobInfo j = (JobInfo) o;
    if (jobId != j.jobId) {
        return false;
    }
    // XXX won't be correct if one is parcelled and the other not.
    if (!kindofEqualsBundle(extras, j.extras)) {
        return false;
    }
    // XXX won't be correct if one is parcelled and the other not.
    if (!kindofEqualsBundle(transientExtras, j.transientExtras)) {
        return false;
    }
    // regardless of whether their contents are the same.
    if (clipData != j.clipData) {
        return false;
    }
    if (clipGrantFlags != j.clipGrantFlags) {
        return false;
    }
    if (!Objects.equals(service, j.service)) {
        return false;
    }
    if (constraintFlags != j.constraintFlags) {
        return false;
    }
    if (!Arrays.equals(triggerContentUris, j.triggerContentUris)) {
        return false;
    }
    if (triggerContentUpdateDelay != j.triggerContentUpdateDelay) {
        return false;
    }
    if (triggerContentMaxDelay != j.triggerContentMaxDelay) {
        return false;
    }
    if (hasEarlyConstraint != j.hasEarlyConstraint) {
        return false;
    }
    if (hasLateConstraint != j.hasLateConstraint) {
        return false;
    }
    if (!Objects.equals(networkRequest, j.networkRequest)) {
        return false;
    }
    if (networkDownloadBytes != j.networkDownloadBytes) {
        return false;
    }
    if (networkUploadBytes != j.networkUploadBytes) {
        return false;
    }
    if (minLatencyMillis != j.minLatencyMillis) {
        return false;
    }
    if (maxExecutionDelayMillis != j.maxExecutionDelayMillis) {
        return false;
    }
    if (isPeriodic != j.isPeriodic) {
        return false;
    }
    if (isPersisted != j.isPersisted) {
        return false;
    }
    if (intervalMillis != j.intervalMillis) {
        return false;
    }
    if (flexMillis != j.flexMillis) {
        return false;
    }
    if (initialBackoffMillis != j.initialBackoffMillis) {
        return false;
    }
    if (backoffPolicy != j.backoffPolicy) {
        return false;
    }
    if (priority != j.priority) {
        return false;
    }
    if (flags != j.flags) {
        return false;
    }
    return true;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,,,,
196,"<android.bluetooth.BluetoothGatt: BluetoothGattDescriptor getDescriptorById(BluetoothDevice,int)>",27,28,"<android.bluetooth.BluetoothGatt: BluetoothGattDescriptor getDescriptorById(BluetoothDevice,int)>","<android.bluetooth.BluetoothGatt: BluetoothGattDescriptor getDescriptorById(BluetoothDevice,int)>",0,"{
    for (BluetoothGattService svc : mServices) {
        for (BluetoothGattCharacteristic charac : svc.getCharacteristics()) {
            for (BluetoothGattDescriptor desc : charac.getDescriptors()) {
                if (desc.getInstanceId() == instanceId)
                    return desc;
            }
        }
    }
    return null;
}","{
    for (BluetoothGattService svc : mServices) {
        for (BluetoothGattCharacteristic charac : svc.getCharacteristics()) {
            for (BluetoothGattDescriptor desc : charac.getDescriptors()) {
                if (desc.getInstanceId() == instanceId) {
                    return desc;
                }
            }
        }
    }
    return null;
}",1,"/*package*/
","/*package*/
",-1,,,-1,-1,-1,-1,-1,-1,0,0,"The early and late versions are functionally identical. The only difference is the introduction of additional whitespace and curly braces for readability. There are no changes to the logic, return statements, or exception handling.",There are no compatibility issues between the early and late versions because there are no functional changes to the method's implementation.
197,"<android.text.StaticLayout.Builder: Builder setIndents(int[],int[])>",27,28,"<android.text.StaticLayout.Builder: Builder setIndents(int[],int[])>","<android.text.StaticLayout.Builder: Builder setIndents(int[],int[])>",0,"{
    mLeftIndents = leftIndents;
    mRightIndents = rightIndents;
    int leftLen = leftIndents == null ? 0 : leftIndents.length;
    int rightLen = rightIndents == null ? 0 : rightIndents.length;
    int[] indents = new int[Math.max(leftLen, rightLen)];
    for (int i = 0; i < indents.length; i++) {
        int leftMargin = i < leftLen ? leftIndents[i] : 0;
        int rightMargin = i < rightLen ? rightIndents[i] : 0;
        indents[i] = leftMargin + rightMargin;
    }
    nSetIndents(mNativePtr, indents);
    return this;
}","{
    mLeftIndents = leftIndents;
    mRightIndents = rightIndents;
    return this;
}",1,"/**
 * Set indents. Arguments are arrays holding an indent amount, one per line, measured in
 * pixels. For lines past the last element in the array, the last element repeats.
 *
 * @param leftIndents array of indent values for left margin, in pixels
 * @param rightIndents array of indent values for right margin, in pixels
 * @return this builder, useful for chaining
 */
","/**
 * Set indents. Arguments are arrays holding an indent amount, one per line, measured in
 * pixels. For lines past the last element in the array, the last element repeats.
 *
 * @param leftIndents array of indent values for left margin, in pixels
 * @param rightIndents array of indent values for right margin, in pixels
 * @return this builder, useful for chaining
 */
",-1,,[@NonNull],-1,-1,-1,-1,-1,-1,"1,4",1,"The loop that calculates 'indents' along with its initialization logic has been removed, and there's a deletion of the call to nSetIndents(mNativePtr, indents), making this a change to the method body. Hence, the types of changes are 1 (Return statement changed) and 4 (Other statement changed).","The functionality of calculating and setting indents previously done in the method is removed in the later version. Since the API no longer initializes a new `indents` array, modifies it, or calls `nSetIndents` method, it will return differently, which potentially changes the object state expected by the caller. Therefore, the CI type is 1 (Compatibility Issue caused by potential different return values or types)."
198,<android.webkit.WebViewLibraryLoader.RelroFileCreator: void main(String[])>,27,28,<android.webkit.WebViewLibraryLoader.RelroFileCreator: void main(String[])>,<android.webkit.WebViewLibraryLoader.RelroFileCreator: void main(String[])>,0,"{
    boolean result = false;
    boolean is64Bit = VMRuntime.getRuntime().is64Bit();
    try {
        if (args.length != 2 || args[0] == null || args[1] == null) {
            Log.e(LOGTAG, ""Invalid RelroFileCreator args: "" + Arrays.toString(args));
            return;
        }
        Log.v(LOGTAG, ""RelroFileCreator (64bit = "" + is64Bit + ""), "" + "" 32-bit lib: "" + args[0] + "", 64-bit lib: "" + args[1]);
        if (!sAddressSpaceReserved) {
            Log.e(LOGTAG, ""can't create relro file; address space not reserved"");
            return;
        }
        result = nativeCreateRelroFile(args[0], /* path32 */
        args[1], /* path64 */
        CHROMIUM_WEBVIEW_NATIVE_RELRO_32, CHROMIUM_WEBVIEW_NATIVE_RELRO_64);
        if (result && DEBUG)
            Log.v(LOGTAG, ""created relro file"");
    } finally {
        // We must do our best to always notify the update service, even if something fails.
        try {
            WebViewFactory.getUpdateService().notifyRelroCreationCompleted();
        } catch (RemoteException e) {
            Log.e(LOGTAG, ""error notifying update service"", e);
        }
        if (!result)
            Log.e(LOGTAG, ""failed to create relro file"");
        // Must explicitly exit or else this process will just sit around after we return.
        System.exit(0);
    }
}","{
    boolean result = false;
    boolean is64Bit = VMRuntime.getRuntime().is64Bit();
    try {
        if (args.length != 1 || args[0] == null) {
            Log.e(LOGTAG, ""Invalid RelroFileCreator args: "" + Arrays.toString(args));
            return;
        }
        Log.v(LOGTAG, ""RelroFileCreator (64bit = "" + is64Bit + ""), lib: "" + args[0]);
        if (!sAddressSpaceReserved) {
            Log.e(LOGTAG, ""can't create relro file; address space not reserved"");
            return;
        }
        result = nativeCreateRelroFile(args[0], /* path */
        is64Bit ? CHROMIUM_WEBVIEW_NATIVE_RELRO_64 : CHROMIUM_WEBVIEW_NATIVE_RELRO_32);
        if (result && DEBUG)
            Log.v(LOGTAG, ""created relro file"");
    } finally {
        // We must do our best to always notify the update service, even if something fails.
        try {
            WebViewFactory.getUpdateServiceUnchecked().notifyRelroCreationCompleted();
        } catch (RemoteException e) {
            Log.e(LOGTAG, ""error notifying update service"", e);
        }
        if (!result)
            Log.e(LOGTAG, ""failed to create relro file"");
        // Must explicitly exit or else this process will just sit around after we return.
        System.exit(0);
    }
}",1,"// Called in an unprivileged child process to create the relro file.
","// Called in an unprivileged child process to create the relro file.
",-1,,,-1,-1,-1,-1,-1,-1,"1,3,4,5",1,Multiple changes have been made:,"- The call `WebViewFactory.getUpdateService()` is changed to `WebViewFactory.getUpdateServiceUnchecked()` in the late implementation, which indicates a dependent API change because the current implementation depends on this API method, and it's being changed."
200,<android.bluetooth.BluetoothDevice: IBluetooth getService()>,27,28,<android.bluetooth.BluetoothDevice: IBluetooth getService()>,<android.bluetooth.BluetoothDevice: IBluetooth getService()>,0,"{
    synchronized (BluetoothDevice.class) {
        if (sService == null) {
            BluetoothAdapter adapter = BluetoothAdapter.getDefaultAdapter();
            sService = adapter.getBluetoothService(mStateChangeCallback);
        }
    }
    return sService;
}","{
    synchronized (BluetoothDevice.class) {
        if (sService == null) {
            BluetoothAdapter adapter = BluetoothAdapter.getDefaultAdapter();
            sService = adapter.getBluetoothService(sStateChangeCallback);
        }
    }
    return sService;
}",1,"/*package*/
","/*package*/
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The change is in the identifier of the callback from mStateChangeCallback to sStateChangeCallback, which suggests a change in the variable being used. This change falls under the category 4, as it is neither a return statement change, exception handling change, control dependency change, nor a dependent API change.","There's no Compatibility Issue as long as the new callback (sStateChangeCallback) is functionally equivalent to the old one (mStateChangeCallback). There is no indication that the behavior of the getService() method itself would be altered on the basis of which callback reference it holds, assuming the callbacks are defined to operate equivalently. Hence, it would not lead to a different return value or type, nor would it lead to different exception handling."
201,"<android.widget.Editor.HandleView: void positionAtCursorOffset(int,boolean,boolean)>",27,28,"<android.widget.Editor.HandleView: void positionAtCursorOffset(int,boolean,boolean)>","<android.widget.Editor.HandleView: void positionAtCursorOffset(int,boolean,boolean)>",0,"{
    // A HandleView relies on the layout, which may be nulled by external methods
    Layout layout = mTextView.getLayout();
    if (layout == null) {
        // Will update controllers' state, hiding them and stopping selection mode if needed
        prepareCursorControllers();
        return;
    }
    layout = mTextView.getLayout();
    boolean offsetChanged = offset != mPreviousOffset;
    if (offsetChanged || forceUpdatePosition) {
        if (offsetChanged) {
            updateSelection(offset);
            if (fromTouchScreen && mHapticTextHandleEnabled) {
                mTextView.performHapticFeedback(HapticFeedbackConstants.TEXT_HANDLE_MOVE);
            }
            addPositionToTouchUpFilter(offset);
        }
        final int line = layout.getLineForOffset(offset);
        mPrevLine = line;
        mPositionX = getCursorHorizontalPosition(layout, offset) - mHotspotX - getHorizontalOffset() + getCursorOffset();
        mPositionY = layout.getLineBottom(line);
        // Take TextView's padding and scroll into account.
        mPositionX += mTextView.viewportToContentHorizontalOffset();
        mPositionY += mTextView.viewportToContentVerticalOffset();
        mPreviousOffset = offset;
        mPositionHasChanged = true;
    }
}","{
    // A HandleView relies on the layout, which may be nulled by external methods
    Layout layout = mTextView.getLayout();
    if (layout == null) {
        // Will update controllers' state, hiding them and stopping selection mode if needed
        prepareCursorControllers();
        return;
    }
    layout = mTextView.getLayout();
    boolean offsetChanged = offset != mPreviousOffset;
    if (offsetChanged || forceUpdatePosition) {
        if (offsetChanged) {
            updateSelection(offset);
            if (fromTouchScreen && mHapticTextHandleEnabled) {
                mTextView.performHapticFeedback(HapticFeedbackConstants.TEXT_HANDLE_MOVE);
            }
            addPositionToTouchUpFilter(offset);
        }
        final int line = layout.getLineForOffset(offset);
        mPrevLine = line;
        mPositionX = getCursorHorizontalPosition(layout, offset) - mHotspotX - getHorizontalOffset() + getCursorOffset();
        mPositionY = layout.getLineBottomWithoutSpacing(line);
        // Take TextView's padding and scroll into account.
        mPositionX += mTextView.viewportToContentHorizontalOffset();
        mPositionY += mTextView.viewportToContentVerticalOffset();
        mPreviousOffset = offset;
        mPositionHasChanged = true;
    }
}",1,"/**
 * @param offset Cursor offset. Must be in [-1, length].
 * @param forceUpdatePosition whether to force update the position.  This should be true
 * when If the parent has been scrolled, for example.
 * @param fromTouchScreen {@code true} if the cursor is moved with motion events from the
 * touch screen.
 */
","/**
 * @param offset Cursor offset. Must be in [-1, length].
 * @param forceUpdatePosition whether to force update the position.  This should be true
 * when If the parent has been scrolled, for example.
 * @param fromTouchScreen {@code true} if the cursor is moved with motion events from the
 * touch screen.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,1,"The code change occurs in the line `mPositionY = layout.getLineBottom(line);` which is replaced with `mPositionY = layout.getLineBottomWithoutSpacing(line);`. This constitutes an other statement change, so the type is 4.","The change in method `getLineBottom` to `getLineBottomWithoutSpacing` for calculating `mPositionY` may lead to the API potentially returning a different `mPositionY` value. This will affect the position at which the handle is drawn, so the CI type is 1."
203,<android.app.Notification.Builder: RemoteViews createBigContentView()>,27,28,<android.app.Notification.Builder: RemoteViews createBigContentView()>,<android.app.Notification.Builder: RemoteViews createBigContentView()>,0,"{
    RemoteViews result = null;
    if (mN.bigContentView != null && useExistingRemoteView()) {
        return mN.bigContentView;
    } else if (mStyle != null) {
        result = mStyle.makeBigContentView();
        hideLine1Text(result);
    } else if (mActions.size() != 0) {
        result = applyStandardTemplateWithActions(getBigBaseLayoutResource());
    }
    makeHeaderExpanded(result);
    return result;
}","{
    RemoteViews result = null;
    if (mN.bigContentView != null && useExistingRemoteView()) {
        return mN.bigContentView;
    } else if (mStyle != null) {
        result = mStyle.makeBigContentView();
        hideLine1Text(result);
    } else if (mActions.size() != 0) {
        result = applyStandardTemplateWithActions(getBigBaseLayoutResource(), null);
    }
    makeHeaderExpanded(result);
    return result;
}",1,"/**
 * Construct a RemoteViews for the final big notification layout.
 */
","/**
 * Construct a RemoteViews for the final big notification layout.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,4,5",1,"The method `applyStandardTemplateWithActions` has an additional parameter `null` in the late version. There's also an update in the method call which accounts for an 'Other statement changed', and since the change affects the dependent API method, it is categorized as 'Dependent API changed'. Both are potential changes in return statements, hence we have code change type 1,4,5.","Considering the method `applyStandardTemplateWithActions` receives an additional argument, it could potentially affect the `RemoteViews` object that is returned by the method, and subsequently the return value of `createBigContentView()`. Therefore, this could result in a situation where the API may return a different value in the late version when compared to the early version, which represents a CI type 1."
204,"<android.app.ContextImpl: Context createPackageContext(String,int)>",27,28,"<android.app.ContextImpl: Context createPackageContext(String,int)>","<android.app.ContextImpl: Context createPackageContext(String,int)>",0,"{
    return createPackageContextAsUser(packageName, flags, mUser != null ? mUser : Process.myUserHandle());
}","{
    return createPackageContextAsUser(packageName, flags, mUser);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,5,0,"The method call createPackageContextAsUser has changed by removing the ternary operator and simply passing the mUser field as a parameter. As such, a dependent API createPackageContextAsUser's way of invocation has been modified, which leads to the change type 5.","There is no compatibility issue detected because the functionality provided by createPackageContextAsUser is expected to behave the same way given mUser is not null. The previous version is effectively providing a fallback to Process.myUserHandle() in case mUser was null, but this change might indicate mUser is ensured to be non-null at this point in the code. If the mUser was indeed nullable and this change was made without ensuring mUser is always non-null, this would be a case of a compatibility issue. However, without a clear indication of mUser's nullability and its handling change, we assume non-null guarantee has been established, hence no compatibility issue."
205,"<android.provider.Settings.Secure: boolean putFloat(ContentResolver,String,float)>",27,28,"<android.provider.Settings.Secure: boolean putFloat(ContentResolver,String,float)>","<android.provider.Settings.Secure: boolean putFloat(ContentResolver,String,float)>",0,"{
    return putFloatForUser(cr, name, value, UserHandle.myUserId());
}","{
    return putFloatForUser(cr, name, value, cr.getUserId());
}",1,"/**
 * Convenience function for updating a single settings value as a
 * floating point number. This will either create a new entry in the
 * table if the given name does not exist, or modify the value of the
 * existing row with that name.  Note that internally setting values
 * are always stored as strings, so this function converts the given
 * value to a string before storing it.
 *
 * @param cr The ContentResolver to access.
 * @param name The name of the setting to modify.
 * @param value The new value for the setting.
 * @return true if the value was set, false on database errors
 */
","/**
 * Convenience function for updating a single settings value as a
 * floating point number. This will either create a new entry in the
 * table if the given name does not exist, or modify the value of the
 * existing row with that name.  Note that internally setting values
 * are always stored as strings, so this function converts the given
 * value to a string before storing it.
 *
 * @param cr The ContentResolver to access.
 * @param name The name of the setting to modify.
 * @param value The new value for the setting.
 * @return true if the value was set, false on database errors
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The dependent API call changed from UserHandle.myUserId() to cr.getUserId(), so the code change type is 5.","Since there is no indication that the behavior of UserHandle.myUserId() and cr.getUserId() is different, there is no direct sign of a compatibility issue, thus the CI type is 0."
206,"<android.service.autofill.CustomDescription.Builder: Builder addChild(int,Transformation)>",27,28,"<android.service.autofill.CustomDescription.Builder: Builder addChild(int,Transformation)>","<android.service.autofill.CustomDescription.Builder: Builder addChild(int,Transformation)>",0,"{
    Preconditions.checkArgument((transformation instanceof InternalTransformation), ""not provided by Android System: "" + transformation);
    if (mTransformations == null) {
        mTransformations = new ArrayList<>();
    }
    mTransformations.add(new Pair<>(id, (InternalTransformation) transformation));
    return this;
}","{
    throwIfDestroyed();
    Preconditions.checkArgument((transformation instanceof InternalTransformation), ""not provided by Android System: "" + transformation);
    if (mTransformations == null) {
        mTransformations = new ArrayList<>();
    }
    mTransformations.add(new Pair<>(id, (InternalTransformation) transformation));
    return this;
}",1,"/**
 * Adds a transformation to replace the value of a child view with the fields in the
 * screen.
 *
 * <p>When multiple transformations are added for the same child view, they will be applied
 * in the same order as added.
 *
 * @param id view id of the children view.
 * @param transformation an implementation provided by the Android System.
 * @return this builder.
 * @throws IllegalArgumentException if {@code transformation} is not a class provided
 * by the Android System.
 */
","/**
 * Adds a transformation to replace the value of a child view with the fields in the
 * screen.
 *
 * <p>When multiple transformations are added for the same child view, they will be applied
 * in the same order as added.
 *
 * @param id view id of the children view.
 * @param transformation an implementation provided by the Android System.
 * @return this builder.
 * @throws IllegalArgumentException if {@code transformation} is not a class provided
 * by the Android System.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The introduction of the new method call throwIfDestroyed() does not affect the control flow for the rest of the method but adds a condition that if not met will prevent the method from completing normally, so the code change type is 4.","The change is not affecting the behavior of the API in terms of what it returns or the exceptions it declares to throw, as it only introduces an internal state check (presumably to enforce the object not being in a 'destroyed' state). It does not lead to different values being returned or different exceptions being handled, as the exception thrown would be an unchecked exception not altering the method's contract. Therefore, there is no compatibility issue, and the CI type is 0."
207,<android.view.inputmethod.InputMethodManager: void hideStatusIcon(IBinder)>,27,28,<android.view.inputmethod.InputMethodManager: void hideStatusIcon(IBinder)>,<android.view.inputmethod.InputMethodManager: void hideStatusIcon(IBinder)>,0,"{
    try {
        mService.updateStatusIcon(imeToken, null, 0);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}","{
    hideStatusIconInternal(imeToken);
}",1,,"/**
 * @deprecated Use {@link InputMethodService#hideStatusIcon()} instead. This method was
 * intended for IME developers who should be accessing APIs through the service. APIs in
 * this class are intended for app developers interacting with the IME.
 */
",-1,,[@Deprecated],-1,-1,-1,-1,-1,-1,"4,5",0,"The method implementation now calls a different method, hideStatusIconInternal(imeToken), instead of directly using mService.updateStatusIcon(). However, without knowing if the behavior of hideStatusIconInternal() is different from the inline code it replaces, it's classified as ""Other statement changed"". The exact behavior of hideStatusIconInternal is not specified, so based on the provided information, we assume that it encapsulates the same behavior as the inlined code in the previous version. Additionally, this indicates a ""Dependent API changed"" because a direct call to another method (which is a dependent API) is now in place of the previous code.",There is no CI because the change is an internal refactoring that presumably preserves the external behavior of the hideStatusIcon method. The refactoring to use hideStatusIconInternal(imeToken) does not indicate a change in the observable behavior of the API; it's an internal change to organize the code differently. The addition of the @Deprecated annotation also does not affect the runtime behavior.
208,"<android.service.autofill.Dataset.Builder: Builder setValue(AutofillId,AutofillValue)>",27,28,"<android.service.autofill.Dataset.Builder: Builder setValue(AutofillId,AutofillValue)>","<android.service.autofill.Dataset.Builder: Builder setValue(AutofillId,AutofillValue)>",0,"{
    throwIfDestroyed();
    if (mPresentation == null) {
        throw new IllegalStateException(""Dataset presentation not set on constructor"");
    }
    setValueAndPresentation(id, value, null);
    return this;
}","{
    throwIfDestroyed();
    setLifeTheUniverseAndEverything(id, value, null, null);
    return this;
}",1,"/**
 * Sets the value of a field.
 *
 * @param id id returned by {@link
 * android.app.assist.AssistStructure.ViewNode#getAutofillId()}.
 * @param value value to be autofilled. Pass {@code null} if you do not have the value
 * but the target view is a logical part of the dataset. For example, if
 * the dataset needs an authentication and you have no access to the value.
 * @return This builder.
 * @throws IllegalStateException if the builder was constructed without a
 * {@link RemoteViews presentation}.
 */
","/**
 * Sets the value of a field.
 *
 * <b>Note:</b> Prior to Android {@link android.os.Build.VERSION_CODES#P}, this method would
 * throw an {@link IllegalStateException} if this builder was constructed without a
 * {@link RemoteViews presentation}. Android {@link android.os.Build.VERSION_CODES#P} and
 * higher removed this restriction because datasets used as an
 * {@link android.view.autofill.AutofillManager#EXTRA_AUTHENTICATION_RESULT
 * authentication result} do not need a presentation. But if you don't set the presentation
 * in the constructor in a dataset that is meant to be shown to the user, the autofill UI
 * for this field will not be displayed.
 *
 * <p><b>Note:</b> On Android {@link android.os.Build.VERSION_CODES#P} and
 * higher, datasets that require authentication can be also be filtered by passing a
 * {@link AutofillValue#forText(CharSequence) text value} as the {@code value} parameter.
 *
 * @param id id returned by {@link
 * android.app.assist.AssistStructure.ViewNode#getAutofillId()}.
 * @param value value to be autofilled. Pass {@code null} if you do not have the value
 * but the target view is a logical part of the dataset. For example, if
 * the dataset needs authentication and you have no access to the value.
 * @return this builder.
 */
",-1,[@NonNull],[@NonNull],-1,-1,-1,-1,-1,-1,"4,5",0,"The method called within the implementation changed from setValueAndPresentation to setLifeTheUniverseAndEverything, but the overall behavior of the method as indicated by the method signatures is intended to remain the same with additional parameters being null, indicating potentially unused or optional parameters. Therefore, the code change type is classified as 4 and 5 due to the dependent API method name change.","Although there is a change in the dependent API, considering that the additional parameters in the new method are passed as null, it does not necessarily indicate a change in the behavior relevant to the caller. As long as the semantics of setLifeTheUniverseAndEverything(id, value, null, null) are intended to be the same as the previous setValueAndPresentation(id, value, null), there would be no compatibility issue; hence, the pred_CI value is 0."
209,"<android.widget.RemoteViews.LayoutParamAction: void apply(View,ViewGroup,OnClickHandler)>",27,28,"<android.widget.RemoteViews.LayoutParamAction: void apply(View,ViewGroup,OnClickHandler)>","<android.widget.RemoteViews.LayoutParamAction: void apply(View,ViewGroup,OnClickHandler)>",0,"{
    final View target = root.findViewById(viewId);
    if (target == null) {
        return;
    }
    ViewGroup.LayoutParams layoutParams = target.getLayoutParams();
    if (layoutParams == null) {
        return;
    }
    switch(property) {
        case LAYOUT_MARGIN_END_DIMEN:
            if (layoutParams instanceof ViewGroup.MarginLayoutParams) {
                int resolved = resolveDimenPixelOffset(target, value);
                ((ViewGroup.MarginLayoutParams) layoutParams).setMarginEnd(resolved);
                target.setLayoutParams(layoutParams);
            }
            break;
        case LAYOUT_MARGIN_BOTTOM_DIMEN:
            if (layoutParams instanceof ViewGroup.MarginLayoutParams) {
                int resolved = resolveDimenPixelOffset(target, value);
                ((ViewGroup.MarginLayoutParams) layoutParams).bottomMargin = resolved;
                target.setLayoutParams(layoutParams);
            }
            break;
        case LAYOUT_WIDTH:
            layoutParams.width = value;
            target.setLayoutParams(layoutParams);
            break;
        default:
            throw new IllegalArgumentException(""Unknown property "" + property);
    }
}","{
    final View target = root.findViewById(viewId);
    if (target == null) {
        return;
    }
    ViewGroup.LayoutParams layoutParams = target.getLayoutParams();
    if (layoutParams == null) {
        return;
    }
    int value = mValue;
    switch(mProperty) {
        case LAYOUT_MARGIN_END_DIMEN:
            value = resolveDimenPixelOffset(target, mValue);
        // fall-through
        case LAYOUT_MARGIN_END:
            if (layoutParams instanceof ViewGroup.MarginLayoutParams) {
                ((ViewGroup.MarginLayoutParams) layoutParams).setMarginEnd(value);
                target.setLayoutParams(layoutParams);
            }
            break;
        case LAYOUT_MARGIN_BOTTOM_DIMEN:
            if (layoutParams instanceof ViewGroup.MarginLayoutParams) {
                int resolved = resolveDimenPixelOffset(target, mValue);
                ((ViewGroup.MarginLayoutParams) layoutParams).bottomMargin = resolved;
                target.setLayoutParams(layoutParams);
            }
            break;
        case LAYOUT_WIDTH:
            layoutParams.width = mValue;
            target.setLayoutParams(layoutParams);
            break;
        default:
            throw new IllegalArgumentException(""Unknown property "" + mProperty);
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,4",0,"There are changes in the control dependency, specifically in the 'switch' case, where the variable name `property` has been changed to `mProperty`. Additionally, the handling of the case `LAYOUT_MARGIN_END_DIMEN` has been altered by adding a new case: `LAYOUT_MARGIN_END`. These changes imply that there was a refactoring within the control flow and variable names, thus falling under type 3 and 4.","Despite the control flow and variable name changes, the actual behavior of the method with regards to what it returns (in this case it returns void, so the returned value is not affected) or the exceptions it might throw does not appear to change. The fall-through logic for the `LAYOUT_MARGIN_END_DIMEN` case seems intentional and the actual operation performed remains consistent with the previous version, so there does not appear to be a Compatibility Issue."
211,<android.os.Parcel: void writeTypedList(List<T>)>,27,28,<android.os.Parcel: void writeTypedList(List<T>)>,<android.os.Parcel: void writeTypedList(List<T>)>,0,"{
    if (val == null) {
        writeInt(-1);
        return;
    }
    int N = val.size();
    int i = 0;
    writeInt(N);
    while (i < N) {
        T item = val.get(i);
        if (item != null) {
            writeInt(1);
            item.writeToParcel(this, 0);
        } else {
            writeInt(0);
        }
        i++;
    }
}","{
    writeTypedList(val, 0);
}",1,"/**
 * Flatten a List containing a particular object type into the parcel, at
 * the current dataPosition() and growing dataCapacity() if needed.  The
 * type of the objects in the list must be one that implements Parcelable.
 * Unlike the generic writeList() method, however, only the raw data of the
 * objects is written and not their type, so you must use the corresponding
 * readTypedList() to unmarshall them.
 *
 * @param val The list of objects to be written.
 *
 * @see #createTypedArrayList
 * @see #readTypedList
 * @see Parcelable
 */
","/**
 * Flatten a List containing a particular object type into the parcel, at
 * the current dataPosition() and growing dataCapacity() if needed.  The
 * type of the objects in the list must be one that implements Parcelable.
 * Unlike the generic writeList() method, however, only the raw data of the
 * objects is written and not their type, so you must use the corresponding
 * readTypedList() to unmarshall them.
 *
 * @param val The list of objects to be written.
 *
 * @see #createTypedArrayList
 * @see #readTypedList
 * @see Parcelable
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The early version's implementation of the method is removed and replaced with a call to writeTypedList(val, 0). This shows a change in the dependent API as a new overloaded method is now being called.","There is no compatibility issue from the perspective of the public API because the method signature is unchanged, and it is reasonable to assume that the replacement method (writeTypedList(val, 0)) will perform the same list-writing functionality as the inlined code it replaces. The implementation details are abstracted away from the API consumers. Therefore, assuming that the newly called method (writeTypedList with two parameters) is correctly implementing the same logic as the inlined code previously did, calling writeTypedList(val, 0) should not result in a different behavior from the API consumer's perspective."
213,"<android.content.ContentResolver: void takePersistableUriPermission(Uri,int)>",27,28,"<android.content.ContentResolver: void takePersistableUriPermission(Uri,int)>","<android.content.ContentResolver: void takePersistableUriPermission(Uri,int)>",0,"{
    Preconditions.checkNotNull(uri, ""uri"");
    try {
        ActivityManager.getService().takePersistableUriPermission(ContentProvider.getUriWithoutUserId(uri), modeFlags, resolveUserId(uri));
    } catch (RemoteException e) {
    }
}","{
    Preconditions.checkNotNull(uri, ""uri"");
    try {
        ActivityManager.getService().takePersistableUriPermission(ContentProvider.getUriWithoutUserId(uri), modeFlags, /* toPackage= */
        null, resolveUserId(uri));
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Take a persistable URI permission grant that has been offered. Once
 * taken, the permission grant will be remembered across device reboots.
 * Only URI permissions granted with
 * {@link Intent#FLAG_GRANT_PERSISTABLE_URI_PERMISSION} can be persisted. If
 * the grant has already been persisted, taking it again will touch
 * {@link UriPermission#getPersistedTime()}.
 *
 * @see #getPersistedUriPermissions()
 */
","/**
 * Take a persistable URI permission grant that has been offered. Once
 * taken, the permission grant will be remembered across device reboots.
 * Only URI permissions granted with
 * {@link Intent#FLAG_GRANT_PERSISTABLE_URI_PERMISSION} can be persisted. If
 * the grant has already been persisted, taking it again will touch
 * {@link UriPermission#getPersistedTime()}.
 *
 * @see #getPersistedUriPermissions()
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,4,5",2,The change includes:,- No direct changes to return statements or control dependency structures (although the control flow may indirectly change due to the potential throwing of an exception where previously there was none).
214,<android.os.StrictMode.ThreadPolicy.Builder: ThreadPolicy build()>,27,28,<android.os.StrictMode.ThreadPolicy.Builder: ThreadPolicy build()>,<android.os.StrictMode.ThreadPolicy.Builder: ThreadPolicy build()>,0,"{
    // set, enable simple logging.
    if (mMask != 0 && (mMask & (PENALTY_DEATH | PENALTY_LOG | PENALTY_DROPBOX | PENALTY_DIALOG)) == 0) {
        penaltyLog();
    }
    return new ThreadPolicy(mMask);
}","{
    // set, enable simple logging.
    if (mListener == null && mMask != 0 && (mMask & (PENALTY_DEATH | PENALTY_LOG | PENALTY_DROPBOX | PENALTY_DIALOG)) == 0) {
        penaltyLog();
    }
    return new ThreadPolicy(mMask, mListener, mExecutor);
}",1,"/**
 * Construct the ThreadPolicy instance.
 *
 * <p>Note: if no penalties are enabled before calling
 * <code>build</code>, {@link #penaltyLog} is implicitly
 * set.
 */
","/**
 * Construct the ThreadPolicy instance.
 *
 * <p>Note: if no penalties are enabled before calling <code>build</code>, {@link
 * #penaltyLog} is implicitly set.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3,5",1,"The constructor call for 'new ThreadPolicy' now includes additional parameters 'mListener' and 'mExecutor', and there's also an additional condition check for 'mListener == null' in the 'if' statement. This constitutes changes in return statement, control dependency, and dependent API change, so the code change type is 1,3,5.","The change in the 'if' condition may result in 'penaltyLog()' not being called in situations where 'mListener' is not null. Additionally, the change in constructor parameters for 'new ThreadPolicy' means the method could potentially return an instance of 'ThreadPolicy' with different state. Therefore, the CI type is 1."
215,<android.net.LinkProperties: boolean equals(Object)>,27,28,<android.net.LinkProperties: boolean equals(Object)>,<android.net.LinkProperties: boolean equals(Object)>,0,"{
    if (this == obj)
        return true;
    if (!(obj instanceof LinkProperties))
        return false;
    LinkProperties target = (LinkProperties) obj;
    /**
     * This method does not check that stacked interfaces are equal, because
     * stacked interfaces are not so much a property of the link as a
     * description of connections between links.
     */
    return isIdenticalInterfaceName(target) && isIdenticalAddresses(target) && isIdenticalDnses(target) && isIdenticalRoutes(target) && isIdenticalHttpProxy(target) && isIdenticalStackedLinks(target) && isIdenticalMtu(target) && isIdenticalTcpBufferSizes(target);
}","{
    if (this == obj)
        return true;
    if (!(obj instanceof LinkProperties))
        return false;
    LinkProperties target = (LinkProperties) obj;
    /**
     * This method does not check that stacked interfaces are equal, because
     * stacked interfaces are not so much a property of the link as a
     * description of connections between links.
     */
    return isIdenticalInterfaceName(target) && isIdenticalAddresses(target) && isIdenticalDnses(target) && isIdenticalPrivateDns(target) && isIdenticalValidatedPrivateDnses(target) && isIdenticalRoutes(target) && isIdenticalHttpProxy(target) && isIdenticalStackedLinks(target) && isIdenticalMtu(target) && isIdenticalTcpBufferSizes(target);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,5",1,"The return statement has changed because the method calls within the return statement changed from ""isIdenticalDnses(target)"" to ""isIdenticalPrivateDns(target) && isIdenticalValidatedPrivateDnses(target)"". This means that the dependent APIs ""isIdenticalDnses"", ""isIdenticalPrivateDns"", and ""isIdenticalValidatedPrivateDnses"" have undergone changes, implying the code change types are 1 and 5.","Since the logic for determining equality has changed with the new checks for private DNSes, it's possible that two objects that would have been considered equal in the earlier version are no longer equal or vice versa in the late version. The changed dependent APIs have a direct impact on the return value. As a result, this is a CI of type 1, due to a potential difference in the return values."
218,"<android.app.job.JobInfo.Builder: Builder setBackoffCriteria(long,int)>",27,28,"<android.app.job.JobInfo.Builder: Builder setBackoffCriteria(long,int)>","<android.app.job.JobInfo.Builder: Builder setBackoffCriteria(long,int)>",0,"{
    mBackoffPolicySet = true;
    mInitialBackoffMillis = initialBackoffMillis;
    mBackoffPolicy = backoffPolicy;
    return this;
}","{
    final long minBackoff = getMinBackoffMillis();
    if (initialBackoffMillis < minBackoff) {
        Log.w(TAG, ""Requested backoff "" + formatDuration(initialBackoffMillis) + "" for job "" + mJobId + "" is too small; raising to "" + formatDuration(minBackoff));
        initialBackoffMillis = minBackoff;
    }
    mBackoffPolicySet = true;
    mInitialBackoffMillis = initialBackoffMillis;
    mBackoffPolicy = backoffPolicy;
    return this;
}",1,"/**
 * Set up the back-off/retry policy.
 * This defaults to some respectable values: {30 seconds, Exponential}. We cap back-off at
 * 5hrs.
 * Note that trying to set a backoff criteria for a job with
 * {@link #setRequiresDeviceIdle(boolean)} will throw an exception when you call build().
 * This is because back-off typically does not make sense for these types of jobs. See
 * {@link android.app.job.JobService#jobFinished(android.app.job.JobParameters, boolean)}
 * for more description of the return value for the case of a job executing while in idle
 * mode.
 * @param initialBackoffMillis Millisecond time interval to wait initially when job has
 * failed.
 */
","/**
 * Set up the back-off/retry policy.
 * This defaults to some respectable values: {30 seconds, Exponential}. We cap back-off at
 * 5hrs.
 * Note that trying to set a backoff criteria for a job with
 * {@link #setRequiresDeviceIdle(boolean)} will throw an exception when you call build().
 * This is because back-off typically does not make sense for these types of jobs. See
 * {@link android.app.job.JobService#jobFinished(android.app.job.JobParameters, boolean)}
 * for more description of the return value for the case of a job executing while in idle
 * mode.
 * @param initialBackoffMillis Millisecond time interval to wait initially when job has
 * failed.
 * @see JobInfo#getInitialBackoffMillis()
 * @see JobInfo#getBackoffPolicy()
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",0,The late version includes additional logic to check if the 'initialBackoffMillis' value is less than the 'minBackoff' and conditionally adjust the value. This constitutes both a control dependency change (due to the introduction of an 'if' statement - type 3) and an other statement change (due to the addition of logging and assignment statements - type 4).,"Although there is a change in the 'if' statement and the initialBackoffMillis variable might be modified, this modification affects only internal state and does not alter the returned object or its observable state from an API consumer's perspective, because the adjustment is internal to meeting a minimum requirement. Therefore, there is no Compatibility Issue as the method still returns 'this', the same Builder instance, regardless of the validation and the possible adjustment of the 'initialBackoffMillis' value (type 0)."
219,"<android.view.inputmethod.InputMethodManager: boolean switchToNextInputMethod(IBinder,boolean)>",27,28,"<android.view.inputmethod.InputMethodManager: boolean switchToNextInputMethod(IBinder,boolean)>","<android.view.inputmethod.InputMethodManager: boolean switchToNextInputMethod(IBinder,boolean)>",0,"{
    synchronized (mH) {
        try {
            return mService.switchToNextInputMethod(imeToken, onlyCurrentIme);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }
}","{
    return switchToNextInputMethodInternal(imeToken, onlyCurrentIme);
}",1,"/**
 * Force switch to the next input method and subtype. If there is no IME enabled except
 * current IME and subtype, do nothing.
 * @param imeToken Supplies the identifying token given to an input method when it was started,
 * which allows it to perform this operation on itself.
 * @param onlyCurrentIme if true, the framework will find the next subtype which
 * belongs to the current IME
 * @return true if the current input method and subtype was successfully switched to the next
 * input method and subtype.
 */
","/**
 * Force switch to the next input method and subtype. If there is no IME enabled except
 * current IME and subtype, do nothing.
 * @param imeToken Supplies the identifying token given to an input method when it was started,
 * which allows it to perform this operation on itself.
 * @param onlyCurrentIme if true, the framework will find the next subtype which
 * belongs to the current IME
 * @return true if the current input method and subtype was successfully switched to the next
 * input method and subtype.
 * @deprecated Use {@link InputMethodService#switchToNextInputMethod(boolean)} instead. This
 * method was intended for IME developers who should be accessing APIs through the service.
 * APIs in this class are intended for app developers interacting with the IME.
 */
",-1,,[@Deprecated],-1,-1,-1,-1,-1,-1,"1,5",1,The method implementation changed from using an internal synchronized block and directly calling `mService.switchToNextInputMethod` to calling another method `switchToNextInputMethodInternal`. This counts as a change in the dependent API because the actual execution of the switching functionality is moved from the synchronized block to another method.,"The dependent API change could lead to a difference in the return value, because previously the service call was made within a synchronized block on `mH`, which is removed in the late version. If `switchToNextInputMethodInternal` does not handle synchronization in the same manner or performs additional logic, the behavior of the API method could be different, hence the Compatibility Issue is 1."
220,"<android.content.IntentFilter: void dump(Printer,String)>",27,28,"<android.content.IntentFilter: void dump(Printer,String)>","<android.content.IntentFilter: void dump(Printer,String)>",0,"{
    StringBuilder sb = new StringBuilder(256);
    if (mActions.size() > 0) {
        Iterator<String> it = mActions.iterator();
        while (it.hasNext()) {
            sb.setLength(0);
            sb.append(prefix);
            sb.append(""Action: \"""");
            sb.append(it.next());
            sb.append(""\"""");
            du.println(sb.toString());
        }
    }
    if (mCategories != null) {
        Iterator<String> it = mCategories.iterator();
        while (it.hasNext()) {
            sb.setLength(0);
            sb.append(prefix);
            sb.append(""Category: \"""");
            sb.append(it.next());
            sb.append(""\"""");
            du.println(sb.toString());
        }
    }
    if (mDataSchemes != null) {
        Iterator<String> it = mDataSchemes.iterator();
        while (it.hasNext()) {
            sb.setLength(0);
            sb.append(prefix);
            sb.append(""Scheme: \"""");
            sb.append(it.next());
            sb.append(""\"""");
            du.println(sb.toString());
        }
    }
    if (mDataSchemeSpecificParts != null) {
        Iterator<PatternMatcher> it = mDataSchemeSpecificParts.iterator();
        while (it.hasNext()) {
            PatternMatcher pe = it.next();
            sb.setLength(0);
            sb.append(prefix);
            sb.append(""Ssp: \"""");
            sb.append(pe);
            sb.append(""\"""");
            du.println(sb.toString());
        }
    }
    if (mDataAuthorities != null) {
        Iterator<AuthorityEntry> it = mDataAuthorities.iterator();
        while (it.hasNext()) {
            AuthorityEntry ae = it.next();
            sb.setLength(0);
            sb.append(prefix);
            sb.append(""Authority: \"""");
            sb.append(ae.mHost);
            sb.append(""\"": "");
            sb.append(ae.mPort);
            if (ae.mWild)
                sb.append("" WILD"");
            du.println(sb.toString());
        }
    }
    if (mDataPaths != null) {
        Iterator<PatternMatcher> it = mDataPaths.iterator();
        while (it.hasNext()) {
            PatternMatcher pe = it.next();
            sb.setLength(0);
            sb.append(prefix);
            sb.append(""Path: \"""");
            sb.append(pe);
            sb.append(""\"""");
            du.println(sb.toString());
        }
    }
    if (mDataTypes != null) {
        Iterator<String> it = mDataTypes.iterator();
        while (it.hasNext()) {
            sb.setLength(0);
            sb.append(prefix);
            sb.append(""Type: \"""");
            sb.append(it.next());
            sb.append(""\"""");
            du.println(sb.toString());
        }
    }
    if (mPriority != 0 || mHasPartialTypes) {
        sb.setLength(0);
        sb.append(prefix);
        sb.append(""mPriority="");
        sb.append(mPriority);
        sb.append("", mHasPartialTypes="");
        sb.append(mHasPartialTypes);
        du.println(sb.toString());
    }
    if (getAutoVerify()) {
        sb.setLength(0);
        sb.append(prefix);
        sb.append(""AutoVerify="");
        sb.append(getAutoVerify());
        du.println(sb.toString());
    }
}","{
    StringBuilder sb = new StringBuilder(256);
    if (mActions.size() > 0) {
        Iterator<String> it = mActions.iterator();
        while (it.hasNext()) {
            sb.setLength(0);
            sb.append(prefix);
            sb.append(""Action: \"""");
            sb.append(it.next());
            sb.append(""\"""");
            du.println(sb.toString());
        }
    }
    if (mCategories != null) {
        Iterator<String> it = mCategories.iterator();
        while (it.hasNext()) {
            sb.setLength(0);
            sb.append(prefix);
            sb.append(""Category: \"""");
            sb.append(it.next());
            sb.append(""\"""");
            du.println(sb.toString());
        }
    }
    if (mDataSchemes != null) {
        Iterator<String> it = mDataSchemes.iterator();
        while (it.hasNext()) {
            sb.setLength(0);
            sb.append(prefix);
            sb.append(""Scheme: \"""");
            sb.append(it.next());
            sb.append(""\"""");
            du.println(sb.toString());
        }
    }
    if (mDataSchemeSpecificParts != null) {
        Iterator<PatternMatcher> it = mDataSchemeSpecificParts.iterator();
        while (it.hasNext()) {
            PatternMatcher pe = it.next();
            sb.setLength(0);
            sb.append(prefix);
            sb.append(""Ssp: \"""");
            sb.append(pe);
            sb.append(""\"""");
            du.println(sb.toString());
        }
    }
    if (mDataAuthorities != null) {
        Iterator<AuthorityEntry> it = mDataAuthorities.iterator();
        while (it.hasNext()) {
            AuthorityEntry ae = it.next();
            sb.setLength(0);
            sb.append(prefix);
            sb.append(""Authority: \"""");
            sb.append(ae.mHost);
            sb.append(""\"": "");
            sb.append(ae.mPort);
            if (ae.mWild)
                sb.append("" WILD"");
            du.println(sb.toString());
        }
    }
    if (mDataPaths != null) {
        Iterator<PatternMatcher> it = mDataPaths.iterator();
        while (it.hasNext()) {
            PatternMatcher pe = it.next();
            sb.setLength(0);
            sb.append(prefix);
            sb.append(""Path: \"""");
            sb.append(pe);
            sb.append(""\"""");
            du.println(sb.toString());
        }
    }
    if (mDataTypes != null) {
        Iterator<String> it = mDataTypes.iterator();
        while (it.hasNext()) {
            sb.setLength(0);
            sb.append(prefix);
            sb.append(""Type: \"""");
            sb.append(it.next());
            sb.append(""\"""");
            du.println(sb.toString());
        }
    }
    if (mPriority != 0 || mOrder != 0 || mHasPartialTypes) {
        sb.setLength(0);
        sb.append(prefix);
        sb.append(""mPriority="");
        sb.append(mPriority);
        sb.append("", mOrder="");
        sb.append(mOrder);
        sb.append("", mHasPartialTypes="");
        sb.append(mHasPartialTypes);
        du.println(sb.toString());
    }
    if (getAutoVerify()) {
        sb.setLength(0);
        sb.append(prefix);
        sb.append(""AutoVerify="");
        sb.append(getAutoVerify());
        du.println(sb.toString());
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,,,,
221,<android.net.NetworkCapabilities: int hashCode()>,27,28,<android.net.NetworkCapabilities: int hashCode()>,<android.net.NetworkCapabilities: int hashCode()>,0,"{
    return ((int) (mNetworkCapabilities & 0xFFFFFFFF) + ((int) (mNetworkCapabilities >> 32) * 3) + ((int) (mTransportTypes & 0xFFFFFFFF) * 5) + ((int) (mTransportTypes >> 32) * 7) + (mLinkUpBandwidthKbps * 11) + (mLinkDownBandwidthKbps * 13) + Objects.hashCode(mNetworkSpecifier) * 17 + (mSignalStrength * 19));
}","{
    return (int) (mNetworkCapabilities & 0xFFFFFFFF) + ((int) (mNetworkCapabilities >> 32) * 3) + ((int) (mUnwantedNetworkCapabilities & 0xFFFFFFFF) * 5) + ((int) (mUnwantedNetworkCapabilities >> 32) * 7) + ((int) (mTransportTypes & 0xFFFFFFFF) * 11) + ((int) (mTransportTypes >> 32) * 13) + (mLinkUpBandwidthKbps * 17) + (mLinkDownBandwidthKbps * 19) + Objects.hashCode(mNetworkSpecifier) * 23 + (mSignalStrength * 29) + Objects.hashCode(mUids) * 31 + Objects.hashCode(mSSID) * 37;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,4",1,"The method's return expression changed by including additional factors (mUnwantedNetworkCapabilities, mUids, and mSSID) and changing the multipliers associated with some existing components such as mTransportTypes, mLinkUpBandwidthKbps, etc. This means some other statement has been added to the return value calculation, so the code change type is 4, and also the return value of the hashCode() method has been affected directly which makes the change type 1 as well.","Since the hashCode calculation is adjusted to include new fields and changed coefficients, the potential return value of this method will be different even when called on the same object state as before. This is a direct effect on the return value, resulting in a CI of type 1."
222,<android.bluetooth.le.AdvertisingSetParameters: String toString()>,27,28,<android.bluetooth.le.AdvertisingSetParameters: String toString()>,<android.bluetooth.le.AdvertisingSetParameters: String toString()>,0,"{
    return ""AdvertisingSetParameters [connectable="" + connectable + "", isLegacy="" + isLegacy + "", isAnonymous="" + isAnonymous + "", includeTxPower="" + includeTxPower + "", primaryPhy="" + primaryPhy + "", secondaryPhy="" + secondaryPhy + "", interval="" + interval + "", txPowerLevel="" + txPowerLevel + ""]"";
}","{
    return ""AdvertisingSetParameters [connectable="" + mConnectable + "", isLegacy="" + mIsLegacy + "", isAnonymous="" + mIsAnonymous + "", includeTxPower="" + mIncludeTxPower + "", primaryPhy="" + mPrimaryPhy + "", secondaryPhy="" + mSecondaryPhy + "", interval="" + mInterval + "", txPowerLevel="" + mTxPowerLevel + ""]"";
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"The return statement has changed, but it's only a change of variable namesfrom not having the 'm' prefix to having the 'm' prefix. Since the actual behavior of the method should still be to return a String representation of the object's state and there's no indication that the underlying variables' meaning has changed, this is classified as ""Other statement changed.""",There is no Compatibility Issue because changing the names of the variables used inside the toString method does not impact the method's outward behavior as long as the values the variables represent remain the same.
223,<android.hardware.camera2.CaptureRequest: int hashCode()>,27,28,<android.hardware.camera2.CaptureRequest: int hashCode()>,<android.hardware.camera2.CaptureRequest: int hashCode()>,0,"{
    return HashCodeHelpers.hashCodeGeneric(mSettings, mSurfaceSet, mUserTag);
}","{
    return HashCodeHelpers.hashCodeGeneric(mPhysicalCameraSettings, mSurfaceSet, mUserTag);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,5,1,"The implementation has changed from using mSettings to mPhysicalCameraSettings as an argument in the hashCodeGeneric() method, which indicates a change in the dependent API and therefore the code change type is 5.","Because the hash code is computed based on different member variables between the versions, this will lead to a different return value from the hashCode() method. Therefore, the CI type is 1."
225,<android.text.format.DateFormat: char[] getDateFormatOrder(Context)>,27,28,<android.text.format.DateFormat: char[] getDateFormatOrder(Context)>,<android.text.format.DateFormat: char[] getDateFormatOrder(Context)>,0,"{
    return ICU.getDateFormatOrder(getDateFormatString());
}","{
    return ICU.getDateFormatOrder(getDateFormatString(context));
}",1,"/**
 * Gets the current date format stored as a char array. Returns a 3 element
 * array containing the day ({@code 'd'}), month ({@code 'M'}), and year ({@code 'y'}))
 * in the order specified by the user's format preference.  Note that this order is
 * <i>only</i> appropriate for all-numeric dates; spelled-out (MEDIUM and LONG)
 * dates will generally contain other punctuation, spaces, or words,
 * not just the day, month, and year, and not necessarily in the same
 * order returned here.
 */
","/**
 * Gets the current date format stored as a char array. Returns a 3 element
 * array containing the day ({@code 'd'}), month ({@code 'M'}), and year ({@code 'y'}))
 * in the order specified by the user's format preference.  Note that this order is
 * <i>only</i> appropriate for all-numeric dates; spelled-out (MEDIUM and LONG)
 * dates will generally contain other punctuation, spaces, or words,
 * not just the day, month, and year, and not necessarily in the same
 * order returned here.
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The method signature remains the same, but the implementation has changed by adding a new parameter 'context' to the method getDateFormatString(). This is a change in a dependent API, categorized as a type 5 change.","There's no compatibility issue detected because the change does not lead to a different return value or type, nor does it affect exception handling. The change only adapts the internal call to pass the required context. This would not affect the behavior as observed by the caller, assuming the context passed inside getDateFormatString(context) is properly managed and does not alter the return pattern of the method. Hence, no compatibility issue of type 1 or 2 is seen here."
226,<android.bluetooth.le.AdvertisingSetParameters: boolean isLegacy()>,27,28,<android.bluetooth.le.AdvertisingSetParameters: boolean isLegacy()>,<android.bluetooth.le.AdvertisingSetParameters: boolean isLegacy()>,0,"{
    return isLegacy;
}","{
    return mIsLegacy;
}",1,"/**
 * Returns whether the legacy advertisement will be used.
 */
","/**
 * Returns whether the legacy advertisement will be used.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The member variable name has been changed from 'isLegacy' to 'mIsLegacy', which falls under an 'Other statement changed', so the code change type is 4. ","Since the change simply consists of renaming a member variable without altering the return type or the behavior of the method, no Compatibility Issue could arise from this change. Therefore, the CI type is 0."
228,"<android.hardware.SystemSensorManager.BaseEventQueue: int injectSensorDataBase(int,float[],int,long)>",27,28,"<android.hardware.SystemSensorManager.BaseEventQueue: int injectSensorDataBase(int,float[],int,long)>","<android.hardware.SystemSensorManager.BaseEventQueue: int injectSensorDataBase(int,float[],int,long)>",0,"{
    return nativeInjectSensorData(nSensorEventQueue, handle, values, accuracy, timestamp);
}","{
    return nativeInjectSensorData(mNativeSensorEventQueue, handle, values, accuracy, timestamp);
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,4,0,The change here is the renaming of a variable used inside the method implementation: nSensorEventQueue has been changed to mNativeSensorEventQueue. The change type is 4.,"Since only the name of the variable has been changed, without any change to how the method works internally, the return value of the method and its behavior remain unchanged. There is no CI, as renaming a variable does not affect the external behavior of the API."
230,<android.view.View: void onRestoreInstanceState(Parcelable)>,27,28,<android.view.View: void onRestoreInstanceState(Parcelable)>,<android.view.View: void onRestoreInstanceState(Parcelable)>,0,"{
    mPrivateFlags |= PFLAG_SAVE_STATE_CALLED;
    if (state != null && !(state instanceof AbsSavedState)) {
        throw new IllegalArgumentException(""Wrong state class, expecting View State but "" + ""received "" + state.getClass().toString() + "" instead. This usually happens "" + ""when two views of different type have the same id in the same hierarchy. "" + ""This view's id is "" + ViewDebug.resolveId(mContext, getId()) + "". Make sure "" + ""other views do not use the same id."");
    }
    if (state != null && state instanceof BaseSavedState) {
        BaseSavedState baseState = (BaseSavedState) state;
        if ((baseState.mSavedData & BaseSavedState.START_ACTIVITY_REQUESTED_WHO_SAVED) != 0) {
            mStartActivityRequestWho = baseState.mStartActivityRequestWhoSaved;
        }
        if ((baseState.mSavedData & BaseSavedState.IS_AUTOFILLED) != 0) {
            setAutofilled(baseState.mIsAutofilled);
        }
        if ((baseState.mSavedData & BaseSavedState.AUTOFILL_ID) != 0) {
            // It can happen that views have the same view id and the restoration path will not
            // be able to distinguish between them. The autofill id needs to be unique though.
            // Hence prevent the same autofill view id from being restored multiple times.
            ((BaseSavedState) state).mSavedData &= ~BaseSavedState.AUTOFILL_ID;
            mAutofillViewId = baseState.mAutofillViewId;
        }
    }
}","{
    mPrivateFlags |= PFLAG_SAVE_STATE_CALLED;
    if (state != null && !(state instanceof AbsSavedState)) {
        throw new IllegalArgumentException(""Wrong state class, expecting View State but "" + ""received "" + state.getClass().toString() + "" instead. This usually happens "" + ""when two views of different type have the same id in the same hierarchy. "" + ""This view's id is "" + ViewDebug.resolveId(mContext, getId()) + "". Make sure "" + ""other views do not use the same id."");
    }
    if (state != null && state instanceof BaseSavedState) {
        BaseSavedState baseState = (BaseSavedState) state;
        if ((baseState.mSavedData & BaseSavedState.START_ACTIVITY_REQUESTED_WHO_SAVED) != 0) {
            mStartActivityRequestWho = baseState.mStartActivityRequestWhoSaved;
        }
        if ((baseState.mSavedData & BaseSavedState.IS_AUTOFILLED) != 0) {
            setAutofilled(baseState.mIsAutofilled);
        }
        if ((baseState.mSavedData & BaseSavedState.AUTOFILL_ID) != 0) {
            // It can happen that views have the same view id and the restoration path will not
            // be able to distinguish between them. The autofill id needs to be unique though.
            // Hence prevent the same autofill view id from being restored multiple times.
            ((BaseSavedState) state).mSavedData &= ~BaseSavedState.AUTOFILL_ID;
            if ((mPrivateFlags3 & PFLAG3_AUTOFILLID_EXPLICITLY_SET) != 0) {
                // Ignore when view already set it through setAutofillId();
                if (android.view.autofill.Helper.sDebug) {
                    Log.d(VIEW_LOG_TAG, ""onRestoreInstanceState(): not setting autofillId to "" + baseState.mAutofillViewId + "" because view explicitly set it to "" + mAutofillId);
                }
            } else {
                mAutofillViewId = baseState.mAutofillViewId;
                // will be set on demand by getAutofillId()
                mAutofillId = null;
            }
        }
    }
}",1,"/**
 * Hook allowing a view to re-apply a representation of its internal state that had previously
 * been generated by {@link #onSaveInstanceState}. This function will never be called with a
 * null state.
 *
 * @param state The frozen state that had previously been returned by
 * {@link #onSaveInstanceState}.
 *
 * @see #onSaveInstanceState()
 * @see #restoreHierarchyState(android.util.SparseArray)
 * @see #dispatchRestoreInstanceState(android.util.SparseArray)
 */
","/**
 * Hook allowing a view to re-apply a representation of its internal state that had previously
 * been generated by {@link #onSaveInstanceState}. This function will never be called with a
 * null state.
 *
 * @param state The frozen state that had previously been returned by
 * {@link #onSaveInstanceState}.
 *
 * @see #onSaveInstanceState()
 * @see #restoreHierarchyState(android.util.SparseArray)
 * @see #dispatchRestoreInstanceState(android.util.SparseArray)
 */
",-1,[@CallSuper],[@CallSuper],-1,-1,-1,-1,-1,-1,"3,4",0,"The code change includes a new control dependency (an if-statement checking mPrivateFlags3) and other statements related to logging and setting mAutofillId. Therefore, the change types are 3 for the control dependency change and 4 for the other statement changes.","No Compatibility Issue is detected since the behavior changes do not lead to different return values or exception throwings, they just add conditional logic to control the assignment process, which would not externally affect the API's contract or the behavior expected by the calling code."
231,<android.content.pm.PackageItemInfo: CharSequence loadLabel(PackageManager)>,27,28,<android.content.pm.PackageItemInfo: CharSequence loadLabel(PackageManager)>,<android.content.pm.PackageItemInfo: CharSequence loadLabel(PackageManager)>,0,"{
    if (nonLocalizedLabel != null) {
        return nonLocalizedLabel;
    }
    if (labelRes != 0) {
        CharSequence label = pm.getText(packageName, labelRes, getApplicationInfo());
        if (label != null) {
            return label.toString().trim();
        }
    }
    if (name != null) {
        return name;
    }
    return packageName;
}","{
    if (sForceSafeLabels) {
        return loadSafeLabel(pm);
    } else {
        return loadUnsafeLabel(pm);
    }
}",1,"/**
 * Retrieve the current textual label associated with this item.  This
 * will call back on the given PackageManager to load the label from
 * the application.
 *
 * @param pm A PackageManager from which the label can be loaded; usually
 * the PackageManager from which you originally retrieved this item.
 *
 * @return Returns a CharSequence containing the item's label.  If the
 * item does not have a label, its name is returned.
 */
","/**
 * Retrieve the current textual label associated with this item.  This
 * will call back on the given PackageManager to load the label from
 * the application.
 *
 * @param pm A PackageManager from which the label can be loaded; usually
 * the PackageManager from which you originally retrieved this item.
 *
 * @return Returns a CharSequence containing the item's label.  If the
 * item does not have a label, its name is returned.
 */
",-1,,[@NonNull],-1,-1,-1,-1,-1,-1,"1,4",1,"The return statements have been completely refactored to delegate the label loading to methods loadSafeLabel(pm) and loadUnsafeLabel(pm). The entire logic of the method has changed, making it now dependent on the results of those new methods. Hence, the change type is 1 for the return statement change and 4 for other statement changed.","The complete refactoring of how the label is loaded can lead to this API returning different values compared to its previous implementation because it delegates to different methods which may have their own logic and checks. Therefore, this represents a Compatibility Issue of type 1, caused by potential different return values."
232,<android.util.MapCollections.EntrySet: boolean contains(Object)>,27,28,<android.util.MapCollections.EntrySet: boolean contains(Object)>,<android.util.MapCollections.EntrySet: boolean contains(Object)>,0,"{
    if (!(o instanceof Map.Entry))
        return false;
    Map.Entry<?, ?> e = (Map.Entry<?, ?>) o;
    int index = colIndexOfKey(e.getKey());
    if (index < 0) {
        return false;
    }
    Object foundVal = colGetEntry(index, 1);
    return Objects.equal(foundVal, e.getValue());
}","{
    if (!(o instanceof Map.Entry))
        return false;
    Map.Entry<?, ?> e = (Map.Entry<?, ?>) o;
    int index = colIndexOfKey(e.getKey());
    if (index < 0) {
        return false;
    }
    Object foundVal = colGetEntry(index, 1);
    return Objects.equals(foundVal, e.getValue());
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"The change is from Objects.equal to Objects.equals, which does not modify the logic of the method or its behaviour since both are equivalent in comparing two objects for equality; they are just different ways of calling the same operation. Therefore, the change type is 4.","There is no Compatibility Issue because the behaviour of the API remains the same despite the implementation change. Objects.equal and Objects.equals both compare two objects for equality in Java, so the use of either will give the same result when the API is called."
233,<android.hardware.radio.TunerAdapter: boolean isAnalogForced()>,27,28,<android.hardware.radio.TunerAdapter: boolean isAnalogForced()>,<android.hardware.radio.TunerAdapter: boolean isAnalogForced()>,0,"{
    try {
        return mTuner.isAnalogForced();
    } catch (RemoteException e) {
        throw new RuntimeException(""service died"", e);
    }
}","{
    try {
        return isConfigFlagSet(RadioManager.CONFIG_FORCE_ANALOG);
    } catch (UnsupportedOperationException ex) {
        throw new IllegalStateException(ex);
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,2,5","1,2","The return statement has been changed to a different method call, and the exception caught and re-thrown has been changed from RemoteException to UnsupportedOperationException. Lastly, the dependent API called within the try block has been changed. Thus, the change types are 1, 2, and 5.",This change introduces a CI for two reasons: 
235,<android.widget.Editor.SuggestionsPopupWindow: void show()>,27,28,<android.widget.Editor.SuggestionsPopupWindow: void show()>,<android.widget.Editor.SuggestionsPopupWindow: void show()>,0,"{
    if (!(mTextView.getText() instanceof Editable))
        return;
    if (extractedTextModeWillBeStarted()) {
        return;
    }
    if (updateSuggestions()) {
        mCursorWasVisibleBeforeSuggestions = mCursorVisible;
        mTextView.setCursorVisible(false);
        mIsShowingUp = true;
        super.show();
    }
}","{
    if (!(mTextView.getText() instanceof Editable))
        return;
    if (extractedTextModeWillBeStarted()) {
        return;
    }
    if (updateSuggestions()) {
        mCursorWasVisibleBeforeSuggestions = mCursorVisible;
        mTextView.setCursorVisible(false);
        mIsShowingUp = true;
        super.show();
    }
    mSuggestionListView.setVisibility(mNumberOfSuggestions == 0 ? View.GONE : View.VISIBLE);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"An new other statement, 'mSuggestionListView.setVisibility(...)', has been added, and it is not a return, exception handling or control dependency statement, so the code change type is 4.","The added statement does not affect the return value or the exception throwing behavior of the method, hence there is no compatibility issue. The method always completed void and that behavior hasn't changed."
236,<android.widget.RemoteViews.ViewGroupActionAdd: boolean hasSameAppInfo(ApplicationInfo)>,27,28,<android.widget.RemoteViews.ViewGroupActionAdd: boolean hasSameAppInfo(ApplicationInfo)>,<android.widget.RemoteViews.ViewGroupActionAdd: boolean hasSameAppInfo(ApplicationInfo)>,0,"{
    return mNestedViews.mApplication.packageName.equals(parentInfo.packageName) && mNestedViews.mApplication.uid == parentInfo.uid;
}","{
    return mNestedViews.hasSameAppInfo(parentInfo);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,5,0,"The method implementation changed to a call to mNestedViews.hasSameAppInfo(parentInfo). This indicates that the logic is now encapsulated within the hasSameAppInfo method of mNestedViews. This is a change in the dependent API (mNestedViews.hasSameAppInfo), so the code change is of type 5.",There is no Compatibility Issue present because the new method (mNestedViews.hasSameAppInfo) is intended to perform the same check as the inline code from the earlier version. The refactoring to a method call doesn't change the expected behavior as long as the contract of the new method is to perform the same comparison.
237,"<android.app.PendingIntent: PendingIntent getActivity(Context,int,Intent,int,Bundle)>",27,28,"<android.app.PendingIntent: PendingIntent getActivity(Context,int,Intent,int,Bundle)>","<android.app.PendingIntent: PendingIntent getActivity(Context,int,Intent,int,Bundle)>",0,"{
    String packageName = context.getPackageName();
    String resolvedType = intent != null ? intent.resolveTypeIfNeeded(context.getContentResolver()) : null;
    try {
        intent.migrateExtraStreamToClipData();
        intent.prepareToLeaveProcess(context);
        IIntentSender target = ActivityManager.getService().getIntentSender(ActivityManager.INTENT_SENDER_ACTIVITY, packageName, null, null, requestCode, new Intent[] { intent }, resolvedType != null ? new String[] { resolvedType } : null, flags, options, UserHandle.myUserId());
        return target != null ? new PendingIntent(target) : null;
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}","{
    String packageName = context.getPackageName();
    String resolvedType = intent != null ? intent.resolveTypeIfNeeded(context.getContentResolver()) : null;
    try {
        intent.migrateExtraStreamToClipData();
        intent.prepareToLeaveProcess(context);
        IIntentSender target = ActivityManager.getService().getIntentSender(ActivityManager.INTENT_SENDER_ACTIVITY, packageName, null, null, requestCode, new Intent[] { intent }, resolvedType != null ? new String[] { resolvedType } : null, flags, options, context.getUserId());
        return target != null ? new PendingIntent(target) : null;
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Retrieve a PendingIntent that will start a new activity, like calling
 * {@link Context#startActivity(Intent) Context.startActivity(Intent)}.
 * Note that the activity will be started outside of the context of an
 * existing activity, so you must use the {@link Intent#FLAG_ACTIVITY_NEW_TASK
 * Intent.FLAG_ACTIVITY_NEW_TASK} launch flag in the Intent.
 *
 * <p class=""note"">For security reasons, the {@link android.content.Intent}
 * you supply here should almost always be an <em>explicit intent</em>,
 * that is specify an explicit component to be delivered to through
 * {@link Intent#setClass(android.content.Context, Class) Intent.setClass}</p>
 *
 * @param context The Context in which this PendingIntent should start
 * the activity.
 * @param requestCode Private request code for the sender
 * @param intent Intent of the activity to be launched.
 * @param flags May be {@link #FLAG_ONE_SHOT}, {@link #FLAG_NO_CREATE},
 * {@link #FLAG_CANCEL_CURRENT}, {@link #FLAG_UPDATE_CURRENT},
 * or any of the flags as supported by
 * {@link Intent#fillIn Intent.fillIn()} to control which unspecified parts
 * of the intent that can be supplied when the actual send happens.
 * @param options Additional options for how the Activity should be started.
 * May be null if there are no options.
 *
 * @return Returns an existing or new PendingIntent matching the given
 * parameters.  May return null only if {@link #FLAG_NO_CREATE} has been
 * supplied.
 */
","/**
 * Retrieve a PendingIntent that will start a new activity, like calling
 * {@link Context#startActivity(Intent) Context.startActivity(Intent)}.
 * Note that the activity will be started outside of the context of an
 * existing activity, so you must use the {@link Intent#FLAG_ACTIVITY_NEW_TASK
 * Intent.FLAG_ACTIVITY_NEW_TASK} launch flag in the Intent.
 *
 * <p class=""note"">For security reasons, the {@link android.content.Intent}
 * you supply here should almost always be an <em>explicit intent</em>,
 * that is specify an explicit component to be delivered to through
 * {@link Intent#setClass(android.content.Context, Class) Intent.setClass}</p>
 *
 * @param context The Context in which this PendingIntent should start
 * the activity.
 * @param requestCode Private request code for the sender
 * @param intent Intent of the activity to be launched.
 * @param flags May be {@link #FLAG_ONE_SHOT}, {@link #FLAG_NO_CREATE},
 * {@link #FLAG_CANCEL_CURRENT}, {@link #FLAG_UPDATE_CURRENT},
 * or any of the flags as supported by
 * {@link Intent#fillIn Intent.fillIn()} to control which unspecified parts
 * of the intent that can be supplied when the actual send happens.
 * @param options Additional options for how the Activity should be started.
 * May be null if there are no options.
 *
 * @return Returns an existing or new PendingIntent matching the given
 * parameters.  May return null only if {@link #FLAG_NO_CREATE} has been
 * supplied.
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,The code change type is 5 because only the last parameter passed to ActivityManager.getService().getIntentSender() changed from UserHandle.myUserId() to context.getUserId(). ,"There is no Compatibility Issue here because the method getActivity() is expected to behave in the same way despite the change in retrieving the user ID. It still provides the same functional contract: it returns a PendingIntent based on the given Intent. The change in how the user ID is retrieved does not affect the behavior from the client's perspective, assuming both methods correctly provide the user ID relevant for the context in which this method is used."
239,<android.hardware.radio.RadioManager.ModuleProperties: String toString()>,27,28,<android.hardware.radio.RadioManager.ModuleProperties: String toString()>,<android.hardware.radio.RadioManager.ModuleProperties: String toString()>,0,"{
    return ""ModuleProperties [mId="" + mId + "", mServiceName="" + mServiceName + "", mClassId="" + mClassId + "", mImplementor="" + mImplementor + "", mProduct="" + mProduct + "", mVersion="" + mVersion + "", mSerial="" + mSerial + "", mNumTuners="" + mNumTuners + "", mNumAudioSources="" + mNumAudioSources + "", mIsCaptureSupported="" + mIsCaptureSupported + "", mIsBgScanSupported="" + mIsBgScanSupported + "", mBands="" + Arrays.toString(mBands) + ""]"";
}","{
    return ""ModuleProperties [mId="" + mId + "", mServiceName="" + mServiceName + "", mClassId="" + mClassId + "", mImplementor="" + mImplementor + "", mProduct="" + mProduct + "", mVersion="" + mVersion + "", mSerial="" + mSerial + "", mNumTuners="" + mNumTuners + "", mNumAudioSources="" + mNumAudioSources + "", mIsInitializationRequired="" + mIsInitializationRequired + "", mIsCaptureSupported="" + mIsCaptureSupported + "", mIsBgScanSupported="" + mIsBgScanSupported + "", mBands="" + Arrays.toString(mBands) + ""]"";
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,4",1,"The change is in the string literal within the return statement, where a new value (""mIsInitializationRequired="" + mIsInitializationRequired) is added to the returned String, and there are no annotations that would affect the change classification. The code change type is 1 for the return statement change and 4 for the other statement change.","The addition of the new string concatenation involving ""mIsInitializationRequired"" will cause the method to return a different value in the late version, thus there is a potential different return value, and the CI type is 1."
240,<android.bluetooth.BluetoothAdapter: boolean isMultipleAdvertisementSupported()>,27,28,<android.bluetooth.BluetoothAdapter: boolean isMultipleAdvertisementSupported()>,<android.bluetooth.BluetoothAdapter: boolean isMultipleAdvertisementSupported()>,0,"{
    if (getState() != STATE_ON)
        return false;
    try {
        mServiceLock.readLock().lock();
        if (mService != null)
            return mService.isMultiAdvertisementSupported();
    } catch (RemoteException e) {
        Log.e(TAG, ""failed to get isMultipleAdvertisementSupported, error: "", e);
    } finally {
        mServiceLock.readLock().unlock();
    }
    return false;
}","{
    if (getState() != STATE_ON) {
        return false;
    }
    try {
        mServiceLock.readLock().lock();
        if (mService != null) {
            return mService.isMultiAdvertisementSupported();
        }
    } catch (RemoteException e) {
        Log.e(TAG, ""failed to get isMultipleAdvertisementSupported, error: "", e);
    } finally {
        mServiceLock.readLock().unlock();
    }
    return false;
}",1,"/**
 * Return true if the multi advertisement is supported by the chipset
 *
 * @return true if Multiple Advertisement feature is supported
 */
","/**
 * Return true if the multi advertisement is supported by the chipset
 *
 * @return true if Multiple Advertisement feature is supported
 */
",-1,,,-1,-1,-1,-1,-1,-1,0,0,There is no change to the functional behaviour of the code; only the code formatting has been updated (adding curly braces around conditional statements). ,No Compatibility Issue arises from these changes as they do not affect the functionality or behavior of the method.
242,<android.net.VpnService: Intent prepare(Context)>,27,28,<android.net.VpnService: Intent prepare(Context)>,<android.net.VpnService: Intent prepare(Context)>,0,"{
    try {
        if (getService().prepareVpn(context.getPackageName(), null, UserHandle.myUserId())) {
            return null;
        }
    } catch (RemoteException e) {
    // ignore
    }
    return VpnConfig.getIntentForConfirmation();
}","{
    try {
        if (getService().prepareVpn(context.getPackageName(), null, context.getUserId())) {
            return null;
        }
    } catch (RemoteException e) {
    // ignore
    }
    return VpnConfig.getIntentForConfirmation();
}",1,"/**
 * Prepare to establish a VPN connection. This method returns {@code null}
 * if the VPN application is already prepared or if the user has previously
 * consented to the VPN application. Otherwise, it returns an
 * {@link Intent} to a system activity. The application should launch the
 * activity using {@link Activity#startActivityForResult} to get itself
 * prepared. The activity may pop up a dialog to require user action, and
 * the result will come back via its {@link Activity#onActivityResult}.
 * If the result is {@link Activity#RESULT_OK}, the application becomes
 * prepared and is granted to use other methods in this class.
 *
 * <p>Only one application can be granted at the same time. The right
 * is revoked when another application is granted. The application
 * losing the right will be notified via its {@link #onRevoke}. Unless
 * it becomes prepared again, subsequent calls to other methods in this
 * class will fail.
 *
 * <p>The user may disable the VPN at any time while it is activated, in
 * which case this method will return an intent the next time it is
 * executed to obtain the user's consent again.
 *
 * @see #onRevoke
 */
","/**
 * Prepare to establish a VPN connection. This method returns {@code null}
 * if the VPN application is already prepared or if the user has previously
 * consented to the VPN application. Otherwise, it returns an
 * {@link Intent} to a system activity. The application should launch the
 * activity using {@link Activity#startActivityForResult} to get itself
 * prepared. The activity may pop up a dialog to require user action, and
 * the result will come back via its {@link Activity#onActivityResult}.
 * If the result is {@link Activity#RESULT_OK}, the application becomes
 * prepared and is granted to use other methods in this class.
 *
 * <p>Only one application can be granted at the same time. The right
 * is revoked when another application is granted. The application
 * losing the right will be notified via its {@link #onRevoke}. Unless
 * it becomes prepared again, subsequent calls to other methods in this
 * class will fail.
 *
 * <p>The user may disable the VPN at any time while it is activated, in
 * which case this method will return an intent the next time it is
 * executed to obtain the user's consent again.
 *
 * @see #onRevoke
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The code change is a dependent API change, where the call to UserHandle.myUserId() has been replaced with context.getUserId(). Since the early implementation depends on UserHandle.myUserId() and the late version uses a different call, context.getUserId(), the change type is 5.","There is no Compatibility Issue detected because the replacement of UserHandle.myUserId() with context.getUserId() is an internal change to get the user ID and should not affect the return value or exception handling of the method. The change doesn't directly affect the method's control flow or outcomes. Therefore, the CI type is 0."
243,"<android.widget.Editor.CursorAnchorInfoNotifier: void updatePosition(int,int,boolean,boolean)>",27,28,"<android.widget.Editor.CursorAnchorInfoNotifier: void updatePosition(int,int,boolean,boolean)>","<android.widget.Editor.CursorAnchorInfoNotifier: void updatePosition(int,int,boolean,boolean)>",0,"{
    final InputMethodState ims = mInputMethodState;
    if (ims == null || ims.mBatchEditNesting > 0) {
        return;
    }
    final InputMethodManager imm = InputMethodManager.peekInstance();
    if (null == imm) {
        return;
    }
    if (!imm.isActive(mTextView)) {
        return;
    }
    // Skip if the IME has not requested the cursor/anchor position.
    if (!imm.isCursorAnchorInfoEnabled()) {
        return;
    }
    Layout layout = mTextView.getLayout();
    if (layout == null) {
        return;
    }
    final CursorAnchorInfo.Builder builder = mSelectionInfoBuilder;
    builder.reset();
    final int selectionStart = mTextView.getSelectionStart();
    builder.setSelectionRange(selectionStart, mTextView.getSelectionEnd());
    // Construct transformation matrix from view local coordinates to screen coordinates.
    mViewToScreenMatrix.set(mTextView.getMatrix());
    mTextView.getLocationOnScreen(mTmpIntOffset);
    mViewToScreenMatrix.postTranslate(mTmpIntOffset[0], mTmpIntOffset[1]);
    builder.setMatrix(mViewToScreenMatrix);
    final float viewportToContentHorizontalOffset = mTextView.viewportToContentHorizontalOffset();
    final float viewportToContentVerticalOffset = mTextView.viewportToContentVerticalOffset();
    final CharSequence text = mTextView.getText();
    if (text instanceof Spannable) {
        final Spannable sp = (Spannable) text;
        int composingTextStart = EditableInputConnection.getComposingSpanStart(sp);
        int composingTextEnd = EditableInputConnection.getComposingSpanEnd(sp);
        if (composingTextEnd < composingTextStart) {
            final int temp = composingTextEnd;
            composingTextEnd = composingTextStart;
            composingTextStart = temp;
        }
        final boolean hasComposingText = (0 <= composingTextStart) && (composingTextStart < composingTextEnd);
        if (hasComposingText) {
            final CharSequence composingText = text.subSequence(composingTextStart, composingTextEnd);
            builder.setComposingText(composingTextStart, composingText);
            mTextView.populateCharacterBounds(builder, composingTextStart, composingTextEnd, viewportToContentHorizontalOffset, viewportToContentVerticalOffset);
        }
    }
    // Treat selectionStart as the insertion point.
    if (0 <= selectionStart) {
        final int offset = selectionStart;
        final int line = layout.getLineForOffset(offset);
        final float insertionMarkerX = layout.getPrimaryHorizontal(offset) + viewportToContentHorizontalOffset;
        final float insertionMarkerTop = layout.getLineTop(line) + viewportToContentVerticalOffset;
        final float insertionMarkerBaseline = layout.getLineBaseline(line) + viewportToContentVerticalOffset;
        final float insertionMarkerBottom = layout.getLineBottom(line) + viewportToContentVerticalOffset;
        final boolean isTopVisible = mTextView.isPositionVisible(insertionMarkerX, insertionMarkerTop);
        final boolean isBottomVisible = mTextView.isPositionVisible(insertionMarkerX, insertionMarkerBottom);
        int insertionMarkerFlags = 0;
        if (isTopVisible || isBottomVisible) {
            insertionMarkerFlags |= CursorAnchorInfo.FLAG_HAS_VISIBLE_REGION;
        }
        if (!isTopVisible || !isBottomVisible) {
            insertionMarkerFlags |= CursorAnchorInfo.FLAG_HAS_INVISIBLE_REGION;
        }
        if (layout.isRtlCharAt(offset)) {
            insertionMarkerFlags |= CursorAnchorInfo.FLAG_IS_RTL;
        }
        builder.setInsertionMarkerLocation(insertionMarkerX, insertionMarkerTop, insertionMarkerBaseline, insertionMarkerBottom, insertionMarkerFlags);
    }
    imm.updateCursorAnchorInfo(mTextView, builder.build());
}","{
    final InputMethodState ims = mInputMethodState;
    if (ims == null || ims.mBatchEditNesting > 0) {
        return;
    }
    final InputMethodManager imm = InputMethodManager.peekInstance();
    if (null == imm) {
        return;
    }
    if (!imm.isActive(mTextView)) {
        return;
    }
    // Skip if the IME has not requested the cursor/anchor position.
    if (!imm.isCursorAnchorInfoEnabled()) {
        return;
    }
    Layout layout = mTextView.getLayout();
    if (layout == null) {
        return;
    }
    final CursorAnchorInfo.Builder builder = mSelectionInfoBuilder;
    builder.reset();
    final int selectionStart = mTextView.getSelectionStart();
    builder.setSelectionRange(selectionStart, mTextView.getSelectionEnd());
    // Construct transformation matrix from view local coordinates to screen coordinates.
    mViewToScreenMatrix.set(mTextView.getMatrix());
    mTextView.getLocationOnScreen(mTmpIntOffset);
    mViewToScreenMatrix.postTranslate(mTmpIntOffset[0], mTmpIntOffset[1]);
    builder.setMatrix(mViewToScreenMatrix);
    final float viewportToContentHorizontalOffset = mTextView.viewportToContentHorizontalOffset();
    final float viewportToContentVerticalOffset = mTextView.viewportToContentVerticalOffset();
    final CharSequence text = mTextView.getText();
    if (text instanceof Spannable) {
        final Spannable sp = (Spannable) text;
        int composingTextStart = EditableInputConnection.getComposingSpanStart(sp);
        int composingTextEnd = EditableInputConnection.getComposingSpanEnd(sp);
        if (composingTextEnd < composingTextStart) {
            final int temp = composingTextEnd;
            composingTextEnd = composingTextStart;
            composingTextStart = temp;
        }
        final boolean hasComposingText = (0 <= composingTextStart) && (composingTextStart < composingTextEnd);
        if (hasComposingText) {
            final CharSequence composingText = text.subSequence(composingTextStart, composingTextEnd);
            builder.setComposingText(composingTextStart, composingText);
            mTextView.populateCharacterBounds(builder, composingTextStart, composingTextEnd, viewportToContentHorizontalOffset, viewportToContentVerticalOffset);
        }
    }
    // Treat selectionStart as the insertion point.
    if (0 <= selectionStart) {
        final int offset = selectionStart;
        final int line = layout.getLineForOffset(offset);
        final float insertionMarkerX = layout.getPrimaryHorizontal(offset) + viewportToContentHorizontalOffset;
        final float insertionMarkerTop = layout.getLineTop(line) + viewportToContentVerticalOffset;
        final float insertionMarkerBaseline = layout.getLineBaseline(line) + viewportToContentVerticalOffset;
        final float insertionMarkerBottom = layout.getLineBottomWithoutSpacing(line) + viewportToContentVerticalOffset;
        final boolean isTopVisible = mTextView.isPositionVisible(insertionMarkerX, insertionMarkerTop);
        final boolean isBottomVisible = mTextView.isPositionVisible(insertionMarkerX, insertionMarkerBottom);
        int insertionMarkerFlags = 0;
        if (isTopVisible || isBottomVisible) {
            insertionMarkerFlags |= CursorAnchorInfo.FLAG_HAS_VISIBLE_REGION;
        }
        if (!isTopVisible || !isBottomVisible) {
            insertionMarkerFlags |= CursorAnchorInfo.FLAG_HAS_INVISIBLE_REGION;
        }
        if (layout.isRtlCharAt(offset)) {
            insertionMarkerFlags |= CursorAnchorInfo.FLAG_IS_RTL;
        }
        builder.setInsertionMarkerLocation(insertionMarkerX, insertionMarkerTop, insertionMarkerBaseline, insertionMarkerBottom, insertionMarkerFlags);
    }
    imm.updateCursorAnchorInfo(mTextView, builder.build());
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,,,,
244,"<android.text.Selection: boolean moveUp(Spannable,Layout)>",27,28,"<android.text.Selection: boolean moveUp(Spannable,Layout)>","<android.text.Selection: boolean moveUp(Spannable,Layout)>",0,"{
    int start = getSelectionStart(text);
    int end = getSelectionEnd(text);
    if (start != end) {
        int min = Math.min(start, end);
        int max = Math.max(start, end);
        setSelection(text, min);
        if (min == 0 && max == text.length()) {
            return false;
        }
        return true;
    } else {
        int line = layout.getLineForOffset(end);
        if (line > 0) {
            int move;
            if (layout.getParagraphDirection(line) == layout.getParagraphDirection(line - 1)) {
                float h = layout.getPrimaryHorizontal(end);
                move = layout.getOffsetForHorizontal(line - 1, h);
            } else {
                move = layout.getLineStart(line - 1);
            }
            setSelection(text, move);
            return true;
        } else if (end != 0) {
            setSelection(text, 0);
            return true;
        }
    }
    return false;
}","{
    int start = getSelectionStart(text);
    int end = getSelectionEnd(text);
    if (start != end) {
        int min = Math.min(start, end);
        int max = Math.max(start, end);
        setSelection(text, min);
        if (min == 0 && max == text.length()) {
            return false;
        }
        return true;
    } else {
        int line = layout.getLineForOffset(end);
        if (line > 0) {
            setSelectionAndMemory(text, layout, line, end, -1, /* direction */
            false);
            return true;
        } else if (end != 0) {
            setSelection(text, 0);
            return true;
        }
    }
    return false;
}",1,"/**
 * Move the cursor to the buffer offset physically above the current
 * offset, to the beginning if it is on the top line but not at the
 * start, or return false if the cursor is already on the top line.
 */
","/**
 * Move the cursor to the buffer offset physically above the current
 * offset, to the beginning if it is on the top line but not at the
 * start, or return false if the cursor is already on the top line.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4,5",1,"The dependent API ""setSelectionAndMemory"" has replaced a block of code which indicates a control dependency change (type 3). This implies there may have been changes in the functionality provided by ""setSelectionAndMemory"" as opposed to directly using various methods within the block. Some local variables have also been removed, and the parameters passed to ""setSelectionAndMemory"" might include computations previously done in the block removed (type 4). The replacement of the block of code with a single API call is also a dependent API change (type 5).","Since we cannot see the implementation of ""setSelectionAndMemory"" we must assume that it behaves differently than the removed code block. Its usage potentially changes the behavior of the ""moveUp"" method, specifically in how it handles setting the selection which could lead to the API returning a different value when compared with the previous version. Thus, the CI type is 1."
245,<android.content.pm.ResolveInfo: Drawable loadIcon(PackageManager)>,27,28,<android.content.pm.ResolveInfo: Drawable loadIcon(PackageManager)>,<android.content.pm.ResolveInfo: Drawable loadIcon(PackageManager)>,0,"{
    Drawable dr = null;
    if (resolvePackageName != null && iconResourceId != 0) {
        dr = pm.getDrawable(resolvePackageName, iconResourceId, null);
    }
    ComponentInfo ci = getComponentInfo();
    if (dr == null && iconResourceId != 0) {
        ApplicationInfo ai = ci.applicationInfo;
        dr = pm.getDrawable(ci.packageName, iconResourceId, ai);
    }
    if (dr != null) {
        return pm.getUserBadgedIcon(dr, new UserHandle(UserHandle.myUserId()));
    }
    return ci.loadIcon(pm);
}","{
    Drawable dr = null;
    if (resolvePackageName != null && iconResourceId != 0) {
        dr = pm.getDrawable(resolvePackageName, iconResourceId, null);
    }
    ComponentInfo ci = getComponentInfo();
    if (dr == null && iconResourceId != 0) {
        ApplicationInfo ai = ci.applicationInfo;
        dr = pm.getDrawable(ci.packageName, iconResourceId, ai);
    }
    if (dr != null) {
        return pm.getUserBadgedIcon(dr, new UserHandle(pm.getUserId()));
    }
    return ci.loadIcon(pm);
}",1,"/**
 * Retrieve the current graphical icon associated with this resolution.  This
 * will call back on the given PackageManager to load the icon from
 * the application.
 *
 * @param pm A PackageManager from which the icon can be loaded; usually
 * the PackageManager from which you originally retrieved this item.
 *
 * @return Returns a Drawable containing the resolution's icon.  If the
 * item does not have an icon, the default activity icon is returned.
 */
","/**
 * Retrieve the current graphical icon associated with this resolution.  This
 * will call back on the given PackageManager to load the icon from
 * the application.
 *
 * @param pm A PackageManager from which the icon can be loaded; usually
 * the PackageManager from which you originally retrieved this item.
 *
 * @return Returns a Drawable containing the resolution's icon.  If the
 * item does not have an icon, the default activity icon is returned.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The only change between the early and late version is the parameter passed to new UserHandle() where early version uses UserHandle.myUserId() and late version uses pm.getUserId(). This means only an internal detail about how the UserHandle is obtained has changed without affecting the external behavior of the API, so the change type is 4.","There is no Compatibility Issue caused by the change since it does not affect the return type or value of the API, neither does it introduce changes in exception handling. The change internally uses a different method to get the user ID, which should result in the same user ID as before. Therefore, it should not change the API's external behavior regarding the Drawable returned to the caller."
246,"<android.net.Network.NetworkBoundSocketFactory: Socket createSocket(InetAddress,int,InetAddress,int)>",27,28,"<android.net.Network.NetworkBoundSocketFactory: Socket createSocket(InetAddress,int,InetAddress,int)>","<android.net.Network.NetworkBoundSocketFactory: Socket createSocket(InetAddress,int,InetAddress,int)>",0,"{
    Socket socket = createSocket();
    socket.bind(new InetSocketAddress(localAddress, localPort));
    socket.connect(new InetSocketAddress(address, port));
    return socket;
}","{
    Socket socket = createSocket();
    boolean failed = true;
    try {
        socket.bind(new InetSocketAddress(localAddress, localPort));
        socket.connect(new InetSocketAddress(address, port));
        failed = false;
    } finally {
        if (failed)
            IoUtils.closeQuietly(socket);
    }
    return socket;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"The late implementation introduces a 'failed' flag and a 'try-finally' block, but the overall behavior of the method remains the same in successful execution scenarios (no Compatibility Issue from normal return values). The added code only affects the state in which an exception is thrown, which is not part of the instructions to classify as a Compatibility Issue according to the definition provided. Hence, the change type is 4.","No Compatibility Issue arises from the code change because the additional statements only ensure the socket is closed when an exception occurs during binding or connecting. This does not affect the return value or the exceptions thrown by the method itself; hence, there is no change in exception handling that would be visible to the caller within the context of API behavior."
247,"<android.service.autofill.FillResponse.Builder: Builder setAuthentication(AutofillId[],IntentSender,RemoteViews)>",27,28,"<android.service.autofill.FillResponse.Builder: Builder setAuthentication(AutofillId[],IntentSender,RemoteViews)>","<android.service.autofill.FillResponse.Builder: Builder setAuthentication(AutofillId[],IntentSender,RemoteViews)>",0,"{
    throwIfDestroyed();
    if (ids == null || ids.length == 0) {
        throw new IllegalArgumentException(""ids cannot be null or empry"");
    }
    if (authentication == null ^ presentation == null) {
        throw new IllegalArgumentException(""authentication and presentation"" + "" must be both non-null or null"");
    }
    mAuthentication = authentication;
    mPresentation = presentation;
    mAuthenticationIds = ids;
    return this;
}","{
    throwIfDestroyed();
    throwIfDisableAutofillCalled();
    if (mHeader != null || mFooter != null) {
        throw new IllegalStateException(""Already called #setHeader() or #setFooter()"");
    }
    if (authentication == null ^ presentation == null) {
        throw new IllegalArgumentException(""authentication and presentation"" + "" must be both non-null or null"");
    }
    mAuthentication = authentication;
    mPresentation = presentation;
    mAuthenticationIds = assertValid(ids);
    return this;
}",1,"/**
 * Requires a fill response authentication before autofilling the screen with
 * any data set in this response.
 *
 * <p>This is typically useful when a user interaction is required to unlock their
 * data vault if you encrypt the data set labels and data set data. It is recommended
 * to encrypt only the sensitive data and not the data set labels which would allow
 * auth on the data set level leading to a better user experience. Note that if you
 * use sensitive data as a label, for example an email address, then it should also
 * be encrypted. The provided {@link android.app.PendingIntent intent} must be an
 * {@link Activity} which implements your authentication flow. Also if you provide an auth
 * intent you also need to specify the presentation view to be shown in the fill UI
 * for the user to trigger your authentication flow.
 *
 * <p>When a user triggers autofill, the system launches the provided intent
 * whose extras will have the
 * {@link android.view.autofill.AutofillManager#EXTRA_ASSIST_STRUCTURE screen
 * content} and your {@link android.view.autofill.AutofillManager#EXTRA_CLIENT_STATE
 * client state}. Once you complete your authentication flow you should set the
 * {@link Activity} result to {@link android.app.Activity#RESULT_OK} and set the
 * {@link android.view.autofill.AutofillManager#EXTRA_AUTHENTICATION_RESULT} extra
 * with the fully populated {@link FillResponse response} (or {@code null} if the screen
 * cannot be autofilled).
 *
 * <p>For example, if you provided an empty {@link FillResponse response} because the
 * user's data was locked and marked that the response needs an authentication then
 * in the response returned if authentication succeeds you need to provide all
 * available data sets some of which may need to be further authenticated, for
 * example a credit card whose CVV needs to be entered.
 *
 * <p>If you provide an authentication intent you must also provide a presentation
 * which is used to visualize visualize the response for triggering the authentication
 * flow.
 *
 * <p></><strong>Note:</strong> Do not make the provided pending intent
 * immutable by using {@link android.app.PendingIntent#FLAG_IMMUTABLE} as the
 * platform needs to fill in the authentication arguments.
 *
 * @param authentication Intent to an activity with your authentication flow.
 * @param presentation The presentation to visualize the response.
 * @param ids id of Views that when focused will display the authentication UI affordance.
 *
 * @return This builder.
 * @throws IllegalArgumentException if {@code ids} is {@code null} or empty, or if
 * neither {@code authentication} nor {@code presentation} is non-{@code null}.
 *
 * @see android.app.PendingIntent#getIntentSender()
 */
","/**
 * Triggers a custom UI before before autofilling the screen with any data set in this
 * response.
 *
 * <p><b>Note:</b> Although the name of this method suggests that it should be used just for
 * authentication flow, it can be used for other advanced flows; see {@link AutofillService}
 * for examples.
 *
 * <p>This is typically useful when a user interaction is required to unlock their
 * data vault if you encrypt the data set labels and data set data. It is recommended
 * to encrypt only the sensitive data and not the data set labels which would allow
 * auth on the data set level leading to a better user experience. Note that if you
 * use sensitive data as a label, for example an email address, then it should also
 * be encrypted. The provided {@link android.app.PendingIntent intent} must be an
 * {@link Activity} which implements your authentication flow. Also if you provide an auth
 * intent you also need to specify the presentation view to be shown in the fill UI
 * for the user to trigger your authentication flow.
 *
 * <p>When a user triggers autofill, the system launches the provided intent
 * whose extras will have the
 * {@link android.view.autofill.AutofillManager#EXTRA_ASSIST_STRUCTURE screen
 * content} and your {@link android.view.autofill.AutofillManager#EXTRA_CLIENT_STATE
 * client state}. Once you complete your authentication flow you should set the
 * {@link Activity} result to {@link android.app.Activity#RESULT_OK} and set the
 * {@link android.view.autofill.AutofillManager#EXTRA_AUTHENTICATION_RESULT} extra
 * with the fully populated {@link FillResponse response} (or {@code null} if the screen
 * cannot be autofilled).
 *
 * <p>For example, if you provided an empty {@link FillResponse response} because the
 * user's data was locked and marked that the response needs an authentication then
 * in the response returned if authentication succeeds you need to provide all
 * available data sets some of which may need to be further authenticated, for
 * example a credit card whose CVV needs to be entered.
 *
 * <p>If you provide an authentication intent you must also provide a presentation
 * which is used to visualize visualize the response for triggering the authentication
 * flow.
 *
 * <p><b>Note:</b> Do not make the provided pending intent
 * immutable by using {@link android.app.PendingIntent#FLAG_IMMUTABLE} as the
 * platform needs to fill in the authentication arguments.
 *
 * <p>Theme does not work with RemoteViews layout. Avoid hardcoded text color
 * or background color: Autofill on different platforms may have different themes.
 *
 * @param authentication Intent to an activity with your authentication flow.
 * @param presentation The presentation to visualize the response.
 * @param ids id of Views that when focused will display the authentication UI.
 *
 * @return This builder.
 *
 * @throws IllegalArgumentException if any of the following occurs:
 * <ul>
 * <li>{@code ids} is {@code null}</li>
 * <li>{@code ids} is empty</li>
 * <li>{@code ids} contains a {@code null} element</li>
 * <li>both {@code authentication} and {@code presentation} are {@code null}</li>
 * <li>both {@code authentication} and {@code presentation} are non-{@code null}</li>
 * </ul>
 *
 * @throws IllegalStateException if a {@link #setHeader(RemoteViews) header} or a
 * {@link #setFooter(RemoteViews) footer} are already set for this builder.
 *
 * @see android.app.PendingIntent#getIntentSender()
 */
",-1,[@NonNull],[@NonNull],-1,-1,-1,-1,-1,-1,"2,3,4,5","1,2","There has been a new exception handling statement introduced (throwIfDisableAutofillCalled()), and a new check for states (if (mHeader != null || mFooter != null)), which means that changes are of type 2 (Exception handling statement changed) and 3 (Control dependency changed). Also, the call to 'assertValid(ids)' has replaced the null or length check, which indicates a change in other statements (type 4) as well as a potential change in the dependent API (type 5) if 'assertValid' is an API method check that was not present in the early version.","The addition of a new method call 'throwIfDisableAutofillCalled()' introduces a new path where an IllegalStateException could be thrown, and the new condition 'if (mHeader != null || mFooter != null)' could result in an IllegalStateException before reaching the previously existing IllegalArgumentException checks. These changes affect the exceptional flow of the method, resulting in potential different exception handling (CI type 2). Additionally, the replacement of the manual 'ids' check with 'assertValid(ids)' could also potentially change the return value because the validation logic could be different or more extensive than a simple null or empty check, which could affect what 'mAuthenticationIds' is set to before returning 'this' (CI type 1)."
248,"<android.app.SharedPreferencesImpl.EditorImpl: Editor putBoolean(String,boolean)>",27,28,"<android.app.SharedPreferencesImpl.EditorImpl: Editor putBoolean(String,boolean)>","<android.app.SharedPreferencesImpl.EditorImpl: Editor putBoolean(String,boolean)>",0,"{
    synchronized (mLock) {
        mModified.put(key, value);
        return this;
    }
}","{
    synchronized (mEditorLock) {
        mModified.put(key, value);
        return this;
    }
}",1,,,-1,,[@Override],-1,-1,-1,-1,-1,-1,4,0,"The lock object used in the synchronized block is the only thing that has changed. It has changed from `mLock` to `mEditorLock`. The rest of the code remains the same, including the put operation on `mModified` and the return value. Hence, the change type is 4.","The change in lock object does not affect the external behavior of the method as long as the integrity of the shared resources (`mModified`) is maintained in a multi-threaded environment. Since no behaviors such as return values or exception handling appear to have changed from the perspective of the method's caller, there is no Compatibility Issue, and the CI type is 0."
249,<android.view.textclassifier.TextClassification: Drawable getIcon()>,27,28,<android.view.textclassifier.TextClassification: Drawable getIcon()>,<android.view.textclassifier.TextClassification: Drawable getIcon()>,0,"{
    return mIcon;
}","{
    return mLegacyIcon;
}",1,"/**
 * Returns an icon that may be rendered on a widget used to act on the classified text.
 */
","/**
 * Returns an icon that may be rendered on a widget used to act on the classified text.
 *
 * <p><strong>NOTE: </strong>This field is not parcelable and only represents the icon of the
 * first {@link RemoteAction} (if one exists) when this object is read from a parcel.
 *
 * @deprecated Use {@link #getActions()} instead.
 */
",-1,[@Nullable],"[@Deprecated, @Nullable]",-1,-1,-1,-1,-1,-1,"1,4",1,"The return statement has changed because the reference has been updated from mIcon to mLegacyIcon, which indicates a direct change in the data being returned. The variable name change is considered an 'Other statement changed' type as well, even though it's a single reference change, because it does not fall under the other specified change types, so the code change type is 1,4.","Since the variable that is being returned has been changed, it means that the method potentially returns a different Drawable object than before. Hence, there is a possibility of a Compatibility Issue arising from a potential difference in the return values, and the CI type is 1."
250,"<android.nfc.cardemulation.CardEmulation: boolean registerAidsForService(ComponentName,String,List<String>)>",27,28,"<android.nfc.cardemulation.CardEmulation: boolean registerAidsForService(ComponentName,String,List<String>)>","<android.nfc.cardemulation.CardEmulation: boolean registerAidsForService(ComponentName,String,List<String>)>",0,"{
    AidGroup aidGroup = new AidGroup(aids, category);
    try {
        return sService.registerAidGroupForService(UserHandle.myUserId(), service, aidGroup);
    } catch (RemoteException e) {
        // Try one more time
        recoverService();
        if (sService == null) {
            Log.e(TAG, ""Failed to recover CardEmulationService."");
            return false;
        }
        try {
            return sService.registerAidGroupForService(UserHandle.myUserId(), service, aidGroup);
        } catch (RemoteException ee) {
            Log.e(TAG, ""Failed to reach CardEmulationService."");
            return false;
        }
    }
}","{
    AidGroup aidGroup = new AidGroup(aids, category);
    try {
        return sService.registerAidGroupForService(mContext.getUserId(), service, aidGroup);
    } catch (RemoteException e) {
        // Try one more time
        recoverService();
        if (sService == null) {
            Log.e(TAG, ""Failed to recover CardEmulationService."");
            return false;
        }
        try {
            return sService.registerAidGroupForService(mContext.getUserId(), service, aidGroup);
        } catch (RemoteException ee) {
            Log.e(TAG, ""Failed to reach CardEmulationService."");
            return false;
        }
    }
}",1,"/**
 * Registers a list of AIDs for a specific category for the
 * specified service.
 *
 * <p>If a list of AIDs for that category was previously
 * registered for this service (either statically
 * through the manifest, or dynamically by using this API),
 * that list of AIDs will be replaced with this one.
 *
 * <p>Note that you can only register AIDs for a service that
 * is running under the same UID as the caller of this API. Typically
 * this means you need to call this from the same
 * package as the service itself, though UIDs can also
 * be shared between packages using shared UIDs.
 *
 * @param service The component name of the service
 * @param category The category of AIDs to be registered
 * @param aids A list containing the AIDs to be registered
 * @return whether the registration was successful.
 */
","/**
 * Registers a list of AIDs for a specific category for the
 * specified service.
 *
 * <p>If a list of AIDs for that category was previously
 * registered for this service (either statically
 * through the manifest, or dynamically by using this API),
 * that list of AIDs will be replaced with this one.
 *
 * <p>Note that you can only register AIDs for a service that
 * is running under the same UID as the caller of this API. Typically
 * this means you need to call this from the same
 * package as the service itself, though UIDs can also
 * be shared between packages using shared UIDs.
 *
 * @param service The component name of the service
 * @param category The category of AIDs to be registered
 * @param aids A list containing the AIDs to be registered
 * @return whether the registration was successful.
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,The method UserHandle.myUserId() has been replaced by mContext.getUserId() in the return statements within the try-catch blocks; this is an example of a change in a dependent API.,"There is no Compatibility Issue detected because the changed method seems to be used for acquiring the same information  the user ID in the context of the caller. The logic and potential return values or exceptions from the method itself did not change within the scope of the API provided, hence it would not lead to CI."
251,<android.content.ContentResolver: SyncInfo getCurrentSync()>,27,28,<android.content.ContentResolver: SyncInfo getCurrentSync()>,<android.content.ContentResolver: SyncInfo getCurrentSync()>,0,"{
    try {
        final List<SyncInfo> syncs = getContentService().getCurrentSyncs();
        if (syncs.isEmpty()) {
            return null;
        }
        return syncs.get(0);
    } catch (RemoteException e) {
        throw new RuntimeException(""the ContentService should always be reachable"", e);
    }
}","{
    try {
        final List<SyncInfo> syncs = getContentService().getCurrentSyncs();
        if (syncs.isEmpty()) {
            return null;
        }
        return syncs.get(0);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * If a sync is active returns the information about it, otherwise returns null.
 * <p>
 * This method requires the caller to hold the permission
 * {@link android.Manifest.permission#READ_SYNC_STATS}.
 * <p>
 * @return the SyncInfo for the currently active sync or null if one is not active.
 * @deprecated
 * Since multiple concurrent syncs are now supported you should use
 * {@link #getCurrentSyncs()} to get the accurate list of current syncs.
 * This method returns the first item from the list of current syncs
 * or null if there are none.
 */
","/**
 * If a sync is active returns the information about it, otherwise returns null.
 * <p>
 * This method requires the caller to hold the permission
 * {@link android.Manifest.permission#READ_SYNC_STATS}.
 * <p>
 * @return the SyncInfo for the currently active sync or null if one is not active.
 * @deprecated
 * Since multiple concurrent syncs are now supported you should use
 * {@link #getCurrentSyncs()} to get the accurate list of current syncs.
 * This method returns the first item from the list of current syncs
 * or null if there are none.
 */
",-1,[@Deprecated],[@Deprecated],-1,-1,-1,-1,-1,-1,2,2,"The exception handling statement has changed. The API now throws e.rethrowFromSystemServer() instead of new RuntimeException, so the code change type is 2.","The change in how the exception is thrown means that the same exception scenario will be handled differently between the versions, including possibly different exception types being propagated up. Therefore, the CI type is 2."
252,<android.service.notification.NotificationListenerService.MyHandler: void handleMessage(Message)>,27,28,<android.service.notification.NotificationListenerService.MyHandler: void handleMessage(Message)>,<android.service.notification.NotificationListenerService.MyHandler: void handleMessage(Message)>,0,"{
    if (!isConnected) {
        return;
    }
    switch(msg.what) {
        case MSG_ON_NOTIFICATION_POSTED:
            {
                SomeArgs args = (SomeArgs) msg.obj;
                StatusBarNotification sbn = (StatusBarNotification) args.arg1;
                RankingMap rankingMap = (RankingMap) args.arg2;
                args.recycle();
                onNotificationPosted(sbn, rankingMap);
            }
            break;
        case MSG_ON_NOTIFICATION_REMOVED:
            {
                SomeArgs args = (SomeArgs) msg.obj;
                StatusBarNotification sbn = (StatusBarNotification) args.arg1;
                RankingMap rankingMap = (RankingMap) args.arg2;
                int reason = (int) args.arg3;
                args.recycle();
                onNotificationRemoved(sbn, rankingMap, reason);
            }
            break;
        case MSG_ON_LISTENER_CONNECTED:
            {
                onListenerConnected();
            }
            break;
        case MSG_ON_NOTIFICATION_RANKING_UPDATE:
            {
                RankingMap rankingMap = (RankingMap) msg.obj;
                onNotificationRankingUpdate(rankingMap);
            }
            break;
        case MSG_ON_LISTENER_HINTS_CHANGED:
            {
                final int hints = msg.arg1;
                onListenerHintsChanged(hints);
            }
            break;
        case MSG_ON_INTERRUPTION_FILTER_CHANGED:
            {
                final int interruptionFilter = msg.arg1;
                onInterruptionFilterChanged(interruptionFilter);
            }
            break;
        case MSG_ON_NOTIFICATION_CHANNEL_MODIFIED:
            {
                SomeArgs args = (SomeArgs) msg.obj;
                String pkgName = (String) args.arg1;
                UserHandle user = (UserHandle) args.arg2;
                NotificationChannel channel = (NotificationChannel) args.arg3;
                int modificationType = (int) args.arg4;
                onNotificationChannelModified(pkgName, user, channel, modificationType);
            }
            break;
        case MSG_ON_NOTIFICATION_CHANNEL_GROUP_MODIFIED:
            {
                SomeArgs args = (SomeArgs) msg.obj;
                String pkgName = (String) args.arg1;
                UserHandle user = (UserHandle) args.arg2;
                NotificationChannelGroup group = (NotificationChannelGroup) args.arg3;
                int modificationType = (int) args.arg4;
                onNotificationChannelGroupModified(pkgName, user, group, modificationType);
            }
            break;
    }
}","{
    if (!isConnected) {
        return;
    }
    switch(msg.what) {
        case MSG_ON_NOTIFICATION_POSTED:
            {
                SomeArgs args = (SomeArgs) msg.obj;
                StatusBarNotification sbn = (StatusBarNotification) args.arg1;
                RankingMap rankingMap = (RankingMap) args.arg2;
                args.recycle();
                onNotificationPosted(sbn, rankingMap);
            }
            break;
        case MSG_ON_NOTIFICATION_REMOVED:
            {
                SomeArgs args = (SomeArgs) msg.obj;
                StatusBarNotification sbn = (StatusBarNotification) args.arg1;
                RankingMap rankingMap = (RankingMap) args.arg2;
                int reason = (int) args.arg3;
                NotificationStats stats = (NotificationStats) args.arg4;
                args.recycle();
                onNotificationRemoved(sbn, rankingMap, stats, reason);
            }
            break;
        case MSG_ON_LISTENER_CONNECTED:
            {
                onListenerConnected();
            }
            break;
        case MSG_ON_NOTIFICATION_RANKING_UPDATE:
            {
                RankingMap rankingMap = (RankingMap) msg.obj;
                onNotificationRankingUpdate(rankingMap);
            }
            break;
        case MSG_ON_LISTENER_HINTS_CHANGED:
            {
                final int hints = msg.arg1;
                onListenerHintsChanged(hints);
            }
            break;
        case MSG_ON_INTERRUPTION_FILTER_CHANGED:
            {
                final int interruptionFilter = msg.arg1;
                onInterruptionFilterChanged(interruptionFilter);
            }
            break;
        case MSG_ON_NOTIFICATION_CHANNEL_MODIFIED:
            {
                SomeArgs args = (SomeArgs) msg.obj;
                String pkgName = (String) args.arg1;
                UserHandle user = (UserHandle) args.arg2;
                NotificationChannel channel = (NotificationChannel) args.arg3;
                int modificationType = (int) args.arg4;
                onNotificationChannelModified(pkgName, user, channel, modificationType);
            }
            break;
        case MSG_ON_NOTIFICATION_CHANNEL_GROUP_MODIFIED:
            {
                SomeArgs args = (SomeArgs) msg.obj;
                String pkgName = (String) args.arg1;
                UserHandle user = (UserHandle) args.arg2;
                NotificationChannelGroup group = (NotificationChannelGroup) args.arg3;
                int modificationType = (int) args.arg4;
                onNotificationChannelGroupModified(pkgName, user, group, modificationType);
            }
            break;
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,4",1,"The implementation of the `MSG_ON_NOTIFICATION_REMOVED` case within the `switch` statement has changed. An additional argument (`NotificationStats stats = (NotificationStats) args.arg4`) is introduced and the method `onNotificationRemoved` is called with this new argument, instead of the previous form. This change falls under both control dependency change (since the change is within a switch case) and other statement change, so the code change type is 3,4.","The additional argument for the `onNotificationRemoved` method could potentially change the behavior of the `handleMessage` method because it alters the information passed to the `onNotificationRemoved` callback. Consequently, this could lead to different behavior during runtime when the callback is processed with the new arguments, hence a potential Compatibility Issue due to different return values or types, so the CI type is 1."
253,"<android.provider.Settings.System: boolean putLong(ContentResolver,String,long)>",27,28,"<android.provider.Settings.System: boolean putLong(ContentResolver,String,long)>","<android.provider.Settings.System: boolean putLong(ContentResolver,String,long)>",0,"{
    return putLongForUser(cr, name, value, UserHandle.myUserId());
}","{
    return putLongForUser(cr, name, value, cr.getUserId());
}",1,"/**
 * Convenience function for updating a single settings value as a long
 * integer. This will either create a new entry in the table if the
 * given name does not exist, or modify the value of the existing row
 * with that name.  Note that internally setting values are always
 * stored as strings, so this function converts the given value to a
 * string before storing it.
 *
 * @param cr The ContentResolver to access.
 * @param name The name of the setting to modify.
 * @param value The new value for the setting.
 * @return true if the value was set, false on database errors
 */
","/**
 * Convenience function for updating a single settings value as a long
 * integer. This will either create a new entry in the table if the
 * given name does not exist, or modify the value of the existing row
 * with that name.  Note that internally setting values are always
 * stored as strings, so this function converts the given value to a
 * string before storing it.
 *
 * @param cr The ContentResolver to access.
 * @param name The name of the setting to modify.
 * @param value The new value for the setting.
 * @return true if the value was set, false on database errors
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The dependent API putLongForUser() is invoked with a different parameter: UserHandle.myUserId() is changed to cr.getUserId(). Therefore, the code change type is 5.","Since the change only affects the parameter by which the user ID is obtained and does not inherently affect the return type or value of the method itself (assuming that cr.getUserId() is functionally equivalent to UserHandle.myUserId() for the user context in which the method is called), it does not necessarily imply possible different return values or different exceptions being thrown. Therefore, there is no detected Compatibility Issue as per the given information, and the CI type is 0."
255,<android.bluetooth.BluetoothAdapter: boolean getLeAccess()>,27,28,<android.bluetooth.BluetoothAdapter: boolean getLeAccess()>,<android.bluetooth.BluetoothAdapter: boolean getLeAccess()>,0,"{
    if (getLeState() == STATE_ON)
        return true;
    else if (getLeState() == STATE_BLE_ON)
        // TODO: FILTER SYSTEM APPS HERE <--
        return true;
    return false;
}","{
    if (getLeState() == STATE_ON) {
        return true;
    } else if (getLeState() == STATE_BLE_ON) {
        // TODO: FILTER SYSTEM APPS HERE <--
        return true;
    }
    return false;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,0,0,"There is no functional change in the implementation between the early and late versions; only the formatting has been altered with the addition of braces for better readability. Therefore, there is no change in the behavior of the code.","Since there is no actual code change and only formatting was altered without affecting the execution flow or the return values, there is no compatibility issue between the versions."
256,<android.view.textclassifier.TextSelection: String getEntity(int)>,27,28,<android.view.textclassifier.TextSelection: String getEntity(int)>,<android.view.textclassifier.TextSelection: String getEntity(int)>,0,"{
    return mEntities.get(index);
}","{
    return mEntityConfidence.getEntities().get(index);
}",1,"/**
 * Returns the entity at the specified index. Entities are ordered from high confidence
 * to low confidence.
 *
 * @throws IndexOutOfBoundsException if the specified index is out of range.
 * @see #getEntityCount() for the number of entities available.
 */
","/**
 * Returns the entity at the specified index. Entities are ordered from high confidence
 * to low confidence.
 *
 * @throws IndexOutOfBoundsException if the specified index is out of range.
 * @see #getEntityCount() for the number of entities available.
 */
",-1,"[@NonNull, @EntityType]","[@NonNull, @EntityType]",-1,-1,-1,-1,-1,-1,5,0,"The method `getEntity(int)` has its implementation changed from using `mEntities.get(index)` to `mEntityConfidence.getEntities().get(index)`, which indicates a change to a dependent API (the method used to retrieve the entities has changed); thus the code change type is 5.","Despite the change in how the entity is retrieved, since the type and contract of the method `getEntity(int)` remain unchanged, and the annotations also remain the same as [@NonNull, @EntityType], there is no indication that the behavior of the method in terms of return values or exceptions has changed. As the change does not affect the observable behavior of the API from a client's perspective, there is no Compatibility Issue; thus, the CI type is 0."
258,<android.content.ContentResolver: boolean getMasterSyncAutomatically()>,27,28,<android.content.ContentResolver: boolean getMasterSyncAutomatically()>,<android.content.ContentResolver: boolean getMasterSyncAutomatically()>,0,"{
    try {
        return getContentService().getMasterSyncAutomatically();
    } catch (RemoteException e) {
        throw new RuntimeException(""the ContentService should always be reachable"", e);
    }
}","{
    try {
        return getContentService().getMasterSyncAutomatically();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Gets the master auto-sync setting that applies to all the providers and accounts.
 * If this is false then the per-provider auto-sync setting is ignored.
 * <p>This method requires the caller to hold the permission
 * {@link android.Manifest.permission#READ_SYNC_SETTINGS}.
 *
 * @return the master auto-sync setting that applies to all the providers and accounts
 */
","/**
 * Gets the master auto-sync setting that applies to all the providers and accounts.
 * If this is false then the per-provider auto-sync setting is ignored.
 * <p>This method requires the caller to hold the permission
 * {@link android.Manifest.permission#READ_SYNC_SETTINGS}.
 *
 * @return the master auto-sync setting that applies to all the providers and accounts
 */
",-1,,,-1,-1,-1,-1,-1,-1,2,2,"The exception handling statement has changed from throwing a new RuntimeException to calling e.rethrowFromSystemServer(), so the code change type is 2.","With the change in exception handling logic, the exceptions thrown by this method in the case of a RemoteException have changed. It used to throw a RuntimeException with a specific message, but now it rethrows the RemoteException with some additional system server context. Therefore, the CI type is 2."
259,"<android.os.TokenWatcher: void acquire(IBinder,String)>",27,28,"<android.os.TokenWatcher: void acquire(IBinder,String)>","<android.os.TokenWatcher: void acquire(IBinder,String)>",0,"{
    synchronized (mTokens) {
        // explicitly checked to avoid bogus sendNotification calls because
        // of the WeakHashMap and the GC
        int oldSize = mTokens.size();
        Death d = new Death(token, tag);
        try {
            token.linkToDeath(d, 0);
        } catch (RemoteException e) {
            return;
        }
        mTokens.put(token, d);
        if (oldSize == 0 && !mAcquired) {
            sendNotificationLocked(true);
            mAcquired = true;
        }
    }
}","{
    synchronized (mTokens) {
        if (mTokens.containsKey(token)) {
            return;
        }
        // explicitly checked to avoid bogus sendNotification calls because
        // of the WeakHashMap and the GC
        int oldSize = mTokens.size();
        Death d = new Death(token, tag);
        try {
            token.linkToDeath(d, 0);
        } catch (RemoteException e) {
            return;
        }
        mTokens.put(token, d);
        if (oldSize == 0 && !mAcquired) {
            sendNotificationLocked(true);
            mAcquired = true;
        }
    }
}",1,"/**
 * Record that this token has been acquired.  When acquire is called, and
 * the current count is 0, the acquired method is called on the given
 * handler.
 *
 * @param token An IBinder object.  If this token has already been acquired,
 * no action is taken.
 * @param tag   A string used by the {@link #dump} method for debugging,
 * to see who has references.
 */
","/**
 * Record that this token has been acquired.  When acquire is called, and
 * the current count is 0, the acquired method is called on the given
 * handler.
 *
 * Note that the same {@code token} can only be acquired once. If this
 * {@code token} has already been acquired, no action is taken. The first
 * subsequent call to {@link #release} will release this {@code token}
 * immediately.
 *
 * @param token An IBinder object.
 * @param tag   A string used by the {@link #dump} method for debugging,
 * to see who has references.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",0,"The late version has added a condition to check if the token already exists in mTokens, and if it does, it will return early. There is no other change in the control flow nor the return or exception handling. Thus, the code changes include: addition of a new check (condition) which is a change in control dependency (3), and a new return statement introduced within it (4).","There is no Compatibility Issue since the newly introduced return statement would only affect redundant or duplicate token acquisitions, which do not change the method's expected successful behavior or outcome under normal circumstances, and do not modify the method's return type or introduce a new exception path."
260,"<android.text.Selection: boolean extendDown(Spannable,Layout)>",27,28,"<android.text.Selection: boolean extendDown(Spannable,Layout)>","<android.text.Selection: boolean extendDown(Spannable,Layout)>",0,"{
    int end = getSelectionEnd(text);
    int line = layout.getLineForOffset(end);
    if (line < layout.getLineCount() - 1) {
        int move;
        if (layout.getParagraphDirection(line) == layout.getParagraphDirection(line + 1)) {
            float h = layout.getPrimaryHorizontal(end);
            move = layout.getOffsetForHorizontal(line + 1, h);
        } else {
            move = layout.getLineStart(line + 1);
        }
        extendSelection(text, move);
        return true;
    } else if (end != text.length()) {
        extendSelection(text, text.length());
        return true;
    }
    return true;
}","{
    int end = getSelectionEnd(text);
    int line = layout.getLineForOffset(end);
    if (line < layout.getLineCount() - 1) {
        setSelectionAndMemory(text, layout, line, end, 1, /* direction */
        true);
        return true;
    } else if (end != text.length()) {
        extendSelection(text, text.length(), -1);
        return true;
    }
    return true;
}",1,"/**
 * Move the selection end to the buffer offset physically below
 * the current selection end.
 */
","/**
 * Move the selection end to the buffer offset physically below
 * the current selection end.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4,5",0,"The control dependency has changed because the if condition check is followed by different statements. There's a new method invocation 'setSelectionAndMemory' with different parameters and 'extendSelection' method invocation parameters also changed, which is classified as an Other statement change, and since the method names and list of parameters have changed, it is also a Dependent API change. Therefore, the code change types are 3,4,5.","There isn't a Compatibility Issue here because although the implementation details within the conditional blocks have changed, they do not alter the final behavior of the method with respect to the return value or exception throwing  the method consistently returns true in all branches in both versions."
263,<android.net.TrafficStats: long getMobileTxBytes()>,27,28,<android.net.TrafficStats: long getMobileTxBytes()>,<android.net.TrafficStats: long getMobileTxBytes()>,0,"{
    long total = 0;
    for (String iface : getMobileIfaces()) {
        total += getTxBytes(iface);
    }
    return total;
}","{
    long total = 0;
    for (String iface : getMobileIfaces()) {
        total += addIfSupported(getTxBytes(iface));
    }
    return total;
}",1,"/**
 * Return number of bytes transmitted across mobile networks since device
 * boot. Counts packets across all mobile network interfaces, and always
 * increases monotonically since device boot. Statistics are measured at the
 * network layer, so they include both TCP and UDP usage.
 * <p>
 * Before {@link android.os.Build.VERSION_CODES#JELLY_BEAN_MR2}, this may
 * return {@link #UNSUPPORTED} on devices where statistics aren't available.
 */
","/**
 * Return number of bytes transmitted across mobile networks since device
 * boot. Counts packets across all mobile network interfaces, and always
 * increases monotonically since device boot. Statistics are measured at the
 * network layer, so they include both TCP and UDP usage.
 * <p>
 * Before {@link android.os.Build.VERSION_CODES#JELLY_BEAN_MR2}, this may
 * return {@link #UNSUPPORTED} on devices where statistics aren't available.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",1,"The implementation calls a different method addIfSupported(getTxBytes(iface)) instead of directly adding getTxBytes(iface) to total. This indicates both an 'Other statement changed' and a 'Dependent API changed', hence types 4 and 5.","Because the computation of the total now potentially includes the logic encapsulated in addIfSupported(), which modifies how the transaction bytes are added to total based on the support status of each iface, the return value of the method could differ. Therefore, this introduces a 'Compatibility Issue caused by potential different return values', resulting in type 1."
266,<android.app.KeyguardManager: boolean inKeyguardRestrictedInputMode()>,27,28,<android.app.KeyguardManager: boolean inKeyguardRestrictedInputMode()>,<android.app.KeyguardManager: boolean inKeyguardRestrictedInputMode()>,0,"{
    try {
        return mWM.inKeyguardRestrictedInputMode();
    } catch (RemoteException ex) {
        return false;
    }
}","{
    return isKeyguardLocked();
}",1,"/**
 * If keyguard screen is showing or in restricted key input mode (i.e. in
 * keyguard password emergency screen). When in such mode, certain keys,
 * such as the Home key and the right soft keys, don't work.
 *
 * @return true if in keyguard restricted input mode.
 *
 * @see android.view.WindowManagerPolicy#inKeyguardRestrictedKeyInputMode
 */
","/**
 * @deprecated Use {@link #isKeyguardLocked()} instead.
 *
 * If keyguard screen is showing or in restricted key input mode (i.e. in
 * keyguard password emergency screen). When in such mode, certain keys,
 * such as the Home key and the right soft keys, don't work.
 *
 * @return true if in keyguard restricted input mode.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The implementation of the method changed from making a remote call to directly using a local method, isKeyguardLocked(), with no try-catch block around it, so the change types are 1 (for the change in the return statement) and 5 (because it's now dependent on a different API, isKeyguardLocked(), instead of inKeyguardRestrictedInputMode()).","Since the implementation no longer relies on a remote procedure call and instead calls a different method, the behavior can be different: the API may return a different value in cases where the remote call used to fail and catch a RemoteException. Consequently, the potential for returning a different value exists, and the CI type is 1."
267,"<android.view.ViewGroup: boolean requestFocus(int,Rect)>",27,28,"<android.view.ViewGroup: boolean requestFocus(int,Rect)>","<android.view.ViewGroup: boolean requestFocus(int,Rect)>",0,"{
    if (DBG) {
        System.out.println(this + "" ViewGroup.requestFocus direction="" + direction);
    }
    int descendantFocusability = getDescendantFocusability();
    switch(descendantFocusability) {
        case FOCUS_BLOCK_DESCENDANTS:
            return super.requestFocus(direction, previouslyFocusedRect);
        case FOCUS_BEFORE_DESCENDANTS:
            {
                final boolean took = super.requestFocus(direction, previouslyFocusedRect);
                return took ? took : onRequestFocusInDescendants(direction, previouslyFocusedRect);
            }
        case FOCUS_AFTER_DESCENDANTS:
            {
                final boolean took = onRequestFocusInDescendants(direction, previouslyFocusedRect);
                return took ? took : super.requestFocus(direction, previouslyFocusedRect);
            }
        default:
            throw new IllegalStateException(""descendant focusability must be "" + ""one of FOCUS_BEFORE_DESCENDANTS, FOCUS_AFTER_DESCENDANTS, FOCUS_BLOCK_DESCENDANTS "" + ""but is "" + descendantFocusability);
    }
}","{
    if (DBG) {
        System.out.println(this + "" ViewGroup.requestFocus direction="" + direction);
    }
    int descendantFocusability = getDescendantFocusability();
    boolean result;
    switch(descendantFocusability) {
        case FOCUS_BLOCK_DESCENDANTS:
            result = super.requestFocus(direction, previouslyFocusedRect);
            break;
        case FOCUS_BEFORE_DESCENDANTS:
            {
                final boolean took = super.requestFocus(direction, previouslyFocusedRect);
                result = took ? took : onRequestFocusInDescendants(direction, previouslyFocusedRect);
                break;
            }
        case FOCUS_AFTER_DESCENDANTS:
            {
                final boolean took = onRequestFocusInDescendants(direction, previouslyFocusedRect);
                result = took ? took : super.requestFocus(direction, previouslyFocusedRect);
                break;
            }
        default:
            throw new IllegalStateException(""descendant focusability must be "" + ""one of FOCUS_BEFORE_DESCENDANTS, FOCUS_AFTER_DESCENDANTS, FOCUS_BLOCK_DESCENDANTS "" + ""but is "" + descendantFocusability);
    }
    if (result && !isLayoutValid() && ((mPrivateFlags & PFLAG_WANTS_FOCUS) == 0)) {
        mPrivateFlags |= PFLAG_WANTS_FOCUS;
    }
    return result;
}",1,"/**
 * {@inheritDoc}
 *
 * Looks for a view to give focus to respecting the setting specified by
 * {@link #getDescendantFocusability()}.
 *
 * Uses {@link #onRequestFocusInDescendants(int, android.graphics.Rect)} to
 * find focus within the children of this group when appropriate.
 *
 * @see #FOCUS_BEFORE_DESCENDANTS
 * @see #FOCUS_AFTER_DESCENDANTS
 * @see #FOCUS_BLOCK_DESCENDANTS
 * @see #onRequestFocusInDescendants(int, android.graphics.Rect)
 */
","/**
 * {@inheritDoc}
 *
 * Looks for a view to give focus to respecting the setting specified by
 * {@link #getDescendantFocusability()}.
 *
 * Uses {@link #onRequestFocusInDescendants(int, android.graphics.Rect)} to
 * find focus within the children of this group when appropriate.
 *
 * @see #FOCUS_BEFORE_DESCENDANTS
 * @see #FOCUS_AFTER_DESCENDANTS
 * @see #FOCUS_BLOCK_DESCENDANTS
 * @see #onRequestFocusInDescendants(int, android.graphics.Rect)
 */
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,4",0,"The change between versions is the introduction of a new local variable 'result' that is used to store the return value and an additional if statement outside the switch block. The changes do not affect the return value or exception handling within the existing control flow, hence the change type is 3,4.","There is no Compatibility Issue as the changes in the control flow and the additional if statement do not alter the behavior of how the method returns a value or throws an exception in an observable way for the caller, so the CI type is 0."
268,<android.hardware.camera2.legacy.CameraDeviceUserShim.CameraCallbackThread.CallbackHandler: void handleMessage(Message)>,27,28,<android.hardware.camera2.legacy.CameraDeviceUserShim.CameraCallbackThread.CallbackHandler: void handleMessage(Message)>,<android.hardware.camera2.legacy.CameraDeviceUserShim.CameraCallbackThread.CallbackHandler: void handleMessage(Message)>,0,"{
    try {
        switch(msg.what) {
            case CAMERA_ERROR:
                {
                    int errorCode = msg.arg1;
                    CaptureResultExtras resultExtras = (CaptureResultExtras) msg.obj;
                    mCallbacks.onDeviceError(errorCode, resultExtras);
                    break;
                }
            case CAMERA_IDLE:
                mCallbacks.onDeviceIdle();
                break;
            case CAPTURE_STARTED:
                {
                    long timestamp = msg.arg2 & 0xFFFFFFFFL;
                    timestamp = (timestamp << 32) | (msg.arg1 & 0xFFFFFFFFL);
                    CaptureResultExtras resultExtras = (CaptureResultExtras) msg.obj;
                    mCallbacks.onCaptureStarted(resultExtras, timestamp);
                    break;
                }
            case RESULT_RECEIVED:
                {
                    Object[] resultArray = (Object[]) msg.obj;
                    CameraMetadataNative result = (CameraMetadataNative) resultArray[0];
                    CaptureResultExtras resultExtras = (CaptureResultExtras) resultArray[1];
                    mCallbacks.onResultReceived(result, resultExtras);
                    break;
                }
            case PREPARED:
                {
                    int streamId = msg.arg1;
                    mCallbacks.onPrepared(streamId);
                    break;
                }
            case REPEATING_REQUEST_ERROR:
                {
                    Object[] objArray = (Object[]) msg.obj;
                    long lastFrameNumber = (Long) objArray[0];
                    int repeatingRequestId = (Integer) objArray[1];
                    mCallbacks.onRepeatingRequestError(lastFrameNumber, repeatingRequestId);
                    break;
                }
            case REQUEST_QUEUE_EMPTY:
                {
                    mCallbacks.onRequestQueueEmpty();
                    break;
                }
            default:
                throw new IllegalArgumentException(""Unknown callback message "" + msg.what);
        }
    } catch (RemoteException e) {
        throw new IllegalStateException(""Received remote exception during camera callback "" + msg.what, e);
    }
}","{
    try {
        switch(msg.what) {
            case CAMERA_ERROR:
                {
                    int errorCode = msg.arg1;
                    CaptureResultExtras resultExtras = (CaptureResultExtras) msg.obj;
                    mCallbacks.onDeviceError(errorCode, resultExtras);
                    break;
                }
            case CAMERA_IDLE:
                mCallbacks.onDeviceIdle();
                break;
            case CAPTURE_STARTED:
                {
                    long timestamp = msg.arg2 & 0xFFFFFFFFL;
                    timestamp = (timestamp << 32) | (msg.arg1 & 0xFFFFFFFFL);
                    CaptureResultExtras resultExtras = (CaptureResultExtras) msg.obj;
                    mCallbacks.onCaptureStarted(resultExtras, timestamp);
                    break;
                }
            case RESULT_RECEIVED:
                {
                    Object[] resultArray = (Object[]) msg.obj;
                    CameraMetadataNative result = (CameraMetadataNative) resultArray[0];
                    CaptureResultExtras resultExtras = (CaptureResultExtras) resultArray[1];
                    mCallbacks.onResultReceived(result, resultExtras, new PhysicalCaptureResultInfo[0]);
                    break;
                }
            case PREPARED:
                {
                    int streamId = msg.arg1;
                    mCallbacks.onPrepared(streamId);
                    break;
                }
            case REPEATING_REQUEST_ERROR:
                {
                    Object[] objArray = (Object[]) msg.obj;
                    long lastFrameNumber = (Long) objArray[0];
                    int repeatingRequestId = (Integer) objArray[1];
                    mCallbacks.onRepeatingRequestError(lastFrameNumber, repeatingRequestId);
                    break;
                }
            case REQUEST_QUEUE_EMPTY:
                {
                    mCallbacks.onRequestQueueEmpty();
                    break;
                }
            default:
                throw new IllegalArgumentException(""Unknown callback message "" + msg.what);
        }
    } catch (RemoteException e) {
        throw new IllegalStateException(""Received remote exception during camera callback "" + msg.what, e);
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,3,4",1,"In the `RESULT_RECEIVED` case of the switch statement, an additional parameter `new PhysicalCaptureResultInfo[0]` is passed to the `onResultReceived` method. This is a change in the method call and its arguments, as well as a change to the control dependency since it affects the execution flow within the `RESULT_RECEIVED` case. Another change is that no change occurs outside of the control structures. This makes the change a complex one that includes return statement change (since the method call can return different results based on the modification), control dependency change due to the alteration in the switch case logic, and other statement change due to the additional argument introduction. Hence, the change types are 1, 3, and 4.","Since the methods signature for the callback `onResultReceived` has an additional parameter in the later version, the method may behave differently (e.g., taking into account the new parameter), which could lead to a different return value or behavior. This constitues a potential compatibility issue due to a change in return values or types, hence CI type 1."
269,<android.view.View: WindowId getWindowId()>,27,28,<android.view.View: WindowId getWindowId()>,<android.view.View: WindowId getWindowId()>,0,"{
    if (mAttachInfo == null) {
        return null;
    }
    if (mAttachInfo.mWindowId == null) {
        try {
            mAttachInfo.mIWindowId = mAttachInfo.mSession.getWindowId(mAttachInfo.mWindowToken);
            mAttachInfo.mWindowId = new WindowId(mAttachInfo.mIWindowId);
        } catch (RemoteException e) {
        }
    }
    return mAttachInfo.mWindowId;
}","{
    AttachInfo ai = mAttachInfo;
    if (ai == null) {
        return null;
    }
    if (ai.mWindowId == null) {
        try {
            ai.mIWindowId = ai.mSession.getWindowId(ai.mWindowToken);
            if (ai.mIWindowId != null) {
                ai.mWindowId = new WindowId(ai.mIWindowId);
            }
        } catch (RemoteException e) {
        }
    }
    return ai.mWindowId;
}",1,"/**
 * Retrieve the {@link WindowId} for the window this view is
 * currently attached to.
 */
","/**
 * Retrieve the {@link WindowId} for the window this view is
 * currently attached to.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",0,The code has several changes: ,- There's a minor change with using the new local variable `ai` instead of `mAttachInfo` directly.
271,"<android.view.View: void addFocusables(ArrayList<View>,int,int)>",27,28,"<android.view.View: void addFocusables(ArrayList<View>,int,int)>","<android.view.View: void addFocusables(ArrayList<View>,int,int)>",0,"{
    if (views == null) {
        return;
    }
    if (!isFocusable()) {
        return;
    }
    if ((focusableMode & FOCUSABLES_TOUCH_MODE) == FOCUSABLES_TOUCH_MODE && !isFocusableInTouchMode()) {
        return;
    }
    views.add(this);
}","{
    if (views == null) {
        return;
    }
    if (!canTakeFocus()) {
        return;
    }
    if ((focusableMode & FOCUSABLES_TOUCH_MODE) == FOCUSABLES_TOUCH_MODE && !isFocusableInTouchMode()) {
        return;
    }
    views.add(this);
}",1,"/**
 * Adds any focusable views that are descendants of this view (possibly
 * including this view if it is focusable itself) to views. This method
 * adds all focusable views regardless if we are in touch mode or
 * only views focusable in touch mode if we are in touch mode or
 * only views that can take accessibility focus if accessibility is enabled
 * depending on the focusable mode parameter.
 *
 * @param views Focusable views found so far or null if all we are interested is
 * the number of focusables.
 * @param direction The direction of the focus.
 * @param focusableMode The type of focusables to be added.
 *
 * @see #FOCUSABLES_ALL
 * @see #FOCUSABLES_TOUCH_MODE
 */
","/**
 * Adds any focusable views that are descendants of this view (possibly
 * including this view if it is focusable itself) to views. This method
 * adds all focusable views regardless if we are in touch mode or
 * only views focusable in touch mode if we are in touch mode or
 * only views that can take accessibility focus if accessibility is enabled
 * depending on the focusable mode parameter.
 *
 * @param views Focusable views found so far or null if all we are interested is
 * the number of focusables.
 * @param direction The direction of the focus.
 * @param focusableMode The type of focusables to be added.
 *
 * @see #FOCUSABLES_ALL
 * @see #FOCUSABLES_TOUCH_MODE
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,5",0,The method call within the control dependency statement changed from `!isFocusable()` to `!canTakeFocus()`. This is a change in control dependency (3) as well as a change in dependent API (5).,"The change does not introduce a Compatibility Issue since `canTakeFocus()` is likely an encapsulation that includes the `isFocusable()` check as part of its implementation. Hence, it shouldn't affect the overall behavior of adding the view to the `views` collection based on the focusability condition. The `return` statements are not altered in a way that would change the returned values or types. This is assuming that `canTakeFocus()` has been designed to maintain the same behavior as the previous logic which it has replaced. Without evidence of a behavior change in the API contract, there is no compatibility issue here (0)."
272,<android.hardware.camera2.impl.CallbackProxies.SessionStateCallbackProxy: void onActive(CameraCaptureSession)>,27,28,<android.hardware.camera2.impl.CallbackProxies.SessionStateCallbackProxy: void onActive(CameraCaptureSession)>,<android.hardware.camera2.impl.CallbackProxies.SessionStateCallbackProxy: void onActive(CameraCaptureSession)>,0,"{
    mProxy.invoke(""onActive"", session);
}","{
    final long ident = Binder.clearCallingIdentity();
    try {
        mExecutor.execute(() -> mCallback.onActive(session));
    } finally {
        Binder.restoreCallingIdentity(ident);
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"The way the callback is executed has been changed. Instead of direct invocation, the late version uses an executor to run the callback asynchronously and clears/restores the calling identity around the execution block. These changes make up the code change type 4.","While the implementation of how the 'onActive' callback is executed has changed, it does not lead to compatibility issues assuming the contract of 'onActive' method itself remains the same. The method signature and expected behavior appear to remain unchanged; the callback will still be notified when a session becomes active, regardless of the internal changes to how that notification is dispatched. Therefore, the CI type is 0."
273,<android.view.View: boolean isImportantForAutofill()>,27,28,<android.view.View: boolean isImportantForAutofill()>,<android.view.View: boolean isImportantForAutofill()>,0,"{
    // Check parent mode to ensure we're not hidden.
    ViewParent parent = mParent;
    while (parent instanceof View) {
        final int parentImportance = ((View) parent).getImportantForAutofill();
        if (parentImportance == IMPORTANT_FOR_AUTOFILL_NO_EXCLUDE_DESCENDANTS || parentImportance == IMPORTANT_FOR_AUTOFILL_YES_EXCLUDE_DESCENDANTS) {
            return false;
        }
        parent = parent.getParent();
    }
    final int importance = getImportantForAutofill();
    // First, check the explicit states.
    if (importance == IMPORTANT_FOR_AUTOFILL_YES_EXCLUDE_DESCENDANTS || importance == IMPORTANT_FOR_AUTOFILL_YES) {
        return true;
    }
    if (importance == IMPORTANT_FOR_AUTOFILL_NO_EXCLUDE_DESCENDANTS || importance == IMPORTANT_FOR_AUTOFILL_NO) {
        return false;
    }
    // Then use some heuristics to handle AUTO.
    // Always include views that have an explicit resource id.
    final int id = mID;
    if (id != NO_ID && !isViewIdGenerated(id)) {
        final Resources res = getResources();
        String entry = null;
        String pkg = null;
        try {
            entry = res.getResourceEntryName(id);
            pkg = res.getResourcePackageName(id);
        } catch (Resources.NotFoundException e) {
        // ignore
        }
        if (entry != null && pkg != null && pkg.equals(mContext.getPackageName())) {
            return true;
        }
    }
    // Otherwise, assume it's not important...
    return false;
}","{
    // Check parent mode to ensure we're not hidden.
    ViewParent parent = mParent;
    while (parent instanceof View) {
        final int parentImportance = ((View) parent).getImportantForAutofill();
        if (parentImportance == IMPORTANT_FOR_AUTOFILL_NO_EXCLUDE_DESCENDANTS || parentImportance == IMPORTANT_FOR_AUTOFILL_YES_EXCLUDE_DESCENDANTS) {
            return false;
        }
        parent = parent.getParent();
    }
    final int importance = getImportantForAutofill();
    // First, check the explicit states.
    if (importance == IMPORTANT_FOR_AUTOFILL_YES_EXCLUDE_DESCENDANTS || importance == IMPORTANT_FOR_AUTOFILL_YES) {
        return true;
    }
    if (importance == IMPORTANT_FOR_AUTOFILL_NO_EXCLUDE_DESCENDANTS || importance == IMPORTANT_FOR_AUTOFILL_NO) {
        return false;
    }
    // Then use some heuristics to handle AUTO.
    // Always include views that have an explicit resource id.
    final int id = mID;
    if (id != NO_ID && !isViewIdGenerated(id)) {
        final Resources res = getResources();
        String entry = null;
        String pkg = null;
        try {
            entry = res.getResourceEntryName(id);
            pkg = res.getResourcePackageName(id);
        } catch (Resources.NotFoundException e) {
        // ignore
        }
        if (entry != null && pkg != null && pkg.equals(mContext.getPackageName())) {
            return true;
        }
    }
    // If the app developer explicitly set hints for it, it's important.
    if (getAutofillHints() != null) {
        return true;
    }
    // Otherwise, assume it's not important...
    return false;
}",1,"/**
 * Hints the Android System whether the {@link android.app.assist.AssistStructure.ViewNode}
 * associated with this view is considered important for autofill purposes.
 *
 * <p>Generally speaking, a view is important for autofill if:
 * <ol>
 * <li>The view can be autofilled by an {@link android.service.autofill.AutofillService}.
 * <li>The view contents can help an {@link android.service.autofill.AutofillService}
 * determine how other views can be autofilled.
 * <ol>
 *
 * <p>For example, view containers should typically return {@code false} for performance reasons
 * (since the important info is provided by their children), but if its properties have relevant
 * information (for example, a resource id called {@code credentials}, it should return
 * {@code true}. On the other hand, views representing labels or editable fields should
 * typically return {@code true}, but in some cases they could return {@code false}
 * (for example, if they're part of a ""Captcha"" mechanism).
 *
 * <p>The value returned by this method depends on the value returned by
 * {@link #getImportantForAutofill()}:
 *
 * <ol>
 * <li>if it returns {@link #IMPORTANT_FOR_AUTOFILL_YES} or
 * {@link #IMPORTANT_FOR_AUTOFILL_YES_EXCLUDE_DESCENDANTS}, then it returns {@code true}
 * <li>if it returns {@link #IMPORTANT_FOR_AUTOFILL_NO} or
 * {@link #IMPORTANT_FOR_AUTOFILL_NO_EXCLUDE_DESCENDANTS}, then it returns {@code false}
 * <li>if it returns {@link #IMPORTANT_FOR_AUTOFILL_AUTO}, then it uses some simple heuristics
 * that can return {@code true} in some cases (like a container with a resource id),
 * but {@code false} in most.
 * <li>otherwise, it returns {@code false}.
 * </ol>
 *
 * <p>When a view is considered important for autofill:
 * <ul>
 * <li>The view might automatically trigger an autofill request when focused on.
 * <li>The contents of the view are included in the {@link ViewStructure} used in an autofill
 * request.
 * </ul>
 *
 * <p>On the other hand, when a view is considered not important for autofill:
 * <ul>
 * <li>The view never automatically triggers autofill requests, but it can trigger a manual
 * request through {@link AutofillManager#requestAutofill(View)}.
 * <li>The contents of the view are not included in the {@link ViewStructure} used in an
 * autofill request, unless the request has the
 * {@link #AUTOFILL_FLAG_INCLUDE_NOT_IMPORTANT_VIEWS} flag.
 * </ul>
 *
 * @return whether the view is considered important for autofill.
 *
 * @see #setImportantForAutofill(int)
 * @see #IMPORTANT_FOR_AUTOFILL_AUTO
 * @see #IMPORTANT_FOR_AUTOFILL_YES
 * @see #IMPORTANT_FOR_AUTOFILL_NO
 * @see #IMPORTANT_FOR_AUTOFILL_YES_EXCLUDE_DESCENDANTS
 * @see #IMPORTANT_FOR_AUTOFILL_NO_EXCLUDE_DESCENDANTS
 * @see AutofillManager#requestAutofill(View)
 */
","/**
 * Hints the Android System whether the {@link android.app.assist.AssistStructure.ViewNode}
 * associated with this view is considered important for autofill purposes.
 *
 * <p>Generally speaking, a view is important for autofill if:
 * <ol>
 * <li>The view can be autofilled by an {@link android.service.autofill.AutofillService}.
 * <li>The view contents can help an {@link android.service.autofill.AutofillService}
 * determine how other views can be autofilled.
 * <ol>
 *
 * <p>For example, view containers should typically return {@code false} for performance reasons
 * (since the important info is provided by their children), but if its properties have relevant
 * information (for example, a resource id called {@code credentials}, it should return
 * {@code true}. On the other hand, views representing labels or editable fields should
 * typically return {@code true}, but in some cases they could return {@code false}
 * (for example, if they're part of a ""Captcha"" mechanism).
 *
 * <p>The value returned by this method depends on the value returned by
 * {@link #getImportantForAutofill()}:
 *
 * <ol>
 * <li>if it returns {@link #IMPORTANT_FOR_AUTOFILL_YES} or
 * {@link #IMPORTANT_FOR_AUTOFILL_YES_EXCLUDE_DESCENDANTS}, then it returns {@code true}
 * <li>if it returns {@link #IMPORTANT_FOR_AUTOFILL_NO} or
 * {@link #IMPORTANT_FOR_AUTOFILL_NO_EXCLUDE_DESCENDANTS}, then it returns {@code false}
 * <li>if it returns {@link #IMPORTANT_FOR_AUTOFILL_AUTO}, then it uses some simple heuristics
 * that can return {@code true} in some cases (like a container with a resource id),
 * but {@code false} in most.
 * <li>otherwise, it returns {@code false}.
 * </ol>
 *
 * <p>When a view is considered important for autofill:
 * <ul>
 * <li>The view might automatically trigger an autofill request when focused on.
 * <li>The contents of the view are included in the {@link ViewStructure} used in an autofill
 * request.
 * </ul>
 *
 * <p>On the other hand, when a view is considered not important for autofill:
 * <ul>
 * <li>The view never automatically triggers autofill requests, but it can trigger a manual
 * request through {@link AutofillManager#requestAutofill(View)}.
 * <li>The contents of the view are not included in the {@link ViewStructure} used in an
 * autofill request, unless the request has the
 * {@link #AUTOFILL_FLAG_INCLUDE_NOT_IMPORTANT_VIEWS} flag.
 * </ul>
 *
 * @return whether the view is considered important for autofill.
 *
 * @see #setImportantForAutofill(int)
 * @see #IMPORTANT_FOR_AUTOFILL_AUTO
 * @see #IMPORTANT_FOR_AUTOFILL_YES
 * @see #IMPORTANT_FOR_AUTOFILL_NO
 * @see #IMPORTANT_FOR_AUTOFILL_YES_EXCLUDE_DESCENDANTS
 * @see #IMPORTANT_FOR_AUTOFILL_NO_EXCLUDE_DESCENDANTS
 * @see AutofillManager#requestAutofill(View)
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3",1,"The late implementation has added a new if-statement (`if (getAutofillHints() != null)`) with a return statement (`return true;`), which is a control dependency change (type 3) and a change in the return statement (type 1).","The addition of a new if-statement that returns true based on a different condition (`getAutofillHints() != null`) could lead to a different return value; hence, there is a Compatibility Issue due to potentially different return values (type 1)."
274,<android.bluetooth.BluetoothAdapter: boolean startDiscovery()>,27,28,<android.bluetooth.BluetoothAdapter: boolean startDiscovery()>,<android.bluetooth.BluetoothAdapter: boolean startDiscovery()>,0,"{
    if (getState() != STATE_ON)
        return false;
    try {
        mServiceLock.readLock().lock();
        if (mService != null)
            return mService.startDiscovery();
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
    } finally {
        mServiceLock.readLock().unlock();
    }
    return false;
}","{
    if (getState() != STATE_ON) {
        return false;
    }
    try {
        mServiceLock.readLock().lock();
        if (mService != null) {
            return mService.startDiscovery();
        }
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
    } finally {
        mServiceLock.readLock().unlock();
    }
    return false;
}",1,"/**
 * Start the remote device discovery process.
 * <p>The discovery process usually involves an inquiry scan of about 12
 * seconds, followed by a page scan of each new device to retrieve its
 * Bluetooth name.
 * <p>This is an asynchronous call, it will return immediately. Register
 * for {@link #ACTION_DISCOVERY_STARTED} and {@link
 * #ACTION_DISCOVERY_FINISHED} intents to determine exactly when the
 * discovery starts and completes. Register for {@link
 * BluetoothDevice#ACTION_FOUND} to be notified as remote Bluetooth devices
 * are found.
 * <p>Device discovery is a heavyweight procedure. New connections to
 * remote Bluetooth devices should not be attempted while discovery is in
 * progress, and existing connections will experience limited bandwidth
 * and high latency. Use {@link #cancelDiscovery()} to cancel an ongoing
 * discovery. Discovery is not managed by the Activity,
 * but is run as a system service, so an application should always call
 * {@link BluetoothAdapter#cancelDiscovery()} even if it
 * did not directly request a discovery, just to be sure.
 * <p>Device discovery will only find remote devices that are currently
 * <i>discoverable</i> (inquiry scan enabled). Many Bluetooth devices are
 * not discoverable by default, and need to be entered into a special mode.
 * <p>If Bluetooth state is not {@link #STATE_ON}, this API
 * will return false. After turning on Bluetooth,
 * wait for {@link #ACTION_STATE_CHANGED} with {@link #STATE_ON}
 * to get the updated value.
 *
 * @return true on success, false on error
 */
","/**
 * Start the remote device discovery process.
 * <p>The discovery process usually involves an inquiry scan of about 12
 * seconds, followed by a page scan of each new device to retrieve its
 * Bluetooth name.
 * <p>This is an asynchronous call, it will return immediately. Register
 * for {@link #ACTION_DISCOVERY_STARTED} and {@link
 * #ACTION_DISCOVERY_FINISHED} intents to determine exactly when the
 * discovery starts and completes. Register for {@link
 * BluetoothDevice#ACTION_FOUND} to be notified as remote Bluetooth devices
 * are found.
 * <p>Device discovery is a heavyweight procedure. New connections to
 * remote Bluetooth devices should not be attempted while discovery is in
 * progress, and existing connections will experience limited bandwidth
 * and high latency. Use {@link #cancelDiscovery()} to cancel an ongoing
 * discovery. Discovery is not managed by the Activity,
 * but is run as a system service, so an application should always call
 * {@link BluetoothAdapter#cancelDiscovery()} even if it
 * did not directly request a discovery, just to be sure.
 * <p>Device discovery will only find remote devices that are currently
 * <i>discoverable</i> (inquiry scan enabled). Many Bluetooth devices are
 * not discoverable by default, and need to be entered into a special mode.
 * <p>If Bluetooth state is not {@link #STATE_ON}, this API
 * will return false. After turning on Bluetooth,
 * wait for {@link #ACTION_STATE_CHANGED} with {@link #STATE_ON}
 * to get the updated value.
 *
 * @return true on success, false on error
 */
",-1,[@RequiresPermission(Manifest.permission.BLUETOOTH_ADMIN)],[@RequiresPermission(Manifest.permission.BLUETOOTH_ADMIN)],-1,-1,-1,-1,-1,-1,0,0,There are no changes in the implementation code; the only modification is in code formatting (inserting braces for the if statement). This does not affect the behavior or logic of the code.,"Since no actual code changes have been made between the two versions, just formatting improvements, there will be no change in behavior. Thus, there is no Compatibility Issue between the versions."
275,<android.os.StrictMode.AndroidBlockGuardPolicy: void handleViolationWithTimingAttempt(ViolationInfo)>,27,28,<android.os.StrictMode.AndroidBlockGuardPolicy: void handleViolationWithTimingAttempt(ViolationInfo)>,<android.os.StrictMode.AndroidBlockGuardPolicy: void handleViolationWithTimingAttempt(ViolationInfo)>,0,"{
    Looper looper = Looper.myLooper();
    // go into this immediate mode?
    if (looper == null || (info.policy & THREAD_PENALTY_MASK) == PENALTY_DEATH) {
        // unknown (redundant, already set)
        info.durationMillis = -1;
        handleViolation(info);
        return;
    }
    final ArrayList<ViolationInfo> records = violationsBeingTimed.get();
    if (records.size() >= MAX_OFFENSES_PER_LOOP) {
        // Not worth measuring.  Too many offenses in one loop.
        return;
    }
    records.add(info);
    if (records.size() > 1) {
        // at the end of this Looper's loop.
        return;
    }
    final IWindowManager windowManager = (info.policy & PENALTY_FLASH) != 0 ? sWindowManager.get() : null;
    if (windowManager != null) {
        try {
            windowManager.showStrictModeViolation(true);
        } catch (RemoteException unused) {
        }
    }
    // We post a runnable to a Handler (== delay 0 ms) for
    // measuring the end time of a violation instead of using
    // an IdleHandler (as was previously used) because an
    // IdleHandler may not run for quite a long period of time
    // if an ongoing animation is happening and continually
    // posting ASAP (0 ms) animation steps.  Animations are
    // throttled back to 60fps via SurfaceFlinger/View
    // invalidates, _not_ by posting frame updates every 16
    // milliseconds.
    threadHandler.get().postAtFrontOfQueue(new Runnable() {

        public void run() {
            long loopFinishTime = SystemClock.uptimeMillis();
            // to keep the red border on.
            if (windowManager != null) {
                try {
                    windowManager.showStrictModeViolation(false);
                } catch (RemoteException unused) {
                }
            }
            for (int n = 0; n < records.size(); ++n) {
                ViolationInfo v = records.get(n);
                v.violationNumThisLoop = n + 1;
                v.durationMillis = (int) (loopFinishTime - v.violationUptimeMillis);
                handleViolation(v);
            }
            records.clear();
        }
    });
}","{
    Looper looper = Looper.myLooper();
    // go into this immediate mode?
    if (looper == null || (info.mPolicy & THREAD_PENALTY_MASK) == PENALTY_DEATH) {
        // unknown (redundant, already set)
        info.durationMillis = -1;
        onThreadPolicyViolation(info);
        return;
    }
    final ArrayList<ViolationInfo> records = violationsBeingTimed.get();
    if (records.size() >= MAX_OFFENSES_PER_LOOP) {
        // Not worth measuring.  Too many offenses in one loop.
        return;
    }
    records.add(info);
    if (records.size() > 1) {
        // at the end of this Looper's loop.
        return;
    }
    final IWindowManager windowManager = info.penaltyEnabled(PENALTY_FLASH) ? sWindowManager.get() : null;
    if (windowManager != null) {
        try {
            windowManager.showStrictModeViolation(true);
        } catch (RemoteException unused) {
        }
    }
    // We post a runnable to a Handler (== delay 0 ms) for
    // measuring the end time of a violation instead of using
    // an IdleHandler (as was previously used) because an
    // IdleHandler may not run for quite a long period of time
    // if an ongoing animation is happening and continually
    // posting ASAP (0 ms) animation steps.  Animations are
    // throttled back to 60fps via SurfaceFlinger/View
    // invalidates, _not_ by posting frame updates every 16
    // milliseconds.
    THREAD_HANDLER.get().postAtFrontOfQueue(() -> {
        long loopFinishTime = SystemClock.uptimeMillis();
        // to keep the red border on.
        if (windowManager != null) {
            try {
                windowManager.showStrictModeViolation(false);
            } catch (RemoteException unused) {
            }
        }
        for (int n = 0; n < records.size(); ++n) {
            ViolationInfo v = records.get(n);
            v.violationNumThisLoop = n + 1;
            v.durationMillis = (int) (loopFinishTime - v.violationUptimeMillis);
            onThreadPolicyViolation(v);
        }
        records.clear();
    });
}",1,"// the next epoll_wait)
","// the next epoll_wait)
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"The code change includes modifications in the way a member of the `info` object is accessed (`info.policy` changed to `info.mPolicy`) and an alteration in the method called from `handleViolation(info)` to `onThreadPolicyViolation(info)`. Also, a conditional check `(info.policy & PENALTY_FLASH) != 0` has been changed to a method call `info.penaltyEnabled(PENALTY_FLASH)`. In the Runnable, a lambda expression is used in the late version instead of an anonymous class. Lastly, a variable `threadHandler` has been changed to `THREAD_HANDLER`. This involves changes in other statements but not any control structures, return expressions, or exception handling. Therefore, the change type is 4,5 due to the method call change and a change in the case of a constant.","No Compatibility Issue arises because the changes in question do not affect the return value or exception handling behavior of the method. The method's contract seems to remain the same, despite the internal refactoring and renaming of variables and methods. The changes within the method do not lead to an altered API contract and therefore should not cause different behaviors from an API consumer standpoint. The renaming of variables and methods would not be visible outside of this method's scope. Thus, we conclude that there is no Compatibility Issue."
276,"<android.transition.Visibility: Animator onDisappear(ViewGroup,TransitionValues,int,TransitionValues,int)>",27,28,"<android.transition.Visibility: Animator onDisappear(ViewGroup,TransitionValues,int,TransitionValues,int)>","<android.transition.Visibility: Animator onDisappear(ViewGroup,TransitionValues,int,TransitionValues,int)>",0,"{
    if ((mMode & MODE_OUT) != MODE_OUT) {
        return null;
    }
    View startView = (startValues != null) ? startValues.view : null;
    View endView = (endValues != null) ? endValues.view : null;
    View overlayView = null;
    View viewToKeep = null;
    if (endView == null || endView.getParent() == null) {
        if (endView != null) {
            // endView was removed from its parent - add it to the overlay
            overlayView = endView;
        } else if (startView != null) {
            // it being removed from its current parent
            if (startView.getParent() == null) {
                // no parent - safe to use
                overlayView = startView;
            } else if (startView.getParent() instanceof View) {
                View startParent = (View) startView.getParent();
                TransitionValues startParentValues = getTransitionValues(startParent, true);
                TransitionValues endParentValues = getMatchedTransitionValues(startParent, true);
                VisibilityInfo parentVisibilityInfo = getVisibilityChangeInfo(startParentValues, endParentValues);
                if (!parentVisibilityInfo.visibilityChange) {
                    overlayView = TransitionUtils.copyViewImage(sceneRoot, startView, startParent);
                } else if (startParent.getParent() == null) {
                    int id = startParent.getId();
                    if (id != View.NO_ID && sceneRoot.findViewById(id) != null && mCanRemoveViews) {
                        // no parent, but its parent is unparented  but the parent
                        // hierarchy has been replaced by a new hierarchy with the same id
                        // and it is safe to un-parent startView
                        overlayView = startView;
                    }
                }
            }
        }
    } else {
        // visibility change
        if (endVisibility == View.INVISIBLE) {
            viewToKeep = endView;
        } else {
            // Becoming GONE
            if (startView == endView) {
                viewToKeep = endView;
            } else {
                overlayView = startView;
            }
        }
    }
    final int finalVisibility = endVisibility;
    final ViewGroup finalSceneRoot = sceneRoot;
    if (overlayView != null) {
        // TODO: Need to do this for general case of adding to overlay
        int[] screenLoc = (int[]) startValues.values.get(PROPNAME_SCREEN_LOCATION);
        int screenX = screenLoc[0];
        int screenY = screenLoc[1];
        int[] loc = new int[2];
        sceneRoot.getLocationOnScreen(loc);
        overlayView.offsetLeftAndRight((screenX - loc[0]) - overlayView.getLeft());
        overlayView.offsetTopAndBottom((screenY - loc[1]) - overlayView.getTop());
        sceneRoot.getOverlay().add(overlayView);
        Animator animator = onDisappear(sceneRoot, overlayView, startValues, endValues);
        if (animator == null) {
            sceneRoot.getOverlay().remove(overlayView);
        } else {
            final View finalOverlayView = overlayView;
            addListener(new TransitionListenerAdapter() {

                @Override
                public void onTransitionEnd(Transition transition) {
                    finalSceneRoot.getOverlay().remove(finalOverlayView);
                    transition.removeListener(this);
                }
            });
        }
        return animator;
    }
    if (viewToKeep != null) {
        int originalVisibility = viewToKeep.getVisibility();
        viewToKeep.setTransitionVisibility(View.VISIBLE);
        Animator animator = onDisappear(sceneRoot, viewToKeep, startValues, endValues);
        if (animator != null) {
            DisappearListener disappearListener = new DisappearListener(viewToKeep, finalVisibility, mSuppressLayout);
            animator.addListener(disappearListener);
            animator.addPauseListener(disappearListener);
            addListener(disappearListener);
        } else {
            viewToKeep.setTransitionVisibility(originalVisibility);
        }
        return animator;
    }
    return null;
}","{
    if ((mMode & MODE_OUT) != MODE_OUT) {
        return null;
    }
    View startView = (startValues != null) ? startValues.view : null;
    View endView = (endValues != null) ? endValues.view : null;
    View overlayView = null;
    View viewToKeep = null;
    if (endView == null || endView.getParent() == null) {
        if (endView != null) {
            // endView was removed from its parent - add it to the overlay
            overlayView = endView;
        } else if (startView != null) {
            // it being removed from its current parent
            if (startView.getParent() == null) {
                // no parent - safe to use
                overlayView = startView;
            } else if (startView.getParent() instanceof View) {
                View startParent = (View) startView.getParent();
                TransitionValues startParentValues = getTransitionValues(startParent, true);
                TransitionValues endParentValues = getMatchedTransitionValues(startParent, true);
                VisibilityInfo parentVisibilityInfo = getVisibilityChangeInfo(startParentValues, endParentValues);
                if (!parentVisibilityInfo.visibilityChange) {
                    overlayView = TransitionUtils.copyViewImage(sceneRoot, startView, startParent);
                } else if (startParent.getParent() == null) {
                    int id = startParent.getId();
                    if (id != View.NO_ID && sceneRoot.findViewById(id) != null && mCanRemoveViews) {
                        // no parent, but its parent is unparented  but the parent
                        // hierarchy has been replaced by a new hierarchy with the same id
                        // and it is safe to un-parent startView
                        overlayView = startView;
                    }
                }
            }
        }
    } else {
        // visibility change
        if (endVisibility == View.INVISIBLE) {
            viewToKeep = endView;
        } else {
            // Becoming GONE
            if (startView == endView) {
                viewToKeep = endView;
            } else if (mCanRemoveViews) {
                overlayView = startView;
            } else {
                overlayView = TransitionUtils.copyViewImage(sceneRoot, startView, (View) startView.getParent());
            }
        }
    }
    final int finalVisibility = endVisibility;
    final ViewGroup finalSceneRoot = sceneRoot;
    if (overlayView != null) {
        // TODO: Need to do this for general case of adding to overlay
        int[] screenLoc = (int[]) startValues.values.get(PROPNAME_SCREEN_LOCATION);
        int screenX = screenLoc[0];
        int screenY = screenLoc[1];
        int[] loc = new int[2];
        sceneRoot.getLocationOnScreen(loc);
        overlayView.offsetLeftAndRight((screenX - loc[0]) - overlayView.getLeft());
        overlayView.offsetTopAndBottom((screenY - loc[1]) - overlayView.getTop());
        sceneRoot.getOverlay().add(overlayView);
        Animator animator = onDisappear(sceneRoot, overlayView, startValues, endValues);
        if (animator == null) {
            sceneRoot.getOverlay().remove(overlayView);
        } else {
            final View finalOverlayView = overlayView;
            addListener(new TransitionListenerAdapter() {

                @Override
                public void onTransitionEnd(Transition transition) {
                    finalSceneRoot.getOverlay().remove(finalOverlayView);
                    transition.removeListener(this);
                }
            });
        }
        return animator;
    }
    if (viewToKeep != null) {
        int originalVisibility = viewToKeep.getVisibility();
        viewToKeep.setTransitionVisibility(View.VISIBLE);
        Animator animator = onDisappear(sceneRoot, viewToKeep, startValues, endValues);
        if (animator != null) {
            DisappearListener disappearListener = new DisappearListener(viewToKeep, finalVisibility, mSuppressLayout);
            animator.addListener(disappearListener);
            animator.addPauseListener(disappearListener);
            addListener(disappearListener);
        } else {
            viewToKeep.setTransitionVisibility(originalVisibility);
        }
        return animator;
    }
    return null;
}",1,"/**
 * Subclasses should override this method or
 * {@link #onDisappear(ViewGroup, View, TransitionValues, TransitionValues)}
 * if they need to create an Animator when targets disappear.
 * The method should only be called by the Visibility class; it is
 * not intended to be called from external classes.
 * <p>
 * The default implementation of this method attempts to find a View to use to call
 * {@link #onDisappear(ViewGroup, View, TransitionValues, TransitionValues)},
 * based on the situation of the View in the View hierarchy. For example,
 * if a View was simply removed from its parent, then the View will be added
 * into a {@link android.view.ViewGroupOverlay} and passed as the <code>view</code>
 * parameter in {@link #onDisappear(ViewGroup, View, TransitionValues, TransitionValues)}.
 * If a visible View is changed to be {@link View#GONE} or {@link View#INVISIBLE},
 * then it can be used as the <code>view</code> and the visibility will be changed
 * to {@link View#VISIBLE} for the duration of the animation. However, if a View
 * is in a hierarchy which is also altering its visibility, the situation can be
 * more complicated. In general, if a view that is no longer in the hierarchy in
 * the end scene still has a parent (so its parent hierarchy was removed, but it
 * was not removed from its parent), then it will be left alone to avoid side-effects from
 * improperly removing it from its parent. The only exception to this is if
 * the previous {@link Scene} was {@link Scene#getSceneForLayout(ViewGroup, int,
 * android.content.Context) created from a layout resource file}, then it is considered
 * safe to un-parent the starting scene view in order to make it disappear.</p>
 *
 * @param sceneRoot The root of the transition hierarchy
 * @param startValues The target values in the start scene
 * @param startVisibility The target visibility in the start scene
 * @param endValues The target values in the end scene
 * @param endVisibility The target visibility in the end scene
 * @return An Animator to be started at the appropriate time in the
 * overall transition for this scene change. A null value means no animation
 * should be run.
 */
","/**
 * Subclasses should override this method or
 * {@link #onDisappear(ViewGroup, View, TransitionValues, TransitionValues)}
 * if they need to create an Animator when targets disappear.
 * The method should only be called by the Visibility class; it is
 * not intended to be called from external classes.
 * <p>
 * The default implementation of this method attempts to find a View to use to call
 * {@link #onDisappear(ViewGroup, View, TransitionValues, TransitionValues)},
 * based on the situation of the View in the View hierarchy. For example,
 * if a View was simply removed from its parent, then the View will be added
 * into a {@link android.view.ViewGroupOverlay} and passed as the <code>view</code>
 * parameter in {@link #onDisappear(ViewGroup, View, TransitionValues, TransitionValues)}.
 * If a visible View is changed to be {@link View#GONE} or {@link View#INVISIBLE},
 * then it can be used as the <code>view</code> and the visibility will be changed
 * to {@link View#VISIBLE} for the duration of the animation. However, if a View
 * is in a hierarchy which is also altering its visibility, the situation can be
 * more complicated. In general, if a view that is no longer in the hierarchy in
 * the end scene still has a parent (so its parent hierarchy was removed, but it
 * was not removed from its parent), then it will be left alone to avoid side-effects from
 * improperly removing it from its parent. The only exception to this is if
 * the previous {@link Scene} was {@link Scene#getSceneForLayout(ViewGroup, int,
 * android.content.Context) created from a layout resource file}, then it is considered
 * safe to un-parent the starting scene view in order to make it disappear.</p>
 *
 * @param sceneRoot The root of the transition hierarchy
 * @param startValues The target values in the start scene
 * @param startVisibility The target visibility in the start scene
 * @param endValues The target values in the end scene
 * @param endVisibility The target visibility in the end scene
 * @return An Animator to be started at the appropriate time in the
 * overall transition for this scene change. A null value means no animation
 * should be run.
 */
",-1,,,-1,-1,-1,-1,-1,-1,,,,
277,<android.bluetooth.le.AdvertisingSetParameters: boolean isScannable()>,27,28,<android.bluetooth.le.AdvertisingSetParameters: boolean isScannable()>,<android.bluetooth.le.AdvertisingSetParameters: boolean isScannable()>,0,"{
    return scannable;
}","{
    return mScannable;
}",1,"/**
 * Returns whether the advertisement will be scannable.
 */
","/**
 * Returns whether the advertisement will be scannable.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The change from 'return scannable;' to 'return mScannable;' indicates either a variable name change or the member field vs local variable name has changed. There is no indication that the actual behavior of the method has changed, so the code change type is 4.","No Compatibility Issue arises because there's nothing to suggest that the value of 'scannable' and 'mScannable' would be different. The method still returns a boolean indicating if the advertising set is scannable. Hence, there's no change in the return value or type and no change in exception handling. The CI type is 0."
278,<android.bluetooth.BluetoothSocket: void connect()>,27,28,<android.bluetooth.BluetoothSocket: void connect()>,<android.bluetooth.BluetoothSocket: void connect()>,0,"{
    if (mDevice == null)
        throw new IOException(""Connect is called on null device"");
    try {
        if (mSocketState == SocketState.CLOSED)
            throw new IOException(""socket closed"");
        IBluetooth bluetoothProxy = BluetoothAdapter.getDefaultAdapter().getBluetoothService(null);
        if (bluetoothProxy == null)
            throw new IOException(""Bluetooth is off"");
        mPfd = bluetoothProxy.connectSocket(mDevice, mType, mUuid, mPort, getSecurityFlags());
        synchronized (this) {
            if (DBG)
                Log.d(TAG, ""connect(), SocketState: "" + mSocketState + "", mPfd: "" + mPfd);
            if (mSocketState == SocketState.CLOSED)
                throw new IOException(""socket closed"");
            if (mPfd == null)
                throw new IOException(""bt socket connect failed"");
            FileDescriptor fd = mPfd.getFileDescriptor();
            mSocket = LocalSocket.createConnectedLocalSocket(fd);
            mSocketIS = mSocket.getInputStream();
            mSocketOS = mSocket.getOutputStream();
        }
        int channel = readInt(mSocketIS);
        if (channel <= 0)
            throw new IOException(""bt socket connect failed"");
        mPort = channel;
        waitSocketSignal(mSocketIS);
        synchronized (this) {
            if (mSocketState == SocketState.CLOSED)
                throw new IOException(""bt socket closed"");
            mSocketState = SocketState.CONNECTED;
        }
    } catch (RemoteException e) {
        Log.e(TAG, Log.getStackTraceString(new Throwable()));
        throw new IOException(""unable to send RPC: "" + e.getMessage());
    }
}","{
    if (mDevice == null)
        throw new IOException(""Connect is called on null device"");
    try {
        if (mSocketState == SocketState.CLOSED)
            throw new IOException(""socket closed"");
        IBluetooth bluetoothProxy = BluetoothAdapter.getDefaultAdapter().getBluetoothService(null);
        if (bluetoothProxy == null)
            throw new IOException(""Bluetooth is off"");
        mPfd = bluetoothProxy.getSocketManager().connectSocket(mDevice, mType, mUuid, mPort, getSecurityFlags());
        synchronized (this) {
            if (DBG)
                Log.d(TAG, ""connect(), SocketState: "" + mSocketState + "", mPfd: "" + mPfd);
            if (mSocketState == SocketState.CLOSED)
                throw new IOException(""socket closed"");
            if (mPfd == null)
                throw new IOException(""bt socket connect failed"");
            FileDescriptor fd = mPfd.getFileDescriptor();
            mSocket = LocalSocket.createConnectedLocalSocket(fd);
            mSocketIS = mSocket.getInputStream();
            mSocketOS = mSocket.getOutputStream();
        }
        int channel = readInt(mSocketIS);
        if (channel <= 0) {
            throw new IOException(""bt socket connect failed"");
        }
        mPort = channel;
        waitSocketSignal(mSocketIS);
        synchronized (this) {
            if (mSocketState == SocketState.CLOSED) {
                throw new IOException(""bt socket closed"");
            }
            mSocketState = SocketState.CONNECTED;
        }
    } catch (RemoteException e) {
        Log.e(TAG, Log.getStackTraceString(new Throwable()));
        throw new IOException(""unable to send RPC: "" + e.getMessage());
    }
}",1,"/**
 * Attempt to connect to a remote device.
 * <p>This method will block until a connection is made or the connection
 * fails. If this method returns without an exception then this socket
 * is now connected.
 * <p>Creating new connections to
 * remote Bluetooth devices should not be attempted while device discovery
 * is in progress. Device discovery is a heavyweight procedure on the
 * Bluetooth adapter and will significantly slow a device connection.
 * Use {@link BluetoothAdapter#cancelDiscovery()} to cancel an ongoing
 * discovery. Discovery is not managed by the Activity,
 * but is run as a system service, so an application should always call
 * {@link BluetoothAdapter#cancelDiscovery()} even if it
 * did not directly request a discovery, just to be sure.
 * <p>{@link #close} can be used to abort this call from another thread.
 * @throws IOException on error, for example connection failure
 */
","/**
 * Attempt to connect to a remote device.
 * <p>This method will block until a connection is made or the connection
 * fails. If this method returns without an exception then this socket
 * is now connected.
 * <p>Creating new connections to
 * remote Bluetooth devices should not be attempted while device discovery
 * is in progress. Device discovery is a heavyweight procedure on the
 * Bluetooth adapter and will significantly slow a device connection.
 * Use {@link BluetoothAdapter#cancelDiscovery()} to cancel an ongoing
 * discovery. Discovery is not managed by the Activity,
 * but is run as a system service, so an application should always call
 * {@link BluetoothAdapter#cancelDiscovery()} even if it
 * did not directly request a discovery, just to be sure.
 * <p>{@link #close} can be used to abort this call from another thread.
 *
 * @throws IOException on error, for example connection failure
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"The dependent API call has changed from bluetoothProxy.connectSocket to bluetoothProxy.getSocketManager().connectSocket, which means there is a change in the dependent API. Additionally, there is a stylistic change in the addition of braces for the if-condition (if (channel <= 0) {...}). This does not change the control flow or the behaviour of the program. Therefore, the change types are 4 (for the stylistic change) and 5 (for the dependent API change).","There is no change to the logic of the code and exception handling. The use of braces for a single statement in an if-condition does not affect the return values or exception handling of the method. Similarly, calling connectSocket on bluetoothProxy which was previously being called directly or on the returned object from getSocketManager does not necessarily change the behavior of connect unless the implementation of connectSocket has changed in a way that affects the method's outcome. Since there is no information on the implementation changes of connectSocket, we don't regard it as a compatibility issue based on the given code. Therefore, there is no compatibility issue detected."
279,<android.bluetooth.BluetoothAdapter: boolean isLeCodedPhySupported()>,27,28,<android.bluetooth.BluetoothAdapter: boolean isLeCodedPhySupported()>,<android.bluetooth.BluetoothAdapter: boolean isLeCodedPhySupported()>,0,"{
    if (!getLeAccess())
        return false;
    try {
        mServiceLock.readLock().lock();
        if (mService != null)
            return mService.isLeCodedPhySupported();
    } catch (RemoteException e) {
        Log.e(TAG, ""failed to get isLeCodedPhySupported, error: "", e);
    } finally {
        mServiceLock.readLock().unlock();
    }
    return false;
}","{
    if (!getLeAccess()) {
        return false;
    }
    try {
        mServiceLock.readLock().lock();
        if (mService != null) {
            return mService.isLeCodedPhySupported();
        }
    } catch (RemoteException e) {
        Log.e(TAG, ""failed to get isLeCodedPhySupported, error: "", e);
    } finally {
        mServiceLock.readLock().unlock();
    }
    return false;
}",1,"/**
 * Return true if LE Coded PHY feature is supported.
 *
 * @return true if chipset supports LE Coded PHY feature
 */
","/**
 * Return true if LE Coded PHY feature is supported.
 *
 * @return true if chipset supports LE Coded PHY feature
 */
",-1,,,-1,-1,-1,-1,-1,-1,0,0,"The only differences between the early and late version implementations are code formatting changes (placement of braces). The actual logic, conditional checks, and return values of the method have not changed.","Since there are no changes to the logic, return values, or exception handling in the method, there is no compatibility issue between the two versions."
280,"<android.widget.RemoteViews.ReflectionAction: void apply(View,ViewGroup,OnClickHandler)>",27,28,"<android.widget.RemoteViews.ReflectionAction: void apply(View,ViewGroup,OnClickHandler)>","<android.widget.RemoteViews.ReflectionAction: void apply(View,ViewGroup,OnClickHandler)>",0,"{
    final View view = root.findViewById(viewId);
    if (view == null)
        return;
    Class<?> param = getParameterType();
    if (param == null) {
        throw new ActionException(""bad type: "" + this.type);
    }
    try {
        getMethod(view, this.methodName, param).invoke(view, wrapArg(this.value));
    } catch (ActionException e) {
        throw e;
    } catch (Exception ex) {
        throw new ActionException(ex);
    }
}","{
    final View view = root.findViewById(viewId);
    if (view == null)
        return;
    Class<?> param = getParameterType();
    if (param == null) {
        throw new ActionException(""bad type: "" + this.type);
    }
    try {
        getMethod(view, this.methodName, param, false).invoke(view, this.value);
    } catch (Throwable ex) {
        throw new ActionException(ex);
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,5,1,The `getMethod` function is called with different parameters and the parameter to the `invoke` method has changed suggesting a change in the method signature or processing which constitutes a dependent API change (5).,"The change in the method signature potentially leads to a different method being invoked or the method being invoked with different parameters and hence potentially leads to a different return value or behaviour. Therefore, the Compatibility Issue type is 1."
281,<android.hardware.radio.TunerCallbackAdapter: void onCurrentProgramInfoChanged(ProgramInfo)>,27,28,<android.hardware.radio.TunerCallbackAdapter: void onCurrentProgramInfoChanged(ProgramInfo)>,<android.hardware.radio.TunerCallbackAdapter: void onCurrentProgramInfoChanged(ProgramInfo)>,0,"{
    if (info == null) {
        Log.e(TAG, ""ProgramInfo must not be null"");
        return;
    }
    mHandler.post(() -> {
        mCallback.onProgramInfoChanged(info);
        RadioMetadata metadata = info.getMetadata();
        if (metadata != null)
            mCallback.onMetadataChanged(metadata);
    });
}","{
    if (info == null) {
        Log.e(TAG, ""ProgramInfo must not be null"");
        return;
    }
    synchronized (mLock) {
        mCurrentProgramInfo = info;
    }
    mHandler.post(() -> {
        mCallback.onProgramInfoChanged(info);
        RadioMetadata metadata = info.getMetadata();
        if (metadata != null)
            mCallback.onMetadataChanged(metadata);
    });
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,4",0,"A new 'synchronized' block is introduced which assigns 'info' to 'mCurrentProgramInfo', and the method signature and internal logic of how the callbacks are invoked remain unchanged, so the changes are classified as 3 (Control dependency changed) due to the new synchronization context, and 4 (Other statement changed) due to the assignment operation.","Despite the added 'synchronized' block and the new assignment statement, there is no change in the method's return type, return value, or the exceptions it may throw. Therefore, no Compatibility Issue arises from these changes."
283,<android.app.admin.DnsEvent: String toString()>,27,28,<android.app.admin.DnsEvent: String toString()>,<android.app.admin.DnsEvent: String toString()>,0,"{
    return String.format(""DnsEvent(%s, %s, %d, %d, %s)"", hostname, (ipAddresses == null) ? ""NONE"" : String.join("" "", ipAddresses), ipAddressesCount, timestamp, packageName);
}","{
    return String.format(""DnsEvent(%d, %s, %s, %d, %d, %s)"", mId, mHostname, (mIpAddresses == null) ? ""NONE"" : String.join("" "", mIpAddresses), mIpAddressesCount, mTimestamp, mPackageName);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,1,1,"The format of the string returned by the `toString()` method has changed between versions, including the addition of `mId` and renaming of fields from un-prefixed to prefixed with `m`, resulting in a different return value. Therefore, the code change type is 1.","The change in the return format of the `toString()` method will cause a different string to be returned when the method is called, leading to a different behavior of the API. The CI type is 1, indicating a potential different return value."
285,"<android.provider.BlockedNumberContract: boolean isBlocked(Context,String)>",27,28,"<android.provider.BlockedNumberContract: boolean isBlocked(Context,String)>","<android.provider.BlockedNumberContract: boolean isBlocked(Context,String)>",0,"{
    final Bundle res = context.getContentResolver().call(AUTHORITY_URI, METHOD_IS_BLOCKED, phoneNumber, null);
    return res != null && res.getBoolean(RES_NUMBER_IS_BLOCKED, false);
}","{
    try {
        final Bundle res = context.getContentResolver().call(AUTHORITY_URI, METHOD_IS_BLOCKED, phoneNumber, null);
        return res != null && res.getBoolean(RES_NUMBER_IS_BLOCKED, false);
    } catch (NullPointerException | IllegalArgumentException ex) {
        // The content resolver can throw an NPE or IAE; we don't want to crash Telecom if
        // either of these happen.
        Log.w(null, ""isBlocked: provider not ready."");
        return false;
    }
}",1,"/**
 * Returns whether a given number is in the blocked list.
 *
 * <p> This matches the {@code phoneNumber} against the
 * {@link BlockedNumbers#COLUMN_ORIGINAL_NUMBER} column, and the E164 representation of the
 * {@code phoneNumber} with the {@link BlockedNumbers#COLUMN_E164_NUMBER} column.
 *
 * <p> Note that if the {@link #canCurrentUserBlockNumbers} is {@code false} for the user
 * context {@code context}, this method will throw a {@link SecurityException}.
 *
 * @return {@code true} if the {@code phoneNumber} is blocked.
 */
","/**
 * Returns whether a given number is in the blocked list.
 *
 * <p> This matches the {@code phoneNumber} against the
 * {@link BlockedNumbers#COLUMN_ORIGINAL_NUMBER} column, and the E164 representation of the
 * {@code phoneNumber} with the {@link BlockedNumbers#COLUMN_E164_NUMBER} column.
 *
 * <p> Note that if the {@link #canCurrentUserBlockNumbers} is {@code false} for the user
 * context {@code context}, this method will throw a {@link SecurityException}.
 *
 * @return {@code true} if the {@code phoneNumber} is blocked.
 */
",-1,[@WorkerThread],[@WorkerThread],-1,-1,-1,-1,-1,-1,"2,3",2,"Exception handling statement is introduced, and a try-catch block has been added around the existing code, so the code change types are 2 and 3.","A catch block for handling NullPointerException and IllegalArgumentException has been added that logs a warning and returns false. This means that instead of potentially crashing the application due to an uncaught exception, it will now handle these exceptions and return false. Thus, the behavior of the API has changed in how exceptions are dealt with, which can lead to a Compatibility Issue of type 2."
287,<android.os.Parcel: T[] createTypedArray(Creator<T>)>,27,28,<android.os.Parcel: T[] createTypedArray(Creator<T>)>,<android.os.Parcel: T[] createTypedArray(Creator<T>)>,0,"{
    int N = readInt();
    if (N < 0) {
        return null;
    }
    T[] l = c.newArray(N);
    for (int i = 0; i < N; i++) {
        if (readInt() != 0) {
            l[i] = c.createFromParcel(this);
        }
    }
    return l;
}","{
    int N = readInt();
    if (N < 0) {
        return null;
    }
    T[] l = c.newArray(N);
    for (int i = 0; i < N; i++) {
        l[i] = readTypedObject(c);
    }
    return l;
}",1,"/**
 * Read and return a new array containing a particular object type from
 * the parcel at the current dataPosition().  Returns null if the
 * previously written array was null.  The array <em>must</em> have
 * previously been written via {@link #writeTypedArray} with the same
 * object type.
 *
 * @return A newly created array containing objects with the same data
 * as those that were previously written.
 *
 * @see #writeTypedArray
 */
","/**
 * Read and return a new array containing a particular object type from
 * the parcel at the current dataPosition().  Returns null if the
 * previously written array was null.  The array <em>must</em> have
 * previously been written via {@link #writeTypedArray} with the same
 * object type.
 *
 * @return A newly created array containing objects with the same data
 * as those that were previously written.
 *
 * @see #writeTypedArray
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",0,"The line within the for-loop has been changed from manually checking if the parcelable exists and then reading it, to using the readTypedObject method. This indicates a change in the dependent API as the implementation now relies on readTypedObject method instead of readInt followed by c.createFromParcel(this). Therefore, the code change type is 1,5.","There is no compatibility issue detected based on the change made because both the old and new implementations are designed to achieve the same goal, which is to read an array of typed objects from the Parcel. The newer implementation is using an abstraction of the previous logic, which unless there's a behavioral change in how readTypedObject works compared to the manual in-line code it replaces, should not introduce a compatibility issue. Hence, the CI type is 0."
288,<android.bluetooth.BluetoothDevice: String getName()>,27,28,<android.bluetooth.BluetoothDevice: String getName()>,<android.bluetooth.BluetoothDevice: String getName()>,0,"{
    final IBluetooth service = sService;
    if (service == null) {
        Log.e(TAG, ""BT not enabled. Cannot get Remote Device name"");
        return null;
    }
    try {
        return service.getRemoteName(this);
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
    }
    return null;
}","{
    final IBluetooth service = sService;
    if (service == null) {
        Log.e(TAG, ""BT not enabled. Cannot get Remote Device name"");
        return null;
    }
    try {
        String name = service.getRemoteName(this);
        if (name != null) {
            return name.replaceAll(""[\\t\\n\\r]+"", "" "");
        }
        return null;
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
    }
    return null;
}",1,"/**
 * Get the friendly Bluetooth name of the remote device.
 *
 * <p>The local adapter will automatically retrieve remote names when
 * performing a device scan, and will cache them. This method just returns
 * the name for this device from the cache.
 *
 * @return the Bluetooth name, or null if there was a problem.
 */
","/**
 * Get the friendly Bluetooth name of the remote device.
 *
 * <p>The local adapter will automatically retrieve remote names when
 * performing a device scan, and will cache them. This method just returns
 * the name for this device from the cache.
 *
 * @return the Bluetooth name, or null if there was a problem.
 */
",-1,[@RequiresPermission(Manifest.permission.BLUETOOTH)],[@RequiresPermission(Manifest.permission.BLUETOOTH)],-1,-1,-1,-1,-1,-1,"1,3",1,"The implementation change introduces a new control statement which checks if name is not null and applies a replaceAll method to it before returning, and a new return statement is introduced inside the try block. The change type is 1 for the return statement and 3 for the control dependency change.","The added string sanitization with replaceAll introduces the potential for the late version of the API to return a different value (with whitespace characters removed) compared to the early version where no such sanitization occurs. Therefore, the Compatibility Issue type is 1."
291,<android.net.TrafficStats: long getUidTxPackets(int)>,27,28,<android.net.TrafficStats: long getUidTxPackets(int)>,<android.net.TrafficStats: long getUidTxPackets(int)>,0,"{
    // This isn't actually enforcing any security; it just returns the
    // unsupported value. The real filtering is done at the kernel level.
    final int callingUid = android.os.Process.myUid();
    if (callingUid == android.os.Process.SYSTEM_UID || callingUid == uid) {
        return nativeGetUidStat(uid, TYPE_TX_PACKETS);
    } else {
        return UNSUPPORTED;
    }
}","{
    // This isn't actually enforcing any security; it just returns the
    // unsupported value. The real filtering is done at the kernel level.
    final int callingUid = android.os.Process.myUid();
    if (callingUid == android.os.Process.SYSTEM_UID || callingUid == uid) {
        try {
            return getStatsService().getUidStats(uid, TYPE_TX_PACKETS);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    } else {
        return UNSUPPORTED;
    }
}",1,"/**
 * Return number of packets transmitted by the given UID since device boot.
 * Counts packets across all network interfaces, and always increases
 * monotonically since device boot. Statistics are measured at the network
 * layer, so they include both TCP and UDP usage.
 * <p>
 * Before {@link android.os.Build.VERSION_CODES#JELLY_BEAN_MR2}, this may return
 * {@link #UNSUPPORTED} on devices where statistics aren't available.
 * <p>
 * Starting in {@link android.os.Build.VERSION_CODES#N} this will only
 * report traffic statistics for the calling UID. It will return
 * {@link #UNSUPPORTED} for all other UIDs for privacy reasons. To access
 * historical network statistics belonging to other UIDs, use
 * {@link NetworkStatsManager}.
 *
 * @see android.os.Process#myUid()
 * @see android.content.pm.ApplicationInfo#uid
 */
","/**
 * Return number of packets transmitted by the given UID since device boot.
 * Counts packets across all network interfaces, and always increases
 * monotonically since device boot. Statistics are measured at the network
 * layer, so they include both TCP and UDP usage.
 * <p>
 * Before {@link android.os.Build.VERSION_CODES#JELLY_BEAN_MR2}, this may return
 * {@link #UNSUPPORTED} on devices where statistics aren't available.
 * <p>
 * Starting in {@link android.os.Build.VERSION_CODES#N} this will only
 * report traffic statistics for the calling UID. It will return
 * {@link #UNSUPPORTED} for all other UIDs for privacy reasons. To access
 * historical network statistics belonging to other UIDs, use
 * {@link NetworkStatsManager}.
 *
 * @see android.os.Process#myUid()
 * @see android.content.pm.ApplicationInfo#uid
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,2,5","1,2","The implementation has changed in the following ways: Return statement changed from returning the result of nativeGetUidStat() to obtaining the result through getStatsService().getUidStats(). Furthermore, an exception handling statement has been added for RemoteException which rethrows the exception using throw e.rethrowFromSystemServer(). Lastly, there is a change in the dependent API from nativeGetUidStat() to getStatsService().getUidStats(). Thus, the code change type is 1, 2, 5.",These changes could lead to a Compatibility Issue for the following reasons:
292,"<android.widget.SelectionActionModeHelper.SelectionMetricsLogger: void logSelectionAction(int,int,int,TextClassification)>",27,28,"<android.widget.SelectionActionModeHelper.SelectionMetricsLogger: void logSelectionAction(int,int,int,TextClassification)>","<android.widget.SelectionActionModeHelper.SelectionMetricsLogger: void logSelectionAction(int,int,int,TextClassification)>",0,"{
    try {
        Preconditions.checkArgumentInRange(start, 0, mText.length(), ""start"");
        Preconditions.checkArgumentInRange(end, start, mText.length(), ""end"");
        int[] wordIndices = getWordDelta(start, end);
        if (classification != null) {
            mDelegate.logEvent(SelectionEvent.selectionAction(wordIndices[0], wordIndices[1], action, classification));
        } else {
            mDelegate.logEvent(SelectionEvent.selectionAction(wordIndices[0], wordIndices[1], action));
        }
    } catch (Exception e) {
        // Avoid crashes due to logging.
        Log.d(LOG_TAG, e.getMessage());
    }
}","{
    try {
        if (hasActiveClassificationSession()) {
            Preconditions.checkArgumentInRange(start, 0, mText.length(), ""start"");
            Preconditions.checkArgumentInRange(end, start, mText.length(), ""end"");
            int[] wordIndices = getWordDelta(start, end);
            if (classification != null) {
                mClassificationSession.onSelectionEvent(SelectionEvent.createSelectionActionEvent(wordIndices[0], wordIndices[1], action, classification));
            } else {
                mClassificationSession.onSelectionEvent(SelectionEvent.createSelectionActionEvent(wordIndices[0], wordIndices[1], action));
            }
            if (SelectionEvent.isTerminal(action)) {
                endTextClassificationSession();
            }
        }
    } catch (Exception e) {
        // Avoid crashes due to logging.
        Log.e(LOG_TAG, """" + e.getMessage(), e);
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"2,3,5",1,"The control dependency has changed due to the introduction of a new 'if' condition (if (hasActiveClassificationSession())), a new method call with different arguments (SelectionEvent.createSelectionActionEvent(..) instead of SelectionEvent.selectionAction(..)), and a method call in a condition (if (SelectionEvent.isTerminal(action))). Also, the implementation of the exception handling has changed slightly, with a change from Log.d to Log.e. There is also the presence of a dependent API change, as the behavior and the methods of the delegate object (mDelegate vs. mClassificationSession) are used differently. So, the change type is 2,3,5.","The new control dependency on hasActiveClassificationSession() may prevent the execution of subsequent statements that were always executed before this check was added. Additionally, the dependent API calls changed, with mDelegate being replaced by mClassificationSession, and endTextClassificationSession() potentially ending the session, which was not present in the early version. These changes can potentially lead to a different return behavior (even though the method is void, it affects the side-effects and state of the system), and thus the CI type is 1 due to a potential difference in behavior introduced by these changes."
293,<android.text.style.ImageSpan: Drawable getDrawable()>,27,28,<android.text.style.ImageSpan: Drawable getDrawable()>,<android.text.style.ImageSpan: Drawable getDrawable()>,0,"{
    Drawable drawable = null;
    if (mDrawable != null) {
        drawable = mDrawable;
    } else if (mContentUri != null) {
        Bitmap bitmap = null;
        try {
            InputStream is = mContext.getContentResolver().openInputStream(mContentUri);
            bitmap = BitmapFactory.decodeStream(is);
            drawable = new BitmapDrawable(mContext.getResources(), bitmap);
            drawable.setBounds(0, 0, drawable.getIntrinsicWidth(), drawable.getIntrinsicHeight());
            is.close();
        } catch (Exception e) {
            Log.e(""sms"", ""Failed to loaded content "" + mContentUri, e);
        }
    } else {
        try {
            drawable = mContext.getDrawable(mResourceId);
            drawable.setBounds(0, 0, drawable.getIntrinsicWidth(), drawable.getIntrinsicHeight());
        } catch (Exception e) {
            Log.e(""sms"", ""Unable to find resource: "" + mResourceId);
        }
    }
    return drawable;
}","{
    Drawable drawable = null;
    if (mDrawable != null) {
        drawable = mDrawable;
    } else if (mContentUri != null) {
        Bitmap bitmap = null;
        try {
            InputStream is = mContext.getContentResolver().openInputStream(mContentUri);
            bitmap = BitmapFactory.decodeStream(is);
            drawable = new BitmapDrawable(mContext.getResources(), bitmap);
            drawable.setBounds(0, 0, drawable.getIntrinsicWidth(), drawable.getIntrinsicHeight());
            is.close();
        } catch (Exception e) {
            Log.e(""ImageSpan"", ""Failed to loaded content "" + mContentUri, e);
        }
    } else {
        try {
            drawable = mContext.getDrawable(mResourceId);
            drawable.setBounds(0, 0, drawable.getIntrinsicWidth(), drawable.getIntrinsicHeight());
        } catch (Exception e) {
            Log.e(""ImageSpan"", ""Unable to find resource: "" + mResourceId);
        }
    }
    return drawable;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"The code has changed only in the string literals within the Log.e method calls, modifying the tag from ""sms"" to ""ImageSpan"". Since this change does not affect the return value or the exception handling of the method, the code change type is 4 (Other statement changed).","There is no Compatibility Issue as the behavior of the method regarding return values or exceptions has not been altered. The change does not affect the API contract or its interaction with external code. Therefore, the CI type is 0 (No Compatibility Issue)."
294,<android.os.StrictMode.AndroidBlockGuardPolicy: void onResourceMismatch(Object)>,27,28,<android.os.StrictMode.AndroidBlockGuardPolicy: void onResourceMismatch(Object)>,<android.os.StrictMode.AndroidBlockGuardPolicy: void onResourceMismatch(Object)>,0,"{
    if ((mPolicyMask & DETECT_RESOURCE_MISMATCH) == 0) {
        return;
    }
    if (tooManyViolationsThisLoop()) {
        return;
    }
    BlockGuard.BlockGuardPolicyException e = new StrictModeResourceMismatchViolation(mPolicyMask, tag);
    e.fillInStackTrace();
    startHandlingViolationException(e);
}","{
    if ((mPolicyMask & DETECT_RESOURCE_MISMATCH) == 0) {
        return;
    }
    if (tooManyViolationsThisLoop()) {
        return;
    }
    startHandlingViolationException(new ResourceMismatchViolation(tag));
}",1,"// Not part of BlockGuard.Policy; just part of StrictMode:
","// Not part of BlockGuard.Policy; just part of StrictMode:
",-1,,,-1,-1,-1,-1,-1,-1,"1,4",1,"The instantiation of the Exception object (StrictModeResourceMismatchViolation) has been changed to a different Exception type (ResourceMismatchViolation), and the call to 'e.fillInStackTrace()' has been removed. Thus, this includes return statement changes (as a different exception might be thrown leading to different catch blocks executing) and other statement changes which include the instantiation details.","The change in the exception that is being thrown potentially leads to a different behavior since a different exception class is being instantiated and thrown. There is no longer a call to 'fillInStackTrace()' on the exception, which could affect the stack trace information available to exception handlers. Therefore, it can be classified as a CI due to a potential difference in the exception handling behavior (type 1)."
296,"<android.text.Selection: boolean moveDown(Spannable,Layout)>",27,28,"<android.text.Selection: boolean moveDown(Spannable,Layout)>","<android.text.Selection: boolean moveDown(Spannable,Layout)>",0,"{
    int start = getSelectionStart(text);
    int end = getSelectionEnd(text);
    if (start != end) {
        int min = Math.min(start, end);
        int max = Math.max(start, end);
        setSelection(text, max);
        if (min == 0 && max == text.length()) {
            return false;
        }
        return true;
    } else {
        int line = layout.getLineForOffset(end);
        if (line < layout.getLineCount() - 1) {
            int move;
            if (layout.getParagraphDirection(line) == layout.getParagraphDirection(line + 1)) {
                float h = layout.getPrimaryHorizontal(end);
                move = layout.getOffsetForHorizontal(line + 1, h);
            } else {
                move = layout.getLineStart(line + 1);
            }
            setSelection(text, move);
            return true;
        } else if (end != text.length()) {
            setSelection(text, text.length());
            return true;
        }
    }
    return false;
}","{
    int start = getSelectionStart(text);
    int end = getSelectionEnd(text);
    if (start != end) {
        int min = Math.min(start, end);
        int max = Math.max(start, end);
        setSelection(text, max);
        if (min == 0 && max == text.length()) {
            return false;
        }
        return true;
    } else {
        int line = layout.getLineForOffset(end);
        if (line < layout.getLineCount() - 1) {
            setSelectionAndMemory(text, layout, line, end, 1, /* direction */
            false);
            return true;
        } else if (end != text.length()) {
            setSelection(text, text.length());
            return true;
        }
    }
    return false;
}",1,"/**
 * Move the cursor to the buffer offset physically below the current
 * offset, to the end of the buffer if it is on the bottom line but
 * not at the end, or return false if the cursor is already at the
 * end of the buffer.
 */
","/**
 * Move the cursor to the buffer offset physically below the current
 * offset, to the end of the buffer if it is on the bottom line but
 * not at the end, or return false if the cursor is already at the
 * end of the buffer.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,5",1,"There is a control dependency change where the implementation of the if block when start does not equal end has been modified. It now calls setSelectionAndMemory() instead of the series of instructions previously there. Moreover, there is a dependent API change because the method setSelectionAndMemory() is called instead of several other operations, which indicates a reliance on another, possibly modified, API. The change type is 3,5.","The behavior of the method may be different because of the changes in the control dependency as well as the introduction of a dependent API call that could behave differently than the inlined code it replaced. Therefore, the CI type is 1."
298,<android.net.Network.NetworkBoundSocketFactory: Socket createSocket()>,27,28,<android.net.Network.NetworkBoundSocketFactory: Socket createSocket()>,<android.net.Network.NetworkBoundSocketFactory: Socket createSocket()>,0,"{
    Socket socket = new Socket();
    bindSocket(socket);
    return socket;
}","{
    Socket socket = new Socket();
    boolean failed = true;
    try {
        bindSocket(socket);
        failed = false;
    } finally {
        if (failed)
            IoUtils.closeQuietly(socket);
    }
    return socket;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,4",0,"The method now includes a new boolean variable 'failed', a try-finally block and a change in exception handling (quietly closing the socket). These represent changes in the method's internal logic and control flow (3), and the addition of a new variable and a try-finally block are other statements changed (4).","Despite these internal changes, the external behavior of the method from the caller's perspective remains the same. The method will still return a socket, and the method signature and return type haven't changed. Exceptions are handled differently internally, but from the outside, if 'bindSocket' throws an exception, it would have surfaced in the early version as well. Now it just ensures the socket is closed if 'bindSocket' throws an exception, which doesn't affect external behavior as the caller would typically have to handle the exception anyway. Thus, there is no CI for return values, types, or exceptions."
299,<android.net.IpSecManager.UdpEncapsulationSocket: void close()>,27,28,<android.net.IpSecManager.UdpEncapsulationSocket: void close()>,<android.net.IpSecManager.UdpEncapsulationSocket: void close()>,0,"{
    try {
        mService.closeUdpEncapsulationSocket(mResourceId);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
    try {
        mPfd.close();
    } catch (IOException e) {
        Log.e(TAG, ""Failed to close UDP Encapsulation Socket with Port= "" + mPort);
        throw e;
    }
    mCloseGuard.close();
}","{
    try {
        mService.closeUdpEncapsulationSocket(mResourceId);
        mResourceId = INVALID_RESOURCE_ID;
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    } catch (Exception e) {
        // On close we swallow all random exceptions since failure to close is not
        // actionable by the user.
        Log.e(TAG, ""Failed to close "" + this + "", Exception="" + e);
    } finally {
        mResourceId = INVALID_RESOURCE_ID;
        mCloseGuard.close();
    }
    try {
        mPfd.close();
    } catch (IOException e) {
        Log.e(TAG, ""Failed to close UDP Encapsulation Socket with Port= "" + mPort);
        throw e;
    }
}",1,,"/**
 * Close this socket.
 *
 * <p>This closes the wrapped socket. Open encapsulation sockets count against a user's
 * resource limits, and forgetting to close them eventually will result in {@link
 * ResourceUnavailableException} being thrown.
 */
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"2,3,4,5",2,"There's a change in exception handling by adding a new catch block for a generic Exception, changes to the control flow by adding a finally block and modification in the order of statements. Moreover, the assignment of INVALID_RESOURCE_ID to mResourceId is now done inside the try block and finally block, which modifies state, so the change types are 2, 3, 4, 5.","A new catch block for a generic Exception has been added which changes the exceptions that are caught and how they are handled. Previously, only RemoteException instances would lead to an action (rethrowing the exception). Now, any other Exception is logged and swallowed. Consequently, this is a Compatibility Issue caused by potential different exception handlings, hence the CI type is 2."
300,"<android.content.pm.LauncherApps: void startAppDetailsActivity(ComponentName,UserHandle,Rect,Bundle)>",27,28,"<android.content.pm.LauncherApps: void startAppDetailsActivity(ComponentName,UserHandle,Rect,Bundle)>","<android.content.pm.LauncherApps: void startAppDetailsActivity(ComponentName,UserHandle,Rect,Bundle)>",0,"{
    logErrorForInvalidProfileAccess(user);
    try {
        mService.showAppDetailsAsUser(mContext.getPackageName(), component, sourceBounds, opts, user);
    } catch (RemoteException re) {
        throw re.rethrowFromSystemServer();
    }
}","{
    logErrorForInvalidProfileAccess(user);
    try {
        mService.showAppDetailsAsUser(mContext.getIApplicationThread(), mContext.getPackageName(), component, sourceBounds, opts, user);
    } catch (RemoteException re) {
        throw re.rethrowFromSystemServer();
    }
}",1,"/**
 * Starts the settings activity to show the application details for a
 * package in the specified profile.
 *
 * @param component The ComponentName of the package to launch settings for.
 * @param user The UserHandle of the profile
 * @param sourceBounds The Rect containing the source bounds of the clicked icon
 * @param opts Options to pass to startActivity
 */
","/**
 * Starts the settings activity to show the application details for a
 * package in the specified profile.
 *
 * @param component The ComponentName of the package to launch settings for.
 * @param user The UserHandle of the profile
 * @param sourceBounds The Rect containing the source bounds of the clicked icon
 * @param opts Options to pass to startActivity
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The call to mService.showAppDetailsAsUser has an extra argument mContext.getIApplicationThread() in the late version. This indicates that the dependent API mService.showAppDetailsAsUser has undergone a change, thus the code change type is 5.","The change does not lead to a difference in the final behavior from the perspective of the API signature because the method still performs the same action with the same incoming parameters and has no change in return type or exception handling. Therefore, there is no compatibility issue."
302,<android.database.sqlite.SQLiteDatabase: void disableWriteAheadLogging()>,27,28,<android.database.sqlite.SQLiteDatabase: void disableWriteAheadLogging()>,<android.database.sqlite.SQLiteDatabase: void disableWriteAheadLogging()>,0,"{
    synchronized (mLock) {
        throwIfNotOpenLocked();
        if ((mConfigurationLocked.openFlags & ENABLE_WRITE_AHEAD_LOGGING) == 0) {
            return;
        }
        mConfigurationLocked.openFlags &= ~ENABLE_WRITE_AHEAD_LOGGING;
        try {
            mConnectionPoolLocked.reconfigure(mConfigurationLocked);
        } catch (RuntimeException ex) {
            mConfigurationLocked.openFlags |= ENABLE_WRITE_AHEAD_LOGGING;
            throw ex;
        }
    }
}","{
    synchronized (mLock) {
        throwIfNotOpenLocked();
        final int oldFlags = mConfigurationLocked.openFlags;
        final boolean walDisabled = (oldFlags & ENABLE_WRITE_AHEAD_LOGGING) == 0;
        final boolean compatibilityWalDisabled = (oldFlags & DISABLE_COMPATIBILITY_WAL) != 0;
        if (walDisabled && compatibilityWalDisabled) {
            return;
        }
        mConfigurationLocked.openFlags &= ~ENABLE_WRITE_AHEAD_LOGGING;
        // If an app explicitly disables WAL, compatibility mode should be disabled too
        mConfigurationLocked.openFlags |= DISABLE_COMPATIBILITY_WAL;
        try {
            mConnectionPoolLocked.reconfigure(mConfigurationLocked);
        } catch (RuntimeException ex) {
            mConfigurationLocked.openFlags = oldFlags;
            throw ex;
        }
    }
}",1,"/**
 * This method disables the features enabled by {@link #enableWriteAheadLogging()}.
 *
 * @throws IllegalStateException if there are transactions in progress at the
 * time this method is called.  WAL mode can only be changed when there are no
 * transactions in progress.
 *
 * @see #enableWriteAheadLogging
 */
","/**
 * This method disables the features enabled by {@link #enableWriteAheadLogging()}.
 *
 * @throws IllegalStateException if there are transactions in progress at the
 * time this method is called.  WAL mode can only be changed when there are no
 * transactions in progress.
 *
 * @see #enableWriteAheadLogging
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3,4","1,2","There is a control dependency change where an additional check for `DISABLE_COMPATIBILITY_WAL` is added in the condition. The old flags are saved in a variable now instead of the previous bitmasking directly on the configuration flags. Also, changes made within the try block to reset the flags back to original on exception instead of just adding the `ENABLE_WRITE_AHEAD_LOGGING` back which was the case previously.",
303,<android.view.inputmethod.BaseInputConnection: CharSequence getSelectedText(int)>,27,28,<android.view.inputmethod.BaseInputConnection: CharSequence getSelectedText(int)>,<android.view.inputmethod.BaseInputConnection: CharSequence getSelectedText(int)>,0,"{
    final Editable content = getEditable();
    if (content == null)
        return null;
    int a = Selection.getSelectionStart(content);
    int b = Selection.getSelectionEnd(content);
    if (a > b) {
        int tmp = a;
        a = b;
        b = tmp;
    }
    if (a == b)
        return null;
    if ((flags & GET_TEXT_WITH_STYLES) != 0) {
        return content.subSequence(a, b);
    }
    return TextUtils.substring(content, a, b);
}","{
    final Editable content = getEditable();
    if (content == null)
        return null;
    int a = Selection.getSelectionStart(content);
    int b = Selection.getSelectionEnd(content);
    if (a > b) {
        int tmp = a;
        a = b;
        b = tmp;
    }
    if (a == b || a < 0)
        return null;
    if ((flags & GET_TEXT_WITH_STYLES) != 0) {
        return content.subSequence(a, b);
    }
    return TextUtils.substring(content, a, b);
}",1,"/**
 * The default implementation returns the text currently selected, or null if none is
 * selected.
 */
","/**
 * The default implementation returns the text currently selected, or null if none is
 * selected.
 */
",-1,,,-1,-1,-1,-1,-1,-1,3,0,The control dependency has changed with the addition of the `a < 0` check in the if statement condition.,"Although there is a change in the control dependency, there is no compatibility issue because the additional `a < 0` check only strengthens the precondition to ensure that 'a' is non-negative before proceeding with substring operations. It prevents potentially unexpected behavior on invalid input where 'a' could have been negative in the early version, which would have been an error when calling subSequence or TextUtils.substring with a negative index. The outcome of the method, given valid input, remains the same."
304,<android.widget.ListPopupWindow: void show()>,27,28,<android.widget.ListPopupWindow: void show()>,<android.widget.ListPopupWindow: void show()>,0,"{
    int height = buildDropDown();
    final boolean noInputMethod = isInputMethodNotNeeded();
    mPopup.setAllowScrollingAnchorParent(!noInputMethod);
    mPopup.setWindowLayoutType(mDropDownWindowLayoutType);
    if (mPopup.isShowing()) {
        if (!getAnchorView().isAttachedToWindow()) {
            // Don't update position if the anchor view is detached from window.
            return;
        }
        final int widthSpec;
        if (mDropDownWidth == ViewGroup.LayoutParams.MATCH_PARENT) {
            // The call to PopupWindow's update method below can accept -1 for any
            // value you do not want to update.
            widthSpec = -1;
        } else if (mDropDownWidth == ViewGroup.LayoutParams.WRAP_CONTENT) {
            widthSpec = getAnchorView().getWidth();
        } else {
            widthSpec = mDropDownWidth;
        }
        final int heightSpec;
        if (mDropDownHeight == ViewGroup.LayoutParams.MATCH_PARENT) {
            // The call to PopupWindow's update method below can accept -1 for any
            // value you do not want to update.
            heightSpec = noInputMethod ? height : ViewGroup.LayoutParams.MATCH_PARENT;
            if (noInputMethod) {
                mPopup.setWidth(mDropDownWidth == ViewGroup.LayoutParams.MATCH_PARENT ? ViewGroup.LayoutParams.MATCH_PARENT : 0);
                mPopup.setHeight(0);
            } else {
                mPopup.setWidth(mDropDownWidth == ViewGroup.LayoutParams.MATCH_PARENT ? ViewGroup.LayoutParams.MATCH_PARENT : 0);
                mPopup.setHeight(ViewGroup.LayoutParams.MATCH_PARENT);
            }
        } else if (mDropDownHeight == ViewGroup.LayoutParams.WRAP_CONTENT) {
            heightSpec = height;
        } else {
            heightSpec = mDropDownHeight;
        }
        mPopup.setOutsideTouchable(!mForceIgnoreOutsideTouch && !mDropDownAlwaysVisible);
        mPopup.update(getAnchorView(), mDropDownHorizontalOffset, mDropDownVerticalOffset, (widthSpec < 0) ? -1 : widthSpec, (heightSpec < 0) ? -1 : heightSpec);
    } else {
        final int widthSpec;
        if (mDropDownWidth == ViewGroup.LayoutParams.MATCH_PARENT) {
            widthSpec = ViewGroup.LayoutParams.MATCH_PARENT;
        } else {
            if (mDropDownWidth == ViewGroup.LayoutParams.WRAP_CONTENT) {
                widthSpec = getAnchorView().getWidth();
            } else {
                widthSpec = mDropDownWidth;
            }
        }
        final int heightSpec;
        if (mDropDownHeight == ViewGroup.LayoutParams.MATCH_PARENT) {
            heightSpec = ViewGroup.LayoutParams.MATCH_PARENT;
        } else {
            if (mDropDownHeight == ViewGroup.LayoutParams.WRAP_CONTENT) {
                heightSpec = height;
            } else {
                heightSpec = mDropDownHeight;
            }
        }
        mPopup.setWidth(widthSpec);
        mPopup.setHeight(heightSpec);
        mPopup.setClipToScreenEnabled(true);
        // use outside touchable to dismiss drop down when touching outside of it, so
        // only set this if the dropdown is not always visible
        mPopup.setOutsideTouchable(!mForceIgnoreOutsideTouch && !mDropDownAlwaysVisible);
        mPopup.setTouchInterceptor(mTouchInterceptor);
        mPopup.setEpicenterBounds(mEpicenterBounds);
        if (mOverlapAnchorSet) {
            mPopup.setOverlapAnchor(mOverlapAnchor);
        }
        mPopup.showAsDropDown(getAnchorView(), mDropDownHorizontalOffset, mDropDownVerticalOffset, mDropDownGravity);
        mDropDownList.setSelection(ListView.INVALID_POSITION);
        if (!mModal || mDropDownList.isInTouchMode()) {
            clearListSelection();
        }
        if (!mModal) {
            mHandler.post(mHideSelector);
        }
    }
}","{
    int height = buildDropDown();
    final boolean noInputMethod = isInputMethodNotNeeded();
    mPopup.setAllowScrollingAnchorParent(!noInputMethod);
    mPopup.setWindowLayoutType(mDropDownWindowLayoutType);
    if (mPopup.isShowing()) {
        if (!getAnchorView().isAttachedToWindow()) {
            // Don't update position if the anchor view is detached from window.
            return;
        }
        final int widthSpec;
        if (mDropDownWidth == ViewGroup.LayoutParams.MATCH_PARENT) {
            // The call to PopupWindow's update method below can accept -1 for any
            // value you do not want to update.
            widthSpec = -1;
        } else if (mDropDownWidth == ViewGroup.LayoutParams.WRAP_CONTENT) {
            widthSpec = getAnchorView().getWidth();
        } else {
            widthSpec = mDropDownWidth;
        }
        final int heightSpec;
        if (mDropDownHeight == ViewGroup.LayoutParams.MATCH_PARENT) {
            // The call to PopupWindow's update method below can accept -1 for any
            // value you do not want to update.
            heightSpec = noInputMethod ? height : ViewGroup.LayoutParams.MATCH_PARENT;
            if (noInputMethod) {
                mPopup.setWidth(mDropDownWidth == ViewGroup.LayoutParams.MATCH_PARENT ? ViewGroup.LayoutParams.MATCH_PARENT : 0);
                mPopup.setHeight(0);
            } else {
                mPopup.setWidth(mDropDownWidth == ViewGroup.LayoutParams.MATCH_PARENT ? ViewGroup.LayoutParams.MATCH_PARENT : 0);
                mPopup.setHeight(ViewGroup.LayoutParams.MATCH_PARENT);
            }
        } else if (mDropDownHeight == ViewGroup.LayoutParams.WRAP_CONTENT) {
            heightSpec = height;
        } else {
            heightSpec = mDropDownHeight;
        }
        mPopup.setOutsideTouchable(!mForceIgnoreOutsideTouch && !mDropDownAlwaysVisible);
        mPopup.update(getAnchorView(), mDropDownHorizontalOffset, mDropDownVerticalOffset, (widthSpec < 0) ? -1 : widthSpec, (heightSpec < 0) ? -1 : heightSpec);
        mPopup.getContentView().restoreDefaultFocus();
    } else {
        final int widthSpec;
        if (mDropDownWidth == ViewGroup.LayoutParams.MATCH_PARENT) {
            widthSpec = ViewGroup.LayoutParams.MATCH_PARENT;
        } else {
            if (mDropDownWidth == ViewGroup.LayoutParams.WRAP_CONTENT) {
                widthSpec = getAnchorView().getWidth();
            } else {
                widthSpec = mDropDownWidth;
            }
        }
        final int heightSpec;
        if (mDropDownHeight == ViewGroup.LayoutParams.MATCH_PARENT) {
            heightSpec = ViewGroup.LayoutParams.MATCH_PARENT;
        } else {
            if (mDropDownHeight == ViewGroup.LayoutParams.WRAP_CONTENT) {
                heightSpec = height;
            } else {
                heightSpec = mDropDownHeight;
            }
        }
        mPopup.setWidth(widthSpec);
        mPopup.setHeight(heightSpec);
        mPopup.setClipToScreenEnabled(true);
        // use outside touchable to dismiss drop down when touching outside of it, so
        // only set this if the dropdown is not always visible
        mPopup.setOutsideTouchable(!mForceIgnoreOutsideTouch && !mDropDownAlwaysVisible);
        mPopup.setTouchInterceptor(mTouchInterceptor);
        mPopup.setEpicenterBounds(mEpicenterBounds);
        if (mOverlapAnchorSet) {
            mPopup.setOverlapAnchor(mOverlapAnchor);
        }
        mPopup.showAsDropDown(getAnchorView(), mDropDownHorizontalOffset, mDropDownVerticalOffset, mDropDownGravity);
        mDropDownList.setSelection(ListView.INVALID_POSITION);
        mPopup.getContentView().restoreDefaultFocus();
        if (!mModal || mDropDownList.isInTouchMode()) {
            clearListSelection();
        }
        if (!mModal) {
            mHandler.post(mHideSelector);
        }
    }
}",1,"/**
 * Show the popup list. If the list is already showing, this method
 * will recalculate the popup's size and position.
 */
","/**
 * Show the popup list. If the list is already showing, this method
 * will recalculate the popup's size and position.
 */
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,,,,
305,"<android.provider.Settings.Secure: boolean isLocationProviderEnabled(ContentResolver,String)>",27,28,"<android.provider.Settings.Secure: boolean isLocationProviderEnabled(ContentResolver,String)>","<android.provider.Settings.Secure: boolean isLocationProviderEnabled(ContentResolver,String)>",0,"{
    return isLocationProviderEnabledForUser(cr, provider, UserHandle.myUserId());
}","{
    return isLocationProviderEnabledForUser(cr, provider, cr.getUserId());
}",1,"/**
 * Helper method for determining if a location provider is enabled.
 *
 * @param cr the content resolver to use
 * @param provider the location provider to query
 * @return true if the provider is enabled
 *
 * @deprecated use {@link #LOCATION_MODE} or
 * {@link LocationManager#isProviderEnabled(String)}
 */
","/**
 * Helper method for determining if a location provider is enabled.
 *
 * @param cr the content resolver to use
 * @param provider the location provider to query
 * @return true if the provider is enabled
 *
 * @deprecated use {@link LocationManager#isProviderEnabled(String)}
 */
",-1,[@Deprecated],[@Deprecated],-1,-1,-1,-1,-1,-1,5,0,"The only change is in the parameter passed to the method isLocationProviderEnabledForUser, switching from UserHandle.myUserId() to cr.getUserId(), which indicates a change in the dependent API, so the code change type is 5.","There is no direct indication that this change would lead to a different return type or value or different exception handling; the change seems to be internal and assumes that cr.getUserId() and UserHandle.myUserId() return the same value for the current user context. Therefore, there seems to be no compatibility issue, so the CI type is 0."
308,<android.service.autofill.FillResponse.Builder: Builder setIgnoredIds(AutofillId)>,27,28,<android.service.autofill.FillResponse.Builder: Builder setIgnoredIds(AutofillId)>,<android.service.autofill.FillResponse.Builder: Builder setIgnoredIds(AutofillId)>,0,"{
    mIgnoredIds = ids;
    return this;
}","{
    throwIfDestroyed();
    mIgnoredIds = ids;
    return this;
}",1,"/**
 * Specifies views that should not trigger new
 * {@link AutofillService#onFillRequest(FillRequest, android.os.CancellationSignal,
 * FillCallback)} requests.
 *
 * <p>This is typically used when the service cannot autofill the view; for example, a
 * text field representing the result of a Captcha challenge.
 */
","/**
 * Specifies views that should not trigger new
 * {@link AutofillService#onFillRequest(FillRequest, android.os.CancellationSignal,
 * FillCallback)} requests.
 *
 * <p>This is typically used when the service cannot autofill the view; for example, a
 * text field representing the result of a Captcha challenge.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,2,"The late implementation introduces a new method call to throwIfDestroyed() before setting mIgnoredIds, which is a change type 4 (Other statement changed).","The introduction of the throwIfDestroyed() method could cause a new exception to be thrown if the builder has been destroyed, hence there is a potential Compatibility Issue caused by different exception handling (type 2)."
309,"<android.bluetooth.BluetoothSocket: int write(byte[],int,int)>",27,28,"<android.bluetooth.BluetoothSocket: int write(byte[],int,int)>","<android.bluetooth.BluetoothSocket: int write(byte[],int,int)>",0,"{
    // to the actual message length.
    if (VDBG)
        Log.d(TAG, ""write: "" + mSocketOS + "" length: "" + length);
    if (mType == TYPE_L2CAP) {
        if (length <= mMaxTxPacketSize) {
            mSocketOS.write(b, offset, length);
        } else {
            if (DBG)
                Log.w(TAG, ""WARNING: Write buffer larger than L2CAP packet size!\n"" + ""Packet will be divided into SDU packets of size "" + mMaxTxPacketSize);
            int tmpOffset = offset;
            int bytesToWrite = length;
            while (bytesToWrite > 0) {
                int tmpLength = (bytesToWrite > mMaxTxPacketSize) ? mMaxTxPacketSize : bytesToWrite;
                mSocketOS.write(b, tmpOffset, tmpLength);
                tmpOffset += tmpLength;
                bytesToWrite -= tmpLength;
            }
        }
    } else {
        mSocketOS.write(b, offset, length);
    }
    // There is no good way to confirm since the entire process is asynchronous anyway
    if (VDBG)
        Log.d(TAG, ""write out: "" + mSocketOS + "" length: "" + length);
    return length;
}","{
    // to the actual message length.
    if (VDBG)
        Log.d(TAG, ""write: "" + mSocketOS + "" length: "" + length);
    if ((mType == TYPE_L2CAP) || (mType == TYPE_L2CAP_LE)) {
        if (length <= mMaxTxPacketSize) {
            mSocketOS.write(b, offset, length);
        } else {
            if (DBG) {
                Log.w(TAG, ""WARNING: Write buffer larger than L2CAP packet size!\n"" + ""Packet will be divided into SDU packets of size "" + mMaxTxPacketSize);
            }
            int tmpOffset = offset;
            int bytesToWrite = length;
            while (bytesToWrite > 0) {
                int tmpLength = (bytesToWrite > mMaxTxPacketSize) ? mMaxTxPacketSize : bytesToWrite;
                mSocketOS.write(b, tmpOffset, tmpLength);
                tmpOffset += tmpLength;
                bytesToWrite -= tmpLength;
            }
        }
    } else {
        mSocketOS.write(b, offset, length);
    }
    // There is no good way to confirm since the entire process is asynchronous anyway
    if (VDBG)
        Log.d(TAG, ""write out: "" + mSocketOS + "" length: "" + length);
    return length;
}",1,"/*package*/
","/*package*/
",-1,,,-1,-1,-1,-1,-1,-1,3,1,"The condition in the if statement is extended to include an additional type (TYPE_L2CAP_LE), making the if condition broader in the late version, so the code change type is 3.","This change extends the branch condition, which can lead to the L2CAP specific write behavior being applied to more instances (TYPE_L2CAP_LE in addition to TYPE_L2CAP). This affects the behavior of the method and potentially the return value when the mType is TYPE_L2CAP_LE, as it would now enter a branch that it previously would not have. Therefore, this can potentially cause the API to return a different number of written bytes under different conditions, which indicates a CI type of 1."
311,<android.app.admin.DnsEvent: int getTotalResolvedAddressCount()>,27,28,<android.app.admin.DnsEvent: int getTotalResolvedAddressCount()>,<android.app.admin.DnsEvent: int getTotalResolvedAddressCount()>,0,"{
    return ipAddressesCount;
}","{
    return mIpAddressesCount;
}",1,"/**
 * Returns the number of IP addresses returned from the DNS lookup event. May be different from
 * the length of the list returned by {@link #getInetAddresses()} if there were too many
 * addresses to log.
 */
","/**
 * Returns the number of IP addresses returned from the DNS lookup event. May be different from
 * the length of the list returned by {@link #getInetAddresses()} if there were too many
 * addresses to log.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The code has been changed from a direct variable access (ipAddressesCount) to a member variable access with a potential getter (mIpAddressesCount), so the change type is 4.","Since both accesses seem to refer to the same value and there's no indication that behavior has changed other than possible accessor method usage, the change doesn't suggest different behavior regarding return values or exception throwing. Therefore, there is no Compatibility Issue, so the CI type is 0."
312,<android.widget.RemoteViews.BitmapCache: int getBitmapId(Bitmap)>,27,28,<android.widget.RemoteViews.BitmapCache: int getBitmapId(Bitmap)>,<android.widget.RemoteViews.BitmapCache: int getBitmapId(Bitmap)>,0,"{
    if (b == null) {
        return -1;
    } else {
        if (mBitmaps.contains(b)) {
            return mBitmaps.indexOf(b);
        } else {
            mBitmaps.add(b);
            return (mBitmaps.size() - 1);
        }
    }
}","{
    if (b == null) {
        return -1;
    } else {
        if (mBitmaps.contains(b)) {
            return mBitmaps.indexOf(b);
        } else {
            mBitmaps.add(b);
            mBitmapMemory = -1;
            return (mBitmaps.size() - 1);
        }
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,4,0,"There is a new statement ""mBitmapMemory = -1;"" that is added, which does not affect the returned value or the control flow. The code change type is 4 due to this additional assignment statement.","The value returned from the method has not changed, nor has any exception handling or control dependency been altered. Thus, there is no Compatibility Issue, which is type 0."
314,"<android.appwidget.AppWidgetManager: boolean bindAppWidgetIdIfAllowed(int,ComponentName)>",27,28,"<android.appwidget.AppWidgetManager: boolean bindAppWidgetIdIfAllowed(int,ComponentName)>","<android.appwidget.AppWidgetManager: boolean bindAppWidgetIdIfAllowed(int,ComponentName)>",0,"{
    if (mService == null) {
        return false;
    }
    return bindAppWidgetIdIfAllowed(appWidgetId, UserHandle.myUserId(), provider, null);
}","{
    if (mService == null) {
        return false;
    }
    return bindAppWidgetIdIfAllowed(appWidgetId, mContext.getUserId(), provider, null);
}",1,"/**
 * Set the component for a given appWidgetId.
 *
 * <p class=""note"">You need the BIND_APPWIDGET permission or the user must have enabled binding
 * widgets always for your component. Should be used by apps that host widgets; if this
 * method returns false, call {@link #ACTION_APPWIDGET_BIND} to request permission to
 * bind
 *
 * @param appWidgetId   The AppWidget id under which to bind the provider.
 * @param provider      The {@link android.content.BroadcastReceiver} that will be the AppWidget
 * provider for this AppWidget.
 * @return true if this component has permission to bind the AppWidget
 */
","/**
 * Set the component for a given appWidgetId.
 *
 * <p class=""note"">You need the BIND_APPWIDGET permission or the user must have enabled binding
 * widgets always for your component. Should be used by apps that host widgets; if this
 * method returns false, call {@link #ACTION_APPWIDGET_BIND} to request permission to
 * bind
 *
 * @param appWidgetId   The AppWidget id under which to bind the provider.
 * @param provider      The {@link android.content.BroadcastReceiver} that will be the AppWidget
 * provider for this AppWidget.
 * @return true if this component has permission to bind the AppWidget
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The method call within the return statement has changed from `UserHandle.myUserId()` to `mContext.getUserId()`. This is a change in the dependent API, so the code change type is 5.","As there is no change to the structure of the method, the method's returned value types, or the exception handling, there are no Compatibility Issues as per our definitions. The change to the dependent API does not inherently signify a behavior change in the context of this method's contract, thus no CI is detected."
315,<android.net.NetworkStats.Entry: int hashCode()>,27,28,<android.net.NetworkStats.Entry: int hashCode()>,<android.net.NetworkStats.Entry: int hashCode()>,0,"{
    return Objects.hash(uid, set, tag, metered, roaming, iface);
}","{
    return Objects.hash(uid, set, tag, metered, roaming, defaultNetwork, iface);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,4",1,"The hashCode() method's implementation has been modified by adding an additional field (defaultNetwork) to the Objects.hash() method, which changes the way hashCode is calculated for the object. Therefore, the change type is 1 (Return statement changed) and 4 (Other statement changed). ","The change in the return statement due to the addition of a new field to the hash calculation will cause the objects of this class to have different hash codes across versions 27 and 28 when the defaultNetwork values are involved. This constitutes a compatibility issue because the change can affect the behavior of collections like HashMap and HashSet that rely on these hash codes, leading to the CI type 1 (Compatibility Issue caused by potential different return values or types)."
317,<android.companion.CompanionDeviceManager.CallbackProxy: void onFailure(CharSequence)>,27,28,<android.companion.CompanionDeviceManager.CallbackProxy: void onFailure(CharSequence)>,<android.companion.CompanionDeviceManager.CallbackProxy: void onFailure(CharSequence)>,0,"{
    Handler handler = mHandler;
    if (handler == null)
        return;
    handler.post(() -> {
        Callback callback = mCallback;
        if (callback == null)
            return;
        callback.onFailure(reason);
    });
}","{
    lockAndPost(Callback::onFailure, reason);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"4,5",0,"The method implementation body has changed to use a single method call lockAndPost(Callback::onFailure, reason), which abstracts the logic previously directly implemented in the body, so the change type is Other statement changed (4) since the overall logic structure remains the same and Dependent API changed (5) because now it depends on the new 'lockAndPost' method.","Assuming the 'lockAndPost' method correctly preserves the behavior of posting a Runnable to a Handler (as in the early implementation), this change does not lead to a CI because it doesn't affect the API's external behavior. The logic within the new 'lockAndPost' method should manage the threading and callback invocation in the same way as the earlier version's implementation does explicitly. Therefore, there's No Compatibility Issue (0)."
319,"<android.appwidget.AppWidgetManager: boolean bindAppWidgetIdIfAllowed(int,ComponentName,Bundle)>",27,28,"<android.appwidget.AppWidgetManager: boolean bindAppWidgetIdIfAllowed(int,ComponentName,Bundle)>","<android.appwidget.AppWidgetManager: boolean bindAppWidgetIdIfAllowed(int,ComponentName,Bundle)>",0,"{
    if (mService == null) {
        return false;
    }
    return bindAppWidgetIdIfAllowed(appWidgetId, UserHandle.myUserId(), provider, options);
}","{
    if (mService == null) {
        return false;
    }
    return bindAppWidgetIdIfAllowed(appWidgetId, mContext.getUserId(), provider, options);
}",1,"/**
 * Set the component for a given appWidgetId.
 *
 * <p class=""note"">You need the BIND_APPWIDGET permission or the user must have enabled binding
 * widgets always for your component. Should be used by apps that host widgets; if this
 * method returns false, call {@link #ACTION_APPWIDGET_BIND} to request permission to
 * bind
 *
 * @param appWidgetId The AppWidget id under which to bind the provider.
 * @param provider      The {@link android.content.BroadcastReceiver} that will be the AppWidget
 * provider for this AppWidget.
 * @param options       Bundle containing options for the AppWidget. See also
 * {@link #updateAppWidgetOptions(int, Bundle)}
 *
 * @return true if this component has permission to bind the AppWidget
 */
","/**
 * Set the component for a given appWidgetId.
 *
 * <p class=""note"">You need the BIND_APPWIDGET permission or the user must have enabled binding
 * widgets always for your component. Should be used by apps that host widgets; if this
 * method returns false, call {@link #ACTION_APPWIDGET_BIND} to request permission to
 * bind
 *
 * @param appWidgetId The AppWidget id under which to bind the provider.
 * @param provider      The {@link android.content.BroadcastReceiver} that will be the AppWidget
 * provider for this AppWidget.
 * @param options       Bundle containing options for the AppWidget. See also
 * {@link #updateAppWidgetOptions(int, Bundle)}
 *
 * @return true if this component has permission to bind the AppWidget
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"The implementation has changed to use mContext.getUserId() instead of UserHandle.myUserId(), thus the dependent API UserHandle.myUserId() has been replaced by mContext.getUserId(). This is categorized as other statement changed (4) and dependent API changed (5).","The change in the implementation does not affect the potential behavior of the bindAppWidgetIdIfAllowed API because the purpose of both UserHandle.myUserId() and mContext.getUserId() is to retrieve the identifier of the calling user. Both should return the same value assuming mContext is correctly initialized. Therefore, there is no compatibility issue (0)."
321,"<android.app.KeyguardManager: void requestDismissKeyguard(Activity,KeyguardDismissCallback)>",27,28,"<android.app.KeyguardManager: void requestDismissKeyguard(Activity,KeyguardDismissCallback)>","<android.app.KeyguardManager: void requestDismissKeyguard(Activity,KeyguardDismissCallback)>",0,"{
    try {
        mAm.dismissKeyguard(activity.getActivityToken(), new IKeyguardDismissCallback.Stub() {

            @Override
            public void onDismissError() throws RemoteException {
                if (callback != null && !activity.isDestroyed()) {
                    activity.mHandler.post(callback::onDismissError);
                }
            }

            @Override
            public void onDismissSucceeded() throws RemoteException {
                if (callback != null && !activity.isDestroyed()) {
                    activity.mHandler.post(callback::onDismissSucceeded);
                }
            }

            @Override
            public void onDismissCancelled() throws RemoteException {
                if (callback != null && !activity.isDestroyed()) {
                    activity.mHandler.post(callback::onDismissCancelled);
                }
            }
        });
    } catch (RemoteException e) {
        Log.i(TAG, ""Failed to dismiss keyguard: "" + e);
    }
}","{
    requestDismissKeyguard(activity, null, /* message */
    callback);
}",1,"/**
 * If the device is currently locked (see {@link #isKeyguardLocked()}, requests the Keyguard to
 * be dismissed.
 * <p>
 * If the Keyguard is not secure or the device is currently in a trusted state, calling this
 * method will immediately dismiss the Keyguard without any user interaction.
 * <p>
 * If the Keyguard is secure and the device is not in a trusted state, this will bring up the
 * UI so the user can enter their credentials.
 * <p>
 * If the value set for the {@link Activity} attr {@link android.R.attr#turnScreenOn} is true,
 * the screen will turn on when the keyguard is dismissed.
 *
 * @param activity The activity requesting the dismissal. The activity must be either visible
 * by using {@link LayoutParams#FLAG_SHOW_WHEN_LOCKED} or must be in a state in
 * which it would be visible if Keyguard would not be hiding it. If that's not
 * the case, the request will fail immediately and
 * {@link KeyguardDismissCallback#onDismissError} will be invoked.
 * @param callback The callback to be called if the request to dismiss Keyguard was successful
 * or {@code null} if the caller isn't interested in knowing the result. The
 * callback will not be invoked if the activity was destroyed before the
 * callback was received.
 */
","/**
 * If the device is currently locked (see {@link #isKeyguardLocked()}, requests the Keyguard to
 * be dismissed.
 * <p>
 * If the Keyguard is not secure or the device is currently in a trusted state, calling this
 * method will immediately dismiss the Keyguard without any user interaction.
 * <p>
 * If the Keyguard is secure and the device is not in a trusted state, this will bring up the
 * UI so the user can enter their credentials.
 * <p>
 * If the value set for the {@link Activity} attr {@link android.R.attr#turnScreenOn} is true,
 * the screen will turn on when the keyguard is dismissed.
 *
 * @param activity The activity requesting the dismissal. The activity must be either visible
 * by using {@link LayoutParams#FLAG_SHOW_WHEN_LOCKED} or must be in a state in
 * which it would be visible if Keyguard would not be hiding it. If that's not
 * the case, the request will fail immediately and
 * {@link KeyguardDismissCallback#onDismissError} will be invoked.
 * @param callback The callback to be called if the request to dismiss Keyguard was successful
 * or {@code null} if the caller isn't interested in knowing the result. The
 * callback will not be invoked if the activity was destroyed before the
 * callback was received.
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The implementation of the method has been completely changed, and now it delegates the operation to another overloaded method of requestDismissKeyguard. Since this is a structural change rather than a change in logic within the method body, the code change is of type 5.","There is no direct Compatibility Issue from this change alone, because the logic now happens in another method which is not provided here. The change here should be a refactoring for cleaner code or better structure. Without knowing the implementation of the overloaded method, we cannot conclude a different behavior would happen. Thus, the CI situation is 0."
322,<android.hardware.radio.ProgramSelector.Identifier: int getType()>,27,28,<android.hardware.radio.ProgramSelector.Identifier: int getType()>,<android.hardware.radio.ProgramSelector.Identifier: int getType()>,0,"{
    return mType;
}","{
    if (mType == IDENTIFIER_TYPE_HD_SUBCHANNEL && mValue > 10) {
        /* HD_SUBCHANNEL and HD_STATION_NAME use the same identifier type, but they differ
                 * in possible values: sub channel is 0-7, station name is greater than ASCII space
                 * code (32).
                 */
        return IDENTIFIER_TYPE_HD_STATION_NAME;
    }
    return mType;
}",1,"/**
 * Type of an identifier.
 *
 * @return type of an identifier.
 */
","/**
 * Type of an identifier.
 *
 * @return type of an identifier.
 */
",-1,[@IdentifierType],[@IdentifierType],-1,-1,-1,-1,-1,-1,"1,3",1,"The late implementation version introduces an if-statement along with an additional return statement that can return a different value based on the condition, so the change types are 1 (for the additional return statement with a different value) and 3 (for the addition of a control flow statement).","This change results in a Compatibility Issue due to the new conditional statement altering the return value based on the logic implemented. Depending on the condition, the method now potentially returns a different value (IDENTIFIER_TYPE_HD_STATION_NAME instead of mType when the condition is true), so the CI type is 1 (Compatibility Issue caused by a potential different return value)."
323,<android.app.ActivityOptions: Bundle toBundle()>,27,28,<android.app.ActivityOptions: Bundle toBundle()>,<android.app.ActivityOptions: Bundle toBundle()>,0,"{
    Bundle b = new Bundle();
    if (mPackageName != null) {
        b.putString(KEY_PACKAGE_NAME, mPackageName);
    }
    if (mLaunchBounds != null) {
        b.putParcelable(KEY_LAUNCH_BOUNDS, mLaunchBounds);
    }
    b.putInt(KEY_ANIM_TYPE, mAnimationType);
    if (mUsageTimeReport != null) {
        b.putParcelable(KEY_USAGE_TIME_REPORT, mUsageTimeReport);
    }
    switch(mAnimationType) {
        case ANIM_CUSTOM:
            b.putInt(KEY_ANIM_ENTER_RES_ID, mCustomEnterResId);
            b.putInt(KEY_ANIM_EXIT_RES_ID, mCustomExitResId);
            b.putBinder(KEY_ANIM_START_LISTENER, mAnimationStartedListener != null ? mAnimationStartedListener.asBinder() : null);
            break;
        case ANIM_CUSTOM_IN_PLACE:
            b.putInt(KEY_ANIM_IN_PLACE_RES_ID, mCustomInPlaceResId);
            break;
        case ANIM_SCALE_UP:
        case ANIM_CLIP_REVEAL:
            b.putInt(KEY_ANIM_START_X, mStartX);
            b.putInt(KEY_ANIM_START_Y, mStartY);
            b.putInt(KEY_ANIM_WIDTH, mWidth);
            b.putInt(KEY_ANIM_HEIGHT, mHeight);
            break;
        case ANIM_THUMBNAIL_SCALE_UP:
        case ANIM_THUMBNAIL_SCALE_DOWN:
        case ANIM_THUMBNAIL_ASPECT_SCALE_UP:
        case ANIM_THUMBNAIL_ASPECT_SCALE_DOWN:
            // the bitmap to a hardware bitmap and pass through the GraphicBuffer
            if (mThumbnail != null) {
                final Bitmap hwBitmap = mThumbnail.copy(Config.HARDWARE, false);
                if (hwBitmap != null) {
                    b.putParcelable(KEY_ANIM_THUMBNAIL, hwBitmap.createGraphicBufferHandle());
                } else {
                    Slog.w(TAG, ""Failed to copy thumbnail"");
                }
            }
            b.putInt(KEY_ANIM_START_X, mStartX);
            b.putInt(KEY_ANIM_START_Y, mStartY);
            b.putInt(KEY_ANIM_WIDTH, mWidth);
            b.putInt(KEY_ANIM_HEIGHT, mHeight);
            b.putBinder(KEY_ANIM_START_LISTENER, mAnimationStartedListener != null ? mAnimationStartedListener.asBinder() : null);
            break;
        case ANIM_SCENE_TRANSITION:
            if (mTransitionReceiver != null) {
                b.putParcelable(KEY_TRANSITION_COMPLETE_LISTENER, mTransitionReceiver);
            }
            b.putBoolean(KEY_TRANSITION_IS_RETURNING, mIsReturning);
            b.putStringArrayList(KEY_TRANSITION_SHARED_ELEMENTS, mSharedElementNames);
            b.putParcelable(KEY_RESULT_DATA, mResultData);
            b.putInt(KEY_RESULT_CODE, mResultCode);
            b.putInt(KEY_EXIT_COORDINATOR_INDEX, mExitCoordinatorIndex);
            break;
    }
    b.putInt(KEY_LAUNCH_DISPLAY_ID, mLaunchDisplayId);
    b.putInt(KEY_LAUNCH_STACK_ID, mLaunchStackId);
    b.putInt(KEY_LAUNCH_TASK_ID, mLaunchTaskId);
    b.putBoolean(KEY_TASK_OVERLAY, mTaskOverlay);
    b.putBoolean(KEY_TASK_OVERLAY_CAN_RESUME, mTaskOverlayCanResume);
    b.putInt(KEY_DOCK_CREATE_MODE, mDockCreateMode);
    b.putBoolean(KEY_DISALLOW_ENTER_PICTURE_IN_PICTURE_WHILE_LAUNCHING, mDisallowEnterPictureInPictureWhileLaunching);
    if (mAnimSpecs != null) {
        b.putParcelableArray(KEY_ANIM_SPECS, mAnimSpecs);
    }
    if (mAnimationFinishedListener != null) {
        b.putBinder(KEY_ANIMATION_FINISHED_LISTENER, mAnimationFinishedListener.asBinder());
    }
    if (mSpecsFuture != null) {
        b.putBinder(KEY_SPECS_FUTURE, mSpecsFuture.asBinder());
    }
    b.putInt(KEY_ROTATION_ANIMATION_HINT, mRotationAnimationHint);
    if (mAppVerificationBundle != null) {
        b.putBundle(KEY_INSTANT_APP_VERIFICATION_BUNDLE, mAppVerificationBundle);
    }
    return b;
}","{
    Bundle b = new Bundle();
    if (mPackageName != null) {
        b.putString(KEY_PACKAGE_NAME, mPackageName);
    }
    if (mLaunchBounds != null) {
        b.putParcelable(KEY_LAUNCH_BOUNDS, mLaunchBounds);
    }
    b.putInt(KEY_ANIM_TYPE, mAnimationType);
    if (mUsageTimeReport != null) {
        b.putParcelable(KEY_USAGE_TIME_REPORT, mUsageTimeReport);
    }
    switch(mAnimationType) {
        case ANIM_CUSTOM:
            b.putInt(KEY_ANIM_ENTER_RES_ID, mCustomEnterResId);
            b.putInt(KEY_ANIM_EXIT_RES_ID, mCustomExitResId);
            b.putBinder(KEY_ANIM_START_LISTENER, mAnimationStartedListener != null ? mAnimationStartedListener.asBinder() : null);
            break;
        case ANIM_CUSTOM_IN_PLACE:
            b.putInt(KEY_ANIM_IN_PLACE_RES_ID, mCustomInPlaceResId);
            break;
        case ANIM_SCALE_UP:
        case ANIM_CLIP_REVEAL:
            b.putInt(KEY_ANIM_START_X, mStartX);
            b.putInt(KEY_ANIM_START_Y, mStartY);
            b.putInt(KEY_ANIM_WIDTH, mWidth);
            b.putInt(KEY_ANIM_HEIGHT, mHeight);
            break;
        case ANIM_THUMBNAIL_SCALE_UP:
        case ANIM_THUMBNAIL_SCALE_DOWN:
        case ANIM_THUMBNAIL_ASPECT_SCALE_UP:
        case ANIM_THUMBNAIL_ASPECT_SCALE_DOWN:
            // the bitmap to a hardware bitmap and pass through the GraphicBuffer
            if (mThumbnail != null) {
                final Bitmap hwBitmap = mThumbnail.copy(Config.HARDWARE, false);
                if (hwBitmap != null) {
                    b.putParcelable(KEY_ANIM_THUMBNAIL, hwBitmap.createGraphicBufferHandle());
                } else {
                    Slog.w(TAG, ""Failed to copy thumbnail"");
                }
            }
            b.putInt(KEY_ANIM_START_X, mStartX);
            b.putInt(KEY_ANIM_START_Y, mStartY);
            b.putInt(KEY_ANIM_WIDTH, mWidth);
            b.putInt(KEY_ANIM_HEIGHT, mHeight);
            b.putBinder(KEY_ANIM_START_LISTENER, mAnimationStartedListener != null ? mAnimationStartedListener.asBinder() : null);
            break;
        case ANIM_SCENE_TRANSITION:
            if (mTransitionReceiver != null) {
                b.putParcelable(KEY_TRANSITION_COMPLETE_LISTENER, mTransitionReceiver);
            }
            b.putBoolean(KEY_TRANSITION_IS_RETURNING, mIsReturning);
            b.putStringArrayList(KEY_TRANSITION_SHARED_ELEMENTS, mSharedElementNames);
            b.putParcelable(KEY_RESULT_DATA, mResultData);
            b.putInt(KEY_RESULT_CODE, mResultCode);
            b.putInt(KEY_EXIT_COORDINATOR_INDEX, mExitCoordinatorIndex);
            break;
    }
    b.putBoolean(KEY_LOCK_TASK_MODE, mLockTaskMode);
    b.putInt(KEY_LAUNCH_DISPLAY_ID, mLaunchDisplayId);
    b.putInt(KEY_LAUNCH_WINDOWING_MODE, mLaunchWindowingMode);
    b.putInt(KEY_LAUNCH_ACTIVITY_TYPE, mLaunchActivityType);
    b.putInt(KEY_LAUNCH_TASK_ID, mLaunchTaskId);
    b.putBoolean(KEY_TASK_OVERLAY, mTaskOverlay);
    b.putBoolean(KEY_TASK_OVERLAY_CAN_RESUME, mTaskOverlayCanResume);
    b.putBoolean(KEY_AVOID_MOVE_TO_FRONT, mAvoidMoveToFront);
    b.putInt(KEY_SPLIT_SCREEN_CREATE_MODE, mSplitScreenCreateMode);
    b.putBoolean(KEY_DISALLOW_ENTER_PICTURE_IN_PICTURE_WHILE_LAUNCHING, mDisallowEnterPictureInPictureWhileLaunching);
    if (mAnimSpecs != null) {
        b.putParcelableArray(KEY_ANIM_SPECS, mAnimSpecs);
    }
    if (mAnimationFinishedListener != null) {
        b.putBinder(KEY_ANIMATION_FINISHED_LISTENER, mAnimationFinishedListener.asBinder());
    }
    if (mSpecsFuture != null) {
        b.putBinder(KEY_SPECS_FUTURE, mSpecsFuture.asBinder());
    }
    b.putInt(KEY_ROTATION_ANIMATION_HINT, mRotationAnimationHint);
    if (mAppVerificationBundle != null) {
        b.putBundle(KEY_INSTANT_APP_VERIFICATION_BUNDLE, mAppVerificationBundle);
    }
    if (mRemoteAnimationAdapter != null) {
        b.putParcelable(KEY_REMOTE_ANIMATION_ADAPTER, mRemoteAnimationAdapter);
    }
    return b;
}",1,"/**
 * Returns the created options as a Bundle, which can be passed to
 * {@link android.content.Context#startActivity(android.content.Intent, android.os.Bundle)
 * Context.startActivity(Intent, Bundle)} and related methods.
 * Note that the returned Bundle is still owned by the ActivityOptions
 * object; you must not modify it, but can supply it to the startActivity
 * methods that take an options Bundle.
 */
","/**
 * Returns the created options as a Bundle, which can be passed to
 * {@link android.content.Context#startActivity(android.content.Intent, android.os.Bundle)
 * Context.startActivity(Intent, Bundle)} and related methods.
 * Note that the returned Bundle is still owned by the ActivityOptions
 * object; you must not modify it, but can supply it to the startActivity
 * methods that take an options Bundle.
 */
",-1,,,-1,-1,-1,-1,-1,-1,,,,
324,<android.appwidget.AppWidgetHostView: void dispatchRestoreInstanceState(SparseArray<Parcelable>)>,27,28,<android.appwidget.AppWidgetHostView: void dispatchRestoreInstanceState(SparseArray<Parcelable>)>,<android.appwidget.AppWidgetHostView: void dispatchRestoreInstanceState(SparseArray<Parcelable>)>,0,"{
    final Parcelable parcelable = container.get(generateId());
    ParcelableSparseArray jail = null;
    if (parcelable != null && parcelable instanceof ParcelableSparseArray) {
        jail = (ParcelableSparseArray) parcelable;
    }
    if (jail == null)
        jail = new ParcelableSparseArray();
    try {
        super.dispatchRestoreInstanceState(jail);
    } catch (Exception e) {
        Log.e(TAG, ""failed to restoreInstanceState for widget id: "" + mAppWidgetId + "", "" + (mInfo == null ? ""null"" : mInfo.provider), e);
    }
}","{
    final Parcelable parcelable = container.get(generateId());
    SparseArray<Parcelable> jail = null;
    if (parcelable instanceof Bundle) {
        jail = ((Bundle) parcelable).getSparseParcelableArray(KEY_JAILED_ARRAY);
    }
    if (jail == null)
        jail = new SparseArray<>();
    try {
        super.dispatchRestoreInstanceState(jail);
    } catch (Exception e) {
        Log.e(TAG, ""failed to restoreInstanceState for widget id: "" + mAppWidgetId + "", "" + (mInfo == null ? ""null"" : mInfo.provider), e);
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,3,4",1,"The assignment of `jail` has changed from one with a cast from `ParcelableSparseArray` to directly getting it from a `Bundle`. Moreover, a control dependency change occurs with the change in the condition `parcelable instanceof ParcelableSparseArray` to `parcelable instanceof Bundle`. Another change is the replacement of `new ParcelableSparseArray()` with `new SparseArray<>()`. These changes are not just simply type changes, but logic changes in how the state is restored, leading to a potential different return value through the `dispatchRestoreInstanceState` call. Hence, the code changes include return statement changed (1), control dependency changed (3), and other statement changed (4).","The change in how the `jail` variable is retrieved and instantiated can potentially affect the outcome of the `dispatchRestoreInstanceState` method call, causing the API to potentially experience different behavior or return different results (as the value passed on to `super.dispatchRestoreInstanceState` has changed). Therefore, a Compatibility Issue arises due to potentially different return values or types (1)."
325,<android.content.pm.ShortcutInfo: String toString()>,27,28,<android.content.pm.ShortcutInfo: String toString()>,<android.content.pm.ShortcutInfo: String toString()>,0,"{
    return toStringInner(/* secure =*/
    true, /* includeInternalData =*/
    false);
}","{
    return toStringInner(/* secure =*/
    true, /* includeInternalData =*/
    false, /*indent=*/
    null);
}",1,"/**
 * Return a string representation, intended for logging.  Some fields will be retracted.
 */
","/**
 * Return a string representation, intended for logging.  Some fields will be retracted.
 */
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,5,0,"The only change in the implementation is the addition of a new parameter to the `toStringInner` method call. There is no alteration in the behavior of the `toString` method itself since the returned value from `toStringInner` is still returned. However, this depends on whether the `toStringInner` implementation behaves differently with the new `indent` parameter set to `null`. Consequently, the code change type is 5.","Based on the information given, there is no direct evidence that the change in the parameter list for `toStringInner` will lead to a different return value or throw a new exception. The actual impact on compatibility depends on if the implementation of `toStringInner` would produce a different result. Since we don't have the implementation details for `toStringInner`, we cannot classify this as a Compatibility Issue. Therefore, the CI type is 0."
326,"<android.app.usage.UsageEvents: void writeToParcel(Parcel,int)>",27,28,"<android.app.usage.UsageEvents: void writeToParcel(Parcel,int)>","<android.app.usage.UsageEvents: void writeToParcel(Parcel,int)>",0,"{
    dest.writeInt(mEventCount);
    dest.writeInt(mIndex);
    if (mEventCount > 0) {
        dest.writeStringArray(mStringPool);
        if (mEventsToWrite != null) {
            // Write out the events
            Parcel p = Parcel.obtain();
            try {
                p.setDataPosition(0);
                for (int i = 0; i < mEventCount; i++) {
                    final Event event = mEventsToWrite.get(i);
                    writeEventToParcel(event, p, flags);
                }
                final int listByteLength = p.dataPosition();
                // Write the total length of the data.
                dest.writeInt(listByteLength);
                // Write our current position into the data.
                dest.writeInt(0);
                // Write the data.
                dest.appendFrom(p, 0, listByteLength);
            } finally {
                p.recycle();
            }
        } else if (mParcel != null) {
            // Write the total length of the data.
            dest.writeInt(mParcel.dataSize());
            // Write out current position into the data.
            dest.writeInt(mParcel.dataPosition());
            // Write the data.
            dest.appendFrom(mParcel, 0, mParcel.dataSize());
        } else {
            throw new IllegalStateException(""Either mParcel or mEventsToWrite must not be null"");
        }
    }
}","{
    Parcel data = Parcel.obtain();
    data.writeInt(mEventCount);
    data.writeInt(mIndex);
    if (mEventCount > 0) {
        data.writeStringArray(mStringPool);
        if (mEventsToWrite != null) {
            // Write out the events
            Parcel p = Parcel.obtain();
            try {
                p.setDataPosition(0);
                for (int i = 0; i < mEventCount; i++) {
                    final Event event = mEventsToWrite.get(i);
                    writeEventToParcel(event, p, flags);
                }
                final int listByteLength = p.dataPosition();
                // Write the total length of the data.
                data.writeInt(listByteLength);
                // Write our current position into the data.
                data.writeInt(0);
                // Write the data.
                data.appendFrom(p, 0, listByteLength);
            } finally {
                p.recycle();
            }
        } else if (mParcel != null) {
            // Write the total length of the data.
            data.writeInt(mParcel.dataSize());
            // Write out current position into the data.
            data.writeInt(mParcel.dataPosition());
            // Write the data.
            data.appendFrom(mParcel, 0, mParcel.dataSize());
        } else {
            throw new IllegalStateException(""Either mParcel or mEventsToWrite must not be null"");
        }
    }
    // Data can be too large for a transact. Write the data as a Blob, which will be written to
    // ashmem if too large.
    dest.writeBlob(data.marshall());
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"The method's internal implementation logic has changed with the addition of creating a new Parcel object for writing the data and subsequently writing it to the destination parcel as a Blob. However, the method signature and its expected behavior from the caller's perspective remain unaltered. This change is categorized as 4 (Other statement changed).","There is no Compatibility Issue since the method's input parameters, output type, behavior, and expected interactions with the method have not been altered. The method still performs the same action, which is writing the event to a parcel, just the internal mechanism has changed to manage large data. This does not affect how the method is called or the results it produces as observed by the caller. Therefore, the CI type is 0 (No Compatibility Issue)."
328,<android.view.View: boolean onTouchEvent(MotionEvent)>,27,28,<android.view.View: boolean onTouchEvent(MotionEvent)>,<android.view.View: boolean onTouchEvent(MotionEvent)>,0,"{
    final float x = event.getX();
    final float y = event.getY();
    final int viewFlags = mViewFlags;
    final int action = event.getAction();
    final boolean clickable = ((viewFlags & CLICKABLE) == CLICKABLE || (viewFlags & LONG_CLICKABLE) == LONG_CLICKABLE) || (viewFlags & CONTEXT_CLICKABLE) == CONTEXT_CLICKABLE;
    if ((viewFlags & ENABLED_MASK) == DISABLED) {
        if (action == MotionEvent.ACTION_UP && (mPrivateFlags & PFLAG_PRESSED) != 0) {
            setPressed(false);
        }
        mPrivateFlags3 &= ~PFLAG3_FINGER_DOWN;
        // events, it just doesn't respond to them.
        return clickable;
    }
    if (mTouchDelegate != null) {
        if (mTouchDelegate.onTouchEvent(event)) {
            return true;
        }
    }
    if (clickable || (viewFlags & TOOLTIP) == TOOLTIP) {
        switch(action) {
            case MotionEvent.ACTION_UP:
                mPrivateFlags3 &= ~PFLAG3_FINGER_DOWN;
                if ((viewFlags & TOOLTIP) == TOOLTIP) {
                    handleTooltipUp();
                }
                if (!clickable) {
                    removeTapCallback();
                    removeLongPressCallback();
                    mInContextButtonPress = false;
                    mHasPerformedLongPress = false;
                    mIgnoreNextUpEvent = false;
                    break;
                }
                boolean prepressed = (mPrivateFlags & PFLAG_PREPRESSED) != 0;
                if ((mPrivateFlags & PFLAG_PRESSED) != 0 || prepressed) {
                    // take focus if we don't have it already and we should in
                    // touch mode.
                    boolean focusTaken = false;
                    if (isFocusable() && isFocusableInTouchMode() && !isFocused()) {
                        focusTaken = requestFocus();
                    }
                    if (prepressed) {
                        // The button is being released before we actually
                        // showed it as pressed.  Make it show the pressed
                        // state now (before scheduling the click) to ensure
                        // the user sees it.
                        setPressed(true, x, y);
                    }
                    if (!mHasPerformedLongPress && !mIgnoreNextUpEvent) {
                        // This is a tap, so remove the longpress check
                        removeLongPressCallback();
                        // Only perform take click actions if we were in the pressed state
                        if (!focusTaken) {
                            // of the view update before click actions start.
                            if (mPerformClick == null) {
                                mPerformClick = new PerformClick();
                            }
                            if (!post(mPerformClick)) {
                                performClick();
                            }
                        }
                    }
                    if (mUnsetPressedState == null) {
                        mUnsetPressedState = new UnsetPressedState();
                    }
                    if (prepressed) {
                        postDelayed(mUnsetPressedState, ViewConfiguration.getPressedStateDuration());
                    } else if (!post(mUnsetPressedState)) {
                        // If the post failed, unpress right now
                        mUnsetPressedState.run();
                    }
                    removeTapCallback();
                }
                mIgnoreNextUpEvent = false;
                break;
            case MotionEvent.ACTION_DOWN:
                if (event.getSource() == InputDevice.SOURCE_TOUCHSCREEN) {
                    mPrivateFlags3 |= PFLAG3_FINGER_DOWN;
                }
                mHasPerformedLongPress = false;
                if (!clickable) {
                    checkForLongClick(0, x, y);
                    break;
                }
                if (performButtonActionOnTouchDown(event)) {
                    break;
                }
                // Walk up the hierarchy to determine if we're inside a scrolling container.
                boolean isInScrollingContainer = isInScrollingContainer();
                // a short period in case this is a scroll.
                if (isInScrollingContainer) {
                    mPrivateFlags |= PFLAG_PREPRESSED;
                    if (mPendingCheckForTap == null) {
                        mPendingCheckForTap = new CheckForTap();
                    }
                    mPendingCheckForTap.x = event.getX();
                    mPendingCheckForTap.y = event.getY();
                    postDelayed(mPendingCheckForTap, ViewConfiguration.getTapTimeout());
                } else {
                    // Not inside a scrolling container, so show the feedback right away
                    setPressed(true, x, y);
                    checkForLongClick(0, x, y);
                }
                break;
            case MotionEvent.ACTION_CANCEL:
                if (clickable) {
                    setPressed(false);
                }
                removeTapCallback();
                removeLongPressCallback();
                mInContextButtonPress = false;
                mHasPerformedLongPress = false;
                mIgnoreNextUpEvent = false;
                mPrivateFlags3 &= ~PFLAG3_FINGER_DOWN;
                break;
            case MotionEvent.ACTION_MOVE:
                if (clickable) {
                    drawableHotspotChanged(x, y);
                }
                // Be lenient about moving outside of buttons
                if (!pointInView(x, y, mTouchSlop)) {
                    // Outside button
                    // Remove any future long press/tap checks
                    removeTapCallback();
                    removeLongPressCallback();
                    if ((mPrivateFlags & PFLAG_PRESSED) != 0) {
                        setPressed(false);
                    }
                    mPrivateFlags3 &= ~PFLAG3_FINGER_DOWN;
                }
                break;
        }
        return true;
    }
    return false;
}","{
    final float x = event.getX();
    final float y = event.getY();
    final int viewFlags = mViewFlags;
    final int action = event.getAction();
    final boolean clickable = ((viewFlags & CLICKABLE) == CLICKABLE || (viewFlags & LONG_CLICKABLE) == LONG_CLICKABLE) || (viewFlags & CONTEXT_CLICKABLE) == CONTEXT_CLICKABLE;
    if ((viewFlags & ENABLED_MASK) == DISABLED) {
        if (action == MotionEvent.ACTION_UP && (mPrivateFlags & PFLAG_PRESSED) != 0) {
            setPressed(false);
        }
        mPrivateFlags3 &= ~PFLAG3_FINGER_DOWN;
        // events, it just doesn't respond to them.
        return clickable;
    }
    if (mTouchDelegate != null) {
        if (mTouchDelegate.onTouchEvent(event)) {
            return true;
        }
    }
    if (clickable || (viewFlags & TOOLTIP) == TOOLTIP) {
        switch(action) {
            case MotionEvent.ACTION_UP:
                mPrivateFlags3 &= ~PFLAG3_FINGER_DOWN;
                if ((viewFlags & TOOLTIP) == TOOLTIP) {
                    handleTooltipUp();
                }
                if (!clickable) {
                    removeTapCallback();
                    removeLongPressCallback();
                    mInContextButtonPress = false;
                    mHasPerformedLongPress = false;
                    mIgnoreNextUpEvent = false;
                    break;
                }
                boolean prepressed = (mPrivateFlags & PFLAG_PREPRESSED) != 0;
                if ((mPrivateFlags & PFLAG_PRESSED) != 0 || prepressed) {
                    // take focus if we don't have it already and we should in
                    // touch mode.
                    boolean focusTaken = false;
                    if (isFocusable() && isFocusableInTouchMode() && !isFocused()) {
                        focusTaken = requestFocus();
                    }
                    if (prepressed) {
                        // The button is being released before we actually
                        // showed it as pressed.  Make it show the pressed
                        // state now (before scheduling the click) to ensure
                        // the user sees it.
                        setPressed(true, x, y);
                    }
                    if (!mHasPerformedLongPress && !mIgnoreNextUpEvent) {
                        // This is a tap, so remove the longpress check
                        removeLongPressCallback();
                        // Only perform take click actions if we were in the pressed state
                        if (!focusTaken) {
                            // of the view update before click actions start.
                            if (mPerformClick == null) {
                                mPerformClick = new PerformClick();
                            }
                            if (!post(mPerformClick)) {
                                performClickInternal();
                            }
                        }
                    }
                    if (mUnsetPressedState == null) {
                        mUnsetPressedState = new UnsetPressedState();
                    }
                    if (prepressed) {
                        postDelayed(mUnsetPressedState, ViewConfiguration.getPressedStateDuration());
                    } else if (!post(mUnsetPressedState)) {
                        // If the post failed, unpress right now
                        mUnsetPressedState.run();
                    }
                    removeTapCallback();
                }
                mIgnoreNextUpEvent = false;
                break;
            case MotionEvent.ACTION_DOWN:
                if (event.getSource() == InputDevice.SOURCE_TOUCHSCREEN) {
                    mPrivateFlags3 |= PFLAG3_FINGER_DOWN;
                }
                mHasPerformedLongPress = false;
                if (!clickable) {
                    checkForLongClick(0, x, y);
                    break;
                }
                if (performButtonActionOnTouchDown(event)) {
                    break;
                }
                // Walk up the hierarchy to determine if we're inside a scrolling container.
                boolean isInScrollingContainer = isInScrollingContainer();
                // a short period in case this is a scroll.
                if (isInScrollingContainer) {
                    mPrivateFlags |= PFLAG_PREPRESSED;
                    if (mPendingCheckForTap == null) {
                        mPendingCheckForTap = new CheckForTap();
                    }
                    mPendingCheckForTap.x = event.getX();
                    mPendingCheckForTap.y = event.getY();
                    postDelayed(mPendingCheckForTap, ViewConfiguration.getTapTimeout());
                } else {
                    // Not inside a scrolling container, so show the feedback right away
                    setPressed(true, x, y);
                    checkForLongClick(0, x, y);
                }
                break;
            case MotionEvent.ACTION_CANCEL:
                if (clickable) {
                    setPressed(false);
                }
                removeTapCallback();
                removeLongPressCallback();
                mInContextButtonPress = false;
                mHasPerformedLongPress = false;
                mIgnoreNextUpEvent = false;
                mPrivateFlags3 &= ~PFLAG3_FINGER_DOWN;
                break;
            case MotionEvent.ACTION_MOVE:
                if (clickable) {
                    drawableHotspotChanged(x, y);
                }
                // Be lenient about moving outside of buttons
                if (!pointInView(x, y, mTouchSlop)) {
                    // Outside button
                    // Remove any future long press/tap checks
                    removeTapCallback();
                    removeLongPressCallback();
                    if ((mPrivateFlags & PFLAG_PRESSED) != 0) {
                        setPressed(false);
                    }
                    mPrivateFlags3 &= ~PFLAG3_FINGER_DOWN;
                }
                break;
        }
        return true;
    }
    return false;
}",1,"/**
 * Implement this method to handle touch screen motion events.
 * <p>
 * If this method is used to detect click actions, it is recommended that
 * the actions be performed by implementing and calling
 * {@link #performClick()}. This will ensure consistent system behavior,
 * including:
 * <ul>
 * <li>obeying click sound preferences
 * <li>dispatching OnClickListener calls
 * <li>handling {@link AccessibilityNodeInfo#ACTION_CLICK ACTION_CLICK} when
 * accessibility features are enabled
 * </ul>
 *
 * @param event The motion event.
 * @return True if the event was handled, false otherwise.
 */
","/**
 * Implement this method to handle touch screen motion events.
 * <p>
 * If this method is used to detect click actions, it is recommended that
 * the actions be performed by implementing and calling
 * {@link #performClick()}. This will ensure consistent system behavior,
 * including:
 * <ul>
 * <li>obeying click sound preferences
 * <li>dispatching OnClickListener calls
 * <li>handling {@link AccessibilityNodeInfo#ACTION_CLICK ACTION_CLICK} when
 * accessibility features are enabled
 * </ul>
 *
 * @param event The motion event.
 * @return True if the event was handled, false otherwise.
 */
",-1,,,-1,-1,-1,-1,-1,-1,,,,
329,"<android.content.res.TypedArray: int getColor(int,int)>",27,28,"<android.content.res.TypedArray: int getColor(int,int)>","<android.content.res.TypedArray: int getColor(int,int)>",0,"{
    if (mRecycled) {
        throw new RuntimeException(""Cannot make calls to a recycled instance!"");
    }
    final int attrIndex = index;
    index *= AssetManager.STYLE_NUM_ENTRIES;
    final int[] data = mData;
    final int type = data[index + AssetManager.STYLE_TYPE];
    if (type == TypedValue.TYPE_NULL) {
        return defValue;
    } else if (type >= TypedValue.TYPE_FIRST_INT && type <= TypedValue.TYPE_LAST_INT) {
        return data[index + AssetManager.STYLE_DATA];
    } else if (type == TypedValue.TYPE_STRING) {
        final TypedValue value = mValue;
        if (getValueAt(index, value)) {
            final ColorStateList csl = mResources.loadColorStateList(value, value.resourceId, mTheme);
            return csl.getDefaultColor();
        }
        return defValue;
    } else if (type == TypedValue.TYPE_ATTRIBUTE) {
        final TypedValue value = mValue;
        getValueAt(index, value);
        throw new UnsupportedOperationException(""Failed to resolve attribute at index "" + attrIndex + "": "" + value);
    }
    throw new UnsupportedOperationException(""Can't convert value at index "" + attrIndex + "" to color: type=0x"" + Integer.toHexString(type));
}","{
    if (mRecycled) {
        throw new RuntimeException(""Cannot make calls to a recycled instance!"");
    }
    final int attrIndex = index;
    index *= STYLE_NUM_ENTRIES;
    final int[] data = mData;
    final int type = data[index + STYLE_TYPE];
    if (type == TypedValue.TYPE_NULL) {
        return defValue;
    } else if (type >= TypedValue.TYPE_FIRST_INT && type <= TypedValue.TYPE_LAST_INT) {
        return data[index + STYLE_DATA];
    } else if (type == TypedValue.TYPE_STRING) {
        final TypedValue value = mValue;
        if (getValueAt(index, value)) {
            final ColorStateList csl = mResources.loadColorStateList(value, value.resourceId, mTheme);
            return csl.getDefaultColor();
        }
        return defValue;
    } else if (type == TypedValue.TYPE_ATTRIBUTE) {
        final TypedValue value = mValue;
        getValueAt(index, value);
        throw new UnsupportedOperationException(""Failed to resolve attribute at index "" + attrIndex + "": "" + value);
    }
    throw new UnsupportedOperationException(""Can't convert value at index "" + attrIndex + "" to color: type=0x"" + Integer.toHexString(type));
}",1,"/**
 * Retrieve the color value for the attribute at <var>index</var>.  If
 * the attribute references a color resource holding a complex
 * {@link android.content.res.ColorStateList}, then the default color from
 * the set is returned.
 * <p>
 * This method will throw an exception if the attribute is defined but is
 * not an integer color or color state list.
 *
 * @param index Index of attribute to retrieve.
 * @param defValue Value to return if the attribute is not defined or
 * not a resource.
 *
 * @return Attribute color value, or defValue if not defined.
 * @throws RuntimeException if the TypedArray has already been recycled.
 * @throws UnsupportedOperationException if the attribute is defined but is
 * not an integer color or color state list.
 */
","/**
 * Retrieve the color value for the attribute at <var>index</var>.  If
 * the attribute references a color resource holding a complex
 * {@link android.content.res.ColorStateList}, then the default color from
 * the set is returned.
 * <p>
 * This method will throw an exception if the attribute is defined but is
 * not an integer color or color state list.
 *
 * @param index Index of attribute to retrieve.
 * @param defValue Value to return if the attribute is not defined or
 * not a resource.
 *
 * @return Attribute color value, or defValue if not defined.
 * @throws RuntimeException if the TypedArray has already been recycled.
 * @throws UnsupportedOperationException if the attribute is defined but is
 * not an integer color or color state list.
 */
",-1,[@ColorInt],[@ColorInt],-1,-1,-1,-1,-1,-1,0,0,"No code changes are detected between the early and the late versions of the implementation, so the code change type is 0.","There are no changes in the implementation, meaning there are no compatibility issues. Thus, the CI type is 0."
330,<android.hardware.SensorManager: List<Sensor> getSensorList(int)>,27,28,<android.hardware.SensorManager: List<Sensor> getSensorList(int)>,<android.hardware.SensorManager: List<Sensor> getSensorList(int)>,0,"{
    // cache the returned lists the first time
    List<Sensor> list;
    final List<Sensor> fullList = getFullSensorList();
    synchronized (mSensorListByType) {
        list = mSensorListByType.get(type);
        if (list == null) {
            if (type == Sensor.TYPE_ALL) {
                list = fullList;
            } else {
                list = new ArrayList<Sensor>();
                for (Sensor i : fullList) {
                    if (i.getType() == type)
                        list.add(i);
                }
            }
            list = Collections.unmodifiableList(list);
            mSensorListByType.append(type, list);
        }
    }
    return list;
}","{
    // cache the returned lists the first time
    List<Sensor> list;
    final List<Sensor> fullList = getFullSensorList();
    synchronized (mSensorListByType) {
        list = mSensorListByType.get(type);
        if (list == null) {
            if (type == Sensor.TYPE_ALL) {
                list = fullList;
            } else {
                list = new ArrayList<Sensor>();
                for (Sensor i : fullList) {
                    if (i.getType() == type) {
                        list.add(i);
                    }
                }
            }
            list = Collections.unmodifiableList(list);
            mSensorListByType.append(type, list);
        }
    }
    return list;
}",1,"/**
 * Use this method to get the list of available sensors of a certain type.
 * Make multiple calls to get sensors of different types or use
 * {@link android.hardware.Sensor#TYPE_ALL Sensor.TYPE_ALL} to get all the
 * sensors.
 *
 * <p class=""note"">
 * NOTE: Both wake-up and non wake-up sensors matching the given type are
 * returned. Check {@link Sensor#isWakeUpSensor()} to know the wake-up properties
 * of the returned {@link Sensor}.
 * </p>
 *
 * @param type
 * of sensors requested
 *
 * @return a list of sensors matching the asked type.
 *
 * @see #getDefaultSensor(int)
 * @see Sensor
 */
","/**
 * Use this method to get the list of available sensors of a certain type.
 * Make multiple calls to get sensors of different types or use
 * {@link android.hardware.Sensor#TYPE_ALL Sensor.TYPE_ALL} to get all the
 * sensors.
 *
 * <p class=""note"">
 * NOTE: Both wake-up and non wake-up sensors matching the given type are
 * returned. Check {@link Sensor#isWakeUpSensor()} to know the wake-up properties
 * of the returned {@link Sensor}.
 * </p>
 *
 * @param type
 * of sensors requested
 *
 * @return a list of sensors matching the asked type.
 *
 * @see #getDefaultSensor(int)
 * @see Sensor
 */
",-1,,,-1,-1,-1,-1,-1,-1,0,0,There is no change in the implementation between the early version and the late version. The code is identical in both versions.,"Since there is no change in the implementation between the versions, there is no potential Compatibility Issue."
331,"<android.content.res.AssetManager: AssetFileDescriptor openNonAssetFd(int,String)>",27,28,"<android.content.res.AssetManager: AssetFileDescriptor openNonAssetFd(int,String)>","<android.content.res.AssetManager: AssetFileDescriptor openNonAssetFd(int,String)>",0,"{
    synchronized (this) {
        if (!mOpen) {
            throw new RuntimeException(""Assetmanager has been closed"");
        }
        ParcelFileDescriptor pfd = openNonAssetFdNative(cookie, fileName, mOffsets);
        if (pfd != null) {
            return new AssetFileDescriptor(pfd, mOffsets[0], mOffsets[1]);
        }
    }
    throw new FileNotFoundException(""Asset absolute file: "" + fileName);
}","{
    Preconditions.checkNotNull(fileName, ""fileName"");
    synchronized (this) {
        ensureOpenLocked();
        final ParcelFileDescriptor pfd = nativeOpenNonAssetFd(mObject, cookie, fileName, mOffsets);
        if (pfd == null) {
            throw new FileNotFoundException(""Asset absolute file: "" + fileName);
        }
        return new AssetFileDescriptor(pfd, mOffsets[0], mOffsets[1]);
    }
}",1,,"/**
 * Open a non-asset as an asset by mmapping it and returning an {@link AssetFileDescriptor}.
 * This provides direct access to all of the files included in an application
 * package (not only its assets).  Applications should not normally use this.
 *
 * The asset must not be compressed, or an exception will be thrown.
 *
 * @param cookie Identifier of the package to be opened.
 * @param fileName Name of the asset to retrieve.
 */
",-1,,[@NonNull],-1,-1,-1,-1,-1,-1,"1,2,3,4,5","1,2","The implementation has introduced new checks, new exception handling, and a new method call. The new call to Preconditions.checkNotNull() can throw a NullPointerException which is a new change in exception handling, and a call to ensureOpenLocked() replaces a manual check for mOpen which changes the control dependency and others. Also, the method name openNonAssetFdNative has been changed to nativeOpenNonAssetFd, which is a dependent API change. The position of FileNotFoundException has moved and is now thrown only if pfd == null. This represents changes in return statements, exception handling, control dependency, other statements, and dependent API change.","The new precondition check for fileName introduces a new possible NullPointerException which was not present before, creating a new Compatibility Issue of type 2. The method call changes, removal of the RuntimeException, and addition of FileNotFoundException at a different logic point introduce issues with potential different return values (FileNotFound being thrown where previously a return could occur), which is a Compatibility Issue of type 1."
332,<android.app.Activity: void setPictureInPictureParams(PictureInPictureParams)>,27,28,<android.app.Activity: void setPictureInPictureParams(PictureInPictureParams)>,<android.app.Activity: void setPictureInPictureParams(PictureInPictureParams)>,0,"{
    try {
        if (params == null) {
            throw new IllegalArgumentException(""Expected non-null picture-in-picture params"");
        }
        ActivityManagerNative.getDefault().setPictureInPictureParams(mToken, params);
    } catch (RemoteException e) {
    }
}","{
    try {
        if (!deviceSupportsPictureInPictureMode()) {
            return;
        }
        if (params == null) {
            throw new IllegalArgumentException(""Expected non-null picture-in-picture params"");
        }
        ActivityManagerNative.getDefault().setPictureInPictureParams(mToken, params);
    } catch (RemoteException e) {
    }
}",1,"/**
 * Updates the properties of the picture-in-picture activity, or sets it to be used later when
 * {@link #enterPictureInPictureMode()} is called.
 *
 * @param params the new parameters for the picture-in-picture.
 */
","/**
 * Updates the properties of the picture-in-picture activity, or sets it to be used later when
 * {@link #enterPictureInPictureMode()} is called.
 *
 * @param params the new parameters for the picture-in-picture.
 */
",-1,,,-1,-1,-1,-1,-1,-1,3,0,"A new `if` control dependency has been introduced before the existing null check for the `params`, checking `deviceSupportsPictureInPictureMode` and then returning early if this condition is not met. Therefore, the code change type is 3.","The introduction of the new device support check does not inherently change the return type or the exceptions thrown, since the method signature indicates it returns `void` and the only exception handling present is for `RemoteException`, which remains unchanged. The behavior change would prevent the method from proceeding in cases where the device does not support picture-in-picture mode, but this is an intended control flow alteration, not an incompatibility issue as per the given API behavior. If a device did not support picture-in-picture mode previously, the method would have resulted in an undefined state or error, which the new check aims to prevent gracefully. Thus, there is no Compatibility Issue as it does not introduce a change to the value or type of variables returned or the exceptions thrown by the method."
333,"<android.hardware.camera2.impl.CameraCaptureSessionImpl: int captureBurst(List<CaptureRequest>,CaptureCallback,Handler)>",27,28,"<android.hardware.camera2.impl.CameraCaptureSessionImpl: int captureBurst(List<CaptureRequest>,CaptureCallback,Handler)>","<android.hardware.camera2.impl.CameraCaptureSessionImpl: int captureBurst(List<CaptureRequest>,CaptureCallback,Handler)>",0,"{
    if (requests == null) {
        throw new IllegalArgumentException(""Requests must not be null"");
    } else if (requests.isEmpty()) {
        throw new IllegalArgumentException(""Requests must have at least one element"");
    }
    for (CaptureRequest request : requests) {
        if (request.isReprocess()) {
            if (!isReprocessable()) {
                throw new IllegalArgumentException(""This capture session cannot handle "" + ""reprocess requests"");
            } else if (request.getReprocessableSessionId() != mId) {
                throw new IllegalArgumentException(""Capture request was created for another "" + ""session"");
            }
        }
    }
    synchronized (mDeviceImpl.mInterfaceLock) {
        checkNotClosed();
        handler = checkHandler(handler, callback);
        if (DEBUG) {
            CaptureRequest[] requestArray = requests.toArray(new CaptureRequest[0]);
            Log.v(TAG, mIdString + ""captureBurst - requests "" + Arrays.toString(requestArray) + "", callback "" + callback + "" handler "" + handler);
        }
        return addPendingSequence(mDeviceImpl.captureBurst(requests, createCaptureCallbackProxy(handler, callback), mDeviceHandler));
    }
}","{
    checkCaptureRequests(requests);
    synchronized (mDeviceImpl.mInterfaceLock) {
        checkNotClosed();
        handler = checkHandler(handler, callback);
        if (DEBUG) {
            CaptureRequest[] requestArray = requests.toArray(new CaptureRequest[0]);
            Log.v(TAG, mIdString + ""captureBurst - requests "" + Arrays.toString(requestArray) + "", callback "" + callback + "" handler "" + handler);
        }
        return addPendingSequence(mDeviceImpl.captureBurst(requests, createCaptureCallbackProxy(handler, callback), mDeviceExecutor));
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"4,5",1,"The early implementation includes checks for the validity of the 'requests' list and the reprocessability of each 'CaptureRequest', while the late implementation substitutes this check with a single method call 'checkCaptureRequests(requests)'. Additionally, 'mDeviceHandler' is replaced with 'mDeviceExecutor' in the method call. The code change types are 4,5.","The substitution of the request validation code with a method call could potentially alter the behavior of the API if 'checkCaptureRequests' has a different implementation than the inline validation. Changing 'mDeviceHandler' to 'mDeviceExecutor' could change the thread on which the execution takes place, leading to potential behavioral differences. Therefore, the CI type is 1."
334,"<android.content.res.TypedArray: int getInt(int,int)>",27,28,"<android.content.res.TypedArray: int getInt(int,int)>","<android.content.res.TypedArray: int getInt(int,int)>",0,"{
    if (mRecycled) {
        throw new RuntimeException(""Cannot make calls to a recycled instance!"");
    }
    index *= AssetManager.STYLE_NUM_ENTRIES;
    final int[] data = mData;
    final int type = data[index + AssetManager.STYLE_TYPE];
    if (type == TypedValue.TYPE_NULL) {
        return defValue;
    } else if (type >= TypedValue.TYPE_FIRST_INT && type <= TypedValue.TYPE_LAST_INT) {
        return data[index + AssetManager.STYLE_DATA];
    }
    final TypedValue v = mValue;
    if (getValueAt(index, v)) {
        StrictMode.noteResourceMismatch(v);
        return XmlUtils.convertValueToInt(v.coerceToString(), defValue);
    }
    // We already checked for TYPE_NULL. This should never happen.
    throw new RuntimeException(""getInt of bad type: 0x"" + Integer.toHexString(type));
}","{
    if (mRecycled) {
        throw new RuntimeException(""Cannot make calls to a recycled instance!"");
    }
    index *= STYLE_NUM_ENTRIES;
    final int[] data = mData;
    final int type = data[index + STYLE_TYPE];
    if (type == TypedValue.TYPE_NULL) {
        return defValue;
    } else if (type >= TypedValue.TYPE_FIRST_INT && type <= TypedValue.TYPE_LAST_INT) {
        return data[index + STYLE_DATA];
    }
    final TypedValue v = mValue;
    if (getValueAt(index, v)) {
        StrictMode.noteResourceMismatch(v);
        return XmlUtils.convertValueToInt(v.coerceToString(), defValue);
    }
    // We already checked for TYPE_NULL. This should never happen.
    throw new RuntimeException(""getInt of bad type: 0x"" + Integer.toHexString(type));
}",1,"/**
 * Retrieve the integer value for the attribute at <var>index</var>.
 * <p>
 * If the attribute is not an integer, this method will attempt to coerce
 * it to an integer using {@link Integer#decode(String)}.
 *
 * @param index Index of attribute to retrieve.
 * @param defValue Value to return if the attribute is not defined or
 * cannot be coerced to an integer.
 *
 * @return Integer value of the attribute, or defValue if the attribute was
 * not defined or could not be coerced to an integer.
 * @throws RuntimeException if the TypedArray has already been recycled.
 */
","/**
 * Retrieve the integer value for the attribute at <var>index</var>.
 * <p>
 * If the attribute is not an integer, this method will attempt to coerce
 * it to an integer using {@link Integer#decode(String)}.
 *
 * @param index Index of attribute to retrieve.
 * @param defValue Value to return if the attribute is not defined or
 * cannot be coerced to an integer.
 *
 * @return Integer value of the attribute, or defValue if the attribute was
 * not defined or could not be coerced to an integer.
 * @throws RuntimeException if the TypedArray has already been recycled.
 */
",-1,,,-1,-1,-1,-1,-1,-1,0,0,There is no actual change in the implementation code between the two versions.,No Compatibility Issue could arise since there is no change in the code.
336,<android.hardware.radio.RadioManager.ProgramInfo: boolean isLive()>,27,28,<android.hardware.radio.RadioManager.ProgramInfo: boolean isLive()>,<android.hardware.radio.RadioManager.ProgramInfo: boolean isLive()>,0,"{
    return (mFlags & FLAG_LIVE) != 0;
}","{
    return (mInfoFlags & FLAG_LIVE) != 0;
}",1,"/**
 * {@code true} if the program is currently playing live stream.
 * This may result in a slightly altered reception parameters,
 * usually targetted at reduced latency.
 */
","/**
 * {@code true} if the program is currently playing live stream.
 * This may result in a slightly altered reception parameters,
 * usually targetted at reduced latency.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The change is only related to the variable from which a flag is checked: mFlags changed to mInfoFlags. Since the logic of determining the 'isLive' state hasn't changed, the change type is 4.","There are no changes in return types, exception handling, or control flow which can cause compatibility issues. Assuming that mInfoFlags is correctly representing the same flags that were previously held in mFlags, the behavior of the method remains the same. Hence, there's no compatibility issue."
337,<android.bluetooth.BluetoothDevice: BluetoothSocket createRfcommSocketToServiceRecord(UUID)>,27,28,<android.bluetooth.BluetoothDevice: BluetoothSocket createRfcommSocketToServiceRecord(UUID)>,<android.bluetooth.BluetoothDevice: BluetoothSocket createRfcommSocketToServiceRecord(UUID)>,0,"{
    if (isBluetoothEnabled() == false) {
        Log.e(TAG, ""Bluetooth is not enabled"");
        throw new IOException();
    }
    return new BluetoothSocket(BluetoothSocket.TYPE_RFCOMM, -1, true, true, this, -1, new ParcelUuid(uuid));
}","{
    if (!isBluetoothEnabled()) {
        Log.e(TAG, ""Bluetooth is not enabled"");
        throw new IOException();
    }
    return new BluetoothSocket(BluetoothSocket.TYPE_RFCOMM, -1, true, true, this, -1, new ParcelUuid(uuid));
}",1,"/**
 * Create an RFCOMM {@link BluetoothSocket} ready to start a secure
 * outgoing connection to this remote device using SDP lookup of uuid.
 * <p>This is designed to be used with {@link
 * BluetoothAdapter#listenUsingRfcommWithServiceRecord} for peer-peer
 * Bluetooth applications.
 * <p>Use {@link BluetoothSocket#connect} to initiate the outgoing
 * connection. This will also perform an SDP lookup of the given uuid to
 * determine which channel to connect to.
 * <p>The remote device will be authenticated and communication on this
 * socket will be encrypted.
 * <p> Use this socket only if an authenticated socket link is possible.
 * Authentication refers to the authentication of the link key to
 * prevent man-in-the-middle type of attacks.
 * For example, for Bluetooth 2.1 devices, if any of the devices does not
 * have an input and output capability or just has the ability to
 * display a numeric key, a secure socket connection is not possible.
 * In such a case, use {#link createInsecureRfcommSocketToServiceRecord}.
 * For more details, refer to the Security Model section 5.2 (vol 3) of
 * Bluetooth Core Specification version 2.1 + EDR.
 * <p>Hint: If you are connecting to a Bluetooth serial board then try
 * using the well-known SPP UUID 00001101-0000-1000-8000-00805F9B34FB.
 * However if you are connecting to an Android peer then please generate
 * your own unique UUID.
 *
 * @param uuid service record uuid to lookup RFCOMM channel
 * @return a RFCOMM BluetoothServerSocket ready for an outgoing connection
 * @throws IOException on error, for example Bluetooth not available, or
 * insufficient permissions
 */
","/**
 * Create an RFCOMM {@link BluetoothSocket} ready to start a secure
 * outgoing connection to this remote device using SDP lookup of uuid.
 * <p>This is designed to be used with {@link
 * BluetoothAdapter#listenUsingRfcommWithServiceRecord} for peer-peer
 * Bluetooth applications.
 * <p>Use {@link BluetoothSocket#connect} to initiate the outgoing
 * connection. This will also perform an SDP lookup of the given uuid to
 * determine which channel to connect to.
 * <p>The remote device will be authenticated and communication on this
 * socket will be encrypted.
 * <p> Use this socket only if an authenticated socket link is possible.
 * Authentication refers to the authentication of the link key to
 * prevent man-in-the-middle type of attacks.
 * For example, for Bluetooth 2.1 devices, if any of the devices does not
 * have an input and output capability or just has the ability to
 * display a numeric key, a secure socket connection is not possible.
 * In such a case, use {#link createInsecureRfcommSocketToServiceRecord}.
 * For more details, refer to the Security Model section 5.2 (vol 3) of
 * Bluetooth Core Specification version 2.1 + EDR.
 * <p>Hint: If you are connecting to a Bluetooth serial board then try
 * using the well-known SPP UUID 00001101-0000-1000-8000-00805F9B34FB.
 * However if you are connecting to an Android peer then please generate
 * your own unique UUID.
 *
 * @param uuid service record uuid to lookup RFCOMM channel
 * @return a RFCOMM BluetoothServerSocket ready for an outgoing connection
 * @throws IOException on error, for example Bluetooth not available, or insufficient
 * permissions
 */
",-1,[@RequiresPermission(Manifest.permission.BLUETOOTH)],[@RequiresPermission(Manifest.permission.BLUETOOTH)],-1,-1,-1,-1,-1,-1,0,0,"The only change is in the if statement where ""isBluetoothEnabled() == false"" has been replaced by ""!isBluetoothEnabled()"", which is logically equivalent and does not alter the program's behavior. There are no changes in the return statement, exception handling, control dependency, or any other code statements, and the dependent APIs remain unchanged.",There are no compatibility issues as the change is purely syntactical and doesn't affect the return value or exceptions thrown by the method. The behavior of the API remains identical between the two versions.
338,<android.net.LinkProperties: int hashCode()>,27,28,<android.net.LinkProperties: int hashCode()>,<android.net.LinkProperties: int hashCode()>,0,"{
    return ((null == mIfaceName) ? 0 : mIfaceName.hashCode() + mLinkAddresses.size() * 31 + mDnses.size() * 37 + ((null == mDomains) ? 0 : mDomains.hashCode()) + mRoutes.size() * 41 + ((null == mHttpProxy) ? 0 : mHttpProxy.hashCode()) + mStackedLinks.hashCode() * 47) + mMtu * 51 + ((null == mTcpBufferSizes) ? 0 : mTcpBufferSizes.hashCode());
}","{
    return ((null == mIfaceName) ? 0 : mIfaceName.hashCode() + mLinkAddresses.size() * 31 + mDnses.size() * 37 + mValidatedPrivateDnses.size() * 61 + ((null == mDomains) ? 0 : mDomains.hashCode()) + mRoutes.size() * 41 + ((null == mHttpProxy) ? 0 : mHttpProxy.hashCode()) + mStackedLinks.hashCode() * 47) + mMtu * 51 + ((null == mTcpBufferSizes) ? 0 : mTcpBufferSizes.hashCode()) + (mUsePrivateDns ? 57 : 0) + ((null == mPrivateDnsServerName) ? 0 : mPrivateDnsServerName.hashCode());
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,4",1,"The hashCode computation has changed in the late version by adding mValidatedPrivateDnses.size() * 61, mUsePrivateDns ? 57 : 0 and a conditional statement for mPrivateDnsServerName.hashCode(). Since hashCode computation is altered by including additional fields and corresponding coefficients, the change types are 1 and 4.","The modified hashCode method will produce different hash codes for the same object between these two versions if mValidatedPrivateDnses, mUsePrivateDns, or mPrivateDnsServerName are not null or differ in size. It constitutes a Compatibility Issue since objects that were considered equal in the previous version may not be considered equal in the new version, and vice versa, so the CI type is 1."
339,"<android.view.View: WindowInsets computeSystemWindowInsets(WindowInsets,Rect)>",27,28,"<android.view.View: WindowInsets computeSystemWindowInsets(WindowInsets,Rect)>","<android.view.View: WindowInsets computeSystemWindowInsets(WindowInsets,Rect)>",0,"{
    if ((mViewFlags & OPTIONAL_FITS_SYSTEM_WINDOWS) == 0 || mAttachInfo == null || (mAttachInfo.mSystemUiVisibility & SYSTEM_UI_LAYOUT_FLAGS) == 0) {
        outLocalInsets.set(in.getSystemWindowInsets());
        return in.consumeSystemWindowInsets();
    } else {
        outLocalInsets.set(0, 0, 0, 0);
        return in;
    }
}","{
    if ((mViewFlags & OPTIONAL_FITS_SYSTEM_WINDOWS) == 0 || mAttachInfo == null || ((mAttachInfo.mSystemUiVisibility & SYSTEM_UI_LAYOUT_FLAGS) == 0 && !mAttachInfo.mOverscanRequested)) {
        outLocalInsets.set(in.getSystemWindowInsets());
        return in.consumeSystemWindowInsets().inset(outLocalInsets);
    } else {
        // The application wants to take care of fitting system window for
        // the content...  however we still need to take care of any overscan here.
        final Rect overscan = mAttachInfo.mOverscanInsets;
        outLocalInsets.set(overscan);
        return in.inset(outLocalInsets);
    }
}",1,"/**
 * Compute insets that should be consumed by this view and the ones that should propagate
 * to those under it.
 *
 * @param in Insets currently being processed by this View, likely received as a parameter
 * to {@link #onApplyWindowInsets(WindowInsets)}.
 * @param outLocalInsets A Rect that will receive the insets that should be consumed
 * by this view
 * @return Insets that should be passed along to views under this one
 */
","/**
 * Compute insets that should be consumed by this view and the ones that should propagate
 * to those under it.
 *
 * @param in Insets currently being processed by this View, likely received as a parameter
 * to {@link #onApplyWindowInsets(WindowInsets)}.
 * @param outLocalInsets A Rect that will receive the insets that should be consumed
 * by this view
 * @return Insets that should be passed along to views under this one
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3",1,"The conditional check within the if statement has been augmented with an additional condition (mAttachInfo.mOverscanRequested) also there are changes to the return statement with the inclusion of the inset function on the in object making the code change types 1,3.","As there are changes to the conditional logic that determine which branch of the if statement will execute, and the return statements have been altered to include additional calls/methods (e.g., in.consumeSystemWindowInsets().inset(outLocalInsets) and in.inset(outLocalInsets)), it is possible that the API will return a different object with potentially different state or modifications, indicating a CI type 1."
340,<android.view.textclassifier.TextClassification: String getEntity(int)>,27,28,<android.view.textclassifier.TextClassification: String getEntity(int)>,<android.view.textclassifier.TextClassification: String getEntity(int)>,0,"{
    return mEntities.get(index);
}","{
    return mEntityConfidence.getEntities().get(index);
}",1,"/**
 * Returns the entity at the specified index. Entities are ordered from high confidence
 * to low confidence.
 *
 * @throws IndexOutOfBoundsException if the specified index is out of range.
 * @see #getEntityCount() for the number of entities available.
 */
","/**
 * Returns the entity at the specified index. Entities are ordered from high confidence
 * to low confidence.
 *
 * @throws IndexOutOfBoundsException if the specified index is out of range.
 * @see #getEntityCount() for the number of entities available.
 */
",-1,"[@NonNull, @EntityType]","[@NonNull, @EntityType]",-1,-1,-1,-1,-1,-1,5,0,"The implementation has changed because the source of the entities has changed from mEntities.get(index) to mEntityConfidence.getEntities().get(index), which means a dependent API change, so the code change type is 5.","The change involves altering which object's method is being called to obtain the entity. However, the returned data type (String) and the method signature remain the same. Since there is no indication that the behavior has changed in a way that would result in a different value, exception being thrown, or different return type, and it still non-nullably returns an entity of type @EntityType, there is no compatibility issue, so the CI type is 0."
342,<android.content.Intent: String toUri(int)>,27,28,<android.content.Intent: String toUri(int)>,<android.content.Intent: String toUri(int)>,0,"{
    StringBuilder uri = new StringBuilder(128);
    if ((flags & URI_ANDROID_APP_SCHEME) != 0) {
        if (mPackage == null) {
            throw new IllegalArgumentException(""Intent must include an explicit package name to build an android-app: "" + this);
        }
        uri.append(""android-app://"");
        uri.append(mPackage);
        String scheme = null;
        if (mData != null) {
            scheme = mData.getScheme();
            if (scheme != null) {
                uri.append('/');
                uri.append(scheme);
                String authority = mData.getEncodedAuthority();
                if (authority != null) {
                    uri.append('/');
                    uri.append(authority);
                    String path = mData.getEncodedPath();
                    if (path != null) {
                        uri.append(path);
                    }
                    String queryParams = mData.getEncodedQuery();
                    if (queryParams != null) {
                        uri.append('?');
                        uri.append(queryParams);
                    }
                    String fragment = mData.getEncodedFragment();
                    if (fragment != null) {
                        uri.append('#');
                        uri.append(fragment);
                    }
                }
            }
        }
        toUriFragment(uri, null, scheme == null ? Intent.ACTION_MAIN : Intent.ACTION_VIEW, mPackage, flags);
        return uri.toString();
    }
    String scheme = null;
    if (mData != null) {
        String data = mData.toString();
        if ((flags & URI_INTENT_SCHEME) != 0) {
            final int N = data.length();
            for (int i = 0; i < N; i++) {
                char c = data.charAt(i);
                if ((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || c == '.' || c == '-') {
                    continue;
                }
                if (c == ':' && i > 0) {
                    // Valid scheme.
                    scheme = data.substring(0, i);
                    uri.append(""intent:"");
                    data = data.substring(i + 1);
                    break;
                }
                // No scheme.
                break;
            }
        }
        uri.append(data);
    } else if ((flags & URI_INTENT_SCHEME) != 0) {
        uri.append(""intent:"");
    }
    toUriFragment(uri, scheme, Intent.ACTION_VIEW, null, flags);
    return uri.toString();
}","{
    StringBuilder uri = new StringBuilder(128);
    if ((flags & URI_ANDROID_APP_SCHEME) != 0) {
        if (mPackage == null) {
            throw new IllegalArgumentException(""Intent must include an explicit package name to build an android-app: "" + this);
        }
        uri.append(""android-app://"");
        uri.append(mPackage);
        String scheme = null;
        if (mData != null) {
            scheme = mData.getScheme();
            if (scheme != null) {
                uri.append('/');
                uri.append(scheme);
                String authority = mData.getEncodedAuthority();
                if (authority != null) {
                    uri.append('/');
                    uri.append(authority);
                    String path = mData.getEncodedPath();
                    if (path != null) {
                        uri.append(path);
                    }
                    String queryParams = mData.getEncodedQuery();
                    if (queryParams != null) {
                        uri.append('?');
                        uri.append(queryParams);
                    }
                    String fragment = mData.getEncodedFragment();
                    if (fragment != null) {
                        uri.append('#');
                        uri.append(fragment);
                    }
                }
            }
        }
        toUriFragment(uri, null, scheme == null ? Intent.ACTION_MAIN : Intent.ACTION_VIEW, mPackage, flags);
        return uri.toString();
    }
    String scheme = null;
    if (mData != null) {
        String data = mData.toString();
        if ((flags & URI_INTENT_SCHEME) != 0) {
            final int N = data.length();
            for (int i = 0; i < N; i++) {
                char c = data.charAt(i);
                if ((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || (c >= '0' && c <= '9') || c == '.' || c == '-' || c == '+') {
                    continue;
                }
                if (c == ':' && i > 0) {
                    // Valid scheme.
                    scheme = data.substring(0, i);
                    uri.append(""intent:"");
                    data = data.substring(i + 1);
                    break;
                }
                // No scheme.
                break;
            }
        }
        uri.append(data);
    } else if ((flags & URI_INTENT_SCHEME) != 0) {
        uri.append(""intent:"");
    }
    toUriFragment(uri, scheme, Intent.ACTION_VIEW, null, flags);
    return uri.toString();
}",1,"/**
 * Convert this Intent into a String holding a URI representation of it.
 * The returned URI string has been properly URI encoded, so it can be
 * used with {@link Uri#parse Uri.parse(String)}.  The URI contains the
 * Intent's data as the base URI, with an additional fragment describing
 * the action, categories, type, flags, package, component, and extras.
 *
 * <p>You can convert the returned string back to an Intent with
 * {@link #getIntent}.
 *
 * @param flags Additional operating flags.
 *
 * @return Returns a URI encoding URI string describing the entire contents
 * of the Intent.
 */
","/**
 * Convert this Intent into a String holding a URI representation of it.
 * The returned URI string has been properly URI encoded, so it can be
 * used with {@link Uri#parse Uri.parse(String)}.  The URI contains the
 * Intent's data as the base URI, with an additional fragment describing
 * the action, categories, type, flags, package, component, and extras.
 *
 * <p>You can convert the returned string back to an Intent with
 * {@link #getIntent}.
 *
 * @param flags Additional operating flags.
 *
 * @return Returns a URI encoding URI string describing the entire contents
 * of the Intent.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The only change is in the loop that validates the scheme of the data string. The additional condition checks for numbers (0-9) and the plus sign (+) as valid characters in the scheme. No control structures, return statements, or exception handling has changed, so the change type is 4 (Other statement changed).","The change to the valid characters in the scheme doesn't impact the behavior concerning return values or exception throwing since it only allows for a broader set of URLs to be processed without altering the code's logical flow or the method signature. Thus, there is no Compatibility Issue, which means the CI type is 0."
344,"<android.app.assist.AssistStructure.ViewNode: int writeSelfToParcel(Parcel,PooledStringWriter,boolean,float[])>",27,28,"<android.app.assist.AssistStructure.ViewNode: int writeSelfToParcel(Parcel,PooledStringWriter,boolean,float[])>","<android.app.assist.AssistStructure.ViewNode: int writeSelfToParcel(Parcel,PooledStringWriter,boolean,float[])>",0,"{
    // Guard used to skip non-sanitized data when writing for autofill.
    boolean writeSensitive = true;
    int flags = mFlags & ~FLAGS_ALL_CONTROL;
    if (mId != View.NO_ID) {
        flags |= FLAGS_HAS_ID;
    }
    if (mAutofillId != null) {
        flags |= FLAGS_HAS_AUTOFILL_DATA;
    }
    if ((mX & ~0x7fff) != 0 || (mY & ~0x7fff) != 0 || (mWidth & ~0x7fff) != 0 | (mHeight & ~0x7fff) != 0) {
        flags |= FLAGS_HAS_LARGE_COORDS;
    }
    if (mScrollX != 0 || mScrollY != 0) {
        flags |= FLAGS_HAS_SCROLL;
    }
    if (mMatrix != null) {
        flags |= FLAGS_HAS_MATRIX;
    }
    if (mElevation != 0) {
        flags |= FLAGS_HAS_ELEVATION;
    }
    if (mAlpha != 1.0f) {
        flags |= FLAGS_HAS_ALPHA;
    }
    if (mContentDescription != null) {
        flags |= FLAGS_HAS_CONTENT_DESCRIPTION;
    }
    if (mText != null) {
        flags |= FLAGS_HAS_TEXT;
        if (!mText.isSimple()) {
            flags |= FLAGS_HAS_COMPLEX_TEXT;
        }
    }
    if (mInputType != 0) {
        flags |= FLAGS_HAS_INPUT_TYPE;
    }
    if (mWebDomain != null) {
        flags |= FLAGS_HAS_URL;
    }
    if (mLocaleList != null) {
        flags |= FLAGS_HAS_LOCALE_LIST;
    }
    if (mExtras != null) {
        flags |= FLAGS_HAS_EXTRAS;
    }
    if (mChildren != null) {
        flags |= FLAGS_HAS_CHILDREN;
    }
    pwriter.writeString(mClassName);
    int writtenFlags = flags;
    if ((flags & FLAGS_HAS_AUTOFILL_DATA) != 0 && (mSanitized || !sanitizeOnWrite)) {
        // Remove 'checked' from sanitized autofill request.
        writtenFlags = flags & ~FLAGS_CHECKED;
    }
    if (mAutofillOverlay != null) {
        if (mAutofillOverlay.focused) {
            writtenFlags |= ViewNode.FLAGS_FOCUSED;
        } else {
            writtenFlags &= ~ViewNode.FLAGS_FOCUSED;
        }
    }
    out.writeInt(writtenFlags);
    if ((flags & FLAGS_HAS_ID) != 0) {
        out.writeInt(mId);
        if (mId != 0) {
            pwriter.writeString(mIdEntry);
            if (mIdEntry != null) {
                pwriter.writeString(mIdType);
                pwriter.writeString(mIdPackage);
            }
        }
    }
    if ((flags & FLAGS_HAS_AUTOFILL_DATA) != 0) {
        writeSensitive = mSanitized || !sanitizeOnWrite;
        out.writeInt(mSanitized ? 1 : 0);
        out.writeParcelable(mAutofillId, 0);
        out.writeInt(mAutofillType);
        out.writeStringArray(mAutofillHints);
        final AutofillValue sanitizedValue;
        if (writeSensitive) {
            sanitizedValue = mAutofillValue;
        } else if (mAutofillOverlay != null && mAutofillOverlay.value != null) {
            sanitizedValue = mAutofillOverlay.value;
        } else {
            sanitizedValue = null;
        }
        out.writeParcelable(sanitizedValue, 0);
        out.writeCharSequenceArray(mAutofillOptions);
        if (mHtmlInfo instanceof Parcelable) {
            out.writeParcelable((Parcelable) mHtmlInfo, 0);
        } else {
            out.writeParcelable(null, 0);
        }
    }
    if ((flags & FLAGS_HAS_LARGE_COORDS) != 0) {
        out.writeInt(mX);
        out.writeInt(mY);
        out.writeInt(mWidth);
        out.writeInt(mHeight);
    } else {
        out.writeInt((mY << 16) | mX);
        out.writeInt((mHeight << 16) | mWidth);
    }
    if ((flags & FLAGS_HAS_SCROLL) != 0) {
        out.writeInt(mScrollX);
        out.writeInt(mScrollY);
    }
    if ((flags & FLAGS_HAS_MATRIX) != 0) {
        mMatrix.getValues(tmpMatrix);
        out.writeFloatArray(tmpMatrix);
    }
    if ((flags & FLAGS_HAS_ELEVATION) != 0) {
        out.writeFloat(mElevation);
    }
    if ((flags & FLAGS_HAS_ALPHA) != 0) {
        out.writeFloat(mAlpha);
    }
    if ((flags & FLAGS_HAS_CONTENT_DESCRIPTION) != 0) {
        TextUtils.writeToParcel(mContentDescription, out, 0);
    }
    if ((flags & FLAGS_HAS_TEXT) != 0) {
        mText.writeToParcel(out, (flags & FLAGS_HAS_COMPLEX_TEXT) == 0, writeSensitive);
    }
    if ((flags & FLAGS_HAS_INPUT_TYPE) != 0) {
        out.writeInt(mInputType);
    }
    if ((flags & FLAGS_HAS_URL) != 0) {
        out.writeString(mWebDomain);
    }
    if ((flags & FLAGS_HAS_LOCALE_LIST) != 0) {
        out.writeParcelable(mLocaleList, 0);
    }
    if ((flags & FLAGS_HAS_EXTRAS) != 0) {
        out.writeBundle(mExtras);
    }
    return flags;
}","{
    // Guard used to skip non-sanitized data when writing for autofill.
    boolean writeSensitive = true;
    int flags = mFlags & ~FLAGS_ALL_CONTROL;
    if (mId != View.NO_ID) {
        flags |= FLAGS_HAS_ID;
    }
    if (mAutofillId != null) {
        flags |= FLAGS_HAS_AUTOFILL_DATA;
    }
    if ((mX & ~0x7fff) != 0 || (mY & ~0x7fff) != 0 || (mWidth & ~0x7fff) != 0 | (mHeight & ~0x7fff) != 0) {
        flags |= FLAGS_HAS_LARGE_COORDS;
    }
    if (mScrollX != 0 || mScrollY != 0) {
        flags |= FLAGS_HAS_SCROLL;
    }
    if (mMatrix != null) {
        flags |= FLAGS_HAS_MATRIX;
    }
    if (mElevation != 0) {
        flags |= FLAGS_HAS_ELEVATION;
    }
    if (mAlpha != 1.0f) {
        flags |= FLAGS_HAS_ALPHA;
    }
    if (mContentDescription != null) {
        flags |= FLAGS_HAS_CONTENT_DESCRIPTION;
    }
    if (mText != null) {
        flags |= FLAGS_HAS_TEXT;
        if (!mText.isSimple()) {
            flags |= FLAGS_HAS_COMPLEX_TEXT;
        }
    }
    if (mInputType != 0) {
        flags |= FLAGS_HAS_INPUT_TYPE;
    }
    if (mWebScheme != null || mWebDomain != null) {
        flags |= FLAGS_HAS_URL;
    }
    if (mLocaleList != null) {
        flags |= FLAGS_HAS_LOCALE_LIST;
    }
    if (mExtras != null) {
        flags |= FLAGS_HAS_EXTRAS;
    }
    if (mChildren != null) {
        flags |= FLAGS_HAS_CHILDREN;
    }
    pwriter.writeString(mClassName);
    int writtenFlags = flags;
    if ((flags & FLAGS_HAS_AUTOFILL_DATA) != 0 && (mSanitized || !sanitizeOnWrite)) {
        // Remove 'checked' from sanitized autofill request.
        writtenFlags = flags & ~FLAGS_CHECKED;
    }
    if (mAutofillOverlay != null) {
        if (mAutofillOverlay.focused) {
            writtenFlags |= ViewNode.FLAGS_FOCUSED;
        } else {
            writtenFlags &= ~ViewNode.FLAGS_FOCUSED;
        }
    }
    out.writeInt(writtenFlags);
    if ((flags & FLAGS_HAS_ID) != 0) {
        out.writeInt(mId);
        if (mId != View.NO_ID) {
            pwriter.writeString(mIdEntry);
            if (mIdEntry != null) {
                pwriter.writeString(mIdType);
                pwriter.writeString(mIdPackage);
            }
        }
    }
    if ((flags & FLAGS_HAS_AUTOFILL_DATA) != 0) {
        writeSensitive = mSanitized || !sanitizeOnWrite;
        out.writeInt(mSanitized ? 1 : 0);
        out.writeParcelable(mAutofillId, 0);
        out.writeInt(mAutofillType);
        out.writeStringArray(mAutofillHints);
        final AutofillValue sanitizedValue;
        if (writeSensitive) {
            sanitizedValue = mAutofillValue;
        } else if (mAutofillOverlay != null && mAutofillOverlay.value != null) {
            sanitizedValue = mAutofillOverlay.value;
        } else {
            sanitizedValue = null;
        }
        out.writeParcelable(sanitizedValue, 0);
        out.writeCharSequenceArray(mAutofillOptions);
        if (mHtmlInfo instanceof Parcelable) {
            out.writeParcelable((Parcelable) mHtmlInfo, 0);
        } else {
            out.writeParcelable(null, 0);
        }
        out.writeInt(mMinEms);
        out.writeInt(mMaxEms);
        out.writeInt(mMaxLength);
        pwriter.writeString(mTextIdEntry);
        out.writeInt(mImportantForAutofill);
    }
    if ((flags & FLAGS_HAS_LARGE_COORDS) != 0) {
        out.writeInt(mX);
        out.writeInt(mY);
        out.writeInt(mWidth);
        out.writeInt(mHeight);
    } else {
        out.writeInt((mY << 16) | mX);
        out.writeInt((mHeight << 16) | mWidth);
    }
    if ((flags & FLAGS_HAS_SCROLL) != 0) {
        out.writeInt(mScrollX);
        out.writeInt(mScrollY);
    }
    if ((flags & FLAGS_HAS_MATRIX) != 0) {
        mMatrix.getValues(tmpMatrix);
        out.writeFloatArray(tmpMatrix);
    }
    if ((flags & FLAGS_HAS_ELEVATION) != 0) {
        out.writeFloat(mElevation);
    }
    if ((flags & FLAGS_HAS_ALPHA) != 0) {
        out.writeFloat(mAlpha);
    }
    if ((flags & FLAGS_HAS_CONTENT_DESCRIPTION) != 0) {
        TextUtils.writeToParcel(mContentDescription, out, 0);
    }
    if ((flags & FLAGS_HAS_TEXT) != 0) {
        mText.writeToParcel(out, (flags & FLAGS_HAS_COMPLEX_TEXT) == 0, writeSensitive);
    }
    if ((flags & FLAGS_HAS_INPUT_TYPE) != 0) {
        out.writeInt(mInputType);
    }
    if ((flags & FLAGS_HAS_URL) != 0) {
        out.writeString(mWebScheme);
        out.writeString(mWebDomain);
    }
    if ((flags & FLAGS_HAS_LOCALE_LIST) != 0) {
        out.writeParcelable(mLocaleList, 0);
    }
    if ((flags & FLAGS_HAS_EXTRAS) != 0) {
        out.writeBundle(mExtras);
    }
    return flags;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,,,,
345,<android.widget.RemoteViews: RemoteViews clone()>,27,28,<android.widget.RemoteViews: RemoteViews clone()>,<android.widget.RemoteViews: RemoteViews clone()>,0,"{
    synchronized (this) {
        Preconditions.checkState(mIsRoot, ""RemoteView has been attached to another RemoteView. "" + ""May only clone the root of a RemoteView hierarchy."");
        Parcel p = Parcel.obtain();
        // Do not parcel the Bitmap cache - doing so creates an expensive copy of all bitmaps.
        // Instead pretend we're not owning the cache while parceling.
        mIsRoot = false;
        writeToParcel(p, PARCELABLE_ELIDE_DUPLICATES);
        p.setDataPosition(0);
        mIsRoot = true;
        RemoteViews rv = new RemoteViews(p, mBitmapCache.clone(), mApplication, 0);
        rv.mIsRoot = true;
        p.recycle();
        return rv;
    }
}","{
    Preconditions.checkState(mIsRoot, ""RemoteView has been attached to another RemoteView. "" + ""May only clone the root of a RemoteView hierarchy."");
    return new RemoteViews(this);
}",1,"/**
 * Returns a deep copy of the RemoteViews object. The RemoteView may not be
 * attached to another RemoteView -- it must be the root of a hierarchy.
 *
 * @throws IllegalStateException if this is not the root of a RemoteView
 * hierarchy
 */
","/**
 * Returns a deep copy of the RemoteViews object. The RemoteView may not be
 * attached to another RemoteView -- it must be the root of a hierarchy.
 *
 * @deprecated use {@link #RemoteViews(RemoteViews)} instead.
 * @throws IllegalStateException if this is not the root of a RemoteView
 * hierarchy
 */
",-1,[@Override],"[@Override, @Deprecated]",-1,-1,-1,-1,-1,-1,"1,3,4",1,"The early version of the method uses explicit parcel logic and several state changes to create a clone of the RemoteViews, while the late version delegates the cloning to a constructor, significantly changing the implementation. In addition, the late version is marked as @Deprecated. The changes include a new return statement, a removed synchronized block and control flow, and other internal implementation details. Therefore, the change type is 1,3,4.","Since the whole cloning logic has been changed to use a different constructor (new RemoteViews(this)), the clone created might behave differently compared to the early version (which includes detailed parcel logic and other operations). The new implementation could potentially return a clone that has different characteristics or contents from the early implementation. Hence, the CI type is 1 due to the potential different return value."
346,<android.app.ActivityManager: void killBackgroundProcesses(String)>,27,28,<android.app.ActivityManager: void killBackgroundProcesses(String)>,<android.app.ActivityManager: void killBackgroundProcesses(String)>,0,"{
    try {
        getService().killBackgroundProcesses(packageName, UserHandle.myUserId());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}","{
    try {
        getService().killBackgroundProcesses(packageName, mContext.getUserId());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Have the system immediately kill all background processes associated
 * with the given package.  This is the same as the kernel killing those
 * processes to reclaim memory; the system will take care of restarting
 * these processes in the future as needed.
 *
 * @param packageName The name of the package whose processes are to
 * be killed.
 */
","/**
 * Have the system immediately kill all background processes associated
 * with the given package.  This is the same as the kernel killing those
 * processes to reclaim memory; the system will take care of restarting
 * these processes in the future as needed.
 *
 * @param packageName The name of the package whose processes are to
 * be killed.
 */
",-1,[@RequiresPermission(Manifest.permission.KILL_BACKGROUND_PROCESSES)],[@RequiresPermission(Manifest.permission.KILL_BACKGROUND_PROCESSES)],-1,-1,-1,-1,-1,-1,5,0,"The method killBackgroundProcesses() now calls mContext.getUserId() instead of UserHandle.myUserId(), indicating a change in the dependent API. This is a change type 5.","There is no Compatibility Issue caused by this change, as it does not inherently affect the return value or the exception handling of the method. The method does not return any value (void) and does not change the exception it might throw; it continues to throw the same RemoteException wrapped by rethrowFromSystemServer(). The change in how the user ID is obtained does not alter these aspects of the API's behavior. Therefore, the CI type is 0."
347,"<android.content.ContentResolver: Object addStatusChangeListener(int,SyncStatusObserver)>",27,28,"<android.content.ContentResolver: Object addStatusChangeListener(int,SyncStatusObserver)>","<android.content.ContentResolver: Object addStatusChangeListener(int,SyncStatusObserver)>",0,"{
    if (callback == null) {
        throw new IllegalArgumentException(""you passed in a null callback"");
    }
    try {
        ISyncStatusObserver.Stub observer = new ISyncStatusObserver.Stub() {

            @Override
            public void onStatusChanged(int which) throws RemoteException {
                callback.onStatusChanged(which);
            }
        };
        getContentService().addStatusChangeListener(mask, observer);
        return observer;
    } catch (RemoteException e) {
        throw new RuntimeException(""the ContentService should always be reachable"", e);
    }
}","{
    if (callback == null) {
        throw new IllegalArgumentException(""you passed in a null callback"");
    }
    try {
        ISyncStatusObserver.Stub observer = new ISyncStatusObserver.Stub() {

            @Override
            public void onStatusChanged(int which) throws RemoteException {
                callback.onStatusChanged(which);
            }
        };
        getContentService().addStatusChangeListener(mask, observer);
        return observer;
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Request notifications when the different aspects of the SyncManager change. The
 * different items that can be requested are:
 * <ul>
 * <li> {@link #SYNC_OBSERVER_TYPE_PENDING}
 * <li> {@link #SYNC_OBSERVER_TYPE_ACTIVE}
 * <li> {@link #SYNC_OBSERVER_TYPE_SETTINGS}
 * </ul>
 * The caller can set one or more of the status types in the mask for any
 * given listener registration.
 * @param mask the status change types that will cause the callback to be invoked
 * @param callback observer to be invoked when the status changes
 * @return a handle that can be used to remove the listener at a later time
 */
","/**
 * Request notifications when the different aspects of the SyncManager change. The
 * different items that can be requested are:
 * <ul>
 * <li> {@link #SYNC_OBSERVER_TYPE_PENDING}
 * <li> {@link #SYNC_OBSERVER_TYPE_ACTIVE}
 * <li> {@link #SYNC_OBSERVER_TYPE_SETTINGS}
 * </ul>
 * The caller can set one or more of the status types in the mask for any
 * given listener registration.
 * @param mask the status change types that will cause the callback to be invoked
 * @param callback observer to be invoked when the status changes
 * @return a handle that can be used to remove the listener at a later time
 */
",-1,,,-1,-1,-1,-1,-1,-1,2,2,"The exception handling statement has changed. In the early version, a new RuntimeException is thrown, while in the late version, the RemoteException is re-thrown using `rethrowFromSystemServer()`, so the change type is 2.","The method of exception handling has changed, which means the caller may now receive a different exception type when a RemoteException occurs. This represents a change in the APIs behavior, constituting a Compatibility Issue of type 2."
348,"<android.content.pm.PackageManager: PackageInfo getPackageArchiveInfo(String,int)>",27,28,"<android.content.pm.PackageManager: PackageInfo getPackageArchiveInfo(String,int)>","<android.content.pm.PackageManager: PackageInfo getPackageArchiveInfo(String,int)>",0,"{
    final PackageParser parser = new PackageParser();
    parser.setCallback(new PackageParser.CallbackImpl(this));
    final File apkFile = new File(archiveFilePath);
    try {
        if ((flags & (MATCH_DIRECT_BOOT_UNAWARE | MATCH_DIRECT_BOOT_AWARE)) != 0) {
        // Caller expressed an explicit opinion about what encryption
        // aware/unaware components they want to see, so fall through and
        // give them what they want
        } else {
            // Caller expressed no opinion, so match everything
            flags |= MATCH_DIRECT_BOOT_AWARE | MATCH_DIRECT_BOOT_UNAWARE;
        }
        PackageParser.Package pkg = parser.parseMonolithicPackage(apkFile, 0);
        if ((flags & GET_SIGNATURES) != 0) {
            PackageParser.collectCertificates(pkg, 0);
        }
        PackageUserState state = new PackageUserState();
        return PackageParser.generatePackageInfo(pkg, null, flags, 0, 0, null, state);
    } catch (PackageParserException e) {
        return null;
    }
}","{
    final PackageParser parser = new PackageParser();
    parser.setCallback(new PackageParser.CallbackImpl(this));
    final File apkFile = new File(archiveFilePath);
    try {
        if ((flags & (MATCH_DIRECT_BOOT_UNAWARE | MATCH_DIRECT_BOOT_AWARE)) != 0) {
        // Caller expressed an explicit opinion about what encryption
        // aware/unaware components they want to see, so fall through and
        // give them what they want
        } else {
            // Caller expressed no opinion, so match everything
            flags |= MATCH_DIRECT_BOOT_AWARE | MATCH_DIRECT_BOOT_UNAWARE;
        }
        PackageParser.Package pkg = parser.parseMonolithicPackage(apkFile, 0);
        if ((flags & GET_SIGNATURES) != 0) {
            PackageParser.collectCertificates(pkg, false);
        }
        PackageUserState state = new PackageUserState();
        return PackageParser.generatePackageInfo(pkg, null, flags, 0, 0, null, state);
    } catch (PackageParserException e) {
        return null;
    }
}",1,"/**
 * Retrieve overall information about an application package defined in a
 * package archive file
 *
 * @param archiveFilePath The path to the archive file
 * @param flags Additional option flags to modify the data returned.
 * @return A PackageInfo object containing information about the package
 * archive. If the package could not be parsed, returns null.
 */
","/**
 * Retrieve overall information about an application package defined in a
 * package archive file
 *
 * @param archiveFilePath The path to the archive file
 * @param flags Additional option flags to modify the data returned.
 * @return A PackageInfo object containing information about the package
 * archive. If the package could not be parsed, returns null.
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The dependent method `PackageParser.collectCertificates()`'s invocation changed by introducing a new `false` parameter, so the change type is 5.","Despite the change in parameter to the dependent method `PackageParser.collectCertificates()`, there's no indication that this would alter the return type or thrown exceptions of the `getPackageArchiveInfo` method; the wrapper's control flow and return points remain unchanged. Therefore, the change is not classified as introducing a potential Compatibility Issue, thus the CI type is 0."
350,"<android.database.sqlite.SQLiteDatabase: SQLiteDatabase openDatabase(String,CursorFactory,int,DatabaseErrorHandler)>",27,28,"<android.database.sqlite.SQLiteDatabase: SQLiteDatabase openDatabase(String,CursorFactory,int,DatabaseErrorHandler)>","<android.database.sqlite.SQLiteDatabase: SQLiteDatabase openDatabase(String,CursorFactory,int,DatabaseErrorHandler)>",0,"{
    SQLiteDatabase db = new SQLiteDatabase(path, flags, factory, errorHandler, -1, -1, -1);
    db.open();
    return db;
}","{
    SQLiteDatabase db = new SQLiteDatabase(path, flags, factory, errorHandler, -1, -1, -1, null, null);
    db.open();
    return db;
}",1,"/**
 * Open the database according to the flags {@link #OPEN_READWRITE}
 * {@link #OPEN_READONLY} {@link #CREATE_IF_NECESSARY} and/or {@link #NO_LOCALIZED_COLLATORS}.
 *
 * <p>Sets the locale of the database to the  the system's current locale.
 * Call {@link #setLocale} if you would like something else.</p>
 *
 * <p>Accepts input param: a concrete instance of {@link DatabaseErrorHandler} to be
 * used to handle corruption when sqlite reports database corruption.</p>
 *
 * @param path to database file to open and/or create
 * @param factory an optional factory class that is called to instantiate a
 * cursor when query is called, or null for default
 * @param flags to control database access mode
 * @param errorHandler the {@link DatabaseErrorHandler} obj to be used to handle corruption
 * when sqlite reports database corruption
 * @return the newly opened database
 * @throws SQLiteException if the database cannot be opened
 */
","/**
 * Open the database according to the flags {@link #OPEN_READWRITE}
 * {@link #OPEN_READONLY} {@link #CREATE_IF_NECESSARY} and/or {@link #NO_LOCALIZED_COLLATORS}.
 *
 * <p>Sets the locale of the database to the  the system's current locale.
 * Call {@link #setLocale} if you would like something else.</p>
 *
 * <p>Accepts input param: a concrete instance of {@link DatabaseErrorHandler} to be
 * used to handle corruption when sqlite reports database corruption.</p>
 *
 * @param path to database file to open and/or create
 * @param factory an optional factory class that is called to instantiate a
 * cursor when query is called, or null for default
 * @param flags to control database access mode
 * @param errorHandler the {@link DatabaseErrorHandler} obj to be used to handle corruption
 * when sqlite reports database corruption
 * @return the newly opened database
 * @throws SQLiteException if the database cannot be opened
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"The constructor for SQLiteDatabase has an additional two parameters set to 'null' in the late version, which does not affect the return statement or exception handling, so the code change type is 4. Also, it represents a change to a dependent API due to the modified constructor parameters, thus the second change type is 5.","Since the additional parameters are set to null, and given there is no change in the control flow, return statements, or exceptions being thrown (the behavior of the method is not altered), there is no Compatibility Issue, and the type is 0."
351,"<android.content.res.TypedArray: int getResourceId(int,int)>",27,28,"<android.content.res.TypedArray: int getResourceId(int,int)>","<android.content.res.TypedArray: int getResourceId(int,int)>",0,"{
    if (mRecycled) {
        throw new RuntimeException(""Cannot make calls to a recycled instance!"");
    }
    index *= AssetManager.STYLE_NUM_ENTRIES;
    final int[] data = mData;
    if (data[index + AssetManager.STYLE_TYPE] != TypedValue.TYPE_NULL) {
        final int resid = data[index + AssetManager.STYLE_RESOURCE_ID];
        if (resid != 0) {
            return resid;
        }
    }
    return defValue;
}","{
    if (mRecycled) {
        throw new RuntimeException(""Cannot make calls to a recycled instance!"");
    }
    index *= STYLE_NUM_ENTRIES;
    final int[] data = mData;
    if (data[index + STYLE_TYPE] != TypedValue.TYPE_NULL) {
        final int resid = data[index + STYLE_RESOURCE_ID];
        if (resid != 0) {
            return resid;
        }
    }
    return defValue;
}",1,"/**
 * Retrieves the resource identifier for the attribute at
 * <var>index</var>.  Note that attribute resource as resolved when
 * the overall {@link TypedArray} object is retrieved.  As a
 * result, this function will return the resource identifier of the
 * final resource value that was found, <em>not</em> necessarily the
 * original resource that was specified by the attribute.
 *
 * @param index Index of attribute to retrieve.
 * @param defValue Value to return if the attribute is not defined or
 * not a resource.
 *
 * @return Attribute resource identifier, or defValue if not defined.
 * @throws RuntimeException if the TypedArray has already been recycled.
 */
","/**
 * Retrieves the resource identifier for the attribute at
 * <var>index</var>.  Note that attribute resource as resolved when
 * the overall {@link TypedArray} object is retrieved.  As a
 * result, this function will return the resource identifier of the
 * final resource value that was found, <em>not</em> necessarily the
 * original resource that was specified by the attribute.
 *
 * @param index Index of attribute to retrieve.
 * @param defValue Value to return if the attribute is not defined or
 * not a resource.
 *
 * @return Attribute resource identifier, or defValue if not defined.
 * @throws RuntimeException if the TypedArray has already been recycled.
 */
",-1,[@AnyRes],[@AnyRes],-1,-1,-1,-1,-1,-1,0,0,"There are no changes in the control flow or logic of the methods. The constants `AssetManager.STYLE_NUM_ENTRIES`, `AssetManager.STYLE_TYPE`, and `AssetManager.STYLE_RESOURCE_ID` had `AssetManager` removed but they refer to the same values, which indicates no real change in the implementation. The method parameters and return type remain unchanged.","Since there are no code changes that would alter the behavior, control flow, or outputs of the method, there is no Compatibility Issue between the two versions."
352,<android.net.Network: InetAddress[] getAllByName(String)>,27,28,<android.net.Network: InetAddress[] getAllByName(String)>,<android.net.Network: InetAddress[] getAllByName(String)>,0,"{
    return InetAddress.getAllByNameOnNet(host, netId);
}","{
    return InetAddress.getAllByNameOnNet(host, getNetIdForResolv());
}",1,"/**
 * Operates the same as {@code InetAddress.getAllByName} except that host
 * resolution is done on this network.
 *
 * @param host the hostname or literal IP string to be resolved.
 * @return the array of addresses associated with the specified host.
 * @throws UnknownHostException if the address lookup fails.
 */
","/**
 * Operates the same as {@code InetAddress.getAllByName} except that host
 * resolution is done on this network.
 *
 * @param host the hostname or literal IP string to be resolved.
 * @return the array of addresses associated with the specified host.
 * @throws UnknownHostException if the address lookup fails.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The code change is in the parameter passed to the method InetAddress.getAllByNameOnNet(), the early version directly uses the variable `netId`, while the late version calls the method `getNetIdForResolv()`. So the code change type is 1,5.","Since the method getAllByNameOnNet() is now called with a different parameter, it may return different results based on the new method's return value. Hence, this change could potentially result in different return values in the late version API compared to the early version, therefore the CI type is 1."
353,<android.view.View: void hideTooltip()>,27,28,<android.view.View: void hideTooltip()>,<android.view.View: void hideTooltip()>,0,"{
    if (mTooltipInfo == null) {
        return;
    }
    removeCallbacks(mTooltipInfo.mShowTooltipRunnable);
    if (mTooltipInfo.mTooltipPopup == null) {
        return;
    }
    mTooltipInfo.mTooltipPopup.hide();
    mTooltipInfo.mTooltipPopup = null;
    mTooltipInfo.mTooltipFromLongClick = false;
    if (mAttachInfo != null) {
        mAttachInfo.mTooltipHost = null;
    }
}","{
    if (mTooltipInfo == null) {
        return;
    }
    removeCallbacks(mTooltipInfo.mShowTooltipRunnable);
    if (mTooltipInfo.mTooltipPopup == null) {
        return;
    }
    mTooltipInfo.mTooltipPopup.hide();
    mTooltipInfo.mTooltipPopup = null;
    mTooltipInfo.mTooltipFromLongClick = false;
    mTooltipInfo.clearAnchorPos();
    if (mAttachInfo != null) {
        mAttachInfo.mTooltipHost = null;
    }
    // The available accessibility actions have changed
    notifyViewAccessibilityStateChangedIfNeeded(CONTENT_CHANGE_TYPE_UNDEFINED);
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,4,0,"A new method call mTooltipInfo.clearAnchorPos() and notifyViewAccessibilityStateChangedIfNeeded(CONTENT_CHANGE_TYPE_UNDEFINED) has been added that was not in the early implementation, so the code change type is 4 (Other statement changed).","The method hideTooltip() does not return any value nor does it throw checked exceptions, and the added statements do not affect the API's return type or exception handling. Thus, there are no compatibility issues potentially leading to changes in the method's expected return type or exception handling behavior. The CI type is 0 (No Compatibility Issue)."
355,<android.content.res.AssetManager.AssetInputStream: int available()>,27,28,<android.content.res.AssetManager.AssetInputStream: int available()>,<android.content.res.AssetManager.AssetInputStream: int available()>,0,"{
    long len = getAssetRemainingLength(mAsset);
    return len > Integer.MAX_VALUE ? Integer.MAX_VALUE : (int) len;
}","{
    ensureOpen();
    final long len = nativeAssetGetRemainingLength(mAssetNativePtr);
    return len > Integer.MAX_VALUE ? Integer.MAX_VALUE : (int) len;
}",1,,,-1,,[@Override],-1,-1,-1,-1,-1,-1,"4,5",0,"The implementation now includes a call to ensureOpen() and uses a different native method named nativeAssetGetRemainingLength(mAssetNativePtr) instead of getAssetRemainingLength(mAsset). The annotation is also updated with @Override, but this does not affect the execution. Hence, the change types involved are 4 (Other statement changed) and 5 (Dependent API changed).","While these changes impact the implementation, they do not necessarily introduce a compatibility issue since there's no change to the return type or value because of the control logic remaining the same and the integer max value check also remains. It is assumed that the new method ensureOpen() does not throw an exception and nativeAssetGetRemainingLength() behaves the same as getAssetRemainingLength(mAsset) in terms of returning the remaining length of the asset. There is not enough information to assume that ensureOpen() would change the behavior of the `available()` method in a way that would introduce a CI. Thus, pred_CI is 0 (No Compatibility Issue)."
356,<android.service.autofill.FillResponse.Builder: FillResponse build()>,27,28,<android.service.autofill.FillResponse.Builder: FillResponse build()>,<android.service.autofill.FillResponse.Builder: FillResponse build()>,0,"{
    throwIfDestroyed();
    if (mAuthentication == null && mDatasets == null && mSaveInfo == null) {
        throw new IllegalArgumentException(""need to provide at least one DataSet or a "" + ""SaveInfo or an authentication with a presentation"");
    }
    mDestroyed = true;
    return new FillResponse(this);
}","{
    throwIfDestroyed();
    if (mAuthentication == null && mDatasets == null && mSaveInfo == null && mDisableDuration == 0 && mFieldClassificationIds == null && mClientState == null) {
        throw new IllegalStateException(""need to provide: at least one DataSet, or a "" + ""SaveInfo, or an authentication with a presentation, "" + ""or a FieldsDetection, or a client state, or disable autofill"");
    }
    if (mDatasets == null && (mHeader != null || mFooter != null)) {
        throw new IllegalStateException(""must add at least 1 dataset when using header or footer"");
    }
    mDestroyed = true;
    return new FillResponse(this);
}",1,"/**
 * Builds a new {@link FillResponse} instance.
 *
 * <p>You must provide at least one dataset or some savable ids or an authentication with a
 * presentation view.
 *
 * @return A built response.
 */
","/**
 * Builds a new {@link FillResponse} instance.
 *
 * @throws IllegalStateException if any of the following conditions occur:
 * <ol>
 * <li>{@link #build()} was already called.
 * <li>No call was made to {@link #addDataset(Dataset)},
 * {@link #setAuthentication(AutofillId[], IntentSender, RemoteViews)},
 * {@link #setSaveInfo(SaveInfo)}, {@link #disableAutofill(long)},
 * {@link #setClientState(Bundle)},
 * or {@link #setFieldClassificationIds(AutofillId...)}.
 * <li>{@link #setHeader(RemoteViews)} or {@link #setFooter(RemoteViews)} is called
 * without any previous calls to {@link #addDataset(Dataset)}.
 * </ol>
 *
 * @return A built response.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,3",2,"The condition in the 'if' statements has changed by adding additional checks (mDisableDuration, mFieldClassificationIds, mClientState) and changing the exception type from IllegalArgumentException to IllegalStateException. Also, a new exception handling statement is introduced for checking mDatasets with mHeader and mFooter, so the code change types are 2,3.","Since the changes involve additions to the conditions for throwing exceptions, as well as changing the type of exception being thrown in one case, and adding another condition for throwing a new exception, this can lead to different behaviors related to exception handling when invoking the API. Therefore, the CI type is 2."
359,"<android.content.ContentResolver: void setIsSyncable(Account,String,int)>",27,28,"<android.content.ContentResolver: void setIsSyncable(Account,String,int)>","<android.content.ContentResolver: void setIsSyncable(Account,String,int)>",0,"{
    try {
        getContentService().setIsSyncable(account, authority, syncable);
    } catch (RemoteException e) {
    // exception ignored; if this is thrown then it means the runtime is in the midst of
    // being restarted
    }
}","{
    try {
        getContentService().setIsSyncable(account, authority, syncable);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Set whether this account/provider is syncable.
 * <p>This method requires the caller to hold the permission
 * {@link android.Manifest.permission#WRITE_SYNC_SETTINGS}.
 * @param syncable >0 denotes syncable, 0 means not syncable, <0 means unknown
 */
","/**
 * Set whether this account/provider is syncable.
 * <p>This method requires the caller to hold the permission
 * {@link android.Manifest.permission#WRITE_SYNC_SETTINGS}.
 * @param syncable >0 denotes syncable, 0 means not syncable, <0 means unknown
 */
",-1,,,-1,-1,-1,-1,-1,-1,2,2,"The exception handling statement has changed by introducing a new `throw` statement in the catch block: `throw e.rethrowFromSystemServer();`, so the code change type is 2.","With the introduced `throw` statement, the later version of the method will throw an exception in scenarios where previously it was suppressed. This will lead to a compatibility issue due to potential different exception handlings, and the CI type is 2."
360,<android.view.accessibility.AccessibilityWindowInfo: AccessibilityWindowInfo obtain(AccessibilityWindowInfo)>,27,28,<android.view.accessibility.AccessibilityWindowInfo: AccessibilityWindowInfo obtain(AccessibilityWindowInfo)>,<android.view.accessibility.AccessibilityWindowInfo: AccessibilityWindowInfo obtain(AccessibilityWindowInfo)>,0,"{
    AccessibilityWindowInfo infoClone = obtain();
    infoClone.mType = info.mType;
    infoClone.mLayer = info.mLayer;
    infoClone.mBooleanProperties = info.mBooleanProperties;
    infoClone.mId = info.mId;
    infoClone.mParentId = info.mParentId;
    infoClone.mBoundsInScreen.set(info.mBoundsInScreen);
    infoClone.mTitle = info.mTitle;
    infoClone.mAnchorId = info.mAnchorId;
    infoClone.mInPictureInPicture = info.mInPictureInPicture;
    if (info.mChildIds != null && info.mChildIds.size() > 0) {
        if (infoClone.mChildIds == null) {
            infoClone.mChildIds = info.mChildIds.clone();
        } else {
            infoClone.mChildIds.addAll(info.mChildIds);
        }
    }
    infoClone.mConnectionId = info.mConnectionId;
    return infoClone;
}","{
    AccessibilityWindowInfo infoClone = obtain();
    infoClone.mType = info.mType;
    infoClone.mLayer = info.mLayer;
    infoClone.mBooleanProperties = info.mBooleanProperties;
    infoClone.mId = info.mId;
    infoClone.mParentId = info.mParentId;
    infoClone.mBoundsInScreen.set(info.mBoundsInScreen);
    infoClone.mTitle = info.mTitle;
    infoClone.mAnchorId = info.mAnchorId;
    if (info.mChildIds != null && info.mChildIds.size() > 0) {
        if (infoClone.mChildIds == null) {
            infoClone.mChildIds = info.mChildIds.clone();
        } else {
            infoClone.mChildIds.addAll(info.mChildIds);
        }
    }
    infoClone.mConnectionId = info.mConnectionId;
    return infoClone;
}",1,"/**
 * Returns a cached instance if such is available or a new one is
 * created. The returned instance is initialized from the given
 * <code>info</code>.
 *
 * @param info The other info.
 * @return An instance.
 */
","/**
 * Returns a cached instance if such is available or a new one is
 * created. The returned instance is initialized from the given
 * <code>info</code>.
 *
 * @param info The other info.
 * @return An instance.
 */
",-1,,,-1,-1,-1,-1,-1,-1,0,0,There are no changes in the implementation between the early and late versions.,"Since there is no change in the implementation, no compatibility issue could arise."
361,"<android.widget.RemoteViewsAdapter.RemoteViewsFrameLayoutRefSet: void notifyOnRemoteViewsLoaded(int,RemoteViews)>",27,28,"<android.widget.RemoteViewsAdapter.RemoteViewsFrameLayoutRefSet: void notifyOnRemoteViewsLoaded(int,RemoteViews)>","<android.widget.RemoteViewsAdapter.RemoteViewsFrameLayoutRefSet: void notifyOnRemoteViewsLoaded(int,RemoteViews)>",0,"{
    if (view == null)
        return;
    final LinkedList<RemoteViewsFrameLayout> refs = mReferences.get(position);
    if (refs != null) {
        // Notify all the references for that position of the newly loaded RemoteViews
        for (final RemoteViewsFrameLayout ref : refs) {
            ref.onRemoteViewsLoaded(view, mRemoteViewsOnClickHandler, true);
            if (mViewToLinkedList.containsKey(ref)) {
                mViewToLinkedList.remove(ref);
            }
        }
        refs.clear();
        // Remove this set from the original mapping
        mReferences.remove(position);
    }
}","{
    if (view == null)
        return;
    // Remove this set from the original mapping
    final LinkedList<RemoteViewsFrameLayout> refs = removeReturnOld(position);
    if (refs != null) {
        // Notify all the references for that position of the newly loaded RemoteViews
        for (final RemoteViewsFrameLayout ref : refs) {
            ref.onRemoteViewsLoaded(view, mRemoteViewsOnClickHandler, true);
        }
    }
}",1,"/**
 * Notifies each of the RemoteViewsFrameLayouts associated with a particular position that
 * the associated RemoteViews has loaded.
 */
","/**
 * Notifies each of the RemoteViewsFrameLayouts associated with a particular position that
 * the associated RemoteViews has loaded.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,5",0,The implementation changes include:,
362,"<android.app.UiAutomation: AccessibilityEvent executeAndWaitForEvent(Runnable,AccessibilityEventFilter,long)>",27,28,"<android.app.UiAutomation: AccessibilityEvent executeAndWaitForEvent(Runnable,AccessibilityEventFilter,long)>","<android.app.UiAutomation: AccessibilityEvent executeAndWaitForEvent(Runnable,AccessibilityEventFilter,long)>",0,"{
    // Acquire the lock and prepare for receiving events.
    synchronized (mLock) {
        throwIfNotConnectedLocked();
        mEventQueue.clear();
        // Prepare to wait for an event.
        mWaitingForEventDelivery = true;
    }
    // Note: We have to release the lock since calling out with this lock held
    // can bite. We will correctly filter out events from other interactions,
    // so starting to collect events before running the action is just fine.
    // We will ignore events from previous interactions.
    final long executionStartTimeMillis = SystemClock.uptimeMillis();
    // Execute the command *without* the lock being held.
    command.run();
    // Acquire the lock and wait for the event.
    try {
        // Wait for the event.
        final long startTimeMillis = SystemClock.uptimeMillis();
        while (true) {
            List<AccessibilityEvent> localEvents = new ArrayList<>();
            synchronized (mLock) {
                localEvents.addAll(mEventQueue);
                mEventQueue.clear();
            }
            // Drain the event queue
            while (!localEvents.isEmpty()) {
                AccessibilityEvent event = localEvents.remove(0);
                // Ignore events from previous interactions.
                if (event.getEventTime() < executionStartTimeMillis) {
                    continue;
                }
                if (filter.accept(event)) {
                    return event;
                }
                event.recycle();
            }
            // Check if timed out and if not wait.
            final long elapsedTimeMillis = SystemClock.uptimeMillis() - startTimeMillis;
            final long remainingTimeMillis = timeoutMillis - elapsedTimeMillis;
            if (remainingTimeMillis <= 0) {
                throw new TimeoutException(""Expected event not received within: "" + timeoutMillis + "" ms."");
            }
            synchronized (mLock) {
                if (mEventQueue.isEmpty()) {
                    try {
                        mLock.wait(remainingTimeMillis);
                    } catch (InterruptedException ie) {
                    /* ignore */
                    }
                }
            }
        }
    } finally {
        synchronized (mLock) {
            mWaitingForEventDelivery = false;
            mEventQueue.clear();
            mLock.notifyAll();
        }
    }
}","{
    // Acquire the lock and prepare for receiving events.
    synchronized (mLock) {
        throwIfNotConnectedLocked();
        mEventQueue.clear();
        // Prepare to wait for an event.
        mWaitingForEventDelivery = true;
    }
    // Note: We have to release the lock since calling out with this lock held
    // can bite. We will correctly filter out events from other interactions,
    // so starting to collect events before running the action is just fine.
    // We will ignore events from previous interactions.
    final long executionStartTimeMillis = SystemClock.uptimeMillis();
    // Execute the command *without* the lock being held.
    command.run();
    List<AccessibilityEvent> receivedEvents = new ArrayList<>();
    // Acquire the lock and wait for the event.
    try {
        // Wait for the event.
        final long startTimeMillis = SystemClock.uptimeMillis();
        while (true) {
            List<AccessibilityEvent> localEvents = new ArrayList<>();
            synchronized (mLock) {
                localEvents.addAll(mEventQueue);
                mEventQueue.clear();
            }
            // Drain the event queue
            while (!localEvents.isEmpty()) {
                AccessibilityEvent event = localEvents.remove(0);
                // Ignore events from previous interactions.
                if (event.getEventTime() < executionStartTimeMillis) {
                    continue;
                }
                if (filter.accept(event)) {
                    return event;
                }
                receivedEvents.add(event);
            }
            // Check if timed out and if not wait.
            final long elapsedTimeMillis = SystemClock.uptimeMillis() - startTimeMillis;
            final long remainingTimeMillis = timeoutMillis - elapsedTimeMillis;
            if (remainingTimeMillis <= 0) {
                throw new TimeoutException(""Expected event not received within: "" + timeoutMillis + "" ms among: "" + receivedEvents);
            }
            synchronized (mLock) {
                if (mEventQueue.isEmpty()) {
                    try {
                        mLock.wait(remainingTimeMillis);
                    } catch (InterruptedException ie) {
                    /* ignore */
                    }
                }
            }
        }
    } finally {
        int size = receivedEvents.size();
        for (int i = 0; i < size; i++) {
            receivedEvents.get(i).recycle();
        }
        synchronized (mLock) {
            mWaitingForEventDelivery = false;
            mEventQueue.clear();
            mLock.notifyAll();
        }
    }
}",1,"/**
 * Executes a command and waits for a specific accessibility event up to a
 * given wait timeout. To detect a sequence of events one can implement a
 * filter that keeps track of seen events of the expected sequence and
 * returns true after the last event of that sequence is received.
 * <p>
 * <strong>Note:</strong> It is caller's responsibility to recycle the returned event.
 * </p>
 * @param command The command to execute.
 * @param filter Filter that recognizes the expected event.
 * @param timeoutMillis The wait timeout in milliseconds.
 *
 * @throws TimeoutException If the expected event is not received within the timeout.
 */
","/**
 * Executes a command and waits for a specific accessibility event up to a
 * given wait timeout. To detect a sequence of events one can implement a
 * filter that keeps track of seen events of the expected sequence and
 * returns true after the last event of that sequence is received.
 * <p>
 * <strong>Note:</strong> It is caller's responsibility to recycle the returned event.
 * </p>
 * @param command The command to execute.
 * @param filter Filter that recognizes the expected event.
 * @param timeoutMillis The wait timeout in milliseconds.
 *
 * @throws TimeoutException If the expected event is not received within the timeout.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,2,3,4","1,2",The implementation is changed in several ways: ,"- An exception `TimeoutException` is thrown with a different message, now including the `receivedEvents`."
363,"<android.service.autofill.ImageTransformation.Builder: Builder addOption(Pattern,int)>",27,28,"<android.service.autofill.ImageTransformation.Builder: Builder addOption(Pattern,int)>","<android.service.autofill.ImageTransformation.Builder: Builder addOption(Pattern,int)>",0,"{
    throwIfDestroyed();
    Preconditions.checkNotNull(regex);
    Preconditions.checkArgument(resId != 0);
    mOptions.add(new Pair<>(regex, resId));
    return this;
}","{
    addOptionInternal(regex, resId, null);
    return this;
}",1,"/**
 * Adds an option to replace the child view with a different image when the regex matches.
 *
 * @param regex regular expression defining what should be matched to use this image.
 * @param resId resource id of the image (in the autofill service's package). The
 * {@link RemoteViews presentation} must contain a {@link ImageView} child with that id.
 *
 * @return this build
 */
","/**
 * Adds an option to replace the child view with a different image when the regex matches.
 *
 * @param regex regular expression defining what should be matched to use this image.
 * @param resId resource id of the image (in the autofill service's package). The
 * {@link RemoteViews presentation} must contain a {@link ImageView} child with that id.
 *
 * @return this build
 *
 * @deprecated use {@link #addOption(Pattern, int, CharSequence)} instead.
 */
",-1,,[@Deprecated],-1,-1,-1,-1,-1,-1,"4,5",0,"The early version of the method directly adds a new option with checks and throws exceptions if conditions are not satisfied. In the late version, an internal method addOptionInternal is called instead. Since there is no information on the implementation of addOptionInternal, the actual behavior could be different. This is classified as a change in other statements (4) because the calls within the method are different and there is also a change in the dependent API (5), as the actual operation depends on the new internal method addOptionInternal.","According to the information provided, the calling of addOptionInternal instead of directly adding an option as in the early version doesn't necessarily lead to a different return value or exception handling, assuming addOptionInternal is doing the same checks and adding operations as the early version. Therefore, no compatibility issue is detected (0)."
365,"<android.text.BoringLayout: BoringLayout replaceOrMake(CharSequence,TextPaint,int,Alignment,float,float,Metrics,boolean,TruncateAt,int)>",27,28,"<android.text.BoringLayout: BoringLayout replaceOrMake(CharSequence,TextPaint,int,Alignment,float,float,Metrics,boolean,TruncateAt,int)>","<android.text.BoringLayout: BoringLayout replaceOrMake(CharSequence,TextPaint,int,Alignment,float,float,Metrics,boolean,TruncateAt,int)>",0,"{
    boolean trust;
    if (ellipsize == null || ellipsize == TextUtils.TruncateAt.MARQUEE) {
        replaceWith(source, paint, outerwidth, align, spacingmult, spacingadd);
        mEllipsizedWidth = outerwidth;
        mEllipsizedStart = 0;
        mEllipsizedCount = 0;
        trust = true;
    } else {
        replaceWith(TextUtils.ellipsize(source, paint, ellipsizedWidth, ellipsize, true, this), paint, outerwidth, align, spacingmult, spacingadd);
        mEllipsizedWidth = ellipsizedWidth;
        trust = false;
    }
    init(getText(), paint, outerwidth, align, spacingmult, spacingadd, metrics, includepad, trust);
    return this;
}","{
    boolean trust;
    if (ellipsize == null || ellipsize == TextUtils.TruncateAt.MARQUEE) {
        replaceWith(source, paint, outerWidth, align, spacingMult, spacingAdd);
        mEllipsizedWidth = outerWidth;
        mEllipsizedStart = 0;
        mEllipsizedCount = 0;
        trust = true;
    } else {
        replaceWith(TextUtils.ellipsize(source, paint, ellipsizedWidth, ellipsize, true, this), paint, outerWidth, align, spacingMult, spacingAdd);
        mEllipsizedWidth = ellipsizedWidth;
        trust = false;
    }
    init(getText(), paint, align, metrics, includePad, trust);
    return this;
}",1,"/**
 * Returns a BoringLayout for the specified text, potentially reusing
 * this one if it is already suitable.  The caller must make sure that
 * no one is still using this Layout.
 */
","/**
 * Returns a BoringLayout for the specified text, potentially reusing
 * this one if it is already suitable.  The caller must make sure that
 * no one is still using this Layout.
 *
 * @param source the text to render
 * @param paint the default paint for the layout
 * @param outerWidth the wrapping width for the text
 * @param align whether to left, right, or center the text
 * @param spacingMult this value is no longer used by BoringLayout
 * @param spacingAdd this value is no longer used by BoringLayout
 * @param metrics {@code #Metrics} instance that contains information about FontMetrics and
 * line width
 * @param includePad set whether to include extra space beyond font ascent and descent which is
 * needed to avoid clipping in some scripts
 * @param ellipsize whether to ellipsize the text if width of the text is longer than the
 * requested width
 * @param ellipsizedWidth the width to which this Layout is ellipsizing. If {@code ellipsize} is
 * {@code null}, or is {@link TextUtils.TruncateAt#MARQUEE} this value is
 * not used, {@code outerwidth} is used instead
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,4",1,"The early version of the implementation calls 'init' with 9 parameters, while the late version only calls it with 7. Also, variable names' casing in the late version has changed, this is another statement change (although it's just a refactoring and does not impact the behavior). Hence, the change types include a Return statement changed (1) and Other statement changed (4).","Due to the change in the number of parameters in the 'init' method call, there's a possible CI caused by a potentially different return value. The refactor of variable names does not cause a change in behavior; therefore, it wouldn't be considered a CI. The change in the 'init' method is classified as type 1."
366,<android.view.accessibility.AccessibilityManager: boolean isEnabled()>,27,28,<android.view.accessibility.AccessibilityManager: boolean isEnabled()>,<android.view.accessibility.AccessibilityManager: boolean isEnabled()>,0,"{
    synchronized (mLock) {
        IAccessibilityManager service = getServiceLocked();
        if (service == null) {
            return false;
        }
        return mIsEnabled;
    }
}","{
    synchronized (mLock) {
        return mIsEnabled || (mAccessibilityPolicy != null && mAccessibilityPolicy.isEnabled(mIsEnabled));
    }
}",1,"/**
 * Returns if the accessibility in the system is enabled.
 *
 * @return True if accessibility is enabled, false otherwise.
 */
","/**
 * Returns if the accessibility in the system is enabled.
 *
 * @return True if accessibility is enabled, false otherwise.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3",1,"The return statement inside the synchronized block has been modified to include an additional condition involving mAccessibilityPolicy, and the control dependency that previously checked for the service being null has been removed. This constitutes a return statement change and a control dependency change, so the code change type is 1,3.","The new return value is dependent on a new condition (mAccessibilityPolicy != null && mAccessibilityPolicy.isEnabled(mIsEnabled)) which did not exist in the early version. This means the late version of the API could potentially return a different value under certain conditions, leading to a CI of type 1."
367,<android.view.accessibility.AccessibilityManager: void sendAccessibilityEvent(AccessibilityEvent)>,27,28,<android.view.accessibility.AccessibilityManager: void sendAccessibilityEvent(AccessibilityEvent)>,<android.view.accessibility.AccessibilityManager: void sendAccessibilityEvent(AccessibilityEvent)>,0,"{
    final IAccessibilityManager service;
    final int userId;
    synchronized (mLock) {
        service = getServiceLocked();
        if (service == null) {
            return;
        }
        if (!mIsEnabled) {
            Looper myLooper = Looper.myLooper();
            if (myLooper == Looper.getMainLooper()) {
                throw new IllegalStateException(""Accessibility off. Did you forget to check that?"");
            } else {
                // If we're not running on the thread with the main looper, it's possible for
                // the state of accessibility to change between checking isEnabled and
                // calling this method. So just log the error rather than throwing the
                // exception.
                Log.e(LOG_TAG, ""AccessibilityEvent sent with accessibility disabled"");
                return;
            }
        }
        if ((event.getEventType() & mRelevantEventTypes) == 0) {
            if (DEBUG) {
                Log.i(LOG_TAG, ""Not dispatching irrelevant event: "" + event + "" that is not among "" + AccessibilityEvent.eventTypeToString(mRelevantEventTypes));
            }
            return;
        }
        userId = mUserId;
    }
    try {
        event.setEventTime(SystemClock.uptimeMillis());
        // it is possible that this manager is in the same process as the service but
        // client using it is called through Binder from another process. Example: MMS
        // app adds a SMS notification and the NotificationManagerService calls this method
        long identityToken = Binder.clearCallingIdentity();
        service.sendAccessibilityEvent(event, userId);
        Binder.restoreCallingIdentity(identityToken);
        if (DEBUG) {
            Log.i(LOG_TAG, event + "" sent"");
        }
    } catch (RemoteException re) {
        Log.e(LOG_TAG, ""Error during sending "" + event + "" "", re);
    } finally {
        event.recycle();
    }
}","{
    final IAccessibilityManager service;
    final int userId;
    final AccessibilityEvent dispatchedEvent;
    synchronized (mLock) {
        service = getServiceLocked();
        if (service == null) {
            return;
        }
        event.setEventTime(SystemClock.uptimeMillis());
        if (mAccessibilityPolicy != null) {
            dispatchedEvent = mAccessibilityPolicy.onAccessibilityEvent(event, mIsEnabled, mRelevantEventTypes);
            if (dispatchedEvent == null) {
                return;
            }
        } else {
            dispatchedEvent = event;
        }
        if (!isEnabled()) {
            Looper myLooper = Looper.myLooper();
            if (myLooper == Looper.getMainLooper()) {
                throw new IllegalStateException(""Accessibility off. Did you forget to check that?"");
            } else {
                // If we're not running on the thread with the main looper, it's possible for
                // the state of accessibility to change between checking isEnabled and
                // calling this method. So just log the error rather than throwing the
                // exception.
                Log.e(LOG_TAG, ""AccessibilityEvent sent with accessibility disabled"");
                return;
            }
        }
        if ((dispatchedEvent.getEventType() & mRelevantEventTypes) == 0) {
            if (DEBUG) {
                Log.i(LOG_TAG, ""Not dispatching irrelevant event: "" + dispatchedEvent + "" that is not among "" + AccessibilityEvent.eventTypeToString(mRelevantEventTypes));
            }
            return;
        }
        userId = mUserId;
    }
    try {
        // it is possible that this manager is in the same process as the service but
        // client using it is called through Binder from another process. Example: MMS
        // app adds a SMS notification and the NotificationManagerService calls this method
        long identityToken = Binder.clearCallingIdentity();
        try {
            service.sendAccessibilityEvent(dispatchedEvent, userId);
        } finally {
            Binder.restoreCallingIdentity(identityToken);
        }
        if (DEBUG) {
            Log.i(LOG_TAG, dispatchedEvent + "" sent"");
        }
    } catch (RemoteException re) {
        Log.e(LOG_TAG, ""Error during sending "" + dispatchedEvent + "" "", re);
    } finally {
        if (event != dispatchedEvent) {
            event.recycle();
        }
        dispatchedEvent.recycle();
    }
}",1,"/**
 * Sends an {@link AccessibilityEvent}.
 *
 * @param event The event to send.
 *
 * @throws IllegalStateException if accessibility is not enabled.
 *
 * <strong>Note:</strong> The preferred mechanism for sending custom accessibility
 * events is through calling
 * {@link android.view.ViewParent#requestSendAccessibilityEvent(View, AccessibilityEvent)}
 * instead of this method to allow predecessors to augment/filter events sent by
 * their descendants.
 */
","/**
 * Sends an {@link AccessibilityEvent}.
 *
 * @param event The event to send.
 *
 * @throws IllegalStateException if accessibility is not enabled.
 *
 * <strong>Note:</strong> The preferred mechanism for sending custom accessibility
 * events is through calling
 * {@link android.view.ViewParent#requestSendAccessibilityEvent(View, AccessibilityEvent)}
 * instead of this method to allow predecessors to augment/filter events sent by
 * their descendants.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,2,3,5","1,2",The code underwent several changes:,- The isEnabled() check has been added in the synchronized block to replace the mIsEnabled check.
368,<android.bluetooth.le.PeriodicAdvertisingParameters.Builder: PeriodicAdvertisingParameters build()>,27,28,<android.bluetooth.le.PeriodicAdvertisingParameters.Builder: PeriodicAdvertisingParameters build()>,<android.bluetooth.le.PeriodicAdvertisingParameters.Builder: PeriodicAdvertisingParameters build()>,0,"{
    return new PeriodicAdvertisingParameters(includeTxPower, interval);
}","{
    return new PeriodicAdvertisingParameters(mIncludeTxPower, mInterval);
}",1,"/**
 * Build the {@link AdvertisingSetParameters} object.
 */
","/**
 * Build the {@link AdvertisingSetParameters} object.
 */
",-1,,,-1,-1,-1,-1,-1,-1,0,0,"There is no actual code difference between the early and late version; the variable names have been changed, but they represent the same behavior and usage, thus no fundamental code change has occurred.",There will be no compatibility issue as there is no change to the behavior of the code between the two versions. The method will return the same value with the same type for the given parameters.
369,"<android.content.res.TypedArray: int getDimensionPixelSize(int,int)>",27,28,"<android.content.res.TypedArray: int getDimensionPixelSize(int,int)>","<android.content.res.TypedArray: int getDimensionPixelSize(int,int)>",0,"{
    if (mRecycled) {
        throw new RuntimeException(""Cannot make calls to a recycled instance!"");
    }
    final int attrIndex = index;
    index *= AssetManager.STYLE_NUM_ENTRIES;
    final int[] data = mData;
    final int type = data[index + AssetManager.STYLE_TYPE];
    if (type == TypedValue.TYPE_NULL) {
        return defValue;
    } else if (type == TypedValue.TYPE_DIMENSION) {
        return TypedValue.complexToDimensionPixelSize(data[index + AssetManager.STYLE_DATA], mMetrics);
    } else if (type == TypedValue.TYPE_ATTRIBUTE) {
        final TypedValue value = mValue;
        getValueAt(index, value);
        throw new UnsupportedOperationException(""Failed to resolve attribute at index "" + attrIndex + "": "" + value);
    }
    throw new UnsupportedOperationException(""Can't convert value at index "" + attrIndex + "" to dimension: type=0x"" + Integer.toHexString(type));
}","{
    if (mRecycled) {
        throw new RuntimeException(""Cannot make calls to a recycled instance!"");
    }
    final int attrIndex = index;
    index *= STYLE_NUM_ENTRIES;
    final int[] data = mData;
    final int type = data[index + STYLE_TYPE];
    if (type == TypedValue.TYPE_NULL) {
        return defValue;
    } else if (type == TypedValue.TYPE_DIMENSION) {
        return TypedValue.complexToDimensionPixelSize(data[index + STYLE_DATA], mMetrics);
    } else if (type == TypedValue.TYPE_ATTRIBUTE) {
        final TypedValue value = mValue;
        getValueAt(index, value);
        throw new UnsupportedOperationException(""Failed to resolve attribute at index "" + attrIndex + "": "" + value);
    }
    throw new UnsupportedOperationException(""Can't convert value at index "" + attrIndex + "" to dimension: type=0x"" + Integer.toHexString(type));
}",1,"/**
 * Retrieve a dimensional unit attribute at <var>index</var> for use
 * as a size in raw pixels.  This is the same as
 * {@link #getDimension}, except the returned value is converted to
 * integer pixels for use as a size.  A size conversion involves
 * rounding the base value, and ensuring that a non-zero base value
 * is at least one pixel in size.
 * <p>
 * This method will throw an exception if the attribute is defined but is
 * not a dimension.
 *
 * @param index Index of attribute to retrieve.
 * @param defValue Value to return if the attribute is not defined or
 * not a resource.
 *
 * @return Attribute dimension value multiplied by the appropriate
 * metric and truncated to integer pixels, or defValue if not defined.
 * @throws RuntimeException if the TypedArray has already been recycled.
 * @throws UnsupportedOperationException if the attribute is defined but is
 * not a dimension.
 *
 * @see #getDimension
 * @see #getDimensionPixelOffset
 */
","/**
 * Retrieve a dimensional unit attribute at <var>index</var> for use
 * as a size in raw pixels.  This is the same as
 * {@link #getDimension}, except the returned value is converted to
 * integer pixels for use as a size.  A size conversion involves
 * rounding the base value, and ensuring that a non-zero base value
 * is at least one pixel in size.
 * <p>
 * This method will throw an exception if the attribute is defined but is
 * not a dimension.
 *
 * @param index Index of attribute to retrieve.
 * @param defValue Value to return if the attribute is not defined or
 * not a resource.
 *
 * @return Attribute dimension value multiplied by the appropriate
 * metric and truncated to integer pixels, or defValue if not defined.
 * @throws RuntimeException if the TypedArray has already been recycled.
 * @throws UnsupportedOperationException if the attribute is defined but is
 * not a dimension.
 *
 * @see #getDimension
 * @see #getDimensionPixelOffset
 */
",-1,,,-1,-1,-1,-1,-1,-1,0,0,"The implementation is the same between the two versions except for the use of `AssetManager.STYLE_NUM_ENTRIES` in the early version and `STYLE_NUM_ENTRIES` in the late version, which seems to be a change in naming that does not affect the functionality assuming `STYLE_NUM_ENTRIES` remains defined the same way. The logic and the code behavior remain unchanged. The annotations do not provide information that would change this assessment.",There is no Compatibility Issue detected because there were no changes that could potentially affect the behavior or output of the API.
370,"<android.provider.Settings.Secure: float getFloat(ContentResolver,String)>",27,28,"<android.provider.Settings.Secure: float getFloat(ContentResolver,String)>","<android.provider.Settings.Secure: float getFloat(ContentResolver,String)>",0,"{
    return getFloatForUser(cr, name, UserHandle.myUserId());
}","{
    return getFloatForUser(cr, name, cr.getUserId());
}",1,"/**
 * Convenience function for retrieving a single secure settings value
 * as a float.  Note that internally setting values are always
 * stored as strings; this function converts the string to a float
 * for you.
 * <p>
 * This version does not take a default value.  If the setting has not
 * been set, or the string value is not a number,
 * it throws {@link SettingNotFoundException}.
 *
 * @param cr The ContentResolver to access.
 * @param name The name of the setting to retrieve.
 *
 * @throws SettingNotFoundException Thrown if a setting by the given
 * name can't be found or the setting value is not a float.
 *
 * @return The setting's current value.
 */
","/**
 * Convenience function for retrieving a single secure settings value
 * as a float.  Note that internally setting values are always
 * stored as strings; this function converts the string to a float
 * for you.
 * <p>
 * This version does not take a default value.  If the setting has not
 * been set, or the string value is not a number,
 * it throws {@link SettingNotFoundException}.
 *
 * @param cr The ContentResolver to access.
 * @param name The name of the setting to retrieve.
 *
 * @throws SettingNotFoundException Thrown if a setting by the given
 * name can't be found or the setting value is not a float.
 *
 * @return The setting's current value.
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The method getFloatForUser() has been called with a different parameter in the late version: cr.getUserId() has replaced UserHandle.myUserId(). This indicates that a dependent API has changed, therefore the code change is of type 5.","There is no compatibility issue detected because the return type remains the same and there's no indication that the behavior of getFloatForUser() itself has changed, merely the user ID being passed to it. It's assumed that the UserHandle.myUserId() and cr.getUserId() will return the current user ID, and therefore the behavior of the API should be consistent, leading to the conclusion of no compatibility issue (type 0)."
371,<android.view.WindowInsets: String toString()>,27,28,<android.view.WindowInsets: String toString()>,<android.view.WindowInsets: String toString()>,0,"{
    return ""WindowInsets{systemWindowInsets="" + mSystemWindowInsets + "" windowDecorInsets="" + mWindowDecorInsets + "" stableInsets="" + mStableInsets + (isRound() ? "" round}"" : ""}"");
}","{
    return ""WindowInsets{systemWindowInsets="" + mSystemWindowInsets + "" windowDecorInsets="" + mWindowDecorInsets + "" stableInsets="" + mStableInsets + (mDisplayCutout != null ? "" cutout="" + mDisplayCutout : """") + (isRound() ? "" round"" : """") + ""}"";
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"The string returned has new content added related to mDisplayCutout and has slightly modified formatting for the ""round"" part. No return types, exception handling, or control dependencies have changed; hence the change is categorized as other statement change (4).","There is no Compatibility Issue here because the method simply returns a string representing the WindowInsets object and this change does not affect the object's behavior. It only changes the representation, not the functionality or the outcome that would affect how an application works. Thus, the CI type is 0."
372,<android.widget.TextView: boolean onGenericMotionEvent(MotionEvent)>,27,28,<android.widget.TextView: boolean onGenericMotionEvent(MotionEvent)>,<android.widget.TextView: boolean onGenericMotionEvent(MotionEvent)>,0,"{
    if (mMovement != null && mText instanceof Spannable && mLayout != null) {
        try {
            if (mMovement.onGenericMotionEvent(this, (Spannable) mText, event)) {
                return true;
            }
        } catch (AbstractMethodError ex) {
        // onGenericMotionEvent was added to the MovementMethod interface in API 12.
        // Ignore its absence in case third party applications implemented the
        // interface directly.
        }
    }
    return super.onGenericMotionEvent(event);
}","{
    if (mMovement != null && mText instanceof Spannable && mLayout != null) {
        try {
            if (mMovement.onGenericMotionEvent(this, mSpannable, event)) {
                return true;
            }
        } catch (AbstractMethodError ex) {
        // onGenericMotionEvent was added to the MovementMethod interface in API 12.
        // Ignore its absence in case third party applications implemented the
        // interface directly.
        }
    }
    return super.onGenericMotionEvent(event);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"The only change in the code is the type cast of `mText` was replaced with `mSpannable`. Since `mSpannable` is not defined explicitly in the context provided, it is assumed here to be a member variable of type `Spannable`. This means that the actual argument to `mMovement.onGenericMotionEvent` has not changed its type but only the expression used to refer to it was modified. Therefore, this change can be classified as 4.","There are no changes related to return statements or exception handling; thus, this change does not lead to a CI, so CI type is 0."
373,<android.hardware.fingerprint.FingerprintManager.CryptoObject: Cipher getCipher()>,27,28,<android.hardware.fingerprint.FingerprintManager.CryptoObject: Cipher getCipher()>,<android.hardware.fingerprint.FingerprintManager.CryptoObject: Cipher getCipher()>,0,"{
    return mCrypto instanceof Cipher ? (Cipher) mCrypto : null;
}","{
    return super.getCipher();
}",1,"/**
 * Get {@link Cipher} object.
 * @return {@link Cipher} object or null if this doesn't contain one.
 */
","/**
 * Get {@link Cipher} object.
 * @return {@link Cipher} object or null if this doesn't contain one.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The implementation has switched from an inline conditional check to using a superclass method called super.getCipher(). This may indicate that the dependency on how the Cipher object is retrieved has changed, hence it is both a return statement change and a dependent API change, falling into categories 1 and 5.","Since the source of the returned Cipher object has changed, there is potential for different behaviors. The late version delegates to the superclass's getCipher method, which could have a different implementation compared to the inline ternary operation used in the early version. This could result in a different Cipher object being returned, leading to a Classification Issue type 1."
374,"<android.app.PendingIntent: void send(Context,int,Intent,OnFinished,Handler,String,Bundle)>",27,28,"<android.app.PendingIntent: void send(Context,int,Intent,OnFinished,Handler,String,Bundle)>","<android.app.PendingIntent: void send(Context,int,Intent,OnFinished,Handler,String,Bundle)>",0,"{
    try {
        String resolvedType = intent != null ? intent.resolveTypeIfNeeded(context.getContentResolver()) : null;
        int res = ActivityManager.getService().sendIntentSender(mTarget, mWhitelistToken, code, intent, resolvedType, onFinished != null ? new FinishedDispatcher(this, onFinished, handler) : null, requiredPermission, options);
        if (res < 0) {
            throw new CanceledException();
        }
    } catch (RemoteException e) {
        throw new CanceledException(e);
    }
}","{
    if (sendAndReturnResult(context, code, intent, onFinished, handler, requiredPermission, options) < 0) {
        throw new CanceledException();
    }
}",1,"/**
 * Perform the operation associated with this PendingIntent, allowing the
 * caller to specify information about the Intent to use and be notified
 * when the send has completed.
 *
 * <p>For the intent parameter, a PendingIntent
 * often has restrictions on which fields can be supplied here, based on
 * how the PendingIntent was retrieved in {@link #getActivity},
 * {@link #getBroadcast}, or {@link #getService}.
 *
 * @param context The Context of the caller.  This may be null if
 * <var>intent</var> is also null.
 * @param code Result code to supply back to the PendingIntent's target.
 * @param intent Additional Intent data.  See {@link Intent#fillIn
 * Intent.fillIn()} for information on how this is applied to the
 * original Intent.  Use null to not modify the original Intent.
 * If flag {@link #FLAG_IMMUTABLE} was set when this pending intent was
 * created, this argument will be ignored.
 * @param onFinished The object to call back on when the send has
 * completed, or null for no callback.
 * @param handler Handler identifying the thread on which the callback
 * should happen.  If null, the callback will happen from the thread
 * pool of the process.
 * @param requiredPermission Name of permission that a recipient of the PendingIntent
 * is required to hold.  This is only valid for broadcast intents, and
 * corresponds to the permission argument in
 * {@link Context#sendBroadcast(Intent, String) Context.sendOrderedBroadcast(Intent, String)}.
 * If null, no permission is required.
 * @param options Additional options the caller would like to provide to modify the sending
 * behavior.  May be built from an {@link ActivityOptions} to apply to an activity start.
 *
 * @see #send()
 * @see #send(int)
 * @see #send(Context, int, Intent)
 * @see #send(int, android.app.PendingIntent.OnFinished, Handler)
 * @see #send(Context, int, Intent, OnFinished, Handler)
 *
 * @throws CanceledException Throws CanceledException if the PendingIntent
 * is no longer allowing more intents to be sent through it.
 */
","/**
 * Perform the operation associated with this PendingIntent, allowing the
 * caller to specify information about the Intent to use and be notified
 * when the send has completed.
 *
 * <p>For the intent parameter, a PendingIntent
 * often has restrictions on which fields can be supplied here, based on
 * how the PendingIntent was retrieved in {@link #getActivity},
 * {@link #getBroadcast}, or {@link #getService}.
 *
 * @param context The Context of the caller.  This may be null if
 * <var>intent</var> is also null.
 * @param code Result code to supply back to the PendingIntent's target.
 * @param intent Additional Intent data.  See {@link Intent#fillIn
 * Intent.fillIn()} for information on how this is applied to the
 * original Intent.  Use null to not modify the original Intent.
 * If flag {@link #FLAG_IMMUTABLE} was set when this pending intent was
 * created, this argument will be ignored.
 * @param onFinished The object to call back on when the send has
 * completed, or null for no callback.
 * @param handler Handler identifying the thread on which the callback
 * should happen.  If null, the callback will happen from the thread
 * pool of the process.
 * @param requiredPermission Name of permission that a recipient of the PendingIntent
 * is required to hold.  This is only valid for broadcast intents, and
 * corresponds to the permission argument in
 * {@link Context#sendBroadcast(Intent, String) Context.sendOrderedBroadcast(Intent, String)}.
 * If null, no permission is required.
 * @param options Additional options the caller would like to provide to modify the sending
 * behavior.  May be built from an {@link ActivityOptions} to apply to an activity start.
 *
 * @see #send()
 * @see #send(int)
 * @see #send(Context, int, Intent)
 * @see #send(int, android.app.PendingIntent.OnFinished, Handler)
 * @see #send(Context, int, Intent, OnFinished, Handler)
 *
 * @throws CanceledException Throws CanceledException if the PendingIntent
 * is no longer allowing more intents to be sent through it.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,4,5","1,2","The return statement and the exception handling statement have changed because the inline code performing the send operation in the early version is replaced by a call to the sendAndReturnResult method in the late version. Since the implementation details are moved to this new method, this change involves both the return statement and exception handling statement changes (1,2) as well as a change in a dependent API (5) because now the API relies on the new sendAndReturnResult method, which can have different behavior compared to the inline code.","The new dependent API may return a different result than the previous inline code or may handle exceptions differently. Since the inline implementation details are no longer visible within the scope of this API, we cannot be sure if the sendAndReturnResult method behaves identically to the inline code from the early version. Thus, there is a possibility for a Compatibility Issue caused by potential different return values (1) and a different exception being thrown (2)."
375,<android.bluetooth.BluetoothSocket: int bindListen()>,27,28,<android.bluetooth.BluetoothSocket: int bindListen()>,<android.bluetooth.BluetoothSocket: int bindListen()>,0,"{
    int ret;
    if (mSocketState == SocketState.CLOSED)
        return EBADFD;
    IBluetooth bluetoothProxy = BluetoothAdapter.getDefaultAdapter().getBluetoothService(null);
    if (bluetoothProxy == null) {
        Log.e(TAG, ""bindListen fail, reason: bluetooth is off"");
        return -1;
    }
    try {
        mPfd = bluetoothProxy.createSocketChannel(mType, mServiceName, mUuid, mPort, getSecurityFlags());
    } catch (RemoteException e) {
        Log.e(TAG, Log.getStackTraceString(new Throwable()));
        return -1;
    }
    // read out port number
    try {
        synchronized (this) {
            if (DBG)
                Log.d(TAG, ""bindListen(), SocketState: "" + mSocketState + "", mPfd: "" + mPfd);
            if (mSocketState != SocketState.INIT)
                return EBADFD;
            if (mPfd == null)
                return -1;
            FileDescriptor fd = mPfd.getFileDescriptor();
            if (fd == null) {
                Log.e(TAG, ""bindListen(), null file descriptor"");
                return -1;
            }
            if (DBG)
                Log.d(TAG, ""bindListen(), Create LocalSocket"");
            mSocket = LocalSocket.createConnectedLocalSocket(fd);
            if (DBG)
                Log.d(TAG, ""bindListen(), new LocalSocket.getInputStream()"");
            mSocketIS = mSocket.getInputStream();
            mSocketOS = mSocket.getOutputStream();
        }
        if (DBG)
            Log.d(TAG, ""bindListen(), readInt mSocketIS: "" + mSocketIS);
        int channel = readInt(mSocketIS);
        synchronized (this) {
            if (mSocketState == SocketState.INIT)
                mSocketState = SocketState.LISTENING;
        }
        if (DBG)
            Log.d(TAG, ""channel: "" + channel);
        if (mPort <= -1) {
            mPort = channel;
        }
        // else ASSERT(mPort == channel)
        ret = 0;
    } catch (IOException e) {
        if (mPfd != null) {
            try {
                mPfd.close();
            } catch (IOException e1) {
                Log.e(TAG, ""bindListen, close mPfd: "" + e1);
            }
            mPfd = null;
        }
        Log.e(TAG, ""bindListen, fail to get port number, exception: "" + e);
        return -1;
    }
    return ret;
}","{
    int ret;
    if (mSocketState == SocketState.CLOSED)
        return EBADFD;
    IBluetooth bluetoothProxy = BluetoothAdapter.getDefaultAdapter().getBluetoothService(null);
    if (bluetoothProxy == null) {
        Log.e(TAG, ""bindListen fail, reason: bluetooth is off"");
        return -1;
    }
    try {
        if (DBG)
            Log.d(TAG, ""bindListen(): mPort="" + mPort + "", mType="" + mType);
        mPfd = bluetoothProxy.getSocketManager().createSocketChannel(mType, mServiceName, mUuid, mPort, getSecurityFlags());
    } catch (RemoteException e) {
        Log.e(TAG, Log.getStackTraceString(new Throwable()));
        return -1;
    }
    // read out port number
    try {
        synchronized (this) {
            if (DBG) {
                Log.d(TAG, ""bindListen(), SocketState: "" + mSocketState + "", mPfd: "" + mPfd);
            }
            if (mSocketState != SocketState.INIT)
                return EBADFD;
            if (mPfd == null)
                return -1;
            FileDescriptor fd = mPfd.getFileDescriptor();
            if (fd == null) {
                Log.e(TAG, ""bindListen(), null file descriptor"");
                return -1;
            }
            if (DBG)
                Log.d(TAG, ""bindListen(), Create LocalSocket"");
            mSocket = LocalSocket.createConnectedLocalSocket(fd);
            if (DBG)
                Log.d(TAG, ""bindListen(), new LocalSocket.getInputStream()"");
            mSocketIS = mSocket.getInputStream();
            mSocketOS = mSocket.getOutputStream();
        }
        if (DBG)
            Log.d(TAG, ""bindListen(), readInt mSocketIS: "" + mSocketIS);
        int channel = readInt(mSocketIS);
        synchronized (this) {
            if (mSocketState == SocketState.INIT) {
                mSocketState = SocketState.LISTENING;
            }
        }
        if (DBG)
            Log.d(TAG, ""bindListen(): channel="" + channel + "", mPort="" + mPort);
        if (mPort <= -1) {
            mPort = channel;
        }
        // else ASSERT(mPort == channel)
        ret = 0;
    } catch (IOException e) {
        if (mPfd != null) {
            try {
                mPfd.close();
            } catch (IOException e1) {
                Log.e(TAG, ""bindListen, close mPfd: "" + e1);
            }
            mPfd = null;
        }
        Log.e(TAG, ""bindListen, fail to get port number, exception: "" + e);
        return -1;
    }
    return ret;
}",1,"/*package*/
","/*package*/
",-1,,,-1,-1,-1,-1,-1,-1,,,,
376,<android.content.res.Configuration: int compareTo(Configuration)>,27,28,<android.content.res.Configuration: int compareTo(Configuration)>,<android.content.res.Configuration: int compareTo(Configuration)>,0,"{
    int n;
    float a = this.fontScale;
    float b = that.fontScale;
    if (a < b)
        return -1;
    if (a > b)
        return 1;
    n = this.mcc - that.mcc;
    if (n != 0)
        return n;
    n = this.mnc - that.mnc;
    if (n != 0)
        return n;
    fixUpLocaleList();
    that.fixUpLocaleList();
    // than any non-empty locale list.
    if (this.mLocaleList.isEmpty()) {
        if (!that.mLocaleList.isEmpty())
            return 1;
    } else if (that.mLocaleList.isEmpty()) {
        return -1;
    } else {
        final int minSize = Math.min(this.mLocaleList.size(), that.mLocaleList.size());
        for (int i = 0; i < minSize; ++i) {
            final Locale thisLocale = this.mLocaleList.get(i);
            final Locale thatLocale = that.mLocaleList.get(i);
            n = thisLocale.getLanguage().compareTo(thatLocale.getLanguage());
            if (n != 0)
                return n;
            n = thisLocale.getCountry().compareTo(thatLocale.getCountry());
            if (n != 0)
                return n;
            n = thisLocale.getVariant().compareTo(thatLocale.getVariant());
            if (n != 0)
                return n;
            n = thisLocale.toLanguageTag().compareTo(thatLocale.toLanguageTag());
            if (n != 0)
                return n;
        }
        n = this.mLocaleList.size() - that.mLocaleList.size();
        if (n != 0)
            return n;
    }
    n = this.touchscreen - that.touchscreen;
    if (n != 0)
        return n;
    n = this.keyboard - that.keyboard;
    if (n != 0)
        return n;
    n = this.keyboardHidden - that.keyboardHidden;
    if (n != 0)
        return n;
    n = this.hardKeyboardHidden - that.hardKeyboardHidden;
    if (n != 0)
        return n;
    n = this.navigation - that.navigation;
    if (n != 0)
        return n;
    n = this.navigationHidden - that.navigationHidden;
    if (n != 0)
        return n;
    n = this.orientation - that.orientation;
    if (n != 0)
        return n;
    n = this.colorMode - that.colorMode;
    if (n != 0)
        return n;
    n = this.screenLayout - that.screenLayout;
    if (n != 0)
        return n;
    n = this.uiMode - that.uiMode;
    if (n != 0)
        return n;
    n = this.screenWidthDp - that.screenWidthDp;
    if (n != 0)
        return n;
    n = this.screenHeightDp - that.screenHeightDp;
    if (n != 0)
        return n;
    n = this.smallestScreenWidthDp - that.smallestScreenWidthDp;
    if (n != 0)
        return n;
    n = this.densityDpi - that.densityDpi;
    if (n != 0)
        return n;
    n = this.assetsSeq - that.assetsSeq;
    if (n != 0)
        return n;
    if (this.appBounds == null && that.appBounds != null) {
        return 1;
    } else if (this.appBounds != null && that.appBounds == null) {
        return -1;
    } else if (this.appBounds != null && that.appBounds != null) {
        n = this.appBounds.left - that.appBounds.left;
        if (n != 0)
            return n;
        n = this.appBounds.top - that.appBounds.top;
        if (n != 0)
            return n;
        n = this.appBounds.right - that.appBounds.right;
        if (n != 0)
            return n;
        n = this.appBounds.bottom - that.appBounds.bottom;
        if (n != 0)
            return n;
    }
    // if (n != 0) return n;
    return n;
}","{
    int n;
    float a = this.fontScale;
    float b = that.fontScale;
    if (a < b)
        return -1;
    if (a > b)
        return 1;
    n = this.mcc - that.mcc;
    if (n != 0)
        return n;
    n = this.mnc - that.mnc;
    if (n != 0)
        return n;
    fixUpLocaleList();
    that.fixUpLocaleList();
    // than any non-empty locale list.
    if (this.mLocaleList.isEmpty()) {
        if (!that.mLocaleList.isEmpty())
            return 1;
    } else if (that.mLocaleList.isEmpty()) {
        return -1;
    } else {
        final int minSize = Math.min(this.mLocaleList.size(), that.mLocaleList.size());
        for (int i = 0; i < minSize; ++i) {
            final Locale thisLocale = this.mLocaleList.get(i);
            final Locale thatLocale = that.mLocaleList.get(i);
            n = thisLocale.getLanguage().compareTo(thatLocale.getLanguage());
            if (n != 0)
                return n;
            n = thisLocale.getCountry().compareTo(thatLocale.getCountry());
            if (n != 0)
                return n;
            n = thisLocale.getVariant().compareTo(thatLocale.getVariant());
            if (n != 0)
                return n;
            n = thisLocale.toLanguageTag().compareTo(thatLocale.toLanguageTag());
            if (n != 0)
                return n;
        }
        n = this.mLocaleList.size() - that.mLocaleList.size();
        if (n != 0)
            return n;
    }
    n = this.touchscreen - that.touchscreen;
    if (n != 0)
        return n;
    n = this.keyboard - that.keyboard;
    if (n != 0)
        return n;
    n = this.keyboardHidden - that.keyboardHidden;
    if (n != 0)
        return n;
    n = this.hardKeyboardHidden - that.hardKeyboardHidden;
    if (n != 0)
        return n;
    n = this.navigation - that.navigation;
    if (n != 0)
        return n;
    n = this.navigationHidden - that.navigationHidden;
    if (n != 0)
        return n;
    n = this.orientation - that.orientation;
    if (n != 0)
        return n;
    n = this.colorMode - that.colorMode;
    if (n != 0)
        return n;
    n = this.screenLayout - that.screenLayout;
    if (n != 0)
        return n;
    n = this.uiMode - that.uiMode;
    if (n != 0)
        return n;
    n = this.screenWidthDp - that.screenWidthDp;
    if (n != 0)
        return n;
    n = this.screenHeightDp - that.screenHeightDp;
    if (n != 0)
        return n;
    n = this.smallestScreenWidthDp - that.smallestScreenWidthDp;
    if (n != 0)
        return n;
    n = this.densityDpi - that.densityDpi;
    if (n != 0)
        return n;
    n = this.assetsSeq - that.assetsSeq;
    if (n != 0)
        return n;
    n = windowConfiguration.compareTo(that.windowConfiguration);
    if (n != 0)
        return n;
    // if (n != 0) return n;
    return n;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,,,,
378,<android.widget.TextView: void setTransformationMethod(TransformationMethod)>,27,28,<android.widget.TextView: void setTransformationMethod(TransformationMethod)>,<android.widget.TextView: void setTransformationMethod(TransformationMethod)>,0,"{
    if (method == mTransformation) {
        // the same.
        return;
    }
    if (mTransformation != null) {
        if (mText instanceof Spannable) {
            ((Spannable) mText).removeSpan(mTransformation);
        }
    }
    mTransformation = method;
    if (method instanceof TransformationMethod2) {
        TransformationMethod2 method2 = (TransformationMethod2) method;
        mAllowTransformationLengthChange = !isTextSelectable() && !(mText instanceof Editable);
        method2.setLengthChangesAllowed(mAllowTransformationLengthChange);
    } else {
        mAllowTransformationLengthChange = false;
    }
    setText(mText);
    if (hasPasswordTransformationMethod()) {
        notifyViewAccessibilityStateChangedIfNeeded(AccessibilityEvent.CONTENT_CHANGE_TYPE_UNDEFINED);
    }
    // PasswordTransformationMethod always have LTR text direction heuristics returned by
    // getTextDirectionHeuristic, needs reset
    mTextDir = getTextDirectionHeuristic();
}","{
    if (method == mTransformation) {
        // the same.
        return;
    }
    if (mTransformation != null) {
        if (mSpannable != null) {
            mSpannable.removeSpan(mTransformation);
        }
    }
    mTransformation = method;
    if (method instanceof TransformationMethod2) {
        TransformationMethod2 method2 = (TransformationMethod2) method;
        mAllowTransformationLengthChange = !isTextSelectable() && !(mText instanceof Editable);
        method2.setLengthChangesAllowed(mAllowTransformationLengthChange);
    } else {
        mAllowTransformationLengthChange = false;
    }
    setText(mText);
    if (hasPasswordTransformationMethod()) {
        notifyViewAccessibilityStateChangedIfNeeded(AccessibilityEvent.CONTENT_CHANGE_TYPE_UNDEFINED);
    }
    // PasswordTransformationMethod always have LTR text direction heuristics returned by
    // getTextDirectionHeuristic, needs reset
    mTextDir = getTextDirectionHeuristic();
}",1,"/**
 * Sets the transformation that is applied to the text that this
 * TextView is displaying.
 *
 * @attr ref android.R.styleable#TextView_password
 * @attr ref android.R.styleable#TextView_singleLine
 */
","/**
 * Sets the transformation that is applied to the text that this
 * TextView is displaying.
 *
 * @attr ref android.R.styleable#TextView_password
 * @attr ref android.R.styleable#TextView_singleLine
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The statement for removing the span from the text has been changed from casting mText to Spannable and removing the span to using a direct reference to mSpannable to remove the span. This change is an example of ""Other statement changed.""","There's no compatibility issue caused by this change because it does not alter the behavior of the method concerning return values or exception handling. The method's functionality remains the same, assuming mSpannable is equivalent to casting mText to Spannable when mText is an instance of Spannable. The change only modifies the internal procedure without affecting the API contract."
379,"<android.text.BoringLayout: BoringLayout make(CharSequence,TextPaint,int,Alignment,float,float,Metrics,boolean,TruncateAt,int)>",27,28,"<android.text.BoringLayout: BoringLayout make(CharSequence,TextPaint,int,Alignment,float,float,Metrics,boolean,TruncateAt,int)>","<android.text.BoringLayout: BoringLayout make(CharSequence,TextPaint,int,Alignment,float,float,Metrics,boolean,TruncateAt,int)>",0,"{
    return new BoringLayout(source, paint, outerwidth, align, spacingmult, spacingadd, metrics, includepad, ellipsize, ellipsizedWidth);
}","{
    return new BoringLayout(source, paint, outerWidth, align, spacingmult, spacingadd, metrics, includePad, ellipsize, ellipsizedWidth);
}",1,,"/**
 * Utility function to construct a BoringLayout instance.
 *
 * @param source the text to render
 * @param paint the default paint for the layout
 * @param outerWidth the wrapping width for the text
 * @param align whether to left, right, or center the text
 * @param spacingmult this value is no longer used by BoringLayout
 * @param spacingadd this value is no longer used by BoringLayout
 * @param metrics {@code #Metrics} instance that contains information about FontMetrics and
 * line width
 * @param includePad set whether to include extra space beyond font ascent and descent which is
 * needed to avoid clipping in some scripts
 * @param ellipsize whether to ellipsize the text if width of the text is longer than the
 * requested width
 * @param ellipsizedWidth the width to which this Layout is ellipsizing. If {@code ellipsize} is
 * {@code null}, or is {@link TextUtils.TruncateAt#MARQUEE} this value is
 * not used, {@code outerWidth} is used instead
 */
",-1,,,-1,-1,-1,-1,-1,-1,0,0,"There is no change in the implementation of the method. The only differences are in the capitalization of parameter names, which does not affect the behavior of the method as Java is case-sensitive and these are just variable names inside the method scope.","Since there is no actual change in the implementation, there is no compatibility issue between the two versions."
380,<android.app.Activity: boolean enterPictureInPictureMode(PictureInPictureParams)>,27,28,<android.app.Activity: boolean enterPictureInPictureMode(PictureInPictureParams)>,<android.app.Activity: boolean enterPictureInPictureMode(PictureInPictureParams)>,0,"{
    try {
        if (params == null) {
            throw new IllegalArgumentException(""Expected non-null picture-in-picture params"");
        }
        if (!mCanEnterPictureInPicture) {
            throw new IllegalStateException(""Activity must be resumed to enter"" + "" picture-in-picture"");
        }
        return ActivityManagerNative.getDefault().enterPictureInPictureMode(mToken, params);
    } catch (RemoteException e) {
        return false;
    }
}","{
    try {
        if (!deviceSupportsPictureInPictureMode()) {
            return false;
        }
        if (params == null) {
            throw new IllegalArgumentException(""Expected non-null picture-in-picture params"");
        }
        if (!mCanEnterPictureInPicture) {
            throw new IllegalStateException(""Activity must be resumed to enter"" + "" picture-in-picture"");
        }
        return ActivityManagerNative.getDefault().enterPictureInPictureMode(mToken, params);
    } catch (RemoteException e) {
        return false;
    }
}",1,"/**
 * Puts the activity in picture-in-picture mode if possible in the current system state. The
 * set parameters in {@param params} will be combined with the parameters from prior calls to
 * {@link #setPictureInPictureParams(PictureInPictureParams)}.
 *
 * The system may disallow entering picture-in-picture in various cases, including when the
 * activity is not visible, if the screen is locked or if the user has an activity pinned.
 *
 * @see android.R.attr#supportsPictureInPicture
 * @see PictureInPictureParams
 *
 * @param params non-null parameters to be combined with previously set parameters when entering
 * picture-in-picture.
 *
 * @return true if the system puts this activity into picture-in-picture mode or was already
 * in picture-in-picture mode (@see {@link #isInPictureInPictureMode())
 */
","/**
 * Puts the activity in picture-in-picture mode if possible in the current system state. The
 * set parameters in {@param params} will be combined with the parameters from prior calls to
 * {@link #setPictureInPictureParams(PictureInPictureParams)}.
 *
 * The system may disallow entering picture-in-picture in various cases, including when the
 * activity is not visible, if the screen is locked or if the user has an activity pinned.
 *
 * @see android.R.attr#supportsPictureInPicture
 * @see PictureInPictureParams
 *
 * @param params non-null parameters to be combined with previously set parameters when entering
 * picture-in-picture.
 *
 * @return true if the system successfully put this activity into picture-in-picture mode or was
 * already in picture-in-picture mode (@see {@link #isInPictureInPictureMode()). If the device
 * does not support picture-in-picture, return false.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3",1,"A new conditional check ""deviceSupportsPictureInPictureMode()"" is added before existing checks, which returns false immediately if not supported. Moreover, it does not throw an exception as previous checks. This has changed the control flow and can change the return result. Hence, the changes are of class 1 and 3.","Due to the introduction of a new condition with a return statement, the method can now return a different value (false) before it would have thrown an exception, which could lead to a different behavior for the caller, hence the CI type is 1."
381,"<android.provider.Settings.System: float getFloat(ContentResolver,String)>",27,28,"<android.provider.Settings.System: float getFloat(ContentResolver,String)>","<android.provider.Settings.System: float getFloat(ContentResolver,String)>",0,"{
    return getFloatForUser(cr, name, UserHandle.myUserId());
}","{
    return getFloatForUser(cr, name, cr.getUserId());
}",1,"/**
 * Convenience function for retrieving a single system settings value
 * as a float.  Note that internally setting values are always
 * stored as strings; this function converts the string to a float
 * for you.
 * <p>
 * This version does not take a default value.  If the setting has not
 * been set, or the string value is not a number,
 * it throws {@link SettingNotFoundException}.
 *
 * @param cr The ContentResolver to access.
 * @param name The name of the setting to retrieve.
 *
 * @throws SettingNotFoundException Thrown if a setting by the given
 * name can't be found or the setting value is not a float.
 *
 * @return The setting's current value.
 */
","/**
 * Convenience function for retrieving a single system settings value
 * as a float.  Note that internally setting values are always
 * stored as strings; this function converts the string to a float
 * for you.
 * <p>
 * This version does not take a default value.  If the setting has not
 * been set, or the string value is not a number,
 * it throws {@link SettingNotFoundException}.
 *
 * @param cr The ContentResolver to access.
 * @param name The name of the setting to retrieve.
 *
 * @throws SettingNotFoundException Thrown if a setting by the given
 * name can't be found or the setting value is not a float.
 *
 * @return The setting's current value.
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The dependent API called within the return statement changed from UserHandle.myUserId() to cr.getUserId(), but it still returns a float value, so the code change type is 5.","Despite the change in how the user ID is retrieved, it does not inherently lead to a different behavior in terms of return value or exception handling since both methods are expected to return the current user's ID for the context in which this code operates. Therefore, there is no Compatibility Issue identified, so the CI type is 0."
382,"<android.content.ContentResolver: void addPeriodicSync(Account,String,Bundle,long)>",27,28,"<android.content.ContentResolver: void addPeriodicSync(Account,String,Bundle,long)>","<android.content.ContentResolver: void addPeriodicSync(Account,String,Bundle,long)>",0,"{
    validateSyncExtrasBundle(extras);
    if (extras.getBoolean(SYNC_EXTRAS_MANUAL, false) || extras.getBoolean(SYNC_EXTRAS_DO_NOT_RETRY, false) || extras.getBoolean(SYNC_EXTRAS_IGNORE_BACKOFF, false) || extras.getBoolean(SYNC_EXTRAS_IGNORE_SETTINGS, false) || extras.getBoolean(SYNC_EXTRAS_INITIALIZE, false) || extras.getBoolean(SYNC_EXTRAS_FORCE, false) || extras.getBoolean(SYNC_EXTRAS_EXPEDITED, false)) {
        throw new IllegalArgumentException(""illegal extras were set"");
    }
    try {
        getContentService().addPeriodicSync(account, authority, extras, pollFrequency);
    } catch (RemoteException e) {
    // exception ignored; if this is thrown then it means the runtime is in the midst of
    // being restarted
    }
}","{
    validateSyncExtrasBundle(extras);
    if (invalidPeriodicExtras(extras)) {
        throw new IllegalArgumentException(""illegal extras were set"");
    }
    try {
        getContentService().addPeriodicSync(account, authority, extras, pollFrequency);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Specifies that a sync should be requested with the specified the account, authority,
 * and extras at the given frequency. If there is already another periodic sync scheduled
 * with the account, authority and extras then a new periodic sync won't be added, instead
 * the frequency of the previous one will be updated.
 * <p>
 * These periodic syncs honor the ""syncAutomatically"" and ""masterSyncAutomatically"" settings.
 * Although these sync are scheduled at the specified frequency, it may take longer for it to
 * actually be started if other syncs are ahead of it in the sync operation queue. This means
 * that the actual start time may drift.
 * <p>
 * Periodic syncs are not allowed to have any of {@link #SYNC_EXTRAS_DO_NOT_RETRY},
 * {@link #SYNC_EXTRAS_IGNORE_BACKOFF}, {@link #SYNC_EXTRAS_IGNORE_SETTINGS},
 * {@link #SYNC_EXTRAS_INITIALIZE}, {@link #SYNC_EXTRAS_FORCE},
 * {@link #SYNC_EXTRAS_EXPEDITED}, {@link #SYNC_EXTRAS_MANUAL} set to true.
 * If any are supplied then an {@link IllegalArgumentException} will be thrown.
 *
 * <p>This method requires the caller to hold the permission
 * {@link android.Manifest.permission#WRITE_SYNC_SETTINGS}.
 * <p>The bundle for a periodic sync can be queried by applications with the correct
 * permissions using
 * {@link ContentResolver#getPeriodicSyncs(Account account, String provider)}, so no
 * sensitive data should be transferred here.
 *
 * @param account the account to specify in the sync
 * @param authority the provider to specify in the sync request
 * @param extras extra parameters to go along with the sync request
 * @param pollFrequency how frequently the sync should be performed, in seconds. A minimum value
 * of 1 hour is enforced.
 * @throws IllegalArgumentException if an illegal extra was set or if any of the parameters
 * are null.
 */
","/**
 * Specifies that a sync should be requested with the specified the account, authority,
 * and extras at the given frequency. If there is already another periodic sync scheduled
 * with the account, authority and extras then a new periodic sync won't be added, instead
 * the frequency of the previous one will be updated.
 * <p>
 * These periodic syncs honor the ""syncAutomatically"" and ""masterSyncAutomatically"" settings.
 * Although these sync are scheduled at the specified frequency, it may take longer for it to
 * actually be started if other syncs are ahead of it in the sync operation queue. This means
 * that the actual start time may drift.
 * <p>
 * Periodic syncs are not allowed to have any of {@link #SYNC_EXTRAS_DO_NOT_RETRY},
 * {@link #SYNC_EXTRAS_IGNORE_BACKOFF}, {@link #SYNC_EXTRAS_IGNORE_SETTINGS},
 * {@link #SYNC_EXTRAS_INITIALIZE}, {@link #SYNC_EXTRAS_FORCE},
 * {@link #SYNC_EXTRAS_EXPEDITED}, {@link #SYNC_EXTRAS_MANUAL} set to true.
 * If any are supplied then an {@link IllegalArgumentException} will be thrown.
 *
 * <p>This method requires the caller to hold the permission
 * {@link android.Manifest.permission#WRITE_SYNC_SETTINGS}.
 * <p>The bundle for a periodic sync can be queried by applications with the correct
 * permissions using
 * {@link ContentResolver#getPeriodicSyncs(Account account, String provider)}, so no
 * sensitive data should be transferred here.
 *
 * @param account the account to specify in the sync
 * @param authority the provider to specify in the sync request
 * @param extras extra parameters to go along with the sync request
 * @param pollFrequency how frequently the sync should be performed, in seconds.
 * On Android API level 24 and above, a minmam interval of 15 minutes is enforced.
 * On previous versions, the minimum interval is 1 hour.
 * @throws IllegalArgumentException if an illegal extra was set or if any of the parameters
 * are null.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,3,5","1,2","The control dependency has changed due to the introduction of the invalidPeriodicExtras(extras) method instead of multiple calls to extras.getBoolean(). An exception handling statement has also changed as RemoteException is now re-thrown using rethrowFromSystemServer(). The changes involve both control dependency and exception handling, and the dependent API invalidPeriodicExtras is a new addition which affects the implementation, so the code change types are 2,3,5.","Since the control dependency is changed, the conditions under which an IllegalArgumentException is thrown might have changed due to the new method implementation, leading to a CI type 1 for potentially different return values due to different conditions checked before the exception is thrown. The change in the exception handling may cause previously ignored RemoteExceptions to now cause a system server rethrow, which is a CI type 2 because of a change in the exception thrown."
383,<android.view.View: boolean performClick()>,27,28,<android.view.View: boolean performClick()>,<android.view.View: boolean performClick()>,0,"{
    final boolean result;
    final ListenerInfo li = mListenerInfo;
    if (li != null && li.mOnClickListener != null) {
        playSoundEffect(SoundEffectConstants.CLICK);
        li.mOnClickListener.onClick(this);
        result = true;
    } else {
        result = false;
    }
    sendAccessibilityEvent(AccessibilityEvent.TYPE_VIEW_CLICKED);
    notifyEnterOrExitForAutoFillIfNeeded(true);
    return result;
}","{
    // We still need to call this method to handle the cases where performClick() was called
    // externally, instead of through performClickInternal()
    notifyAutofillManagerOnClick();
    final boolean result;
    final ListenerInfo li = mListenerInfo;
    if (li != null && li.mOnClickListener != null) {
        playSoundEffect(SoundEffectConstants.CLICK);
        li.mOnClickListener.onClick(this);
        result = true;
    } else {
        result = false;
    }
    sendAccessibilityEvent(AccessibilityEvent.TYPE_VIEW_CLICKED);
    notifyEnterOrExitForAutoFillIfNeeded(true);
    return result;
}",1,"/**
 * Call this view's OnClickListener, if it is defined.  Performs all normal
 * actions associated with clicking: reporting accessibility event, playing
 * a sound, etc.
 *
 * @return True there was an assigned OnClickListener that was called, false
 * otherwise is returned.
 */
","// could extend this method without calling super.performClick()).
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"An additional method call notifyAutofillManagerOnClick() is added at the beginning of the method, which is an 'other statement changed', so the change type is 4.","The addition of notifyAutofillManagerOnClick() does not affect the return value or the exception handling of the method. The result variable is still set based on the same conditions, and no new return statements or exception-handling code is introduced. Hence, there is no Compatibility Issue."
384,<android.hardware.radio.RadioManager.ModuleProperties: boolean equals(Object)>,27,28,<android.hardware.radio.RadioManager.ModuleProperties: boolean equals(Object)>,<android.hardware.radio.RadioManager.ModuleProperties: boolean equals(Object)>,0,"{
    if (this == obj)
        return true;
    if (!(obj instanceof ModuleProperties))
        return false;
    ModuleProperties other = (ModuleProperties) obj;
    if (mId != other.getId())
        return false;
    if (!TextUtils.equals(mServiceName, other.mServiceName))
        return false;
    if (mClassId != other.getClassId())
        return false;
    if (mImplementor == null) {
        if (other.getImplementor() != null)
            return false;
    } else if (!mImplementor.equals(other.getImplementor()))
        return false;
    if (mProduct == null) {
        if (other.getProduct() != null)
            return false;
    } else if (!mProduct.equals(other.getProduct()))
        return false;
    if (mVersion == null) {
        if (other.getVersion() != null)
            return false;
    } else if (!mVersion.equals(other.getVersion()))
        return false;
    if (mSerial == null) {
        if (other.getSerial() != null)
            return false;
    } else if (!mSerial.equals(other.getSerial()))
        return false;
    if (mNumTuners != other.getNumTuners())
        return false;
    if (mNumAudioSources != other.getNumAudioSources())
        return false;
    if (mIsCaptureSupported != other.isCaptureSupported())
        return false;
    if (!Arrays.equals(mBands, other.getBands()))
        return false;
    if (mIsBgScanSupported != other.isBackgroundScanningSupported())
        return false;
    if (!mVendorInfo.equals(other.mVendorInfo))
        return false;
    return true;
}","{
    if (this == obj)
        return true;
    if (!(obj instanceof ModuleProperties))
        return false;
    ModuleProperties other = (ModuleProperties) obj;
    if (mId != other.getId())
        return false;
    if (!TextUtils.equals(mServiceName, other.mServiceName))
        return false;
    if (mClassId != other.mClassId)
        return false;
    if (!Objects.equals(mImplementor, other.mImplementor))
        return false;
    if (!Objects.equals(mProduct, other.mProduct))
        return false;
    if (!Objects.equals(mVersion, other.mVersion))
        return false;
    if (!Objects.equals(mSerial, other.mSerial))
        return false;
    if (mNumTuners != other.mNumTuners)
        return false;
    if (mNumAudioSources != other.mNumAudioSources)
        return false;
    if (mIsInitializationRequired != other.mIsInitializationRequired)
        return false;
    if (mIsCaptureSupported != other.mIsCaptureSupported)
        return false;
    if (!Objects.equals(mBands, other.mBands))
        return false;
    if (mIsBgScanSupported != other.mIsBgScanSupported)
        return false;
    if (!Objects.equals(mDabFrequencyTable, other.mDabFrequencyTable))
        return false;
    if (!Objects.equals(mVendorInfo, other.mVendorInfo))
        return false;
    return true;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,4",1,"The changes include that some 'if' conditions were replaced by using Objects.equals for null-safe equality checks, one conditional statement checking the equality of the mIsInitializationRequired field has been added, and another pair of conditional statements checking for equality on mDabFrequencyTable has been added. These changes relate to control dependency (type 3) as the conditions checked within the 'if' statements have been altered, and other statement changed (type 4) because there have been additions and substitutions in the logic checking object equality.","Because of the addition of new 'if' conditions and the replacement of equality checks, the behavior of the equals method could potentially alter, returning a different result from comparisons. The new checks for mIsInitializationRequired and mDabFrequencyTable mean objects that previously might have been considered equal might now not be, and vice versa, leading to a CI of type 1."
385,<android.hardware.camera2.impl.CallbackProxies.SessionStateCallbackProxy: void onClosed(CameraCaptureSession)>,27,28,<android.hardware.camera2.impl.CallbackProxies.SessionStateCallbackProxy: void onClosed(CameraCaptureSession)>,<android.hardware.camera2.impl.CallbackProxies.SessionStateCallbackProxy: void onClosed(CameraCaptureSession)>,0,"{
    mProxy.invoke(""onClosed"", session);
}","{
    final long ident = Binder.clearCallingIdentity();
    try {
        mExecutor.execute(() -> mCallback.onClosed(session));
    } finally {
        Binder.restoreCallingIdentity(ident);
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,The method's implementation has been completely rewritten from directly invoking a method on a proxy object to executing a lambda expression on an `Executor`. This is classified as 'Other statement changed' which is type 4.,"There is no Compatibility Issue since the external behavior of the API (method signature, returned values, thrown exceptions) remains the same, and the effect of the code change does not affect the API's contract with its callers."
386,"<android.view.textclassifier.TextClassification.Builder: Builder setEntityType(String,float)>",27,28,"<android.view.textclassifier.TextClassification.Builder: Builder setEntityType(String,float)>","<android.view.textclassifier.TextClassification.Builder: Builder setEntityType(String,float)>",0,"{
    mEntityConfidence.setEntityType(type, confidenceScore);
    return this;
}","{
    mEntityConfidence.put(type, confidenceScore);
    return this;
}",1,"/**
 * Sets an entity type for the classification result and assigns a confidence score.
 *
 * @param confidenceScore a value from 0 (low confidence) to 1 (high confidence).
 * 0 implies the entity does not exist for the classified text.
 * Values greater than 1 are clamped to 1.
 */
","/**
 * Sets an entity type for the classification result and assigns a confidence score.
 * If a confidence score had already been set for the specified entity type, this will
 * override that score.
 *
 * @param confidenceScore a value from 0 (low confidence) to 1 (high confidence).
 * 0 implies the entity does not exist for the classified text.
 * Values greater than 1 are clamped to 1.
 */
",-1,,[@NonNull],-1,-1,-1,-1,-1,-1,"4,5",0,"The method called on the object mEntityConfidence changed from setEntityType() to put(). It does not change the return statement or exception handling but rather a change in the method called, so the code change is 4,5.","This does not constitute a compatibility issue since it's an internal implementation detail assuming that mEntityConfidence.put() is functionally equivalent to setEntityType() and that it doesn't change the behavior with respect to the values returned or the exceptions thrown by the public API method. The method's contract and return type remain the same, and there are no indications that the behavior as experienced by the API consumer would differ between versions."
387,<android.os.WorkSource: boolean equals(Object)>,27,28,<android.os.WorkSource: boolean equals(Object)>,<android.os.WorkSource: boolean equals(Object)>,0,"{
    return o instanceof WorkSource && !diff((WorkSource) o);
}","{
    if (o instanceof WorkSource) {
        WorkSource other = (WorkSource) o;
        if (diff(other)) {
            return false;
        }
        if (mChains != null && !mChains.isEmpty()) {
            return mChains.equals(other.mChains);
        } else {
            return other.mChains == null || other.mChains.isEmpty();
        }
    }
    return false;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,3,4",1,"The late implementation introduces more conditional checks concerning 'mChains' and uses additional logic to determine equality. The method also returns false directly if 'o' is not an instance of WorkSource, instead of performing a 'diff' check and negating it. The control flow has changed significantly, and other statements are added to compare the 'mChains' variable. Thus, the code change type is 1 for the new return statements, 3 for the changed control flow, and 4 for the added equality check related to 'mChains'.","The additional condition checks and the different return strategy may lead the API to return different boolean results than the early version, thus causing a CI type 1."
388,<android.hardware.usb.UsbRequest: boolean queue(ByteBuffer)>,27,28,<android.hardware.usb.UsbRequest: boolean queue(ByteBuffer)>,<android.hardware.usb.UsbRequest: boolean queue(ByteBuffer)>,0,"{
    // Request need to be initialized
    Preconditions.checkState(mNativeContext != 0, ""request is not initialized"");
    // Request can not be currently queued
    Preconditions.checkState(!mIsUsingNewQueue, ""this request is currently queued"");
    boolean isSend = (mEndpoint.getDirection() == UsbConstants.USB_DIR_OUT);
    boolean wasQueued;
    synchronized (mLock) {
        mBuffer = buffer;
        if (buffer == null) {
            // Null buffers enqueue empty USB requests which is supported
            mIsUsingNewQueue = true;
            wasQueued = native_queue(null, 0, 0);
        } else {
            // Can only send/receive MAX_USBFS_BUFFER_SIZE bytes at once
            Preconditions.checkArgumentInRange(buffer.remaining(), 0, MAX_USBFS_BUFFER_SIZE, ""number of remaining bytes"");
            // Can not receive into read-only buffers.
            Preconditions.checkArgument(!(buffer.isReadOnly() && !isSend), ""buffer can not be "" + ""read-only when receiving data"");
            if (!buffer.isDirect()) {
                mTempBuffer = ByteBuffer.allocateDirect(mBuffer.remaining());
                if (isSend) {
                    // Copy buffer into temporary buffer
                    mBuffer.mark();
                    mTempBuffer.put(mBuffer);
                    mTempBuffer.flip();
                    mBuffer.reset();
                }
                // Send/Receive into the temp buffer instead
                buffer = mTempBuffer;
            }
            mIsUsingNewQueue = true;
            wasQueued = native_queue(buffer, buffer.position(), buffer.remaining());
        }
    }
    if (!wasQueued) {
        mIsUsingNewQueue = false;
        mTempBuffer = null;
        mBuffer = null;
    }
    return wasQueued;
}","{
    // Request need to be initialized
    Preconditions.checkState(mNativeContext != 0, ""request is not initialized"");
    // Request can not be currently queued
    Preconditions.checkState(!mIsUsingNewQueue, ""this request is currently queued"");
    boolean isSend = (mEndpoint.getDirection() == UsbConstants.USB_DIR_OUT);
    boolean wasQueued;
    synchronized (mLock) {
        mBuffer = buffer;
        if (buffer == null) {
            // Null buffers enqueue empty USB requests which is supported
            mIsUsingNewQueue = true;
            wasQueued = native_queue(null, 0, 0);
        } else {
            if (mConnection.getContext().getApplicationInfo().targetSdkVersion < Build.VERSION_CODES.P) {
                // Can only send/receive MAX_USBFS_BUFFER_SIZE bytes at once
                Preconditions.checkArgumentInRange(buffer.remaining(), 0, MAX_USBFS_BUFFER_SIZE, ""number of remaining bytes"");
            }
            // Can not receive into read-only buffers.
            Preconditions.checkArgument(!(buffer.isReadOnly() && !isSend), ""buffer can not be "" + ""read-only when receiving data"");
            if (!buffer.isDirect()) {
                mTempBuffer = ByteBuffer.allocateDirect(mBuffer.remaining());
                if (isSend) {
                    // Copy buffer into temporary buffer
                    mBuffer.mark();
                    mTempBuffer.put(mBuffer);
                    mTempBuffer.flip();
                    mBuffer.reset();
                }
                // Send/Receive into the temp buffer instead
                buffer = mTempBuffer;
            }
            mIsUsingNewQueue = true;
            wasQueued = native_queue(buffer, buffer.position(), buffer.remaining());
        }
    }
    if (!wasQueued) {
        mIsUsingNewQueue = false;
        mTempBuffer = null;
        mBuffer = null;
    }
    return wasQueued;
}",1,"/**
 * Queues the request to send or receive data on its endpoint.
 *
 * <p>For OUT endpoints, the remaining bytes of the buffer will be sent on the endpoint. For IN
 * endpoints, the endpoint will attempt to fill the remaining bytes of the buffer. If the
 * queueing operation is successful, return true. The result will be returned via
 * {@link UsbDeviceConnection#requestWait}</p>
 *
 * @param buffer the buffer containing the bytes to send, or the buffer to fill. The state
 * of the buffer is undefined until the request is returned by
 * {@link UsbDeviceConnection#requestWait}. If the request failed the buffer
 * will be unchanged; if the request succeeded the position of the buffer is
 * incremented by the number of bytes sent/received.
 *
 * @return true if the queueing operation succeeded
 */
","/**
 * Queues the request to send or receive data on its endpoint.
 *
 * <p>For OUT endpoints, the remaining bytes of the buffer will be sent on the endpoint. For IN
 * endpoints, the endpoint will attempt to fill the remaining bytes of the buffer. If the
 * queueing operation is successful, return true. The result will be returned via
 * {@link UsbDeviceConnection#requestWait}</p>
 *
 * @param buffer the buffer containing the bytes to send, or the buffer to fill. The state
 * of the buffer is undefined until the request is returned by
 * {@link UsbDeviceConnection#requestWait}. If the request failed the buffer
 * will be unchanged; if the request succeeded the position of the buffer is
 * incremented by the number of bytes sent/received. Before
 * {@value Build.VERSION_CODES#P}, a buffer of length larger than 16384 bytes
 * would throw IllegalArgumentException. In API {@value Build.VERSION_CODES#P}
 * and after, any size buffer is valid.
 *
 * @return true if the queueing operation succeeded
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,5",0,"The method implementation changed by adding a conditional check for the `targetSdkVersion` before doing the `checkArgumentInRange`. The check `if (mConnection.getContext().getApplicationInfo().targetSdkVersion < Build.VERSION_CODES.P)` introduces a control dependency change based on the SDK version check, and a dependent API has been changed because it adds a condition that depends on the `targetSdkVersion` of the application. Thus, the change type is 3,5.","There is no Compatibility Issue since the functional behavior of `queue()` remains the same for apps targeting SDK versions higher than or equal to `P`. For apps targeting lower versions, the original check remains. This conditional change does not alter the output or exception behavior for existing apps but could potentially reduce restrictions for apps compiling against newer SDK versions, thus no CI is introduced."
389,<android.widget.Editor.InsertionHandleView: boolean onTouchEvent(MotionEvent)>,27,28,<android.widget.Editor.InsertionHandleView: boolean onTouchEvent(MotionEvent)>,<android.widget.Editor.InsertionHandleView: boolean onTouchEvent(MotionEvent)>,0,"{
    final boolean result = super.onTouchEvent(ev);
    switch(ev.getActionMasked()) {
        case MotionEvent.ACTION_DOWN:
            mDownPositionX = ev.getRawX();
            mDownPositionY = ev.getRawY();
            break;
        case MotionEvent.ACTION_UP:
            if (!offsetHasBeenChanged()) {
                final float deltaX = mDownPositionX - ev.getRawX();
                final float deltaY = mDownPositionY - ev.getRawY();
                final float distanceSquared = deltaX * deltaX + deltaY * deltaY;
                final ViewConfiguration viewConfiguration = ViewConfiguration.get(mTextView.getContext());
                final int touchSlop = viewConfiguration.getScaledTouchSlop();
                if (distanceSquared < touchSlop * touchSlop) {
                    // Tapping on the handle toggles the insertion action mode.
                    if (mTextActionMode != null) {
                        stopTextActionMode();
                    } else {
                        startInsertionActionMode();
                    }
                }
            } else {
                if (mTextActionMode != null) {
                    mTextActionMode.invalidateContentRect();
                }
            }
            hideAfterDelay();
            break;
        case MotionEvent.ACTION_CANCEL:
            hideAfterDelay();
            break;
        default:
            break;
    }
    return result;
}","{
    final boolean result = super.onTouchEvent(ev);
    switch(ev.getActionMasked()) {
        case MotionEvent.ACTION_DOWN:
            mDownPositionX = ev.getRawX();
            mDownPositionY = ev.getRawY();
            updateMagnifier(ev);
            break;
        case MotionEvent.ACTION_MOVE:
            updateMagnifier(ev);
            break;
        case MotionEvent.ACTION_UP:
            if (!offsetHasBeenChanged()) {
                final float deltaX = mDownPositionX - ev.getRawX();
                final float deltaY = mDownPositionY - ev.getRawY();
                final float distanceSquared = deltaX * deltaX + deltaY * deltaY;
                final ViewConfiguration viewConfiguration = ViewConfiguration.get(mTextView.getContext());
                final int touchSlop = viewConfiguration.getScaledTouchSlop();
                if (distanceSquared < touchSlop * touchSlop) {
                    // Tapping on the handle toggles the insertion action mode.
                    if (mTextActionMode != null) {
                        stopTextActionMode();
                    } else {
                        startInsertionActionMode();
                    }
                }
            } else {
                if (mTextActionMode != null) {
                    mTextActionMode.invalidateContentRect();
                }
            }
        // Fall through.
        case MotionEvent.ACTION_CANCEL:
            hideAfterDelay();
            dismissMagnifier();
            break;
        default:
            break;
    }
    return result;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,4",0,The control dependency has changed due to the introduction of an ACTION_MOVE case and a new statement within the existing ACTION_DOWN case. There are also new method calls: updateMagnifier(ev) and dismissMagnifier(). These changes qualify as 3 (Control dependency changed) and 4 (Other statement changed).,"The new method calls (updateMagnifier(ev) and dismissMagnifier()) do not affect the return value of the onTouchEvent method nor do they introduce any new control paths that would cause an additional or different exception to be thrown. Therefore, there is no compatibility issue as the method's observed behavior from the outside (in terms of output values or thrown exceptions) would remain unchanged, so the CI type is 0."
390,<android.os.storage.StorageManager: UUID getUuidForPath(File)>,27,28,<android.os.storage.StorageManager: UUID getUuidForPath(File)>,<android.os.storage.StorageManager: UUID getUuidForPath(File)>,0,"{
    Preconditions.checkNotNull(path);
    final String pathString = path.getCanonicalPath();
    if (FileUtils.contains(Environment.getDataDirectory().getAbsolutePath(), pathString)) {
        return UUID_DEFAULT;
    }
    try {
        for (VolumeInfo vol : mStorageManager.getVolumes(0)) {
            if (vol.path != null && FileUtils.contains(vol.path, pathString)) {
                // underlying volume
                return convert(vol.fsUuid);
            }
        }
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
    throw new FileNotFoundException(""Failed to find a storage device for "" + path);
}","{
    Preconditions.checkNotNull(path);
    final String pathString = path.getCanonicalPath();
    if (FileUtils.contains(Environment.getDataDirectory().getAbsolutePath(), pathString)) {
        return UUID_DEFAULT;
    }
    try {
        for (VolumeInfo vol : mStorageManager.getVolumes(0)) {
            if (vol.path != null && FileUtils.contains(vol.path, pathString) && vol.type != VolumeInfo.TYPE_PUBLIC) {
                // underlying volume
                try {
                    return convert(vol.fsUuid);
                } catch (IllegalArgumentException e) {
                    continue;
                }
            }
        }
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
    throw new FileNotFoundException(""Failed to find a storage device for "" + path);
}",1,"/**
 * Return a UUID identifying the storage volume that hosts the given
 * filesystem path.
 * <p>
 * If this path is hosted by the default internal storage of the device at
 * {@link Environment#getDataDirectory()}, the returned value will be
 * {@link #UUID_DEFAULT}.
 *
 * @throws IOException when the storage device hosting the given path isn't
 * present, or when it doesn't have a valid UUID.
 */
","/**
 * Return a UUID identifying the storage volume that hosts the given
 * filesystem path.
 * <p>
 * If this path is hosted by the default internal storage of the device at
 * {@link Environment#getDataDirectory()}, the returned value will be
 * {@link #UUID_DEFAULT}.
 *
 * @throws IOException when the storage device hosting the given path isn't
 * present, or when it doesn't have a valid UUID.
 */
",-1,[@NonNull],[@NonNull],-1,-1,-1,-1,-1,-1,"1,3",1,"The control condition within the 'for' loop has been expanded to include ""vol.type != VolumeInfo.TYPE_PUBLIC"", and a try-catch block has been added for the return statement within this loop. This change affects the control dependency (type 3), and because the specific return statement is now conditioned by an additional check and wrapped inside a nested try-catch, it represents a change in the return statement as well (type 1).","The new condition ""vol.type != VolumeInfo.TYPE_PUBLIC"" could lead to different return values, because it filters out certain volumes from being considered valid for returning their UUID, whereas previously they would have been considered. The introduction of the nested try-catch for IllegalArgumentException around the ""return convert(vol.fsUuid);"" statement could lead to the loop continuing (and potentially returning a different UUID or throwing a FileNotFoundException if no valid volume is found), rather than throwing IllegalArgumentException directly as it would in the early version. This represents a Compatibility Issue of type 1 due to the potential for different return values."
391,<android.service.autofill.SaveCallback: void onSuccess()>,27,28,<android.service.autofill.SaveCallback: void onSuccess()>,<android.service.autofill.SaveCallback: void onSuccess()>,0,"{
    assertNotCalled();
    mCalled = true;
    try {
        mCallback.onSuccess();
    } catch (RemoteException e) {
        e.rethrowAsRuntimeException();
    }
}","{
    onSuccessInternal(null);
}",1,"/**
 * Notifies the Android System that an
 * {@link AutofillService#onSaveRequest(SaveRequest, SaveCallback)} was successfully handled
 * by the service.
 *
 * <p>If the service could not handle the request right away&mdash;for example, because it must
 * launch an activity asking the user to authenticate first or because the network is
 * down&mdash;it should still call {@link #onSuccess()}.
 *
 * @throws RuntimeException if an error occurred while calling the Android System.
 */
","/**
 * Notifies the Android System that an
 * {@link AutofillService#onSaveRequest(SaveRequest, SaveCallback)} was successfully handled
 * by the service.
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The early version implementation had the functionality directly in it, while the late version delegates the functionality to another method onSuccessInternal(null). This indicates a change of dependency on another internal method, resulting in a change type 5.","There is no direct Compatibility Issue since the outward behavior and signature of the method have not changed. The method still attempts to perform the same action, which is to callback onSuccess, just through an internal method now. The change shouldn't affect how the method works from the perspective of the caller as long as onSuccessInternal(null) maintains the same contract, so the CI type is 0."
392,<android.app.NotificationChannelGroup: int hashCode()>,27,28,<android.app.NotificationChannelGroup: int hashCode()>,<android.app.NotificationChannelGroup: int hashCode()>,0,"{
    int result = getId() != null ? getId().hashCode() : 0;
    result = 31 * result + (getName() != null ? getName().hashCode() : 0);
    return result;
}","{
    int result = getId() != null ? getId().hashCode() : 0;
    result = 31 * result + (getName() != null ? getName().hashCode() : 0);
    result = 31 * result + (getDescription() != null ? getDescription().hashCode() : 0);
    result = 31 * result + (isBlocked() ? 1 : 0);
    result = 31 * result + (getChannels() != null ? getChannels().hashCode() : 0);
    return result;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,4",1,"New statements have been added to the method implementation that impact the calculation of the hashCode, and these include hash code computations for additional fields (getDescription, isBlocked, getChannels), so the change type is 1,4.","These changes in how the hashCode is computed will cause the API to potentially return different values, hence the CI type is 1."
393,"<android.app.Activity: void requestPermissions(String[],int)>",27,28,"<android.app.Activity: void requestPermissions(String[],int)>","<android.app.Activity: void requestPermissions(String[],int)>",0,"{
    if (requestCode < 0) {
        throw new IllegalArgumentException(""requestCode should be >= 0"");
    }
    if (mHasCurrentPermissionsRequest) {
        Log.w(TAG, ""Can reqeust only one set of permissions at a time"");
        // Dispatch the callback with empty arrays which means a cancellation.
        onRequestPermissionsResult(requestCode, new String[0], new int[0]);
        return;
    }
    Intent intent = getPackageManager().buildRequestPermissionsIntent(permissions);
    startActivityForResult(REQUEST_PERMISSIONS_WHO_PREFIX, intent, requestCode, null);
    mHasCurrentPermissionsRequest = true;
}","{
    if (requestCode < 0) {
        throw new IllegalArgumentException(""requestCode should be >= 0"");
    }
    if (mHasCurrentPermissionsRequest) {
        Log.w(TAG, ""Can request only one set of permissions at a time"");
        // Dispatch the callback with empty arrays which means a cancellation.
        onRequestPermissionsResult(requestCode, new String[0], new int[0]);
        return;
    }
    Intent intent = getPackageManager().buildRequestPermissionsIntent(permissions);
    startActivityForResult(REQUEST_PERMISSIONS_WHO_PREFIX, intent, requestCode, null);
    mHasCurrentPermissionsRequest = true;
}",1,"/**
 * Requests permissions to be granted to this application. These permissions
 * must be requested in your manifest, they should not be granted to your app,
 * and they should have protection level {@link android.content.pm.PermissionInfo
 * #PROTECTION_DANGEROUS dangerous}, regardless whether they are declared by
 * the platform or a third-party app.
 * <p>
 * Normal permissions {@link android.content.pm.PermissionInfo#PROTECTION_NORMAL}
 * are granted at install time if requested in the manifest. Signature permissions
 * {@link android.content.pm.PermissionInfo#PROTECTION_SIGNATURE} are granted at
 * install time if requested in the manifest and the signature of your app matches
 * the signature of the app declaring the permissions.
 * </p>
 * <p>
 * If your app does not have the requested permissions the user will be presented
 * with UI for accepting them. After the user has accepted or rejected the
 * requested permissions you will receive a callback on {@link
 * #onRequestPermissionsResult(int, String[], int[])} reporting whether the
 * permissions were granted or not.
 * </p>
 * <p>
 * Note that requesting a permission does not guarantee it will be granted and
 * your app should be able to run without having this permission.
 * </p>
 * <p>
 * This method may start an activity allowing the user to choose which permissions
 * to grant and which to reject. Hence, you should be prepared that your activity
 * may be paused and resumed. Further, granting some permissions may require
 * a restart of you application. In such a case, the system will recreate the
 * activity stack before delivering the result to {@link
 * #onRequestPermissionsResult(int, String[], int[])}.
 * </p>
 * <p>
 * When checking whether you have a permission you should use {@link
 * #checkSelfPermission(String)}.
 * </p>
 * <p>
 * Calling this API for permissions already granted to your app would show UI
 * to the user to decide whether the app can still hold these permissions. This
 * can be useful if the way your app uses data guarded by the permissions
 * changes significantly.
 * </p>
 * <p>
 * You cannot request a permission if your activity sets {@link
 * android.R.styleable#AndroidManifestActivity_noHistory noHistory} to
 * <code>true</code> because in this case the activity would not receive
 * result callbacks including {@link #onRequestPermissionsResult(int, String[], int[])}.
 * </p>
 * <p>
 * The <a href=""http://developer.android.com/samples/RuntimePermissions/index.html"">
 * RuntimePermissions</a> sample app demonstrates how to use this method to
 * request permissions at run time.
 * </p>
 *
 * @param permissions The requested permissions. Must me non-null and not empty.
 * @param requestCode Application specific request code to match with a result
 * reported to {@link #onRequestPermissionsResult(int, String[], int[])}.
 * Should be >= 0.
 *
 * @throws IllegalArgumentException if requestCode is negative.
 *
 * @see #onRequestPermissionsResult(int, String[], int[])
 * @see #checkSelfPermission(String)
 * @see #shouldShowRequestPermissionRationale(String)
 */
","/**
 * Requests permissions to be granted to this application. These permissions
 * must be requested in your manifest, they should not be granted to your app,
 * and they should have protection level {@link android.content.pm.PermissionInfo
 * #PROTECTION_DANGEROUS dangerous}, regardless whether they are declared by
 * the platform or a third-party app.
 * <p>
 * Normal permissions {@link android.content.pm.PermissionInfo#PROTECTION_NORMAL}
 * are granted at install time if requested in the manifest. Signature permissions
 * {@link android.content.pm.PermissionInfo#PROTECTION_SIGNATURE} are granted at
 * install time if requested in the manifest and the signature of your app matches
 * the signature of the app declaring the permissions.
 * </p>
 * <p>
 * If your app does not have the requested permissions the user will be presented
 * with UI for accepting them. After the user has accepted or rejected the
 * requested permissions you will receive a callback on {@link
 * #onRequestPermissionsResult(int, String[], int[])} reporting whether the
 * permissions were granted or not.
 * </p>
 * <p>
 * Note that requesting a permission does not guarantee it will be granted and
 * your app should be able to run without having this permission.
 * </p>
 * <p>
 * This method may start an activity allowing the user to choose which permissions
 * to grant and which to reject. Hence, you should be prepared that your activity
 * may be paused and resumed. Further, granting some permissions may require
 * a restart of you application. In such a case, the system will recreate the
 * activity stack before delivering the result to {@link
 * #onRequestPermissionsResult(int, String[], int[])}.
 * </p>
 * <p>
 * When checking whether you have a permission you should use {@link
 * #checkSelfPermission(String)}.
 * </p>
 * <p>
 * Calling this API for permissions already granted to your app would show UI
 * to the user to decide whether the app can still hold these permissions. This
 * can be useful if the way your app uses data guarded by the permissions
 * changes significantly.
 * </p>
 * <p>
 * You cannot request a permission if your activity sets {@link
 * android.R.styleable#AndroidManifestActivity_noHistory noHistory} to
 * <code>true</code> because in this case the activity would not receive
 * result callbacks including {@link #onRequestPermissionsResult(int, String[], int[])}.
 * </p>
 * <p>
 * The <a href=""http://developer.android.com/samples/RuntimePermissions/index.html"">
 * RuntimePermissions</a> sample app demonstrates how to use this method to
 * request permissions at run time.
 * </p>
 *
 * @param permissions The requested permissions. Must me non-null and not empty.
 * @param requestCode Application specific request code to match with a result
 * reported to {@link #onRequestPermissionsResult(int, String[], int[])}.
 * Should be >= 0.
 *
 * @throws IllegalArgumentException if requestCode is negative.
 *
 * @see #onRequestPermissionsResult(int, String[], int[])
 * @see #checkSelfPermission(String)
 * @see #shouldShowRequestPermissionRationale(String)
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The change from ""Can reqeust"" to ""Can request"" in the Log.w call is just a spelling correction in the log message, which is a non-functional change. It does not affect the execution flow or the logic of the method. Hence, the code change type is 4.","This spelling correction in a log message will not result in any difference in behaviour, return values, or thrown exceptions. Therefore, there is no compatibility issue, so the CI type is 0."
394,"<android.app.job.JobInfo.Builder: Builder setPeriodic(long,long)>",27,28,"<android.app.job.JobInfo.Builder: Builder setPeriodic(long,long)>","<android.app.job.JobInfo.Builder: Builder setPeriodic(long,long)>",0,"{
    mIsPeriodic = true;
    mIntervalMillis = intervalMillis;
    mFlexMillis = flexMillis;
    mHasEarlyConstraint = mHasLateConstraint = true;
    return this;
}","{
    final long minPeriod = getMinPeriodMillis();
    if (intervalMillis < minPeriod) {
        Log.w(TAG, ""Requested interval "" + formatDuration(intervalMillis) + "" for job "" + mJobId + "" is too small; raising to "" + formatDuration(minPeriod));
        intervalMillis = minPeriod;
    }
    final long percentClamp = 5 * intervalMillis / 100;
    final long minFlex = Math.max(percentClamp, getMinFlexMillis());
    if (flexMillis < minFlex) {
        Log.w(TAG, ""Requested flex "" + formatDuration(flexMillis) + "" for job "" + mJobId + "" is too small; raising to "" + formatDuration(minFlex));
        flexMillis = minFlex;
    }
    mIsPeriodic = true;
    mIntervalMillis = intervalMillis;
    mFlexMillis = flexMillis;
    mHasEarlyConstraint = mHasLateConstraint = true;
    return this;
}",1,"/**
 * Specify that this job should recur with the provided interval and flex. The job can
 * execute at any time in a window of flex length at the end of the period.
 * @param intervalMillis Millisecond interval for which this job will repeat. A minimum
 * value of {@link #getMinPeriodMillis()} is enforced.
 * @param flexMillis Millisecond flex for this job. Flex is clamped to be at least
 * {@link #getMinFlexMillis()} or 5 percent of the period, whichever is
 * higher.
 */
","/**
 * Specify that this job should recur with the provided interval and flex. The job can
 * execute at any time in a window of flex length at the end of the period.
 * @param intervalMillis Millisecond interval for which this job will repeat. A minimum
 * value of {@link #getMinPeriodMillis()} is enforced.
 * @param flexMillis Millisecond flex for this job. Flex is clamped to be at least
 * {@link #getMinFlexMillis()} or 5 percent of the period, whichever is
 * higher.
 * @see JobInfo#getIntervalMillis()
 * @see JobInfo#getFlexMillis()
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",0,The late version introduces a new control flow (checking if the input parameters are below a certain threshold and logging a warning) and stores the potentially adjusted values in `mIntervalMillis` and `mFlexMillis`. The code change types are 3 for the added conditional checks and 4 for the added logging.,"Despite the control dependency change and additional statements, there's no Compatibility Issue as the alterations don't lead to different behavior that would affect the API's public contract. The API encapsulates this logic and ensures the internal state of `JobInfo.Builder` remains within expected boundaries, which means the return type `Builder` and its behavior remain consistent from the client's perspective. The adjustments made to the input parameters `intervalMillis` and `flexMillis` are internal optimizations to maintain adherence to system constraints."
395,<android.bluetooth.BluetoothAdapter: boolean isDiscovering()>,27,28,<android.bluetooth.BluetoothAdapter: boolean isDiscovering()>,<android.bluetooth.BluetoothAdapter: boolean isDiscovering()>,0,"{
    if (getState() != STATE_ON)
        return false;
    try {
        mServiceLock.readLock().lock();
        if (mService != null)
            return mService.isDiscovering();
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
    } finally {
        mServiceLock.readLock().unlock();
    }
    return false;
}","{
    if (getState() != STATE_ON) {
        return false;
    }
    try {
        mServiceLock.readLock().lock();
        if (mService != null) {
            return mService.isDiscovering();
        }
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
    } finally {
        mServiceLock.readLock().unlock();
    }
    return false;
}",1,"/**
 * Return true if the local Bluetooth adapter is currently in the device
 * discovery process.
 * <p>Device discovery is a heavyweight procedure. New connections to
 * remote Bluetooth devices should not be attempted while discovery is in
 * progress, and existing connections will experience limited bandwidth
 * and high latency. Use {@link #cancelDiscovery()} to cancel an ongoing
 * discovery.
 * <p>Applications can also register for {@link #ACTION_DISCOVERY_STARTED}
 * or {@link #ACTION_DISCOVERY_FINISHED} to be notified when discovery
 * starts or completes.
 * <p>If Bluetooth state is not {@link #STATE_ON}, this API
 * will return false. After turning on Bluetooth,
 * wait for {@link #ACTION_STATE_CHANGED} with {@link #STATE_ON}
 * to get the updated value.
 *
 * @return true if discovering
 */
","/**
 * Return true if the local Bluetooth adapter is currently in the device
 * discovery process.
 * <p>Device discovery is a heavyweight procedure. New connections to
 * remote Bluetooth devices should not be attempted while discovery is in
 * progress, and existing connections will experience limited bandwidth
 * and high latency. Use {@link #cancelDiscovery()} to cancel an ongoing
 * discovery.
 * <p>Applications can also register for {@link #ACTION_DISCOVERY_STARTED}
 * or {@link #ACTION_DISCOVERY_FINISHED} to be notified when discovery
 * starts or completes.
 * <p>If Bluetooth state is not {@link #STATE_ON}, this API
 * will return false. After turning on Bluetooth,
 * wait for {@link #ACTION_STATE_CHANGED} with {@link #STATE_ON}
 * to get the updated value.
 *
 * @return true if discovering
 */
",-1,[@RequiresPermission(Manifest.permission.BLUETOOTH)],[@RequiresPermission(Manifest.permission.BLUETOOTH)],-1,-1,-1,-1,-1,-1,0,0,"There's no actual code change between the two versions; only code formatting has been modified, such as adding braces around the if-statement, which does not affect the execution.","Since there are no changes in the code logic or flow, there's no compatibility issue between these versions."
396,"<android.content.res.AssetManager: InputStream open(String,int)>",27,28,"<android.content.res.AssetManager: InputStream open(String,int)>","<android.content.res.AssetManager: InputStream open(String,int)>",0,"{
    synchronized (this) {
        if (!mOpen) {
            throw new RuntimeException(""Assetmanager has been closed"");
        }
        long asset = openAsset(fileName, accessMode);
        if (asset != 0) {
            AssetInputStream res = new AssetInputStream(asset);
            incRefsLocked(res.hashCode());
            return res;
        }
    }
    throw new FileNotFoundException(""Asset file: "" + fileName);
}","{
    Preconditions.checkNotNull(fileName, ""fileName"");
    synchronized (this) {
        ensureOpenLocked();
        final long asset = nativeOpenAsset(mObject, fileName, accessMode);
        if (asset == 0) {
            throw new FileNotFoundException(""Asset file: "" + fileName);
        }
        final AssetInputStream assetInputStream = new AssetInputStream(asset);
        incRefsLocked(assetInputStream.hashCode());
        return assetInputStream;
    }
}",1,"/**
 * Open an asset using an explicit access mode, returning an InputStream to
 * read its contents.  This provides access to files that have been bundled
 * with an application as assets -- that is, files placed in to the
 * ""assets"" directory.
 *
 * @param fileName The name of the asset to open.  This name can be
 * hierarchical.
 * @param accessMode Desired access mode for retrieving the data.
 *
 * @see #ACCESS_UNKNOWN
 * @see #ACCESS_STREAMING
 * @see #ACCESS_RANDOM
 * @see #ACCESS_BUFFER
 * @see #open(String)
 * @see #list
 */
","/**
 * Open an asset using an explicit access mode, returning an InputStream to
 * read its contents.  This provides access to files that have been bundled
 * with an application as assets -- that is, files placed in to the
 * ""assets"" directory.
 *
 * @param fileName The name of the asset to open.  This name can be hierarchical.
 * @param accessMode Desired access mode for retrieving the data.
 *
 * @see #ACCESS_UNKNOWN
 * @see #ACCESS_STREAMING
 * @see #ACCESS_RANDOM
 * @see #ACCESS_BUFFER
 * @see #open(String)
 * @see #list
 */
",-1,,[@NonNull],-1,-1,-1,-1,-1,-1,"1,2,3,4,5","1,2","The early implementation throws a RuntimeException with a generic message if the AssetManager is not open, while the late implementation uses ensureOpenLocked() to check this instead. The openAsset method has been replaced with nativeOpenAsset. A null-check has been added for fileName, meaning that a NullPointerException can be thrown before reaching the synchronized block, and the FileNotFoundException message has been moved inside the synchronized block. The structure of the code and the exceptions thrown are different, accounting for changes in exception handling, return statements, control dependencies, other statements, and the dependent API (i.e., opening an asset with a native method instead of the openAsset method).","Due to these changes, the API can potentially throw different exceptions (e.g., NullPointerException instead of FileNotFoundException if fileName is null, or FileNotFoundException moved inside the synchronized block). The restructuring of the exception handling logic and the new API call for opening an asset (nativeOpenAsset instead of openAsset) could also lead to different return values. Hence, there could be a Compatibility Issue due to both different return values or types (returning a different kind of InputStream or throwing an exception where it would not have previously) and potential different exception handlings."
397,<android.os.StrictMode: void setVmPolicy(VmPolicy)>,27,28,<android.os.StrictMode: void setVmPolicy(VmPolicy)>,<android.os.StrictMode: void setVmPolicy(VmPolicy)>,0,"{
    synchronized (StrictMode.class) {
        sVmPolicy = policy;
        sVmPolicyMask = policy.mask;
        setCloseGuardEnabled(vmClosableObjectLeaksEnabled());
        Looper looper = Looper.getMainLooper();
        if (looper != null) {
            MessageQueue mq = looper.mQueue;
            if (policy.classInstanceLimit.size() == 0 || (sVmPolicyMask & VM_PENALTY_MASK) == 0) {
                mq.removeIdleHandler(sProcessIdleHandler);
                sIsIdlerRegistered = false;
            } else if (!sIsIdlerRegistered) {
                mq.addIdleHandler(sProcessIdleHandler);
                sIsIdlerRegistered = true;
            }
        }
        int networkPolicy = NETWORK_POLICY_ACCEPT;
        if ((sVmPolicyMask & DETECT_VM_CLEARTEXT_NETWORK) != 0) {
            if ((sVmPolicyMask & PENALTY_DEATH) != 0 || (sVmPolicyMask & PENALTY_DEATH_ON_CLEARTEXT_NETWORK) != 0) {
                networkPolicy = NETWORK_POLICY_REJECT;
            } else {
                networkPolicy = NETWORK_POLICY_LOG;
            }
        }
        final INetworkManagementService netd = INetworkManagementService.Stub.asInterface(ServiceManager.getService(Context.NETWORKMANAGEMENT_SERVICE));
        if (netd != null) {
            try {
                netd.setUidCleartextNetworkPolicy(android.os.Process.myUid(), networkPolicy);
            } catch (RemoteException ignored) {
            }
        } else if (networkPolicy != NETWORK_POLICY_ACCEPT) {
            Log.w(TAG, ""Dropping requested network policy due to missing service!"");
        }
    }
}","{
    synchronized (StrictMode.class) {
        sVmPolicy = policy;
        setCloseGuardEnabled(vmClosableObjectLeaksEnabled());
        Looper looper = Looper.getMainLooper();
        if (looper != null) {
            MessageQueue mq = looper.mQueue;
            if (policy.classInstanceLimit.size() == 0 || (sVmPolicy.mask & VM_PENALTY_MASK) == 0) {
                mq.removeIdleHandler(sProcessIdleHandler);
                sIsIdlerRegistered = false;
            } else if (!sIsIdlerRegistered) {
                mq.addIdleHandler(sProcessIdleHandler);
                sIsIdlerRegistered = true;
            }
        }
        int networkPolicy = NETWORK_POLICY_ACCEPT;
        if ((sVmPolicy.mask & DETECT_VM_CLEARTEXT_NETWORK) != 0) {
            if ((sVmPolicy.mask & PENALTY_DEATH) != 0 || (sVmPolicy.mask & PENALTY_DEATH_ON_CLEARTEXT_NETWORK) != 0) {
                networkPolicy = NETWORK_POLICY_REJECT;
            } else {
                networkPolicy = NETWORK_POLICY_LOG;
            }
        }
        final INetworkManagementService netd = INetworkManagementService.Stub.asInterface(ServiceManager.getService(Context.NETWORKMANAGEMENT_SERVICE));
        if (netd != null) {
            try {
                netd.setUidCleartextNetworkPolicy(android.os.Process.myUid(), networkPolicy);
            } catch (RemoteException ignored) {
            }
        } else if (networkPolicy != NETWORK_POLICY_ACCEPT) {
            Log.w(TAG, ""Dropping requested network policy due to missing service!"");
        }
        if ((sVmPolicy.mask & DETECT_VM_NON_SDK_API_USAGE) != 0) {
            VMRuntime.setNonSdkApiUsageConsumer(sNonSdkApiUsageConsumer);
            VMRuntime.setDedupeHiddenApiWarnings(false);
        } else {
            VMRuntime.setNonSdkApiUsageConsumer(null);
            VMRuntime.setDedupeHiddenApiWarnings(true);
        }
    }
}",1,"/**
 * Sets the policy for what actions in the VM process (on any
 * thread) should be detected, as well as the penalty if such
 * actions occur.
 *
 * @param policy the policy to put into place
 */
","/**
 * Sets the policy for what actions in the VM process (on any thread) should be detected, as
 * well as the penalty if such actions occur.
 *
 * @param policy the policy to put into place
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3,4","1,2",The late implementation has the following changes:,
398,"<android.app.ContextImpl: void startActivity(Intent,Bundle)>",27,28,"<android.app.ContextImpl: void startActivity(Intent,Bundle)>","<android.app.ContextImpl: void startActivity(Intent,Bundle)>",0,"{
    warnIfCallingFromSystemProcess();
    // be launched in.
    if ((intent.getFlags() & Intent.FLAG_ACTIVITY_NEW_TASK) == 0 && options != null && ActivityOptions.fromBundle(options).getLaunchTaskId() == -1) {
        throw new AndroidRuntimeException(""Calling startActivity() from outside of an Activity "" + "" context requires the FLAG_ACTIVITY_NEW_TASK flag."" + "" Is this really what you want?"");
    }
    mMainThread.getInstrumentation().execStartActivity(getOuterContext(), mMainThread.getApplicationThread(), null, (Activity) null, intent, -1, options);
}","{
    warnIfCallingFromSystemProcess();
    // Calling start activity from outside an activity without FLAG_ACTIVITY_NEW_TASK is
    // generally not allowed, except if the caller specifies the task id the activity should
    // be launched in. A bug was existed between N and O-MR1 which allowed this to work. We
    // maintain this for backwards compatibility.
    final int targetSdkVersion = getApplicationInfo().targetSdkVersion;
    if ((intent.getFlags() & Intent.FLAG_ACTIVITY_NEW_TASK) == 0 && (targetSdkVersion < Build.VERSION_CODES.N || targetSdkVersion >= Build.VERSION_CODES.P) && (options == null || ActivityOptions.fromBundle(options).getLaunchTaskId() == -1)) {
        throw new AndroidRuntimeException(""Calling startActivity() from outside of an Activity "" + "" context requires the FLAG_ACTIVITY_NEW_TASK flag."" + "" Is this really what you want?"");
    }
    mMainThread.getInstrumentation().execStartActivity(getOuterContext(), mMainThread.getApplicationThread(), null, (Activity) null, intent, -1, options);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,4",2,"There was a change in the condition which checks if the `FLAG_ACTIVITY_NEW_TASK` is set and the SDK version logic. The late version adds an additional condition to check the `targetSdkVersion`. There's also the addition of a comment that describes backwards compatibility, but comments do not affect code execution. So the code change type is a change in Control dependency (3) and Other statement (comment) changed (4).","With the change in the condition that checks the `targetSdkVersion`, which might potentially change the thrown exception behavior, differently affecting whether an `AndroidRuntimeException` is thrown or not, the CI type is 2 (Compatibility Issue caused by potential different exception handlings)."
399,<android.widget.TextView.Marquee: void tick()>,27,28,<android.widget.TextView.Marquee: void tick()>,<android.widget.TextView.Marquee: void tick()>,0,"{
    if (mStatus != MARQUEE_RUNNING) {
        return;
    }
    mChoreographer.removeFrameCallback(mTickCallback);
    final TextView textView = mView.get();
    if (textView != null && (textView.isFocused() || textView.isSelected())) {
        long currentMs = mChoreographer.getFrameTime();
        long deltaMs = currentMs - mLastAnimationMs;
        mLastAnimationMs = currentMs;
        float deltaPx = deltaMs / 1000f * mPixelsPerSecond;
        mScroll += deltaPx;
        if (mScroll > mMaxScroll) {
            mScroll = mMaxScroll;
            mChoreographer.postFrameCallbackDelayed(mRestartCallback, MARQUEE_DELAY);
        } else {
            mChoreographer.postFrameCallback(mTickCallback);
        }
        textView.invalidate();
    }
}","{
    if (mStatus != MARQUEE_RUNNING) {
        return;
    }
    mChoreographer.removeFrameCallback(mTickCallback);
    final TextView textView = mView.get();
    if (textView != null && (textView.isFocused() || textView.isSelected())) {
        long currentMs = mChoreographer.getFrameTime();
        long deltaMs = currentMs - mLastAnimationMs;
        mLastAnimationMs = currentMs;
        float deltaPx = deltaMs * mPixelsPerMs;
        mScroll += deltaPx;
        if (mScroll > mMaxScroll) {
            mScroll = mMaxScroll;
            mChoreographer.postFrameCallbackDelayed(mRestartCallback, MARQUEE_DELAY);
        } else {
            mChoreographer.postFrameCallback(mTickCallback);
        }
        textView.invalidate();
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,4,0,"The only change in the code is the calculation of `deltaPx` from `deltaMs / 1000f * mPixelsPerSecond` to `deltaMs * mPixelsPerMs`. This is a change in the internal calculation, so the code change type is 4.","The change in the calculation method does not affect the API's external behavior with respect to returned values or thrown exceptions. It is an internal change to how values are computed, but the logic and potential side effects remain the same, so there is no Compatibility Issue."
400,<android.net.TrafficStats: long getTotalRxPackets()>,27,28,<android.net.TrafficStats: long getTotalRxPackets()>,<android.net.TrafficStats: long getTotalRxPackets()>,0,"{
    return nativeGetTotalStat(TYPE_RX_PACKETS);
}","{
    try {
        return getStatsService().getTotalStats(TYPE_RX_PACKETS);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Return number of packets received since device boot. Counts packets
 * across all network interfaces, and always increases monotonically since
 * device boot. Statistics are measured at the network layer, so they
 * include both TCP and UDP usage.
 * <p>
 * Before {@link android.os.Build.VERSION_CODES#JELLY_BEAN_MR2}, this may
 * return {@link #UNSUPPORTED} on devices where statistics aren't available.
 */
","/**
 * Return number of packets received since device boot. Counts packets
 * across all network interfaces, and always increases monotonically since
 * device boot. Statistics are measured at the network layer, so they
 * include both TCP and UDP usage.
 * <p>
 * Before {@link android.os.Build.VERSION_CODES#JELLY_BEAN_MR2}, this may
 * return {@link #UNSUPPORTED} on devices where statistics aren't available.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,5","1,2","The implementation of the method has changed to invoke a different method `getStatsService().getTotalStats(TYPE_RX_PACKETS)` instead of `nativeGetTotalStat(TYPE_RX_PACKETS)`, and a new exception handling statement has been added for RemoteException, so the code change type is 2,5.","The method now relies on a potentially new implementation `getStatsService().getTotalStats`, which may lead to a different return value or throw a new exception. Additionally, the introduction of a new exception handling mechanism could lead to different exception throwing behaviors, so the CI type is 1,2."
401,"<android.provider.Settings.System: long getLong(ContentResolver,String)>",27,28,"<android.provider.Settings.System: long getLong(ContentResolver,String)>","<android.provider.Settings.System: long getLong(ContentResolver,String)>",0,"{
    return getLongForUser(cr, name, UserHandle.myUserId());
}","{
    return getLongForUser(cr, name, cr.getUserId());
}",1,"/**
 * Convenience function for retrieving a single system settings value
 * as a {@code long}.  Note that internally setting values are always
 * stored as strings; this function converts the string to a {@code long}
 * for you.
 * <p>
 * This version does not take a default value.  If the setting has not
 * been set, or the string value is not a number,
 * it throws {@link SettingNotFoundException}.
 *
 * @param cr The ContentResolver to access.
 * @param name The name of the setting to retrieve.
 *
 * @return The setting's current value.
 * @throws SettingNotFoundException Thrown if a setting by the given
 * name can't be found or the setting value is not an integer.
 */
","/**
 * Convenience function for retrieving a single system settings value
 * as a {@code long}.  Note that internally setting values are always
 * stored as strings; this function converts the string to a {@code long}
 * for you.
 * <p>
 * This version does not take a default value.  If the setting has not
 * been set, or the string value is not a number,
 * it throws {@link SettingNotFoundException}.
 *
 * @param cr The ContentResolver to access.
 * @param name The name of the setting to retrieve.
 *
 * @return The setting's current value.
 * @throws SettingNotFoundException Thrown if a setting by the given
 * name can't be found or the setting value is not an integer.
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The implementation has changed from using UserHandle.myUserId() to using cr.getUserId(), so this is a change to a dependent API invocation (the method used to obtain the user ID).","Even though the implementation is using different methods to obtain the user ID, there is no indication that the behavior of the API would be different, assuming that both methods should return the same user ID under normal circumstances. Therefore, there is no Compatibility Issue expected from this change as long as the methods behave as expected in returning the current user's ID."
402,"<android.content.res.TypedArray: float getDimension(int,float)>",27,28,"<android.content.res.TypedArray: float getDimension(int,float)>","<android.content.res.TypedArray: float getDimension(int,float)>",0,"{
    if (mRecycled) {
        throw new RuntimeException(""Cannot make calls to a recycled instance!"");
    }
    final int attrIndex = index;
    index *= AssetManager.STYLE_NUM_ENTRIES;
    final int[] data = mData;
    final int type = data[index + AssetManager.STYLE_TYPE];
    if (type == TypedValue.TYPE_NULL) {
        return defValue;
    } else if (type == TypedValue.TYPE_DIMENSION) {
        return TypedValue.complexToDimension(data[index + AssetManager.STYLE_DATA], mMetrics);
    } else if (type == TypedValue.TYPE_ATTRIBUTE) {
        final TypedValue value = mValue;
        getValueAt(index, value);
        throw new UnsupportedOperationException(""Failed to resolve attribute at index "" + attrIndex + "": "" + value);
    }
    throw new UnsupportedOperationException(""Can't convert value at index "" + attrIndex + "" to dimension: type=0x"" + Integer.toHexString(type));
}","{
    if (mRecycled) {
        throw new RuntimeException(""Cannot make calls to a recycled instance!"");
    }
    final int attrIndex = index;
    index *= STYLE_NUM_ENTRIES;
    final int[] data = mData;
    final int type = data[index + STYLE_TYPE];
    if (type == TypedValue.TYPE_NULL) {
        return defValue;
    } else if (type == TypedValue.TYPE_DIMENSION) {
        return TypedValue.complexToDimension(data[index + STYLE_DATA], mMetrics);
    } else if (type == TypedValue.TYPE_ATTRIBUTE) {
        final TypedValue value = mValue;
        getValueAt(index, value);
        throw new UnsupportedOperationException(""Failed to resolve attribute at index "" + attrIndex + "": "" + value);
    }
    throw new UnsupportedOperationException(""Can't convert value at index "" + attrIndex + "" to dimension: type=0x"" + Integer.toHexString(type));
}",1,"/**
 * Retrieve a dimensional unit attribute at <var>index</var>. Unit
 * conversions are based on the current {@link DisplayMetrics}
 * associated with the resources this {@link TypedArray} object
 * came from.
 * <p>
 * This method will throw an exception if the attribute is defined but is
 * not a dimension.
 *
 * @param index Index of attribute to retrieve.
 * @param defValue Value to return if the attribute is not defined or
 * not a resource.
 *
 * @return Attribute dimension value multiplied by the appropriate
 * metric, or defValue if not defined.
 * @throws RuntimeException if the TypedArray has already been recycled.
 * @throws UnsupportedOperationException if the attribute is defined but is
 * not an integer.
 *
 * @see #getDimensionPixelOffset
 * @see #getDimensionPixelSize
 */
","/**
 * Retrieve a dimensional unit attribute at <var>index</var>. Unit
 * conversions are based on the current {@link DisplayMetrics}
 * associated with the resources this {@link TypedArray} object
 * came from.
 * <p>
 * This method will throw an exception if the attribute is defined but is
 * not a dimension.
 *
 * @param index Index of attribute to retrieve.
 * @param defValue Value to return if the attribute is not defined or
 * not a resource.
 *
 * @return Attribute dimension value multiplied by the appropriate
 * metric, or defValue if not defined.
 * @throws RuntimeException if the TypedArray has already been recycled.
 * @throws UnsupportedOperationException if the attribute is defined but is
 * not an integer.
 *
 * @see #getDimensionPixelOffset
 * @see #getDimensionPixelSize
 */
",-1,,,-1,-1,-1,-1,-1,-1,0,0,"There is no change in the return statements, exception handling, control dependencies, or any other statements, as the modifications visible are only related to representing the AssetManager.STYLE_* constants without the class qualification, which does not affect the behavior of the code.","There is no Compatibility Issue, as there are no changes that affect the execution flow or output of the method."
403,"<android.provider.Settings.System: long getLong(ContentResolver,String,long)>",27,28,"<android.provider.Settings.System: long getLong(ContentResolver,String,long)>","<android.provider.Settings.System: long getLong(ContentResolver,String,long)>",0,"{
    return getLongForUser(cr, name, def, UserHandle.myUserId());
}","{
    return getLongForUser(cr, name, def, cr.getUserId());
}",1,"/**
 * Convenience function for retrieving a single system settings value
 * as a {@code long}.  Note that internally setting values are always
 * stored as strings; this function converts the string to a {@code long}
 * for you.  The default value will be returned if the setting is
 * not defined or not a {@code long}.
 *
 * @param cr The ContentResolver to access.
 * @param name The name of the setting to retrieve.
 * @param def Value to return if the setting is not defined.
 *
 * @return The setting's current value, or 'def' if it is not defined
 * or not a valid {@code long}.
 */
","/**
 * Convenience function for retrieving a single system settings value
 * as a {@code long}.  Note that internally setting values are always
 * stored as strings; this function converts the string to a {@code long}
 * for you.  The default value will be returned if the setting is
 * not defined or not a {@code long}.
 *
 * @param cr The ContentResolver to access.
 * @param name The name of the setting to retrieve.
 * @param def Value to return if the setting is not defined.
 *
 * @return The setting's current value, or 'def' if it is not defined
 * or not a valid {@code long}.
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The code has changed from using UserHandle.myUserId() to cr.getUserId() in the return statement, so the change type is 5.","The change in how the user ID is obtained does not usually alter the functionality or behavior of the getLong method, because both UserHandle.myUserId() and cr.getUserId() are expected to return the ID of the current user. Since the change is more related to how the user ID is retrieved rather than the logic of how the long value is retrieved, this is not expected to cause a Compatibility Issue."
404,"<android.app.Instrumentation: Activity newActivity(Class<?>,Context,IBinder,Application,Intent,ActivityInfo,CharSequence,Activity,String,Object)>",27,28,"<android.app.Instrumentation: Activity newActivity(Class<?>,Context,IBinder,Application,Intent,ActivityInfo,CharSequence,Activity,String,Object)>","<android.app.Instrumentation: Activity newActivity(Class<?>,Context,IBinder,Application,Intent,ActivityInfo,CharSequence,Activity,String,Object)>",0,"{
    Activity activity = (Activity) clazz.newInstance();
    ActivityThread aThread = null;
    activity.attach(context, aThread, this, token, 0, /* ident */
    application, intent, info, title, parent, id, (Activity.NonConfigurationInstances) lastNonConfigurationInstance, new Configuration(), null, /* referrer */
    null, /* voiceInteractor */
    null, /* window */
    null);
    return activity;
}","{
    Activity activity = (Activity) clazz.newInstance();
    ActivityThread aThread = null;
    // Activity.attach expects a non-null Application Object.
    if (application == null) {
        application = new Application();
    }
    activity.attach(context, aThread, this, token, 0, /* ident */
    application, intent, info, title, parent, id, (Activity.NonConfigurationInstances) lastNonConfigurationInstance, new Configuration(), null, /* referrer */
    null, /* voiceInteractor */
    null, /* window */
    null);
    return activity;
}",1,"/**
 * Perform instantiation of an {@link Activity} object.  This method is intended for use with
 * unit tests, such as android.test.ActivityUnitTestCase.  The activity will be useable
 * locally but will be missing some of the linkages necessary for use within the system.
 *
 * @param clazz The Class of the desired Activity
 * @param context The base context for the activity to use
 * @param token The token for this activity to communicate with
 * @param application The application object (if any)
 * @param intent The intent that started this Activity
 * @param info ActivityInfo from the manifest
 * @param title The title, typically retrieved from the ActivityInfo record
 * @param parent The parent Activity (if any)
 * @param id The embedded Id (if any)
 * @param lastNonConfigurationInstance Arbitrary object that will be
 * available via {@link Activity#getLastNonConfigurationInstance()
 * Activity.getLastNonConfigurationInstance()}.
 * @return Returns the instantiated activity
 * @throws InstantiationException
 * @throws IllegalAccessException
 */
","/**
 * Perform instantiation of an {@link Activity} object.  This method is intended for use with
 * unit tests, such as android.test.ActivityUnitTestCase.  The activity will be useable
 * locally but will be missing some of the linkages necessary for use within the system.
 *
 * @param clazz The Class of the desired Activity
 * @param context The base context for the activity to use
 * @param token The token for this activity to communicate with
 * @param application The application object (if any)
 * @param intent The intent that started this Activity
 * @param info ActivityInfo from the manifest
 * @param title The title, typically retrieved from the ActivityInfo record
 * @param parent The parent Activity (if any)
 * @param id The embedded Id (if any)
 * @param lastNonConfigurationInstance Arbitrary object that will be
 * available via {@link Activity#getLastNonConfigurationInstance()
 * Activity.getLastNonConfigurationInstance()}.
 * @return Returns the instantiated activity
 * @throws InstantiationException
 * @throws IllegalAccessException
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",0,"The change included the addition of an 'if' condition to check if the application is null and, if it is, to instantiate a new Application. This is an addition of new control flow and the creation of a new object, which falls under type 3 and 4.","This change does not cause a Compatibility Issue because the behavior of returning an Activity from the method is preserved. Even though a new Application object is created if one is not supplied, the creation of a new Application object within the method does not alter the method's ability to create and return the Activity object as before. The method still returns an activity with the correct type and does not introduce new exception handling or control paths that would change the returned value based on the input parameters provided to the method; therefore, there is no CI."
405,"<android.view.inputmethod.InputMethodManager: void showSoftInputFromInputMethod(IBinder,int)>",27,28,"<android.view.inputmethod.InputMethodManager: void showSoftInputFromInputMethod(IBinder,int)>","<android.view.inputmethod.InputMethodManager: void showSoftInputFromInputMethod(IBinder,int)>",0,"{
    try {
        mService.showMySoftInput(token, flags);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}","{
    showSoftInputFromInputMethodInternal(token, flags);
}",1,"/**
 * Show the input method's soft input area, so the user
 * sees the input method window and can interact with it.
 * This can only be called from the currently active input method,
 * as validated by the given token.
 *
 * @param token Supplies the identifying token given to an input method
 * when it was started, which allows it to perform this operation on
 * itself.
 * @param flags Provides additional operating flags.  Currently may be
 * 0 or have the {@link #SHOW_IMPLICIT} or
 * {@link #SHOW_FORCED} bit set.
 */
","/**
 * Show the input method's soft input area, so the user
 * sees the input method window and can interact with it.
 * This can only be called from the currently active input method,
 * as validated by the given token.
 *
 * @param token Supplies the identifying token given to an input method
 * when it was started, which allows it to perform this operation on
 * itself.
 * @param flags Provides additional operating flags.  Currently may be
 * 0 or have the {@link #SHOW_IMPLICIT} or
 * {@link #SHOW_FORCED} bit set.
 * @deprecated Use {@link InputMethodService#requestShowSelf(int)} instead. This method was
 * intended for IME developers who should be accessing APIs through the service. APIs in this
 * class are intended for app developers interacting with the IME.
 */
",-1,,[@Deprecated],-1,-1,-1,-1,-1,-1,"4,5",0,"The method implementation in the late version calls a different method (showSoftInputFromInputMethodInternal) instead of directly calling mService.showMySoftInput, which indicates a change in the dependent API (4, 5).","Although there is a change in implementation by calling a different method, this change by itself does not cause a compatibility issue since it is internal to the method and does not alter the method's signature or expected behavior. The try-catch block was also removed, yet as long as the internal method correctly handles exceptions as the try-catch block did, the exception behavior remains unchanged. Thus, there are no compatibility issues (0)."
406,<android.content.ContentResolver: void unregisterContentObserver(ContentObserver)>,27,28,<android.content.ContentResolver: void unregisterContentObserver(ContentObserver)>,<android.content.ContentResolver: void unregisterContentObserver(ContentObserver)>,0,"{
    Preconditions.checkNotNull(observer, ""observer"");
    try {
        IContentObserver contentObserver = observer.releaseContentObserver();
        if (contentObserver != null) {
            getContentService().unregisterContentObserver(contentObserver);
        }
    } catch (RemoteException e) {
    }
}","{
    Preconditions.checkNotNull(observer, ""observer"");
    try {
        IContentObserver contentObserver = observer.releaseContentObserver();
        if (contentObserver != null) {
            getContentService().unregisterContentObserver(contentObserver);
        }
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Unregisters a change observer.
 *
 * @param observer The previously registered observer that is no longer needed.
 * @see #registerContentObserver
 */
","/**
 * Unregisters a change observer.
 *
 * @param observer The previously registered observer that is no longer needed.
 * @see #registerContentObserver
 */
",-1,,,-1,-1,-1,-1,-1,-1,2,2,"The code change is an exception handling statement, from catching and ignoring a RemoteException to rethrowing it, so the change type is 2.","This change leads to a potential Compatibility Issue caused by different exception handlings. In the early version, a RemoteException is caught and ignored, while in the late version, the same exception is rethrown. This change will potentially affect client code that was not expecting an exception to be thrown at all, so the CI type is 2."
407,<android.app.NotificationChannel: String toString()>,27,28,<android.app.NotificationChannel: String toString()>,<android.app.NotificationChannel: String toString()>,0,"{
    return ""NotificationChannel{"" + ""mId='"" + mId + '\'' + "", mName="" + mName + "", mDescription="" + (!TextUtils.isEmpty(mDesc) ? ""hasDescription "" : """") + "", mImportance="" + mImportance + "", mBypassDnd="" + mBypassDnd + "", mLockscreenVisibility="" + mLockscreenVisibility + "", mSound="" + mSound + "", mLights="" + mLights + "", mLightColor="" + mLightColor + "", mVibration="" + Arrays.toString(mVibration) + "", mUserLockedFields="" + mUserLockedFields + "", mVibrationEnabled="" + mVibrationEnabled + "", mShowBadge="" + mShowBadge + "", mDeleted="" + mDeleted + "", mGroup='"" + mGroup + '\'' + "", mAudioAttributes="" + mAudioAttributes + "", mBlockableSystem="" + mBlockableSystem + '}';
}","{
    return ""NotificationChannel{"" + ""mId='"" + mId + '\'' + "", mName="" + mName + "", mDescription="" + (!TextUtils.isEmpty(mDesc) ? ""hasDescription "" : """") + "", mImportance="" + mImportance + "", mBypassDnd="" + mBypassDnd + "", mLockscreenVisibility="" + mLockscreenVisibility + "", mSound="" + mSound + "", mLights="" + mLights + "", mLightColor="" + mLightColor + "", mVibration="" + Arrays.toString(mVibration) + "", mUserLockedFields="" + Integer.toHexString(mUserLockedFields) + "", mFgServiceShown="" + mFgServiceShown + "", mVibrationEnabled="" + mVibrationEnabled + "", mShowBadge="" + mShowBadge + "", mDeleted="" + mDeleted + "", mGroup='"" + mGroup + '\'' + "", mAudioAttributes="" + mAudioAttributes + "", mBlockableSystem="" + mBlockableSystem + '}';
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"A new field `mFgServiceShown` is included in the string output, and the value `mUserLockedFields` is shown in hexadecimal form instead of decimal. Therefore, the code change is of type 4, Other statement changed.","Despite the addition of new field information and format change in the output string, this is not a compatibility issue because the method is designed to return a string representation of the object for informational purposes only. It should have no impact on the functional behavior of the application or the object's state. Therefore, the CI type is 0, No Compatibility Issue."
408,<android.view.accessibility.AccessibilityRecord: String toString()>,27,28,<android.view.accessibility.AccessibilityRecord: String toString()>,<android.view.accessibility.AccessibilityRecord: String toString()>,0,"{
    StringBuilder builder = new StringBuilder();
    builder.append("" [ ClassName: "" + mClassName);
    builder.append(""; Text: "" + mText);
    builder.append(""; ContentDescription: "" + mContentDescription);
    builder.append(""; ItemCount: "" + mItemCount);
    builder.append(""; CurrentItemIndex: "" + mCurrentItemIndex);
    builder.append(""; IsEnabled: "" + getBooleanProperty(PROPERTY_ENABLED));
    builder.append(""; IsPassword: "" + getBooleanProperty(PROPERTY_PASSWORD));
    builder.append(""; IsChecked: "" + getBooleanProperty(PROPERTY_CHECKED));
    builder.append(""; IsFullScreen: "" + getBooleanProperty(PROPERTY_FULL_SCREEN));
    builder.append(""; Scrollable: "" + getBooleanProperty(PROPERTY_SCROLLABLE));
    builder.append(""; BeforeText: "" + mBeforeText);
    builder.append(""; FromIndex: "" + mFromIndex);
    builder.append(""; ToIndex: "" + mToIndex);
    builder.append(""; ScrollX: "" + mScrollX);
    builder.append(""; ScrollY: "" + mScrollY);
    builder.append(""; MaxScrollX: "" + mMaxScrollX);
    builder.append(""; MaxScrollY: "" + mMaxScrollY);
    builder.append(""; AddedCount: "" + mAddedCount);
    builder.append(""; RemovedCount: "" + mRemovedCount);
    builder.append(""; ParcelableData: "" + mParcelableData);
    builder.append("" ]"");
    return builder.toString();
}","{
    return appendTo(new StringBuilder()).toString();
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"The implementation of the toString method has been refactored to call a new method appendTo with the StringBuilder instantiation, instead of directly building the string in the method itself. This is an internal change to how the method is implemented and is of type 4, Other statement changed.",There is no Compatibility Issue as the behavior and the return value of the method have not changed; it still returns a String representation of the AccessibilityRecord object. The refactoring does not affect the API's outward behavior.
409,<android.app.Notification.Style: RemoteViews getStandardView(int)>,27,28,<android.app.Notification.Style: RemoteViews getStandardView(int)>,<android.app.Notification.Style: RemoteViews getStandardView(int)>,0,"{
    checkBuilder();
    // Nasty.
    CharSequence oldBuilderContentTitle = mBuilder.getAllExtras().getCharSequence(EXTRA_TITLE);
    if (mBigContentTitle != null) {
        mBuilder.setContentTitle(mBigContentTitle);
    }
    RemoteViews contentView = mBuilder.applyStandardTemplateWithActions(layoutId);
    mBuilder.getAllExtras().putCharSequence(EXTRA_TITLE, oldBuilderContentTitle);
    if (mBigContentTitle != null && mBigContentTitle.equals("""")) {
        contentView.setViewVisibility(R.id.line1, View.GONE);
    } else {
        contentView.setViewVisibility(R.id.line1, View.VISIBLE);
    }
    return contentView;
}","{
    return getStandardView(layoutId, null);
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,1,1,"The early version contains a complex implementation with multiple calls and conditions that set content views and visibility states, while the late version replaces this logic with a single call to another method, so the change type is 1.","Since the late version delegates the work to another method and does not use any of the visible logic present in the early version, it suggests that the behavior of the method may have changed. The method potentially returns different RemoteViews objects due to changes in how the views are constructed and configured. Therefore, there could be a compatibility issue with the potential for different return values, which categorizes it as CI type 1."
410,"<android.provider.Settings.Secure: float getFloat(ContentResolver,String,float)>",27,28,"<android.provider.Settings.Secure: float getFloat(ContentResolver,String,float)>","<android.provider.Settings.Secure: float getFloat(ContentResolver,String,float)>",0,"{
    return getFloatForUser(cr, name, def, UserHandle.myUserId());
}","{
    return getFloatForUser(cr, name, def, cr.getUserId());
}",1,"/**
 * Convenience function for retrieving a single secure settings value
 * as a floating point number.  Note that internally setting values are
 * always stored as strings; this function converts the string to an
 * float for you. The default value will be returned if the setting
 * is not defined or not a valid float.
 *
 * @param cr The ContentResolver to access.
 * @param name The name of the setting to retrieve.
 * @param def Value to return if the setting is not defined.
 *
 * @return The setting's current value, or 'def' if it is not defined
 * or not a valid float.
 */
","/**
 * Convenience function for retrieving a single secure settings value
 * as a floating point number.  Note that internally setting values are
 * always stored as strings; this function converts the string to an
 * float for you. The default value will be returned if the setting
 * is not defined or not a valid float.
 *
 * @param cr The ContentResolver to access.
 * @param name The name of the setting to retrieve.
 * @param def Value to return if the setting is not defined.
 *
 * @return The setting's current value, or 'def' if it is not defined
 * or not a valid float.
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The dependent method parameter changed from UserHandle.myUserId() to cr.getUserId(), so the code change type is 5.","Although the method signature has not changed and the return type is the same, if cr.getUserId() returns the same value as UserHandle.myUserId(), there would be no Compatibility Issue. The use of different methods to obtain the user ID does not inherently cause a CI; it would only be a CI if the returned value of cr.getUserId() and UserHandle.myUserId() can be different, which is not evident based on the given context. Hence, the CI type is 0."
411,"<android.provider.Settings.System: int getInt(ContentResolver,String)>",27,28,"<android.provider.Settings.System: int getInt(ContentResolver,String)>","<android.provider.Settings.System: int getInt(ContentResolver,String)>",0,"{
    return getIntForUser(cr, name, UserHandle.myUserId());
}","{
    return getIntForUser(cr, name, cr.getUserId());
}",1,"/**
 * Convenience function for retrieving a single system settings value
 * as an integer.  Note that internally setting values are always
 * stored as strings; this function converts the string to an integer
 * for you.
 * <p>
 * This version does not take a default value.  If the setting has not
 * been set, or the string value is not a number,
 * it throws {@link SettingNotFoundException}.
 *
 * @param cr The ContentResolver to access.
 * @param name The name of the setting to retrieve.
 *
 * @throws SettingNotFoundException Thrown if a setting by the given
 * name can't be found or the setting value is not an integer.
 *
 * @return The setting's current value.
 */
","/**
 * Convenience function for retrieving a single system settings value
 * as an integer.  Note that internally setting values are always
 * stored as strings; this function converts the string to an integer
 * for you.
 * <p>
 * This version does not take a default value.  If the setting has not
 * been set, or the string value is not a number,
 * it throws {@link SettingNotFoundException}.
 *
 * @param cr The ContentResolver to access.
 * @param name The name of the setting to retrieve.
 *
 * @throws SettingNotFoundException Thrown if a setting by the given
 * name can't be found or the setting value is not an integer.
 *
 * @return The setting's current value.
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"There is a change in the method call from 'UserHandle.myUserId()' to 'cr.getUserId()'. Therefore, it is a dependent API change, so the code change type is 5.","As the change is within the implementation detail of getting the current user ID, and assuming 'cr.getUserId()' returns the same value as 'UserHandle.myUserId()' for the current context, there should be no functional difference in behavior from the perspective of the code calling 'getInt'. Therefore, there is no Compatibility Issue."
412,<android.widget.Editor.EasyEditPopupWindow: int getVerticalLocalPosition(int)>,27,28,<android.widget.Editor.EasyEditPopupWindow: int getVerticalLocalPosition(int)>,<android.widget.Editor.EasyEditPopupWindow: int getVerticalLocalPosition(int)>,0,"{
    return mTextView.getLayout().getLineBottom(line);
}","{
    final Layout layout = mTextView.getLayout();
    return layout.getLineBottomWithoutSpacing(line);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,5",1,"The method invocation in the return statement has changed from getLineBottom(line) to getLineBottomWithoutSpacing(line), and this is a change in a dependent API which means the type of code change is 1,5.","As the method called in the return statement has changed, the API could potentially return a different value, hence the CI type is 1."
413,<android.net.TrafficStats: long getUidRxBytes(int)>,27,28,<android.net.TrafficStats: long getUidRxBytes(int)>,<android.net.TrafficStats: long getUidRxBytes(int)>,0,"{
    // This isn't actually enforcing any security; it just returns the
    // unsupported value. The real filtering is done at the kernel level.
    final int callingUid = android.os.Process.myUid();
    if (callingUid == android.os.Process.SYSTEM_UID || callingUid == uid) {
        return nativeGetUidStat(uid, TYPE_RX_BYTES);
    } else {
        return UNSUPPORTED;
    }
}","{
    // This isn't actually enforcing any security; it just returns the
    // unsupported value. The real filtering is done at the kernel level.
    final int callingUid = android.os.Process.myUid();
    if (callingUid == android.os.Process.SYSTEM_UID || callingUid == uid) {
        try {
            return getStatsService().getUidStats(uid, TYPE_RX_BYTES);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    } else {
        return UNSUPPORTED;
    }
}",1,"/**
 * Return number of bytes received by the given UID since device boot.
 * Counts packets across all network interfaces, and always increases
 * monotonically since device boot. Statistics are measured at the network
 * layer, so they include both TCP and UDP usage.
 * <p>
 * Before {@link android.os.Build.VERSION_CODES#JELLY_BEAN_MR2}, this may return
 * {@link #UNSUPPORTED} on devices where statistics aren't available.
 * <p>
 * Starting in {@link android.os.Build.VERSION_CODES#N} this will only
 * report traffic statistics for the calling UID. It will return
 * {@link #UNSUPPORTED} for all other UIDs for privacy reasons. To access
 * historical network statistics belonging to other UIDs, use
 * {@link NetworkStatsManager}.
 *
 * @see android.os.Process#myUid()
 * @see android.content.pm.ApplicationInfo#uid
 */
","/**
 * Return number of bytes received by the given UID since device boot.
 * Counts packets across all network interfaces, and always increases
 * monotonically since device boot. Statistics are measured at the network
 * layer, so they include both TCP and UDP usage.
 * <p>
 * Before {@link android.os.Build.VERSION_CODES#JELLY_BEAN_MR2}, this may return
 * {@link #UNSUPPORTED} on devices where statistics aren't available.
 * <p>
 * Starting in {@link android.os.Build.VERSION_CODES#N} this will only
 * report traffic statistics for the calling UID. It will return
 * {@link #UNSUPPORTED} for all other UIDs for privacy reasons. To access
 * historical network statistics belonging to other UIDs, use
 * {@link NetworkStatsManager}.
 *
 * @see android.os.Process#myUid()
 * @see android.content.pm.ApplicationInfo#uid
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,3,5","1,2","There are multiple changes in the implementation: the implementation now uses a getStatsService().getUidStats(uid, TYPE_RX_BYTES) call instead of nativeGetUidStat(uid, TYPE_RX_BYTES), which is an indication of a dependent API changed (5). Also, the previous version had no exception handling for the native method call, while the late version has added a try-catch block that catches a RemoteException and throws it after calling rethrowFromSystemServer(), which suggests an exception handling statement changed (2). Lastly, the calling structure inside the condition check has changed, which can be considered a control dependency change (3).","The introduction of a new try-catch block that throws a new exception can lead to a different method behavior in an error scenario, which presents a potential Compatibility Issue for different exception handling (2). Moreover, the dependent API call change could potentially affect what value is returned, which introduces a potential Compatibility Issue for different return values or types (1)."
414,"<android.hardware.HardwareBuffer: HardwareBuffer create(int,int,int,int,long)>",27,28,"<android.hardware.HardwareBuffer: HardwareBuffer create(int,int,int,int,long)>","<android.hardware.HardwareBuffer: HardwareBuffer create(int,int,int,int,long)>",0,"{
    if (!HardwareBuffer.isSupportedFormat(format)) {
        throw new IllegalArgumentException(""Invalid pixel format "" + format);
    }
    if (width <= 0) {
        throw new IllegalArgumentException(""Invalid width "" + width);
    }
    if (height <= 0) {
        throw new IllegalArgumentException(""Invalid height "" + height);
    }
    if (layers <= 0) {
        throw new IllegalArgumentException(""Invalid layer count "" + layers);
    }
    if (format == BLOB && height != 1) {
        throw new IllegalArgumentException(""Height must be 1 when using the BLOB format"");
    }
    long nativeObject = nCreateHardwareBuffer(width, height, format, layers, usage);
    if (nativeObject == 0) {
        throw new IllegalArgumentException(""Unable to create a HardwareBuffer, either the "" + ""dimensions passed were too large, too many image layers were requested, "" + ""or an invalid set of usage flags was passed"");
    }
    return new HardwareBuffer(nativeObject);
}","{
    if (!HardwareBuffer.isSupportedFormat(format)) {
        throw new IllegalArgumentException(""Invalid pixel format "" + format);
    }
    if (width <= 0) {
        throw new IllegalArgumentException(""Invalid width "" + width);
    }
    if (height <= 0) {
        throw new IllegalArgumentException(""Invalid height "" + height);
    }
    if (layers <= 0) {
        throw new IllegalArgumentException(""Invalid layer count "" + layers);
    }
    if (format == BLOB && height != 1) {
        throw new IllegalArgumentException(""Height must be 1 when using the BLOB format"");
    }
    long nativeObject = nCreateHardwareBuffer(width, height, format, layers, usage);
    if (nativeObject == 0) {
        throw new IllegalArgumentException(""Unable to create a HardwareBuffer, either the "" + ""dimensions passed were too large, too many image layers were requested, "" + ""or an invalid set of usage flags or invalid format was passed"");
    }
    return new HardwareBuffer(nativeObject);
}",1,"/**
 * Creates a new <code>HardwareBuffer</code> instance.
 *
 * <p>Calling this method will throw an <code>IllegalStateException</code> if
 * format is not a supported Format type.</p>
 *
 * @param width The width in pixels of the buffer
 * @param height The height in pixels of the buffer
 * @param format The format of each pixel, one of {@link #RGBA_8888}, {@link #RGBA_FP16},
 * {@link #RGBX_8888}, {@link #RGB_565}, {@link #RGB_888}, {@link #RGBA_1010102}, {@link #BLOB}
 * @param layers The number of layers in the buffer
 * @param usage Flags describing how the buffer will be used, one of
 * {@link #USAGE_CPU_READ_RARELY}, {@link #USAGE_CPU_READ_OFTEN},
 * {@link #USAGE_CPU_WRITE_RARELY}, {@link #USAGE_CPU_WRITE_OFTEN},
 * {@link #USAGE_GPU_SAMPLED_IMAGE}, {@link #USAGE_GPU_COLOR_OUTPUT},
 * {@link #USAGE_GPU_DATA_BUFFER}, {@link #USAGE_PROTECTED_CONTENT},
 * {@link #USAGE_SENSOR_DIRECT_DATA}, {@link #USAGE_VIDEO_ENCODE}
 * @return A <code>HardwareBuffer</code> instance if successful, or throws an
 * IllegalArgumentException if the dimensions passed are invalid (either zero, negative, or
 * too large to allocate), if the format is not supported, if the requested number of layers
 * is less than one or not supported, or if the passed usage flags are not a supported set.
 */
","/**
 * Creates a new <code>HardwareBuffer</code> instance.
 *
 * <p>Calling this method will throw an <code>IllegalStateException</code> if
 * format is not a supported Format type.</p>
 *
 * @param width The width in pixels of the buffer
 * @param height The height in pixels of the buffer
 * @param format The @Format of each pixel
 * @param layers The number of layers in the buffer
 * @param usage The @Usage flags describing how the buffer will be used
 * @return A <code>HardwareBuffer</code> instance if successful, or throws an
 * IllegalArgumentException if the dimensions passed are invalid (either zero, negative, or
 * too large to allocate), if the format is not supported, if the requested number of layers
 * is less than one or not supported, or if the passed usage flags are not a supported set.
 */
",-1,[@NonNull],[@NonNull],-1,-1,-1,-1,-1,-1,4,0,"The change is only in the error message of the IllegalArgumentException thrown when nativeObject == 0, so the code change type is 4.","Since the only change here is in the text of an error message, this does not affect the behavior of the method in terms of what it returns or the exceptions it might throw. There is no change in the control flow or in the conditions under which exceptions are thrown; therefore, there is no Compatibility Issue. The method behaves the same way from the perspective of an API consumer."
415,<android.app.admin.SystemUpdatePolicy: String toString()>,27,28,<android.app.admin.SystemUpdatePolicy: String toString()>,<android.app.admin.SystemUpdatePolicy: String toString()>,0,"{
    return String.format(""SystemUpdatePolicy (type: %d, windowStart: %d, windowEnd: %d)"", mPolicyType, mMaintenanceWindowStart, mMaintenanceWindowEnd);
}","{
    return String.format(""SystemUpdatePolicy (type: %d, windowStart: %d, windowEnd: %d, "" + ""freezes: [%s])"", mPolicyType, mMaintenanceWindowStart, mMaintenanceWindowEnd, mFreezePeriods.stream().map(n -> n.toString()).collect(Collectors.joining("","")));
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,4",1,"The return statement's composition has changed by including additional information about the freeze periods with mFreezePeriods, so classes 1 and 4 apply as the string structure is altered and a new operation is introduced.","The change of the return statement will result in the API returning a different value, which pertains to class 1."
416,"<android.app.PendingIntent: PendingIntent getBroadcast(Context,int,Intent,int)>",27,28,"<android.app.PendingIntent: PendingIntent getBroadcast(Context,int,Intent,int)>","<android.app.PendingIntent: PendingIntent getBroadcast(Context,int,Intent,int)>",0,"{
    return getBroadcastAsUser(context, requestCode, intent, flags, new UserHandle(UserHandle.myUserId()));
}","{
    return getBroadcastAsUser(context, requestCode, intent, flags, context.getUser());
}",1,"/**
 * Retrieve a PendingIntent that will perform a broadcast, like calling
 * {@link Context#sendBroadcast(Intent) Context.sendBroadcast()}.
 *
 * <p class=""note"">For security reasons, the {@link android.content.Intent}
 * you supply here should almost always be an <em>explicit intent</em>,
 * that is specify an explicit component to be delivered to through
 * {@link Intent#setClass(android.content.Context, Class) Intent.setClass}</p>
 *
 * @param context The Context in which this PendingIntent should perform
 * the broadcast.
 * @param requestCode Private request code for the sender
 * @param intent The Intent to be broadcast.
 * @param flags May be {@link #FLAG_ONE_SHOT}, {@link #FLAG_NO_CREATE},
 * {@link #FLAG_CANCEL_CURRENT}, {@link #FLAG_UPDATE_CURRENT},
 * {@link #FLAG_IMMUTABLE} or any of the flags as supported by
 * {@link Intent#fillIn Intent.fillIn()} to control which unspecified parts
 * of the intent that can be supplied when the actual send happens.
 *
 * @return Returns an existing or new PendingIntent matching the given
 * parameters.  May return null only if {@link #FLAG_NO_CREATE} has been
 * supplied.
 */
","/**
 * Retrieve a PendingIntent that will perform a broadcast, like calling
 * {@link Context#sendBroadcast(Intent) Context.sendBroadcast()}.
 *
 * <p class=""note"">For security reasons, the {@link android.content.Intent}
 * you supply here should almost always be an <em>explicit intent</em>,
 * that is specify an explicit component to be delivered to through
 * {@link Intent#setClass(android.content.Context, Class) Intent.setClass}</p>
 *
 * @param context The Context in which this PendingIntent should perform
 * the broadcast.
 * @param requestCode Private request code for the sender
 * @param intent The Intent to be broadcast.
 * @param flags May be {@link #FLAG_ONE_SHOT}, {@link #FLAG_NO_CREATE},
 * {@link #FLAG_CANCEL_CURRENT}, {@link #FLAG_UPDATE_CURRENT},
 * {@link #FLAG_IMMUTABLE} or any of the flags as supported by
 * {@link Intent#fillIn Intent.fillIn()} to control which unspecified parts
 * of the intent that can be supplied when the actual send happens.
 *
 * @return Returns an existing or new PendingIntent matching the given
 * parameters.  May return null only if {@link #FLAG_NO_CREATE} has been
 * supplied.
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The API calls 'getBroadcastAsUser' with a different method for obtaining the user handle: `UserHandle.myUserId()` is replaced with `context.getUser()`. There is no change in the return type, control flow, or exception handling. Hence, it's a change in the dependent API, which is type 5.","Though the method for obtaining the user handle parameter has changed, assuming 'context.getUser()' is semantically equivalent to 'new UserHandle(UserHandle.myUserId())' (i.e., they both obtain the identifier of the current user), this change should not cause the method to behave differently. Therefore, there is no Compatibility Issue, so the CI type is 0."
417,"<android.app.assist.AssistStructure: void dump(String,ViewNode,boolean)>",27,28,"<android.app.assist.AssistStructure: void dump(String,ViewNode,boolean)>","<android.app.assist.AssistStructure: void dump(String,ViewNode,boolean)>",0,"{
    Log.i(TAG, prefix + ""View ["" + node.getLeft() + "","" + node.getTop() + "" "" + node.getWidth() + ""x"" + node.getHeight() + ""]"" + "" "" + node.getClassName());
    int id = node.getId();
    if (id != 0) {
        StringBuilder sb = new StringBuilder();
        sb.append(prefix);
        sb.append(""  ID: #"");
        sb.append(Integer.toHexString(id));
        String entry = node.getIdEntry();
        if (entry != null) {
            String type = node.getIdType();
            String pkg = node.getIdPackage();
            sb.append("" "");
            sb.append(pkg);
            sb.append("":"");
            sb.append(type);
            sb.append(""/"");
            sb.append(entry);
        }
        Log.i(TAG, sb.toString());
    }
    int scrollX = node.getScrollX();
    int scrollY = node.getScrollY();
    if (scrollX != 0 || scrollY != 0) {
        Log.i(TAG, prefix + ""  Scroll: "" + scrollX + "","" + scrollY);
    }
    Matrix matrix = node.getTransformation();
    if (matrix != null) {
        Log.i(TAG, prefix + ""  Transformation: "" + matrix);
    }
    float elevation = node.getElevation();
    if (elevation != 0) {
        Log.i(TAG, prefix + ""  Elevation: "" + elevation);
    }
    float alpha = node.getAlpha();
    if (alpha != 0) {
        Log.i(TAG, prefix + ""  Alpha: "" + elevation);
    }
    CharSequence contentDescription = node.getContentDescription();
    if (contentDescription != null) {
        Log.i(TAG, prefix + ""  Content description: "" + contentDescription);
    }
    CharSequence text = node.getText();
    if (text != null) {
        final String safeText = node.isSanitized() || showSensitive ? text.toString() : ""REDACTED["" + text.length() + "" chars]"";
        Log.i(TAG, prefix + ""  Text (sel "" + node.getTextSelectionStart() + ""-"" + node.getTextSelectionEnd() + ""): "" + safeText);
        Log.i(TAG, prefix + ""  Text size: "" + node.getTextSize() + "" , style: #"" + node.getTextStyle());
        Log.i(TAG, prefix + ""  Text color fg: #"" + Integer.toHexString(node.getTextColor()) + "", bg: #"" + Integer.toHexString(node.getTextBackgroundColor()));
        Log.i(TAG, prefix + ""  Input type: "" + node.getInputType());
    }
    String webDomain = node.getWebDomain();
    if (webDomain != null) {
        Log.i(TAG, prefix + ""  Web domain: "" + webDomain);
    }
    HtmlInfo htmlInfo = node.getHtmlInfo();
    if (htmlInfo != null) {
        Log.i(TAG, prefix + ""  HtmlInfo: tag="" + htmlInfo.getTag() + "", attr="" + htmlInfo.getAttributes());
    }
    LocaleList localeList = node.getLocaleList();
    if (localeList != null) {
        Log.i(TAG, prefix + ""  LocaleList: "" + localeList);
    }
    String hint = node.getHint();
    if (hint != null) {
        Log.i(TAG, prefix + ""  Hint: "" + hint);
    }
    Bundle extras = node.getExtras();
    if (extras != null) {
        Log.i(TAG, prefix + ""  Extras: "" + extras);
    }
    if (node.isAssistBlocked()) {
        Log.i(TAG, prefix + ""  BLOCKED"");
    }
    AutofillId autofillId = node.getAutofillId();
    if (autofillId == null) {
        Log.i(TAG, prefix + "" NO autofill ID"");
    } else {
        Log.i(TAG, prefix + ""Autofill info: id= "" + autofillId + "", type="" + node.getAutofillType() + "", options="" + Arrays.toString(node.getAutofillOptions()) + "", hints="" + Arrays.toString(node.getAutofillHints()) + "", value="" + node.getAutofillValue() + "", sanitized="" + node.isSanitized());
    }
    final int NCHILDREN = node.getChildCount();
    if (NCHILDREN > 0) {
        Log.i(TAG, prefix + ""  Children:"");
        String cprefix = prefix + ""    "";
        for (int i = 0; i < NCHILDREN; i++) {
            ViewNode cnode = node.getChildAt(i);
            dump(cprefix, cnode, showSensitive);
        }
    }
}","{
    Log.i(TAG, prefix + ""View ["" + node.getLeft() + "","" + node.getTop() + "" "" + node.getWidth() + ""x"" + node.getHeight() + ""]"" + "" "" + node.getClassName());
    int id = node.getId();
    if (id != 0) {
        StringBuilder sb = new StringBuilder();
        sb.append(prefix);
        sb.append(""  ID: #"");
        sb.append(Integer.toHexString(id));
        String entry = node.getIdEntry();
        if (entry != null) {
            String type = node.getIdType();
            String pkg = node.getIdPackage();
            sb.append("" "");
            sb.append(pkg);
            sb.append("":"");
            sb.append(type);
            sb.append(""/"");
            sb.append(entry);
        }
        Log.i(TAG, sb.toString());
    }
    int scrollX = node.getScrollX();
    int scrollY = node.getScrollY();
    if (scrollX != 0 || scrollY != 0) {
        Log.i(TAG, prefix + ""  Scroll: "" + scrollX + "","" + scrollY);
    }
    Matrix matrix = node.getTransformation();
    if (matrix != null) {
        Log.i(TAG, prefix + ""  Transformation: "" + matrix);
    }
    float elevation = node.getElevation();
    if (elevation != 0) {
        Log.i(TAG, prefix + ""  Elevation: "" + elevation);
    }
    float alpha = node.getAlpha();
    if (alpha != 0) {
        Log.i(TAG, prefix + ""  Alpha: "" + elevation);
    }
    CharSequence contentDescription = node.getContentDescription();
    if (contentDescription != null) {
        Log.i(TAG, prefix + ""  Content description: "" + contentDescription);
    }
    CharSequence text = node.getText();
    if (text != null) {
        final String safeText = node.isSanitized() || showSensitive ? text.toString() : ""REDACTED["" + text.length() + "" chars]"";
        Log.i(TAG, prefix + ""  Text (sel "" + node.getTextSelectionStart() + ""-"" + node.getTextSelectionEnd() + ""): "" + safeText);
        Log.i(TAG, prefix + ""  Text size: "" + node.getTextSize() + "" , style: #"" + node.getTextStyle());
        Log.i(TAG, prefix + ""  Text color fg: #"" + Integer.toHexString(node.getTextColor()) + "", bg: #"" + Integer.toHexString(node.getTextBackgroundColor()));
        Log.i(TAG, prefix + ""  Input type: "" + node.getInputType());
        Log.i(TAG, prefix + ""  Resource id: "" + node.getTextIdEntry());
    }
    String webDomain = node.getWebDomain();
    if (webDomain != null) {
        Log.i(TAG, prefix + ""  Web domain: "" + webDomain);
    }
    HtmlInfo htmlInfo = node.getHtmlInfo();
    if (htmlInfo != null) {
        Log.i(TAG, prefix + ""  HtmlInfo: tag="" + htmlInfo.getTag() + "", attr="" + htmlInfo.getAttributes());
    }
    LocaleList localeList = node.getLocaleList();
    if (localeList != null) {
        Log.i(TAG, prefix + ""  LocaleList: "" + localeList);
    }
    String hint = node.getHint();
    if (hint != null) {
        Log.i(TAG, prefix + ""  Hint: "" + hint);
    }
    Bundle extras = node.getExtras();
    if (extras != null) {
        Log.i(TAG, prefix + ""  Extras: "" + extras);
    }
    if (node.isAssistBlocked()) {
        Log.i(TAG, prefix + ""  BLOCKED"");
    }
    AutofillId autofillId = node.getAutofillId();
    if (autofillId == null) {
        Log.i(TAG, prefix + "" NO autofill ID"");
    } else {
        Log.i(TAG, prefix + ""Autofill info: id= "" + autofillId + "", type="" + node.getAutofillType() + "", options="" + Arrays.toString(node.getAutofillOptions()) + "", hints="" + Arrays.toString(node.getAutofillHints()) + "", value="" + node.getAutofillValue() + "", sanitized="" + node.isSanitized() + "", importantFor="" + node.getImportantForAutofill());
    }
    final int NCHILDREN = node.getChildCount();
    if (NCHILDREN > 0) {
        Log.i(TAG, prefix + ""  Children:"");
        String cprefix = prefix + ""    "";
        for (int i = 0; i < NCHILDREN; i++) {
            ViewNode cnode = node.getChildAt(i);
            dump(cprefix, cnode, showSensitive);
        }
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,,,,
418,<android.widget.Editor.HandleView: boolean onTouchEvent(MotionEvent)>,27,28,<android.widget.Editor.HandleView: boolean onTouchEvent(MotionEvent)>,<android.widget.Editor.HandleView: boolean onTouchEvent(MotionEvent)>,0,"{
    updateFloatingToolbarVisibility(ev);
    switch(ev.getActionMasked()) {
        case MotionEvent.ACTION_DOWN:
            {
                startTouchUpFilter(getCurrentCursorOffset());
                final PositionListener positionListener = getPositionListener();
                mLastParentX = positionListener.getPositionX();
                mLastParentY = positionListener.getPositionY();
                mLastParentXOnScreen = positionListener.getPositionXOnScreen();
                mLastParentYOnScreen = positionListener.getPositionYOnScreen();
                final float xInWindow = ev.getRawX() - mLastParentXOnScreen + mLastParentX;
                final float yInWindow = ev.getRawY() - mLastParentYOnScreen + mLastParentY;
                mTouchToWindowOffsetX = xInWindow - mPositionX;
                mTouchToWindowOffsetY = yInWindow - mPositionY;
                mIsDragging = true;
                mPreviousLineTouched = UNSET_LINE;
                break;
            }
        case MotionEvent.ACTION_MOVE:
            {
                final float xInWindow = ev.getRawX() - mLastParentXOnScreen + mLastParentX;
                final float yInWindow = ev.getRawY() - mLastParentYOnScreen + mLastParentY;
                // Vertical hysteresis: vertical down movement tends to snap to ideal offset
                final float previousVerticalOffset = mTouchToWindowOffsetY - mLastParentY;
                final float currentVerticalOffset = yInWindow - mPositionY - mLastParentY;
                float newVerticalOffset;
                if (previousVerticalOffset < mIdealVerticalOffset) {
                    newVerticalOffset = Math.min(currentVerticalOffset, mIdealVerticalOffset);
                    newVerticalOffset = Math.max(newVerticalOffset, previousVerticalOffset);
                } else {
                    newVerticalOffset = Math.max(currentVerticalOffset, mIdealVerticalOffset);
                    newVerticalOffset = Math.min(newVerticalOffset, previousVerticalOffset);
                }
                mTouchToWindowOffsetY = newVerticalOffset + mLastParentY;
                final float newPosX = xInWindow - mTouchToWindowOffsetX + mHotspotX + getHorizontalOffset();
                final float newPosY = yInWindow - mTouchToWindowOffsetY + mTouchOffsetY;
                updatePosition(newPosX, newPosY, ev.isFromSource(InputDevice.SOURCE_TOUCHSCREEN));
                break;
            }
        case MotionEvent.ACTION_UP:
            filterOnTouchUp(ev.isFromSource(InputDevice.SOURCE_TOUCHSCREEN));
            mIsDragging = false;
            updateDrawable();
            break;
        case MotionEvent.ACTION_CANCEL:
            mIsDragging = false;
            updateDrawable();
            break;
    }
    return true;
}","{
    updateFloatingToolbarVisibility(ev);
    switch(ev.getActionMasked()) {
        case MotionEvent.ACTION_DOWN:
            {
                startTouchUpFilter(getCurrentCursorOffset());
                final PositionListener positionListener = getPositionListener();
                mLastParentX = positionListener.getPositionX();
                mLastParentY = positionListener.getPositionY();
                mLastParentXOnScreen = positionListener.getPositionXOnScreen();
                mLastParentYOnScreen = positionListener.getPositionYOnScreen();
                final float xInWindow = ev.getRawX() - mLastParentXOnScreen + mLastParentX;
                final float yInWindow = ev.getRawY() - mLastParentYOnScreen + mLastParentY;
                mTouchToWindowOffsetX = xInWindow - mPositionX;
                mTouchToWindowOffsetY = yInWindow - mPositionY;
                mIsDragging = true;
                mPreviousLineTouched = UNSET_LINE;
                break;
            }
        case MotionEvent.ACTION_MOVE:
            {
                final float xInWindow = ev.getRawX() - mLastParentXOnScreen + mLastParentX;
                final float yInWindow = ev.getRawY() - mLastParentYOnScreen + mLastParentY;
                // Vertical hysteresis: vertical down movement tends to snap to ideal offset
                final float previousVerticalOffset = mTouchToWindowOffsetY - mLastParentY;
                final float currentVerticalOffset = yInWindow - mPositionY - mLastParentY;
                float newVerticalOffset;
                if (previousVerticalOffset < mIdealVerticalOffset) {
                    newVerticalOffset = Math.min(currentVerticalOffset, mIdealVerticalOffset);
                    newVerticalOffset = Math.max(newVerticalOffset, previousVerticalOffset);
                } else {
                    newVerticalOffset = Math.max(currentVerticalOffset, mIdealVerticalOffset);
                    newVerticalOffset = Math.min(newVerticalOffset, previousVerticalOffset);
                }
                mTouchToWindowOffsetY = newVerticalOffset + mLastParentY;
                final float newPosX = xInWindow - mTouchToWindowOffsetX + mHotspotX + getHorizontalOffset();
                final float newPosY = yInWindow - mTouchToWindowOffsetY + mTouchOffsetY;
                updatePosition(newPosX, newPosY, ev.isFromSource(InputDevice.SOURCE_TOUCHSCREEN));
                break;
            }
        case MotionEvent.ACTION_UP:
            filterOnTouchUp(ev.isFromSource(InputDevice.SOURCE_TOUCHSCREEN));
        // Fall through.
        case MotionEvent.ACTION_CANCEL:
            mIsDragging = false;
            updateDrawable();
            break;
    }
    return true;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,,,,
419,<android.preference.SeekBarVolumizer.Receiver: void setListening(boolean)>,27,28,<android.preference.SeekBarVolumizer.Receiver: void setListening(boolean)>,<android.preference.SeekBarVolumizer.Receiver: void setListening(boolean)>,0,"{
    if (mListening == listening)
        return;
    mListening = listening;
    if (listening) {
        final IntentFilter filter = new IntentFilter(AudioManager.VOLUME_CHANGED_ACTION);
        filter.addAction(AudioManager.INTERNAL_RINGER_MODE_CHANGED_ACTION);
        filter.addAction(NotificationManager.ACTION_INTERRUPTION_FILTER_CHANGED);
        filter.addAction(AudioManager.STREAM_DEVICES_CHANGED_ACTION);
        mContext.registerReceiver(this, filter);
    } else {
        mContext.unregisterReceiver(this);
    }
}","{
    if (mListening == listening)
        return;
    mListening = listening;
    if (listening) {
        final IntentFilter filter = new IntentFilter(AudioManager.VOLUME_CHANGED_ACTION);
        filter.addAction(AudioManager.INTERNAL_RINGER_MODE_CHANGED_ACTION);
        filter.addAction(NotificationManager.ACTION_INTERRUPTION_FILTER_CHANGED);
        filter.addAction(NotificationManager.ACTION_NOTIFICATION_POLICY_CHANGED);
        filter.addAction(AudioManager.STREAM_DEVICES_CHANGED_ACTION);
        mContext.registerReceiver(this, filter);
    } else {
        mContext.unregisterReceiver(this);
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,4,0,"A new action (NotificationManager.ACTION_NOTIFICATION_POLICY_CHANGED) is added to the IntentFilter. This change is classified as 4, Other statement changed.","This modification will not cause the method to return a different value nor to throw a different exception, thus no Compatibility Issue should arise. The type is 0, No Compatibility Issue."
420,<android.text.SpannableStringBuilder: void removeSpan(Object)>,27,28,<android.text.SpannableStringBuilder: void removeSpan(Object)>,<android.text.SpannableStringBuilder: void removeSpan(Object)>,0,"{
    if (mIndexOfSpan == null)
        return;
    Integer i = mIndexOfSpan.remove(what);
    if (i != null) {
        removeSpan(i.intValue());
    }
}","{
    removeSpan(what, 0);
}",1,"/**
 * Remove the specified markup object from the buffer.
 */
","/**
 * Remove the specified markup object from the buffer.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"The method implementation has changed from a block checking a map and conditionally calling another removeSpan method internally, to simply calling another `removeSpan` method with a different signature (`removeSpan(Object, int)`), so the code change type is 4 and 5.","Even though the method signature has changed to call a different `removeSpan` method, the external behavior observed by the caller of `removeSpan(Object)` should remain the same, assuming the new `removeSpan(Object, int)` method is an overloaded version that eventually results in the same action (i.e., removing the span). There is no direct evidence of a return value change or a different exception being thrown from the given information, so we would consider no compatibility issue."
421,<android.bluetooth.BluetoothAdapter: boolean isLePeriodicAdvertisingSupported()>,27,28,<android.bluetooth.BluetoothAdapter: boolean isLePeriodicAdvertisingSupported()>,<android.bluetooth.BluetoothAdapter: boolean isLePeriodicAdvertisingSupported()>,0,"{
    if (!getLeAccess())
        return false;
    try {
        mServiceLock.readLock().lock();
        if (mService != null)
            return mService.isLePeriodicAdvertisingSupported();
    } catch (RemoteException e) {
        Log.e(TAG, ""failed to get isLePeriodicAdvertisingSupported, error: "", e);
    } finally {
        mServiceLock.readLock().unlock();
    }
    return false;
}","{
    if (!getLeAccess()) {
        return false;
    }
    try {
        mServiceLock.readLock().lock();
        if (mService != null) {
            return mService.isLePeriodicAdvertisingSupported();
        }
    } catch (RemoteException e) {
        Log.e(TAG, ""failed to get isLePeriodicAdvertisingSupported, error: "", e);
    } finally {
        mServiceLock.readLock().unlock();
    }
    return false;
}",1,"/**
 * Return true if LE Periodic Advertising feature is supported.
 *
 * @return true if chipset supports LE Periodic Advertising feature
 */
","/**
 * Return true if LE Periodic Advertising feature is supported.
 *
 * @return true if chipset supports LE Periodic Advertising feature
 */
",-1,,,-1,-1,-1,-1,-1,-1,0,0,"The code change is only related to formatting (adding brackets for the if statement), with no change to behavior, statements, or control flow.","Since there are no functional changes to the API's implementation, no Compatibility Issues could arise."
422,<android.app.Notification.StandardTemplateParams: StandardTemplateParams reset()>,27,28,<android.app.Notification.StandardTemplateParams: StandardTemplateParams reset()>,<android.app.Notification.StandardTemplateParams: StandardTemplateParams reset()>,0,"{
    hasProgress = true;
    ambient = false;
    title = null;
    text = null;
    return this;
}","{
    hasProgress = true;
    ambient = false;
    title = null;
    text = null;
    headerTextSecondary = null;
    maxRemoteInputHistory = Style.MAX_REMOTE_INPUT_HISTORY_LINES;
    return this;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,4,0,"New assignments to the fields `headerTextSecondary` and `maxRemoteInputHistory` have been introduced in the method body. This is an additional initialization of member variables but does not affect the method's return type or control flow, hence the code change type is 4.","No Compatibility Issue because the method returns the same type (`this`), and the change does not affect the method's behavior from the caller's perspective. The reset method is expected to reset all fields within the object; additional fields being reset does not constitute a change in the method's contract or expected behavior."
423,<android.view.textclassifier.TextClassification.Builder: Builder setLabel(String)>,27,28,<android.view.textclassifier.TextClassification.Builder: Builder setLabel(String)>,<android.view.textclassifier.TextClassification.Builder: Builder setLabel(String)>,0,"{
    mLabel = label;
    return this;
}","{
    mLegacyLabel = label;
    return this;
}",1,"/**
 * Sets a label that may be rendered on a widget used to act on the classified text.
 */
","/**
 * Sets the label for the <i>primary</i> action that may be rendered on a widget used to
 * act on the classified text.
 *
 * <p><strong>NOTE: </strong>This field is not parcelled. If read from a parcel, the
 * returned label represents the label of the first {@link RemoteAction} (if one exists).
 *
 * @deprecated Use {@link #addAction(RemoteAction)} instead.
 */
",-1,,"[@Deprecated, @NonNull]",-1,-1,-1,-1,-1,-1,4,0,"The field that the label is assigned to has changed from mLabel to mLegacyLabel, so the code change type is 4.","Even though the field in which the label is stored has been changed, this does not affect the method's return type or the value - it still returns the same 'this' reference of the Builder object. Since the change does not alter the behavior visible to the user of the API, there is no Compatibility Issue."
425,<android.bluetooth.BluetoothA2dp: boolean doBind()>,27,28,<android.bluetooth.BluetoothA2dp: boolean doBind()>,<android.bluetooth.BluetoothA2dp: boolean doBind()>,0,"{
    Intent intent = new Intent(IBluetoothA2dp.class.getName());
    ComponentName comp = intent.resolveSystemService(mContext.getPackageManager(), 0);
    intent.setComponent(comp);
    if (comp == null || !mContext.bindServiceAsUser(intent, mConnection, 0, android.os.Process.myUserHandle())) {
        Log.e(TAG, ""Could not bind to Bluetooth A2DP Service with "" + intent);
        return false;
    }
    return true;
}","{
    Intent intent = new Intent(IBluetoothA2dp.class.getName());
    ComponentName comp = intent.resolveSystemService(mContext.getPackageManager(), 0);
    intent.setComponent(comp);
    if (comp == null || !mContext.bindServiceAsUser(intent, mConnection, 0, mContext.getUser())) {
        Log.e(TAG, ""Could not bind to Bluetooth A2DP Service with "" + intent);
        return false;
    }
    return true;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,5,0,"The code change occurred in the method call 'mContext.bindServiceAsUser' where the argument 'android.os.Process.myUserHandle()' is replaced by 'mContext.getUser()'. Therefore, there's a change in the dependent API, and the code change type is 5.","Although there is a change in the dependent API, the behavior and contract of this method 'doBind' are expected to remain the same (i.e., attempting to bind to the service and returning true on success and false on failure). This change is internal and does not affect the returned value or the type of exception that may be thrown. Hence, there's no compatibility issue, and the pred_CI is 0."
427,<android.hardware.camera2.impl.CameraConstrainedHighSpeedCaptureSessionImpl: List<CaptureRequest> createHighSpeedRequestList(CaptureRequest)>,27,28,<android.hardware.camera2.impl.CameraConstrainedHighSpeedCaptureSessionImpl: List<CaptureRequest> createHighSpeedRequestList(CaptureRequest)>,<android.hardware.camera2.impl.CameraConstrainedHighSpeedCaptureSessionImpl: List<CaptureRequest> createHighSpeedRequestList(CaptureRequest)>,0,"{
    if (request == null) {
        throw new IllegalArgumentException(""Input capture request must not be null"");
    }
    Collection<Surface> outputSurfaces = request.getTargets();
    Range<Integer> fpsRange = request.get(CaptureRequest.CONTROL_AE_TARGET_FPS_RANGE);
    StreamConfigurationMap config = mCharacteristics.get(CameraCharacteristics.SCALER_STREAM_CONFIGURATION_MAP);
    SurfaceUtils.checkConstrainedHighSpeedSurfaces(outputSurfaces, fpsRange, config);
    // Request list size: to limit the preview to 30fps, need use maxFps/30; to maximize
    // the preview frame rate, should use maxBatch size for that high speed stream
    // configuration. We choose the former for now.
    int requestListSize = fpsRange.getUpper() / 30;
    List<CaptureRequest> requestList = new ArrayList<CaptureRequest>();
    // Prepare the Request builders: need carry over the request controls.
    // First, create a request builder that will only include preview or recording target.
    CameraMetadataNative requestMetadata = new CameraMetadataNative(request.getNativeCopy());
    // Note that after this step, the requestMetadata is mutated (swapped) and can not be used
    // for next request builder creation.
    CaptureRequest.Builder singleTargetRequestBuilder = new CaptureRequest.Builder(requestMetadata, /*reprocess*/
    false, CameraCaptureSession.SESSION_ID_NONE);
    // Carry over userTag, as native metadata doesn't have this field.
    singleTargetRequestBuilder.setTag(request.getTag());
    // Overwrite the capture intent to make sure a good value is set.
    Iterator<Surface> iterator = outputSurfaces.iterator();
    Surface firstSurface = iterator.next();
    Surface secondSurface = null;
    if (outputSurfaces.size() == 1 && SurfaceUtils.isSurfaceForHwVideoEncoder(firstSurface)) {
        singleTargetRequestBuilder.set(CaptureRequest.CONTROL_CAPTURE_INTENT, CaptureRequest.CONTROL_CAPTURE_INTENT_PREVIEW);
    } else {
        // Video only, or preview + video
        singleTargetRequestBuilder.set(CaptureRequest.CONTROL_CAPTURE_INTENT, CaptureRequest.CONTROL_CAPTURE_INTENT_VIDEO_RECORD);
    }
    singleTargetRequestBuilder.setPartOfCHSRequestList(/*partOfCHSList*/
    true);
    // Second, Create a request builder that will include both preview and recording targets.
    CaptureRequest.Builder doubleTargetRequestBuilder = null;
    if (outputSurfaces.size() == 2) {
        // Have to create a new copy, the original one was mutated after a new
        // CaptureRequest.Builder creation.
        requestMetadata = new CameraMetadataNative(request.getNativeCopy());
        doubleTargetRequestBuilder = new CaptureRequest.Builder(requestMetadata, /*reprocess*/
        false, CameraCaptureSession.SESSION_ID_NONE);
        doubleTargetRequestBuilder.setTag(request.getTag());
        doubleTargetRequestBuilder.set(CaptureRequest.CONTROL_CAPTURE_INTENT, CaptureRequest.CONTROL_CAPTURE_INTENT_VIDEO_RECORD);
        doubleTargetRequestBuilder.addTarget(firstSurface);
        secondSurface = iterator.next();
        doubleTargetRequestBuilder.addTarget(secondSurface);
        doubleTargetRequestBuilder.setPartOfCHSRequestList(/*partOfCHSList*/
        true);
        // Make sure singleTargetRequestBuilder contains only recording surface for
        // preview + recording case.
        Surface recordingSurface = firstSurface;
        if (!SurfaceUtils.isSurfaceForHwVideoEncoder(recordingSurface)) {
            recordingSurface = secondSurface;
        }
        singleTargetRequestBuilder.addTarget(recordingSurface);
    } else {
        // Single output case: either recording or preview.
        singleTargetRequestBuilder.addTarget(firstSurface);
    }
    // Generate the final request list.
    for (int i = 0; i < requestListSize; i++) {
        if (i == 0 && doubleTargetRequestBuilder != null) {
            // First request should be recording + preview request
            requestList.add(doubleTargetRequestBuilder.build());
        } else {
            requestList.add(singleTargetRequestBuilder.build());
        }
    }
    return Collections.unmodifiableList(requestList);
}","{
    if (request == null) {
        throw new IllegalArgumentException(""Input capture request must not be null"");
    }
    Collection<Surface> outputSurfaces = request.getTargets();
    Range<Integer> fpsRange = request.get(CaptureRequest.CONTROL_AE_TARGET_FPS_RANGE);
    StreamConfigurationMap config = mCharacteristics.get(CameraCharacteristics.SCALER_STREAM_CONFIGURATION_MAP);
    SurfaceUtils.checkConstrainedHighSpeedSurfaces(outputSurfaces, fpsRange, config);
    // Request list size: to limit the preview to 30fps, need use maxFps/30; to maximize
    // the preview frame rate, should use maxBatch size for that high speed stream
    // configuration. We choose the former for now.
    int requestListSize = fpsRange.getUpper() / 30;
    List<CaptureRequest> requestList = new ArrayList<CaptureRequest>();
    // Prepare the Request builders: need carry over the request controls.
    // First, create a request builder that will only include preview or recording target.
    CameraMetadataNative requestMetadata = new CameraMetadataNative(request.getNativeCopy());
    // Note that after this step, the requestMetadata is mutated (swapped) and can not be used
    // for next request builder creation.
    CaptureRequest.Builder singleTargetRequestBuilder = new CaptureRequest.Builder(requestMetadata, /*reprocess*/
    false, CameraCaptureSession.SESSION_ID_NONE, request.getLogicalCameraId(), /*physicalCameraIdSet*/
    null);
    // Carry over userTag, as native metadata doesn't have this field.
    singleTargetRequestBuilder.setTag(request.getTag());
    // Overwrite the capture intent to make sure a good value is set.
    Iterator<Surface> iterator = outputSurfaces.iterator();
    Surface firstSurface = iterator.next();
    Surface secondSurface = null;
    if (outputSurfaces.size() == 1 && SurfaceUtils.isSurfaceForHwVideoEncoder(firstSurface)) {
        singleTargetRequestBuilder.set(CaptureRequest.CONTROL_CAPTURE_INTENT, CaptureRequest.CONTROL_CAPTURE_INTENT_PREVIEW);
    } else {
        // Video only, or preview + video
        singleTargetRequestBuilder.set(CaptureRequest.CONTROL_CAPTURE_INTENT, CaptureRequest.CONTROL_CAPTURE_INTENT_VIDEO_RECORD);
    }
    singleTargetRequestBuilder.setPartOfCHSRequestList(/*partOfCHSList*/
    true);
    // Second, Create a request builder that will include both preview and recording targets.
    CaptureRequest.Builder doubleTargetRequestBuilder = null;
    if (outputSurfaces.size() == 2) {
        // Have to create a new copy, the original one was mutated after a new
        // CaptureRequest.Builder creation.
        requestMetadata = new CameraMetadataNative(request.getNativeCopy());
        doubleTargetRequestBuilder = new CaptureRequest.Builder(requestMetadata, /*reprocess*/
        false, CameraCaptureSession.SESSION_ID_NONE, request.getLogicalCameraId(), /*physicalCameraIdSet*/
        null);
        doubleTargetRequestBuilder.setTag(request.getTag());
        doubleTargetRequestBuilder.set(CaptureRequest.CONTROL_CAPTURE_INTENT, CaptureRequest.CONTROL_CAPTURE_INTENT_VIDEO_RECORD);
        doubleTargetRequestBuilder.addTarget(firstSurface);
        secondSurface = iterator.next();
        doubleTargetRequestBuilder.addTarget(secondSurface);
        doubleTargetRequestBuilder.setPartOfCHSRequestList(/*partOfCHSList*/
        true);
        // Make sure singleTargetRequestBuilder contains only recording surface for
        // preview + recording case.
        Surface recordingSurface = firstSurface;
        if (!SurfaceUtils.isSurfaceForHwVideoEncoder(recordingSurface)) {
            recordingSurface = secondSurface;
        }
        singleTargetRequestBuilder.addTarget(recordingSurface);
    } else {
        // Single output case: either recording or preview.
        singleTargetRequestBuilder.addTarget(firstSurface);
    }
    // Generate the final request list.
    for (int i = 0; i < requestListSize; i++) {
        if (i == 0 && doubleTargetRequestBuilder != null) {
            // First request should be recording + preview request
            requestList.add(doubleTargetRequestBuilder.build());
        } else {
            requestList.add(singleTargetRequestBuilder.build());
        }
    }
    return Collections.unmodifiableList(requestList);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,,,,
428,"<android.content.res.AssetManager: CharSequence getResourceBagText(int,int)>",27,28,"<android.content.res.AssetManager: CharSequence getResourceBagText(int,int)>","<android.content.res.AssetManager: CharSequence getResourceBagText(int,int)>",0,"{
    synchronized (this) {
        final TypedValue outValue = mValue;
        final int block = loadResourceBagValue(resId, bagEntryId, outValue, true);
        if (block < 0) {
            return null;
        }
        // Convert the changing configurations flags populated by native code.
        outValue.changingConfigurations = ActivityInfo.activityInfoConfigNativeToJava(outValue.changingConfigurations);
        if (outValue.type == TypedValue.TYPE_STRING) {
            return mStringBlocks[block].get(outValue.data);
        }
        return outValue.coerceToString();
    }
}","{
    synchronized (this) {
        ensureValidLocked();
        final TypedValue outValue = mValue;
        final int cookie = nativeGetResourceBagValue(mObject, resId, bagEntryId, outValue);
        if (cookie <= 0) {
            return null;
        }
        // Convert the changing configurations flags populated by native code.
        outValue.changingConfigurations = ActivityInfo.activityInfoConfigNativeToJava(outValue.changingConfigurations);
        if (outValue.type == TypedValue.TYPE_STRING) {
            return mApkAssets[cookie - 1].getStringFromPool(outValue.data);
        }
        return outValue.coerceToString();
    }
}",1,"/**
 * Retrieves the string value associated with a particular resource
 * identifier for the current configuration.
 *
 * @param resId the resource identifier to load
 * @param bagEntryId
 * @return the string value, or {@code null}
 */
","/**
 * Retrieves the string value associated with a particular resource
 * identifier for the current configuration.
 *
 * @param resId the resource identifier to load
 * @param bagEntryId the index into the bag to load
 * @return the string value, or {@code null}
 */
",-1,[@Nullable],[@Nullable],-1,-1,-1,-1,-1,-1,"4,5",0,"The implementation now uses a different native method (nativeGetResourceBagValue instead of loadResourceBagValue) and a different way to access resources (mApkAssets[cookie - 1].getStringFromPool instead of mStringBlocks[block].get). Given these alterations, 'Other statement changed' and 'Dependent API changed' apply, which corresponds to change types 4 and 5.","Despite the change in implementation, there's no indication of behavior change regarding the return value or exception handling. The mechanism for fetching and returning the value has changed internally, but it doesn't necessarily lead to a different return value or a different exception handling, as long as the new native method and resource accessing method are contractually the same. Therefore, there is no Compatibility Issue detected, indicated by pred_CI code 0."
429,<android.os.StrictMode.VmPolicy.Builder: VmPolicy build()>,27,28,<android.os.StrictMode.VmPolicy.Builder: VmPolicy build()>,<android.os.StrictMode.VmPolicy.Builder: VmPolicy build()>,0,"{
    // set, enable simple logging.
    if (mMask != 0 && (mMask & (PENALTY_DEATH | PENALTY_LOG | PENALTY_DROPBOX | PENALTY_DIALOG)) == 0) {
        penaltyLog();
    }
    return new VmPolicy(mMask, mClassInstanceLimit != null ? mClassInstanceLimit : EMPTY_CLASS_LIMIT_MAP);
}","{
    // set, enable simple logging.
    if (mListener == null && mMask != 0 && (mMask & (PENALTY_DEATH | PENALTY_LOG | PENALTY_DROPBOX | PENALTY_DIALOG)) == 0) {
        penaltyLog();
    }
    return new VmPolicy(mMask, mClassInstanceLimit != null ? mClassInstanceLimit : EMPTY_CLASS_LIMIT_MAP, mListener, mExecutor);
}",1,"/**
 * Construct the VmPolicy instance.
 *
 * <p>Note: if no penalties are enabled before calling
 * <code>build</code>, {@link #penaltyLog} is implicitly
 * set.
 */
","/**
 * Construct the VmPolicy instance.
 *
 * <p>Note: if no penalties are enabled before calling <code>build</code>, {@link
 * #penaltyLog} is implicitly set.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4,5",1,"The control dependency and the return statement have changed. In the late implementation, there's an additional condition checking for mListener and the construction of the VmPolicy object includes more parameters (mListener and mExecutor). This not only affects the flow of the control dependency but also means the object returned now includes two more configuration items that were not part of the early version. Therefore, the change types are 3,4,5.","These modifications could cause the method to return a VmPolicy instance with different characteristics than before, specifically due to additional configuration parameters involved in its construction. This constitutes a potential difference in the return value. Therefore, the CI type is 1."
430,<android.view.TouchDelegate: boolean onTouchEvent(MotionEvent)>,27,28,<android.view.TouchDelegate: boolean onTouchEvent(MotionEvent)>,<android.view.TouchDelegate: boolean onTouchEvent(MotionEvent)>,0,"{
    int x = (int) event.getX();
    int y = (int) event.getY();
    boolean sendToDelegate = false;
    boolean hit = true;
    boolean handled = false;
    switch(event.getAction()) {
        case MotionEvent.ACTION_DOWN:
            Rect bounds = mBounds;
            if (bounds.contains(x, y)) {
                mDelegateTargeted = true;
                sendToDelegate = true;
            }
            break;
        case MotionEvent.ACTION_UP:
        case MotionEvent.ACTION_MOVE:
            sendToDelegate = mDelegateTargeted;
            if (sendToDelegate) {
                Rect slopBounds = mSlopBounds;
                if (!slopBounds.contains(x, y)) {
                    hit = false;
                }
            }
            break;
        case MotionEvent.ACTION_CANCEL:
            sendToDelegate = mDelegateTargeted;
            mDelegateTargeted = false;
            break;
    }
    if (sendToDelegate) {
        final View delegateView = mDelegateView;
        if (hit) {
            // Offset event coordinates to be inside the target view
            event.setLocation(delegateView.getWidth() / 2, delegateView.getHeight() / 2);
        } else {
            // Offset event coordinates to be outside the target view (in case it does
            // something like tracking pressed state)
            int slop = mSlop;
            event.setLocation(-(slop * 2), -(slop * 2));
        }
        handled = delegateView.dispatchTouchEvent(event);
    }
    return handled;
}","{
    int x = (int) event.getX();
    int y = (int) event.getY();
    boolean sendToDelegate = false;
    boolean hit = true;
    boolean handled = false;
    switch(event.getActionMasked()) {
        case MotionEvent.ACTION_DOWN:
            mDelegateTargeted = mBounds.contains(x, y);
            sendToDelegate = mDelegateTargeted;
            break;
        case MotionEvent.ACTION_POINTER_DOWN:
        case MotionEvent.ACTION_POINTER_UP:
        case MotionEvent.ACTION_UP:
        case MotionEvent.ACTION_MOVE:
            sendToDelegate = mDelegateTargeted;
            if (sendToDelegate) {
                Rect slopBounds = mSlopBounds;
                if (!slopBounds.contains(x, y)) {
                    hit = false;
                }
            }
            break;
        case MotionEvent.ACTION_CANCEL:
            sendToDelegate = mDelegateTargeted;
            mDelegateTargeted = false;
            break;
    }
    if (sendToDelegate) {
        final View delegateView = mDelegateView;
        if (hit) {
            // Offset event coordinates to be inside the target view
            event.setLocation(delegateView.getWidth() / 2, delegateView.getHeight() / 2);
        } else {
            // Offset event coordinates to be outside the target view (in case it does
            // something like tracking pressed state)
            int slop = mSlop;
            event.setLocation(-(slop * 2), -(slop * 2));
        }
        handled = delegateView.dispatchTouchEvent(event);
    }
    return handled;
}",1,"/**
 * Will forward touch events to the delegate view if the event is within the bounds
 * specified in the constructor.
 *
 * @param event The touch event to forward
 * @return True if the event was forwarded to the delegate, false otherwise.
 */
","/**
 * Will forward touch events to the delegate view if the event is within the bounds
 * specified in the constructor.
 *
 * @param event The touch event to forward
 * @return True if the event was forwarded to the delegate, false otherwise.
 */
",-1,,,-1,-1,-1,-1,-1,-1,3,0,"The change from event.getAction() to event.getActionMasked() and the introduction of case MotionEvent.ACTION_POINTER_DOWN and case MotionEvent.ACTION_POINTER_UP in the switch statement represent a control dependency change, which is type 3.","Despite the control dependency change, there isn't a Compatibility Issue caused by potential different return values or exception handlings as the general logic and the return value remain unchanged. The onTouchEvent method's behavior is still consistent with respect to how it processes touch events and determines whether to send them to the delegate; the addition of handling for ACTION_POINTER_DOWN and ACTION_POINTER_UP within the existing logic does not affect the other cases and should not change the method's return value when used as intended. Therefore, the CI type is 0."
431,<android.content.res.TypedArray: Typeface getFont(int)>,27,28,<android.content.res.TypedArray: Typeface getFont(int)>,<android.content.res.TypedArray: Typeface getFont(int)>,0,"{
    if (mRecycled) {
        throw new RuntimeException(""Cannot make calls to a recycled instance!"");
    }
    final TypedValue value = mValue;
    if (getValueAt(index * AssetManager.STYLE_NUM_ENTRIES, value)) {
        if (value.type == TypedValue.TYPE_ATTRIBUTE) {
            throw new UnsupportedOperationException(""Failed to resolve attribute at index "" + index + "": "" + value);
        }
        return mResources.getFont(value, value.resourceId);
    }
    return null;
}","{
    if (mRecycled) {
        throw new RuntimeException(""Cannot make calls to a recycled instance!"");
    }
    final TypedValue value = mValue;
    if (getValueAt(index * STYLE_NUM_ENTRIES, value)) {
        if (value.type == TypedValue.TYPE_ATTRIBUTE) {
            throw new UnsupportedOperationException(""Failed to resolve attribute at index "" + index + "": "" + value);
        }
        return mResources.getFont(value, value.resourceId);
    }
    return null;
}",1,"/**
 * Retrieve the Typeface for the attribute at <var>index</var>.
 * <p>
 * This method will throw an exception if the attribute is defined but is
 * not a font.
 *
 * @param index Index of attribute to retrieve.
 *
 * @return Typeface for the attribute, or {@code null} if not defined.
 * @throws RuntimeException if the TypedArray has already been recycled.
 * @throws UnsupportedOperationException if the attribute is defined but is
 * not a font resource.
 */
","/**
 * Retrieve the Typeface for the attribute at <var>index</var>.
 * <p>
 * This method will throw an exception if the attribute is defined but is
 * not a font.
 *
 * @param index Index of attribute to retrieve.
 *
 * @return Typeface for the attribute, or {@code null} if not defined.
 * @throws RuntimeException if the TypedArray has already been recycled.
 * @throws UnsupportedOperationException if the attribute is defined but is
 * not a font resource.
 */
",-1,[@Nullable],[@Nullable],-1,-1,-1,-1,-1,-1,0,0,"There is no actual code change between the early and late versions. The only apparent change is the removal of the class name AssetManager from the constant STYLE_NUM_ENTRIES, which does not affect the behavior because it is referring to the same constant.","Since there are no changes in the implementation that affect the API's behavior, there is no compatibility issue. Both versions of the API will have the same behavior and return the same values under the same conditions."
433,<android.os.Environment: boolean isExternalStorageRemovable()>,27,28,<android.os.Environment: boolean isExternalStorageRemovable()>,<android.os.Environment: boolean isExternalStorageRemovable()>,0,"{
    if (isStorageDisabled())
        return false;
    final File externalDir = sCurrentUser.getExternalDirs()[0];
    return isExternalStorageRemovable(externalDir);
}","{
    final File externalDir = sCurrentUser.getExternalDirs()[0];
    return isExternalStorageRemovable(externalDir);
}",1,"/**
 * Returns whether the primary shared/external storage media is physically
 * removable.
 *
 * @return true if the storage device can be removed (such as an SD card),
 * or false if the storage device is built in and cannot be
 * physically removed.
 */
","/**
 * Returns whether the primary shared/external storage media is physically
 * removable.
 *
 * @return true if the storage device can be removed (such as an SD card),
 * or false if the storage device is built in and cannot be
 * physically removed.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3, 4",0,"The control dependency (if statement checking isStorageDisabled()) is removed in the late version, and this is the only change, so the code change types are 3 and 4.","Although a control statement was removed in the late version, this change does not lead to a Compatibility Issue because, without considering the change's background context (which is not provided), there is no apparent modification to the logic that affects the returned value of the API or the exceptions it might throw. The method still checks if external storage is removable based on the first entry in the `externalDirs` array. The removed if statement could have been a redundant or unnecessary check, or its logic could have been moved elsewhere in the supporting code structure. Without additional information suggesting a change in behavior, this modification does not necessarily imply different return values for API consumers, hence the pred_CI is 0."
434,"<android.hardware.camera2.impl.CameraCaptureSessionImpl: int setRepeatingRequest(CaptureRequest,CaptureCallback,Handler)>",27,28,"<android.hardware.camera2.impl.CameraCaptureSessionImpl: int setRepeatingRequest(CaptureRequest,CaptureCallback,Handler)>","<android.hardware.camera2.impl.CameraCaptureSessionImpl: int setRepeatingRequest(CaptureRequest,CaptureCallback,Handler)>",0,"{
    if (request == null) {
        throw new IllegalArgumentException(""request must not be null"");
    } else if (request.isReprocess()) {
        throw new IllegalArgumentException(""repeating reprocess requests are not supported"");
    }
    synchronized (mDeviceImpl.mInterfaceLock) {
        checkNotClosed();
        handler = checkHandler(handler, callback);
        if (DEBUG) {
            Log.v(TAG, mIdString + ""setRepeatingRequest - request "" + request + "", callback "" + callback + "" handler"" + "" "" + handler);
        }
        return addPendingSequence(mDeviceImpl.setRepeatingRequest(request, createCaptureCallbackProxy(handler, callback), mDeviceHandler));
    }
}","{
    checkRepeatingRequest(request);
    synchronized (mDeviceImpl.mInterfaceLock) {
        checkNotClosed();
        handler = checkHandler(handler, callback);
        if (DEBUG) {
            Log.v(TAG, mIdString + ""setRepeatingRequest - request "" + request + "", callback "" + callback + "" handler"" + "" "" + handler);
        }
        return addPendingSequence(mDeviceImpl.setRepeatingRequest(request, createCaptureCallbackProxy(handler, callback), mDeviceExecutor));
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,5",0,"The early implementation contained explicit check conditions, while the late implementation replaces these with a call to checkRepeatingRequest(request), indicating the logic for checking the request has been moved into a new or existing method. Additionally, 'mDeviceHandler' has been replaced with 'mDeviceExecutor', which suggests a change in the execution mechanism used for callback processing. So the code changes fall under the categories of control dependency change (3) and dependent API changed (5).","Despite the changes in the method's implementation, there are no new return statements or exception handling statements introduced. The control flow changes do not affect the return value or the exceptions thrown by the method directly as the logic is refactored into another method that performs the same checks as before (assuming the checkRepeatingRequest method throws compatible exceptions to the previous inline checks). Furthermore, the replacement of 'mDeviceHandler' with 'mDeviceExecutor' suggests an internal change to how callbacks are executed, but this is an implementation detail that should not affect the compatibility from the API user's perspective. Thus, these changes are not likely to lead to a CI, so the CI type is 0."
435,"<android.app.WallpaperManager: int setResource(int,int)>",27,28,"<android.app.WallpaperManager: int setResource(int,int)>","<android.app.WallpaperManager: int setResource(int,int)>",0,"{
    if (sGlobals.mService == null) {
        Log.w(TAG, ""WallpaperService not running"");
        throw new RuntimeException(new DeadSystemException());
    }
    final Bundle result = new Bundle();
    final WallpaperSetCompletion completion = new WallpaperSetCompletion();
    try {
        Resources resources = mContext.getResources();
        /* Set the wallpaper to the default values */
        ParcelFileDescriptor fd = sGlobals.mService.setWallpaper(""res:"" + resources.getResourceName(resid), mContext.getOpPackageName(), null, false, result, which, completion, UserHandle.myUserId());
        if (fd != null) {
            FileOutputStream fos = null;
            boolean ok = false;
            try {
                fos = new ParcelFileDescriptor.AutoCloseOutputStream(fd);
                copyStreamToWallpaperFile(resources.openRawResource(resid), fos);
                // The 'close()' is the trigger for any server-side image manipulation,
                // so we must do that before waiting for completion.
                fos.close();
                completion.waitForCompletion();
            } finally {
                // Might be redundant but completion shouldn't wait unless the write
                // succeeded; this is a fallback if it threw past the close+wait.
                IoUtils.closeQuietly(fos);
            }
        }
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
    return result.getInt(EXTRA_NEW_WALLPAPER_ID, 0);
}","{
    if (sGlobals.mService == null) {
        Log.w(TAG, ""WallpaperService not running"");
        throw new RuntimeException(new DeadSystemException());
    }
    final Bundle result = new Bundle();
    final WallpaperSetCompletion completion = new WallpaperSetCompletion();
    try {
        Resources resources = mContext.getResources();
        /* Set the wallpaper to the default values */
        ParcelFileDescriptor fd = sGlobals.mService.setWallpaper(""res:"" + resources.getResourceName(resid), mContext.getOpPackageName(), null, false, result, which, completion, mContext.getUserId());
        if (fd != null) {
            FileOutputStream fos = null;
            boolean ok = false;
            try {
                fos = new ParcelFileDescriptor.AutoCloseOutputStream(fd);
                copyStreamToWallpaperFile(resources.openRawResource(resid), fos);
                // The 'close()' is the trigger for any server-side image manipulation,
                // so we must do that before waiting for completion.
                fos.close();
                completion.waitForCompletion();
            } finally {
                // Might be redundant but completion shouldn't wait unless the write
                // succeeded; this is a fallback if it threw past the close+wait.
                IoUtils.closeQuietly(fos);
            }
        }
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
    return result.getInt(EXTRA_NEW_WALLPAPER_ID, 0);
}",1,"/**
 * Version of {@link #setResource(int)} that allows the caller to specify which
 * of the supported wallpaper categories to set.
 *
 * @param resid The resource ID of the bitmap to be used as the wallpaper image
 * @param which Flags indicating which wallpaper(s) to configure with the new imagery
 *
 * @see #FLAG_LOCK
 * @see #FLAG_SYSTEM
 *
 * @return An integer ID assigned to the newly active wallpaper; or zero on failure.
 *
 * @throws IOException
 */
","/**
 * Version of {@link #setResource(int)} that allows the caller to specify which
 * of the supported wallpaper categories to set.
 *
 * @param resid The resource ID of the bitmap to be used as the wallpaper image
 * @param which Flags indicating which wallpaper(s) to configure with the new imagery
 *
 * @see #FLAG_LOCK
 * @see #FLAG_SYSTEM
 *
 * @return An integer ID assigned to the newly active wallpaper; or zero on failure.
 *
 * @throws IOException
 */
",-1,[@RequiresPermission(android.Manifest.permission.SET_WALLPAPER)],[@RequiresPermission(android.Manifest.permission.SET_WALLPAPER)],-1,-1,-1,-1,-1,-1,5,0,"The dependent API call 'UserHandle.myUserId()' in the early implementation has been replaced with 'mContext.getUserId()' in the late implementation. This is a change in the dependent API, so the code change type is 5.","This change in the dependent API does not affect the return value nor does it introduce different exception handling in the context of this API. The method still ultimately returns 'result.getInt(EXTRA_NEW_WALLPAPER_ID, 0)', and the same exceptions are thrown. Therefore, there is no compatibility issue, and the CI type is 0."
436,<android.text.style.TabStopSpan.Standard: int getTabStop()>,27,28,<android.text.style.TabStopSpan.Standard: int getTabStop()>,<android.text.style.TabStopSpan.Standard: int getTabStop()>,0,"{
    return mTab;
}","{
    return mTabOffset;
}",1,,,-1,,[@Override],-1,-1,-1,-1,-1,-1,1,1,"The return statement has changed from returning 'mTab' to returning 'mTabOffset', indicating that the property being returned has been altered, so the code change type is 1.","This change will make the API potentially return a different value, which can affect clients relying on the specific value returned from getTabStop(). Therefore, the CI type is 1."
437,<android.bluetooth.le.PeriodicAdvertisingParameters.Builder: Builder setInterval(int)>,27,28,<android.bluetooth.le.PeriodicAdvertisingParameters.Builder: Builder setInterval(int)>,<android.bluetooth.le.PeriodicAdvertisingParameters.Builder: Builder setInterval(int)>,0,"{
    if (interval < INTERVAL_MIN || interval > INTERVAL_MAX) {
        throw new IllegalArgumentException(""Invalid interval (must be "" + INTERVAL_MIN + ""-"" + INTERVAL_MAX + "")"");
    }
    this.interval = interval;
    return this;
}","{
    if (interval < INTERVAL_MIN || interval > INTERVAL_MAX) {
        throw new IllegalArgumentException(""Invalid interval (must be "" + INTERVAL_MIN + ""-"" + INTERVAL_MAX + "")"");
    }
    mInterval = interval;
    return this;
}",1,"/**
 * Set advertising interval for periodic advertising, in 1.25ms unit.
 * Valid values are from 80 (100ms) to 65519 (81.89875s).
 * Value from range [interval, interval+20ms] will be picked as the actual value.
 * @throws IllegalArgumentException If the interval is invalid.
 */
","/**
 * Set advertising interval for periodic advertising, in 1.25ms unit.
 * Valid values are from 80 (100ms) to 65519 (81.89875s).
 * Value from range [interval, interval+20ms] will be picked as the actual value.
 *
 * @throws IllegalArgumentException If the interval is invalid.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"There is a minimal change in the variable name from `this.interval` to `mInterval`, which does not affect the behavior of the method, so the code change type is 4.","The code change is a simple renaming of a variable and does not affect the API's external behavior. There is no change in the logic or functionality; therefore, there are no Compatibility Issues."
439,<android.content.res.ResourcesImpl.ThemeImpl: int getChangingConfigurations()>,27,28,<android.content.res.ResourcesImpl.ThemeImpl: int getChangingConfigurations()>,<android.content.res.ResourcesImpl.ThemeImpl: int getChangingConfigurations()>,0,"{
    synchronized (mKey) {
        @NativeConfig final int nativeChangingConfig = AssetManager.getThemeChangingConfigurations(mTheme);
        return ActivityInfo.activityInfoConfigNativeToJava(nativeChangingConfig);
    }
}","{
    synchronized (mKey) {
        @NativeConfig final int nativeChangingConfig = AssetManager.nativeThemeGetChangingConfigurations(mTheme);
        return ActivityInfo.activityInfoConfigNativeToJava(nativeChangingConfig);
    }
}",1,,,-1,[@Config],[@Config],-1,-1,-1,-1,-1,-1,5,0,"The method called to retrieve the native changing configurations has changed from AssetManager.getThemeChangingConfigurations(mTheme) to AssetManager.nativeThemeGetChangingConfigurations(mTheme), which implies a change in the dependent API, so the code change type is 5.","There is no Compatibility Issue as long as the new method AssetManager.nativeThemeGetChangingConfigurations(mTheme) returns the same configuration values as the old method AssetManager.getThemeChangingConfigurations(mTheme) would return. There is no information provided to suggest a change in return type or thrown exceptions, therefore, we can infer that there's no compatibility issue."
442,<android.hardware.camera2.impl.CameraDeviceImpl: void close()>,27,28,<android.hardware.camera2.impl.CameraDeviceImpl: void close()>,<android.hardware.camera2.impl.CameraDeviceImpl: void close()>,0,"{
    synchronized (mInterfaceLock) {
        if (mClosing.getAndSet(true)) {
            return;
        }
        if (mRemoteDevice != null) {
            mRemoteDevice.disconnect();
            mRemoteDevice.unlinkToDeath(this, /*flags*/
            0);
        }
        // or a close after a startup error (no remote device but in error state)
        if (mRemoteDevice != null || mInError) {
            mDeviceHandler.post(mCallOnClosed);
        }
        mRemoteDevice = null;
    }
}","{
    synchronized (mInterfaceLock) {
        if (mClosing.getAndSet(true)) {
            return;
        }
        if (mRemoteDevice != null) {
            mRemoteDevice.disconnect();
            mRemoteDevice.unlinkToDeath(this, /*flags*/
            0);
        }
        // or a close after a startup error (no remote device but in error state)
        if (mRemoteDevice != null || mInError) {
            mDeviceExecutor.execute(mCallOnClosed);
        }
        mRemoteDevice = null;
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"4,5",0,"The method from which a call is made has changed: `mDeviceHandler.post(mCallOnClosed)` in the early version to `mDeviceExecutor.execute(mCallOnClosed)` in the late version. This is a Dependent API change, so it is type 4,5. The change would affect how the mCallOnClosed Runnable is executed (from being posted to a Handler to being executed by an Executor), but it does not directly affect the return value or the exception handling of the 'close' method itself.","There is no apparent Compatibility Issue as the method still does not return any value (it's a void method), and there is no exception handling code altered. The inner implementation of how the Runnable is executed doesn't impact the calling code of the 'close' method directly. Thus, the CI type is 0."
443,"<android.hardware.camera2.CameraManager: void registerAvailabilityCallback(AvailabilityCallback,Handler)>",27,28,"<android.hardware.camera2.CameraManager: void registerAvailabilityCallback(AvailabilityCallback,Handler)>","<android.hardware.camera2.CameraManager: void registerAvailabilityCallback(AvailabilityCallback,Handler)>",0,"{
    if (handler == null) {
        Looper looper = Looper.myLooper();
        if (looper == null) {
            throw new IllegalArgumentException(""No handler given, and current thread has no looper!"");
        }
        handler = new Handler(looper);
    }
    CameraManagerGlobal.get().registerAvailabilityCallback(callback, handler);
}","{
    CameraManagerGlobal.get().registerAvailabilityCallback(callback, CameraDeviceImpl.checkAndWrapHandler(handler));
}",1,"/**
 * Register a callback to be notified about camera device availability.
 *
 * <p>Registering the same callback again will replace the handler with the
 * new one provided.</p>
 *
 * <p>The first time a callback is registered, it is immediately called
 * with the availability status of all currently known camera devices.</p>
 *
 * <p>{@link AvailabilityCallback#onCameraUnavailable(String)} will be called whenever a camera
 * device is opened by any camera API client. As of API level 23, other camera API clients may
 * still be able to open such a camera device, evicting the existing client if they have higher
 * priority than the existing client of a camera device. See open() for more details.</p>
 *
 * <p>Since this callback will be registered with the camera service, remember to unregister it
 * once it is no longer needed; otherwise the callback will continue to receive events
 * indefinitely and it may prevent other resources from being released. Specifically, the
 * callbacks will be invoked independently of the general activity lifecycle and independently
 * of the state of individual CameraManager instances.</p>
 *
 * @param callback the new callback to send camera availability notices to
 * @param handler The handler on which the callback should be invoked, or {@code null} to use
 * the current thread's {@link android.os.Looper looper}.
 *
 * @throws IllegalArgumentException if the handler is {@code null} but the current thread has
 * no looper.
 */
","/**
 * Register a callback to be notified about camera device availability.
 *
 * <p>Registering the same callback again will replace the handler with the
 * new one provided.</p>
 *
 * <p>The first time a callback is registered, it is immediately called
 * with the availability status of all currently known camera devices.</p>
 *
 * <p>{@link AvailabilityCallback#onCameraUnavailable(String)} will be called whenever a camera
 * device is opened by any camera API client. As of API level 23, other camera API clients may
 * still be able to open such a camera device, evicting the existing client if they have higher
 * priority than the existing client of a camera device. See open() for more details.</p>
 *
 * <p>Since this callback will be registered with the camera service, remember to unregister it
 * once it is no longer needed; otherwise the callback will continue to receive events
 * indefinitely and it may prevent other resources from being released. Specifically, the
 * callbacks will be invoked independently of the general activity lifecycle and independently
 * of the state of individual CameraManager instances.</p>
 *
 * @param callback the new callback to send camera availability notices to
 * @param handler The handler on which the callback should be invoked, or {@code null} to use
 * the current thread's {@link android.os.Looper looper}.
 *
 * @throws IllegalArgumentException if the handler is {@code null} but the current thread has
 * no looper.
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The implementation of the method removed the logic to create a new handler if one isn't explicitly provided, and now directly uses an API 'CameraDeviceImpl.checkAndWrapHandler(handler)' to potentially perform that logic or other validation/transformation. This indicates a change in the dependent API (type 5).","There's no evidence of a compatibility issue since the dependent API 'CameraDeviceImpl.checkAndWrapHandler(handler)' is likely responsible for ensuring the handler is set correctly, potentially replicating the removed logic. There's no change in the method's return type or exception handling in the signature itself based on the provided information; however, it's not possible to fully assess CI without understanding the specifics of 'CameraDeviceImpl.checkAndWrapHandler(handler)'. Given the information provided, we assume that the change handles compatibility internally, thereby not causing a CI."
444,<android.bluetooth.BluetoothGattServer: BluetoothGattCharacteristic getCharacteristicByHandle(int)>,27,28,<android.bluetooth.BluetoothGattServer: BluetoothGattCharacteristic getCharacteristicByHandle(int)>,<android.bluetooth.BluetoothGattServer: BluetoothGattCharacteristic getCharacteristicByHandle(int)>,0,"{
    for (BluetoothGattService svc : mServices) {
        for (BluetoothGattCharacteristic charac : svc.getCharacteristics()) {
            if (charac.getInstanceId() == handle)
                return charac;
        }
    }
    return null;
}","{
    for (BluetoothGattService svc : mServices) {
        for (BluetoothGattCharacteristic charac : svc.getCharacteristics()) {
            if (charac.getInstanceId() == handle) {
                return charac;
            }
        }
    }
    return null;
}",1,"/*package*/
","/*package*/
",-1,,,-1,-1,-1,-1,-1,-1,0,0,"There is actually no change in implementation between the early version and the late version, the only difference being some white-space and formatting alterations which do not affect the functionality or behavior of the method.","Since there are no code behavior changes, including the way the return value is produced or exceptions being thrown, there is no compatibility issue between the two versions."
445,<android.os.StrictMode.AndroidBlockGuardPolicy: void onWriteToDisk()>,27,28,<android.os.StrictMode.AndroidBlockGuardPolicy: void onWriteToDisk()>,<android.os.StrictMode.AndroidBlockGuardPolicy: void onWriteToDisk()>,0,"{
    if ((mPolicyMask & DETECT_DISK_WRITE) == 0) {
        return;
    }
    if (tooManyViolationsThisLoop()) {
        return;
    }
    BlockGuard.BlockGuardPolicyException e = new StrictModeDiskWriteViolation(mPolicyMask);
    e.fillInStackTrace();
    startHandlingViolationException(e);
}","{
    if ((mPolicyMask & DETECT_DISK_WRITE) == 0) {
        return;
    }
    if (tooManyViolationsThisLoop()) {
        return;
    }
    startHandlingViolationException(new DiskWriteViolation());
}",1,"// Part of BlockGuard.Policy interface:
","// Part of BlockGuard.Policy interface:
",-1,,,-1,-1,-1,-1,-1,-1,"1,4",0,"The instantiation of the exception `e` has changed from `new StrictModeDiskWriteViolation(mPolicyMask)` to `new DiskWriteViolation()`, and the method `fillInStackTrace()` is no longer called, so the code change type is 1,4.","While there is a change in the instantiation of the `BlockGuardPolicyException` object, no Compatibility Issue arises because the behavior related to how exceptions are created and handled does not change the API's outward behavior. The exception is still instantiated and handled the same way in both versions. The difference is in the exception detail (e.g., stack trace being filled in), which does not affect what is thrown or returned. Therefore, the change does not cause a difference in the return value or the exception thrown by the API, and hence no CI is present."
447,<android.view.accessibility.AccessibilityWindowInfo: AccessibilityNodeInfo getAnchor()>,27,28,<android.view.accessibility.AccessibilityWindowInfo: AccessibilityNodeInfo getAnchor()>,<android.view.accessibility.AccessibilityWindowInfo: AccessibilityNodeInfo getAnchor()>,0,"{
    if ((mConnectionId == UNDEFINED_WINDOW_ID) || (mAnchorId == UNDEFINED_WINDOW_ID) || (mParentId == UNDEFINED_WINDOW_ID)) {
        return null;
    }
    AccessibilityInteractionClient client = AccessibilityInteractionClient.getInstance();
    return client.findAccessibilityNodeInfoByAccessibilityId(mConnectionId, mParentId, mAnchorId, true, 0, null);
}","{
    if ((mConnectionId == UNDEFINED_WINDOW_ID) || (mAnchorId == AccessibilityNodeInfo.UNDEFINED_NODE_ID) || (mParentId == UNDEFINED_WINDOW_ID)) {
        return null;
    }
    AccessibilityInteractionClient client = AccessibilityInteractionClient.getInstance();
    return client.findAccessibilityNodeInfoByAccessibilityId(mConnectionId, mParentId, mAnchorId, true, 0, null);
}",1,"/**
 * Gets the node that anchors this window to another.
 *
 * @return The anchor node, or {@code null} if none exists.
 */
","/**
 * Gets the node that anchors this window to another.
 *
 * @return The anchor node, or {@code null} if none exists.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"The code change includes changing a constant from `mAnchorId == UNDEFINED_WINDOW_ID` to `mAnchorId == AccessibilityNodeInfo.UNDEFINED_NODE_ID`. This type of change is classified as 4 and 5 since it involves altering the value of a constant that is checked in a conditional statement, which could potentially be from a dependent API, yet there is no direct evidence that `UNDEFINED_WINDOW_ID` and `AccessibilityNodeInfo.UNDEFINED_NODE_ID` are different values.","There is not enough information to decide if there's a Compatibility Issue since it depends on whether the values of `UNDEFINED_WINDOW_ID` and `AccessibilityNodeInfo.UNDEFINED_NODE_ID` differ. If they are the same value, there is no Compatibility Issue, so we assume there is no CI until proven otherwise. Therefore, the CI type is 0."
450,"<android.content.pm.ShortcutInfo: void writeToParcel(Parcel,int)>",27,28,"<android.content.pm.ShortcutInfo: void writeToParcel(Parcel,int)>","<android.content.pm.ShortcutInfo: void writeToParcel(Parcel,int)>",0,"{
    dest.writeInt(mUserId);
    dest.writeString(mId);
    dest.writeString(mPackageName);
    dest.writeParcelable(mActivity, flags);
    dest.writeInt(mFlags);
    dest.writeInt(mIconResId);
    dest.writeLong(mLastChangedTimestamp);
    if (hasKeyFieldsOnly()) {
        dest.writeInt(0);
        return;
    }
    dest.writeInt(1);
    dest.writeParcelable(mIcon, flags);
    dest.writeCharSequence(mTitle);
    dest.writeInt(mTitleResId);
    dest.writeCharSequence(mText);
    dest.writeInt(mTextResId);
    dest.writeCharSequence(mDisabledMessage);
    dest.writeInt(mDisabledMessageResId);
    dest.writeParcelableArray(mIntents, flags);
    dest.writeParcelableArray(mIntentPersistableExtrases, flags);
    dest.writeInt(mRank);
    dest.writeParcelable(mExtras, flags);
    dest.writeString(mBitmapPath);
    dest.writeString(mIconResName);
    dest.writeString(mTitleResName);
    dest.writeString(mTextResName);
    dest.writeString(mDisabledMessageResName);
    if (mCategories != null) {
        final int N = mCategories.size();
        dest.writeInt(N);
        for (int i = 0; i < N; i++) {
            dest.writeString(mCategories.valueAt(i));
        }
    } else {
        dest.writeInt(0);
    }
}","{
    dest.writeInt(mUserId);
    dest.writeString(mId);
    dest.writeString(mPackageName);
    dest.writeParcelable(mActivity, flags);
    dest.writeInt(mFlags);
    dest.writeInt(mIconResId);
    dest.writeLong(mLastChangedTimestamp);
    dest.writeInt(mDisabledReason);
    if (hasKeyFieldsOnly()) {
        dest.writeInt(0);
        return;
    }
    dest.writeInt(1);
    dest.writeParcelable(mIcon, flags);
    dest.writeCharSequence(mTitle);
    dest.writeInt(mTitleResId);
    dest.writeCharSequence(mText);
    dest.writeInt(mTextResId);
    dest.writeCharSequence(mDisabledMessage);
    dest.writeInt(mDisabledMessageResId);
    dest.writeParcelableArray(mIntents, flags);
    dest.writeParcelableArray(mIntentPersistableExtrases, flags);
    dest.writeInt(mRank);
    dest.writeParcelable(mExtras, flags);
    dest.writeString(mBitmapPath);
    dest.writeString(mIconResName);
    dest.writeString(mTitleResName);
    dest.writeString(mTextResName);
    dest.writeString(mDisabledMessageResName);
    if (mCategories != null) {
        final int N = mCategories.size();
        dest.writeInt(N);
        for (int i = 0; i < N; i++) {
            dest.writeString(mCategories.valueAt(i));
        }
    } else {
        dest.writeInt(0);
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"The only change in the implementation is the introduction of a new statement ""dest.writeInt(mDisabledReason);"" which adds an additional piece of data to the output parcel. This is neither a return statement change, exception handling statement change, control dependency change, nor a dependent API change. Thus, it falls under category 4 (Other statement changed).","This added statement does not lead to a Compatibility Issue because it does not affect the behavior or output of the API in a way that would lead to errors or unexpected behavior. The existing data written to the parcel remains unchanged, only supplemented with additional information. Consequently, there is no change that would lead to different return values, types, or exceptions being thrown. Therefore, the CI type is 0 (No Compatibility Issue)."
451,"<android.text.Selection: boolean extendUp(Spannable,Layout)>",27,28,"<android.text.Selection: boolean extendUp(Spannable,Layout)>","<android.text.Selection: boolean extendUp(Spannable,Layout)>",0,"{
    int end = getSelectionEnd(text);
    int line = layout.getLineForOffset(end);
    if (line > 0) {
        int move;
        if (layout.getParagraphDirection(line) == layout.getParagraphDirection(line - 1)) {
            float h = layout.getPrimaryHorizontal(end);
            move = layout.getOffsetForHorizontal(line - 1, h);
        } else {
            move = layout.getLineStart(line - 1);
        }
        extendSelection(text, move);
        return true;
    } else if (end != 0) {
        extendSelection(text, 0);
        return true;
    }
    return true;
}","{
    int end = getSelectionEnd(text);
    int line = layout.getLineForOffset(end);
    if (line > 0) {
        setSelectionAndMemory(text, layout, line, end, -1, /* direction */
        true);
        return true;
    } else if (end != 0) {
        extendSelection(text, 0);
        return true;
    }
    return true;
}",1,"/**
 * Move the selection end to the buffer offset physically above
 * the current selection end.
 */
","/**
 * Move the selection end to the buffer offset physically above
 * the current selection end.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3,4",0,"The early version has a control block that determines the offset to move up based on the direction of the paragraph and horizontal positioning. This control dependency is modified in the late version to directly set the selection using the setSelectionAndMemory method. There are changes in return statements, control statements, and also different method invocations, which indicate that there is a return statement change, control dependency change, and other statement change. However, since all of these changes unconditionally return 'true', it doesn't lead to a different return value.","Despite changes in the implementation, there is no Compatibility Issue because the method behavior does not ultimately produce a different return value. The method returns 'true' in all cases in both versions, so consumers of the API will not observe a difference in behavior."
452,<android.content.res.TypedArray: TypedValue peekValue(int)>,27,28,<android.content.res.TypedArray: TypedValue peekValue(int)>,<android.content.res.TypedArray: TypedValue peekValue(int)>,0,"{
    if (mRecycled) {
        throw new RuntimeException(""Cannot make calls to a recycled instance!"");
    }
    final TypedValue value = mValue;
    if (getValueAt(index * AssetManager.STYLE_NUM_ENTRIES, value)) {
        return value;
    }
    return null;
}","{
    if (mRecycled) {
        throw new RuntimeException(""Cannot make calls to a recycled instance!"");
    }
    final TypedValue value = mValue;
    if (getValueAt(index * STYLE_NUM_ENTRIES, value)) {
        return value;
    }
    return null;
}",1,"/**
 * Retrieve the raw TypedValue for the attribute at <var>index</var>
 * and return a temporary object holding its data.  This object is only
 * valid until the next call on to {@link TypedArray}.
 *
 * @param index Index of attribute to retrieve.
 *
 * @return Returns a TypedValue object if the attribute is defined,
 * containing its data; otherwise returns null.  (You will not
 * receive a TypedValue whose type is TYPE_NULL.)
 * @throws RuntimeException if the TypedArray has already been recycled.
 */
","/**
 * Retrieve the raw TypedValue for the attribute at <var>index</var>
 * and return a temporary object holding its data.  This object is only
 * valid until the next call on to {@link TypedArray}.
 *
 * @param index Index of attribute to retrieve.
 *
 * @return Returns a TypedValue object if the attribute is defined,
 * containing its data; otherwise returns null.  (You will not
 * receive a TypedValue whose type is TYPE_NULL.)
 * @throws RuntimeException if the TypedArray has already been recycled.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The only change is in the constant used from AssetManager.STYLE_NUM_ENTRIES to STYLE_NUM_ENTRIES which appears to be a reference update. Since the final resulting behavior of the API does not change, as the constant value is presumed to be the same, the change type is 4.","There is no Compatibility Issue as the constant value itself is presumably unchanged. The use of the constant, whether it is scoped with AssetManager or not, would not alter the execution flow or the outcome of the method calls within the API as long as the constant value remains consistent, which we would expect to be true. Thus, there is no change that would affect the return values or exception handling of this API."
457,"<android.widget.LinearLayout: void measureVertical(int,int)>",27,28,"<android.widget.LinearLayout: void measureVertical(int,int)>","<android.widget.LinearLayout: void measureVertical(int,int)>",0,"{
    mTotalLength = 0;
    int maxWidth = 0;
    int childState = 0;
    int alternativeMaxWidth = 0;
    int weightedMaxWidth = 0;
    boolean allFillParent = true;
    float totalWeight = 0;
    final int count = getVirtualChildCount();
    final int widthMode = MeasureSpec.getMode(widthMeasureSpec);
    final int heightMode = MeasureSpec.getMode(heightMeasureSpec);
    boolean matchWidth = false;
    boolean skippedMeasure = false;
    final int baselineChildIndex = mBaselineAlignedChildIndex;
    final boolean useLargestChild = mUseLargestChild;
    int largestChildHeight = Integer.MIN_VALUE;
    int consumedExcessSpace = 0;
    int nonSkippedChildCount = 0;
    // See how tall everyone is. Also remember max width.
    for (int i = 0; i < count; ++i) {
        final View child = getVirtualChildAt(i);
        if (child == null) {
            mTotalLength += measureNullChild(i);
            continue;
        }
        if (child.getVisibility() == View.GONE) {
            i += getChildrenSkipCount(child, i);
            continue;
        }
        nonSkippedChildCount++;
        if (hasDividerBeforeChildAt(i)) {
            mTotalLength += mDividerHeight;
        }
        final LayoutParams lp = (LayoutParams) child.getLayoutParams();
        totalWeight += lp.weight;
        final boolean useExcessSpace = lp.height == 0 && lp.weight > 0;
        if (heightMode == MeasureSpec.EXACTLY && useExcessSpace) {
            // Optimization: don't bother measuring children who are only
            // laid out using excess space. These views will get measured
            // later if we have space to distribute.
            final int totalLength = mTotalLength;
            mTotalLength = Math.max(totalLength, totalLength + lp.topMargin + lp.bottomMargin);
            skippedMeasure = true;
        } else {
            if (useExcessSpace) {
                // The heightMode is either UNSPECIFIED or AT_MOST, and
                // this child is only laid out using excess space. Measure
                // using WRAP_CONTENT so that we can find out the view's
                // optimal height. We'll restore the original height of 0
                // after measurement.
                lp.height = LayoutParams.WRAP_CONTENT;
            }
            // Determine how big this child would like to be. If this or
            // previous children have given a weight, then we allow it to
            // use all available space (and we will shrink things later
            // if needed).
            final int usedHeight = totalWeight == 0 ? mTotalLength : 0;
            measureChildBeforeLayout(child, i, widthMeasureSpec, 0, heightMeasureSpec, usedHeight);
            final int childHeight = child.getMeasuredHeight();
            if (useExcessSpace) {
                // Restore the original height and record how much space
                // we've allocated to excess-only children so that we can
                // match the behavior of EXACTLY measurement.
                lp.height = 0;
                consumedExcessSpace += childHeight;
            }
            final int totalLength = mTotalLength;
            mTotalLength = Math.max(totalLength, totalLength + childHeight + lp.topMargin + lp.bottomMargin + getNextLocationOffset(child));
            if (useLargestChild) {
                largestChildHeight = Math.max(childHeight, largestChildHeight);
            }
        }
        /**
         * If applicable, compute the additional offset to the child's baseline
         * we'll need later when asked {@link #getBaseline}.
         */
        if ((baselineChildIndex >= 0) && (baselineChildIndex == i + 1)) {
            mBaselineChildTop = mTotalLength;
        }
        // weight.  fail fast to aid the developer.
        if (i < baselineChildIndex && lp.weight > 0) {
            throw new RuntimeException(""A child of LinearLayout with index "" + ""less than mBaselineAlignedChildIndex has weight > 0, which "" + ""won't work.  Either remove the weight, or don't set "" + ""mBaselineAlignedChildIndex."");
        }
        boolean matchWidthLocally = false;
        if (widthMode != MeasureSpec.EXACTLY && lp.width == LayoutParams.MATCH_PARENT) {
            // The width of the linear layout will scale, and at least one
            // child said it wanted to match our width. Set a flag
            // indicating that we need to remeasure at least that view when
            // we know our width.
            matchWidth = true;
            matchWidthLocally = true;
        }
        final int margin = lp.leftMargin + lp.rightMargin;
        final int measuredWidth = child.getMeasuredWidth() + margin;
        maxWidth = Math.max(maxWidth, measuredWidth);
        childState = combineMeasuredStates(childState, child.getMeasuredState());
        allFillParent = allFillParent && lp.width == LayoutParams.MATCH_PARENT;
        if (lp.weight > 0) {
            /*
                 * Widths of weighted Views are bogus if we end up
                 * remeasuring, so keep them separate.
                 */
            weightedMaxWidth = Math.max(weightedMaxWidth, matchWidthLocally ? margin : measuredWidth);
        } else {
            alternativeMaxWidth = Math.max(alternativeMaxWidth, matchWidthLocally ? margin : measuredWidth);
        }
        i += getChildrenSkipCount(child, i);
    }
    if (nonSkippedChildCount > 0 && hasDividerBeforeChildAt(count)) {
        mTotalLength += mDividerHeight;
    }
    if (useLargestChild && (heightMode == MeasureSpec.AT_MOST || heightMode == MeasureSpec.UNSPECIFIED)) {
        mTotalLength = 0;
        for (int i = 0; i < count; ++i) {
            final View child = getVirtualChildAt(i);
            if (child == null) {
                mTotalLength += measureNullChild(i);
                continue;
            }
            if (child.getVisibility() == GONE) {
                i += getChildrenSkipCount(child, i);
                continue;
            }
            final LinearLayout.LayoutParams lp = (LinearLayout.LayoutParams) child.getLayoutParams();
            // Account for negative margins
            final int totalLength = mTotalLength;
            mTotalLength = Math.max(totalLength, totalLength + largestChildHeight + lp.topMargin + lp.bottomMargin + getNextLocationOffset(child));
        }
    }
    // Add in our padding
    mTotalLength += mPaddingTop + mPaddingBottom;
    int heightSize = mTotalLength;
    // Check against our minimum height
    heightSize = Math.max(heightSize, getSuggestedMinimumHeight());
    // Reconcile our calculated size with the heightMeasureSpec
    int heightSizeAndState = resolveSizeAndState(heightSize, heightMeasureSpec, 0);
    heightSize = heightSizeAndState & MEASURED_SIZE_MASK;
    // Either expand children with weight to take up available space or
    // shrink them if they extend beyond our current bounds. If we skipped
    // measurement on any children, we need to measure them now.
    int remainingExcess = heightSize - mTotalLength + (mAllowInconsistentMeasurement ? 0 : consumedExcessSpace);
    if (skippedMeasure || remainingExcess != 0 && totalWeight > 0.0f) {
        float remainingWeightSum = mWeightSum > 0.0f ? mWeightSum : totalWeight;
        mTotalLength = 0;
        for (int i = 0; i < count; ++i) {
            final View child = getVirtualChildAt(i);
            if (child == null || child.getVisibility() == View.GONE) {
                continue;
            }
            final LayoutParams lp = (LayoutParams) child.getLayoutParams();
            final float childWeight = lp.weight;
            if (childWeight > 0) {
                final int share = (int) (childWeight * remainingExcess / remainingWeightSum);
                remainingExcess -= share;
                remainingWeightSum -= childWeight;
                final int childHeight;
                if (mUseLargestChild && heightMode != MeasureSpec.EXACTLY) {
                    childHeight = largestChildHeight;
                } else if (lp.height == 0 && (!mAllowInconsistentMeasurement || heightMode == MeasureSpec.EXACTLY)) {
                    // This child needs to be laid out from scratch using
                    // only its share of excess space.
                    childHeight = share;
                } else {
                    // This child had some intrinsic height to which we
                    // need to add its share of excess space.
                    childHeight = child.getMeasuredHeight() + share;
                }
                final int childHeightMeasureSpec = MeasureSpec.makeMeasureSpec(Math.max(0, childHeight), MeasureSpec.EXACTLY);
                final int childWidthMeasureSpec = getChildMeasureSpec(widthMeasureSpec, mPaddingLeft + mPaddingRight + lp.leftMargin + lp.rightMargin, lp.width);
                child.measure(childWidthMeasureSpec, childHeightMeasureSpec);
                // Child may now not fit in vertical dimension.
                childState = combineMeasuredStates(childState, child.getMeasuredState() & (MEASURED_STATE_MASK >> MEASURED_HEIGHT_STATE_SHIFT));
            }
            final int margin = lp.leftMargin + lp.rightMargin;
            final int measuredWidth = child.getMeasuredWidth() + margin;
            maxWidth = Math.max(maxWidth, measuredWidth);
            boolean matchWidthLocally = widthMode != MeasureSpec.EXACTLY && lp.width == LayoutParams.MATCH_PARENT;
            alternativeMaxWidth = Math.max(alternativeMaxWidth, matchWidthLocally ? margin : measuredWidth);
            allFillParent = allFillParent && lp.width == LayoutParams.MATCH_PARENT;
            final int totalLength = mTotalLength;
            mTotalLength = Math.max(totalLength, totalLength + child.getMeasuredHeight() + lp.topMargin + lp.bottomMargin + getNextLocationOffset(child));
        }
        // Add in our padding
        mTotalLength += mPaddingTop + mPaddingBottom;
    // TODO: Should we recompute the heightSpec based on the new total length?
    } else {
        alternativeMaxWidth = Math.max(alternativeMaxWidth, weightedMaxWidth);
        // Children will have already been measured once.
        if (useLargestChild && heightMode != MeasureSpec.EXACTLY) {
            for (int i = 0; i < count; i++) {
                final View child = getVirtualChildAt(i);
                if (child == null || child.getVisibility() == View.GONE) {
                    continue;
                }
                final LinearLayout.LayoutParams lp = (LinearLayout.LayoutParams) child.getLayoutParams();
                float childExtra = lp.weight;
                if (childExtra > 0) {
                    child.measure(MeasureSpec.makeMeasureSpec(child.getMeasuredWidth(), MeasureSpec.EXACTLY), MeasureSpec.makeMeasureSpec(largestChildHeight, MeasureSpec.EXACTLY));
                }
            }
        }
    }
    if (!allFillParent && widthMode != MeasureSpec.EXACTLY) {
        maxWidth = alternativeMaxWidth;
    }
    maxWidth += mPaddingLeft + mPaddingRight;
    // Check against our minimum width
    maxWidth = Math.max(maxWidth, getSuggestedMinimumWidth());
    setMeasuredDimension(resolveSizeAndState(maxWidth, widthMeasureSpec, childState), heightSizeAndState);
    if (matchWidth) {
        forceUniformWidth(count, heightMeasureSpec);
    }
}","{
    mTotalLength = 0;
    int maxWidth = 0;
    int childState = 0;
    int alternativeMaxWidth = 0;
    int weightedMaxWidth = 0;
    boolean allFillParent = true;
    float totalWeight = 0;
    final int count = getVirtualChildCount();
    final int widthMode = MeasureSpec.getMode(widthMeasureSpec);
    final int heightMode = MeasureSpec.getMode(heightMeasureSpec);
    boolean matchWidth = false;
    boolean skippedMeasure = false;
    final int baselineChildIndex = mBaselineAlignedChildIndex;
    final boolean useLargestChild = mUseLargestChild;
    int largestChildHeight = Integer.MIN_VALUE;
    int consumedExcessSpace = 0;
    int nonSkippedChildCount = 0;
    // See how tall everyone is. Also remember max width.
    for (int i = 0; i < count; ++i) {
        final View child = getVirtualChildAt(i);
        if (child == null) {
            mTotalLength += measureNullChild(i);
            continue;
        }
        if (child.getVisibility() == View.GONE) {
            i += getChildrenSkipCount(child, i);
            continue;
        }
        nonSkippedChildCount++;
        if (hasDividerBeforeChildAt(i)) {
            mTotalLength += mDividerHeight;
        }
        final LayoutParams lp = (LayoutParams) child.getLayoutParams();
        totalWeight += lp.weight;
        final boolean useExcessSpace = lp.height == 0 && lp.weight > 0;
        if (heightMode == MeasureSpec.EXACTLY && useExcessSpace) {
            // Optimization: don't bother measuring children who are only
            // laid out using excess space. These views will get measured
            // later if we have space to distribute.
            final int totalLength = mTotalLength;
            mTotalLength = Math.max(totalLength, totalLength + lp.topMargin + lp.bottomMargin);
            skippedMeasure = true;
        } else {
            if (useExcessSpace) {
                // The heightMode is either UNSPECIFIED or AT_MOST, and
                // this child is only laid out using excess space. Measure
                // using WRAP_CONTENT so that we can find out the view's
                // optimal height. We'll restore the original height of 0
                // after measurement.
                lp.height = LayoutParams.WRAP_CONTENT;
            }
            // Determine how big this child would like to be. If this or
            // previous children have given a weight, then we allow it to
            // use all available space (and we will shrink things later
            // if needed).
            final int usedHeight = totalWeight == 0 ? mTotalLength : 0;
            measureChildBeforeLayout(child, i, widthMeasureSpec, 0, heightMeasureSpec, usedHeight);
            final int childHeight = child.getMeasuredHeight();
            if (useExcessSpace) {
                // Restore the original height and record how much space
                // we've allocated to excess-only children so that we can
                // match the behavior of EXACTLY measurement.
                lp.height = 0;
                consumedExcessSpace += childHeight;
            }
            final int totalLength = mTotalLength;
            mTotalLength = Math.max(totalLength, totalLength + childHeight + lp.topMargin + lp.bottomMargin + getNextLocationOffset(child));
            if (useLargestChild) {
                largestChildHeight = Math.max(childHeight, largestChildHeight);
            }
        }
        /**
         * If applicable, compute the additional offset to the child's baseline
         * we'll need later when asked {@link #getBaseline}.
         */
        if ((baselineChildIndex >= 0) && (baselineChildIndex == i + 1)) {
            mBaselineChildTop = mTotalLength;
        }
        // weight.  fail fast to aid the developer.
        if (i < baselineChildIndex && lp.weight > 0) {
            throw new RuntimeException(""A child of LinearLayout with index "" + ""less than mBaselineAlignedChildIndex has weight > 0, which "" + ""won't work.  Either remove the weight, or don't set "" + ""mBaselineAlignedChildIndex."");
        }
        boolean matchWidthLocally = false;
        if (widthMode != MeasureSpec.EXACTLY && lp.width == LayoutParams.MATCH_PARENT) {
            // The width of the linear layout will scale, and at least one
            // child said it wanted to match our width. Set a flag
            // indicating that we need to remeasure at least that view when
            // we know our width.
            matchWidth = true;
            matchWidthLocally = true;
        }
        final int margin = lp.leftMargin + lp.rightMargin;
        final int measuredWidth = child.getMeasuredWidth() + margin;
        maxWidth = Math.max(maxWidth, measuredWidth);
        childState = combineMeasuredStates(childState, child.getMeasuredState());
        allFillParent = allFillParent && lp.width == LayoutParams.MATCH_PARENT;
        if (lp.weight > 0) {
            /*
                 * Widths of weighted Views are bogus if we end up
                 * remeasuring, so keep them separate.
                 */
            weightedMaxWidth = Math.max(weightedMaxWidth, matchWidthLocally ? margin : measuredWidth);
        } else {
            alternativeMaxWidth = Math.max(alternativeMaxWidth, matchWidthLocally ? margin : measuredWidth);
        }
        i += getChildrenSkipCount(child, i);
    }
    if (nonSkippedChildCount > 0 && hasDividerBeforeChildAt(count)) {
        mTotalLength += mDividerHeight;
    }
    if (useLargestChild && (heightMode == MeasureSpec.AT_MOST || heightMode == MeasureSpec.UNSPECIFIED)) {
        mTotalLength = 0;
        for (int i = 0; i < count; ++i) {
            final View child = getVirtualChildAt(i);
            if (child == null) {
                mTotalLength += measureNullChild(i);
                continue;
            }
            if (child.getVisibility() == GONE) {
                i += getChildrenSkipCount(child, i);
                continue;
            }
            final LinearLayout.LayoutParams lp = (LinearLayout.LayoutParams) child.getLayoutParams();
            // Account for negative margins
            final int totalLength = mTotalLength;
            mTotalLength = Math.max(totalLength, totalLength + largestChildHeight + lp.topMargin + lp.bottomMargin + getNextLocationOffset(child));
        }
    }
    // Add in our padding
    mTotalLength += mPaddingTop + mPaddingBottom;
    int heightSize = mTotalLength;
    // Check against our minimum height
    heightSize = Math.max(heightSize, getSuggestedMinimumHeight());
    // Reconcile our calculated size with the heightMeasureSpec
    int heightSizeAndState = resolveSizeAndState(heightSize, heightMeasureSpec, 0);
    heightSize = heightSizeAndState & MEASURED_SIZE_MASK;
    // Either expand children with weight to take up available space or
    // shrink them if they extend beyond our current bounds. If we skipped
    // measurement on any children, we need to measure them now.
    int remainingExcess = heightSize - mTotalLength + (mAllowInconsistentMeasurement ? 0 : consumedExcessSpace);
    if (skippedMeasure || ((sRemeasureWeightedChildren || remainingExcess != 0) && totalWeight > 0.0f)) {
        float remainingWeightSum = mWeightSum > 0.0f ? mWeightSum : totalWeight;
        mTotalLength = 0;
        for (int i = 0; i < count; ++i) {
            final View child = getVirtualChildAt(i);
            if (child == null || child.getVisibility() == View.GONE) {
                continue;
            }
            final LayoutParams lp = (LayoutParams) child.getLayoutParams();
            final float childWeight = lp.weight;
            if (childWeight > 0) {
                final int share = (int) (childWeight * remainingExcess / remainingWeightSum);
                remainingExcess -= share;
                remainingWeightSum -= childWeight;
                final int childHeight;
                if (mUseLargestChild && heightMode != MeasureSpec.EXACTLY) {
                    childHeight = largestChildHeight;
                } else if (lp.height == 0 && (!mAllowInconsistentMeasurement || heightMode == MeasureSpec.EXACTLY)) {
                    // This child needs to be laid out from scratch using
                    // only its share of excess space.
                    childHeight = share;
                } else {
                    // This child had some intrinsic height to which we
                    // need to add its share of excess space.
                    childHeight = child.getMeasuredHeight() + share;
                }
                final int childHeightMeasureSpec = MeasureSpec.makeMeasureSpec(Math.max(0, childHeight), MeasureSpec.EXACTLY);
                final int childWidthMeasureSpec = getChildMeasureSpec(widthMeasureSpec, mPaddingLeft + mPaddingRight + lp.leftMargin + lp.rightMargin, lp.width);
                child.measure(childWidthMeasureSpec, childHeightMeasureSpec);
                // Child may now not fit in vertical dimension.
                childState = combineMeasuredStates(childState, child.getMeasuredState() & (MEASURED_STATE_MASK >> MEASURED_HEIGHT_STATE_SHIFT));
            }
            final int margin = lp.leftMargin + lp.rightMargin;
            final int measuredWidth = child.getMeasuredWidth() + margin;
            maxWidth = Math.max(maxWidth, measuredWidth);
            boolean matchWidthLocally = widthMode != MeasureSpec.EXACTLY && lp.width == LayoutParams.MATCH_PARENT;
            alternativeMaxWidth = Math.max(alternativeMaxWidth, matchWidthLocally ? margin : measuredWidth);
            allFillParent = allFillParent && lp.width == LayoutParams.MATCH_PARENT;
            final int totalLength = mTotalLength;
            mTotalLength = Math.max(totalLength, totalLength + child.getMeasuredHeight() + lp.topMargin + lp.bottomMargin + getNextLocationOffset(child));
        }
        // Add in our padding
        mTotalLength += mPaddingTop + mPaddingBottom;
    // TODO: Should we recompute the heightSpec based on the new total length?
    } else {
        alternativeMaxWidth = Math.max(alternativeMaxWidth, weightedMaxWidth);
        // Children will have already been measured once.
        if (useLargestChild && heightMode != MeasureSpec.EXACTLY) {
            for (int i = 0; i < count; i++) {
                final View child = getVirtualChildAt(i);
                if (child == null || child.getVisibility() == View.GONE) {
                    continue;
                }
                final LinearLayout.LayoutParams lp = (LinearLayout.LayoutParams) child.getLayoutParams();
                float childExtra = lp.weight;
                if (childExtra > 0) {
                    child.measure(MeasureSpec.makeMeasureSpec(child.getMeasuredWidth(), MeasureSpec.EXACTLY), MeasureSpec.makeMeasureSpec(largestChildHeight, MeasureSpec.EXACTLY));
                }
            }
        }
    }
    if (!allFillParent && widthMode != MeasureSpec.EXACTLY) {
        maxWidth = alternativeMaxWidth;
    }
    maxWidth += mPaddingLeft + mPaddingRight;
    // Check against our minimum width
    maxWidth = Math.max(maxWidth, getSuggestedMinimumWidth());
    setMeasuredDimension(resolveSizeAndState(maxWidth, widthMeasureSpec, childState), heightSizeAndState);
    if (matchWidth) {
        forceUniformWidth(count, heightMeasureSpec);
    }
}",1,"/**
 * Measures the children when the orientation of this LinearLayout is set
 * to {@link #VERTICAL}.
 *
 * @param widthMeasureSpec Horizontal space requirements as imposed by the parent.
 * @param heightMeasureSpec Vertical space requirements as imposed by the parent.
 *
 * @see #getOrientation()
 * @see #setOrientation(int)
 * @see #onMeasure(int, int)
 */
","/**
 * Measures the children when the orientation of this LinearLayout is set
 * to {@link #VERTICAL}.
 *
 * @param widthMeasureSpec Horizontal space requirements as imposed by the parent.
 * @param heightMeasureSpec Vertical space requirements as imposed by the parent.
 *
 * @see #getOrientation()
 * @see #setOrientation(int)
 * @see #onMeasure(int, int)
 */
",-1,,,-1,-1,-1,-1,-1,-1,,,,
458,"<android.view.textclassifier.logging.SmartSelectionEventTracker.SelectionEvent: SelectionEvent selectionModified(int,int,TextClassification)>",27,28,"<android.view.textclassifier.logging.SmartSelectionEventTracker.SelectionEvent: SelectionEvent selectionModified(int,int,TextClassification)>","<android.view.textclassifier.logging.SmartSelectionEventTracker.SelectionEvent: SelectionEvent selectionModified(int,int,TextClassification)>",0,"{
    final String entityType = classification.getEntityCount() > 0 ? classification.getEntity(0) : TextClassifier.TYPE_UNKNOWN;
    final String versionTag = classification.getVersionInfo();
    return new SelectionEvent(start, end, EventType.SELECTION_MODIFIED, entityType, versionTag);
}","{
    final String entityType = classification.getEntityCount() > 0 ? classification.getEntity(0) : TextClassifier.TYPE_UNKNOWN;
    final String versionTag = getVersionInfo(classification.getId());
    return new SelectionEvent(start, end, EventType.SELECTION_MODIFIED, entityType, versionTag);
}",1,"/**
 * Creates a ""selection modified"" event.
 * Use when the user modifies the selection and the selection's entity type is known.
 *
 * @param start  the start word (inclusive) index of the selection
 * @param end  the end word (exclusive) index of the selection
 * @param classification  the TextClassification object returned by the TextClassifier that
 * classified the selected text
 */
","/**
 * Creates a ""selection modified"" event.
 * Use when the user modifies the selection and the selection's entity type is known.
 *
 * @param start  the start word (inclusive) index of the selection
 * @param end  the end word (exclusive) index of the selection
 * @param classification  the TextClassification object returned by the TextClassifier that
 * classified the selected text
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"The implementation change consists of calling a different method for obtaining `versionTag`, which changed from `classification.getVersionInfo()` to `getVersionInfo(classification.getId())`. This change doesn't affect the control flow or the type of returned value but involves calling a different method (possibly a refactoring of how version info is retrieved), so the code change types are 4 for the method call change and 5 for the dependent API change.","There is no Compatibility Issue as the returned `SelectionEvent` object still contains the same types of values and the method signature is unchanged. The change in how `versionTag` is retrieved doesn't directly lead to a different return type or throwing a new exception as long as the new method `getVersionInfo(String id)` is expected to have identical behavior to the old `classification.getVersionInfo()`. Without evidence of altered behavior, we can conclude that there is no CI, hence the result is 0."
459,"<android.service.autofill.CustomDescription: void writeToParcel(Parcel,int)>",27,28,"<android.service.autofill.CustomDescription: void writeToParcel(Parcel,int)>","<android.service.autofill.CustomDescription: void writeToParcel(Parcel,int)>",0,"{
    dest.writeParcelable(mPresentation, flags);
    if (mTransformations == null) {
        dest.writeIntArray(null);
    } else {
        final int size = mTransformations.size();
        final int[] ids = new int[size];
        final InternalTransformation[] values = new InternalTransformation[size];
        for (int i = 0; i < size; i++) {
            final Pair<Integer, InternalTransformation> pair = mTransformations.get(i);
            ids[i] = pair.first;
            values[i] = pair.second;
        }
        dest.writeIntArray(ids);
        dest.writeParcelableArray(values, flags);
    }
}","{
    dest.writeParcelable(mPresentation, flags);
    if (mPresentation == null)
        return;
    if (mTransformations == null) {
        dest.writeIntArray(null);
    } else {
        final int size = mTransformations.size();
        final int[] ids = new int[size];
        final InternalTransformation[] values = new InternalTransformation[size];
        for (int i = 0; i < size; i++) {
            final Pair<Integer, InternalTransformation> pair = mTransformations.get(i);
            ids[i] = pair.first;
            values[i] = pair.second;
        }
        dest.writeIntArray(ids);
        dest.writeParcelableArray(values, flags);
    }
    if (mUpdates == null) {
        dest.writeParcelableArray(null, flags);
    } else {
        final int size = mUpdates.size();
        final InternalValidator[] conditions = new InternalValidator[size];
        final BatchUpdates[] updates = new BatchUpdates[size];
        for (int i = 0; i < size; i++) {
            final Pair<InternalValidator, BatchUpdates> pair = mUpdates.get(i);
            conditions[i] = pair.first;
            updates[i] = pair.second;
        }
        dest.writeParcelableArray(conditions, flags);
        dest.writeParcelableArray(updates, flags);
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,3,4",1,"The late implementation adds a return statement when mPresentation is null, which means it will no longer process any further writing to the parcel and changes the control flow. Additionally, the code adds writing of mUpdates to the parcel, which is another block of data that was not included in the early version. These changes are reflected in a new return statement (type 1), a new control dependency due to the additional null check for mPresentation (type 3), and other statement changes where mUpdates are written to the parcel (type 4).","The introduction of the return statement after checking if mPresentation is null introduces a different behavior since it can terminate the method prematurely compared to the early version, which always proceeds with writing to the parcel regardless of mPresentation's state. Furthermore, the additional writing of mUpdates introduces different data being written to the parcel, which could affect the resulting parcel data. Therefore, the CI type is 1, which indicates a potential change in the return value (in this case, the content of the Parcel)."
461,<android.view.textclassifier.TextClassificationManager: TextClassifier getTextClassifier()>,27,28,<android.view.textclassifier.TextClassificationManager: TextClassifier getTextClassifier()>,<android.view.textclassifier.TextClassificationManager: TextClassifier getTextClassifier()>,0,"{
    synchronized (mTextClassifierLock) {
        if (mTextClassifier == null) {
            mTextClassifier = new TextClassifierImpl(mContext);
        }
        return mTextClassifier;
    }
}","{
    synchronized (mLock) {
        if (mCustomTextClassifier != null) {
            return mCustomTextClassifier;
        } else if (isSystemTextClassifierEnabled()) {
            return getSystemTextClassifier();
        } else {
            return getLocalTextClassifier();
        }
    }
}",1,"/**
 * Returns the text classifier.
 */
","/**
 * Returns the text classifier that was set via {@link #setTextClassifier(TextClassifier)}.
 * If this is null, this method returns a default text classifier (i.e. either the system text
 * classifier if one exists, or a local text classifier running in this app.)
 *
 * @see #setTextClassifier(TextClassifier)
 */
",-1,,[@NonNull],-1,-1,-1,-1,-1,-1,"1,3,4,5",1,"The synchronization lock object has changed (from mTextClassifierLock to mLock), the logic inside the synchronized block is completely different, the object being returned can be different (mTextClassifier, mCustomTextClassifier, system or local text classifier), and new methods are being called (isSystemTextClassifierEnabled(), getSystemTextClassifier(), getLocalTextClassifier()). So the change types are 1 (due to new return value possibilities), 3 (control dependency is changed), 4 (multiple other statements are changed), and 5 (dependent APIs are changed as the new implementation relies on additional APIs).","Potential Compatibility Issue type is 1 due to the altered return statement, which can cause the method to return different objects of TextClassifier in the late version. This is because the conditions under which a specific TextClassifier is returned have been revised."
462,<android.content.res.Resources: Theme newTheme()>,27,28,<android.content.res.Resources: Theme newTheme()>,<android.content.res.Resources: Theme newTheme()>,0,"{
    Theme theme = new Theme();
    theme.setImpl(mResourcesImpl.newThemeImpl());
    synchronized (mThemeRefs) {
        mThemeRefs.add(new WeakReference<>(theme));
    }
    return theme;
}","{
    Theme theme = new Theme();
    theme.setImpl(mResourcesImpl.newThemeImpl());
    synchronized (mThemeRefs) {
        mThemeRefs.add(new WeakReference<>(theme));
        // Clean up references to garbage collected themes
        if (mThemeRefs.size() > mThemeRefsNextFlushSize) {
            mThemeRefs.removeIf(ref -> ref.get() == null);
            mThemeRefsNextFlushSize = Math.max(MIN_THEME_REFS_FLUSH_SIZE, 2 * mThemeRefs.size());
        }
    }
    return theme;
}",1,"/**
 * Generate a new Theme object for this set of Resources.  It initially
 * starts out empty.
 *
 * @return Theme The newly created Theme container.
 */
","/**
 * Generate a new Theme object for this set of Resources.  It initially
 * starts out empty.
 *
 * @return Theme The newly created Theme container.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The late version adds a block of code within the synchronized statement that removes garbage-collected themes from mThemeRefs, but it doesn't affect the returned value or the exception handling. So the code change type is 4.","There is no change in the type or the value being returned by the method, and the exception handling behavior remains unchanged, so there is no compatibility issue detected. The CI type is 0."
463,<android.bluetooth.le.AdvertisingSetParameters.Builder: Builder setTxPowerLevel(int)>,27,28,<android.bluetooth.le.AdvertisingSetParameters.Builder: Builder setTxPowerLevel(int)>,<android.bluetooth.le.AdvertisingSetParameters.Builder: Builder setTxPowerLevel(int)>,0,"{
    if (txPowerLevel < TX_POWER_MIN || txPowerLevel > TX_POWER_MAX) {
        throw new IllegalArgumentException(""unknown txPowerLevel "" + txPowerLevel);
    }
    this.txPowerLevel = txPowerLevel;
    return this;
}","{
    if (txPowerLevel < TX_POWER_MIN || txPowerLevel > TX_POWER_MAX) {
        throw new IllegalArgumentException(""unknown txPowerLevel "" + txPowerLevel);
    }
    mTxPowerLevel = txPowerLevel;
    return this;
}",1,"/**
 * Set the transmission power level for the advertising.
 * @param txPowerLevel Transmission power of Bluetooth LE Advertising, in
 * dBm. The valid range is [-127, 1] Recommended values are:
 * {@link AdvertisingSetParameters#TX_POWER_ULTRA_LOW},
 * {@link AdvertisingSetParameters#TX_POWER_LOW},
 * {@link AdvertisingSetParameters#TX_POWER_MEDIUM}, or
 * {@link AdvertisingSetParameters#TX_POWER_HIGH}.
 *
 * @throws IllegalArgumentException If the {@code txPowerLevel} is invalid.
 */
","/**
 * Set the transmission power level for the advertising.
 *
 * @param txPowerLevel Transmission power of Bluetooth LE Advertising, in dBm. The valid
 * range is [-127, 1] Recommended values are:
 * {@link AdvertisingSetParameters#TX_POWER_ULTRA_LOW},
 * {@link AdvertisingSetParameters#TX_POWER_LOW},
 * {@link AdvertisingSetParameters#TX_POWER_MEDIUM},
 * or {@link AdvertisingSetParameters#TX_POWER_HIGH}.
 * @throws IllegalArgumentException If the {@code txPowerLevel} is invalid.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The implementation change is the renaming of a field from `this.txPowerLevel` to `mTxPowerLevel`. This is an internal change and does not affect the method's external behavior (assuming the field represents the same data and is just renamed), so the change type is 4.","There is no compatibility issue as the method signature, logic, and exception behavior remain the same. The method consistently throws the same exception under the same conditions and returns the same type (`this`). Thus, the CI type is 0."
464,<android.text.format.DateFormat: DateFormat getDateFormat(Context)>,27,28,<android.text.format.DateFormat: DateFormat getDateFormat(Context)>,<android.text.format.DateFormat: DateFormat getDateFormat(Context)>,0,"{
    return java.text.DateFormat.getDateInstance(java.text.DateFormat.SHORT);
}","{
    final Locale locale = context.getResources().getConfiguration().locale;
    return java.text.DateFormat.getDateInstance(java.text.DateFormat.SHORT, locale);
}",1,"/**
 * Returns a {@link java.text.DateFormat} object that can format the date
 * in short form according to the current locale.
 *
 * @param context the application context
 * @return the {@link java.text.DateFormat} object that properly formats the date.
 */
","/**
 * Returns a {@link java.text.DateFormat} object that can format the date
 * in short form according to the context's locale.
 *
 * @param context the application context
 * @return the {@link java.text.DateFormat} object that properly formats the date.
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,1,"The method call within the return statement now takes an additional argument, 'locale', which is obtained from the context in the late version. Hence, the dependent API has been changed, making the change type 5.","Since the format of the returned 'DateFormat' will now be sensitive to the locale of the context provided, different results may be returned when calling this method with different contexts. This constitutes a compatibility issue due to potential different return values, categorizing this as type 1."
465,<android.app.NotificationChannelGroup: String toString()>,27,28,<android.app.NotificationChannelGroup: String toString()>,<android.app.NotificationChannelGroup: String toString()>,0,"{
    return ""NotificationChannelGroup{"" + ""mId='"" + mId + '\'' + "", mName="" + mName + "", mChannels="" + mChannels + '}';
}","{
    return ""NotificationChannelGroup{"" + ""mId='"" + mId + '\'' + "", mName="" + mName + "", mDescription="" + (!TextUtils.isEmpty(mDescription) ? ""hasDescription "" : """") + "", mBlocked="" + mBlocked + "", mChannels="" + mChannels + '}';
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,1,"The toString method has been altered to include more fields in the output string (`mDescription` and `mBlocked`). Therefore, there is a code change that affects the method's output, and the specific change type is 4.","Since the output of the toString method is different between the two versions (more information is included in the late version), calling this method on an object of `NotificationChannelGroup` will return a different value in the late version compared to the early version. This is categorized under CI type 1 due to the potential for different return values."
466,<android.speech.tts.SynthesisPlaybackQueueItem: void run()>,27,28,<android.speech.tts.SynthesisPlaybackQueueItem: void run()>,<android.speech.tts.SynthesisPlaybackQueueItem: void run()>,0,"{
    final UtteranceProgressDispatcher dispatcher = getDispatcher();
    dispatcher.dispatchOnStart();
    if (!mAudioTrack.init()) {
        dispatcher.dispatchOnError(TextToSpeech.ERROR_OUTPUT);
        return;
    }
    mAudioTrack.setPlaybackPositionUpdateListener(this);
    // Ensure we set the first marker if there is one.
    updateMarker();
    try {
        byte[] buffer = null;
        // OR (c) done() is called in which case it will return null.
        while ((buffer = take()) != null) {
            mAudioTrack.write(buffer);
            mLogger.onAudioDataWritten();
        }
    } catch (InterruptedException ie) {
        if (DBG)
            Log.d(TAG, ""Interrupted waiting for buffers, cleaning up."");
    }
    mAudioTrack.waitAndRelease();
    if (mStatusCode == TextToSpeech.SUCCESS) {
        dispatcher.dispatchOnSuccess();
    } else if (mStatusCode == TextToSpeech.STOPPED) {
        dispatcher.dispatchOnStop();
    } else {
        dispatcher.dispatchOnError(mStatusCode);
    }
    mLogger.onCompleted(mStatusCode);
}","{
    if (!mRunState.compareAndSet(NOT_RUN, RUN_CALLED)) {
        // stop() was already called before run(). Do nothing and just finish.
        return;
    }
    final UtteranceProgressDispatcher dispatcher = getDispatcher();
    dispatcher.dispatchOnStart();
    if (!mAudioTrack.init()) {
        dispatcher.dispatchOnError(TextToSpeech.ERROR_OUTPUT);
        return;
    }
    mAudioTrack.setPlaybackPositionUpdateListener(this);
    // Ensure we set the first marker if there is one.
    updateMarker();
    try {
        byte[] buffer = null;
        // OR (c) done() is called in which case it will return null.
        while ((buffer = take()) != null) {
            mAudioTrack.write(buffer);
            mLogger.onAudioDataWritten();
        }
    } catch (InterruptedException ie) {
        if (DBG)
            Log.d(TAG, ""Interrupted waiting for buffers, cleaning up."");
    }
    mAudioTrack.waitAndRelease();
    dispatchEndStatus();
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,3,4","1,2","The method in the late version introduces a new 'if' control check with a return statement at the beginning and replaces the condition after 'while' and the final status dispatching block with a call to `dispatchEndStatus()`. Additionally, there is a change in how the method starts its execution due to the check for `mRunState.compareAndSet(NOT_RUN, RUN_CALLED)`. The code change type is 1,3,4 due to the new return statement, new control check, and change in other non-control statements.",There is a potential change in behavior leading to a CI because:
467,"<android.content.res.ResourcesImpl.ThemeImpl: TypedArray obtainStyledAttributes(Theme,AttributeSet,int[],int,int)>",27,28,"<android.content.res.ResourcesImpl.ThemeImpl: TypedArray obtainStyledAttributes(Theme,AttributeSet,int[],int,int)>","<android.content.res.ResourcesImpl.ThemeImpl: TypedArray obtainStyledAttributes(Theme,AttributeSet,int[],int,int)>",0,"{
    synchronized (mKey) {
        final int len = attrs.length;
        final TypedArray array = TypedArray.obtain(wrapper.getResources(), len);
        // XXX note that for now we only work with compiled XML files.
        // To support generic XML files we will need to manually parse
        // out the attributes from the XML file (applying type information
        // contained in the resources and such).
        final XmlBlock.Parser parser = (XmlBlock.Parser) set;
        AssetManager.applyStyle(mTheme, defStyleAttr, defStyleRes, parser != null ? parser.mParseState : 0, attrs, attrs.length, array.mDataAddress, array.mIndicesAddress);
        array.mTheme = wrapper;
        array.mXml = parser;
        return array;
    }
}","{
    synchronized (mKey) {
        final int len = attrs.length;
        final TypedArray array = TypedArray.obtain(wrapper.getResources(), len);
        // XXX note that for now we only work with compiled XML files.
        // To support generic XML files we will need to manually parse
        // out the attributes from the XML file (applying type information
        // contained in the resources and such).
        final XmlBlock.Parser parser = (XmlBlock.Parser) set;
        mAssets.applyStyle(mTheme, defStyleAttr, defStyleRes, parser, attrs, array.mDataAddress, array.mIndicesAddress);
        array.mTheme = wrapper;
        array.mXml = parser;
        return array;
    }
}",1,,,-1,[@NonNull],[@NonNull],-1,-1,-1,-1,-1,-1,5,0,"`AssetManager.applyStyle(...)` has been changed to `mAssets.applyStyle(...)`, which indicates a change in the dependent API being called. This is thus a type 5 change.","Since there's no indication that the behavior of `applyStyle` has changed, merely the instance on which it is called, there are no changes that affect the return values or exception handling of the method directly. Therefore, there is no compatibility issue."
468,<android.view.inputmethod.InputMethodManager.H: void handleMessage(Message)>,27,28,<android.view.inputmethod.InputMethodManager.H: void handleMessage(Message)>,<android.view.inputmethod.InputMethodManager.H: void handleMessage(Message)>,0,"{
    switch(msg.what) {
        case MSG_DUMP:
            {
                SomeArgs args = (SomeArgs) msg.obj;
                try {
                    doDump((FileDescriptor) args.arg1, (PrintWriter) args.arg2, (String[]) args.arg3);
                } catch (RuntimeException e) {
                    ((PrintWriter) args.arg2).println(""Exception: "" + e);
                }
                synchronized (args.arg4) {
                    ((CountDownLatch) args.arg4).countDown();
                }
                args.recycle();
                return;
            }
        case MSG_BIND:
            {
                final InputBindResult res = (InputBindResult) msg.obj;
                if (DEBUG) {
                    Log.i(TAG, ""handleMessage: MSG_BIND "" + res.sequence + "","" + res.id);
                }
                synchronized (mH) {
                    if (mBindSequence < 0 || mBindSequence != res.sequence) {
                        Log.w(TAG, ""Ignoring onBind: cur seq="" + mBindSequence + "", given seq="" + res.sequence);
                        if (res.channel != null && res.channel != mCurChannel) {
                            res.channel.dispose();
                        }
                        return;
                    }
                    mRequestUpdateCursorAnchorInfoMonitorMode = REQUEST_UPDATE_CURSOR_ANCHOR_INFO_NONE;
                    setInputChannelLocked(res.channel);
                    mCurMethod = res.method;
                    mCurId = res.id;
                    mBindSequence = res.sequence;
                }
                startInputInner(InputMethodClient.START_INPUT_REASON_BOUND_TO_IMMS, null, 0, 0, 0);
                return;
            }
        case MSG_UNBIND:
            {
                final int sequence = msg.arg1;
                @InputMethodClient.UnbindReason final int reason = msg.arg2;
                if (DEBUG) {
                    Log.i(TAG, ""handleMessage: MSG_UNBIND "" + sequence + "" reason="" + InputMethodClient.getUnbindReason(reason));
                }
                final boolean startInput;
                synchronized (mH) {
                    if (mBindSequence != sequence) {
                        return;
                    }
                    clearBindingLocked();
                    // we would like to re-connect to the next input method.
                    if (mServedView != null && mServedView.isFocused()) {
                        mServedConnecting = true;
                    }
                    startInput = mActive;
                }
                if (startInput) {
                    startInputInner(InputMethodClient.START_INPUT_REASON_UNBOUND_FROM_IMMS, null, 0, 0, 0);
                }
                return;
            }
        case MSG_SET_ACTIVE:
            {
                final boolean active = msg.arg1 != 0;
                final boolean fullscreen = msg.arg2 != 0;
                if (DEBUG) {
                    Log.i(TAG, ""handleMessage: MSG_SET_ACTIVE "" + active + "", was "" + mActive);
                }
                synchronized (mH) {
                    mActive = active;
                    mFullscreenMode = fullscreen;
                    if (!active) {
                        // Some other client has starting using the IME, so note
                        // that this happened and make sure our own editor's
                        // state is reset.
                        mHasBeenInactive = true;
                        try {
                            // Note that finishComposingText() is allowed to run
                            // even when we are not active.
                            mIInputContext.finishComposingText();
                        } catch (RemoteException e) {
                        }
                    }
                    // handling this message.
                    if (mServedView != null && mServedView.hasWindowFocus()) {
                        if (checkFocusNoStartInput(mHasBeenInactive)) {
                            final int reason = active ? InputMethodClient.START_INPUT_REASON_ACTIVATED_BY_IMMS : InputMethodClient.START_INPUT_REASON_DEACTIVATED_BY_IMMS;
                            startInputInner(reason, null, 0, 0, 0);
                        }
                    }
                }
                return;
            }
        case MSG_SEND_INPUT_EVENT:
            {
                sendInputEventAndReportResultOnMainLooper((PendingEvent) msg.obj);
                return;
            }
        case MSG_TIMEOUT_INPUT_EVENT:
            {
                finishedInputEvent(msg.arg1, false, true);
                return;
            }
        case MSG_FLUSH_INPUT_EVENT:
            {
                finishedInputEvent(msg.arg1, false, false);
                return;
            }
        case MSG_SET_USER_ACTION_NOTIFICATION_SEQUENCE_NUMBER:
            {
                synchronized (mH) {
                    mNextUserActionNotificationSequenceNumber = msg.arg1;
                }
                return;
            }
        case MSG_REPORT_FULLSCREEN_MODE:
            {
                final boolean fullscreen = msg.arg1 != 0;
                InputConnection ic = null;
                synchronized (mH) {
                    mFullscreenMode = fullscreen;
                    if (mServedInputConnectionWrapper != null) {
                        ic = mServedInputConnectionWrapper.getInputConnection();
                    }
                }
                if (ic != null) {
                    ic.reportFullscreenMode(fullscreen);
                }
                return;
            }
    }
}","{
    switch(msg.what) {
        case MSG_DUMP:
            {
                SomeArgs args = (SomeArgs) msg.obj;
                try {
                    doDump((FileDescriptor) args.arg1, (PrintWriter) args.arg2, (String[]) args.arg3);
                } catch (RuntimeException e) {
                    ((PrintWriter) args.arg2).println(""Exception: "" + e);
                }
                synchronized (args.arg4) {
                    ((CountDownLatch) args.arg4).countDown();
                }
                args.recycle();
                return;
            }
        case MSG_BIND:
            {
                final InputBindResult res = (InputBindResult) msg.obj;
                if (DEBUG) {
                    Log.i(TAG, ""handleMessage: MSG_BIND "" + res.sequence + "","" + res.id);
                }
                synchronized (mH) {
                    if (mBindSequence < 0 || mBindSequence != res.sequence) {
                        Log.w(TAG, ""Ignoring onBind: cur seq="" + mBindSequence + "", given seq="" + res.sequence);
                        if (res.channel != null && res.channel != mCurChannel) {
                            res.channel.dispose();
                        }
                        return;
                    }
                    mRequestUpdateCursorAnchorInfoMonitorMode = REQUEST_UPDATE_CURSOR_ANCHOR_INFO_NONE;
                    setInputChannelLocked(res.channel);
                    mCurMethod = res.method;
                    mCurId = res.id;
                    mBindSequence = res.sequence;
                }
                startInputInner(InputMethodClient.START_INPUT_REASON_BOUND_TO_IMMS, null, 0, 0, 0);
                return;
            }
        case MSG_UNBIND:
            {
                final int sequence = msg.arg1;
                @InputMethodClient.UnbindReason final int reason = msg.arg2;
                if (DEBUG) {
                    Log.i(TAG, ""handleMessage: MSG_UNBIND "" + sequence + "" reason="" + InputMethodClient.getUnbindReason(reason));
                }
                final boolean startInput;
                synchronized (mH) {
                    if (mBindSequence != sequence) {
                        return;
                    }
                    clearBindingLocked();
                    // we would like to re-connect to the next input method.
                    if (mServedView != null && mServedView.isFocused()) {
                        mServedConnecting = true;
                    }
                    startInput = mActive;
                }
                if (startInput) {
                    startInputInner(InputMethodClient.START_INPUT_REASON_UNBOUND_FROM_IMMS, null, 0, 0, 0);
                }
                return;
            }
        case MSG_SET_ACTIVE:
            {
                final boolean active = msg.arg1 != 0;
                final boolean fullscreen = msg.arg2 != 0;
                if (DEBUG) {
                    Log.i(TAG, ""handleMessage: MSG_SET_ACTIVE "" + active + "", was "" + mActive);
                }
                synchronized (mH) {
                    mActive = active;
                    mFullscreenMode = fullscreen;
                    if (!active) {
                        // Some other client has starting using the IME, so note
                        // that this happened and make sure our own editor's
                        // state is reset.
                        mRestartOnNextWindowFocus = true;
                        try {
                            // Note that finishComposingText() is allowed to run
                            // even when we are not active.
                            mIInputContext.finishComposingText();
                        } catch (RemoteException e) {
                        }
                    }
                    // handling this message.
                    if (mServedView != null && canStartInput(mServedView)) {
                        if (checkFocusNoStartInput(mRestartOnNextWindowFocus)) {
                            final int reason = active ? InputMethodClient.START_INPUT_REASON_ACTIVATED_BY_IMMS : InputMethodClient.START_INPUT_REASON_DEACTIVATED_BY_IMMS;
                            startInputInner(reason, null, 0, 0, 0);
                        }
                    }
                }
                return;
            }
        case MSG_SEND_INPUT_EVENT:
            {
                sendInputEventAndReportResultOnMainLooper((PendingEvent) msg.obj);
                return;
            }
        case MSG_TIMEOUT_INPUT_EVENT:
            {
                finishedInputEvent(msg.arg1, false, true);
                return;
            }
        case MSG_FLUSH_INPUT_EVENT:
            {
                finishedInputEvent(msg.arg1, false, false);
                return;
            }
        case MSG_SET_USER_ACTION_NOTIFICATION_SEQUENCE_NUMBER:
            {
                synchronized (mH) {
                    mNextUserActionNotificationSequenceNumber = msg.arg1;
                }
                return;
            }
        case MSG_REPORT_FULLSCREEN_MODE:
            {
                final boolean fullscreen = msg.arg1 != 0;
                InputConnection ic = null;
                synchronized (mH) {
                    mFullscreenMode = fullscreen;
                    if (mServedInputConnectionWrapper != null) {
                        ic = mServedInputConnectionWrapper.getInputConnection();
                    }
                }
                if (ic != null) {
                    ic.reportFullscreenMode(fullscreen);
                }
                return;
            }
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,,,,
469,"<android.app.Activity: PendingIntent createPendingResult(int,Intent,int)>",27,28,"<android.app.Activity: PendingIntent createPendingResult(int,Intent,int)>","<android.app.Activity: PendingIntent createPendingResult(int,Intent,int)>",0,"{
    String packageName = getPackageName();
    try {
        data.prepareToLeaveProcess(this);
        IIntentSender target = ActivityManager.getService().getIntentSender(ActivityManager.INTENT_SENDER_ACTIVITY_RESULT, packageName, mParent == null ? mToken : mParent.mToken, mEmbeddedID, requestCode, new Intent[] { data }, null, flags, null, UserHandle.myUserId());
        return target != null ? new PendingIntent(target) : null;
    } catch (RemoteException e) {
    // Empty
    }
    return null;
}","{
    String packageName = getPackageName();
    try {
        data.prepareToLeaveProcess(this);
        IIntentSender target = ActivityManager.getService().getIntentSender(ActivityManager.INTENT_SENDER_ACTIVITY_RESULT, packageName, mParent == null ? mToken : mParent.mToken, mEmbeddedID, requestCode, new Intent[] { data }, null, flags, null, getUserId());
        return target != null ? new PendingIntent(target) : null;
    } catch (RemoteException e) {
    // Empty
    }
    return null;
}",1,"/**
 * Create a new PendingIntent object which you can hand to others
 * for them to use to send result data back to your
 * {@link #onActivityResult} callback.  The created object will be either
 * one-shot (becoming invalid after a result is sent back) or multiple
 * (allowing any number of results to be sent through it).
 *
 * @param requestCode Private request code for the sender that will be
 * associated with the result data when it is returned.  The sender can not
 * modify this value, allowing you to identify incoming results.
 * @param data Default data to supply in the result, which may be modified
 * by the sender.
 * @param flags May be {@link PendingIntent#FLAG_ONE_SHOT PendingIntent.FLAG_ONE_SHOT},
 * {@link PendingIntent#FLAG_NO_CREATE PendingIntent.FLAG_NO_CREATE},
 * {@link PendingIntent#FLAG_CANCEL_CURRENT PendingIntent.FLAG_CANCEL_CURRENT},
 * {@link PendingIntent#FLAG_UPDATE_CURRENT PendingIntent.FLAG_UPDATE_CURRENT},
 * or any of the flags as supported by
 * {@link Intent#fillIn Intent.fillIn()} to control which unspecified parts
 * of the intent that can be supplied when the actual send happens.
 *
 * @return Returns an existing or new PendingIntent matching the given
 * parameters.  May return null only if
 * {@link PendingIntent#FLAG_NO_CREATE PendingIntent.FLAG_NO_CREATE} has been
 * supplied.
 *
 * @see PendingIntent
 */
","/**
 * Create a new PendingIntent object which you can hand to others
 * for them to use to send result data back to your
 * {@link #onActivityResult} callback.  The created object will be either
 * one-shot (becoming invalid after a result is sent back) or multiple
 * (allowing any number of results to be sent through it).
 *
 * @param requestCode Private request code for the sender that will be
 * associated with the result data when it is returned.  The sender can not
 * modify this value, allowing you to identify incoming results.
 * @param data Default data to supply in the result, which may be modified
 * by the sender.
 * @param flags May be {@link PendingIntent#FLAG_ONE_SHOT PendingIntent.FLAG_ONE_SHOT},
 * {@link PendingIntent#FLAG_NO_CREATE PendingIntent.FLAG_NO_CREATE},
 * {@link PendingIntent#FLAG_CANCEL_CURRENT PendingIntent.FLAG_CANCEL_CURRENT},
 * {@link PendingIntent#FLAG_UPDATE_CURRENT PendingIntent.FLAG_UPDATE_CURRENT},
 * or any of the flags as supported by
 * {@link Intent#fillIn Intent.fillIn()} to control which unspecified parts
 * of the intent that can be supplied when the actual send happens.
 *
 * @return Returns an existing or new PendingIntent matching the given
 * parameters.  May return null only if
 * {@link PendingIntent#FLAG_NO_CREATE PendingIntent.FLAG_NO_CREATE} has been
 * supplied.
 *
 * @see PendingIntent
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The implementation change between the early version and late version is the call to `UserHandle.myUserId()` which has been replaced with `getUserId()`. This indicates a change in how the user ID is obtained, and since this ID is used as a parameter in a method call, it is a dependent API change. Hence, the change type is 5.","The change does not affect the returned value of the method or the exceptions it may throw. The behavior change only pertains to how the user ID is retrieved, which does not constitute an observable change in behavior of the `createPendingResult` method itself. Therefore, there is no Compatibility Issue, and the CI type is 0."
471,"<android.provider.Settings.Secure: boolean putString(ContentResolver,String,String)>",27,28,"<android.provider.Settings.Secure: boolean putString(ContentResolver,String,String)>","<android.provider.Settings.Secure: boolean putString(ContentResolver,String,String)>",0,"{
    return putStringForUser(resolver, name, value, UserHandle.myUserId());
}","{
    return putStringForUser(resolver, name, value, resolver.getUserId());
}",1,"/**
 * Store a name/value pair into the database.
 * @param resolver to access the database with
 * @param name to store
 * @param value to associate with the name
 * @return true if the value was set, false on database errors
 */
","/**
 * Store a name/value pair into the database.
 * @param resolver to access the database with
 * @param name to store
 * @param value to associate with the name
 * @return true if the value was set, false on database errors
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The implementation of putString has been changed by replacing UserHandle.myUserId() with resolver.getUserId() for getting user ID, indicating there has been a modification in the way the user ID is retrieved, which is a dependent API change, so the code change type is 5.","Since the change is related to how the user ID is fetched and does not inherently affect what the method returns or the exception it may throw (assuming resolver.getUserId() is an equivalent call to UserHandle.myUserId() for the user associated with the resolver), there is no compatibility issue expected here; therefore, the CI type is 0."
472,"<android.accounts.AccountManager: AccountManagerFuture<Bundle> finishSession(Bundle,Activity,AccountManagerCallback<Bundle>,Handler)>",27,28,"<android.accounts.AccountManager: AccountManagerFuture<Bundle> finishSession(Bundle,Activity,AccountManagerCallback<Bundle>,Handler)>","<android.accounts.AccountManager: AccountManagerFuture<Bundle> finishSession(Bundle,Activity,AccountManagerCallback<Bundle>,Handler)>",0,"{
    return finishSessionAsUser(sessionBundle, activity, Process.myUserHandle(), callback, handler);
}","{
    return finishSessionAsUser(sessionBundle, activity, mContext.getUser(), callback, handler);
}",1,"/**
 * Finishes the session started by {@link #startAddAccountSession} or
 * {@link #startUpdateCredentialsSession}. This will either add the account
 * to AccountManager or update the local credentials stored.
 * <p>
 * This method may be called from any thread, but the returned
 * {@link AccountManagerFuture} must not be used on the main thread.
 *
 * @param sessionBundle a {@link Bundle} created by {@link #startAddAccountSession} or
 * {@link #startUpdateCredentialsSession}
 * @param activity The {@link Activity} context to use for launching a new
 * authenticator-defined sub-Activity to prompt the user to
 * create an account or reauthenticate existing account; used
 * only to call startActivity(); if null, the prompt will not
 * be launched directly, but the necessary {@link Intent} will
 * be returned to the caller instead
 * @param callback Callback to invoke when the request completes, null for
 * no callback
 * @param handler {@link Handler} identifying the callback thread, null for
 * the main thread
 * @return An {@link AccountManagerFuture} which resolves to a Bundle with
 * these fields if an activity was supplied and an account was added
 * to device or local credentials were updated::
 * <ul>
 * <li>{@link #KEY_ACCOUNT_NAME} - the name of the account created
 * <li>{@link #KEY_ACCOUNT_TYPE} - the type of the account
 * <li>{@link #KEY_ACCOUNT_STATUS_TOKEN} - optional, token to check
 * status of the account
 * </ul>
 * If no activity was specified and additional information is needed
 * from user, the returned Bundle may contains only
 * {@link #KEY_INTENT} with the {@link Intent} needed to launch the
 * actual account creation process. If an error occurred,
 * {@link AccountManagerFuture#getResult()} throws:
 * <ul>
 * <li>{@link AuthenticatorException} if no authenticator was
 * registered for this account type or the authenticator failed to
 * respond
 * <li>{@link OperationCanceledException} if the operation was
 * canceled for any reason, including the user canceling the
 * creation process or adding accounts (of this type) has been
 * disabled by policy
 * <li>{@link IOException} if the authenticator experienced an I/O
 * problem creating a new account, usually because of network
 * trouble
 * </ul>
 * @see #startAddAccountSession and #startUpdateCredentialsSession
 */
","/**
 * Finishes the session started by {@link #startAddAccountSession} or
 * {@link #startUpdateCredentialsSession}. This will either add the account
 * to AccountManager or update the local credentials stored.
 * <p>
 * This method may be called from any thread, but the returned
 * {@link AccountManagerFuture} must not be used on the main thread.
 *
 * @param sessionBundle a {@link Bundle} created by {@link #startAddAccountSession} or
 * {@link #startUpdateCredentialsSession}
 * @param activity The {@link Activity} context to use for launching a new
 * authenticator-defined sub-Activity to prompt the user to
 * create an account or reauthenticate existing account; used
 * only to call startActivity(); if null, the prompt will not
 * be launched directly, but the necessary {@link Intent} will
 * be returned to the caller instead
 * @param callback Callback to invoke when the request completes, null for
 * no callback
 * @param handler {@link Handler} identifying the callback thread, null for
 * the main thread
 * @return An {@link AccountManagerFuture} which resolves to a Bundle with
 * these fields if an activity was supplied and an account was added
 * to device or local credentials were updated::
 * <ul>
 * <li>{@link #KEY_ACCOUNT_NAME} - the name of the account created
 * <li>{@link #KEY_ACCOUNT_TYPE} - the type of the account
 * <li>{@link #KEY_ACCOUNT_STATUS_TOKEN} - optional, token to check
 * status of the account
 * </ul>
 * If no activity was specified and additional information is needed
 * from user, the returned Bundle may contains only
 * {@link #KEY_INTENT} with the {@link Intent} needed to launch the
 * actual account creation process. If an error occurred,
 * {@link AccountManagerFuture#getResult()} throws:
 * <ul>
 * <li>{@link AuthenticatorException} if no authenticator was
 * registered for this account type or the authenticator failed to
 * respond
 * <li>{@link OperationCanceledException} if the operation was
 * canceled for any reason, including the user canceling the
 * creation process or adding accounts (of this type) has been
 * disabled by policy
 * <li>{@link IOException} if the authenticator experienced an I/O
 * problem creating a new account, usually because of network
 * trouble
 * </ul>
 * @see #startAddAccountSession and #startUpdateCredentialsSession
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The method finishSessionAsUser() is called with different parameters: Process.myUserHandle() is replaced by mContext.getUser(), so the change is of type 5.","Since the only change is the parameter used in calling the dependent API finishSessionAsUser(), and assuming that mContext.getUser() returns the appropriate UserHandle for the context in which AccountManager is operating (which should be equivalent to Process.myUserHandle() for the context's user), there's no indication that this change would lead to different behaviors. Hence, there is no compatibility issue, and the CI type is 0."
473,<android.view.accessibility.AccessibilityManager: List<AccessibilityServiceInfo> getInstalledAccessibilityServiceList()>,27,28,<android.view.accessibility.AccessibilityManager: List<AccessibilityServiceInfo> getInstalledAccessibilityServiceList()>,<android.view.accessibility.AccessibilityManager: List<AccessibilityServiceInfo> getInstalledAccessibilityServiceList()>,0,"{
    final IAccessibilityManager service;
    final int userId;
    synchronized (mLock) {
        service = getServiceLocked();
        if (service == null) {
            return Collections.emptyList();
        }
        userId = mUserId;
    }
    List<AccessibilityServiceInfo> services = null;
    try {
        services = service.getInstalledAccessibilityServiceList(userId);
        if (DEBUG) {
            Log.i(LOG_TAG, ""Installed AccessibilityServices "" + services);
        }
    } catch (RemoteException re) {
        Log.e(LOG_TAG, ""Error while obtaining the installed AccessibilityServices. "", re);
    }
    if (services != null) {
        return Collections.unmodifiableList(services);
    } else {
        return Collections.emptyList();
    }
}","{
    final IAccessibilityManager service;
    final int userId;
    synchronized (mLock) {
        service = getServiceLocked();
        if (service == null) {
            return Collections.emptyList();
        }
        userId = mUserId;
    }
    List<AccessibilityServiceInfo> services = null;
    try {
        services = service.getInstalledAccessibilityServiceList(userId);
        if (DEBUG) {
            Log.i(LOG_TAG, ""Installed AccessibilityServices "" + services);
        }
    } catch (RemoteException re) {
        Log.e(LOG_TAG, ""Error while obtaining the installed AccessibilityServices. "", re);
    }
    if (mAccessibilityPolicy != null) {
        services = mAccessibilityPolicy.getInstalledAccessibilityServiceList(services);
    }
    if (services != null) {
        return Collections.unmodifiableList(services);
    } else {
        return Collections.emptyList();
    }
}",1,"/**
 * Returns the {@link AccessibilityServiceInfo}s of the installed accessibility services.
 *
 * @return An unmodifiable list with {@link AccessibilityServiceInfo}s.
 */
","/**
 * Returns the {@link AccessibilityServiceInfo}s of the installed accessibility services.
 *
 * @return An unmodifiable list with {@link AccessibilityServiceInfo}s.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",0,"The code has introduced a new control dependency related to the mAccessibilityPolicy object and an additional method call on that object has been included. This results in a change type of 3. There is also a new statement with a method call which is an 'Other statement changed', thus the change type is also 4.","The change does not cause a Compatibility Issue because the list of services is potentially being filtered or altered by the policy, but since the function is expected to return a list of installed accessibility services, it is still doing so. The potential alteration is part of intended behavior to allow for policy-based control over the services returned. Therefore, there is no guaranteed difference in return value or types, and no difference in exception handling. The change is an additional layer of policy application, which is an expected extension of functionality within the framework's operation model, not something that would constitute a compatibility breach as per the provided definitions."
474,<android.bluetooth.le.AdvertisingSet: void setPeriodicAdvertisingParameters(PeriodicAdvertisingParameters)>,27,28,<android.bluetooth.le.AdvertisingSet: void setPeriodicAdvertisingParameters(PeriodicAdvertisingParameters)>,<android.bluetooth.le.AdvertisingSet: void setPeriodicAdvertisingParameters(PeriodicAdvertisingParameters)>,0,"{
    try {
        gatt.setPeriodicAdvertisingParameters(this.advertiserId, parameters);
    } catch (RemoteException e) {
        Log.e(TAG, ""remote exception - "", e);
    }
}","{
    try {
        mGatt.setPeriodicAdvertisingParameters(mAdvertiserId, parameters);
    } catch (RemoteException e) {
        Log.e(TAG, ""remote exception - "", e);
    }
}",1,"/**
 * Update periodic advertising parameters associated with this set. Must be called when
 * periodic advertising is not enabled. This method returns immediately, the operation
 * status is delivered through {@code callback.onPeriodicAdvertisingParametersUpdated()}.
 */
","/**
 * Update periodic advertising parameters associated with this set. Must be called when
 * periodic advertising is not enabled. This method returns immediately, the operation
 * status is delivered through {@code callback.onPeriodicAdvertisingParametersUpdated()}.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The only change is the renaming of private fields from `gatt` to `mGatt` and `advertiserId` to `mAdvertiserId`. Since this is an internal change and does not affect the signature of Dependent APIs nor the behavior of the method itself, the code change type is 4.",There is no Compatibility Issue because the behavior of the method did not change; it still catches `RemoteException` and logs it without altering the method's logic or control flow. The renaming of fields does not impact API users.
476,<android.app.assist.AssistStructure.ViewNodeBuilder: void setWebDomain(String)>,27,28,<android.app.assist.AssistStructure.ViewNodeBuilder: void setWebDomain(String)>,<android.app.assist.AssistStructure.ViewNodeBuilder: void setWebDomain(String)>,0,"{
    if (domain == null) {
        mNode.mWebDomain = null;
        return;
    }
    mNode.mWebDomain = Uri.parse(domain).getHost();
}","{
    mNode.setWebDomain(domain);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,5,0,"The implementation of the method has been simplified by using another method (mNode.setWebDomain(domain)) instead of the inline implementation. Thus, the change type is 5.","As long as the behavior of mNode.setWebDomain(domain) is consistent with the inline code that it replaces, this refactoring would not cause a CI. Therefore, there is no compatibility issue."
478,<android.app.Notification.Action: Action clone()>,27,28,<android.app.Notification.Action: Action clone()>,<android.app.Notification.Action: Action clone()>,0,"{
    return new Action(getIcon(), title, // safe to alias
    actionIntent, mExtras == null ? new Bundle() : new Bundle(mExtras), getRemoteInputs(), getAllowGeneratedReplies());
}","{
    return new Action(getIcon(), title, // safe to alias
    actionIntent, mExtras == null ? new Bundle() : new Bundle(mExtras), getRemoteInputs(), getAllowGeneratedReplies(), getSemanticAction());
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,5",1,"The constructor for creating a new Action object has an additional parameter in the late version (getSemanticAction()), which indicates a change in the dependent API, so the change types are 1,5.","Since the constructor for creating a new Action object has an additional parameter, the created object may differ in the late version due to the inclusion of 'semanticAction'. This is a potential source for a different return value, so the CI type is 1."
479,<android.content.ContentResolver: List<SyncInfo> getCurrentSyncs()>,27,28,<android.content.ContentResolver: List<SyncInfo> getCurrentSyncs()>,<android.content.ContentResolver: List<SyncInfo> getCurrentSyncs()>,0,"{
    try {
        return getContentService().getCurrentSyncs();
    } catch (RemoteException e) {
        throw new RuntimeException(""the ContentService should always be reachable"", e);
    }
}","{
    try {
        return getContentService().getCurrentSyncs();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Returns a list with information about all the active syncs. This list will be empty
 * if there are no active syncs.
 * <p>
 * This method requires the caller to hold the permission
 * {@link android.Manifest.permission#READ_SYNC_STATS}.
 * <p>
 * @return a List of SyncInfo objects for the currently active syncs.
 */
","/**
 * Returns a list with information about all the active syncs. This list will be empty
 * if there are no active syncs.
 * <p>
 * This method requires the caller to hold the permission
 * {@link android.Manifest.permission#READ_SYNC_STATS}.
 * <p>
 * @return a List of SyncInfo objects for the currently active syncs.
 */
",-1,,,-1,-1,-1,-1,-1,-1,2,2,"The exception handling statement has changed from throwing a new RuntimeException to throwing the exception from the system server by calling e.rethrowFromSystemServer(), so the code change type is 2.","The change in exception handling could lead to a different type of exception being thrown, therefore it is a Compatibility Issue of type 2."
480,<android.inputmethodservice.InputMethodService: void setBackDisposition(int)>,27,28,<android.inputmethodservice.InputMethodService: void setBackDisposition(int)>,<android.inputmethodservice.InputMethodService: void setBackDisposition(int)>,0,"{
    mBackDisposition = disposition;
}","{
    if (disposition == mBackDisposition) {
        return;
    }
    if (disposition > BACK_DISPOSITION_MAX || disposition < BACK_DISPOSITION_MIN) {
        Log.e(TAG, ""Invalid back disposition value ("" + disposition + "") specified."");
        return;
    }
    mBackDisposition = disposition;
    mImm.setImeWindowStatus(mToken, mStartInputToken, mapToImeWindowStatus(isInputViewShown()), mBackDisposition);
}",1,,"/**
 * Sets the disposition mode that indicates the expected affordance for the back button.
 *
 * <p>Keep in mind that specifying this flag does not change the the default behavior of
 * {@link #onKeyDown(int, KeyEvent)}.  It is IME developers' responsibility for making sure that
 * their custom implementation of {@link #onKeyDown(int, KeyEvent)} is consistent with the mode
 * specified to this API.</p>
 *
 * @see #getBackDisposition()
 * @param disposition disposition mode to be set
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",0,"There are new control flow changes and added statements within the method such as conditional checks and an additional call to mImm.setImeWindowStatus. Therefore, the changes include both a control dependency change (3) and other statement changes (4).","Despite these changes, there is no CI as the new checks and conditions only perform early returns or logging for invalid values. The core behavior of setting the back disposition remains the same and will still complete if the input disposition is within a valid range. There would only be an issue if incorrect values were being set in the early version which are now being caught, but assuming that the earlier usage was correct, existing correct usage should remain compatible."
481,<android.accounts.AccountManager: Account[] getAccountsByType(String)>,27,28,<android.accounts.AccountManager: Account[] getAccountsByType(String)>,<android.accounts.AccountManager: Account[] getAccountsByType(String)>,0,"{
    return getAccountsByTypeAsUser(type, Process.myUserHandle());
}","{
    return getAccountsByTypeAsUser(type, mContext.getUser());
}",1,"/**
 * Lists all accounts of particular type visible to the caller. These accounts may be visible
 * because the user granted access to the account, or the AbstractAcccountAuthenticator managing
 * the account did so or because the client shares a signature with the managing
 * AbstractAccountAuthenticator.
 *
 * <p>
 * The account type is a string token corresponding to the authenticator and useful domain of
 * the account. For example, there are types corresponding to Google and Facebook. The exact
 * string token to use will be published somewhere associated with the authenticator in
 * question.
 *
 * <p>
 * It is safe to call this method from the main thread.
 *
 * <p>
 * Caller targeting API level {@link android.os.Build.VERSION_CODES#O} and above, will get list
 * of accounts made visible to it by user
 * (see {@link #newChooseAccountIntent(Account, List, String[], String,
 * String, String[], Bundle)}) or AbstractAcccountAuthenticator
 * using {@link #setAccountVisibility}.
 * {@link android.Manifest.permission#GET_ACCOUNTS} permission is not used.
 *
 * <p>
 * Caller targeting API level below {@link android.os.Build.VERSION_CODES#O} that have not been
 * granted the {@link android.Manifest.permission#GET_ACCOUNTS} permission, will only see those
 * accounts managed by AbstractAccountAuthenticators whose signature matches the client.
 *
 * <p>
 * <b>NOTE:</b> If targeting your app to work on API level
 * {@link android.os.Build.VERSION_CODES#LOLLIPOP_MR1} and before,
 * {@link android.Manifest.permission#GET_ACCOUNTS} permission is
 * needed for those platforms, irrespective of uid or signature match. See docs for this
 * function in API level {@link android.os.Build.VERSION_CODES#LOLLIPOP_MR1}.
 *
 * @param type The type of accounts to return, null to retrieve all accounts
 * @return An array of {@link Account}, one per matching account. Empty (never null) if no
 * accounts of the specified type have been added.
 */
","/**
 * Lists all accounts of particular type visible to the caller. These accounts may be visible
 * because the user granted access to the account, or the AbstractAcccountAuthenticator managing
 * the account did so or because the client shares a signature with the managing
 * AbstractAccountAuthenticator.
 *
 * <p>
 * The account type is a string token corresponding to the authenticator and useful domain of
 * the account. For example, there are types corresponding to Google and Facebook. The exact
 * string token to use will be published somewhere associated with the authenticator in
 * question.
 *
 * <p>
 * It is safe to call this method from the main thread.
 *
 * <p>
 * Caller targeting API level {@link android.os.Build.VERSION_CODES#O} and above, will get list
 * of accounts made visible to it by user
 * (see {@link #newChooseAccountIntent(Account, List, String[], String,
 * String, String[], Bundle)}) or AbstractAcccountAuthenticator
 * using {@link #setAccountVisibility}.
 * {@link android.Manifest.permission#GET_ACCOUNTS} permission is not used.
 *
 * <p>
 * Caller targeting API level below {@link android.os.Build.VERSION_CODES#O} that have not been
 * granted the {@link android.Manifest.permission#GET_ACCOUNTS} permission, will only see those
 * accounts managed by AbstractAccountAuthenticators whose signature matches the client.
 *
 * <p>
 * <b>NOTE:</b> If targeting your app to work on API level
 * {@link android.os.Build.VERSION_CODES#LOLLIPOP_MR1} and before,
 * {@link android.Manifest.permission#GET_ACCOUNTS} permission is
 * needed for those platforms, irrespective of uid or signature match. See docs for this
 * function in API level {@link android.os.Build.VERSION_CODES#LOLLIPOP_MR1}.
 *
 * @param type The type of accounts to return, null to retrieve all accounts
 * @return An array of {@link Account}, one per matching account. Empty (never null) if no
 * accounts of the specified type have been added.
 */
",-1,[@NonNull],[@NonNull],-1,-1,-1,-1,-1,-1,5,0,"The method getAccountsByTypeAsUser remains the same but is now called with a different parameter: mContext.getUser() replaces Process.myUserHandle(). This indicates that a dependent API has changed (the method of acquiring the user has been modified), so the code change type is 5.","Though the method call to get the user has changed, since both methods should return a UserHandle object representing the current user, the return type and the behavior of the getAccountsByType method theoretically remain unchanged. As such, there is no Compatibility Issue; hence, the CI type is 0."
482,<android.os.StrictMode: ThreadPolicy allowThreadDiskWrites()>,27,28,<android.os.StrictMode: ThreadPolicy allowThreadDiskWrites()>,<android.os.StrictMode: ThreadPolicy allowThreadDiskWrites()>,0,"{
    int oldPolicyMask = getThreadPolicyMask();
    int newPolicyMask = oldPolicyMask & ~(DETECT_DISK_WRITE | DETECT_DISK_READ);
    if (newPolicyMask != oldPolicyMask) {
        setThreadPolicyMask(newPolicyMask);
    }
    return new ThreadPolicy(oldPolicyMask);
}","{
    return new ThreadPolicy(allowThreadDiskWritesMask(), sThreadViolationListener.get(), sThreadViolationExecutor.get());
}",1,"/**
 * A convenience wrapper that takes the current
 * {@link ThreadPolicy} from {@link #getThreadPolicy}, modifies it
 * to permit both disk reads &amp; writes, and sets the new policy
 * with {@link #setThreadPolicy}, returning the old policy so you
 * can restore it at the end of a block.
 *
 * @return the old policy, to be passed to {@link #setThreadPolicy} to
 * restore the policy at the end of a block
 */
","/**
 * A convenience wrapper that takes the current {@link ThreadPolicy} from {@link
 * #getThreadPolicy}, modifies it to permit both disk reads &amp; writes, and sets the new
 * policy with {@link #setThreadPolicy}, returning the old policy so you can restore it at the
 * end of a block.
 *
 * @return the old policy, to be passed to {@link #setThreadPolicy} to restore the policy at the
 * end of a block
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,4,5",1,"The late implementation has a completely new method body using different mechanisms to create and return a new ThreadPolicy object. There's no longer calculation of the policy mask in the method itself; instead, it directly calls allowThreadDiskWritesMask(). Also, the 'get()' calls on sThreadViolationListener and sThreadViolationExecutor indicate dependence on their states. There are no local control structures or exception handling that are modified or introduced; the changes here pertain to how the return value is constructed and the dependence on other methods or state. Therefore, the changes include Return statement changed (1), Other statement changed (4), and Dependent API changed (5).","With the significant restructuring of the method's implementation detail and the introduction of the new method allowThreadDiskWritesMask(), which presumably changes how the mask is calculated or retrieved, along with the dependency on the state of sThreadViolationListener and sThreadViolationExecutor, it's clear that the returned object can have different initialization states resulting from these changes. Hence, there is a Compatibility Issue due to potential different return values or types, and the CI type is 1."
483,"<android.provider.Settings.System: boolean putString(ContentResolver,String,String)>",27,28,"<android.provider.Settings.System: boolean putString(ContentResolver,String,String)>","<android.provider.Settings.System: boolean putString(ContentResolver,String,String)>",0,"{
    return putStringForUser(resolver, name, value, UserHandle.myUserId());
}","{
    return putStringForUser(resolver, name, value, resolver.getUserId());
}",1,"/**
 * Store a name/value pair into the database.
 * @param resolver to access the database with
 * @param name to store
 * @param value to associate with the name
 * @return true if the value was set, false on database errors
 */
","/**
 * Store a name/value pair into the database.
 * @param resolver to access the database with
 * @param name to store
 * @param value to associate with the name
 * @return true if the value was set, false on database errors
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The method parameter within the return statement has changed from UserHandle.myUserId() to resolver.getUserId(), so the change type is 5.","There is no Compatibility Issue here, as the change in method parameter represents an internal refactoring and does not affect the outward behavior of the putString() method. The putString() method itself will return the same values for the same inputs, assuming the resolver.getUserId() internally returns the same value as UserHandle.myUserId() for the context of the current user. Therefore, the potential behaviors of the API remain unchanged."
484,"<android.app.ContextImpl: int checkPermission(String,int,int)>",27,28,"<android.app.ContextImpl: int checkPermission(String,int,int)>","<android.app.ContextImpl: int checkPermission(String,int,int)>",0,"{
    if (permission == null) {
        throw new IllegalArgumentException(""permission is null"");
    }
    final IActivityManager am = ActivityManager.getService();
    if (am == null) {
        // Well this is super awkward; we somehow don't have an active
        // ActivityManager instance. If we're testing a root or system
        // UID, then they totally have whatever permission this is.
        final int appId = UserHandle.getAppId(uid);
        if (appId == Process.ROOT_UID || appId == Process.SYSTEM_UID) {
            Slog.w(TAG, ""Missing ActivityManager; assuming "" + uid + "" holds "" + permission);
            return PackageManager.PERMISSION_GRANTED;
        }
    }
    try {
        return am.checkPermission(permission, pid, uid);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}","{
    if (permission == null) {
        throw new IllegalArgumentException(""permission is null"");
    }
    final IActivityManager am = ActivityManager.getService();
    if (am == null) {
        // Well this is super awkward; we somehow don't have an active
        // ActivityManager instance. If we're testing a root or system
        // UID, then they totally have whatever permission this is.
        final int appId = UserHandle.getAppId(uid);
        if (appId == Process.ROOT_UID || appId == Process.SYSTEM_UID) {
            Slog.w(TAG, ""Missing ActivityManager; assuming "" + uid + "" holds "" + permission);
            return PackageManager.PERMISSION_GRANTED;
        }
        Slog.w(TAG, ""Missing ActivityManager; assuming "" + uid + "" does not hold "" + permission);
        return PackageManager.PERMISSION_DENIED;
    }
    try {
        return am.checkPermission(permission, pid, uid);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,1,1,"In the late version, there is a new return statement (return PackageManager.PERMISSION_DENIED;) which returns a different value compared to the early version where this condition would continue to check the permission via am.checkPermission(permission, pid, uid). Therefore, the code change is of type 1.","The new return statement added in the late version creates a Compatibility Issue of type 1, as the method now has a pathway in which it will return PackageManager.PERMISSION_DENIED where previously it would have proceeded to check the permission, possibly returning PERMISSION_GRANTED instead. This introduces a potential different return value based on the state of the system when the method is called."
487,<android.view.ViewGroup.ViewLocationHolder: int compareTo(ViewLocationHolder)>,27,28,<android.view.ViewGroup.ViewLocationHolder: int compareTo(ViewLocationHolder)>,<android.view.ViewGroup.ViewLocationHolder: int compareTo(ViewLocationHolder)>,0,"{
    // This instance is greater than an invalid argument.
    if (another == null) {
        return 1;
    }
    if (sComparisonStrategy == COMPARISON_STRATEGY_STRIPE) {
        // First is above second.
        if (mLocation.bottom - another.mLocation.top <= 0) {
            return -1;
        }
        // First is below second.
        if (mLocation.top - another.mLocation.bottom >= 0) {
            return 1;
        }
    }
    // We are ordering left-to-right, top-to-bottom.
    if (mLayoutDirection == LAYOUT_DIRECTION_LTR) {
        final int leftDifference = mLocation.left - another.mLocation.left;
        if (leftDifference != 0) {
            return leftDifference;
        }
    } else {
        // RTL
        final int rightDifference = mLocation.right - another.mLocation.right;
        if (rightDifference != 0) {
            return -rightDifference;
        }
    }
    // We are ordering left-to-right, top-to-bottom.
    final int topDifference = mLocation.top - another.mLocation.top;
    if (topDifference != 0) {
        return topDifference;
    }
    // Break tie by height.
    final int heightDiference = mLocation.height() - another.mLocation.height();
    if (heightDiference != 0) {
        return -heightDiference;
    }
    // Break tie by width.
    final int widthDiference = mLocation.width() - another.mLocation.width();
    if (widthDiference != 0) {
        return -widthDiference;
    }
    // and stable, hence this is deterministic tie breaking.
    return mView.getAccessibilityViewId() - another.mView.getAccessibilityViewId();
}","{
    // This instance is greater than an invalid argument.
    if (another == null) {
        return 1;
    }
    int boundsResult = compareBoundsOfTree(this, another);
    if (boundsResult != 0) {
        return boundsResult;
    }
    // and stable, hence this is deterministic tie breaking.
    return mView.getAccessibilityViewId() - another.mView.getAccessibilityViewId();
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,3,4,5",1,"The control dependency has changed since there is a new method `compareBoundsOfTree` introduced that replaces all the previous bounds comparison logic, which also includes return statement changes for those comparisons. Additionally, the dependency on the method `compareBoundsOfTree` is a change in the used API. There is thus a change in the control flow, return statements, other statements, and a dependent API, making this a change of types 1,3,4,5.","As the comparison logic has been replaced by a new method `compareBoundsOfTree`, the API could potentially return different values, leading to a different order in sorted items. Hence, this constitutes a Compatibility Issue of type 1."
488,<android.hardware.camera2.impl.CameraDeviceImpl: Builder createReprocessCaptureRequest(TotalCaptureResult)>,27,28,<android.hardware.camera2.impl.CameraDeviceImpl: Builder createReprocessCaptureRequest(TotalCaptureResult)>,<android.hardware.camera2.impl.CameraDeviceImpl: Builder createReprocessCaptureRequest(TotalCaptureResult)>,0,"{
    synchronized (mInterfaceLock) {
        checkIfCameraClosedOrInError();
        CameraMetadataNative resultMetadata = new CameraMetadataNative(inputResult.getNativeCopy());
        return new CaptureRequest.Builder(resultMetadata, /*reprocess*/
        true, inputResult.getSessionId());
    }
}","{
    synchronized (mInterfaceLock) {
        checkIfCameraClosedOrInError();
        CameraMetadataNative resultMetadata = new CameraMetadataNative(inputResult.getNativeCopy());
        return new CaptureRequest.Builder(resultMetadata, /*reprocess*/
        true, inputResult.getSessionId(), getId(), /*physicalCameraIdSet*/
        null);
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"4,5",0,"The constructor for CaptureRequest.Builder has an additional two parameters in its late version. This is an example of an Other statement changed, as well as a Dependent API changed; however, since these new parameters do not affect the behavior in a way that would alter the contract of the API (no different return values or types, no new exceptions), there is no Compatibility Issue according to the definition. Therefore, the code change is 4,5.","There is no Compatibility Issue because the additional parameters in the constructor call do not change the return type or the exceptions thrown by the createReprocessCaptureRequest method. The difference does not alter the outward behavior; it only affects the internals of the CaptureRequest.Builder instantiation. Hence, we can conclude there is no CI, denoted by 0."
489,<android.widget.RemoteViews.Action: String getUniqueKey()>,27,28,<android.widget.RemoteViews.Action: String getUniqueKey()>,<android.widget.RemoteViews.Action: String getUniqueKey()>,0,"{
    return (getActionName() + viewId);
}","{
    return (getActionTag() + ""_"" + viewId);
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The method invoked within the return statement has changed from getActionName() to getActionTag(), and an additional string ""_"" is being added in the return statement, indicating both change type 1 and 5.","The return value of the method will be different because it not only changes from getActionName() to getActionTag() but also alters the structure of the returned String. Therefore, the change can cause a Compatibility Issue of type 1 due to different return values."
491,<android.net.TrafficStats: long getUidTxBytes(int)>,27,28,<android.net.TrafficStats: long getUidTxBytes(int)>,<android.net.TrafficStats: long getUidTxBytes(int)>,0,"{
    // This isn't actually enforcing any security; it just returns the
    // unsupported value. The real filtering is done at the kernel level.
    final int callingUid = android.os.Process.myUid();
    if (callingUid == android.os.Process.SYSTEM_UID || callingUid == uid) {
        return nativeGetUidStat(uid, TYPE_TX_BYTES);
    } else {
        return UNSUPPORTED;
    }
}","{
    // This isn't actually enforcing any security; it just returns the
    // unsupported value. The real filtering is done at the kernel level.
    final int callingUid = android.os.Process.myUid();
    if (callingUid == android.os.Process.SYSTEM_UID || callingUid == uid) {
        try {
            return getStatsService().getUidStats(uid, TYPE_TX_BYTES);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    } else {
        return UNSUPPORTED;
    }
}",1,"/**
 * Return number of bytes transmitted by the given UID since device boot.
 * Counts packets across all network interfaces, and always increases
 * monotonically since device boot. Statistics are measured at the network
 * layer, so they include both TCP and UDP usage.
 * <p>
 * Before {@link android.os.Build.VERSION_CODES#JELLY_BEAN_MR2}, this may
 * return {@link #UNSUPPORTED} on devices where statistics aren't available.
 * <p>
 * Starting in {@link android.os.Build.VERSION_CODES#N} this will only
 * report traffic statistics for the calling UID. It will return
 * {@link #UNSUPPORTED} for all other UIDs for privacy reasons. To access
 * historical network statistics belonging to other UIDs, use
 * {@link NetworkStatsManager}.
 *
 * @see android.os.Process#myUid()
 * @see android.content.pm.ApplicationInfo#uid
 */
","/**
 * Return number of bytes transmitted by the given UID since device boot.
 * Counts packets across all network interfaces, and always increases
 * monotonically since device boot. Statistics are measured at the network
 * layer, so they include both TCP and UDP usage.
 * <p>
 * Before {@link android.os.Build.VERSION_CODES#JELLY_BEAN_MR2}, this may
 * return {@link #UNSUPPORTED} on devices where statistics aren't available.
 * <p>
 * Starting in {@link android.os.Build.VERSION_CODES#N} this will only
 * report traffic statistics for the calling UID. It will return
 * {@link #UNSUPPORTED} for all other UIDs for privacy reasons. To access
 * historical network statistics belonging to other UIDs, use
 * {@link NetworkStatsManager}.
 *
 * @see android.os.Process#myUid()
 * @see android.content.pm.ApplicationInfo#uid
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,5","1,2","The method used to get UID statistics within the 'if' block has changed from nativeGetUidStat(uid, TYPE_TX_BYTES) to getStatsService().getUidStats(uid, TYPE_TX_BYTES), and an exception handling block has been added. There's no change in the control flow, but the method of obtaining the data has changed, which is a type 5 change. Due to the change in how exceptions are handled, the method now throws a rethrown exception from the system server, which is a type 2 change.","Since the method of obtaining data has changed to one that could throw an exception where it previously returned a static value (UNSUPPORTED), there's potential for the behavior of the method to change. In the case of an exception, the caller now has to deal with a thrown exception instead of receiving a constant value, which can lead to different behavior. This could affect both return values/types (CI type 1) if the new implementation behaves differently than the old native call, and exception handling (CI type 2) because a new exception is now being thrown where before one was never thrown."
492,<android.net.LocalSocketImpl.SocketOutputStream: void flush()>,27,28,<android.net.LocalSocketImpl.SocketOutputStream: void flush()>,<android.net.LocalSocketImpl.SocketOutputStream: void flush()>,0,"{
    FileDescriptor myFd = fd;
    if (myFd == null)
        throw new IOException(""socket closed"");
    // Loop until the output buffer is empty.
    MutableInt pending = new MutableInt(0);
    while (true) {
        try {
            // See linux/net/unix/af_unix.c
            Os.ioctlInt(myFd, OsConstants.TIOCOUTQ, pending);
        } catch (ErrnoException e) {
            throw e.rethrowAsIOException();
        }
        if (pending.value <= 0) {
            // The output buffer is empty.
            break;
        }
        try {
            Thread.sleep(10);
        } catch (InterruptedException ie) {
            break;
        }
    }
}","{
    FileDescriptor myFd = fd;
    if (myFd == null)
        throw new IOException(""socket closed"");
    // Loop until the output buffer is empty.
    Int32Ref pending = new Int32Ref(0);
    while (true) {
        try {
            // See linux/net/unix/af_unix.c
            Os.ioctlInt(myFd, OsConstants.TIOCOUTQ, pending);
        } catch (ErrnoException e) {
            throw e.rethrowAsIOException();
        }
        if (pending.value <= 0) {
            // The output buffer is empty.
            break;
        }
        try {
            Thread.sleep(10);
        } catch (InterruptedException ie) {
            break;
        }
    }
}",1,"/**
 * Wait until the data in sending queue is emptied. A polling version
 * for flush implementation.
 * @throws IOException
 * if an i/o error occurs.
 */
","/**
 * Wait until the data in sending queue is emptied. A polling version
 * for flush implementation.
 * @throws IOException
 * if an i/o error occurs.
 */
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"The change from MutableInt to Int32Ref does not affect any control flow or exception handling but indicates a change in the usage of a different class for the pending reference. Therefore, the change type is 4.","The change from MutableInt to Int32Ref is an internal implementation detail that does not affect the API's external behavior. There are no changes in the exception throwing or return statements, and the logic of the method is preserved across the early to late implementation. Thus, there is no compatibility issue, and the CI type is 0."
493,"<android.app.WallpaperManager.Globals: Bitmap peekWallpaperBitmap(Context,boolean,int)>",27,28,"<android.app.WallpaperManager.Globals: Bitmap peekWallpaperBitmap(Context,boolean,int)>","<android.app.WallpaperManager.Globals: Bitmap peekWallpaperBitmap(Context,boolean,int)>",0,"{
    return peekWallpaperBitmap(context, returnDefault, which, context.getUserId());
}","{
    return peekWallpaperBitmap(context, returnDefault, which, context.getUserId(), false);
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,5,0,"The method peekWallpaperBitmap() now includes an additional parameter in its call, changing from 3 parameters to 4 parameters, but because it's overloaded method, we consider the change as a Dependent API changed (class 5).","There is no Compatibility Issue since the call to peekWallpaperBitmap() with a different number of parameters is just an overload. The same previously existing method with the original number of parameters should still exist and operate as before, which means existing code calling this method will not be affected."
494,<android.app.admin.ConnectEvent: String toString()>,27,28,<android.app.admin.ConnectEvent: String toString()>,<android.app.admin.ConnectEvent: String toString()>,0,"{
    return String.format(""ConnectEvent(%s, %d, %d, %s)"", ipAddress, port, timestamp, packageName);
}","{
    return String.format(""ConnectEvent(%d, %s, %d, %d, %s)"", mId, mIpAddress, mPort, mTimestamp, mPackageName);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,1,1,"The String format within the return statement has changed by adding an extra parameter 'mId', and the variables used in the String format have been prefixed with 'm', indicating changes in how the string is composed, therefore the code change type is 1.","Changes in the return statement will make the API return a different string value, since the format and parameters of the string have changed. Therefore, the CI type is 1."
495,<android.hardware.radio.TunerAdapter: int setConfiguration(BandConfig)>,27,28,<android.hardware.radio.TunerAdapter: int setConfiguration(BandConfig)>,<android.hardware.radio.TunerAdapter: int setConfiguration(BandConfig)>,0,"{
    try {
        mTuner.setConfiguration(config);
        mBand = config.getType();
        return RadioManager.STATUS_OK;
    } catch (IllegalArgumentException e) {
        Log.e(TAG, ""Can't set configuration"", e);
        return RadioManager.STATUS_BAD_VALUE;
    } catch (RemoteException e) {
        Log.e(TAG, ""service died"", e);
        return RadioManager.STATUS_DEAD_OBJECT;
    }
}","{
    if (config == null)
        return RadioManager.STATUS_BAD_VALUE;
    try {
        mTuner.setConfiguration(config);
        mBand = config.getType();
        return RadioManager.STATUS_OK;
    } catch (IllegalArgumentException e) {
        Log.e(TAG, ""Can't set configuration"", e);
        return RadioManager.STATUS_BAD_VALUE;
    } catch (RemoteException e) {
        Log.e(TAG, ""service died"", e);
        return RadioManager.STATUS_DEAD_OBJECT;
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,3,1,"An if-statement checking the nullity of the config parameter has been added at the beginning of the method, so the code change type is 3.","Because of the newly introduced if-statement, the method can now return RadioManager.STATUS_BAD_VALUE if the 'config' parameter is null before any further actions are taken. In the early version, if 'config' is null and null is an illegal argument, an IllegalArgumentException would be caught, and the method would also return RadioManager.STATUS_BAD_VALUE, but if null is not an illegal argument then the behavior when 'config' is null would be different between the versions. Thus, the CI type is 1."
497,<android.accounts.AccountManager.AmsTask.Response: void onResult(Bundle)>,27,28,<android.accounts.AccountManager.AmsTask.Response: void onResult(Bundle)>,<android.accounts.AccountManager.AmsTask.Response: void onResult(Bundle)>,0,"{
    Intent intent = bundle.getParcelable(KEY_INTENT);
    if (intent != null && mActivity != null) {
        // since the user provided an Activity we will silently start intents
        // that we see
        mActivity.startActivity(intent);
    // leave the Future running to wait for the real response to this request
    } else if (bundle.getBoolean(""retry"")) {
        try {
            doWork();
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    } else {
        set(bundle);
    }
}","{
    if (bundle == null) {
        onError(ERROR_CODE_INVALID_RESPONSE, ""null bundle returned"");
        return;
    }
    Intent intent = bundle.getParcelable(KEY_INTENT);
    if (intent != null && mActivity != null) {
        // since the user provided an Activity we will silently start intents
        // that we see
        mActivity.startActivity(intent);
    // leave the Future running to wait for the real response to this request
    } else if (bundle.getBoolean(""retry"")) {
        try {
            doWork();
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    } else {
        set(bundle);
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,3,2,"The late version added a new check for the bundle to be non-null at the start of the method, followed by an error handling branch that was not present in the early version, so the code change type is 3.","Compatibility Issue arises from the new error handling branch that throws an exception when the bundle is null. In contrast, the early version would allow a null bundle to proceed, which would result in a NullPointerException later. Therefore, we have a CI caused by potential different exception handlings, making the CI type 2."
498,<android.content.ContentResolver: List<UriPermission> getOutgoingPersistedUriPermissions()>,27,28,<android.content.ContentResolver: List<UriPermission> getOutgoingPersistedUriPermissions()>,<android.content.ContentResolver: List<UriPermission> getOutgoingPersistedUriPermissions()>,0,"{
    try {
        return ActivityManager.getService().getPersistedUriPermissions(mPackageName, false).getList();
    } catch (RemoteException e) {
        throw new RuntimeException(""Activity manager has died"", e);
    }
}","{
    try {
        return ActivityManager.getService().getPersistedUriPermissions(mPackageName, false).getList();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Return list of all persisted URI permission grants that are hosted by the
 * calling app. That is, the returned permissions have been granted
 * <em>from</em> the calling app. Only grants taken with
 * {@link #takePersistableUriPermission(Uri, int)} are returned.
 * <p>Note: Some of the returned URIs may not be usable until after the user is unlocked.
 */
","/**
 * Return list of all persisted URI permission grants that are hosted by the
 * calling app. That is, the returned permissions have been granted
 * <em>from</em> the calling app. Only grants taken with
 * {@link #takePersistableUriPermission(Uri, int)} are returned.
 * <p>Note: Some of the returned URIs may not be usable until after the user is unlocked.
 */
",-1,[@NonNull],[@NonNull],-1,-1,-1,-1,-1,-1,2,2,"The exception handling statement has changed from throwing a new RuntimeException to throwing the exception from rethrowFromSystemServer method, so the code change type is 2.","Because the change in the exception handling statement can cause a different exception to be thrown (from a generic RuntimeException to a specific one through rethrowFromSystemServer), the CI type is 2."
502,<android.app.KeyguardManager: boolean isDeviceSecure()>,27,28,<android.app.KeyguardManager: boolean isDeviceSecure()>,<android.app.KeyguardManager: boolean isDeviceSecure()>,0,"{
    return isDeviceSecure(UserHandle.myUserId());
}","{
    return isDeviceSecure(mContext.getUserId());
}",1,"/**
 * Returns whether the device is secured with a PIN, pattern or
 * password.
 *
 * <p>See also {@link #isKeyguardSecure} which treats SIM locked states as secure.
 *
 * @return true if a PIN, pattern or password was set.
 */
","/**
 * Returns whether the device is secured with a PIN, pattern or
 * password.
 *
 * <p>See also {@link #isKeyguardSecure} which treats SIM locked states as secure.
 *
 * @return true if a PIN, pattern or password was set.
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The method isDeviceSecure has changed the way it retrieves the user ID: from using UserHandle.myUserId() to mContext.getUserId(). Therefore, the code change type is 5.",There is no Compatibility Issue detected as the method isDeviceSecure expects a user ID as its argument and the change is only about how the user ID is obtained. The behavior of how the user ID affects the return value of isDeviceSecure is not modified between the versions.
503,"<android.util.proto.ProtoOutputStream: void write(long,byte[])>",27,28,"<android.util.proto.ProtoOutputStream: void write(long,byte[])>","<android.util.proto.ProtoOutputStream: void write(long,byte[])>",0,"{
    assertNotCompacted();
    final int id = (int) fieldId;
    switch((int) ((fieldId & (FIELD_TYPE_MASK | FIELD_COUNT_MASK)) >> FIELD_TYPE_SHIFT)) {
        // bytes
        case (int) ((FIELD_TYPE_BYTES | FIELD_COUNT_SINGLE) >> FIELD_TYPE_SHIFT):
            writeBytesImpl(id, val);
            break;
        case (int) ((FIELD_TYPE_BYTES | FIELD_COUNT_REPEATED) >> FIELD_TYPE_SHIFT):
        case (int) ((FIELD_TYPE_BYTES | FIELD_COUNT_PACKED) >> FIELD_TYPE_SHIFT):
            writeRepeatedBytesImpl(id, val);
            break;
        // Object
        case (int) ((FIELD_TYPE_OBJECT | FIELD_COUNT_SINGLE) >> FIELD_TYPE_SHIFT):
            writeObjectImpl(id, val);
            break;
        case (int) ((FIELD_TYPE_OBJECT | FIELD_COUNT_REPEATED) >> FIELD_TYPE_SHIFT):
        case (int) ((FIELD_TYPE_OBJECT | FIELD_COUNT_PACKED) >> FIELD_TYPE_SHIFT):
            writeRepeatedObjectImpl(id, val);
            break;
        // nothing else allowed
        default:
            {
                throw new IllegalArgumentException(""Attempt to call write(long, byte[]) with "" + getFieldIdString(fieldId));
            }
    }
}","{
    assertNotCompacted();
    final int id = (int) fieldId;
    switch((int) ((fieldId & (FIELD_TYPE_MASK | FIELD_COUNT_MASK)) >> FIELD_TYPE_SHIFT)) {
        // bytes
        case (int) ((FIELD_TYPE_BYTES | FIELD_COUNT_SINGLE) >> FIELD_TYPE_SHIFT):
            writeBytesImpl(id, val);
            break;
        case (int) ((FIELD_TYPE_BYTES | FIELD_COUNT_REPEATED) >> FIELD_TYPE_SHIFT):
        case (int) ((FIELD_TYPE_BYTES | FIELD_COUNT_PACKED) >> FIELD_TYPE_SHIFT):
            writeRepeatedBytesImpl(id, val);
            break;
        // Object
        case (int) ((FIELD_TYPE_MESSAGE | FIELD_COUNT_SINGLE) >> FIELD_TYPE_SHIFT):
            writeObjectImpl(id, val);
            break;
        case (int) ((FIELD_TYPE_MESSAGE | FIELD_COUNT_REPEATED) >> FIELD_TYPE_SHIFT):
        case (int) ((FIELD_TYPE_MESSAGE | FIELD_COUNT_PACKED) >> FIELD_TYPE_SHIFT):
            writeRepeatedObjectImpl(id, val);
            break;
        // nothing else allowed
        default:
            {
                throw new IllegalArgumentException(""Attempt to call write(long, byte[]) with "" + getFieldIdString(fieldId));
            }
    }
}",1,"/**
 * Write a byte[] value for the given fieldId.
 *
 * If the field is not a bytes or object field, an exception will be thrown.
 *
 * @param fieldId The field identifier constant from the generated class.
 * @param val The value.
 */
","/**
 * Write a byte[] value for the given fieldId.
 *
 * If the field is not a bytes or object field, an exception will be thrown.
 *
 * @param fieldId The field identifier constant from the generated class.
 * @param val The value.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The change is found in the value of the case labels inside the switch statement, where FIELD_TYPE_OBJECT has been replaced with FIELD_TYPE_MESSAGE. This represents changes in constants or macros used, classified as an other statement changed.","This change does not cause any difference in the execution paths or the behavior of the API. It is merely a renaming of an internal constant value, and the logic of the method remains identical, thus no Compatibility Issue should arise."
504,<android.net.TrafficStats: long getTotalTxPackets()>,27,28,<android.net.TrafficStats: long getTotalTxPackets()>,<android.net.TrafficStats: long getTotalTxPackets()>,0,"{
    return nativeGetTotalStat(TYPE_TX_PACKETS);
}","{
    try {
        return getStatsService().getTotalStats(TYPE_TX_PACKETS);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Return number of packets transmitted since device boot. Counts packets
 * across all network interfaces, and always increases monotonically since
 * device boot. Statistics are measured at the network layer, so they
 * include both TCP and UDP usage.
 * <p>
 * Before {@link android.os.Build.VERSION_CODES#JELLY_BEAN_MR2}, this may
 * return {@link #UNSUPPORTED} on devices where statistics aren't available.
 */
","/**
 * Return number of packets transmitted since device boot. Counts packets
 * across all network interfaces, and always increases monotonically since
 * device boot. Statistics are measured at the network layer, so they
 * include both TCP and UDP usage.
 * <p>
 * Before {@link android.os.Build.VERSION_CODES#JELLY_BEAN_MR2}, this may
 * return {@link #UNSUPPORTED} on devices where statistics aren't available.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,5","1,2","The implementation has changed from a direct call to a native method to a call to getStatsService().getTotalStats(), and also introduced a try-catch block for RemoteException, so the change type is 2,5.","The change in implementation method could result in different values or types being returned due to the switch from native code to binder IPC call, and the new exception handling can cause different exceptions to be thrown. Consequently, the CI type is 1,2."
505,<android.bluetooth.BluetoothAdapter: int getScanMode()>,27,28,<android.bluetooth.BluetoothAdapter: int getScanMode()>,<android.bluetooth.BluetoothAdapter: int getScanMode()>,0,"{
    if (getState() != STATE_ON)
        return SCAN_MODE_NONE;
    try {
        mServiceLock.readLock().lock();
        if (mService != null)
            return mService.getScanMode();
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
    } finally {
        mServiceLock.readLock().unlock();
    }
    return SCAN_MODE_NONE;
}","{
    if (getState() != STATE_ON) {
        return SCAN_MODE_NONE;
    }
    try {
        mServiceLock.readLock().lock();
        if (mService != null) {
            return mService.getScanMode();
        }
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
    } finally {
        mServiceLock.readLock().unlock();
    }
    return SCAN_MODE_NONE;
}",1,"/**
 * Get the current Bluetooth scan mode of the local Bluetooth adapter.
 * <p>The Bluetooth scan mode determines if the local adapter is
 * connectable and/or discoverable from remote Bluetooth devices.
 * <p>Possible values are:
 * {@link #SCAN_MODE_NONE},
 * {@link #SCAN_MODE_CONNECTABLE},
 * {@link #SCAN_MODE_CONNECTABLE_DISCOVERABLE}.
 * <p>If Bluetooth state is not {@link #STATE_ON}, this API
 * will return {@link #SCAN_MODE_NONE}. After turning on Bluetooth,
 * wait for {@link #ACTION_STATE_CHANGED} with {@link #STATE_ON}
 * to get the updated value.
 *
 * @return scan mode
 */
","/**
 * Get the current Bluetooth scan mode of the local Bluetooth adapter.
 * <p>The Bluetooth scan mode determines if the local adapter is
 * connectable and/or discoverable from remote Bluetooth devices.
 * <p>Possible values are:
 * {@link #SCAN_MODE_NONE},
 * {@link #SCAN_MODE_CONNECTABLE},
 * {@link #SCAN_MODE_CONNECTABLE_DISCOVERABLE}.
 * <p>If Bluetooth state is not {@link #STATE_ON}, this API
 * will return {@link #SCAN_MODE_NONE}. After turning on Bluetooth,
 * wait for {@link #ACTION_STATE_CHANGED} with {@link #STATE_ON}
 * to get the updated value.
 *
 * @return scan mode
 */
",-1,"[@RequiresPermission(Manifest.permission.BLUETOOTH), @ScanMode]","[@RequiresPermission(Manifest.permission.BLUETOOTH), @ScanMode]",-1,-1,-1,-1,-1,-1,0,0,"There are no changes in the actual code logic or any edits that affect how the code operates. The changes seen are purely styling (placement of braces), which do not alter the logic or the outcome of the method.",No Compatibility Issue since there are no actual code or behavioral changes. The implementation of the method has remained logically consistent between the two versions.
506,<android.content.res.AssetManager: void finalize()>,27,28,<android.content.res.AssetManager: void finalize()>,<android.content.res.AssetManager: void finalize()>,0,"{
    try {
        if (DEBUG_REFS && mNumRefs != 0) {
            Log.w(TAG, ""AssetManager "" + this + "" finalized with non-zero refs: "" + mNumRefs);
            if (mRefStacks != null) {
                for (RuntimeException e : mRefStacks.values()) {
                    Log.w(TAG, ""Reference from here"", e);
                }
            }
        }
        destroy();
    } finally {
        super.finalize();
    }
}","{
    if (DEBUG_REFS && mNumRefs != 0) {
        Log.w(TAG, ""AssetManager "" + this + "" finalized with non-zero refs: "" + mNumRefs);
        if (mRefStacks != null) {
            for (RuntimeException e : mRefStacks.values()) {
                Log.w(TAG, ""Reference from here"", e);
            }
        }
    }
    if (mObject != 0) {
        nativeDestroy(mObject);
    }
}",1,,,-1,,[@Override],-1,-1,-1,-1,-1,-1,"2,4",2,"There are changes in the exception handling and other statements. The try-finally block has been removed, altering the structure of exception handling. Additionally, the destroy() method has been replaced with a direct check (if (mObject != 0)) and the nativeDestroy(mObject) method call. These changes are identified as types 2 and 4.","The removal of the try-finally block changes how exceptions may be propagated. In the early version, even if destroy() threw an exception, super.finalize() would still be called due to the finally block. In the late version, if nativeDestroy(mObject) throws an exception, the method terminates immediately, and any code following the throwing statement won't be executed. This constitutes an exception handling change, leading to a potential compatibility issue of type 2."
507,<android.hardware.radio.TunerCallbackAdapter: void onBackgroundScanComplete()>,27,28,<android.hardware.radio.TunerCallbackAdapter: void onBackgroundScanComplete()>,<android.hardware.radio.TunerCallbackAdapter: void onBackgroundScanComplete()>,0,"{
    mHandler.post(() -> mCallback.onBackgroundScanComplete());
}","{
    synchronized (mLock) {
        if (mLastCompleteList == null) {
            Log.i(TAG, ""Got onBackgroundScanComplete callback, but the "" + ""program list didn't get through yet. Delaying it..."");
            mDelayedCompleteCallback = true;
            return;
        }
        sendBackgroundScanCompleteLocked();
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,4",0,"The implementation code added synchronized block, condition check, logging, and changed the call to send callback, so the change types are 3(Control dependency change) and 4(Other statement changed).","There is no Compatibility Issue, as no change has been made that would affect the behavior as seen by the client of the API. The change only introduces internal state checking and delayed execution logic, but still eventually performs the callback. There is no change in the method return type, no new exceptions are thrown, and the value returned to the caller is not altered."
508,<android.bluetooth.le.AdvertisingSet: void setScanResponseData(AdvertiseData)>,27,28,<android.bluetooth.le.AdvertisingSet: void setScanResponseData(AdvertiseData)>,<android.bluetooth.le.AdvertisingSet: void setScanResponseData(AdvertiseData)>,0,"{
    try {
        gatt.setScanResponseData(this.advertiserId, scanResponse);
    } catch (RemoteException e) {
        Log.e(TAG, ""remote exception - "", e);
    }
}","{
    try {
        mGatt.setScanResponseData(mAdvertiserId, scanResponse);
    } catch (RemoteException e) {
        Log.e(TAG, ""remote exception - "", e);
    }
}",1,"/**
 * Set/update scan response data. Make sure that data doesn't exceed the size limit for
 * specified AdvertisingSetParameters. This method returns immediately, the operation status
 * is delivered through {@code callback.onScanResponseDataSet()}.
 *
 * @param scanResponse Scan response associated with the advertisement data. Size must not
 * exceed {@link BluetoothAdapter#getLeMaximumAdvertisingDataLength}. If the
 * update takes place when the advertising set is enabled, the data can be
 * maximum 251 bytes long.
 */
","/**
 * Set/update scan response data. Make sure that data doesn't exceed the size limit for
 * specified AdvertisingSetParameters. This method returns immediately, the operation status
 * is delivered through {@code callback.onScanResponseDataSet()}.
 *
 * @param scanResponse Scan response associated with the advertisement data. Size must not
 * exceed {@link BluetoothAdapter#getLeMaximumAdvertisingDataLength}. If the update takes place
 * when the advertising set is enabled, the data can be maximum 251 bytes long.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The change is only in the naming convention of variables from gatt to mGatt and advertiserId to mAdvertiserId, so the code change type is 4.","The renaming of variables does not affect the behavior of the API, as they are still referring to the same entities. There's no change in the logic or control flow that would cause the API to behave differently between the two versions. Therefore, there is no compatibility issue."
509,"<android.widget.SelectionActionModeHelper.SelectionMetricsLogger: void logSelectionModified(int,int,TextClassification,TextSelection)>",27,28,"<android.widget.SelectionActionModeHelper.SelectionMetricsLogger: void logSelectionModified(int,int,TextClassification,TextSelection)>","<android.widget.SelectionActionModeHelper.SelectionMetricsLogger: void logSelectionModified(int,int,TextClassification,TextSelection)>",0,"{
    try {
        Preconditions.checkArgumentInRange(start, 0, mText.length(), ""start"");
        Preconditions.checkArgumentInRange(end, start, mText.length(), ""end"");
        int[] wordIndices = getWordDelta(start, end);
        if (selection != null) {
            mDelegate.logEvent(SelectionEvent.selectionModified(wordIndices[0], wordIndices[1], selection));
        } else if (classification != null) {
            mDelegate.logEvent(SelectionEvent.selectionModified(wordIndices[0], wordIndices[1], classification));
        } else {
            mDelegate.logEvent(SelectionEvent.selectionModified(wordIndices[0], wordIndices[1]));
        }
    } catch (Exception e) {
        // Avoid crashes due to logging.
        Log.d(LOG_TAG, e.getMessage());
    }
}","{
    try {
        if (hasActiveClassificationSession()) {
            Preconditions.checkArgumentInRange(start, 0, mText.length(), ""start"");
            Preconditions.checkArgumentInRange(end, start, mText.length(), ""end"");
            int[] wordIndices = getWordDelta(start, end);
            if (selection != null) {
                mClassificationSession.onSelectionEvent(SelectionEvent.createSelectionModifiedEvent(wordIndices[0], wordIndices[1], selection));
            } else if (classification != null) {
                mClassificationSession.onSelectionEvent(SelectionEvent.createSelectionModifiedEvent(wordIndices[0], wordIndices[1], classification));
            } else {
                mClassificationSession.onSelectionEvent(SelectionEvent.createSelectionModifiedEvent(wordIndices[0], wordIndices[1]));
            }
        }
    } catch (Exception e) {
        // Avoid crashes due to logging.
        Log.e(LOG_TAG, """" + e.getMessage(), e);
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"3,4,5","1,2","The logic for checking if there is an active classification session (hasActiveClassificationSession()) has been introduced, and it wraps around the existing checks and log event calls. Therefore, a new control dependency has been introduced (3). Additionally, the methods 'logEvent' and 'onSelectionEvent' might be different (this depends on their implementations, which are not provided here), implying a change on dependent APIs (5). Besides that, Log method changed from Log.d to Log.e, which is categorized as Other statement changed (4).","A Compatibility Issue related to return values or types could arise because now the logging behavior only occurs if there is an active classification session, potentially affecting the outcome of the logging (1). Furthermore, the kind of exception handling has become more verbose by including the stack trace within the log, which could affect clients monitoring log outputs, potentially recognizing different exception handling (2)."
511,"<android.provider.Settings.Secure: int getInt(ContentResolver,String)>",27,28,"<android.provider.Settings.Secure: int getInt(ContentResolver,String)>","<android.provider.Settings.Secure: int getInt(ContentResolver,String)>",0,"{
    return getIntForUser(cr, name, UserHandle.myUserId());
}","{
    return getIntForUser(cr, name, cr.getUserId());
}",1,"/**
 * Convenience function for retrieving a single secure settings value
 * as an integer.  Note that internally setting values are always
 * stored as strings; this function converts the string to an integer
 * for you.
 * <p>
 * This version does not take a default value.  If the setting has not
 * been set, or the string value is not a number,
 * it throws {@link SettingNotFoundException}.
 *
 * @param cr The ContentResolver to access.
 * @param name The name of the setting to retrieve.
 *
 * @throws SettingNotFoundException Thrown if a setting by the given
 * name can't be found or the setting value is not an integer.
 *
 * @return The setting's current value.
 */
","/**
 * Convenience function for retrieving a single secure settings value
 * as an integer.  Note that internally setting values are always
 * stored as strings; this function converts the string to an integer
 * for you.
 * <p>
 * This version does not take a default value.  If the setting has not
 * been set, or the string value is not a number,
 * it throws {@link SettingNotFoundException}.
 *
 * @param cr The ContentResolver to access.
 * @param name The name of the setting to retrieve.
 *
 * @throws SettingNotFoundException Thrown if a setting by the given
 * name can't be found or the setting value is not an integer.
 *
 * @return The setting's current value.
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The implementation of the method has changed by making use of a different method to obtain the user ID: From `UserHandle.myUserId()` to `cr.getUserId()`. The method `getIntForUser` that depends on the user ID could potentially behave differently based on the implementation of `getUserId()`. Therefore, the code change type is 5.","Since `UserHandle.myUserId()` and `cr.getUserId()` are expected to return the same user ID for the current process (unless their implementations were different which is not indicated by the provided information), there should not be a difference in the behavior of `getInt` when fetching the integer value for a key. Therefore, it is predicted that there is no Compatibility Issue (CI type 0)."
513,<android.view.ViewGroup: void dispatchProvideStructure(ViewStructure)>,27,28,<android.view.ViewGroup: void dispatchProvideStructure(ViewStructure)>,<android.view.ViewGroup: void dispatchProvideStructure(ViewStructure)>,0,"{
    super.dispatchProvideStructure(structure);
    if (isAssistBlocked() || structure.getChildCount() != 0) {
        return;
    }
    final int childrenCount = mChildrenCount;
    if (childrenCount <= 0) {
        return;
    }
    if (!isLaidOut()) {
        Log.v(VIEW_LOG_TAG, ""dispatchProvideStructure(): not laid out, ignoring "" + childrenCount + "" children of "" + getAccessibilityViewId());
        return;
    }
    structure.setChildCount(childrenCount);
    ArrayList<View> preorderedList = buildOrderedChildList();
    boolean customOrder = preorderedList == null && isChildrenDrawingOrderEnabled();
    for (int i = 0; i < childrenCount; i++) {
        int childIndex;
        try {
            childIndex = getAndVerifyPreorderedIndex(childrenCount, i, customOrder);
        } catch (IndexOutOfBoundsException e) {
            childIndex = i;
            if (mContext.getApplicationInfo().targetSdkVersion < Build.VERSION_CODES.M) {
                Log.w(TAG, ""Bad getChildDrawingOrder while collecting assist @ "" + i + "" of "" + childrenCount, e);
                // At least one app is failing when we call getChildDrawingOrder
                // at this point, so deal semi-gracefully with it by falling back
                // on the basic order.
                customOrder = false;
                if (i > 0) {
                    // If we failed at the first index, there really isn't
                    // anything to do -- we will just proceed with the simple
                    // sequence order.
                    // Otherwise, we failed in the middle, so need to come up
                    // with an order for the remaining indices and use that.
                    // Failed at the first one, easy peasy.
                    int[] permutation = new int[childrenCount];
                    SparseBooleanArray usedIndices = new SparseBooleanArray();
                    // Go back and collected the indices we have done so far.
                    for (int j = 0; j < i; j++) {
                        permutation[j] = getChildDrawingOrder(childrenCount, j);
                        usedIndices.put(permutation[j], true);
                    }
                    // Fill in the remaining indices with indices that have not
                    // yet been used.
                    int nextIndex = 0;
                    for (int j = i; j < childrenCount; j++) {
                        while (usedIndices.get(nextIndex, false)) {
                            nextIndex++;
                        }
                        permutation[j] = nextIndex;
                        nextIndex++;
                    }
                    // Build the final view list.
                    preorderedList = new ArrayList<>(childrenCount);
                    for (int j = 0; j < childrenCount; j++) {
                        final int index = permutation[j];
                        final View child = mChildren[index];
                        preorderedList.add(child);
                    }
                }
            } else {
                throw e;
            }
        }
        final View child = getAndVerifyPreorderedView(preorderedList, mChildren, childIndex);
        final ViewStructure cstructure = structure.newChild(i);
        child.dispatchProvideStructure(cstructure);
    }
    if (preorderedList != null) {
        preorderedList.clear();
    }
}","{
    super.dispatchProvideStructure(structure);
    if (isAssistBlocked() || structure.getChildCount() != 0) {
        return;
    }
    final int childrenCount = mChildrenCount;
    if (childrenCount <= 0) {
        return;
    }
    if (!isLaidOut()) {
        if (Helper.sVerbose) {
            Log.v(VIEW_LOG_TAG, ""dispatchProvideStructure(): not laid out, ignoring "" + childrenCount + "" children of "" + getAccessibilityViewId());
        }
        return;
    }
    structure.setChildCount(childrenCount);
    ArrayList<View> preorderedList = buildOrderedChildList();
    boolean customOrder = preorderedList == null && isChildrenDrawingOrderEnabled();
    for (int i = 0; i < childrenCount; i++) {
        int childIndex;
        try {
            childIndex = getAndVerifyPreorderedIndex(childrenCount, i, customOrder);
        } catch (IndexOutOfBoundsException e) {
            childIndex = i;
            if (mContext.getApplicationInfo().targetSdkVersion < Build.VERSION_CODES.M) {
                Log.w(TAG, ""Bad getChildDrawingOrder while collecting assist @ "" + i + "" of "" + childrenCount, e);
                // At least one app is failing when we call getChildDrawingOrder
                // at this point, so deal semi-gracefully with it by falling back
                // on the basic order.
                customOrder = false;
                if (i > 0) {
                    // If we failed at the first index, there really isn't
                    // anything to do -- we will just proceed with the simple
                    // sequence order.
                    // Otherwise, we failed in the middle, so need to come up
                    // with an order for the remaining indices and use that.
                    // Failed at the first one, easy peasy.
                    int[] permutation = new int[childrenCount];
                    SparseBooleanArray usedIndices = new SparseBooleanArray();
                    // Go back and collected the indices we have done so far.
                    for (int j = 0; j < i; j++) {
                        permutation[j] = getChildDrawingOrder(childrenCount, j);
                        usedIndices.put(permutation[j], true);
                    }
                    // Fill in the remaining indices with indices that have not
                    // yet been used.
                    int nextIndex = 0;
                    for (int j = i; j < childrenCount; j++) {
                        while (usedIndices.get(nextIndex, false)) {
                            nextIndex++;
                        }
                        permutation[j] = nextIndex;
                        nextIndex++;
                    }
                    // Build the final view list.
                    preorderedList = new ArrayList<>(childrenCount);
                    for (int j = 0; j < childrenCount; j++) {
                        final int index = permutation[j];
                        final View child = mChildren[index];
                        preorderedList.add(child);
                    }
                }
            } else {
                throw e;
            }
        }
        final View child = getAndVerifyPreorderedView(preorderedList, mChildren, childIndex);
        final ViewStructure cstructure = structure.newChild(i);
        child.dispatchProvideStructure(cstructure);
    }
    if (preorderedList != null) {
        preorderedList.clear();
    }
}",1,"/**
 * Dispatch creation of {@link ViewStructure} down the hierarchy.  This implementation
 * adds in all child views of the view group, in addition to calling the default View
 * implementation.
 */
","/**
 * Dispatch creation of {@link ViewStructure} down the hierarchy.  This implementation
 * adds in all child views of the view group, in addition to calling the default View
 * implementation.
 */
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,,,,
514,<android.view.textclassifier.TextClassification: CharSequence getLabel()>,27,28,<android.view.textclassifier.TextClassification: CharSequence getLabel()>,<android.view.textclassifier.TextClassification: CharSequence getLabel()>,0,"{
    return mLabel;
}","{
    return mLegacyLabel;
}",1,"/**
 * Returns a label that may be rendered on a widget used to act on the classified text.
 */
","/**
 * Returns a label that may be rendered on a widget used to act on the classified text.
 *
 * <p><strong>NOTE: </strong>This field is not parcelable and only represents the label of the
 * first {@link RemoteAction} (if one exists) when this object is read from a parcel.
 *
 * @deprecated Use {@link #getActions()} instead.
 */
",-1,[@Nullable],"[@Deprecated, @Nullable]",-1,-1,-1,-1,-1,-1,1,1,"The return statement changed from returning mLabel to returning mLegacyLabel, so the code change type is 1.","As the field returned by the API method has changed, the API will return a potentially different value, therefore, the CI type is 1."
515,<android.app.Instrumentation: Activity startActivitySync(Intent)>,27,28,<android.app.Instrumentation: Activity startActivitySync(Intent)>,<android.app.Instrumentation: Activity startActivitySync(Intent)>,0,"{
    validateNotAppThread();
    synchronized (mSync) {
        intent = new Intent(intent);
        ActivityInfo ai = intent.resolveActivityInfo(getTargetContext().getPackageManager(), 0);
        if (ai == null) {
            throw new RuntimeException(""Unable to resolve activity for: "" + intent);
        }
        String myProc = mThread.getProcessName();
        if (!ai.processName.equals(myProc)) {
            // there is a single match that is in our package.
            throw new RuntimeException(""Intent in process "" + myProc + "" resolved to different process "" + ai.processName + "": "" + intent);
        }
        intent.setComponent(new ComponentName(ai.applicationInfo.packageName, ai.name));
        final ActivityWaiter aw = new ActivityWaiter(intent);
        if (mWaitingActivities == null) {
            mWaitingActivities = new ArrayList();
        }
        mWaitingActivities.add(aw);
        getTargetContext().startActivity(intent);
        do {
            try {
                mSync.wait();
            } catch (InterruptedException e) {
            }
        } while (mWaitingActivities.contains(aw));
        return aw.activity;
    }
}","{
    return startActivitySync(intent, null);
}",1,"/**
 * Start a new activity and wait for it to begin running before returning.
 * In addition to being synchronous, this method as some semantic
 * differences from the standard {@link Context#startActivity} call: the
 * activity component is resolved before talking with the activity manager
 * (its class name is specified in the Intent that this method ultimately
 * starts), and it does not allow you to start activities that run in a
 * different process.  In addition, if the given Intent resolves to
 * multiple activities, instead of displaying a dialog for the user to
 * select an activity, an exception will be thrown.
 *
 * <p>The function returns as soon as the activity goes idle following the
 * call to its {@link Activity#onCreate}.  Generally this means it has gone
 * through the full initialization including {@link Activity#onResume} and
 * drawn and displayed its initial window.
 *
 * @param intent Description of the activity to start.
 *
 * @see Context#startActivity
 */
","/**
 * Start a new activity and wait for it to begin running before returning.
 * In addition to being synchronous, this method as some semantic
 * differences from the standard {@link Context#startActivity} call: the
 * activity component is resolved before talking with the activity manager
 * (its class name is specified in the Intent that this method ultimately
 * starts), and it does not allow you to start activities that run in a
 * different process.  In addition, if the given Intent resolves to
 * multiple activities, instead of displaying a dialog for the user to
 * select an activity, an exception will be thrown.
 *
 * <p>The function returns as soon as the activity goes idle following the
 * call to its {@link Activity#onCreate}.  Generally this means it has gone
 * through the full initialization including {@link Activity#onResume} and
 * drawn and displayed its initial window.
 *
 * @param intent Description of the activity to start.
 *
 * @see Context#startActivity
 * @see #startActivitySync(Intent, Bundle)
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The method implementation in the late version is calling an overloaded method startActivitySync(intent, null) instead of providing the original implementation which included various checks and synchronization mechanisms. Thus, there is both a return statement change and a dependent API change, which is indicated by code change types 1 and 5.","Since the late version delegates to a different method, the behavior might have changed, including potential different return values or types depending on the implementation of the new method called. Therefore, the CI type is 1."
516,<android.bluetooth.BluetoothAdapter: int getLeMaximumAdvertisingDataLength()>,27,28,<android.bluetooth.BluetoothAdapter: int getLeMaximumAdvertisingDataLength()>,<android.bluetooth.BluetoothAdapter: int getLeMaximumAdvertisingDataLength()>,0,"{
    if (!getLeAccess())
        return 0;
    try {
        mServiceLock.readLock().lock();
        if (mService != null)
            return mService.getLeMaximumAdvertisingDataLength();
    } catch (RemoteException e) {
        Log.e(TAG, ""failed to get getLeMaximumAdvertisingDataLength, error: "", e);
    } finally {
        mServiceLock.readLock().unlock();
    }
    return 0;
}","{
    if (!getLeAccess()) {
        return 0;
    }
    try {
        mServiceLock.readLock().lock();
        if (mService != null) {
            return mService.getLeMaximumAdvertisingDataLength();
        }
    } catch (RemoteException e) {
        Log.e(TAG, ""failed to get getLeMaximumAdvertisingDataLength, error: "", e);
    } finally {
        mServiceLock.readLock().unlock();
    }
    return 0;
}",1,"/**
 * Return the maximum LE advertising data length in bytes,
 * if LE Extended Advertising feature is supported, 0 otherwise.
 *
 * @return the maximum LE advertising data length.
 */
","/**
 * Return the maximum LE advertising data length in bytes,
 * if LE Extended Advertising feature is supported, 0 otherwise.
 *
 * @return the maximum LE advertising data length.
 */
",-1,,,-1,-1,-1,-1,-1,-1,0,0,"There is no functional change in the implementation; only code formatting has been modified (brackets have been added to `if` and `if` block), which doesn't affect the behavior.",No compatibility issue could arise because there is no actual change in what the method does or how it behaves.
517,<android.os.PowerManager.WakeLock: void setWorkSource(WorkSource)>,27,28,<android.os.PowerManager.WakeLock: void setWorkSource(WorkSource)>,<android.os.PowerManager.WakeLock: void setWorkSource(WorkSource)>,0,"{
    synchronized (mToken) {
        if (ws != null && ws.size() == 0) {
            ws = null;
        }
        final boolean changed;
        if (ws == null) {
            changed = mWorkSource != null;
            mWorkSource = null;
        } else if (mWorkSource == null) {
            changed = true;
            mWorkSource = new WorkSource(ws);
        } else {
            changed = mWorkSource.diff(ws);
            if (changed) {
                mWorkSource.set(ws);
            }
        }
        if (changed && mHeld) {
            try {
                mService.updateWakeLockWorkSource(mToken, mWorkSource, mHistoryTag);
            } catch (RemoteException e) {
                throw e.rethrowFromSystemServer();
            }
        }
    }
}","{
    synchronized (mToken) {
        if (ws != null && ws.isEmpty()) {
            ws = null;
        }
        final boolean changed;
        if (ws == null) {
            changed = mWorkSource != null;
            mWorkSource = null;
        } else if (mWorkSource == null) {
            changed = true;
            mWorkSource = new WorkSource(ws);
        } else {
            changed = !mWorkSource.equals(ws);
            if (changed) {
                mWorkSource.set(ws);
            }
        }
        if (changed && mHeld) {
            try {
                mService.updateWakeLockWorkSource(mToken, mWorkSource, mHistoryTag);
            } catch (RemoteException e) {
                throw e.rethrowFromSystemServer();
            }
        }
    }
}",1,"/**
 * Sets the work source associated with the wake lock.
 * <p>
 * The work source is used to determine on behalf of which application
 * the wake lock is being held.  This is useful in the case where a
 * service is performing work on behalf of an application so that the
 * cost of that work can be accounted to the application.
 * </p>
 *
 * @param ws The work source, or null if none.
 */
","/**
 * Sets the work source associated with the wake lock.
 * <p>
 * The work source is used to determine on behalf of which application
 * the wake lock is being held.  This is useful in the case where a
 * service is performing work on behalf of an application so that the
 * cost of that work can be accounted to the application.
 * </p>
 *
 * <p>
 * Make sure to follow the tag naming convention when using WorkSource
 * to make it easier for app developers to understand wake locks
 * attributed to them. See {@link PowerManager#newWakeLock(int, String)}
 * documentation.
 * </p>
 *
 * @param ws The work source, or null if none.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The only change made is in the boolean expression for the variable ""changed"": from mWorkSource.diff(ws) to !mWorkSource.equals(ws). Both expressions are used to compare two WorkSource objects, but use different methods, so the change type is 4.","There is no Compatibility Issue caused by this change. The new implementation is a straightforward replacement of the comparison logic from a diff check to an equality check, and it is intended to reflect a similar semantic i.e., whether the WorkSource has changed. The outcome remains a boolean representing if the change has occurred, which does not affect the return type or value of the method, nor does it introduce new exceptions or alter existing exception handling, therefore the CI type is 0."
518,<android.service.autofill.SaveInfo: String toString()>,27,28,<android.service.autofill.SaveInfo: String toString()>,<android.service.autofill.SaveInfo: String toString()>,0,"{
    if (!sDebug)
        return super.toString();
    return new StringBuilder(""SaveInfo: [type="").append(DebugUtils.flagsToString(SaveInfo.class, ""SAVE_DATA_TYPE_"", mType)).append("", requiredIds="").append(Arrays.toString(mRequiredIds)).append("", optionalIds="").append(Arrays.toString(mOptionalIds)).append("", description="").append(mDescription).append(DebugUtils.flagsToString(SaveInfo.class, ""NEGATIVE_BUTTON_STYLE_"", mNegativeButtonStyle)).append("", mFlags="").append(mFlags).append("", mCustomDescription="").append(mCustomDescription).append("", validation="").append(mValidator).append(""]"").toString();
}","{
    if (!sDebug)
        return super.toString();
    final StringBuilder builder = new StringBuilder(""SaveInfo: [type="").append(DebugUtils.flagsToString(SaveInfo.class, ""SAVE_DATA_TYPE_"", mType)).append("", requiredIds="").append(Arrays.toString(mRequiredIds)).append("", style="").append(DebugUtils.flagsToString(SaveInfo.class, ""NEGATIVE_BUTTON_STYLE_"", mNegativeButtonStyle));
    if (mOptionalIds != null) {
        builder.append("", optionalIds="").append(Arrays.toString(mOptionalIds));
    }
    if (mDescription != null) {
        builder.append("", description="").append(mDescription);
    }
    if (mFlags != 0) {
        builder.append("", flags="").append(mFlags);
    }
    if (mCustomDescription != null) {
        builder.append("", customDescription="").append(mCustomDescription);
    }
    if (mValidator != null) {
        builder.append("", validator="").append(mValidator);
    }
    if (mSanitizerKeys != null) {
        builder.append("", sanitizerKeys="").append(mSanitizerKeys.length);
    }
    if (mSanitizerValues != null) {
        builder.append("", sanitizerValues="").append(mSanitizerValues.length);
    }
    if (mTriggerId != null) {
        builder.append("", triggerId="").append(mTriggerId);
    }
    return builder.append(""]"").toString();
}",1,"// ///////////////////////////////////
","// ///////////////////////////////////
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,4",0,"There is a restructuring of the method to use conditionals to append parts of the string conditionally rather than unconditionally, and also introduction of new fields checks (for mSanitizerKeys, mSanitizerValues, and mTriggerId). So, the change types here are 3 and 4.","No Compatibility Issue would arise since the method's purpose is to return a string representation of the object and it is debug information. The logic ensures that all the potential information is represented, although through a different condition-checking mechanism. The actual functionality from an API consumer's perspective remains consistent, which would not impact the normal operation or cause unexpected behavior change; therefore, there is no CI."
520,"<android.hardware.SensorManager: boolean remapCoordinateSystem(float[],int,int,float[])>",27,28,"<android.hardware.SensorManager: boolean remapCoordinateSystem(float[],int,int,float[])>","<android.hardware.SensorManager: boolean remapCoordinateSystem(float[],int,int,float[])>",0,"{
    if (inR == outR) {
        final float[] temp = mTempMatrix;
        synchronized (temp) {
            // we don't expect to have a lot of contention
            if (remapCoordinateSystemImpl(inR, X, Y, temp)) {
                final int size = outR.length;
                for (int i = 0; i < size; i++) outR[i] = temp[i];
                return true;
            }
        }
    }
    return remapCoordinateSystemImpl(inR, X, Y, outR);
}","{
    if (inR == outR) {
        final float[] temp = sTempMatrix;
        synchronized (temp) {
            // we don't expect to have a lot of contention
            if (remapCoordinateSystemImpl(inR, X, Y, temp)) {
                final int size = outR.length;
                for (int i = 0; i < size; i++) {
                    outR[i] = temp[i];
                }
                return true;
            }
        }
    }
    return remapCoordinateSystemImpl(inR, X, Y, outR);
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,4,0,"The only change is from mTempMatrix to sTempMatrix which suggests a possible change in the context of the variable (from instance variable to static variable). However, this change does not affect the output of the method directly, so the change type is 4.",There is no compatibility issue introduced by this change as the logic and functionality of the method have not been altered and it does not affect the behavior of the method from the API consumer's point of view. The change is internal and does not impact the method's contract. The method behavior remains consistent between versions from the perspective of the client code.
522,"<android.text.BoringLayout: BoringLayout replaceOrMake(CharSequence,TextPaint,int,Alignment,float,float,Metrics,boolean)>",27,28,"<android.text.BoringLayout: BoringLayout replaceOrMake(CharSequence,TextPaint,int,Alignment,float,float,Metrics,boolean)>","<android.text.BoringLayout: BoringLayout replaceOrMake(CharSequence,TextPaint,int,Alignment,float,float,Metrics,boolean)>",0,"{
    replaceWith(source, paint, outerwidth, align, spacingmult, spacingadd);
    mEllipsizedWidth = outerwidth;
    mEllipsizedStart = 0;
    mEllipsizedCount = 0;
    init(source, paint, outerwidth, align, spacingmult, spacingadd, metrics, includepad, true);
    return this;
}","{
    replaceWith(source, paint, outerwidth, align, spacingMult, spacingAdd);
    mEllipsizedWidth = outerwidth;
    mEllipsizedStart = 0;
    mEllipsizedCount = 0;
    init(source, paint, align, metrics, includePad, true);
    return this;
}",1,"/**
 * Returns a BoringLayout for the specified text, potentially reusing
 * this one if it is already suitable.  The caller must make sure that
 * no one is still using this Layout.
 */
","/**
 * Returns a BoringLayout for the specified text, potentially reusing
 * this one if it is already suitable.  The caller must make sure that
 * no one is still using this Layout.
 *
 * @param source the text to render
 * @param paint the default paint for the layout
 * @param outerwidth the wrapping width for the text
 * @param align whether to left, right, or center the text
 * @param spacingMult this value is no longer used by BoringLayout
 * @param spacingAdd this value is no longer used by BoringLayout
 * @param metrics {@code #Metrics} instance that contains information about FontMetrics and
 * line width
 * @param includePad set whether to include extra space beyond font ascent and descent which is
 * needed to avoid clipping in some scripts
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,5",0,"The parameters in the `init` method call have changed, with `spacingmult` and `spacingadd` being removed and `includePad` changed to `includepad`, indicating that the dependent API `init` has changed its signature or the way it's being called, which is a code change of type 5. Also, the capitalization of `spacingMult`, `spacingAdd`, and `includePad` has been changed to comply with Java naming conventions, but this does not affect the code behavior (as Java is case sensitive), so this is not substantial. However, a control dependency change is also noticed as part of the dependent API change, which means a change type of 3.","There are no new return statements, and there are no changes related to exception handling. The method's behavior, in terms of API contract, is expected to remain the same despite the internal refactoring, as the purpose of the method seems unaltered  it still initializes with given parameters and returns `this`. Thus, there should not be a Compatibility Issue."
524,<android.hardware.camera2.CameraManager.CameraManagerGlobal: String[] getCameraIdList()>,27,28,<android.hardware.camera2.CameraManager.CameraManagerGlobal: String[] getCameraIdList()>,<android.hardware.camera2.CameraManager.CameraManagerGlobal: String[] getCameraIdList()>,0,"{
    String[] cameraIds = null;
    synchronized (mLock) {
        // Try to make sure we have an up-to-date list of camera devices.
        connectCameraServiceLocked();
        int idCount = 0;
        for (int i = 0; i < mDeviceStatus.size(); i++) {
            int status = mDeviceStatus.valueAt(i);
            if (status == ICameraServiceListener.STATUS_NOT_PRESENT || status == ICameraServiceListener.STATUS_ENUMERATING)
                continue;
            idCount++;
        }
        cameraIds = new String[idCount];
        idCount = 0;
        for (int i = 0; i < mDeviceStatus.size(); i++) {
            int status = mDeviceStatus.valueAt(i);
            if (status == ICameraServiceListener.STATUS_NOT_PRESENT || status == ICameraServiceListener.STATUS_ENUMERATING)
                continue;
            cameraIds[idCount] = mDeviceStatus.keyAt(i);
            idCount++;
        }
    }
    return cameraIds;
}","{
    String[] cameraIds = null;
    synchronized (mLock) {
        // Try to make sure we have an up-to-date list of camera devices.
        connectCameraServiceLocked();
        int idCount = 0;
        for (int i = 0; i < mDeviceStatus.size(); i++) {
            int status = mDeviceStatus.valueAt(i);
            if (status == ICameraServiceListener.STATUS_NOT_PRESENT || status == ICameraServiceListener.STATUS_ENUMERATING)
                continue;
            idCount++;
        }
        cameraIds = new String[idCount];
        idCount = 0;
        for (int i = 0; i < mDeviceStatus.size(); i++) {
            int status = mDeviceStatus.valueAt(i);
            if (status == ICameraServiceListener.STATUS_NOT_PRESENT || status == ICameraServiceListener.STATUS_ENUMERATING)
                continue;
            cameraIds[idCount] = mDeviceStatus.keyAt(i);
            idCount++;
        }
    }
    // The sort logic must match the logic in
    // libcameraservice/common/CameraProviderManager.cpp::getAPI1CompatibleCameraDeviceIds
    Arrays.sort(cameraIds, new Comparator<String>() {

        @Override
        public int compare(String s1, String s2) {
            int s1Int = 0, s2Int = 0;
            try {
                s1Int = Integer.parseInt(s1);
            } catch (NumberFormatException e) {
                s1Int = -1;
            }
            try {
                s2Int = Integer.parseInt(s2);
            } catch (NumberFormatException e) {
                s2Int = -1;
            }
            // Uint device IDs first
            if (s1Int >= 0 && s2Int >= 0) {
                return s1Int - s2Int;
            } else if (s1Int >= 0) {
                return -1;
            } else if (s2Int >= 0) {
                return 1;
            } else {
                // Simple string compare if both id are not uint
                return s1.compareTo(s2);
            }
        }
    });
    return cameraIds;
}",1,"/**
 * Get a list of all camera IDs that are at least PRESENT; ignore devices that are
 * NOT_PRESENT or ENUMERATING, since they cannot be used by anyone.
 */
","/**
 * Get a list of all camera IDs that are at least PRESENT; ignore devices that are
 * NOT_PRESENT or ENUMERATING, since they cannot be used by anyone.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The late version introduces a new logic to sort the array ""cameraIds"" just before the return statement. This change is not related to return, exception handling, or control dependency, so the code change type is 4.","The sorting of the array ""cameraIds"" will not lead to a compatibility issue since it does not affect the data type or the occurrence of exceptions. The method still returns a String array of the same camera IDs, albeit sorted, which does not constitute a change in the API's external behavior in terms of producing different return types or throwing different exceptions."
525,<android.os.Binder: IInterface queryLocalInterface(String)>,27,28,<android.os.Binder: IInterface queryLocalInterface(String)>,<android.os.Binder: IInterface queryLocalInterface(String)>,0,"{
    if (mDescriptor.equals(descriptor)) {
        return mOwner;
    }
    return null;
}","{
    if (mDescriptor != null && mDescriptor.equals(descriptor)) {
        return mOwner;
    }
    return null;
}",1,"/**
 * Use information supplied to attachInterface() to return the
 * associated IInterface if it matches the requested
 * descriptor.
 */
","/**
 * Use information supplied to attachInterface() to return the
 * associated IInterface if it matches the requested
 * descriptor.
 */
",-1,[@Nullable],[@Nullable],-1,-1,-1,-1,-1,-1,3,0,"The control statement 'if' has an added null check for mDescriptor, so the code change type is 3.","The change introduces an additional null check for mDescriptor which prevents a possible NullPointerException if mDescriptor is null. However, this does not lead to a Compatibility Issue because it does not change the expected behavior of the method in terms of the returned value or the exceptions it may throw. If mDescriptor is null, both versions would return null. The late version just adds a check to make the null condition explicit and safe to avoid a potential NullPointerException."
526,"<android.view.inputmethod.InputMethodManager: boolean startInputInner(int,IBinder,int,int,int)>",27,28,"<android.view.inputmethod.InputMethodManager: boolean startInputInner(int,IBinder,int,int,int)>","<android.view.inputmethod.InputMethodManager: boolean startInputInner(int,IBinder,int,int,int)>",0,"{
    final View view;
    synchronized (mH) {
        view = mServedView;
        // Make sure we have a window token for the served view.
        if (DEBUG) {
            Log.v(TAG, ""Starting input: view="" + dumpViewInfo(view) + "" reason="" + InputMethodClient.getStartInputReason(startInputReason));
        }
        if (view == null) {
            if (DEBUG)
                Log.v(TAG, ""ABORT input: no served view!"");
            return false;
        }
    }
    // Now we need to get an input connection from the served view.
    // This is complicated in a couple ways: we can't be holding our lock
    // when calling out to the view, and we need to make sure we call into
    // the view on the same thread that is driving its view hierarchy.
    Handler vh = view.getHandler();
    if (vh == null) {
        // screen without a connection.
        if (DEBUG)
            Log.v(TAG, ""ABORT input: no handler for view! Close current input."");
        closeCurrentInput();
        return false;
    }
    if (vh.getLooper() != Looper.myLooper()) {
        // we need to reschedule our work for over there.
        if (DEBUG)
            Log.v(TAG, ""Starting input: reschedule to view thread"");
        vh.post(new Runnable() {

            @Override
            public void run() {
                startInputInner(startInputReason, null, 0, 0, 0);
            }
        });
        return false;
    }
    // Okay we are now ready to call into the served view and have it
    // do its stuff.
    // Life is good: let's hook everything up!
    EditorInfo tba = new EditorInfo();
    // Note: Use Context#getOpPackageName() rather than Context#getPackageName() so that the
    // system can verify the consistency between the uid of this process and package name passed
    // from here. See comment of Context#getOpPackageName() for details.
    tba.packageName = view.getContext().getOpPackageName();
    tba.fieldId = view.getId();
    InputConnection ic = view.onCreateInputConnection(tba);
    if (DEBUG)
        Log.v(TAG, ""Starting input: tba="" + tba + "" ic="" + ic);
    synchronized (mH) {
        // changed.
        if (mServedView != view || !mServedConnecting) {
            // Something else happened, so abort.
            if (DEBUG)
                Log.v(TAG, ""Starting input: finished by someone else. view="" + dumpViewInfo(view) + "" mServedView="" + dumpViewInfo(mServedView) + "" mServedConnecting="" + mServedConnecting);
            return false;
        }
        // connected so we want to restart it.
        if (mCurrentTextBoxAttribute == null) {
            controlFlags |= CONTROL_START_INITIAL;
        }
        // Hook 'em up and let 'er rip.
        mCurrentTextBoxAttribute = tba;
        mServedConnecting = false;
        if (mServedInputConnectionWrapper != null) {
            mServedInputConnectionWrapper.deactivate();
            mServedInputConnectionWrapper = null;
        }
        ControlledInputConnectionWrapper servedContext;
        final int missingMethodFlags;
        if (ic != null) {
            mCursorSelStart = tba.initialSelStart;
            mCursorSelEnd = tba.initialSelEnd;
            mCursorCandStart = -1;
            mCursorCandEnd = -1;
            mCursorRect.setEmpty();
            mCursorAnchorInfo = null;
            final Handler icHandler;
            missingMethodFlags = InputConnectionInspector.getMissingMethodFlags(ic);
            if ((missingMethodFlags & InputConnectionInspector.MissingMethodFlags.GET_HANDLER) != 0) {
                // InputConnection#getHandler() is not implemented.
                icHandler = null;
            } else {
                icHandler = ic.getHandler();
            }
            servedContext = new ControlledInputConnectionWrapper(icHandler != null ? icHandler.getLooper() : vh.getLooper(), ic, this);
        } else {
            servedContext = null;
            missingMethodFlags = 0;
        }
        mServedInputConnectionWrapper = servedContext;
        try {
            if (DEBUG)
                Log.v(TAG, ""START INPUT: view="" + dumpViewInfo(view) + "" ic="" + ic + "" tba="" + tba + "" controlFlags=#"" + Integer.toHexString(controlFlags));
            final InputBindResult res = mService.startInputOrWindowGainedFocus(startInputReason, mClient, windowGainingFocus, controlFlags, softInputMode, windowFlags, tba, servedContext, missingMethodFlags);
            if (DEBUG)
                Log.v(TAG, ""Starting input: Bind result="" + res);
            if (res != null) {
                if (res.id != null) {
                    setInputChannelLocked(res.channel);
                    mBindSequence = res.sequence;
                    mCurMethod = res.method;
                    mCurId = res.id;
                    mNextUserActionNotificationSequenceNumber = res.userActionNotificationSequenceNumber;
                } else {
                    if (res.channel != null && res.channel != mCurChannel) {
                        res.channel.dispose();
                    }
                    if (mCurMethod == null) {
                        // This means there is no input method available.
                        if (DEBUG)
                            Log.v(TAG, ""ABORT input: no input method!"");
                        return true;
                    }
                }
            } else {
                if (startInputReason == InputMethodClient.START_INPUT_REASON_WINDOW_FOCUS_GAIN) {
                    // TODO: InputBindResult should have the error code.
                    if (DEBUG)
                        Log.w(TAG, ""startInputOrWindowGainedFocus failed. "" + ""Window focus may have already been lost. "" + ""win="" + windowGainingFocus + "" view="" + dumpViewInfo(view));
                    if (!mActive) {
                        // mHasBeenInactive is a latch switch to forcefully refresh IME focus
                        // state when an inactive (mActive == false) client is gaining window
                        // focus. In case we have unnecessary disable the latch due to this
                        // spurious wakeup, we re-enable the latch here.
                        // TODO: Come up with more robust solution.
                        mHasBeenInactive = true;
                    }
                }
            }
            if (mCurMethod != null && mCompletions != null) {
                try {
                    mCurMethod.displayCompletions(mCompletions);
                } catch (RemoteException e) {
                }
            }
        } catch (RemoteException e) {
            Log.w(TAG, ""IME died: "" + mCurId, e);
        }
    }
    return true;
}","{
    final View view;
    synchronized (mH) {
        view = mServedView;
        // Make sure we have a window token for the served view.
        if (DEBUG) {
            Log.v(TAG, ""Starting input: view="" + dumpViewInfo(view) + "" reason="" + InputMethodClient.getStartInputReason(startInputReason));
        }
        if (view == null) {
            if (DEBUG)
                Log.v(TAG, ""ABORT input: no served view!"");
            return false;
        }
    }
    // Now we need to get an input connection from the served view.
    // This is complicated in a couple ways: we can't be holding our lock
    // when calling out to the view, and we need to make sure we call into
    // the view on the same thread that is driving its view hierarchy.
    Handler vh = view.getHandler();
    if (vh == null) {
        // screen without a connection.
        if (DEBUG)
            Log.v(TAG, ""ABORT input: no handler for view! Close current input."");
        closeCurrentInput();
        return false;
    }
    if (vh.getLooper() != Looper.myLooper()) {
        // we need to reschedule our work for over there.
        if (DEBUG)
            Log.v(TAG, ""Starting input: reschedule to view thread"");
        vh.post(() -> startInputInner(startInputReason, null, 0, 0, 0));
        return false;
    }
    // Okay we are now ready to call into the served view and have it
    // do its stuff.
    // Life is good: let's hook everything up!
    EditorInfo tba = new EditorInfo();
    // Note: Use Context#getOpPackageName() rather than Context#getPackageName() so that the
    // system can verify the consistency between the uid of this process and package name passed
    // from here. See comment of Context#getOpPackageName() for details.
    tba.packageName = view.getContext().getOpPackageName();
    tba.fieldId = view.getId();
    InputConnection ic = view.onCreateInputConnection(tba);
    if (DEBUG)
        Log.v(TAG, ""Starting input: tba="" + tba + "" ic="" + ic);
    synchronized (mH) {
        // changed.
        if (mServedView != view || !mServedConnecting) {
            // Something else happened, so abort.
            if (DEBUG)
                Log.v(TAG, ""Starting input: finished by someone else. view="" + dumpViewInfo(view) + "" mServedView="" + dumpViewInfo(mServedView) + "" mServedConnecting="" + mServedConnecting);
            return false;
        }
        // connected so we want to restart it.
        if (mCurrentTextBoxAttribute == null) {
            controlFlags |= CONTROL_START_INITIAL;
        }
        // Hook 'em up and let 'er rip.
        mCurrentTextBoxAttribute = tba;
        mServedConnecting = false;
        if (mServedInputConnectionWrapper != null) {
            mServedInputConnectionWrapper.deactivate();
            mServedInputConnectionWrapper = null;
        }
        ControlledInputConnectionWrapper servedContext;
        final int missingMethodFlags;
        if (ic != null) {
            mCursorSelStart = tba.initialSelStart;
            mCursorSelEnd = tba.initialSelEnd;
            mCursorCandStart = -1;
            mCursorCandEnd = -1;
            mCursorRect.setEmpty();
            mCursorAnchorInfo = null;
            final Handler icHandler;
            missingMethodFlags = InputConnectionInspector.getMissingMethodFlags(ic);
            if ((missingMethodFlags & InputConnectionInspector.MissingMethodFlags.GET_HANDLER) != 0) {
                // InputConnection#getHandler() is not implemented.
                icHandler = null;
            } else {
                icHandler = ic.getHandler();
            }
            servedContext = new ControlledInputConnectionWrapper(icHandler != null ? icHandler.getLooper() : vh.getLooper(), ic, this);
        } else {
            servedContext = null;
            missingMethodFlags = 0;
        }
        mServedInputConnectionWrapper = servedContext;
        try {
            if (DEBUG)
                Log.v(TAG, ""START INPUT: view="" + dumpViewInfo(view) + "" ic="" + ic + "" tba="" + tba + "" controlFlags=#"" + Integer.toHexString(controlFlags));
            final InputBindResult res = mService.startInputOrWindowGainedFocus(startInputReason, mClient, windowGainingFocus, controlFlags, softInputMode, windowFlags, tba, servedContext, missingMethodFlags, view.getContext().getApplicationInfo().targetSdkVersion);
            if (DEBUG)
                Log.v(TAG, ""Starting input: Bind result="" + res);
            if (res == null) {
                Log.wtf(TAG, ""startInputOrWindowGainedFocus must not return"" + "" null. startInputReason="" + InputMethodClient.getStartInputReason(startInputReason) + "" editorInfo="" + tba + "" controlFlags=#"" + Integer.toHexString(controlFlags));
                return false;
            }
            if (res.id != null) {
                setInputChannelLocked(res.channel);
                mBindSequence = res.sequence;
                mCurMethod = res.method;
                mCurId = res.id;
                mNextUserActionNotificationSequenceNumber = res.userActionNotificationSequenceNumber;
            } else if (res.channel != null && res.channel != mCurChannel) {
                res.channel.dispose();
            }
            switch(res.result) {
                case InputBindResult.ResultCode.ERROR_NOT_IME_TARGET_WINDOW:
                    mRestartOnNextWindowFocus = true;
                    break;
            }
            if (mCurMethod != null && mCompletions != null) {
                try {
                    mCurMethod.displayCompletions(mCompletions);
                } catch (RemoteException e) {
                }
            }
        } catch (RemoteException e) {
            Log.w(TAG, ""IME died: "" + mCurId, e);
        }
    }
    return true;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,,,,
527,<android.os.ParcelFileDescriptor: int detachFd()>,27,28,<android.os.ParcelFileDescriptor: int detachFd()>,<android.os.ParcelFileDescriptor: int detachFd()>,0,"{
    if (mWrapped != null) {
        return mWrapped.detachFd();
    } else {
        if (mClosed) {
            throw new IllegalStateException(""Already closed"");
        }
        final int fd = getFd();
        Parcel.clearFileDescriptor(mFd);
        writeCommStatusAndClose(Status.DETACHED, null);
        mClosed = true;
        mGuard.close();
        releaseResources();
        return fd;
    }
}","{
    if (mWrapped != null) {
        return mWrapped.detachFd();
    } else {
        if (mClosed) {
            throw new IllegalStateException(""Already closed"");
        }
        final int fd = getFd();
        mFd.setInt$(-1);
        writeCommStatusAndClose(Status.DETACHED, null);
        mClosed = true;
        mGuard.close();
        releaseResources();
        return fd;
    }
}",1,"/**
 * Return the native fd int for this ParcelFileDescriptor and detach it from
 * the object here. You are now responsible for closing the fd in native
 * code.
 * <p>
 * You should not detach when the original creator of the descriptor is
 * expecting a reliable signal through {@link #close()} or
 * {@link #closeWithError(String)}.
 *
 * @see #canDetectErrors()
 */
","/**
 * Return the native fd int for this ParcelFileDescriptor and detach it from
 * the object here. You are now responsible for closing the fd in native
 * code.
 * <p>
 * You should not detach when the original creator of the descriptor is
 * expecting a reliable signal through {@link #close()} or
 * {@link #closeWithError(String)}.
 *
 * @see #canDetectErrors()
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"The statement Parcel.clearFileDescriptor(mFd) in the early version is replaced with mFd.setInt$(-1) in the late version. This change affects an internal operation on the mFd object, but the external behavior and the return value of the function are invariant. Also, the change in how the file descriptor is detached (the internal state change of mFd) is a change in the dependent API, thus change type 5 is applicable.","This change does not affect the return value of the method nor the exceptions it throws. The method's behavior from the caller's point of view remains the same, returning the same fd value without introducing new exceptions or omitting existing ones. Hence, there is no Compatibility Issue, pred_CI is 0."
529,<android.view.View: boolean isImportantForAccessibility()>,27,28,<android.view.View: boolean isImportantForAccessibility()>,<android.view.View: boolean isImportantForAccessibility()>,0,"{
    final int mode = (mPrivateFlags2 & PFLAG2_IMPORTANT_FOR_ACCESSIBILITY_MASK) >> PFLAG2_IMPORTANT_FOR_ACCESSIBILITY_SHIFT;
    if (mode == IMPORTANT_FOR_ACCESSIBILITY_NO || mode == IMPORTANT_FOR_ACCESSIBILITY_NO_HIDE_DESCENDANTS) {
        return false;
    }
    // Check parent mode to ensure we're not hidden.
    ViewParent parent = mParent;
    while (parent instanceof View) {
        if (((View) parent).getImportantForAccessibility() == IMPORTANT_FOR_ACCESSIBILITY_NO_HIDE_DESCENDANTS) {
            return false;
        }
        parent = parent.getParent();
    }
    return mode == IMPORTANT_FOR_ACCESSIBILITY_YES || isActionableForAccessibility() || hasListenersForAccessibility() || getAccessibilityNodeProvider() != null || getAccessibilityLiveRegion() != ACCESSIBILITY_LIVE_REGION_NONE;
}","{
    final int mode = (mPrivateFlags2 & PFLAG2_IMPORTANT_FOR_ACCESSIBILITY_MASK) >> PFLAG2_IMPORTANT_FOR_ACCESSIBILITY_SHIFT;
    if (mode == IMPORTANT_FOR_ACCESSIBILITY_NO || mode == IMPORTANT_FOR_ACCESSIBILITY_NO_HIDE_DESCENDANTS) {
        return false;
    }
    // Check parent mode to ensure we're not hidden.
    ViewParent parent = mParent;
    while (parent instanceof View) {
        if (((View) parent).getImportantForAccessibility() == IMPORTANT_FOR_ACCESSIBILITY_NO_HIDE_DESCENDANTS) {
            return false;
        }
        parent = parent.getParent();
    }
    return mode == IMPORTANT_FOR_ACCESSIBILITY_YES || isActionableForAccessibility() || hasListenersForAccessibility() || getAccessibilityNodeProvider() != null || getAccessibilityLiveRegion() != ACCESSIBILITY_LIVE_REGION_NONE || isAccessibilityPane();
}",1,"/**
 * Computes whether this view should be exposed for accessibility. In
 * general, views that are interactive or provide information are exposed
 * while views that serve only as containers are hidden.
 * <p>
 * If an ancestor of this view has importance
 * {@link #IMPORTANT_FOR_ACCESSIBILITY_NO_HIDE_DESCENDANTS}, this method
 * returns <code>false</code>.
 * <p>
 * Otherwise, the value is computed according to the view's
 * {@link #getImportantForAccessibility()} value:
 * <ol>
 * <li>{@link #IMPORTANT_FOR_ACCESSIBILITY_NO} or
 * {@link #IMPORTANT_FOR_ACCESSIBILITY_NO_HIDE_DESCENDANTS}, return <code>false
 * </code>
 * <li>{@link #IMPORTANT_FOR_ACCESSIBILITY_YES}, return <code>true</code>
 * <li>{@link #IMPORTANT_FOR_ACCESSIBILITY_AUTO}, return <code>true</code> if
 * view satisfies any of the following:
 * <ul>
 * <li>Is actionable, e.g. {@link #isClickable()},
 * {@link #isLongClickable()}, or {@link #isFocusable()}
 * <li>Has an {@link AccessibilityDelegate}
 * <li>Has an interaction listener, e.g. {@link OnTouchListener},
 * {@link OnKeyListener}, etc.
 * <li>Is an accessibility live region, e.g.
 * {@link #getAccessibilityLiveRegion()} is not
 * {@link #ACCESSIBILITY_LIVE_REGION_NONE}.
 * </ul>
 * </ol>
 *
 * @return Whether the view is exposed for accessibility.
 * @see #setImportantForAccessibility(int)
 * @see #getImportantForAccessibility()
 */
","/**
 * Computes whether this view should be exposed for accessibility. In
 * general, views that are interactive or provide information are exposed
 * while views that serve only as containers are hidden.
 * <p>
 * If an ancestor of this view has importance
 * {@link #IMPORTANT_FOR_ACCESSIBILITY_NO_HIDE_DESCENDANTS}, this method
 * returns <code>false</code>.
 * <p>
 * Otherwise, the value is computed according to the view's
 * {@link #getImportantForAccessibility()} value:
 * <ol>
 * <li>{@link #IMPORTANT_FOR_ACCESSIBILITY_NO} or
 * {@link #IMPORTANT_FOR_ACCESSIBILITY_NO_HIDE_DESCENDANTS}, return <code>false
 * </code>
 * <li>{@link #IMPORTANT_FOR_ACCESSIBILITY_YES}, return <code>true</code>
 * <li>{@link #IMPORTANT_FOR_ACCESSIBILITY_AUTO}, return <code>true</code> if
 * view satisfies any of the following:
 * <ul>
 * <li>Is actionable, e.g. {@link #isClickable()},
 * {@link #isLongClickable()}, or {@link #isFocusable()}
 * <li>Has an {@link AccessibilityDelegate}
 * <li>Has an interaction listener, e.g. {@link OnTouchListener},
 * {@link OnKeyListener}, etc.
 * <li>Is an accessibility live region, e.g.
 * {@link #getAccessibilityLiveRegion()} is not
 * {@link #ACCESSIBILITY_LIVE_REGION_NONE}.
 * </ul>
 * <li>Has an accessibility pane title, see {@link #setAccessibilityPaneTitle}</li>
 * </ol>
 *
 * @return Whether the view is exposed for accessibility.
 * @see #setImportantForAccessibility(int)
 * @see #getImportantForAccessibility()
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,1,"The method implementation has a new conditional check ""isAccessibilityPane()"" at the end of the return statement, which is a change in the ""other statement"" category (4).","This additional condition could potentially change the return value of the method when ""isAccessibilityPane()"" is true. The change can cause the method to return true where it previously would have returned false, which indicates a potential Compatibility Issue of type 1 (issue caused by potential different return values)."
530,<android.util.AtomicFile: void finishWrite(FileOutputStream)>,27,28,<android.util.AtomicFile: void finishWrite(FileOutputStream)>,<android.util.AtomicFile: void finishWrite(FileOutputStream)>,0,"{
    if (str != null) {
        FileUtils.sync(str);
        try {
            str.close();
            mBackupName.delete();
        } catch (IOException e) {
            Log.w(""AtomicFile"", ""finishWrite: Got exception:"", e);
        }
    }
}","{
    if (str != null) {
        FileUtils.sync(str);
        try {
            str.close();
            mBackupName.delete();
        } catch (IOException e) {
            Log.w(""AtomicFile"", ""finishWrite: Got exception:"", e);
        }
        if (mCommitTag != null) {
            com.android.internal.logging.EventLogTags.writeCommitSysConfigFile(mCommitTag, SystemClock.uptimeMillis() - mStartTime);
        }
    }
}",1,"/**
 * Call when you have successfully finished writing to the stream
 * returned by {@link #startWrite()}.  This will close, sync, and
 * commit the new data.  The next attempt to read the atomic file
 * will return the new file stream.
 */
","/**
 * Call when you have successfully finished writing to the stream
 * returned by {@link #startWrite()}.  This will close, sync, and
 * commit the new data.  The next attempt to read the atomic file
 * will return the new file stream.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The late version adds a new block of code that logs an event using an EventLogTags API if `mCommitTag` is not null. This is neither a change in the return statement nor an exception handling statement, so the code change type is 4.","The added code for logging does not affect the return type or value, nor does it change exception handling. It doesn't change the behavior of the method in a way that would affect clients depending on its functionality. Therefore, there is no Compatibility Issue, and the CI type is 0."
532,"<android.inputmethodservice.InputMethodService.InputMethodImpl: void showSoftInput(int,ResultReceiver)>",27,28,"<android.inputmethodservice.InputMethodService.InputMethodImpl: void showSoftInput(int,ResultReceiver)>","<android.inputmethodservice.InputMethodService.InputMethodImpl: void showSoftInput(int,ResultReceiver)>",0,"{
    if (DEBUG)
        Log.v(TAG, ""showSoftInput()"");
    boolean wasVis = isInputViewShown();
    if (dispatchOnShowInputRequested(flags, false)) {
        try {
            showWindow(true);
        } catch (BadTokenException e) {
        // We have ignored BadTokenException here since Jelly Bean MR-2 (API Level 18).
        // We could ignore BadTokenException in InputMethodService#showWindow() instead,
        // but it may break assumptions for those who override #showWindow() that we can
        // detect errors in #showWindow() by checking BadTokenException.
        // TODO: Investigate its feasibility.  Update JavaDoc of #showWindow() of
        // whether it's OK to override #showWindow() or not.
        }
    }
    clearInsetOfPreviousIme();
    // If user uses hard keyboard, IME button should always be shown.
    boolean showing = isInputViewShown();
    mImm.setImeWindowStatus(mToken, mStartInputToken, IME_ACTIVE | (showing ? IME_VISIBLE : 0), mBackDisposition);
    if (resultReceiver != null) {
        resultReceiver.send(wasVis != isInputViewShown() ? InputMethodManager.RESULT_SHOWN : (wasVis ? InputMethodManager.RESULT_UNCHANGED_SHOWN : InputMethodManager.RESULT_UNCHANGED_HIDDEN), null);
    }
}","{
    if (DEBUG)
        Log.v(TAG, ""showSoftInput()"");
    boolean wasVis = isInputViewShown();
    if (dispatchOnShowInputRequested(flags, false)) {
        try {
            showWindow(true);
        } catch (BadTokenException e) {
        // We have ignored BadTokenException here since Jelly Bean MR-2 (API Level 18).
        // We could ignore BadTokenException in InputMethodService#showWindow() instead,
        // but it may break assumptions for those who override #showWindow() that we can
        // detect errors in #showWindow() by checking BadTokenException.
        // TODO: Investigate its feasibility.  Update JavaDoc of #showWindow() of
        // whether it's OK to override #showWindow() or not.
        }
    }
    clearInsetOfPreviousIme();
    // If user uses hard keyboard, IME button should always be shown.
    mImm.setImeWindowStatus(mToken, mStartInputToken, mapToImeWindowStatus(isInputViewShown()), mBackDisposition);
    if (resultReceiver != null) {
        resultReceiver.send(wasVis != isInputViewShown() ? InputMethodManager.RESULT_SHOWN : (wasVis ? InputMethodManager.RESULT_UNCHANGED_SHOWN : InputMethodManager.RESULT_UNCHANGED_HIDDEN), null);
    }
}",1,"/**
 * Handle a request by the system to show the soft input area.
 */
","/**
 * {@inheritDoc}
 */
",-1,,"[@MainThread, @Override]",-1,-1,-1,-1,-1,-1,"4,5",0,"The statement calling `mImm.setImeWindowStatus()` has changed from using a ternary operation inline to calling a method `mapToImeWindowStatus()`; this is categorized as 'Other statement changed' (4). The dependent API `mapToImeWindowStatus()` is not present in the early version, implying a 'Dependent API changed' (5).","Since the information about `mapToImeWindowStatus()` is not provided, we cannot determine if the output could potentially lead to a different return value or cause a new exception. However, assuming that `mapToImeWindowStatus(isInputViewShown())` behaves identically to the ternary operation `IME_ACTIVE | (showing ? IME_VISIBLE : 0)`, and considering there are no changes to the logic that influences the behavior of `resultReceiver.send()`, no compatibility issues are expected (0)."
533,"<android.nfc.cardemulation.CardEmulation: List<String> getAidsForService(ComponentName,String)>",27,28,"<android.nfc.cardemulation.CardEmulation: List<String> getAidsForService(ComponentName,String)>","<android.nfc.cardemulation.CardEmulation: List<String> getAidsForService(ComponentName,String)>",0,"{
    try {
        AidGroup group = sService.getAidGroupForService(UserHandle.myUserId(), service, category);
        return (group != null ? group.getAids() : null);
    } catch (RemoteException e) {
        recoverService();
        if (sService == null) {
            Log.e(TAG, ""Failed to recover CardEmulationService."");
            return null;
        }
        try {
            AidGroup group = sService.getAidGroupForService(UserHandle.myUserId(), service, category);
            return (group != null ? group.getAids() : null);
        } catch (RemoteException ee) {
            Log.e(TAG, ""Failed to recover CardEmulationService."");
            return null;
        }
    }
}","{
    try {
        AidGroup group = sService.getAidGroupForService(mContext.getUserId(), service, category);
        return (group != null ? group.getAids() : null);
    } catch (RemoteException e) {
        recoverService();
        if (sService == null) {
            Log.e(TAG, ""Failed to recover CardEmulationService."");
            return null;
        }
        try {
            AidGroup group = sService.getAidGroupForService(mContext.getUserId(), service, category);
            return (group != null ? group.getAids() : null);
        } catch (RemoteException ee) {
            Log.e(TAG, ""Failed to recover CardEmulationService."");
            return null;
        }
    }
}",1,"/**
 * Retrieves the currently registered AIDs for the specified
 * category for a service.
 *
 * <p>Note that this will only return AIDs that were dynamically
 * registered using {@link #registerAidsForService(ComponentName, String, List)}
 * method. It will *not* return AIDs that were statically registered
 * in the manifest.
 *
 * @param service The component name of the service
 * @param category The category for which the AIDs were registered,
 * e.g. {@link #CATEGORY_PAYMENT}
 * @return The list of AIDs registered for this category, or null if it couldn't be found.
 */
","/**
 * Retrieves the currently registered AIDs for the specified
 * category for a service.
 *
 * <p>Note that this will only return AIDs that were dynamically
 * registered using {@link #registerAidsForService(ComponentName, String, List)}
 * method. It will *not* return AIDs that were statically registered
 * in the manifest.
 *
 * @param service The component name of the service
 * @param category The category for which the AIDs were registered,
 * e.g. {@link #CATEGORY_PAYMENT}
 * @return The list of AIDs registered for this category, or null if it couldn't be found.
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The dependent API call UserHandle.myUserId() has been changed to mContext.getUserId() in the two try blocks, therefore the code change type is 5.","There is no change in return statements or exception handling that would lead to a compatibility issue as the method's signature and return type remain consistent, and the exception handling logic has not been altered. The behavior of the API depends on the user ID passed to getAidGroupForService method which is an implementation detail. Assuming that the context's getUserId method returns the same ID as UserHandle.myUserId() for the given context of the CardEmulation service, there should be no compatibility issue. Hence, the CI type is 0."
534,<android.text.format.DateFormat: DateFormat getTimeFormat(Context)>,27,28,<android.text.format.DateFormat: DateFormat getTimeFormat(Context)>,<android.text.format.DateFormat: DateFormat getTimeFormat(Context)>,0,"{
    return new java.text.SimpleDateFormat(getTimeFormatString(context));
}","{
    final Locale locale = context.getResources().getConfiguration().locale;
    return new java.text.SimpleDateFormat(getTimeFormatString(context), locale);
}",1,"/**
 * Returns a {@link java.text.DateFormat} object that can format the time according
 * to the current locale and the user's 12-/24-hour clock preference.
 * @param context the application context
 * @return the {@link java.text.DateFormat} object that properly formats the time.
 */
","/**
 * Returns a {@link java.text.DateFormat} object that can format the time according
 * to the context's locale and the user's 12-/24-hour clock preference.
 * @param context the application context
 * @return the {@link java.text.DateFormat} object that properly formats the time.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The constructor call for `java.text.SimpleDateFormat` has changed from a single argument to a dual-argument call, including `getLocale()`. This means a dependent API (`getTimeFormatString(context)`) has been overloaded with an additional parameter, so change type is 1,5.","The change in the constructor may cause the method to return `DateFormat` objects formatted with different locales, which implies a difference in behavior and potential incompatibility. Therefore, the CI type is 1."
535,<android.app.SharedPreferencesImpl.EditorImpl: void apply()>,27,28,<android.app.SharedPreferencesImpl.EditorImpl: void apply()>,<android.app.SharedPreferencesImpl.EditorImpl: void apply()>,0,"{
    final long startTime = System.currentTimeMillis();
    final MemoryCommitResult mcr = commitToMemory();
    final Runnable awaitCommit = new Runnable() {

        public void run() {
            try {
                mcr.writtenToDiskLatch.await();
            } catch (InterruptedException ignored) {
            }
            if (DEBUG && mcr.wasWritten) {
                Log.d(TAG, mFile.getName() + "":"" + mcr.memoryStateGeneration + "" applied after "" + (System.currentTimeMillis() - startTime) + "" ms"");
            }
        }
    };
    QueuedWork.addFinisher(awaitCommit);
    Runnable postWriteRunnable = new Runnable() {

        public void run() {
            awaitCommit.run();
            QueuedWork.removeFinisher(awaitCommit);
        }
    };
    SharedPreferencesImpl.this.enqueueDiskWrite(mcr, postWriteRunnable);
    // Okay to notify the listeners before it's hit disk
    // because the listeners should always get the same
    // SharedPreferences instance back, which has the
    // changes reflected in memory.
    notifyListeners(mcr);
}","{
    final long startTime = System.currentTimeMillis();
    final MemoryCommitResult mcr = commitToMemory();
    final Runnable awaitCommit = new Runnable() {

        @Override
        public void run() {
            try {
                mcr.writtenToDiskLatch.await();
            } catch (InterruptedException ignored) {
            }
            if (DEBUG && mcr.wasWritten) {
                Log.d(TAG, mFile.getName() + "":"" + mcr.memoryStateGeneration + "" applied after "" + (System.currentTimeMillis() - startTime) + "" ms"");
            }
        }
    };
    QueuedWork.addFinisher(awaitCommit);
    Runnable postWriteRunnable = new Runnable() {

        @Override
        public void run() {
            awaitCommit.run();
            QueuedWork.removeFinisher(awaitCommit);
        }
    };
    SharedPreferencesImpl.this.enqueueDiskWrite(mcr, postWriteRunnable);
    // Okay to notify the listeners before it's hit disk
    // because the listeners should always get the same
    // SharedPreferences instance back, which has the
    // changes reflected in memory.
    notifyListeners(mcr);
}",1,,,-1,,[@Override],-1,-1,-1,-1,-1,-1,4,0,"The only change between the versions is the addition of the @Override annotation, which does not change the actual functionality of the method but rather indicates that a method overrides a method in a superclass. Therefore, the change type is 4.",The use of the @Override annotation has no functional impact on the behavior of the method and cannot cause a Compatibility Issue.
536,<android.os.StrictMode: ThreadPolicy getThreadPolicy()>,27,28,<android.os.StrictMode: ThreadPolicy getThreadPolicy()>,<android.os.StrictMode: ThreadPolicy getThreadPolicy()>,0,"{
    // should be in a thread-local and not allocate on each call.
    return new ThreadPolicy(getThreadPolicyMask());
}","{
    // should be in a thread-local and not allocate on each call.
    return new ThreadPolicy(getThreadPolicyMask(), sThreadViolationListener.get(), sThreadViolationExecutor.get());
}",1,"/**
 * Returns the current thread's policy.
 */
","/**
 * Returns the current thread's policy.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The constructor called for ThreadPolicy has changed from one parameter to three parameters in the late version which indicates a change in the ThreadPolicy object initialization process. Additionally, the method getThreadPolicyMask() remained unchanged, but the late version now also uses sThreadViolationListener.get() and sThreadViolationExecutor.get() as additional parameters for the constructor. This could be a change in a dependent API since the constructor for ThreadPolicy can be considered as being a dependent API, so the change type is 1,5.","The modification to the constructor invocation can potentially lead to a different ThreadPolicy object being returned due to new behavior or fields being initialized with additional information from the newly added parameters (sThreadViolationListener.get() and sThreadViolationExecutor.get()). Consequently, this would cause the API to return different objects between early and late versions, so the CI type is 1."
537,"<android.bluetooth.le.BluetoothLeScanner.BleScanCallbackWrapper: void onFoundOrLost(boolean,ScanResult)>",27,28,"<android.bluetooth.le.BluetoothLeScanner.BleScanCallbackWrapper: void onFoundOrLost(boolean,ScanResult)>","<android.bluetooth.le.BluetoothLeScanner.BleScanCallbackWrapper: void onFoundOrLost(boolean,ScanResult)>",0,"{
    if (VDBG) {
        Log.d(TAG, ""onFoundOrLost() - onFound = "" + onFound + "" "" + scanResult.toString());
    }
    // Check null in case the scan has been stopped
    synchronized (this) {
        if (mScannerId <= 0)
            return;
    }
    Handler handler = new Handler(Looper.getMainLooper());
    handler.post(new Runnable() {

        @Override
        public void run() {
            if (onFound) {
                mScanCallback.onScanResult(ScanSettings.CALLBACK_TYPE_FIRST_MATCH, scanResult);
            } else {
                mScanCallback.onScanResult(ScanSettings.CALLBACK_TYPE_MATCH_LOST, scanResult);
            }
        }
    });
}","{
    if (VDBG) {
        Log.d(TAG, ""onFoundOrLost() - onFound = "" + onFound + "" "" + scanResult.toString());
    }
    // Check null in case the scan has been stopped
    synchronized (this) {
        if (mScannerId <= 0) {
            return;
        }
    }
    Handler handler = new Handler(Looper.getMainLooper());
    handler.post(new Runnable() {

        @Override
        public void run() {
            if (onFound) {
                mScanCallback.onScanResult(ScanSettings.CALLBACK_TYPE_FIRST_MATCH, scanResult);
            } else {
                mScanCallback.onScanResult(ScanSettings.CALLBACK_TYPE_MATCH_LOST, scanResult);
            }
        }
    });
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,0,0,There are no differences in the implementation of the methods from the early version to the late version. The code remains identical.,"Since there is no change in the code, there are no compatibility issues between the two versions of the API."
539,<android.hardware.camera2.impl.CallbackProxies.SessionStateCallbackProxy: void onCaptureQueueEmpty(CameraCaptureSession)>,27,28,<android.hardware.camera2.impl.CallbackProxies.SessionStateCallbackProxy: void onCaptureQueueEmpty(CameraCaptureSession)>,<android.hardware.camera2.impl.CallbackProxies.SessionStateCallbackProxy: void onCaptureQueueEmpty(CameraCaptureSession)>,0,"{
    mProxy.invoke(""onCaptureQueueEmpty"", session);
}","{
    final long ident = Binder.clearCallingIdentity();
    try {
        mExecutor.execute(() -> mCallback.onCaptureQueueEmpty(session));
    } finally {
        Binder.restoreCallingIdentity(ident);
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"2,4",2,"The method implementation changed from using mProxy.invoke to execute a Runnable using mExecutor with a significant change in the way how the callback is executed, including handling the Binder identity. Thus, the change type is exception handling statement changed (2) as well as other statement changed (4) because of the invocation change.","The late version includes handling of Binder identity that isn't present in the early version, and the execution context of the callback has changed due to wrapping the callback in a Runnable to be executed by an Executor. This means the callback may now throw different runtime exceptions related to thread execution or security contexts, which represents a Compatibility Issue of type 2."
541,"<android.app.WallpaperManager: int setStream(InputStream,Rect,boolean,int)>",27,28,"<android.app.WallpaperManager: int setStream(InputStream,Rect,boolean,int)>","<android.app.WallpaperManager: int setStream(InputStream,Rect,boolean,int)>",0,"{
    validateRect(visibleCropHint);
    if (sGlobals.mService == null) {
        Log.w(TAG, ""WallpaperService not running"");
        throw new RuntimeException(new DeadSystemException());
    }
    final Bundle result = new Bundle();
    final WallpaperSetCompletion completion = new WallpaperSetCompletion();
    try {
        ParcelFileDescriptor fd = sGlobals.mService.setWallpaper(null, mContext.getOpPackageName(), visibleCropHint, allowBackup, result, which, completion, UserHandle.myUserId());
        if (fd != null) {
            FileOutputStream fos = null;
            try {
                fos = new ParcelFileDescriptor.AutoCloseOutputStream(fd);
                copyStreamToWallpaperFile(bitmapData, fos);
                fos.close();
                completion.waitForCompletion();
            } finally {
                IoUtils.closeQuietly(fos);
            }
        }
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
    return result.getInt(EXTRA_NEW_WALLPAPER_ID, 0);
}","{
    validateRect(visibleCropHint);
    if (sGlobals.mService == null) {
        Log.w(TAG, ""WallpaperService not running"");
        throw new RuntimeException(new DeadSystemException());
    }
    final Bundle result = new Bundle();
    final WallpaperSetCompletion completion = new WallpaperSetCompletion();
    try {
        ParcelFileDescriptor fd = sGlobals.mService.setWallpaper(null, mContext.getOpPackageName(), visibleCropHint, allowBackup, result, which, completion, mContext.getUserId());
        if (fd != null) {
            FileOutputStream fos = null;
            try {
                fos = new ParcelFileDescriptor.AutoCloseOutputStream(fd);
                copyStreamToWallpaperFile(bitmapData, fos);
                fos.close();
                completion.waitForCompletion();
            } finally {
                IoUtils.closeQuietly(fos);
            }
        }
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
    return result.getInt(EXTRA_NEW_WALLPAPER_ID, 0);
}",1,"/**
 * Version of {@link #setStream(InputStream, Rect, boolean)} that allows the caller
 * to specify which of the supported wallpaper categories to set.
 *
 * @param bitmapData A stream containing the raw data to install as a wallpaper.  This
 * data can be in any format handled by {@link BitmapRegionDecoder}.
 * @param visibleCropHint The rectangular subregion of the streamed image that should be
 * displayed as wallpaper.  Passing {@code null} for this parameter means that
 * the full image should be displayed if possible given the image's and device's
 * aspect ratios, etc.
 * @param allowBackup {@code true} if the OS is permitted to back up this wallpaper
 * image for restore to a future device; {@code false} otherwise.
 * @param which Flags indicating which wallpaper(s) to configure with the new imagery.
 * @return An integer ID assigned to the newly active wallpaper; or zero on failure.
 *
 * @see #getWallpaperId(int)
 * @see #FLAG_LOCK
 * @see #FLAG_SYSTEM
 *
 * @throws IOException
 */
","/**
 * Version of {@link #setStream(InputStream, Rect, boolean)} that allows the caller
 * to specify which of the supported wallpaper categories to set.
 *
 * @param bitmapData A stream containing the raw data to install as a wallpaper.  This
 * data can be in any format handled by {@link BitmapRegionDecoder}.
 * @param visibleCropHint The rectangular subregion of the streamed image that should be
 * displayed as wallpaper.  Passing {@code null} for this parameter means that
 * the full image should be displayed if possible given the image's and device's
 * aspect ratios, etc.
 * @param allowBackup {@code true} if the OS is permitted to back up this wallpaper
 * image for restore to a future device; {@code false} otherwise.
 * @param which Flags indicating which wallpaper(s) to configure with the new imagery.
 * @return An integer ID assigned to the newly active wallpaper; or zero on failure.
 *
 * @see #getWallpaperId(int)
 * @see #FLAG_LOCK
 * @see #FLAG_SYSTEM
 *
 * @throws IOException
 */
",-1,[@RequiresPermission(android.Manifest.permission.SET_WALLPAPER)],[@RequiresPermission(android.Manifest.permission.SET_WALLPAPER)],-1,-1,-1,-1,-1,-1,5,0,"The only change is in the following call: UserHandle.myUserId() has been changed to mContext.getUserId(). As mContext.getUserId() may potentially refer to a different API or same API with different context, the code change type is 5.","There is no Compatibility Issue detected because the value returned by the API does not depend on the changed part of the code, as long as mContext.getUserId() provides a valid user ID as UserHandle.myUserId() did. The overall logic and return value of the method have not been altered."
542,"<android.app.Notification.MessagingStyle: MessagingStyle addMessage(CharSequence,long,CharSequence)>",27,28,"<android.app.Notification.MessagingStyle: MessagingStyle addMessage(CharSequence,long,CharSequence)>","<android.app.Notification.MessagingStyle: MessagingStyle addMessage(CharSequence,long,CharSequence)>",0,"{
    return addMessage(new Message(text, timestamp, sender));
}","{
    return addMessage(text, timestamp, sender == null ? null : new Person.Builder().setName(sender).build());
}",1,"/**
 * Adds a message for display by this notification. Convenience call for a simple
 * {@link Message} in {@link #addMessage(Notification.MessagingStyle.Message)}.
 * @param text A {@link CharSequence} to be displayed as the message content
 * @param timestamp Time at which the message arrived
 * @param sender A {@link CharSequence} to be used for displaying the name of the
 * sender. Should be <code>null</code> for messages by the current user, in which case
 * the platform will insert {@link #getUserDisplayName()}.
 * Should be unique amongst all individuals in the conversation, and should be
 * consistent during re-posts of the notification.
 *
 * @see Message#Message(CharSequence, long, CharSequence)
 *
 * @return this object for method chaining
 */
","/**
 * Adds a message for display by this notification. Convenience call for a simple
 * {@link Message} in {@link #addMessage(Notification.MessagingStyle.Message)}.
 * @param text A {@link CharSequence} to be displayed as the message content
 * @param timestamp Time at which the message arrived
 * @param sender A {@link CharSequence} to be used for displaying the name of the
 * sender. Should be <code>null</code> for messages by the current user, in which case
 * the platform will insert {@link #getUserDisplayName()}.
 * Should be unique amongst all individuals in the conversation, and should be
 * consistent during re-posts of the notification.
 *
 * @see Message#Message(CharSequence, long, CharSequence)
 *
 * @return this object for method chaining
 *
 * @deprecated use {@link #addMessage(CharSequence, long, Person)}
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",1,"The method invocation of addMessage() now includes a conditional expression, which constructs a new Person object or passes null based on whether 'sender' is null. The implementation creates a Person object with the sender's name when `sender` is not null. Whereas before the change, it passed the `sender` directly to the new Message object. This affects the 'addMessage' dependent API since it modifies the type and, potentially, the number of parameters it encloses, leading to the change types 4,5.","The change in how the 'sender' parameter is handled potentially affects the return value of the method. Before the change, the 'sender' is directly passed as a CharSequence, but after the change, it is converted to a Person object if it's not null. This could lead the API to return different values because the Message object that is added will contain different representations of the sender, thus the CI type is 1."
543,"<android.app.WallpaperManager: int setBitmap(Bitmap,Rect,boolean,int)>",27,28,"<android.app.WallpaperManager: int setBitmap(Bitmap,Rect,boolean,int)>","<android.app.WallpaperManager: int setBitmap(Bitmap,Rect,boolean,int)>",0,"{
    return setBitmap(fullImage, visibleCropHint, allowBackup, which, UserHandle.myUserId());
}","{
    return setBitmap(fullImage, visibleCropHint, allowBackup, which, mContext.getUserId());
}",1,"/**
 * Version of {@link #setBitmap(Bitmap, Rect, boolean)} that allows the caller
 * to specify which of the supported wallpaper categories to set.
 *
 * @param fullImage A bitmap that will supply the wallpaper imagery.
 * @param visibleCropHint The rectangular subregion of {@code fullImage} that should be
 * displayed as wallpaper.  Passing {@code null} for this parameter means that
 * the full image should be displayed if possible given the image's and device's
 * aspect ratios, etc.
 * @param allowBackup {@code true} if the OS is permitted to back up this wallpaper
 * image for restore to a future device; {@code false} otherwise.
 * @param which Flags indicating which wallpaper(s) to configure with the new imagery.
 *
 * @see #FLAG_LOCK
 * @see #FLAG_SYSTEM
 *
 * @return An integer ID assigned to the newly active wallpaper; or zero on failure.
 *
 * @throws IOException
 */
","/**
 * Version of {@link #setBitmap(Bitmap, Rect, boolean)} that allows the caller
 * to specify which of the supported wallpaper categories to set.
 *
 * @param fullImage A bitmap that will supply the wallpaper imagery.
 * @param visibleCropHint The rectangular subregion of {@code fullImage} that should be
 * displayed as wallpaper.  Passing {@code null} for this parameter means that
 * the full image should be displayed if possible given the image's and device's
 * aspect ratios, etc.
 * @param allowBackup {@code true} if the OS is permitted to back up this wallpaper
 * image for restore to a future device; {@code false} otherwise.
 * @param which Flags indicating which wallpaper(s) to configure with the new imagery.
 *
 * @see #FLAG_LOCK
 * @see #FLAG_SYSTEM
 *
 * @return An integer ID assigned to the newly active wallpaper; or zero on failure.
 *
 * @throws IOException
 */
",-1,[@RequiresPermission(android.Manifest.permission.SET_WALLPAPER)],[@RequiresPermission(android.Manifest.permission.SET_WALLPAPER)],-1,-1,-1,-1,-1,-1,5,0,"The API change involves replacing UserHandle.myUserId() with mContext.getUserId() as the parameter passed to the setBitmap() function, which is a change in the dependent API (the method called to obtain the user ID), thus the code change type is 5.","There is no Compatibility Issue as the core functionality of the API has not been altered. Both implementations seem to retrieve the ID of the user to apply the wallpaper setting. As long as the user ID fetched by mContext.getUserId() is equivalent to that by UserHandle.myUserId(), the behavior should remain consistent. Therefore, without further evidence of a different behavior, we assume no CI."
545,<android.view.textclassifier.TextClassification.Builder: TextClassification build()>,27,28,<android.view.textclassifier.TextClassification.Builder: TextClassification build()>,<android.view.textclassifier.TextClassification.Builder: TextClassification build()>,0,"{
    return new TextClassification(mText, mIcon, mLabel, mIntent, mOnClickListener, mEntityConfidence, mLogType, mVersionInfo);
}","{
    return new TextClassification(mText, mLegacyIcon, mLegacyLabel, mLegacyIntent, mLegacyOnClickListener, mActions, mEntityConfidence, mId);
}",1,"/**
 * Builds and returns a {@link TextClassification} object.
 */
","/**
 * Builds and returns a {@link TextClassification} object.
 */
",-1,,[@NonNull],-1,-1,-1,-1,-1,-1,"1,5",1,"The parameters of the constructor for `TextClassification` have changed, which means the method is initializing `TextClassification` with different data. This indicates both a dependent API change and a change in the return statement, so the code change type is 1,5.","As the parameters used to construct the `TextClassification` object have changed, the object returned by `build()` in the late version may be different from the one returned in the early version, which can lead to a potential Compatibility Issue due to different return values. Hence, the CI type is 1."
546,<android.bluetooth.le.AdvertisingSetParameters.Builder: Builder setPrimaryPhy(int)>,27,28,<android.bluetooth.le.AdvertisingSetParameters.Builder: Builder setPrimaryPhy(int)>,<android.bluetooth.le.AdvertisingSetParameters.Builder: Builder setPrimaryPhy(int)>,0,"{
    if (primaryPhy != BluetoothDevice.PHY_LE_1M && primaryPhy != BluetoothDevice.PHY_LE_CODED) {
        throw new IllegalArgumentException(""bad primaryPhy "" + primaryPhy);
    }
    this.primaryPhy = primaryPhy;
    return this;
}","{
    if (primaryPhy != BluetoothDevice.PHY_LE_1M && primaryPhy != BluetoothDevice.PHY_LE_CODED) {
        throw new IllegalArgumentException(""bad primaryPhy "" + primaryPhy);
    }
    mPrimaryPhy = primaryPhy;
    return this;
}",1,"/**
 * Set the primary physical channel used for this advertising set.
 *
 * This is used only if legacy mode is not used.
 *
 * Use {@link BluetoothAdapter#isLeCodedPhySupported} to determine if LE Coded PHY is
 * supported on this device.
 * @param primaryPhy Primary advertising physical channel, can only be
 * {@link BluetoothDevice#PHY_LE_1M} or
 * {@link BluetoothDevice#PHY_LE_CODED}.
 * @throws IllegalArgumentException If the primaryPhy is invalid.
 */
","/**
 * Set the primary physical channel used for this advertising set.
 *
 * This is used only if legacy mode is not used.
 *
 * Use {@link BluetoothAdapter#isLeCodedPhySupported} to determine if LE Coded PHY is
 * supported on this device.
 *
 * @param primaryPhy Primary advertising physical channel, can only be {@link
 * BluetoothDevice#PHY_LE_1M} or {@link BluetoothDevice#PHY_LE_CODED}.
 * @throws IllegalArgumentException If the primaryPhy is invalid.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The variable name changed from 'this.primaryPhy' to 'mPrimaryPhy'. Since no other parts of the method have changed, the code change type is 4.","There is no compatibility issue here as this change is simply internal variable renaming and does not affect return values, exception handling, control flow, or external API dependencies. Thus, the behavior from a caller's point of view remains unchanged."
547,<android.app.ActivityThread.H: String codeToString(int)>,27,28,<android.app.ActivityThread.H: String codeToString(int)>,<android.app.ActivityThread.H: String codeToString(int)>,0,"{
    if (DEBUG_MESSAGES) {
        switch(code) {
            case LAUNCH_ACTIVITY:
                return ""LAUNCH_ACTIVITY"";
            case PAUSE_ACTIVITY:
                return ""PAUSE_ACTIVITY"";
            case PAUSE_ACTIVITY_FINISHING:
                return ""PAUSE_ACTIVITY_FINISHING"";
            case STOP_ACTIVITY_SHOW:
                return ""STOP_ACTIVITY_SHOW"";
            case STOP_ACTIVITY_HIDE:
                return ""STOP_ACTIVITY_HIDE"";
            case SHOW_WINDOW:
                return ""SHOW_WINDOW"";
            case HIDE_WINDOW:
                return ""HIDE_WINDOW"";
            case RESUME_ACTIVITY:
                return ""RESUME_ACTIVITY"";
            case SEND_RESULT:
                return ""SEND_RESULT"";
            case DESTROY_ACTIVITY:
                return ""DESTROY_ACTIVITY"";
            case BIND_APPLICATION:
                return ""BIND_APPLICATION"";
            case EXIT_APPLICATION:
                return ""EXIT_APPLICATION"";
            case NEW_INTENT:
                return ""NEW_INTENT"";
            case RECEIVER:
                return ""RECEIVER"";
            case CREATE_SERVICE:
                return ""CREATE_SERVICE"";
            case SERVICE_ARGS:
                return ""SERVICE_ARGS"";
            case STOP_SERVICE:
                return ""STOP_SERVICE"";
            case CONFIGURATION_CHANGED:
                return ""CONFIGURATION_CHANGED"";
            case CLEAN_UP_CONTEXT:
                return ""CLEAN_UP_CONTEXT"";
            case GC_WHEN_IDLE:
                return ""GC_WHEN_IDLE"";
            case BIND_SERVICE:
                return ""BIND_SERVICE"";
            case UNBIND_SERVICE:
                return ""UNBIND_SERVICE"";
            case DUMP_SERVICE:
                return ""DUMP_SERVICE"";
            case LOW_MEMORY:
                return ""LOW_MEMORY"";
            case ACTIVITY_CONFIGURATION_CHANGED:
                return ""ACTIVITY_CONFIGURATION_CHANGED"";
            case ACTIVITY_MOVED_TO_DISPLAY:
                return ""ACTIVITY_MOVED_TO_DISPLAY"";
            case RELAUNCH_ACTIVITY:
                return ""RELAUNCH_ACTIVITY"";
            case PROFILER_CONTROL:
                return ""PROFILER_CONTROL"";
            case CREATE_BACKUP_AGENT:
                return ""CREATE_BACKUP_AGENT"";
            case DESTROY_BACKUP_AGENT:
                return ""DESTROY_BACKUP_AGENT"";
            case SUICIDE:
                return ""SUICIDE"";
            case REMOVE_PROVIDER:
                return ""REMOVE_PROVIDER"";
            case ENABLE_JIT:
                return ""ENABLE_JIT"";
            case DISPATCH_PACKAGE_BROADCAST:
                return ""DISPATCH_PACKAGE_BROADCAST"";
            case SCHEDULE_CRASH:
                return ""SCHEDULE_CRASH"";
            case DUMP_HEAP:
                return ""DUMP_HEAP"";
            case DUMP_ACTIVITY:
                return ""DUMP_ACTIVITY"";
            case SLEEPING:
                return ""SLEEPING"";
            case SET_CORE_SETTINGS:
                return ""SET_CORE_SETTINGS"";
            case UPDATE_PACKAGE_COMPATIBILITY_INFO:
                return ""UPDATE_PACKAGE_COMPATIBILITY_INFO"";
            case TRIM_MEMORY:
                return ""TRIM_MEMORY"";
            case DUMP_PROVIDER:
                return ""DUMP_PROVIDER"";
            case UNSTABLE_PROVIDER_DIED:
                return ""UNSTABLE_PROVIDER_DIED"";
            case REQUEST_ASSIST_CONTEXT_EXTRAS:
                return ""REQUEST_ASSIST_CONTEXT_EXTRAS"";
            case TRANSLUCENT_CONVERSION_COMPLETE:
                return ""TRANSLUCENT_CONVERSION_COMPLETE"";
            case INSTALL_PROVIDER:
                return ""INSTALL_PROVIDER"";
            case ON_NEW_ACTIVITY_OPTIONS:
                return ""ON_NEW_ACTIVITY_OPTIONS"";
            case ENTER_ANIMATION_COMPLETE:
                return ""ENTER_ANIMATION_COMPLETE"";
            case MULTI_WINDOW_MODE_CHANGED:
                return ""MULTI_WINDOW_MODE_CHANGED"";
            case PICTURE_IN_PICTURE_MODE_CHANGED:
                return ""PICTURE_IN_PICTURE_MODE_CHANGED"";
            case LOCAL_VOICE_INTERACTION_STARTED:
                return ""LOCAL_VOICE_INTERACTION_STARTED"";
            case ATTACH_AGENT:
                return ""ATTACH_AGENT"";
            case APPLICATION_INFO_CHANGED:
                return ""APPLICATION_INFO_CHANGED"";
        }
    }
    return Integer.toString(code);
}","{
    if (DEBUG_MESSAGES) {
        switch(code) {
            case BIND_APPLICATION:
                return ""BIND_APPLICATION"";
            case EXIT_APPLICATION:
                return ""EXIT_APPLICATION"";
            case RECEIVER:
                return ""RECEIVER"";
            case CREATE_SERVICE:
                return ""CREATE_SERVICE"";
            case SERVICE_ARGS:
                return ""SERVICE_ARGS"";
            case STOP_SERVICE:
                return ""STOP_SERVICE"";
            case CONFIGURATION_CHANGED:
                return ""CONFIGURATION_CHANGED"";
            case CLEAN_UP_CONTEXT:
                return ""CLEAN_UP_CONTEXT"";
            case GC_WHEN_IDLE:
                return ""GC_WHEN_IDLE"";
            case BIND_SERVICE:
                return ""BIND_SERVICE"";
            case UNBIND_SERVICE:
                return ""UNBIND_SERVICE"";
            case DUMP_SERVICE:
                return ""DUMP_SERVICE"";
            case LOW_MEMORY:
                return ""LOW_MEMORY"";
            case PROFILER_CONTROL:
                return ""PROFILER_CONTROL"";
            case CREATE_BACKUP_AGENT:
                return ""CREATE_BACKUP_AGENT"";
            case DESTROY_BACKUP_AGENT:
                return ""DESTROY_BACKUP_AGENT"";
            case SUICIDE:
                return ""SUICIDE"";
            case REMOVE_PROVIDER:
                return ""REMOVE_PROVIDER"";
            case ENABLE_JIT:
                return ""ENABLE_JIT"";
            case DISPATCH_PACKAGE_BROADCAST:
                return ""DISPATCH_PACKAGE_BROADCAST"";
            case SCHEDULE_CRASH:
                return ""SCHEDULE_CRASH"";
            case DUMP_HEAP:
                return ""DUMP_HEAP"";
            case DUMP_ACTIVITY:
                return ""DUMP_ACTIVITY"";
            case SLEEPING:
                return ""SLEEPING"";
            case SET_CORE_SETTINGS:
                return ""SET_CORE_SETTINGS"";
            case UPDATE_PACKAGE_COMPATIBILITY_INFO:
                return ""UPDATE_PACKAGE_COMPATIBILITY_INFO"";
            case DUMP_PROVIDER:
                return ""DUMP_PROVIDER"";
            case UNSTABLE_PROVIDER_DIED:
                return ""UNSTABLE_PROVIDER_DIED"";
            case REQUEST_ASSIST_CONTEXT_EXTRAS:
                return ""REQUEST_ASSIST_CONTEXT_EXTRAS"";
            case TRANSLUCENT_CONVERSION_COMPLETE:
                return ""TRANSLUCENT_CONVERSION_COMPLETE"";
            case INSTALL_PROVIDER:
                return ""INSTALL_PROVIDER"";
            case ON_NEW_ACTIVITY_OPTIONS:
                return ""ON_NEW_ACTIVITY_OPTIONS"";
            case ENTER_ANIMATION_COMPLETE:
                return ""ENTER_ANIMATION_COMPLETE"";
            case LOCAL_VOICE_INTERACTION_STARTED:
                return ""LOCAL_VOICE_INTERACTION_STARTED"";
            case ATTACH_AGENT:
                return ""ATTACH_AGENT"";
            case APPLICATION_INFO_CHANGED:
                return ""APPLICATION_INFO_CHANGED"";
            case RUN_ISOLATED_ENTRY_POINT:
                return ""RUN_ISOLATED_ENTRY_POINT"";
            case EXECUTE_TRANSACTION:
                return ""EXECUTE_TRANSACTION"";
            case RELAUNCH_ACTIVITY:
                return ""RELAUNCH_ACTIVITY"";
        }
    }
    return Integer.toString(code);
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,,,,
550,<android.app.job.JobInfo: int getNetworkType()>,27,28,<android.app.job.JobInfo: int getNetworkType()>,<android.app.job.JobInfo: int getNetworkType()>,0,"{
    return networkType;
}","{
    if (networkRequest == null) {
        return NETWORK_TYPE_NONE;
    } else if (networkRequest.networkCapabilities.hasCapability(NET_CAPABILITY_NOT_METERED)) {
        return NETWORK_TYPE_UNMETERED;
    } else if (networkRequest.networkCapabilities.hasCapability(NET_CAPABILITY_NOT_ROAMING)) {
        return NETWORK_TYPE_NOT_ROAMING;
    } else if (networkRequest.networkCapabilities.hasTransport(TRANSPORT_CELLULAR)) {
        return NETWORK_TYPE_CELLULAR;
    } else {
        return NETWORK_TYPE_ANY;
    }
}",1,"/**
 * The kind of connectivity requirements that the job has.
 */
","/**
 * Return the basic description of the kind of network this job requires.
 *
 * @deprecated This method attempts to map {@link #getRequiredNetwork()}
 * into the set of simple constants, which results in a loss of
 * fidelity. Callers should move to using
 * {@link #getRequiredNetwork()} directly.
 * @see Builder#setRequiredNetworkType(int)
 */
",-1,[@NetworkType],"[@Deprecated, @NetworkType]",-1,-1,-1,-1,-1,-1,"1,3,5",1,"The early version simply returns the value of a variable, while the late version evaluates a series of conditions to return a value, which includes checks for specific capabilities and transports. The conditions depend on the properties of the 'networkRequest' member variable that did not previously affect the return value. This represents a control dependency change (3), a change to the return statement (1), and a change to the dependent API (5), since the logic now involves methods from the 'networkRequest.networkCapabilities' object which was not present in the early version.","The late version of the API introduces new logic that determines the return value based on different properties of 'networkRequest'. This new code path leads to different potential return values. Hence, it is classified as a compatibility issue of type 1 due to potential differing return values."
551,"<android.content.res.TypedArray: int getLayoutDimension(int,String)>",27,28,"<android.content.res.TypedArray: int getLayoutDimension(int,String)>","<android.content.res.TypedArray: int getLayoutDimension(int,String)>",0,"{
    if (mRecycled) {
        throw new RuntimeException(""Cannot make calls to a recycled instance!"");
    }
    final int attrIndex = index;
    index *= AssetManager.STYLE_NUM_ENTRIES;
    final int[] data = mData;
    final int type = data[index + AssetManager.STYLE_TYPE];
    if (type >= TypedValue.TYPE_FIRST_INT && type <= TypedValue.TYPE_LAST_INT) {
        return data[index + AssetManager.STYLE_DATA];
    } else if (type == TypedValue.TYPE_DIMENSION) {
        return TypedValue.complexToDimensionPixelSize(data[index + AssetManager.STYLE_DATA], mMetrics);
    } else if (type == TypedValue.TYPE_ATTRIBUTE) {
        final TypedValue value = mValue;
        getValueAt(index, value);
        throw new UnsupportedOperationException(""Failed to resolve attribute at index "" + attrIndex + "": "" + value);
    }
    throw new UnsupportedOperationException(getPositionDescription() + "": You must supply a "" + name + "" attribute."");
}","{
    if (mRecycled) {
        throw new RuntimeException(""Cannot make calls to a recycled instance!"");
    }
    final int attrIndex = index;
    index *= STYLE_NUM_ENTRIES;
    final int[] data = mData;
    final int type = data[index + STYLE_TYPE];
    if (type >= TypedValue.TYPE_FIRST_INT && type <= TypedValue.TYPE_LAST_INT) {
        return data[index + STYLE_DATA];
    } else if (type == TypedValue.TYPE_DIMENSION) {
        return TypedValue.complexToDimensionPixelSize(data[index + STYLE_DATA], mMetrics);
    } else if (type == TypedValue.TYPE_ATTRIBUTE) {
        final TypedValue value = mValue;
        getValueAt(index, value);
        throw new UnsupportedOperationException(""Failed to resolve attribute at index "" + attrIndex + "": "" + value);
    }
    throw new UnsupportedOperationException(getPositionDescription() + "": You must supply a "" + name + "" attribute."");
}",1,"/**
 * Special version of {@link #getDimensionPixelSize} for retrieving
 * {@link android.view.ViewGroup}'s layout_width and layout_height
 * attributes.  This is only here for performance reasons; applications
 * should use {@link #getDimensionPixelSize}.
 * <p>
 * This method will throw an exception if the attribute is defined but is
 * not a dimension or integer (enum).
 *
 * @param index Index of the attribute to retrieve.
 * @param name Textual name of attribute for error reporting.
 *
 * @return Attribute dimension value multiplied by the appropriate
 * metric and truncated to integer pixels.
 * @throws RuntimeException if the TypedArray has already been recycled.
 * @throws UnsupportedOperationException if the attribute is defined but is
 * not a dimension or integer (enum).
 */
","/**
 * Special version of {@link #getDimensionPixelSize} for retrieving
 * {@link android.view.ViewGroup}'s layout_width and layout_height
 * attributes.  This is only here for performance reasons; applications
 * should use {@link #getDimensionPixelSize}.
 * <p>
 * This method will throw an exception if the attribute is defined but is
 * not a dimension or integer (enum).
 *
 * @param index Index of the attribute to retrieve.
 * @param name Textual name of attribute for error reporting.
 *
 * @return Attribute dimension value multiplied by the appropriate
 * metric and truncated to integer pixels.
 * @throws RuntimeException if the TypedArray has already been recycled.
 * @throws UnsupportedOperationException if the attribute is defined but is
 * not a dimension or integer (enum).
 */
",-1,,,-1,-1,-1,-1,-1,-1,0,0,"The code and functionality have not changed between the two versions, only the reference to `AssetManager.STYLE_NUM_ENTRIES` has been shortened to `STYLE_NUM_ENTRIES` due to the probable import of the class. This is simply a stylistic change and does not affect the behavior of the method.","Since there are no changes in the logic, return values, exceptions thrown, or control flow of the method, there is no Compatibility Issue."
552,"<android.content.res.ResourcesImpl.ThemeImpl: TypedArray resolveAttributes(Theme,int[],int[])>",27,28,"<android.content.res.ResourcesImpl.ThemeImpl: TypedArray resolveAttributes(Theme,int[],int[])>","<android.content.res.ResourcesImpl.ThemeImpl: TypedArray resolveAttributes(Theme,int[],int[])>",0,"{
    synchronized (mKey) {
        final int len = attrs.length;
        if (values == null || len != values.length) {
            throw new IllegalArgumentException(""Base attribute values must the same length as attrs"");
        }
        final TypedArray array = TypedArray.obtain(wrapper.getResources(), len);
        AssetManager.resolveAttrs(mTheme, 0, 0, values, attrs, array.mData, array.mIndices);
        array.mTheme = wrapper;
        array.mXml = null;
        return array;
    }
}","{
    synchronized (mKey) {
        final int len = attrs.length;
        if (values == null || len != values.length) {
            throw new IllegalArgumentException(""Base attribute values must the same length as attrs"");
        }
        final TypedArray array = TypedArray.obtain(wrapper.getResources(), len);
        mAssets.resolveAttrs(mTheme, 0, 0, values, attrs, array.mData, array.mIndices);
        array.mTheme = wrapper;
        array.mXml = null;
        return array;
    }
}",1,,,-1,[@NonNull],[@NonNull],-1,-1,-1,-1,-1,-1,5,0,"The method AssetManager.resolveAttrs() is changed to mAssets.resolveAttrs(). This indicates a change in the dependent API as the instance used to call the method changed from a possible static/global instance to a member variable. So, the code change type is 5.","Since the change is internal to how the dependent API is accessed but the API signature, the input arguments, and the returned value are unaffected, there is no compatibility issue. The behavior of the method from the perspective of an API consumer should remain the same provided the internal state associated with mAssets provides the same functionality as AssetManager in terms of resolveAttrs(). Therefore, the CI type is 0."
553,<android.webkit.WebView: String findAddress(String)>,27,28,<android.webkit.WebView: String findAddress(String)>,<android.webkit.WebView: String findAddress(String)>,0,"{
    // Could also be deprecated
    return getFactory().getStatics().findAddress(addr);
}","{
    if (addr == null) {
        throw new NullPointerException(""addr is null"");
    }
    return FindAddress.findAddress(addr);
}",1,"/**
 * Gets the first substring consisting of the address of a physical
 * location. Currently, only addresses in the United States are detected,
 * and consist of:
 * <ul>
 * <li>a house number</li>
 * <li>a street name</li>
 * <li>a street type (Road, Circle, etc), either spelled out or
 * abbreviated</li>
 * <li>a city name</li>
 * <li>a state or territory, either spelled out or two-letter abbr</li>
 * <li>an optional 5 digit or 9 digit zip code</li>
 * </ul>
 * All names must be correctly capitalized, and the zip code, if present,
 * must be valid for the state. The street type must be a standard USPS
 * spelling or abbreviation. The state or territory must also be spelled
 * or abbreviated using USPS standards. The house number may not exceed
 * five digits.
 *
 * @param addr the string to search for addresses
 * @return the address, or if no address is found, null
 */
","/**
 * Gets the first substring consisting of the address of a physical
 * location. Currently, only addresses in the United States are detected,
 * and consist of:
 * <ul>
 * <li>a house number</li>
 * <li>a street name</li>
 * <li>a street type (Road, Circle, etc), either spelled out or
 * abbreviated</li>
 * <li>a city name</li>
 * <li>a state or territory, either spelled out or two-letter abbr</li>
 * <li>an optional 5 digit or 9 digit zip code</li>
 * </ul>
 * All names must be correctly capitalized, and the zip code, if present,
 * must be valid for the state. The street type must be a standard USPS
 * spelling or abbreviation. The state or territory must also be spelled
 * or abbreviated using USPS standards. The house number may not exceed
 * five digits.
 *
 * @param addr the string to search for addresses
 * @return the address, or if no address is found, {@code null}
 * @deprecated this method is superseded by {@link TextClassifier#generateLinks(
 * android.view.textclassifier.TextLinks.Request)}. Avoid using this method even when targeting
 * API levels where no alternative is available.
 */
",-1,,"[@Nullable, @Deprecated]",-1,-1,-1,-1,-1,-1,"1,2,5","1,2",The implementation has changed in the following ways:,
554,"<android.widget.RemoteViews.SetOnClickPendingIntent: void apply(View,ViewGroup,OnClickHandler)>",27,28,"<android.widget.RemoteViews.SetOnClickPendingIntent: void apply(View,ViewGroup,OnClickHandler)>","<android.widget.RemoteViews.SetOnClickPendingIntent: void apply(View,ViewGroup,OnClickHandler)>",0,"{
    final View target = root.findViewById(viewId);
    if (target == null)
        return;
    // sense, do they mean to set a PendingIntent template for the AdapterView's children?
    if (mIsWidgetCollectionChild) {
        Log.w(LOG_TAG, ""Cannot setOnClickPendingIntent for collection item "" + ""(id: "" + viewId + "")"");
        ApplicationInfo appInfo = root.getContext().getApplicationInfo();
        // been disabled from the outset, but was left open by accident.
        if (appInfo != null && appInfo.targetSdkVersion >= Build.VERSION_CODES.JELLY_BEAN) {
            return;
        }
    }
    // If the pendingIntent is null, we clear the onClickListener
    OnClickListener listener = null;
    if (pendingIntent != null) {
        listener = new OnClickListener() {

            public void onClick(View v) {
                // Find target view location in screen coordinates and
                // fill into PendingIntent before sending.
                final Rect rect = getSourceBounds(v);
                final Intent intent = new Intent();
                intent.setSourceBounds(rect);
                handler.onClickHandler(v, pendingIntent, intent);
            }
        };
    }
    target.setOnClickListener(listener);
}","{
    final View target = root.findViewById(viewId);
    if (target == null)
        return;
    // sense, do they mean to set a PendingIntent template for the AdapterView's children?
    if (mIsWidgetCollectionChild) {
        Log.w(LOG_TAG, ""Cannot setOnClickPendingIntent for collection item "" + ""(id: "" + viewId + "")"");
        ApplicationInfo appInfo = root.getContext().getApplicationInfo();
        // been disabled from the outset, but was left open by accident.
        if (appInfo != null && appInfo.targetSdkVersion >= Build.VERSION_CODES.JELLY_BEAN) {
            return;
        }
    }
    // If the pendingIntent is null, we clear the onClickListener
    OnClickListener listener = null;
    if (pendingIntent != null) {
        listener = new OnClickListener() {

            public void onClick(View v) {
                // Find target view location in screen coordinates and
                // fill into PendingIntent before sending.
                final Rect rect = getSourceBounds(v);
                final Intent intent = new Intent();
                intent.setSourceBounds(rect);
                handler.onClickHandler(v, pendingIntent, intent);
            }
        };
    }
    target.setTagInternal(R.id.pending_intent_tag, pendingIntent);
    target.setOnClickListener(listener);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"There is a new statement added, target.setTagInternal(R.id.pending_intent_tag, pendingIntent);, which does not affect the control flow, the return variables, nor does it involve exception handling. The change is categorized as 4 (Other statement changed).","The addition of the new statement target.setTagInternal does not alter the return type or value, nor does it change how exceptions are handled. Thus, there is no compatibility issue according to the descriptions provided; hence the CI type is 0 (No Compatibility Issue)."
555,"<android.text.Layout: void getSelectionPath(int,int,Path)>",27,28,"<android.text.Layout: void getSelectionPath(int,int,Path)>","<android.text.Layout: void getSelectionPath(int,int,Path)>",0,"{
    dest.reset();
    if (start == end)
        return;
    if (end < start) {
        int temp = end;
        end = start;
        start = temp;
    }
    int startline = getLineForOffset(start);
    int endline = getLineForOffset(end);
    int top = getLineTop(startline);
    int bottom = getLineBottom(endline);
    if (startline == endline) {
        addSelection(startline, start, end, top, bottom, dest);
    } else {
        final float width = mWidth;
        addSelection(startline, start, getLineEnd(startline), top, getLineBottom(startline), dest);
        if (getParagraphDirection(startline) == DIR_RIGHT_TO_LEFT)
            dest.addRect(getLineLeft(startline), top, 0, getLineBottom(startline), Path.Direction.CW);
        else
            dest.addRect(getLineRight(startline), top, width, getLineBottom(startline), Path.Direction.CW);
        for (int i = startline + 1; i < endline; i++) {
            top = getLineTop(i);
            bottom = getLineBottom(i);
            dest.addRect(0, top, width, bottom, Path.Direction.CW);
        }
        top = getLineTop(endline);
        bottom = getLineBottom(endline);
        addSelection(endline, getLineStart(endline), end, top, bottom, dest);
        if (getParagraphDirection(endline) == DIR_RIGHT_TO_LEFT)
            dest.addRect(width, top, getLineRight(endline), bottom, Path.Direction.CW);
        else
            dest.addRect(0, top, getLineLeft(endline), bottom, Path.Direction.CW);
    }
}","{
    dest.reset();
    getSelection(start, end, (left, top, right, bottom, textSelectionLayout) -> dest.addRect(left, top, right, bottom, Path.Direction.CW));
}",1,"/**
 * Fills in the specified Path with a representation of a highlight
 * between the specified offsets.  This will often be a rectangle
 * or a potentially discontinuous set of rectangles.  If the start
 * and end are the same, the returned path is empty.
 */
","/**
 * Fills in the specified Path with a representation of a highlight
 * between the specified offsets.  This will often be a rectangle
 * or a potentially discontinuous set of rectangles.  If the start
 * and end are the same, the returned path is empty.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The method's internal logic has been refactored to use a lambda expression that delegates to a new method getSelection; the previous implementation's control structure and calculation logic have been replaced. The type of code change is 1,5 because the return logic relies on the implementation of the getSelection method, which this API now depends on.","Given that the implementation of the getSelectionPath method has drastically changed and now depends on the new getSelection method, which seems to handle the creation of the selection path, it is reasonable to expect that the behavior and the return values (the content of the Path) may differ between versions. Therefore, the CI type is 1 due to potential differences in returned values."
556,<android.bluetooth.le.PeriodicAdvertisingParameters.Builder: Builder setIncludeTxPower(boolean)>,27,28,<android.bluetooth.le.PeriodicAdvertisingParameters.Builder: Builder setIncludeTxPower(boolean)>,<android.bluetooth.le.PeriodicAdvertisingParameters.Builder: Builder setIncludeTxPower(boolean)>,0,"{
    this.includeTxPower = includeTxPower;
    return this;
}","{
    mIncludeTxPower = includeTxPower;
    return this;
}",1,"/**
 * Whether the transmission power level should be included in the periodic
 * packet.
 */
","/**
 * Whether the transmission power level should be included in the periodic
 * packet.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The field name has changed from 'this.includeTxPower' to 'mIncludeTxPower', which is an example of other statement changed (an assignment statement in this case), so the code change type is 4.","As only the field name has changed, and assuming the internal state change is encapsulated within the object, it will not lead to a difference in behavior observed by the clients of the API. Thus, there is no compatibility issue, and the CI type is 0."
557,<android.util.ArrayMap: V removeAt(int)>,27,28,<android.util.ArrayMap: V removeAt(int)>,<android.util.ArrayMap: V removeAt(int)>,0,"{
    final Object old = mArray[(index << 1) + 1];
    final int osize = mSize;
    final int nsize;
    if (osize <= 1) {
        // Now empty.
        if (DEBUG)
            Log.d(TAG, ""remove: shrink from "" + mHashes.length + "" to 0"");
        freeArrays(mHashes, mArray, osize);
        mHashes = EmptyArray.INT;
        mArray = EmptyArray.OBJECT;
        nsize = 0;
    } else {
        nsize = osize - 1;
        if (mHashes.length > (BASE_SIZE * 2) && mSize < mHashes.length / 3) {
            // Shrunk enough to reduce size of arrays.  We don't allow it to
            // shrink smaller than (BASE_SIZE*2) to avoid flapping between
            // that and BASE_SIZE.
            final int n = osize > (BASE_SIZE * 2) ? (osize + (osize >> 1)) : (BASE_SIZE * 2);
            if (DEBUG)
                Log.d(TAG, ""remove: shrink from "" + mHashes.length + "" to "" + n);
            final int[] ohashes = mHashes;
            final Object[] oarray = mArray;
            allocArrays(n);
            if (CONCURRENT_MODIFICATION_EXCEPTIONS && osize != mSize) {
                throw new ConcurrentModificationException();
            }
            if (index > 0) {
                if (DEBUG)
                    Log.d(TAG, ""remove: copy from 0-"" + index + "" to 0"");
                System.arraycopy(ohashes, 0, mHashes, 0, index);
                System.arraycopy(oarray, 0, mArray, 0, index << 1);
            }
            if (index < nsize) {
                if (DEBUG)
                    Log.d(TAG, ""remove: copy from "" + (index + 1) + ""-"" + nsize + "" to "" + index);
                System.arraycopy(ohashes, index + 1, mHashes, index, nsize - index);
                System.arraycopy(oarray, (index + 1) << 1, mArray, index << 1, (nsize - index) << 1);
            }
        } else {
            if (index < nsize) {
                if (DEBUG)
                    Log.d(TAG, ""remove: move "" + (index + 1) + ""-"" + nsize + "" to "" + index);
                System.arraycopy(mHashes, index + 1, mHashes, index, nsize - index);
                System.arraycopy(mArray, (index + 1) << 1, mArray, index << 1, (nsize - index) << 1);
            }
            mArray[nsize << 1] = null;
            mArray[(nsize << 1) + 1] = null;
        }
    }
    if (CONCURRENT_MODIFICATION_EXCEPTIONS && osize != mSize) {
        throw new ConcurrentModificationException();
    }
    mSize = nsize;
    return (V) old;
}","{
    final Object old = mArray[(index << 1) + 1];
    final int osize = mSize;
    final int nsize;
    if (osize <= 1) {
        // Now empty.
        if (DEBUG)
            Log.d(TAG, ""remove: shrink from "" + mHashes.length + "" to 0"");
        final int[] ohashes = mHashes;
        final Object[] oarray = mArray;
        mHashes = EmptyArray.INT;
        mArray = EmptyArray.OBJECT;
        freeArrays(ohashes, oarray, osize);
        nsize = 0;
    } else {
        nsize = osize - 1;
        if (mHashes.length > (BASE_SIZE * 2) && mSize < mHashes.length / 3) {
            // Shrunk enough to reduce size of arrays.  We don't allow it to
            // shrink smaller than (BASE_SIZE*2) to avoid flapping between
            // that and BASE_SIZE.
            final int n = osize > (BASE_SIZE * 2) ? (osize + (osize >> 1)) : (BASE_SIZE * 2);
            if (DEBUG)
                Log.d(TAG, ""remove: shrink from "" + mHashes.length + "" to "" + n);
            final int[] ohashes = mHashes;
            final Object[] oarray = mArray;
            allocArrays(n);
            if (CONCURRENT_MODIFICATION_EXCEPTIONS && osize != mSize) {
                throw new ConcurrentModificationException();
            }
            if (index > 0) {
                if (DEBUG)
                    Log.d(TAG, ""remove: copy from 0-"" + index + "" to 0"");
                System.arraycopy(ohashes, 0, mHashes, 0, index);
                System.arraycopy(oarray, 0, mArray, 0, index << 1);
            }
            if (index < nsize) {
                if (DEBUG)
                    Log.d(TAG, ""remove: copy from "" + (index + 1) + ""-"" + nsize + "" to "" + index);
                System.arraycopy(ohashes, index + 1, mHashes, index, nsize - index);
                System.arraycopy(oarray, (index + 1) << 1, mArray, index << 1, (nsize - index) << 1);
            }
        } else {
            if (index < nsize) {
                if (DEBUG)
                    Log.d(TAG, ""remove: move "" + (index + 1) + ""-"" + nsize + "" to "" + index);
                System.arraycopy(mHashes, index + 1, mHashes, index, nsize - index);
                System.arraycopy(mArray, (index + 1) << 1, mArray, index << 1, (nsize - index) << 1);
            }
            mArray[nsize << 1] = null;
            mArray[(nsize << 1) + 1] = null;
        }
    }
    if (CONCURRENT_MODIFICATION_EXCEPTIONS && osize != mSize) {
        throw new ConcurrentModificationException();
    }
    mSize = nsize;
    return (V) old;
}",1,"/**
 * Remove the key/value mapping at the given index.
 * @param index The desired index, must be between 0 and {@link #size()}-1.
 * @return Returns the value that was stored at this index.
 */
","/**
 * Remove the key/value mapping at the given index.
 * @param index The desired index, must be between 0 and {@link #size()}-1.
 * @return Returns the value that was stored at this index.
 */
",-1,,,-1,-1,-1,-1,-1,-1,,,,
558,"<android.os.BaseBundle: void writeToParcelInner(Parcel,int)>",27,28,"<android.os.BaseBundle: void writeToParcelInner(Parcel,int)>","<android.os.BaseBundle: void writeToParcelInner(Parcel,int)>",0,"{
    // If the parcel has a read-write helper, we can't just copy the blob, so unparcel it first.
    if (parcel.hasReadWriteHelper()) {
        unparcel();
    }
    // Keep implementation in sync with writeToParcel() in
    // frameworks/native/libs/binder/PersistableBundle.cpp.
    final ArrayMap<String, Object> map;
    synchronized (this) {
        // at the wrong time. So synchronize access the mParcelledData's content.
        if (mParcelledData != null) {
            if (mParcelledData == NoImagePreloadHolder.EMPTY_PARCEL) {
                parcel.writeInt(0);
            } else {
                int length = mParcelledData.dataSize();
                parcel.writeInt(length);
                parcel.writeInt(BUNDLE_MAGIC);
                parcel.appendFrom(mParcelledData, 0, length);
            }
            return;
        }
        map = mMap;
    }
    // Special case for empty bundles.
    if (map == null || map.size() <= 0) {
        parcel.writeInt(0);
        return;
    }
    int lengthPos = parcel.dataPosition();
    // dummy, will hold length
    parcel.writeInt(-1);
    parcel.writeInt(BUNDLE_MAGIC);
    int startPos = parcel.dataPosition();
    parcel.writeArrayMapInternal(map);
    int endPos = parcel.dataPosition();
    // Backpatch length
    parcel.setDataPosition(lengthPos);
    int length = endPos - startPos;
    parcel.writeInt(length);
    parcel.setDataPosition(endPos);
}","{
    // If the parcel has a read-write helper, we can't just copy the blob, so unparcel it first.
    if (parcel.hasReadWriteHelper()) {
        unparcel();
    }
    // Keep implementation in sync with writeToParcel() in
    // frameworks/native/libs/binder/PersistableBundle.cpp.
    final ArrayMap<String, Object> map;
    synchronized (this) {
        // at the wrong time. So synchronize access the mParcelledData's content.
        if (mParcelledData != null) {
            if (mParcelledData == NoImagePreloadHolder.EMPTY_PARCEL) {
                parcel.writeInt(0);
            } else {
                int length = mParcelledData.dataSize();
                parcel.writeInt(length);
                parcel.writeInt(mParcelledByNative ? BUNDLE_MAGIC_NATIVE : BUNDLE_MAGIC);
                parcel.appendFrom(mParcelledData, 0, length);
            }
            return;
        }
        map = mMap;
    }
    // Special case for empty bundles.
    if (map == null || map.size() <= 0) {
        parcel.writeInt(0);
        return;
    }
    int lengthPos = parcel.dataPosition();
    // dummy, will hold length
    parcel.writeInt(-1);
    parcel.writeInt(BUNDLE_MAGIC);
    int startPos = parcel.dataPosition();
    parcel.writeArrayMapInternal(map);
    int endPos = parcel.dataPosition();
    // Backpatch length
    parcel.setDataPosition(lengthPos);
    int length = endPos - startPos;
    parcel.writeInt(length);
    parcel.setDataPosition(endPos);
}",1,"/**
 * Writes the Bundle contents to a Parcel, typically in order for
 * it to be passed through an IBinder connection.
 * @param parcel The parcel to copy this bundle to.
 */
","/**
 * Writes the Bundle contents to a Parcel, typically in order for
 * it to be passed through an IBinder connection.
 * @param parcel The parcel to copy this bundle to.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The only change in the code is the ternary operation for determining the magic number to write to the parcel: `parcel.writeInt(mParcelledByNative ? BUNDLE_MAGIC_NATIVE : BUNDLE_MAGIC);` replaces the constant `parcel.writeInt(BUNDLE_MAGIC);`. This change affects the value written to the parcel but does not affect the control flow or the method signature. Therefore, the change type is 4.","Since the change doesn't affect the way the method behaves from the perspective of user code and doesn't introduce any incompatibility with previous or future versions of the data (as the BUNDLE_MAGIC or BUNDLE_MAGIC_NATIVE are internal representation details that should be compatible with the reading mechanism so long as the native reader knows how to interpret both), this wouldn't cause a compatibility issue. Hence, the compatibility issue classification is 0."
559,<android.content.ContentResolver: String getType(Uri)>,27,28,<android.content.ContentResolver: String getType(Uri)>,<android.content.ContentResolver: String getType(Uri)>,0,"{
    Preconditions.checkNotNull(url, ""url"");
    // XXX would like to have an acquireExistingUnstableProvider for this.
    IContentProvider provider = acquireExistingProvider(url);
    if (provider != null) {
        try {
            return provider.getType(url);
        } catch (RemoteException e) {
            return null;
        } catch (java.lang.Exception e) {
            Log.w(TAG, ""Failed to get type for: "" + url + "" ("" + e.getMessage() + "")"");
            return null;
        } finally {
            releaseProvider(provider);
        }
    }
    if (!SCHEME_CONTENT.equals(url.getScheme())) {
        return null;
    }
    try {
        String type = ActivityManager.getService().getProviderMimeType(ContentProvider.getUriWithoutUserId(url), resolveUserId(url));
        return type;
    } catch (RemoteException e) {
        // Manager will kill this process shortly anyway.
        return null;
    } catch (java.lang.Exception e) {
        Log.w(TAG, ""Failed to get type for: "" + url + "" ("" + e.getMessage() + "")"");
        return null;
    }
}","{
    Preconditions.checkNotNull(url, ""url"");
    // XXX would like to have an acquireExistingUnstableProvider for this.
    IContentProvider provider = acquireExistingProvider(url);
    if (provider != null) {
        try {
            return provider.getType(url);
        } catch (RemoteException e) {
            // Manager will kill this process shortly anyway.
            return null;
        } catch (java.lang.Exception e) {
            Log.w(TAG, ""Failed to get type for: "" + url + "" ("" + e.getMessage() + "")"");
            return null;
        } finally {
            releaseProvider(provider);
        }
    }
    if (!SCHEME_CONTENT.equals(url.getScheme())) {
        return null;
    }
    try {
        String type = ActivityManager.getService().getProviderMimeType(ContentProvider.getUriWithoutUserId(url), resolveUserId(url));
        return type;
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    } catch (java.lang.Exception e) {
        Log.w(TAG, ""Failed to get type for: "" + url + "" ("" + e.getMessage() + "")"");
        return null;
    }
}",1,"/**
 * Return the MIME type of the given content URL.
 *
 * @param url A Uri identifying content (either a list or specific type),
 * using the content:// scheme.
 * @return A MIME type for the content, or null if the URL is invalid or the type is unknown
 */
","/**
 * Return the MIME type of the given content URL.
 *
 * @param url A Uri identifying content (either a list or specific type),
 * using the content:// scheme.
 * @return A MIME type for the content, or null if the URL is invalid or the type is unknown
 */
",-1,[@Nullable],[@Nullable],-1,-1,-1,-1,-1,-1,2,2,"The change from catching the RemoteException and returning null to throwing e.rethrowFromSystemServer() is an exception handling statement change, resulting in code change type 2.","The change in the exception handling for RemoteException causes a difference in behavior. In the early version, the method would return null, but in the late version, it will throw an exception, causing a potential Compatibility Issue of type 2."
560,<android.bluetooth.le.AdvertisingSetParameters.Builder: Builder setInterval(int)>,27,28,<android.bluetooth.le.AdvertisingSetParameters.Builder: Builder setInterval(int)>,<android.bluetooth.le.AdvertisingSetParameters.Builder: Builder setInterval(int)>,0,"{
    if (interval < INTERVAL_MIN || interval > INTERVAL_MAX) {
        throw new IllegalArgumentException(""unknown interval "" + interval);
    }
    this.interval = interval;
    return this;
}","{
    if (interval < INTERVAL_MIN || interval > INTERVAL_MAX) {
        throw new IllegalArgumentException(""unknown interval "" + interval);
    }
    mInterval = interval;
    return this;
}",1,"/**
 * Set advertising interval.
 *
 * @param interval Bluetooth LE Advertising interval, in 0.625ms unit. Valid
 * range is from 160 (100ms) to 16777215 (10,485.759375 s).
 * Recommended values are:
 * {@link AdvertisingSetParameters#INTERVAL_LOW},
 * {@link AdvertisingSetParameters#INTERVAL_MEDIUM}, or
 * {@link AdvertisingSetParameters#INTERVAL_HIGH}.
 * @throws IllegalArgumentException If the interval is invalid.
 */
","/**
 * Set advertising interval.
 *
 * @param interval Bluetooth LE Advertising interval, in 0.625ms unit. Valid range is from
 * 160 (100ms) to 16777215 (10,485.759375 s). Recommended values are: {@link
 * AdvertisingSetParameters#INTERVAL_LOW}, {@link AdvertisingSetParameters#INTERVAL_MEDIUM},
 * or {@link AdvertisingSetParameters#INTERVAL_HIGH}.
 * @throws IllegalArgumentException If the interval is invalid.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The only change is the field assignment from `this.interval` to `mInterval`. Since it's a variable name change within the object state without any change in the control flow or method signature, the change type is 4.","This kind of change does not introduce any different behaviors observable by the caller of the method. The method signature remains the same, and the IllegalArgumentException is thrown under the same conditions as before. Therefore, there is no Compatibility Issue, and the CI type is 0."
561,"<android.view.ViewRootImpl.SendWindowContentChangedAccessibilityEvent: void runOrPost(View,int)>",27,28,"<android.view.ViewRootImpl.SendWindowContentChangedAccessibilityEvent: void runOrPost(View,int)>","<android.view.ViewRootImpl.SendWindowContentChangedAccessibilityEvent: void runOrPost(View,int)>",0,"{
    if (mHandler.getLooper() != Looper.myLooper()) {
        CalledFromWrongThreadException e = new CalledFromWrongThreadException(""Only the "" + ""original thread that created a view hierarchy can touch its views."");
        // TODO: Throw the exception
        Log.e(TAG, ""Accessibility content change on non-UI thread. Future Android "" + ""versions will throw an exception."", e);
        // Attempt to recover. This code does not eliminate the thread safety issue, but
        // it should force any issues to happen near the above log.
        mHandler.removeCallbacks(this);
        if (mSource != null) {
            // Dispatch whatever was pending. It's still possible that the runnable started
            // just before we removed the callbacks, and bad things will happen, but at
            // least they should happen very close to the logged error.
            run();
        }
    }
    if (mSource != null) {
        // If there is no common predecessor, then mSource points to
        // a removed view, hence in this case always prefer the source.
        View predecessor = getCommonPredecessor(mSource, source);
        mSource = (predecessor != null) ? predecessor : source;
        mChangeTypes |= changeType;
        return;
    }
    mSource = source;
    mChangeTypes = changeType;
    final long timeSinceLastMillis = SystemClock.uptimeMillis() - mLastEventTimeMillis;
    final long minEventIntevalMillis = ViewConfiguration.getSendRecurringAccessibilityEventsInterval();
    if (timeSinceLastMillis >= minEventIntevalMillis) {
        removeCallbacksAndRun();
    } else {
        mHandler.postDelayed(this, minEventIntevalMillis - timeSinceLastMillis);
    }
}","{
    if (mHandler.getLooper() != Looper.myLooper()) {
        CalledFromWrongThreadException e = new CalledFromWrongThreadException(""Only the "" + ""original thread that created a view hierarchy can touch its views."");
        // TODO: Throw the exception
        Log.e(TAG, ""Accessibility content change on non-UI thread. Future Android "" + ""versions will throw an exception."", e);
        // Attempt to recover. This code does not eliminate the thread safety issue, but
        // it should force any issues to happen near the above log.
        mHandler.removeCallbacks(this);
        if (mSource != null) {
            // Dispatch whatever was pending. It's still possible that the runnable started
            // just before we removed the callbacks, and bad things will happen, but at
            // least they should happen very close to the logged error.
            run();
        }
    }
    if (mSource != null) {
        // If there is no common predecessor, then mSource points to
        // a removed view, hence in this case always prefer the source.
        View predecessor = getCommonPredecessor(mSource, source);
        if (predecessor != null) {
            predecessor = predecessor.getSelfOrParentImportantForA11y();
        }
        mSource = (predecessor != null) ? predecessor : source;
        mChangeTypes |= changeType;
        return;
    }
    mSource = source;
    mChangeTypes = changeType;
    if (AccessibilityEvent.DEBUG_ORIGIN) {
        mOrigin = Thread.currentThread().getStackTrace();
    }
    final long timeSinceLastMillis = SystemClock.uptimeMillis() - mLastEventTimeMillis;
    final long minEventIntevalMillis = ViewConfiguration.getSendRecurringAccessibilityEventsInterval();
    if (timeSinceLastMillis >= minEventIntevalMillis) {
        removeCallbacksAndRun();
    } else {
        mHandler.postDelayed(this, minEventIntevalMillis - timeSinceLastMillis);
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"3,4",1,"The late version introduces an additional method call ""getSelfOrParentImportantForA11y()"" in the assignment of the ""predecessor"" variable if ""predecessor"" is not null. Additionally, a conditional block setting the ""mOrigin"" variable has been added if ""AccessibilityEvent.DEBUG_ORIGIN"" is true. The changes involve control dependency changes and other statement changes; thus the code change type is 3,4.","The added method call ""getSelfOrParentImportantForA11y()"" can potentially change the value of the ""predecessor"" variable before assignment to ""mSource"", which may lead to a different ""mSource"" object being used, hence affecting the return value in the control flow (return statement within if block). The assignment of ""mOrigin"" does not affect the return value or exception behavior of the method; hence, no CI is raised from this particular addition. The CI type is 1 for the potential change in return values due to the modification of ""predecessor""."
564,"<android.transition.ChangeBounds: Animator createAnimator(ViewGroup,TransitionValues,TransitionValues)>",27,28,"<android.transition.ChangeBounds: Animator createAnimator(ViewGroup,TransitionValues,TransitionValues)>","<android.transition.ChangeBounds: Animator createAnimator(ViewGroup,TransitionValues,TransitionValues)>",0,"{
    if (startValues == null || endValues == null) {
        return null;
    }
    Map<String, Object> startParentVals = startValues.values;
    Map<String, Object> endParentVals = endValues.values;
    ViewGroup startParent = (ViewGroup) startParentVals.get(PROPNAME_PARENT);
    ViewGroup endParent = (ViewGroup) endParentVals.get(PROPNAME_PARENT);
    if (startParent == null || endParent == null) {
        return null;
    }
    final View view = endValues.view;
    if (parentMatches(startParent, endParent)) {
        Rect startBounds = (Rect) startValues.values.get(PROPNAME_BOUNDS);
        Rect endBounds = (Rect) endValues.values.get(PROPNAME_BOUNDS);
        final int startLeft = startBounds.left;
        final int endLeft = endBounds.left;
        final int startTop = startBounds.top;
        final int endTop = endBounds.top;
        final int startRight = startBounds.right;
        final int endRight = endBounds.right;
        final int startBottom = startBounds.bottom;
        final int endBottom = endBounds.bottom;
        final int startWidth = startRight - startLeft;
        final int startHeight = startBottom - startTop;
        final int endWidth = endRight - endLeft;
        final int endHeight = endBottom - endTop;
        Rect startClip = (Rect) startValues.values.get(PROPNAME_CLIP);
        Rect endClip = (Rect) endValues.values.get(PROPNAME_CLIP);
        int numChanges = 0;
        if ((startWidth != 0 && startHeight != 0) || (endWidth != 0 && endHeight != 0)) {
            if (startLeft != endLeft || startTop != endTop)
                ++numChanges;
            if (startRight != endRight || startBottom != endBottom)
                ++numChanges;
        }
        if ((startClip != null && !startClip.equals(endClip)) || (startClip == null && endClip != null)) {
            ++numChanges;
        }
        if (numChanges > 0) {
            Animator anim;
            if (!mResizeClip) {
                view.setLeftTopRightBottom(startLeft, startTop, startRight, startBottom);
                if (numChanges == 2) {
                    if (startWidth == endWidth && startHeight == endHeight) {
                        Path topLeftPath = getPathMotion().getPath(startLeft, startTop, endLeft, endTop);
                        anim = ObjectAnimator.ofObject(view, POSITION_PROPERTY, null, topLeftPath);
                    } else {
                        final ViewBounds viewBounds = new ViewBounds(view);
                        Path topLeftPath = getPathMotion().getPath(startLeft, startTop, endLeft, endTop);
                        ObjectAnimator topLeftAnimator = ObjectAnimator.ofObject(viewBounds, TOP_LEFT_PROPERTY, null, topLeftPath);
                        Path bottomRightPath = getPathMotion().getPath(startRight, startBottom, endRight, endBottom);
                        ObjectAnimator bottomRightAnimator = ObjectAnimator.ofObject(viewBounds, BOTTOM_RIGHT_PROPERTY, null, bottomRightPath);
                        AnimatorSet set = new AnimatorSet();
                        set.playTogether(topLeftAnimator, bottomRightAnimator);
                        anim = set;
                        set.addListener(new AnimatorListenerAdapter() {

                            // We need a strong reference to viewBounds until the
                            // animator ends.
                            private ViewBounds mViewBounds = viewBounds;
                        });
                    }
                } else if (startLeft != endLeft || startTop != endTop) {
                    Path topLeftPath = getPathMotion().getPath(startLeft, startTop, endLeft, endTop);
                    anim = ObjectAnimator.ofObject(view, TOP_LEFT_ONLY_PROPERTY, null, topLeftPath);
                } else {
                    Path bottomRight = getPathMotion().getPath(startRight, startBottom, endRight, endBottom);
                    anim = ObjectAnimator.ofObject(view, BOTTOM_RIGHT_ONLY_PROPERTY, null, bottomRight);
                }
            } else {
                int maxWidth = Math.max(startWidth, endWidth);
                int maxHeight = Math.max(startHeight, endHeight);
                view.setLeftTopRightBottom(startLeft, startTop, startLeft + maxWidth, startTop + maxHeight);
                ObjectAnimator positionAnimator = null;
                if (startLeft != endLeft || startTop != endTop) {
                    Path topLeftPath = getPathMotion().getPath(startLeft, startTop, endLeft, endTop);
                    positionAnimator = ObjectAnimator.ofObject(view, POSITION_PROPERTY, null, topLeftPath);
                }
                final Rect finalClip = endClip;
                if (startClip == null) {
                    startClip = new Rect(0, 0, startWidth, startHeight);
                }
                if (endClip == null) {
                    endClip = new Rect(0, 0, endWidth, endHeight);
                }
                ObjectAnimator clipAnimator = null;
                if (!startClip.equals(endClip)) {
                    view.setClipBounds(startClip);
                    clipAnimator = ObjectAnimator.ofObject(view, ""clipBounds"", sRectEvaluator, startClip, endClip);
                    clipAnimator.addListener(new AnimatorListenerAdapter() {

                        private boolean mIsCanceled;

                        @Override
                        public void onAnimationCancel(Animator animation) {
                            mIsCanceled = true;
                        }

                        @Override
                        public void onAnimationEnd(Animator animation) {
                            if (!mIsCanceled) {
                                view.setClipBounds(finalClip);
                                view.setLeftTopRightBottom(endLeft, endTop, endRight, endBottom);
                            }
                        }
                    });
                }
                anim = TransitionUtils.mergeAnimators(positionAnimator, clipAnimator);
            }
            if (view.getParent() instanceof ViewGroup) {
                final ViewGroup parent = (ViewGroup) view.getParent();
                parent.suppressLayout(true);
                TransitionListener transitionListener = new TransitionListenerAdapter() {

                    boolean mCanceled = false;

                    @Override
                    public void onTransitionCancel(Transition transition) {
                        parent.suppressLayout(false);
                        mCanceled = true;
                    }

                    @Override
                    public void onTransitionEnd(Transition transition) {
                        if (!mCanceled) {
                            parent.suppressLayout(false);
                        }
                        transition.removeListener(this);
                    }

                    @Override
                    public void onTransitionPause(Transition transition) {
                        parent.suppressLayout(false);
                    }

                    @Override
                    public void onTransitionResume(Transition transition) {
                        parent.suppressLayout(true);
                    }
                };
                addListener(transitionListener);
            }
            return anim;
        }
    } else {
        sceneRoot.getLocationInWindow(tempLocation);
        int startX = (Integer) startValues.values.get(PROPNAME_WINDOW_X) - tempLocation[0];
        int startY = (Integer) startValues.values.get(PROPNAME_WINDOW_Y) - tempLocation[1];
        int endX = (Integer) endValues.values.get(PROPNAME_WINDOW_X) - tempLocation[0];
        int endY = (Integer) endValues.values.get(PROPNAME_WINDOW_Y) - tempLocation[1];
        // TODO: also handle size changes: check bounds and animate size changes
        if (startX != endX || startY != endY) {
            final int width = view.getWidth();
            final int height = view.getHeight();
            Bitmap bitmap = Bitmap.createBitmap(width, height, Bitmap.Config.ARGB_8888);
            Canvas canvas = new Canvas(bitmap);
            view.draw(canvas);
            final BitmapDrawable drawable = new BitmapDrawable(bitmap);
            drawable.setBounds(startX, startY, startX + width, startY + height);
            final float transitionAlpha = view.getTransitionAlpha();
            view.setTransitionAlpha(0);
            sceneRoot.getOverlay().add(drawable);
            Path topLeftPath = getPathMotion().getPath(startX, startY, endX, endY);
            PropertyValuesHolder origin = PropertyValuesHolder.ofObject(DRAWABLE_ORIGIN_PROPERTY, null, topLeftPath);
            ObjectAnimator anim = ObjectAnimator.ofPropertyValuesHolder(drawable, origin);
            anim.addListener(new AnimatorListenerAdapter() {

                @Override
                public void onAnimationEnd(Animator animation) {
                    sceneRoot.getOverlay().remove(drawable);
                    view.setTransitionAlpha(transitionAlpha);
                }
            });
            return anim;
        }
    }
    return null;
}","{
    if (startValues == null || endValues == null) {
        return null;
    }
    Map<String, Object> startParentVals = startValues.values;
    Map<String, Object> endParentVals = endValues.values;
    ViewGroup startParent = (ViewGroup) startParentVals.get(PROPNAME_PARENT);
    ViewGroup endParent = (ViewGroup) endParentVals.get(PROPNAME_PARENT);
    if (startParent == null || endParent == null) {
        return null;
    }
    final View view = endValues.view;
    if (parentMatches(startParent, endParent)) {
        Rect startBounds = (Rect) startValues.values.get(PROPNAME_BOUNDS);
        Rect endBounds = (Rect) endValues.values.get(PROPNAME_BOUNDS);
        final int startLeft = startBounds.left;
        final int endLeft = endBounds.left;
        final int startTop = startBounds.top;
        final int endTop = endBounds.top;
        final int startRight = startBounds.right;
        final int endRight = endBounds.right;
        final int startBottom = startBounds.bottom;
        final int endBottom = endBounds.bottom;
        final int startWidth = startRight - startLeft;
        final int startHeight = startBottom - startTop;
        final int endWidth = endRight - endLeft;
        final int endHeight = endBottom - endTop;
        Rect startClip = (Rect) startValues.values.get(PROPNAME_CLIP);
        Rect endClip = (Rect) endValues.values.get(PROPNAME_CLIP);
        int numChanges = 0;
        if ((startWidth != 0 && startHeight != 0) || (endWidth != 0 && endHeight != 0)) {
            if (startLeft != endLeft || startTop != endTop)
                ++numChanges;
            if (startRight != endRight || startBottom != endBottom)
                ++numChanges;
        }
        if ((startClip != null && !startClip.equals(endClip)) || (startClip == null && endClip != null)) {
            ++numChanges;
        }
        if (numChanges > 0) {
            if (view.getParent() instanceof ViewGroup) {
                final ViewGroup parent = (ViewGroup) view.getParent();
                parent.suppressLayout(true);
                TransitionListener transitionListener = new TransitionListenerAdapter() {

                    boolean mCanceled = false;

                    @Override
                    public void onTransitionCancel(Transition transition) {
                        parent.suppressLayout(false);
                        mCanceled = true;
                    }

                    @Override
                    public void onTransitionEnd(Transition transition) {
                        if (!mCanceled) {
                            parent.suppressLayout(false);
                        }
                        transition.removeListener(this);
                    }

                    @Override
                    public void onTransitionPause(Transition transition) {
                        parent.suppressLayout(false);
                    }

                    @Override
                    public void onTransitionResume(Transition transition) {
                        parent.suppressLayout(true);
                    }
                };
                addListener(transitionListener);
            }
            Animator anim;
            if (!mResizeClip) {
                view.setLeftTopRightBottom(startLeft, startTop, startRight, startBottom);
                if (numChanges == 2) {
                    if (startWidth == endWidth && startHeight == endHeight) {
                        Path topLeftPath = getPathMotion().getPath(startLeft, startTop, endLeft, endTop);
                        anim = ObjectAnimator.ofObject(view, POSITION_PROPERTY, null, topLeftPath);
                    } else {
                        final ViewBounds viewBounds = new ViewBounds(view);
                        Path topLeftPath = getPathMotion().getPath(startLeft, startTop, endLeft, endTop);
                        ObjectAnimator topLeftAnimator = ObjectAnimator.ofObject(viewBounds, TOP_LEFT_PROPERTY, null, topLeftPath);
                        Path bottomRightPath = getPathMotion().getPath(startRight, startBottom, endRight, endBottom);
                        ObjectAnimator bottomRightAnimator = ObjectAnimator.ofObject(viewBounds, BOTTOM_RIGHT_PROPERTY, null, bottomRightPath);
                        AnimatorSet set = new AnimatorSet();
                        set.playTogether(topLeftAnimator, bottomRightAnimator);
                        anim = set;
                        set.addListener(new AnimatorListenerAdapter() {

                            // We need a strong reference to viewBounds until the
                            // animator ends.
                            private ViewBounds mViewBounds = viewBounds;
                        });
                    }
                } else if (startLeft != endLeft || startTop != endTop) {
                    Path topLeftPath = getPathMotion().getPath(startLeft, startTop, endLeft, endTop);
                    anim = ObjectAnimator.ofObject(view, TOP_LEFT_ONLY_PROPERTY, null, topLeftPath);
                } else {
                    Path bottomRight = getPathMotion().getPath(startRight, startBottom, endRight, endBottom);
                    anim = ObjectAnimator.ofObject(view, BOTTOM_RIGHT_ONLY_PROPERTY, null, bottomRight);
                }
            } else {
                int maxWidth = Math.max(startWidth, endWidth);
                int maxHeight = Math.max(startHeight, endHeight);
                view.setLeftTopRightBottom(startLeft, startTop, startLeft + maxWidth, startTop + maxHeight);
                ObjectAnimator positionAnimator = null;
                if (startLeft != endLeft || startTop != endTop) {
                    Path topLeftPath = getPathMotion().getPath(startLeft, startTop, endLeft, endTop);
                    positionAnimator = ObjectAnimator.ofObject(view, POSITION_PROPERTY, null, topLeftPath);
                }
                final Rect finalClip = endClip;
                if (startClip == null) {
                    startClip = new Rect(0, 0, startWidth, startHeight);
                }
                if (endClip == null) {
                    endClip = new Rect(0, 0, endWidth, endHeight);
                }
                ObjectAnimator clipAnimator = null;
                if (!startClip.equals(endClip)) {
                    view.setClipBounds(startClip);
                    clipAnimator = ObjectAnimator.ofObject(view, ""clipBounds"", sRectEvaluator, startClip, endClip);
                    clipAnimator.addListener(new AnimatorListenerAdapter() {

                        private boolean mIsCanceled;

                        @Override
                        public void onAnimationCancel(Animator animation) {
                            mIsCanceled = true;
                        }

                        @Override
                        public void onAnimationEnd(Animator animation) {
                            if (!mIsCanceled) {
                                view.setClipBounds(finalClip);
                                view.setLeftTopRightBottom(endLeft, endTop, endRight, endBottom);
                            }
                        }
                    });
                }
                anim = TransitionUtils.mergeAnimators(positionAnimator, clipAnimator);
            }
            return anim;
        }
    } else {
        sceneRoot.getLocationInWindow(tempLocation);
        int startX = (Integer) startValues.values.get(PROPNAME_WINDOW_X) - tempLocation[0];
        int startY = (Integer) startValues.values.get(PROPNAME_WINDOW_Y) - tempLocation[1];
        int endX = (Integer) endValues.values.get(PROPNAME_WINDOW_X) - tempLocation[0];
        int endY = (Integer) endValues.values.get(PROPNAME_WINDOW_Y) - tempLocation[1];
        // TODO: also handle size changes: check bounds and animate size changes
        if (startX != endX || startY != endY) {
            final int width = view.getWidth();
            final int height = view.getHeight();
            Bitmap bitmap = Bitmap.createBitmap(width, height, Bitmap.Config.ARGB_8888);
            Canvas canvas = new Canvas(bitmap);
            view.draw(canvas);
            final BitmapDrawable drawable = new BitmapDrawable(bitmap);
            drawable.setBounds(startX, startY, startX + width, startY + height);
            final float transitionAlpha = view.getTransitionAlpha();
            view.setTransitionAlpha(0);
            sceneRoot.getOverlay().add(drawable);
            Path topLeftPath = getPathMotion().getPath(startX, startY, endX, endY);
            PropertyValuesHolder origin = PropertyValuesHolder.ofObject(DRAWABLE_ORIGIN_PROPERTY, null, topLeftPath);
            ObjectAnimator anim = ObjectAnimator.ofPropertyValuesHolder(drawable, origin);
            anim.addListener(new AnimatorListenerAdapter() {

                @Override
                public void onAnimationEnd(Animator animation) {
                    sceneRoot.getOverlay().remove(drawable);
                    view.setTransitionAlpha(transitionAlpha);
                }
            });
            return anim;
        }
    }
    return null;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,,,,
565,<android.hardware.camera2.CaptureRequest.Builder: T get(Key<T>)>,27,28,<android.hardware.camera2.CaptureRequest.Builder: T get(Key<T>)>,<android.hardware.camera2.CaptureRequest.Builder: T get(Key<T>)>,0,"{
    return mRequest.mSettings.get(key);
}","{
    return mRequest.mLogicalCameraSettings.get(key);
}",1,"/**
 * Get a capture request field value. The field definitions can be
 * found in {@link CaptureRequest}.
 *
 * @throws IllegalArgumentException if the key was not valid
 *
 * @param key The metadata field to read.
 * @return The value of that key, or {@code null} if the field is not set.
 */
","/**
 * Get a capture request field value. The field definitions can be
 * found in {@link CaptureRequest}.
 *
 * @throws IllegalArgumentException if the key was not valid
 *
 * @param key The metadata field to read.
 * @return The value of that key, or {@code null} if the field is not set.
 */
",-1,[@Nullable],[@Nullable],-1,-1,-1,-1,-1,-1,5,1,"The code change involves the change of the object from which a method is called; the method `get(key)` is called on `mRequest.mSettings` in the early version and on `mRequest.mLogicalCameraSettings` in the late version. Since this involves the use of a different object instance to retrieve a value, it is categorized as a dependent API change, type 5.","The change in the source object of the `.get(key)` method call could potentially lead to a different return value since it's not guaranteed that `mRequest.mSettings` and `mRequest.mLogicalCameraSettings` will have the same mappings for the same keys. Therefore, this change could cause the API to return a different value, which represents a compatibility issue of type 1."
567,<android.bluetooth.BluetoothServerSocket: String toString()>,27,28,<android.bluetooth.BluetoothServerSocket: String toString()>,<android.bluetooth.BluetoothServerSocket: String toString()>,0,"{
    StringBuilder sb = new StringBuilder();
    sb.append(""ServerSocket: Type: "");
    switch(mSocket.getConnectionType()) {
        case BluetoothSocket.TYPE_RFCOMM:
            {
                sb.append(""TYPE_RFCOMM"");
                break;
            }
        case BluetoothSocket.TYPE_L2CAP:
            {
                sb.append(""TYPE_L2CAP"");
                break;
            }
        case BluetoothSocket.TYPE_SCO:
            {
                sb.append(""TYPE_SCO"");
                break;
            }
    }
    sb.append("" Channel: "").append(mChannel);
    return sb.toString();
}","{
    StringBuilder sb = new StringBuilder();
    sb.append(""ServerSocket: Type: "");
    switch(mSocket.getConnectionType()) {
        case BluetoothSocket.TYPE_RFCOMM:
            {
                sb.append(""TYPE_RFCOMM"");
                break;
            }
        case BluetoothSocket.TYPE_L2CAP:
            {
                sb.append(""TYPE_L2CAP"");
                break;
            }
        case BluetoothSocket.TYPE_L2CAP_LE:
            {
                sb.append(""TYPE_L2CAP_LE"");
                break;
            }
        case BluetoothSocket.TYPE_SCO:
            {
                sb.append(""TYPE_SCO"");
                break;
            }
    }
    sb.append("" Channel: "").append(mChannel);
    return sb.toString();
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,4",0,"The `switch` statement has been altered to include a new `case` for `BluetoothSocket.TYPE_L2CAP_LE`. However, there are no deletions of previous return statements nor changes in the behavior of existing cases. Additionally, no modifications have been made to the handling of exceptions. Thus, the code change type is 3,4.","Despite the change in the implemented functionality, since this is a `toString()` method, the textual representation of the object now includes a new case for `BluetoothSocket.TYPE_L2CAP_LE`. This change does not affect the API in a way that would cause a different return type or throw a new exception for existing functionality, so there is no compatibility issue, and the CI type is 0."
568,"<android.widget.RemoteViews.ReflectionAction: Action initActionAsync(ViewTree,ViewGroup,OnClickHandler)>",27,28,"<android.widget.RemoteViews.ReflectionAction: Action initActionAsync(ViewTree,ViewGroup,OnClickHandler)>","<android.widget.RemoteViews.ReflectionAction: Action initActionAsync(ViewTree,ViewGroup,OnClickHandler)>",0,"{
    final View view = root.findViewById(viewId);
    if (view == null)
        return ACTION_NOOP;
    Class<?> param = getParameterType();
    if (param == null) {
        throw new ActionException(""bad type: "" + this.type);
    }
    try {
        Method method = getMethod(view, this.methodName, param);
        Method asyncMethod = getAsyncMethod(method);
        if (asyncMethod != null) {
            Runnable endAction = (Runnable) asyncMethod.invoke(view, wrapArg(this.value));
            if (endAction == null) {
                return ACTION_NOOP;
            } else {
                // Special case view stub
                if (endAction instanceof ViewStub.ViewReplaceRunnable) {
                    root.createTree();
                    // Replace child tree
                    root.findViewTreeById(viewId).replaceView(((ViewStub.ViewReplaceRunnable) endAction).view);
                }
                return new RunnableAction(endAction);
            }
        }
    } catch (ActionException e) {
        throw e;
    } catch (Exception ex) {
        throw new ActionException(ex);
    }
    return this;
}","{
    final View view = root.findViewById(viewId);
    if (view == null)
        return ACTION_NOOP;
    Class<?> param = getParameterType();
    if (param == null) {
        throw new ActionException(""bad type: "" + this.type);
    }
    try {
        MethodHandle method = getMethod(view, this.methodName, param, true);
        if (method != null) {
            Runnable endAction = (Runnable) method.invoke(view, this.value);
            if (endAction == null) {
                return ACTION_NOOP;
            } else {
                // Special case view stub
                if (endAction instanceof ViewStub.ViewReplaceRunnable) {
                    root.createTree();
                    // Replace child tree
                    root.findViewTreeById(viewId).replaceView(((ViewStub.ViewReplaceRunnable) endAction).view);
                }
                return new RunnableAction(endAction);
            }
        }
    } catch (Throwable ex) {
        throw new ActionException(ex);
    }
    return this;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,2,3,4,5","1,2","The method used to retrieve the method that needs to be invoked changed from `getMethod(view, this.methodName, param)` in the early version to `getMethod(view, this.methodName, param, true)` in the late version. This change not only modifies the dependent API being invoked (getMethod's parameter list), which is a change type of 5, but also changes the type of variable stored from `Method` to `MethodHandle`, and eliminates the usage of `getAsyncMethod(method)` and `wrapArg(this.value)`, which are changes of type 4. Exception catching block has changed from 'catch (Exception ex)' to 'catch (Throwable ex)', which is a return statement change of type 2. Furthermore, because the method signature being used has changed and this potentially changes how the method invocation takes place, this could lead to different behaviors in both returned values and exceptions that could be thrown, represented by changes of type 1 and 2, respectively.","The change in how the method is found and invoked, as well as the change in the exception type caught could potentially lead to different return values or types (due to the removal of `wrapArg` and use of `MethodHandle` instead of `Method`), and it also could trigger different exception handling behavior (`Throwable` vs `Exception`), all leading to a possible Compatibility Issue of type 1 and 2."
569,"<android.view.View: boolean hasFocusable(boolean,boolean)>",27,28,"<android.view.View: boolean hasFocusable(boolean,boolean)>","<android.view.View: boolean hasFocusable(boolean,boolean)>",0,"{
    if (!isFocusableInTouchMode()) {
        for (ViewParent p = mParent; p instanceof ViewGroup; p = p.getParent()) {
            final ViewGroup g = (ViewGroup) p;
            if (g.shouldBlockFocusForTouchscreen()) {
                return false;
            }
        }
    }
    // Invisible and gone views are never focusable.
    if ((mViewFlags & VISIBILITY_MASK) != VISIBLE) {
        return false;
    }
    // Only use effective focusable value when allowed.
    if ((allowAutoFocus || getFocusable() != FOCUSABLE_AUTO) && isFocusable()) {
        return true;
    }
    return false;
}","{
    if (!isFocusableInTouchMode()) {
        for (ViewParent p = mParent; p instanceof ViewGroup; p = p.getParent()) {
            final ViewGroup g = (ViewGroup) p;
            if (g.shouldBlockFocusForTouchscreen()) {
                return false;
            }
        }
    }
    // Invisible, gone, or disabled views are never focusable.
    if ((mViewFlags & VISIBILITY_MASK) != VISIBLE || (mViewFlags & ENABLED_MASK) != ENABLED) {
        return false;
    }
    // Only use effective focusable value when allowed.
    if ((allowAutoFocus || getFocusable() != FOCUSABLE_AUTO) && isFocusable()) {
        return true;
    }
    return false;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"3,4",1,The statement that checks for visibility and focusability has been changed to also check if the view is not disabled (the condition `(mViewFlags & ENABLED_MASK) != ENABLED` has been added). There is also an additional comment in the code indicating that disabled views are never focusable. This change is classified as both control dependency change (type 3) because of the change in the conditional logic and other statement changed (type 4) because of the change in the comment description.,"These code changes can potentially lead to a different return value because the method now includes an additional check to see if the `View` is enabled before determining if it is focusable. If a view was focusable in the early version but is disabled in the late version, it will now return false instead of true, resulting in a potential Compatibility Issue of type 1 (different return values)."
570,<android.bluetooth.BluetoothAdapter: boolean isLe2MPhySupported()>,27,28,<android.bluetooth.BluetoothAdapter: boolean isLe2MPhySupported()>,<android.bluetooth.BluetoothAdapter: boolean isLe2MPhySupported()>,0,"{
    if (!getLeAccess())
        return false;
    try {
        mServiceLock.readLock().lock();
        if (mService != null)
            return mService.isLe2MPhySupported();
    } catch (RemoteException e) {
        Log.e(TAG, ""failed to get isExtendedAdvertisingSupported, error: "", e);
    } finally {
        mServiceLock.readLock().unlock();
    }
    return false;
}","{
    if (!getLeAccess()) {
        return false;
    }
    try {
        mServiceLock.readLock().lock();
        if (mService != null) {
            return mService.isLe2MPhySupported();
        }
    } catch (RemoteException e) {
        Log.e(TAG, ""failed to get isExtendedAdvertisingSupported, error: "", e);
    } finally {
        mServiceLock.readLock().unlock();
    }
    return false;
}",1,"/**
 * Return true if LE 2M PHY feature is supported.
 *
 * @return true if chipset supports LE 2M PHY feature
 */
","/**
 * Return true if LE 2M PHY feature is supported.
 *
 * @return true if chipset supports LE 2M PHY feature
 */
",-1,,,-1,-1,-1,-1,-1,-1,0,0,"There is no functional change between the two versions of the API implementation other than formatting (e.g., added braces for clarity). This means the behaviour of the API remains unchanged.","Since there is no functional code change, no Compatibility Issue could arise from these changes. The API should behave identically in both versions."
571,<android.hardware.radio.RadioManager.ProgramInfo: boolean isTrafficProgram()>,27,28,<android.hardware.radio.RadioManager.ProgramInfo: boolean isTrafficProgram()>,<android.hardware.radio.RadioManager.ProgramInfo: boolean isTrafficProgram()>,0,"{
    return (mFlags & FLAG_TRAFFIC_PROGRAM) != 0;
}","{
    return (mInfoFlags & FLAG_TRAFFIC_PROGRAM) != 0;
}",1,"/**
 * {@code true} if radio station transmits traffic information
 * regularily.
 */
","/**
 * {@code true} if radio station transmits traffic information
 * regularily.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,1,"The field used in the return statement has changed from mFlags to mInfoFlags, so the code change type is 4.","The field used in the condition has been altered, which can lead the API to potentially return a different boolean value, thus the CI type is 1."
573,"<android.provider.Settings.System: float getFloat(ContentResolver,String,float)>",27,28,"<android.provider.Settings.System: float getFloat(ContentResolver,String,float)>","<android.provider.Settings.System: float getFloat(ContentResolver,String,float)>",0,"{
    return getFloatForUser(cr, name, def, UserHandle.myUserId());
}","{
    return getFloatForUser(cr, name, def, cr.getUserId());
}",1,"/**
 * Convenience function for retrieving a single system settings value
 * as a floating point number.  Note that internally setting values are
 * always stored as strings; this function converts the string to an
 * float for you. The default value will be returned if the setting
 * is not defined or not a valid float.
 *
 * @param cr The ContentResolver to access.
 * @param name The name of the setting to retrieve.
 * @param def Value to return if the setting is not defined.
 *
 * @return The setting's current value, or 'def' if it is not defined
 * or not a valid float.
 */
","/**
 * Convenience function for retrieving a single system settings value
 * as a floating point number.  Note that internally setting values are
 * always stored as strings; this function converts the string to an
 * float for you. The default value will be returned if the setting
 * is not defined or not a valid float.
 *
 * @param cr The ContentResolver to access.
 * @param name The name of the setting to retrieve.
 * @param def Value to return if the setting is not defined.
 *
 * @return The setting's current value, or 'def' if it is not defined
 * or not a valid float.
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,1,"The way user ID is obtained changed from UserHandle.myUserId() to cr.getUserId(), which indicates the dependent API changed, so the change type is 5.","The user ID that is used as a parameter in getFloatForUser() is obtained from different source between the two versions. Since the user ID could potentially differ, it could cause the method to return a different float value, leading to a compatibility issue of type 1."
574,"<android.widget.Editor.TextActionModeCallback: boolean onPrepareActionMode(ActionMode,Menu)>",27,28,"<android.widget.Editor.TextActionModeCallback: boolean onPrepareActionMode(ActionMode,Menu)>","<android.widget.Editor.TextActionModeCallback: boolean onPrepareActionMode(ActionMode,Menu)>",0,"{
    updateSelectAllItem(menu);
    updateReplaceItem(menu);
    updateAssistMenuItem(menu);
    Callback customCallback = getCustomCallback();
    if (customCallback != null) {
        return customCallback.onPrepareActionMode(mode, menu);
    }
    return true;
}","{
    updateSelectAllItem(menu);
    updateReplaceItem(menu);
    updateAssistMenuItems(menu);
    Callback customCallback = getCustomCallback();
    if (customCallback != null) {
        return customCallback.onPrepareActionMode(mode, menu);
    }
    return true;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"There is only a change in the name of a method from `updateAssistMenuItem(menu)` to `updateAssistMenuItems(menu)`, without any change to control flow, exception handling, or return statements, and this does not necessarily mean the behavior or return type of the method has altered. Therefore, the code change type is 4 (Other statement changed).","No CI arises from the change, since there's no evidence the change would result in a different variable being returned or a different type of exception being thrown based on the provided information. The actual behavior may or may not be different depending on what `updateAssistMenuItems(menu)` does compared to `updateAssistMenuItem(menu)`, but strictly based on the provided information, no CI can be confirmed. Thus, the CI type is 0 (No Compatibility Issue)."
575,<android.widget.TextView: boolean onTrackballEvent(MotionEvent)>,27,28,<android.widget.TextView: boolean onTrackballEvent(MotionEvent)>,<android.widget.TextView: boolean onTrackballEvent(MotionEvent)>,0,"{
    if (mMovement != null && mText instanceof Spannable && mLayout != null) {
        if (mMovement.onTrackballEvent(this, (Spannable) mText, event)) {
            return true;
        }
    }
    return super.onTrackballEvent(event);
}","{
    if (mMovement != null && mSpannable != null && mLayout != null) {
        if (mMovement.onTrackballEvent(this, mSpannable, event)) {
            return true;
        }
    }
    return super.onTrackballEvent(event);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,5",0,"The change is found in the control dependency where the condition `mText instanceof Spannable` is replaced with `mSpannable != null`. Furthermore, there is a change in the type of the variable passed to `mMovement.onTrackballEvent()`, which refers to a dependent API change. So, the code change types are 3,5.","Even though there is a change in the control condition and the variable passed to a method, the behavior of the method does not fundamentally change as long as `mSpannable` represents the same condition previously checked by `mText instanceof Spannable`. If `mSpannable` is indeed an equivalent representation that `mText` is a `Spannable`, then there is no change in the behavior of whether the method will return true or proceed to call `super.onTrackballEvent(event)`. Therefore, there's no compatibility issue caused by potential different return values or exception handlings."
576,<android.view.autofill.AutofillManager: void commit()>,27,28,<android.view.autofill.AutofillManager: void commit()>,<android.view.autofill.AutofillManager: void commit()>,0,"{
    if (!hasAutofillFeature()) {
        return;
    }
    synchronized (mLock) {
        if (!mEnabled && !isActiveLocked()) {
            return;
        }
        finishSessionLocked();
    }
}","{
    if (!hasAutofillFeature()) {
        return;
    }
    if (sVerbose)
        Log.v(TAG, ""commit() called by app"");
    synchronized (mLock) {
        commitLocked();
    }
}",1,"/**
 * Called to indicate the current autofill context should be commited.
 *
 * <p>This method is typically called by {@link View Views} that manage virtual views; for
 * example, when the view is rendering an {@code HTML} page with a form and virtual views
 * that represent the HTML elements, it should call this method after the form is submitted and
 * another page is rendered.
 *
 * <p><b>Note:</b> This method does not need to be called on regular application lifecycle
 * methods such as {@link android.app.Activity#finish()}.
 */
","/**
 * Called to indicate the current autofill context should be commited.
 *
 * <p>This method is typically called by {@link View Views} that manage virtual views; for
 * example, when the view is rendering an {@code HTML} page with a form and virtual views
 * that represent the HTML elements, it should call this method after the form is submitted and
 * another page is rendered.
 *
 * <p><b>Note:</b> This method does not need to be called on regular application lifecycle
 * methods such as {@link android.app.Activity#finish()}.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",0,The implementation has changed by adding a log statement which is a change of type 4 and the call to finishSessionLocked() being replaced with commitLocked() within the synchronized block represents a change of type 3.,"The additional log statement does not change the API's behavior as it does not affect the return value nor does it change how exceptions are handled. The change from finishSessionLocked() to commitLocked() does not necessarily indicate a compatibility issue by itself unless commitLocked() has a different implementation that could cause a different behavior. However, as no information about commitLocked()'s implementation or its effects are provided, we cannot assume a behavior change and hence no CI is detected based on the information available."
577,"<android.net.Uri.StringUri: String parseAuthority(String,int)>",27,28,"<android.net.Uri.StringUri: String parseAuthority(String,int)>","<android.net.Uri.StringUri: String parseAuthority(String,int)>",0,"{
    int length = uriString.length();
    // If ""//"" follows the scheme separator, we have an authority.
    if (length > ssi + 2 && uriString.charAt(ssi + 1) == '/' && uriString.charAt(ssi + 2) == '/') {
        // We have an authority.
        // Look for the start of the path, query, or fragment, or the
        // end of the string.
        int end = ssi + 3;
        LOOP: while (end < length) {
            switch(uriString.charAt(end)) {
                // Start of path
                case '/':
                // Start of query
                case '?':
                case // Start of fragment
                '#':
                    break LOOP;
            }
            end++;
        }
        return uriString.substring(ssi + 3, end);
    } else {
        return null;
    }
}","{
    int length = uriString.length();
    // If ""//"" follows the scheme separator, we have an authority.
    if (length > ssi + 2 && uriString.charAt(ssi + 1) == '/' && uriString.charAt(ssi + 2) == '/') {
        // We have an authority.
        // Look for the start of the path, query, or fragment, or the
        // end of the string.
        int end = ssi + 3;
        LOOP: while (end < length) {
            switch(uriString.charAt(end)) {
                // Start of path
                case '/':
                // Start of path
                case '\\':
                // Start of query
                case '?':
                case // Start of fragment
                '#':
                    break LOOP;
            }
            end++;
        }
        return uriString.substring(ssi + 3, end);
    } else {
        return null;
    }
}",1,"/**
 * Parses an authority out of the given URI string.
 *
 * @param uriString URI string
 * @param ssi scheme separator index, -1 for a relative URI
 *
 * @return the authority or null if none is found
 */
","/**
 * Parses an authority out of the given URI string.
 *
 * @param uriString URI string
 * @param ssi scheme separator index, -1 for a relative URI
 *
 * @return the authority or null if none is found
 */
",-1,,,-1,-1,-1,-1,-1,-1,3,0,"The control dependency has changed by adding a new case label ('\\') in the switch statement inside the LOOP. Hence, the code change type is 3.","Although an additional case for the backslash ('\\') character was added, this does not imply a compatibility issue because the change does not affect the authority's extraction result. Both versions of the method still return the same substring (ssi + 3, end) if no reserved characters are found or return null if the requirements for an authority are not met. Therefore, there is no compatibility issue."
578,<android.view.MotionEvent: String toString()>,27,28,<android.view.MotionEvent: String toString()>,<android.view.MotionEvent: String toString()>,0,"{
    StringBuilder msg = new StringBuilder();
    msg.append(""MotionEvent { action="").append(actionToString(getAction()));
    msg.append("", actionButton="").append(buttonStateToString(getActionButton()));
    final int pointerCount = getPointerCount();
    for (int i = 0; i < pointerCount; i++) {
        msg.append("", id["").append(i).append(""]="").append(getPointerId(i));
        msg.append("", x["").append(i).append(""]="").append(getX(i));
        msg.append("", y["").append(i).append(""]="").append(getY(i));
        msg.append("", toolType["").append(i).append(""]="").append(toolTypeToString(getToolType(i)));
    }
    msg.append("", buttonState="").append(MotionEvent.buttonStateToString(getButtonState()));
    msg.append("", metaState="").append(KeyEvent.metaStateToString(getMetaState()));
    msg.append("", flags=0x"").append(Integer.toHexString(getFlags()));
    msg.append("", edgeFlags=0x"").append(Integer.toHexString(getEdgeFlags()));
    msg.append("", pointerCount="").append(pointerCount);
    msg.append("", historySize="").append(getHistorySize());
    msg.append("", eventTime="").append(getEventTime());
    msg.append("", downTime="").append(getDownTime());
    msg.append("", deviceId="").append(getDeviceId());
    msg.append("", source=0x"").append(Integer.toHexString(getSource()));
    msg.append("" }"");
    return msg.toString();
}","{
    StringBuilder msg = new StringBuilder();
    msg.append(""MotionEvent { action="").append(actionToString(getAction()));
    appendUnless(""0"", msg, "", actionButton="", buttonStateToString(getActionButton()));
    final int pointerCount = getPointerCount();
    for (int i = 0; i < pointerCount; i++) {
        appendUnless(i, msg, "", id["" + i + ""]="", getPointerId(i));
        float x = getX(i);
        float y = getY(i);
        if (!DEBUG_CONCISE_TOSTRING || x != 0f || y != 0f) {
            msg.append("", x["").append(i).append(""]="").append(x);
            msg.append("", y["").append(i).append(""]="").append(y);
        }
        appendUnless(TOOL_TYPE_SYMBOLIC_NAMES.get(TOOL_TYPE_FINGER), msg, "", toolType["" + i + ""]="", toolTypeToString(getToolType(i)));
    }
    appendUnless(""0"", msg, "", buttonState="", MotionEvent.buttonStateToString(getButtonState()));
    appendUnless(""0"", msg, "", metaState="", KeyEvent.metaStateToString(getMetaState()));
    appendUnless(""0"", msg, "", flags=0x"", Integer.toHexString(getFlags()));
    appendUnless(""0"", msg, "", edgeFlags=0x"", Integer.toHexString(getEdgeFlags()));
    appendUnless(1, msg, "", pointerCount="", pointerCount);
    appendUnless(0, msg, "", historySize="", getHistorySize());
    msg.append("", eventTime="").append(getEventTime());
    if (!DEBUG_CONCISE_TOSTRING) {
        msg.append("", downTime="").append(getDownTime());
        msg.append("", deviceId="").append(getDeviceId());
        msg.append("", source=0x"").append(Integer.toHexString(getSource()));
    }
    msg.append("" }"");
    return msg.toString();
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,4",1,"There are new method calls (`appendUnless`) introduced which are conditional, resulting in a change in control dependency. Additionally, there are other statements changed such as including condition checks on the `DEBUG_CONCISE_TOSTRING` flag. Thus, the types of changes are 3 and 4.","The `toString()` implementation has been modified to include conditional statements about whether to append certain pieces of information based on the values being non-default or because of the flag `DEBUG_CONCISE_TOSTRING`. This can cause the function to return a different string representation as compared to the earlier version. Therefore, there is a potential Compatibility Issue of type 1 due to different return values."
579,<android.content.res.Resources: TypedArray obtainTypedArray(int)>,27,28,<android.content.res.Resources: TypedArray obtainTypedArray(int)>,<android.content.res.Resources: TypedArray obtainTypedArray(int)>,0,"{
    final ResourcesImpl impl = mResourcesImpl;
    int len = impl.getAssets().getArraySize(id);
    if (len < 0) {
        throw new NotFoundException(""Array resource ID #0x"" + Integer.toHexString(id));
    }
    TypedArray array = TypedArray.obtain(this, len);
    array.mLength = impl.getAssets().retrieveArray(id, array.mData);
    array.mIndices[0] = 0;
    return array;
}","{
    final ResourcesImpl impl = mResourcesImpl;
    int len = impl.getAssets().getResourceArraySize(id);
    if (len < 0) {
        throw new NotFoundException(""Array resource ID #0x"" + Integer.toHexString(id));
    }
    TypedArray array = TypedArray.obtain(this, len);
    array.mLength = impl.getAssets().getResourceArray(id, array.mData);
    array.mIndices[0] = 0;
    return array;
}",1,"/**
 * Return an array of heterogeneous values.
 *
 * @param id The desired resource identifier, as generated by the aapt
 * tool. This integer encodes the package, type, and resource
 * entry. The value 0 is an invalid identifier.
 *
 * @throws NotFoundException Throws NotFoundException if the given ID does not exist.
 *
 * @return Returns a TypedArray holding an array of the array values.
 * Be sure to call {@link TypedArray#recycle() TypedArray.recycle()}
 * when done with it.
 */
","/**
 * Return an array of heterogeneous values.
 *
 * @param id The desired resource identifier, as generated by the aapt
 * tool. This integer encodes the package, type, and resource
 * entry. The value 0 is an invalid identifier.
 *
 * @throws NotFoundException Throws NotFoundException if the given ID does not exist.
 *
 * @return Returns a TypedArray holding an array of the array values.
 * Be sure to call {@link TypedArray#recycle() TypedArray.recycle()}
 * when done with it.
 */
",-1,[@NonNull],[@NonNull],-1,-1,-1,-1,-1,-1,5,0,"The method names involved in obtaining the length and retrieving the array data have changed from getArraySize to getResourceArraySize and from retrieveArray to getResourceArray, respectively. This indicates that the dependent API has changed, so the change type is 5.","Since the change is related only to the method names that are called and not to the return types or exception handling (assuming that the new methods behave identically in terms of returns and exceptions as the old methods), there is no indication of a Compatibility Issue. Thus, the CI type is 0."
580,<android.text.Selection: int getSelectionEnd(CharSequence)>,27,28,<android.text.Selection: int getSelectionEnd(CharSequence)>,<android.text.Selection: int getSelectionEnd(CharSequence)>,0,"{
    if (text instanceof Spanned)
        return ((Spanned) text).getSpanStart(SELECTION_END);
    else
        return -1;
}","{
    if (text instanceof Spanned) {
        return ((Spanned) text).getSpanStart(SELECTION_END);
    }
    return -1;
}",1,"/**
 * Return the offset of the selection edge or cursor, or -1 if
 * there is no selection or cursor.
 */
","/**
 * Return the offset of the selection edge or cursor, or -1 if
 * there is no selection or cursor.
 */
",-1,,,-1,-1,-1,-1,-1,-1,0,0,"The code change is merely a refactoring of the if-else statement to an if statement with a separate return at the end. The same return values are maintained, and the logic remains identical.",There is no compatibility issue as the behavior of the API has not changed; it returns the same values under the same conditions as before.
581,"<android.hardware.camera2.impl.CameraDeviceImpl.CameraDeviceCallbacks: void onCaptureStarted(CaptureResultExtras,long)>",27,28,"<android.hardware.camera2.impl.CameraDeviceImpl.CameraDeviceCallbacks: void onCaptureStarted(CaptureResultExtras,long)>","<android.hardware.camera2.impl.CameraDeviceImpl.CameraDeviceCallbacks: void onCaptureStarted(CaptureResultExtras,long)>",0,"{
    int requestId = resultExtras.getRequestId();
    final long frameNumber = resultExtras.getFrameNumber();
    if (DEBUG) {
        Log.d(TAG, ""Capture started for id "" + requestId + "" frame number "" + frameNumber);
    }
    final CaptureCallbackHolder holder;
    synchronized (mInterfaceLock) {
        // Camera already closed
        if (mRemoteDevice == null)
            return;
        // Get the callback for this frame ID, if there is one
        holder = CameraDeviceImpl.this.mCaptureCallbackMap.get(requestId);
        if (holder == null) {
            return;
        }
        if (isClosed())
            return;
        // Dispatch capture start notice
        holder.getHandler().post(new Runnable() {

            @Override
            public void run() {
                if (!CameraDeviceImpl.this.isClosed()) {
                    final int subsequenceId = resultExtras.getSubsequenceId();
                    final CaptureRequest request = holder.getRequest(subsequenceId);
                    if (holder.hasBatchedOutputs()) {
                        // Send derived onCaptureStarted for requests within the batch
                        final Range<Integer> fpsRange = request.get(CaptureRequest.CONTROL_AE_TARGET_FPS_RANGE);
                        for (int i = 0; i < holder.getRequestCount(); i++) {
                            holder.getCallback().onCaptureStarted(CameraDeviceImpl.this, holder.getRequest(i), timestamp - (subsequenceId - i) * NANO_PER_SECOND / fpsRange.getUpper(), frameNumber - (subsequenceId - i));
                        }
                    } else {
                        holder.getCallback().onCaptureStarted(CameraDeviceImpl.this, holder.getRequest(resultExtras.getSubsequenceId()), timestamp, frameNumber);
                    }
                }
            }
        });
    }
}","{
    int requestId = resultExtras.getRequestId();
    final long frameNumber = resultExtras.getFrameNumber();
    if (DEBUG) {
        Log.d(TAG, ""Capture started for id "" + requestId + "" frame number "" + frameNumber);
    }
    final CaptureCallbackHolder holder;
    synchronized (mInterfaceLock) {
        // Camera already closed
        if (mRemoteDevice == null)
            return;
        // Get the callback for this frame ID, if there is one
        holder = CameraDeviceImpl.this.mCaptureCallbackMap.get(requestId);
        if (holder == null) {
            return;
        }
        if (isClosed())
            return;
        // Dispatch capture start notice
        final long ident = Binder.clearCallingIdentity();
        try {
            holder.getExecutor().execute(new Runnable() {

                @Override
                public void run() {
                    if (!CameraDeviceImpl.this.isClosed()) {
                        final int subsequenceId = resultExtras.getSubsequenceId();
                        final CaptureRequest request = holder.getRequest(subsequenceId);
                        if (holder.hasBatchedOutputs()) {
                            // Send derived onCaptureStarted for requests within the
                            // batch
                            final Range<Integer> fpsRange = request.get(CaptureRequest.CONTROL_AE_TARGET_FPS_RANGE);
                            for (int i = 0; i < holder.getRequestCount(); i++) {
                                holder.getCallback().onCaptureStarted(CameraDeviceImpl.this, holder.getRequest(i), timestamp - (subsequenceId - i) * NANO_PER_SECOND / fpsRange.getUpper(), frameNumber - (subsequenceId - i));
                            }
                        } else {
                            holder.getCallback().onCaptureStarted(CameraDeviceImpl.this, holder.getRequest(resultExtras.getSubsequenceId()), timestamp, frameNumber);
                        }
                    }
                }
            });
        } finally {
            Binder.restoreCallingIdentity(ident);
        }
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"The late implementation introduces two new additional lines: the setting of the calling identity to a certain value before executing the callback and restoring the calling identity after executing the callback. As a result, the invocation of getExecutor().execute has been wrapped with Binder.clearCallingIdentity and Binder.restoreCallingIdentity, but the logic and functionality of the surrounding code remains unchanged, thus the change is classified under 'Other statement changed'.","The change to use Binder.clearCallingIdentity and Binder.restoreCallingIdentity ensures that the callback runs with the identity of the CameraDeviceImpl rather than the identity of the caller. Although this changes how the security context is handled while executing the callback, it doesn't change the behavior of the API as observed by the client code. It will neither return a different value nor throw a different exception due to these lines alone. Therefore, there isn't a Compatibility Issue caused by the change."
583,<android.bluetooth.le.AdvertisingSetParameters.Builder: Builder setIncludeTxPower(boolean)>,27,28,<android.bluetooth.le.AdvertisingSetParameters.Builder: Builder setIncludeTxPower(boolean)>,<android.bluetooth.le.AdvertisingSetParameters.Builder: Builder setIncludeTxPower(boolean)>,0,"{
    this.includeTxPower = includeTxPower;
    return this;
}","{
    mIncludeTxPower = includeTxPower;
    return this;
}",1,"/**
 * Set whether TX power should be included in the extended header.
 *
 * This is used only if legacy mode is not used.
 *
 * @param includeTxPower whether TX power should be included in extended
 * header
 */
","/**
 * Set whether TX power should be included in the extended header.
 *
 * This is used only if legacy mode is not used.
 *
 * @param includeTxPower whether TX power should be included in extended header
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The field name that is being set has changed from this.includeTxPower to mIncludeTxPower which is an instance variable change, so the code change type is 4.","There is no compatibility issue because the method's behavior has not changed, it still sets an internal flag and returns the Builder object itself. The renaming of the field does not alter the API's contract with callers, so the change does not cause a compatibility issue."
584,"<android.provider.Settings.System: boolean putFloat(ContentResolver,String,float)>",27,28,"<android.provider.Settings.System: boolean putFloat(ContentResolver,String,float)>","<android.provider.Settings.System: boolean putFloat(ContentResolver,String,float)>",0,"{
    return putFloatForUser(cr, name, value, UserHandle.myUserId());
}","{
    return putFloatForUser(cr, name, value, cr.getUserId());
}",1,"/**
 * Convenience function for updating a single settings value as a
 * floating point number. This will either create a new entry in the
 * table if the given name does not exist, or modify the value of the
 * existing row with that name.  Note that internally setting values
 * are always stored as strings, so this function converts the given
 * value to a string before storing it.
 *
 * @param cr The ContentResolver to access.
 * @param name The name of the setting to modify.
 * @param value The new value for the setting.
 * @return true if the value was set, false on database errors
 */
","/**
 * Convenience function for updating a single settings value as a
 * floating point number. This will either create a new entry in the
 * table if the given name does not exist, or modify the value of the
 * existing row with that name.  Note that internally setting values
 * are always stored as strings, so this function converts the given
 * value to a string before storing it.
 *
 * @param cr The ContentResolver to access.
 * @param name The name of the setting to modify.
 * @param value The new value for the setting.
 * @return true if the value was set, false on database errors
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The method signature has not changed, but the parameter passed to the putFloatForUser method has changed from UserHandle.myUserId() to cr.getUserId(). The change type is 5 because a dependent API (UserHandle.myUserId or ContentResolver.getUserId) invocation has been changed.","There is no Compatibility Issue as long as the cr.getUserId() method returns the same user ID as UserHandle.myUserId() for the context in which the method is used. Since the change is only in the parameter of the dependent API, it doesn't automatically guarantee a different behavior unless the new method returns a different result."
585,<android.widget.DateTimeView.ReceiverInfo: void removeView(DateTimeView)>,27,28,<android.widget.DateTimeView.ReceiverInfo: void removeView(DateTimeView)>,<android.widget.DateTimeView.ReceiverInfo: void removeView(DateTimeView)>,0,"{
    synchronized (mAttachedViews) {
        mAttachedViews.remove(v);
        if (mAttachedViews.isEmpty()) {
            unregister(getApplicationContextIfAvailable(v.getContext()));
        }
    }
}","{
    synchronized (mAttachedViews) {
        final boolean removed = mAttachedViews.remove(v);
        // trying to unregister a receiver that is no longer registered.
        if (removed && mAttachedViews.isEmpty()) {
            unregister(getApplicationContextIfAvailable(v.getContext()));
        }
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"3,4",0,"The late version introduces a new local variable `removed` to capture the return value of `mAttachedViews.remove(v)`. The `if` statement is now dependent on the value of this `removed` variable. Additionally, the comment indicates that `unregister` is only called if `removed` is true, which was not checked before, so the code change type is 3,4.","Although there is an additional variable `removed` introduced and the flow of execution could potentially be affected by whether the view was successfully removed or not, this change does not cause the API to return a different variable, nor does it introduce different exception handlings. It only refines the control flow to prevent a possible error related to unregistering a receiver that is not registered. Therefore, there is no Compatibility Issue as the overall behavior of the method from an external perspective should remain the same, and the CI type is 0."
586,<android.app.job.JobInfo.Builder: JobInfo build()>,27,28,<android.app.job.JobInfo.Builder: JobInfo build()>,<android.app.job.JobInfo.Builder: JobInfo build()>,0,"{
    // Allow jobs with no constraints - What am I, a database?
    if (!mHasEarlyConstraint && !mHasLateConstraint && mConstraintFlags == 0 && mNetworkType == NETWORK_TYPE_NONE && mTriggerContentUris == null) {
        throw new IllegalArgumentException(""You're trying to build a job with no "" + ""constraints, this is not allowed."");
    }
    // Check that a deadline was not set on a periodic job.
    if (mIsPeriodic) {
        if (mMaxExecutionDelayMillis != 0L) {
            throw new IllegalArgumentException(""Can't call setOverrideDeadline() on a "" + ""periodic job."");
        }
        if (mMinLatencyMillis != 0L) {
            throw new IllegalArgumentException(""Can't call setMinimumLatency() on a "" + ""periodic job"");
        }
        if (mTriggerContentUris != null) {
            throw new IllegalArgumentException(""Can't call addTriggerContentUri() on a "" + ""periodic job"");
        }
    }
    if (mIsPersisted) {
        if (mTriggerContentUris != null) {
            throw new IllegalArgumentException(""Can't call addTriggerContentUri() on a "" + ""persisted job"");
        }
        if (!mTransientExtras.isEmpty()) {
            throw new IllegalArgumentException(""Can't call setTransientExtras() on a "" + ""persisted job"");
        }
        if (mClipData != null) {
            throw new IllegalArgumentException(""Can't call setClipData() on a "" + ""persisted job"");
        }
    }
    if (mBackoffPolicySet && (mConstraintFlags & CONSTRAINT_FLAG_DEVICE_IDLE) != 0) {
        throw new IllegalArgumentException(""An idle mode job will not respect any"" + "" back-off policy, so calling setBackoffCriteria with"" + "" setRequiresDeviceIdle is an error."");
    }
    JobInfo job = new JobInfo(this);
    if (job.isPeriodic()) {
        if (job.intervalMillis != job.getIntervalMillis()) {
            StringBuilder builder = new StringBuilder();
            builder.append(""Specified interval for "").append(String.valueOf(mJobId)).append("" is "");
            formatDuration(mIntervalMillis, builder);
            builder.append("". Clamped to "");
            formatDuration(job.getIntervalMillis(), builder);
            Log.w(TAG, builder.toString());
        }
        if (job.flexMillis != job.getFlexMillis()) {
            StringBuilder builder = new StringBuilder();
            builder.append(""Specified flex for "").append(String.valueOf(mJobId)).append("" is "");
            formatDuration(mFlexMillis, builder);
            builder.append("". Clamped to "");
            formatDuration(job.getFlexMillis(), builder);
            Log.w(TAG, builder.toString());
        }
    }
    return job;
}","{
    // Allow jobs with no constraints - What am I, a database?
    if (!mHasEarlyConstraint && !mHasLateConstraint && mConstraintFlags == 0 && mNetworkRequest == null && mTriggerContentUris == null) {
        throw new IllegalArgumentException(""You're trying to build a job with no "" + ""constraints, this is not allowed."");
    }
    // Check that network estimates require network type
    if ((mNetworkDownloadBytes > 0 || mNetworkUploadBytes > 0) && mNetworkRequest == null) {
        throw new IllegalArgumentException(""Can't provide estimated network usage without requiring a network"");
    }
    // We can't serialize network specifiers
    if (mIsPersisted && mNetworkRequest != null && mNetworkRequest.networkCapabilities.getNetworkSpecifier() != null) {
        throw new IllegalArgumentException(""Network specifiers aren't supported for persistent jobs"");
    }
    // Check that a deadline was not set on a periodic job.
    if (mIsPeriodic) {
        if (mMaxExecutionDelayMillis != 0L) {
            throw new IllegalArgumentException(""Can't call setOverrideDeadline() on a "" + ""periodic job."");
        }
        if (mMinLatencyMillis != 0L) {
            throw new IllegalArgumentException(""Can't call setMinimumLatency() on a "" + ""periodic job"");
        }
        if (mTriggerContentUris != null) {
            throw new IllegalArgumentException(""Can't call addTriggerContentUri() on a "" + ""periodic job"");
        }
    }
    if (mIsPersisted) {
        if (mTriggerContentUris != null) {
            throw new IllegalArgumentException(""Can't call addTriggerContentUri() on a "" + ""persisted job"");
        }
        if (!mTransientExtras.isEmpty()) {
            throw new IllegalArgumentException(""Can't call setTransientExtras() on a "" + ""persisted job"");
        }
        if (mClipData != null) {
            throw new IllegalArgumentException(""Can't call setClipData() on a "" + ""persisted job"");
        }
    }
    if ((mFlags & FLAG_IMPORTANT_WHILE_FOREGROUND) != 0 && mHasEarlyConstraint) {
        throw new IllegalArgumentException(""An important while foreground job cannot "" + ""have a time delay"");
    }
    if (mBackoffPolicySet && (mConstraintFlags & CONSTRAINT_FLAG_DEVICE_IDLE) != 0) {
        throw new IllegalArgumentException(""An idle mode job will not respect any"" + "" back-off policy, so calling setBackoffCriteria with"" + "" setRequiresDeviceIdle is an error."");
    }
    return new JobInfo(this);
}",1,"/**
 * @return The job object to hand to the JobScheduler. This object is immutable.
 */
","/**
 * @return The job object to hand to the JobScheduler. This object is immutable.
 */
",-1,,,-1,-1,-1,-1,-1,-1,,,,
587,<android.hardware.camera2.impl.CameraDeviceImpl.CameraDeviceCallbacks: void onDeviceIdle()>,27,28,<android.hardware.camera2.impl.CameraDeviceImpl.CameraDeviceCallbacks: void onDeviceIdle()>,<android.hardware.camera2.impl.CameraDeviceImpl.CameraDeviceCallbacks: void onDeviceIdle()>,0,"{
    if (DEBUG) {
        Log.d(TAG, ""Camera now idle"");
    }
    synchronized (mInterfaceLock) {
        // Camera already closed
        if (mRemoteDevice == null)
            return;
        if (!CameraDeviceImpl.this.mIdle) {
            CameraDeviceImpl.this.mDeviceHandler.post(mCallOnIdle);
        }
        CameraDeviceImpl.this.mIdle = true;
    }
}","{
    if (DEBUG) {
        Log.d(TAG, ""Camera now idle"");
    }
    synchronized (mInterfaceLock) {
        // Camera already closed
        if (mRemoteDevice == null)
            return;
        if (!CameraDeviceImpl.this.mIdle) {
            final long ident = Binder.clearCallingIdentity();
            try {
                CameraDeviceImpl.this.mDeviceExecutor.execute(mCallOnIdle);
            } finally {
                Binder.restoreCallingIdentity(ident);
            }
        }
        CameraDeviceImpl.this.mIdle = true;
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,5",0,"The method used to post the callback has changed from using a Handler (mDeviceHandler.post(mCallOnIdle)) to an Executor (mDeviceExecutor.execute(mCallOnIdle)). Additionally, a new security context management block has been introduced for the callback execution, involving Binder.clearCallingIdentity() and Binder.restoreCallingIdentity(). Hence, the code change type is 3 for the control flow change and 5 for the dependent API change.","As the change does not alter what values are returned by the method nor the exceptions that are thrown (the method has no return value and the exception handling hasn't changed), there is no compatibility issue with respect to return values or exceptions. The internal behavior of the callback execution has been modified to now run in a potentially different thread context, but this does not constitute a compatibility issue as defined here. Hence, the CI type is 0."
588,<android.bluetooth.BluetoothAdapter: int getProfileConnectionState(int)>,27,28,<android.bluetooth.BluetoothAdapter: int getProfileConnectionState(int)>,<android.bluetooth.BluetoothAdapter: int getProfileConnectionState(int)>,0,"{
    if (getState() != STATE_ON)
        return BluetoothProfile.STATE_DISCONNECTED;
    try {
        mServiceLock.readLock().lock();
        if (mService != null)
            return mService.getProfileConnectionState(profile);
    } catch (RemoteException e) {
        Log.e(TAG, ""getProfileConnectionState:"", e);
    } finally {
        mServiceLock.readLock().unlock();
    }
    return BluetoothProfile.STATE_DISCONNECTED;
}","{
    if (getState() != STATE_ON) {
        return BluetoothProfile.STATE_DISCONNECTED;
    }
    try {
        mServiceLock.readLock().lock();
        if (mService != null) {
            return mService.getProfileConnectionState(profile);
        }
    } catch (RemoteException e) {
        Log.e(TAG, ""getProfileConnectionState:"", e);
    } finally {
        mServiceLock.readLock().unlock();
    }
    return BluetoothProfile.STATE_DISCONNECTED;
}",1,"/**
 * Get the current connection state of a profile.
 * This function can be used to check whether the local Bluetooth adapter
 * is connected to any remote device for a specific profile.
 * Profile can be one of {@link BluetoothProfile#HEALTH}, {@link BluetoothProfile#HEADSET},
 * {@link BluetoothProfile#A2DP}.
 *
 * <p> Return value can be one of
 * {@link BluetoothProfile#STATE_DISCONNECTED},
 * {@link BluetoothProfile#STATE_CONNECTING},
 * {@link BluetoothProfile#STATE_CONNECTED},
 * {@link BluetoothProfile#STATE_DISCONNECTING}
 */
","/**
 * Get the current connection state of a profile.
 * This function can be used to check whether the local Bluetooth adapter
 * is connected to any remote device for a specific profile.
 * Profile can be one of {@link BluetoothProfile#HEALTH}, {@link BluetoothProfile#HEADSET},
 * {@link BluetoothProfile#A2DP}.
 *
 * <p> Return value can be one of
 * {@link BluetoothProfile#STATE_DISCONNECTED},
 * {@link BluetoothProfile#STATE_CONNECTING},
 * {@link BluetoothProfile#STATE_CONNECTED},
 * {@link BluetoothProfile#STATE_DISCONNECTING}
 */
",-1,[@RequiresPermission(Manifest.permission.BLUETOOTH)],[@RequiresPermission(Manifest.permission.BLUETOOTH)],-1,-1,-1,-1,-1,-1,0,0,"The implementation between the early and the late version of the API has not changed, only the formatting has been adjusted (the addition of braces around if and for statements), which does not alter the behavior of the API.","Since there is no change in the functionality or flow of the code and no statements have been added, removed, or modified that would affect the output, there is no Compatibility Issue."
589,<android.util.AtomicFile: FileOutputStream startWrite()>,27,28,<android.util.AtomicFile: FileOutputStream startWrite()>,<android.util.AtomicFile: FileOutputStream startWrite()>,0,"{
    // Rename the current file so it may be used as a backup during the next read
    if (mBaseName.exists()) {
        if (!mBackupName.exists()) {
            if (!mBaseName.renameTo(mBackupName)) {
                Log.w(""AtomicFile"", ""Couldn't rename file "" + mBaseName + "" to backup file "" + mBackupName);
            }
        } else {
            mBaseName.delete();
        }
    }
    FileOutputStream str = null;
    try {
        str = new FileOutputStream(mBaseName);
    } catch (FileNotFoundException e) {
        File parent = mBaseName.getParentFile();
        if (!parent.mkdirs()) {
            throw new IOException(""Couldn't create directory "" + mBaseName);
        }
        FileUtils.setPermissions(parent.getPath(), FileUtils.S_IRWXU | FileUtils.S_IRWXG | FileUtils.S_IXOTH, -1, -1);
        try {
            str = new FileOutputStream(mBaseName);
        } catch (FileNotFoundException e2) {
            throw new IOException(""Couldn't create "" + mBaseName);
        }
    }
    return str;
}","{
    return startWrite(mCommitTag != null ? SystemClock.uptimeMillis() : 0);
}",1,"/**
 * Start a new write operation on the file.  This returns a FileOutputStream
 * to which you can write the new file data.  The existing file is replaced
 * with the new data.  You <em>must not</em> directly close the given
 * FileOutputStream; instead call either {@link #finishWrite(FileOutputStream)}
 * or {@link #failWrite(FileOutputStream)}.
 *
 * <p>Note that if another thread is currently performing
 * a write, this will simply replace whatever that thread is writing
 * with the new file being written by this thread, and when the other
 * thread finishes the write the new write operation will no longer be
 * safe (or will be lost).  You must do your own threading protection for
 * access to AtomicFile.
 */
","/**
 * Start a new write operation on the file.  This returns a FileOutputStream
 * to which you can write the new file data.  The existing file is replaced
 * with the new data.  You <em>must not</em> directly close the given
 * FileOutputStream; instead call either {@link #finishWrite(FileOutputStream)}
 * or {@link #failWrite(FileOutputStream)}.
 *
 * <p>Note that if another thread is currently performing
 * a write, this will simply replace whatever that thread is writing
 * with the new file being written by this thread, and when the other
 * thread finishes the write the new write operation will no longer be
 * safe (or will be lost).  You must do your own threading protection for
 * access to AtomicFile.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The method's implementation has changed completely from a block of code performing file operations to a single statement calling startWrite(long) with a conditional expression. This is considered a dependent API change (5) since the method now relies on a different method (startWrite(long)), which represents an alteration in the API it depends on, and also a return statement change (1), because the way the FileOutputStream is created has been modified.","There is a potential Compatibility Issue by returning different values or types in the later version because the method now delegates the file write initiation to startWrite(long) which might have a different implementation considering the condition provided as a parameter, so the CI type is 1."
590,"<android.view.Choreographer: void doFrame(long,int)>",27,28,"<android.view.Choreographer: void doFrame(long,int)>","<android.view.Choreographer: void doFrame(long,int)>",0,"{
    final long startNanos;
    synchronized (mLock) {
        if (!mFrameScheduled) {
            // no work to do
            return;
        }
        if (DEBUG_JANK && mDebugPrintNextFrameTimeDelta) {
            mDebugPrintNextFrameTimeDelta = false;
            Log.d(TAG, ""Frame time delta: "" + ((frameTimeNanos - mLastFrameTimeNanos) * 0.000001f) + "" ms"");
        }
        long intendedFrameTimeNanos = frameTimeNanos;
        startNanos = System.nanoTime();
        final long jitterNanos = startNanos - frameTimeNanos;
        if (jitterNanos >= mFrameIntervalNanos) {
            final long skippedFrames = jitterNanos / mFrameIntervalNanos;
            if (skippedFrames >= SKIPPED_FRAME_WARNING_LIMIT) {
                Log.i(TAG, ""Skipped "" + skippedFrames + "" frames!  "" + ""The application may be doing too much work on its main thread."");
            }
            final long lastFrameOffset = jitterNanos % mFrameIntervalNanos;
            if (DEBUG_JANK) {
                Log.d(TAG, ""Missed vsync by "" + (jitterNanos * 0.000001f) + "" ms "" + ""which is more than the frame interval of "" + (mFrameIntervalNanos * 0.000001f) + "" ms!  "" + ""Skipping "" + skippedFrames + "" frames and setting frame "" + ""time to "" + (lastFrameOffset * 0.000001f) + "" ms in the past."");
            }
            frameTimeNanos = startNanos - lastFrameOffset;
        }
        if (frameTimeNanos < mLastFrameTimeNanos) {
            if (DEBUG_JANK) {
                Log.d(TAG, ""Frame time appears to be going backwards.  May be due to a "" + ""previously skipped frame.  Waiting for next vsync."");
            }
            scheduleVsyncLocked();
            return;
        }
        mFrameInfo.setVsync(intendedFrameTimeNanos, frameTimeNanos);
        mFrameScheduled = false;
        mLastFrameTimeNanos = frameTimeNanos;
    }
    try {
        Trace.traceBegin(Trace.TRACE_TAG_VIEW, ""Choreographer#doFrame"");
        AnimationUtils.lockAnimationClock(frameTimeNanos / TimeUtils.NANOS_PER_MS);
        mFrameInfo.markInputHandlingStart();
        doCallbacks(Choreographer.CALLBACK_INPUT, frameTimeNanos);
        mFrameInfo.markAnimationsStart();
        doCallbacks(Choreographer.CALLBACK_ANIMATION, frameTimeNanos);
        mFrameInfo.markPerformTraversalsStart();
        doCallbacks(Choreographer.CALLBACK_TRAVERSAL, frameTimeNanos);
        doCallbacks(Choreographer.CALLBACK_COMMIT, frameTimeNanos);
    } finally {
        AnimationUtils.unlockAnimationClock();
        Trace.traceEnd(Trace.TRACE_TAG_VIEW);
    }
    if (DEBUG_FRAMES) {
        final long endNanos = System.nanoTime();
        Log.d(TAG, ""Frame "" + frame + "": Finished, took "" + (endNanos - startNanos) * 0.000001f + "" ms, latency "" + (startNanos - frameTimeNanos) * 0.000001f + "" ms."");
    }
}","{
    final long startNanos;
    synchronized (mLock) {
        if (!mFrameScheduled) {
            // no work to do
            return;
        }
        if (DEBUG_JANK && mDebugPrintNextFrameTimeDelta) {
            mDebugPrintNextFrameTimeDelta = false;
            Log.d(TAG, ""Frame time delta: "" + ((frameTimeNanos - mLastFrameTimeNanos) * 0.000001f) + "" ms"");
        }
        long intendedFrameTimeNanos = frameTimeNanos;
        startNanos = System.nanoTime();
        final long jitterNanos = startNanos - frameTimeNanos;
        if (jitterNanos >= mFrameIntervalNanos) {
            final long skippedFrames = jitterNanos / mFrameIntervalNanos;
            if (skippedFrames >= SKIPPED_FRAME_WARNING_LIMIT) {
                Log.i(TAG, ""Skipped "" + skippedFrames + "" frames!  "" + ""The application may be doing too much work on its main thread."");
            }
            final long lastFrameOffset = jitterNanos % mFrameIntervalNanos;
            if (DEBUG_JANK) {
                Log.d(TAG, ""Missed vsync by "" + (jitterNanos * 0.000001f) + "" ms "" + ""which is more than the frame interval of "" + (mFrameIntervalNanos * 0.000001f) + "" ms!  "" + ""Skipping "" + skippedFrames + "" frames and setting frame "" + ""time to "" + (lastFrameOffset * 0.000001f) + "" ms in the past."");
            }
            frameTimeNanos = startNanos - lastFrameOffset;
        }
        if (frameTimeNanos < mLastFrameTimeNanos) {
            if (DEBUG_JANK) {
                Log.d(TAG, ""Frame time appears to be going backwards.  May be due to a "" + ""previously skipped frame.  Waiting for next vsync."");
            }
            scheduleVsyncLocked();
            return;
        }
        if (mFPSDivisor > 1) {
            long timeSinceVsync = frameTimeNanos - mLastFrameTimeNanos;
            if (timeSinceVsync < (mFrameIntervalNanos * mFPSDivisor) && timeSinceVsync > 0) {
                scheduleVsyncLocked();
                return;
            }
        }
        mFrameInfo.setVsync(intendedFrameTimeNanos, frameTimeNanos);
        mFrameScheduled = false;
        mLastFrameTimeNanos = frameTimeNanos;
    }
    try {
        Trace.traceBegin(Trace.TRACE_TAG_VIEW, ""Choreographer#doFrame"");
        AnimationUtils.lockAnimationClock(frameTimeNanos / TimeUtils.NANOS_PER_MS);
        mFrameInfo.markInputHandlingStart();
        doCallbacks(Choreographer.CALLBACK_INPUT, frameTimeNanos);
        mFrameInfo.markAnimationsStart();
        doCallbacks(Choreographer.CALLBACK_ANIMATION, frameTimeNanos);
        mFrameInfo.markPerformTraversalsStart();
        doCallbacks(Choreographer.CALLBACK_TRAVERSAL, frameTimeNanos);
        doCallbacks(Choreographer.CALLBACK_COMMIT, frameTimeNanos);
    } finally {
        AnimationUtils.unlockAnimationClock();
        Trace.traceEnd(Trace.TRACE_TAG_VIEW);
    }
    if (DEBUG_FRAMES) {
        final long endNanos = System.nanoTime();
        Log.d(TAG, ""Frame "" + frame + "": Finished, took "" + (endNanos - startNanos) * 0.000001f + "" ms, latency "" + (startNanos - frameTimeNanos) * 0.000001f + "" ms."");
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,,,,
592,"<android.app.usage.NetworkStatsManager: NetworkStats queryDetails(int,String,long,long)>",27,28,"<android.app.usage.NetworkStatsManager: NetworkStats queryDetails(int,String,long,long)>","<android.app.usage.NetworkStatsManager: NetworkStats queryDetails(int,String,long,long)>",0,"{
    NetworkTemplate template;
    try {
        template = createTemplate(networkType, subscriberId);
    } catch (IllegalArgumentException e) {
        if (DBG)
            Log.e(TAG, ""Cannot create template"", e);
        return null;
    }
    NetworkStats result;
    result = new NetworkStats(mContext, template, mFlags, startTime, endTime);
    result.startUserUidEnumeration();
    return result;
}","{
    NetworkTemplate template;
    try {
        template = createTemplate(networkType, subscriberId);
    } catch (IllegalArgumentException e) {
        if (DBG)
            Log.e(TAG, ""Cannot create template"", e);
        return null;
    }
    NetworkStats result;
    result = new NetworkStats(mContext, template, mFlags, startTime, endTime, mService);
    result.startUserUidEnumeration();
    return result;
}",1,"/**
 * Query network usage statistics details. Result filtered to include only uids belonging to
 * calling user. Result is aggregated over state but not aggregated over time, uid, tag,
 * metered, nor roaming. This means buckets' start and end timestamps are going to be between
 * 'startTime' and 'endTime' parameters. State is going to be
 * {@link NetworkStats.Bucket#STATE_ALL}, uid will vary,
 * tag {@link NetworkStats.Bucket#TAG_NONE}, metered is going to be
 * {@link NetworkStats.Bucket#METERED_ALL}, and roaming is going to be
 * {@link NetworkStats.Bucket#ROAMING_ALL}.
 * <p>Only includes buckets that atomically occur in the inclusive time range. Doesn't
 * interpolate across partial buckets. Since bucket length is in the order of hours, this
 * method cannot be used to measure data usage on a fine grained time scale.
 *
 * @param networkType As defined in {@link ConnectivityManager}, e.g.
 * {@link ConnectivityManager#TYPE_MOBILE}, {@link ConnectivityManager#TYPE_WIFI}
 * etc.
 * @param subscriberId If applicable, the subscriber id of the network interface.
 * @param startTime Start of period. Defined in terms of ""Unix time"", see
 * {@link java.lang.System#currentTimeMillis}.
 * @param endTime End of period. Defined in terms of ""Unix time"", see
 * {@link java.lang.System#currentTimeMillis}.
 * @return Statistics object or null if permissions are insufficient or error happened during
 * statistics collection.
 */
","/**
 * Query network usage statistics details. Result filtered to include only uids belonging to
 * calling user. Result is aggregated over state but not aggregated over time, uid, tag,
 * metered, nor roaming. This means buckets' start and end timestamps are going to be between
 * 'startTime' and 'endTime' parameters. State is going to be
 * {@link NetworkStats.Bucket#STATE_ALL}, uid will vary,
 * tag {@link NetworkStats.Bucket#TAG_NONE},
 * default network is going to be {@link NetworkStats.Bucket#DEFAULT_NETWORK_ALL},
 * metered is going to be {@link NetworkStats.Bucket#METERED_ALL},
 * and roaming is going to be {@link NetworkStats.Bucket#ROAMING_ALL}.
 * <p>Only includes buckets that atomically occur in the inclusive time range. Doesn't
 * interpolate across partial buckets. Since bucket length is in the order of hours, this
 * method cannot be used to measure data usage on a fine grained time scale.
 *
 * @param networkType As defined in {@link ConnectivityManager}, e.g.
 * {@link ConnectivityManager#TYPE_MOBILE}, {@link ConnectivityManager#TYPE_WIFI}
 * etc.
 * @param subscriberId If applicable, the subscriber id of the network interface.
 * @param startTime Start of period. Defined in terms of ""Unix time"", see
 * {@link java.lang.System#currentTimeMillis}.
 * @param endTime End of period. Defined in terms of ""Unix time"", see
 * {@link java.lang.System#currentTimeMillis}.
 * @return Statistics object or null if permissions are insufficient or error happened during
 * statistics collection.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",1,"The constructor call for `NetworkStats` has been changed to include an additional parameter `mService` which indicates that the dependent API `NetworkStats` constructor has changed, resulting in change type 4 and 5 since it's a change in the API the method depends on.","The addition of a new parameter to the constructor call could lead to different behavior of the `NetworkStats` object being returned, hence this is a compatibility issue type 1 due to potential differences in the returned value."
594,<android.text.style.BulletSpan: int getLeadingMargin(boolean)>,27,28,<android.text.style.BulletSpan: int getLeadingMargin(boolean)>,<android.text.style.BulletSpan: int getLeadingMargin(boolean)>,0,"{
    return 2 * BULLET_RADIUS + mGapWidth;
}","{
    return 2 * mBulletRadius + mGapWidth;
}",1,,,-1,,[@Override],-1,-1,-1,-1,-1,-1,"1,4",1,"The implementation has changed from using a constant BULLET_RADIUS to using a variable mBulletRadius, this can change the behavior of the method because the value of mBulletRadius may be different from the constant BULLET_RADIUS. Additionally, this change in the variable reference is classified as 'Other statement changed', so the code change type is 1,4.","Because the value of the radius used for the calculation has changed, it's possible for this method to return a different value, there could be a Compatibility Issue caused by potential different return values. Hence, the CI type is 1."
595,<android.app.SharedPreferencesImpl.EditorImpl: Editor remove(String)>,27,28,<android.app.SharedPreferencesImpl.EditorImpl: Editor remove(String)>,<android.app.SharedPreferencesImpl.EditorImpl: Editor remove(String)>,0,"{
    synchronized (mLock) {
        mModified.put(key, this);
        return this;
    }
}","{
    synchronized (mEditorLock) {
        mModified.put(key, this);
        return this;
    }
}",1,,,-1,,[@Override],-1,-1,-1,-1,-1,-1,4,0,"The only change is the lock object used in the synchronized block, from mLock to mEditorLock, so the change type is 4.","This change is purely internal synchronization detail and doesn't affect the external behavior or the API's inputs/outputs. Therefore, this change will not lead to a Compatibility Issue, hence the CI type is 0."
596,<android.os.StrictMode.AndroidBlockGuardPolicy: void onUnbufferedIO()>,27,28,<android.os.StrictMode.AndroidBlockGuardPolicy: void onUnbufferedIO()>,<android.os.StrictMode.AndroidBlockGuardPolicy: void onUnbufferedIO()>,0,"{
    if ((mPolicyMask & DETECT_UNBUFFERED_IO) == 0) {
        return;
    }
    if (tooManyViolationsThisLoop()) {
        return;
    }
    BlockGuard.BlockGuardPolicyException e = new StrictModeUnbufferedIOViolation(mPolicyMask);
    e.fillInStackTrace();
    startHandlingViolationException(e);
}","{
    if ((mPolicyMask & DETECT_UNBUFFERED_IO) == 0) {
        return;
    }
    if (tooManyViolationsThisLoop()) {
        return;
    }
    startHandlingViolationException(new UnbufferedIoViolation());
}",1,"// Part of BlockGuard.Policy; just part of StrictMode:
","// Not part of BlockGuard.Policy; just part of StrictMode:
",-1,,,-1,-1,-1,-1,-1,-1,"1,4",2,"There are changes in the Other statement category, such as removal of the instantiation and filling of the stack trace for the `BlockGuard.BlockGuardPolicyException` object and a change in the object type that is passed to `startHandlingViolationException` method (from `StrictModeUnbufferedIOViolation` to `UnbufferedIoViolation`). Therefore, the code change types are 1,4.","The thrown exception type from the method `onUnbufferedIO` has changed, which means a different exception may be thrown or propagated up the call stack. Because of this, API consumers that rely on catching specific exception types might encounter issues. Thus, the CI type is 2."
597,<android.text.format.DateFormat: DateFormat getLongDateFormat(Context)>,27,28,<android.text.format.DateFormat: DateFormat getLongDateFormat(Context)>,<android.text.format.DateFormat: DateFormat getLongDateFormat(Context)>,0,"{
    return java.text.DateFormat.getDateInstance(java.text.DateFormat.LONG);
}","{
    final Locale locale = context.getResources().getConfiguration().locale;
    return java.text.DateFormat.getDateInstance(java.text.DateFormat.LONG, locale);
}",1,"/**
 * Returns a {@link java.text.DateFormat} object that can format the date
 * in long form (such as {@code Monday, January 3, 2000}) for the current locale.
 * @param context the application context
 * @return the {@link java.text.DateFormat} object that formats the date in long form.
 */
","/**
 * Returns a {@link java.text.DateFormat} object that can format the date
 * in long form (such as {@code Monday, January 3, 2000}) for the context's locale.
 * @param context the application context
 * @return the {@link java.text.DateFormat} object that formats the date in long form.
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,1,"The implementation of the method has changed to now include a locale parameter when calling getDateInstance, so the dependent API java.text.DateFormat.getDateInstance has changed, making this a code change type of 5.","The change involves a different method overload of getDateInstance being called, one that takes the locale into account. This would definitely return a different DateFormat object based on the locale, and hence there is the potential for different behavior in terms of return value. Therefore, the CI type is 1."
599,<android.util.proto.ProtoOutputStream: long start(long)>,27,28,<android.util.proto.ProtoOutputStream: long start(long)>,<android.util.proto.ProtoOutputStream: long start(long)>,0,"{
    assertNotCompacted();
    final int id = (int) fieldId;
    if ((fieldId & FIELD_TYPE_MASK) == FIELD_TYPE_OBJECT) {
        final long count = fieldId & FIELD_COUNT_MASK;
        if (count == FIELD_COUNT_SINGLE) {
            return startObjectImpl(id, false);
        } else if (count == FIELD_COUNT_REPEATED || count == FIELD_COUNT_PACKED) {
            return startObjectImpl(id, true);
        }
    }
    throw new IllegalArgumentException(""Attempt to call start(long) with "" + getFieldIdString(fieldId));
}","{
    assertNotCompacted();
    final int id = (int) fieldId;
    if ((fieldId & FIELD_TYPE_MASK) == FIELD_TYPE_MESSAGE) {
        final long count = fieldId & FIELD_COUNT_MASK;
        if (count == FIELD_COUNT_SINGLE) {
            return startObjectImpl(id, false);
        } else if (count == FIELD_COUNT_REPEATED || count == FIELD_COUNT_PACKED) {
            return startObjectImpl(id, true);
        }
    }
    throw new IllegalArgumentException(""Attempt to call start(long) with "" + getFieldIdString(fieldId));
}",1,"/**
 * Start a sub object.
 */
","/**
 * Start a sub object.
 */
",-1,,,-1,-1,-1,-1,-1,-1,3,0,"The only code change is the value checked against FIELD_TYPE_MASK from FIELD_TYPE_OBJECT to FIELD_TYPE_MESSAGE. Since the fieldId is being checked for a different condition, this change is classified as 3 (Control dependency changed).","There is no Compatibility Issue detected as the overall structure and behavior of the method remain consistent. The condition checks for a different constant, but this would not change the behavior from a caller's perspective assuming the constants are used appropriately. Therefore, the change does not lead to a CI (0), because it is expected that the input fieldId should contain the correct type (FIELD_TYPE_MESSAGE instead of FIELD_TYPE_OBJECT) for this version of the API."
600,<android.hardware.fingerprint.FingerprintManager.CryptoObject: Mac getMac()>,27,28,<android.hardware.fingerprint.FingerprintManager.CryptoObject: Mac getMac()>,<android.hardware.fingerprint.FingerprintManager.CryptoObject: Mac getMac()>,0,"{
    return mCrypto instanceof Mac ? (Mac) mCrypto : null;
}","{
    return super.getMac();
}",1,"/**
 * Get {@link Mac} object.
 * @return {@link Mac} object or null if this doesn't contain one.
 */
","/**
 * Get {@link Mac} object.
 * @return {@link Mac} object or null if this doesn't contain one.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The implementation has changed from an inline conditional check to a call to a superclass method, so the code change type is 1 and 5.","This change could potentially result in a different return value, as the superclass method 'super.getMac()' could have a different implementation or behavior than the inline conditional statement in the early version, thus the CI type is 1."
604,"<android.app.admin.DevicePolicyManager: UserHandle createAndManageUser(ComponentName,String,ComponentName,PersistableBundle,int)>",27,28,"<android.app.admin.DevicePolicyManager: UserHandle createAndManageUser(ComponentName,String,ComponentName,PersistableBundle,int)>","<android.app.admin.DevicePolicyManager: UserHandle createAndManageUser(ComponentName,String,ComponentName,PersistableBundle,int)>",0,"{
    throwIfParentInstance(""createAndManageUser"");
    try {
        return mService.createAndManageUser(admin, name, profileOwner, adminExtras, flags);
    } catch (RemoteException re) {
        throw re.rethrowFromSystemServer();
    }
}","{
    throwIfParentInstance(""createAndManageUser"");
    try {
        return mService.createAndManageUser(admin, name, profileOwner, adminExtras, flags);
    } catch (ServiceSpecificException e) {
        throw new UserOperationException(e.getMessage(), e.errorCode);
    } catch (RemoteException re) {
        throw re.rethrowFromSystemServer();
    }
}",1,"/**
 * Called by a device owner to create a user with the specified name and a given component of
 * the calling package as profile owner. The UserHandle returned by this method should not be
 * persisted as user handles are recycled as users are removed and created. If you need to
 * persist an identifier for this user, use {@link UserManager#getSerialNumberForUser}. The new
 * user will not be started in the background.
 * <p>
 * admin is the {@link DeviceAdminReceiver} which is the device owner. profileOwner is also a
 * DeviceAdminReceiver in the same package as admin, and will become the profile owner and will
 * be registered as an active admin on the new user. The profile owner package will be installed
 * on the new user.
 * <p>
 * If the adminExtras are not null, they will be stored on the device until the user is started
 * for the first time. Then the extras will be passed to the admin when onEnable is called.
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated with.
 * @param name The user's name.
 * @param profileOwner Which {@link DeviceAdminReceiver} will be profile owner. Has to be in the
 * same package as admin, otherwise no user is created and an
 * IllegalArgumentException is thrown.
 * @param adminExtras Extras that will be passed to onEnable of the admin receiver on the new
 * user.
 * @param flags {@link #SKIP_SETUP_WIZARD} is supported.
 * @see UserHandle
 * @return the {@link android.os.UserHandle} object for the created user, or {@code null} if the
 * user could not be created.
 * @throws SecurityException if {@code admin} is not a device owner.
 */
","/**
 * Called by a device owner to create a user with the specified name and a given component of
 * the calling package as profile owner. The UserHandle returned by this method should not be
 * persisted as user handles are recycled as users are removed and created. If you need to
 * persist an identifier for this user, use {@link UserManager#getSerialNumberForUser}. The new
 * user will not be started in the background.
 * <p>
 * admin is the {@link DeviceAdminReceiver} which is the device owner. profileOwner is also a
 * DeviceAdminReceiver in the same package as admin, and will become the profile owner and will
 * be registered as an active admin on the new user. The profile owner package will be installed
 * on the new user.
 * <p>
 * If the adminExtras are not null, they will be stored on the device until the user is started
 * for the first time. Then the extras will be passed to the admin when onEnable is called.
 * <p>From {@link android.os.Build.VERSION_CODES#P} onwards, if targeting
 * {@link android.os.Build.VERSION_CODES#P}, throws {@link UserOperationException} instead of
 * returning {@code null} on failure.
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated with.
 * @param name The user's name.
 * @param profileOwner Which {@link DeviceAdminReceiver} will be profile owner. Has to be in the
 * same package as admin, otherwise no user is created and an
 * IllegalArgumentException is thrown.
 * @param adminExtras Extras that will be passed to onEnable of the admin receiver on the new
 * user.
 * @param flags {@link #SKIP_SETUP_WIZARD}, {@link #MAKE_USER_EPHEMERAL} and
 * {@link #LEAVE_ALL_SYSTEM_APPS_ENABLED} are supported.
 * @see UserHandle
 * @return the {@link android.os.UserHandle} object for the created user, or {@code null} if the
 * user could not be created.
 * @throws SecurityException if {@code admin} is not a device owner.
 * @throws UserOperationException if the user could not be created and the calling app is
 * targeting {@link android.os.Build.VERSION_CODES#P} and running on
 * {@link android.os.Build.VERSION_CODES#P}.
 */
",-1,[@Nullable],[@Nullable],-1,-1,-1,-1,-1,-1,2,2,"The late version introduces a new catch block for 'ServiceSpecificException' with a different exception being thrown (new UserOperationException), so the code change type is 2.","Due the introduction of the new catch block for 'ServiceSpecificException', a different type of exception could be thrown, leading to a different exception handling behavior. This could potentially affect the behavior of the API call and create a Compatibility Issue of type 2."
606,<android.widget.Toast.TN: void handleHide()>,27,28,<android.widget.Toast.TN: void handleHide()>,<android.widget.Toast.TN: void handleHide()>,0,"{
    if (localLOGV)
        Log.v(TAG, ""HANDLE HIDE: "" + this + "" mView="" + mView);
    if (mView != null) {
        // the view isn't yet added, so let's try not to crash.
        if (mView.getParent() != null) {
            if (localLOGV)
                Log.v(TAG, ""REMOVE! "" + mView + "" in "" + this);
            mWM.removeViewImmediate(mView);
        }
        mView = null;
    }
}","{
    if (localLOGV)
        Log.v(TAG, ""HANDLE HIDE: "" + this + "" mView="" + mView);
    if (mView != null) {
        // the view isn't yet added, so let's try not to crash.
        if (mView.getParent() != null) {
            if (localLOGV)
                Log.v(TAG, ""REMOVE! "" + mView + "" in "" + this);
            mWM.removeViewImmediate(mView);
        }
        // the resources.
        try {
            getService().finishToken(mPackageName, this);
        } catch (RemoteException e) {
        }
        mView = null;
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,4,0,"A try-catch block is added that calls a new method getService().finishToken(mPackageName, this). No return statement nor exception handling statement has changed because the newly introduced exception is swallowed and does not change the control flow of the method or cause it to have a different behavior to external callers. Thus, the code change type is 4.","There's no Compatibility Issue because the additional code does not affect external behavior; it does not throw an exception outwardly due to catching the RemoteException internally, nor does it introduce a different return type or value. The new code runs silently and if it fails, it will not propagate that failure to the caller, resulting in the same external behavior. Hence, no Compatibility Issue arises from this change."
608,<android.service.autofill.SaveInfo.Builder: Builder setFlags(int)>,27,28,<android.service.autofill.SaveInfo.Builder: Builder setFlags(int)>,<android.service.autofill.SaveInfo.Builder: Builder setFlags(int)>,0,"{
    throwIfDestroyed();
    mFlags = Preconditions.checkFlagsArgument(flags, FLAG_SAVE_ON_ALL_VIEWS_INVISIBLE);
    return this;
}","{
    throwIfDestroyed();
    mFlags = Preconditions.checkFlagsArgument(flags, FLAG_SAVE_ON_ALL_VIEWS_INVISIBLE | FLAG_DONT_SAVE_ON_FINISH);
    return this;
}",1,"/**
 * Sets flags changing the save behavior.
 *
 * @param flags {@link #FLAG_SAVE_ON_ALL_VIEWS_INVISIBLE} or {@code 0}.
 * @return This builder.
 */
","/**
 * Sets flags changing the save behavior.
 *
 * @param flags {@link #FLAG_SAVE_ON_ALL_VIEWS_INVISIBLE},
 * {@link #FLAG_DONT_SAVE_ON_FINISH}, or {@code 0}.
 * @return This builder.
 */
",-1,[@NonNull],[@NonNull],-1,-1,-1,-1,-1,-1,4,0,"The only change in the code is the additional flag (FLAG_DONT_SAVE_ON_FINISH) included in the checkFlagsArgument method call. The method signature and its return type remain unchanged, so the code change type is 4.","Despite the change in the flags that are being checked, the public API contract, which is to set flags and return the Builder object itself, has not changed. Therefore, it does not lead to a different return value or exception being thrown. Hence, there is no Compatibility Issue, so the CI type is 0."
609,<android.hardware.camera2.impl.CameraDeviceImpl: void finalizeOutputConfigs(List<OutputConfiguration>)>,27,28,<android.hardware.camera2.impl.CameraDeviceImpl: void finalizeOutputConfigs(List<OutputConfiguration>)>,<android.hardware.camera2.impl.CameraDeviceImpl: void finalizeOutputConfigs(List<OutputConfiguration>)>,0,"{
    if (outputConfigs == null || outputConfigs.size() == 0) {
        throw new IllegalArgumentException(""deferred config is null or empty"");
    }
    synchronized (mInterfaceLock) {
        for (OutputConfiguration config : outputConfigs) {
            int streamId = -1;
            for (int i = 0; i < mConfiguredOutputs.size(); i++) {
                // createReprocessableCaptureSessionByConfigurations() do a copy of the configs.
                if (config.equals(mConfiguredOutputs.valueAt(i))) {
                    streamId = mConfiguredOutputs.keyAt(i);
                    break;
                }
            }
            if (streamId == -1) {
                throw new IllegalArgumentException(""Deferred config is not part of this "" + ""session"");
            }
            if (config.getSurfaces().size() == 0) {
                throw new IllegalArgumentException(""The final config for stream "" + streamId + "" must have at least 1 surface"");
            }
            mRemoteDevice.finalizeOutputConfigurations(streamId, config);
        }
    }
}","{
    if (outputConfigs == null || outputConfigs.size() == 0) {
        throw new IllegalArgumentException(""deferred config is null or empty"");
    }
    synchronized (mInterfaceLock) {
        for (OutputConfiguration config : outputConfigs) {
            int streamId = -1;
            for (int i = 0; i < mConfiguredOutputs.size(); i++) {
                // createReprocessableCaptureSessionByConfigurations() do a copy of the configs.
                if (config.equals(mConfiguredOutputs.valueAt(i))) {
                    streamId = mConfiguredOutputs.keyAt(i);
                    break;
                }
            }
            if (streamId == -1) {
                throw new IllegalArgumentException(""Deferred config is not part of this "" + ""session"");
            }
            if (config.getSurfaces().size() == 0) {
                throw new IllegalArgumentException(""The final config for stream "" + streamId + "" must have at least 1 surface"");
            }
            mRemoteDevice.finalizeOutputConfigurations(streamId, config);
            mConfiguredOutputs.put(streamId, config);
        }
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,4,0,"A new statement `mConfiguredOutputs.put(streamId, config);` is introduced. This is neither a return statement nor an exception handling statement change, and there is no control dependency change, so the code change type is 4.","As the statement added does not affect the return value or the exceptions that this method might throw, as it only affects the internal state of the `mConfiguredOutputs` without changing the API's external behavior, there is no Compatibility Issue, so the CI type is 0."
610,<android.os.WorkSource: int hashCode()>,27,28,<android.os.WorkSource: int hashCode()>,<android.os.WorkSource: int hashCode()>,0,"{
    int result = 0;
    for (int i = 0; i < mNum; i++) {
        result = ((result << 4) | (result >>> 28)) ^ mUids[i];
    }
    if (mNames != null) {
        for (int i = 0; i < mNum; i++) {
            result = ((result << 4) | (result >>> 28)) ^ mNames[i].hashCode();
        }
    }
    return result;
}","{
    int result = 0;
    for (int i = 0; i < mNum; i++) {
        result = ((result << 4) | (result >>> 28)) ^ mUids[i];
    }
    if (mNames != null) {
        for (int i = 0; i < mNum; i++) {
            result = ((result << 4) | (result >>> 28)) ^ mNames[i].hashCode();
        }
    }
    if (mChains != null) {
        result = ((result << 4) | (result >>> 28)) ^ mChains.hashCode();
    }
    return result;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,1,"A new if-statement block that checks and processes 'mNames' is added, resulting in an additional XOR operation in the hashCode calculation. This is an Other statement change, thus it is categorized under code change type 4.","The addition of the if-statement block with 'mChains.hashCode()' can potentially cause the API to return a different value as it alters the final hash computation. This constitutes a potential CI caused by different return values, classified under type 1."
611,"<android.hardware.camera2.impl.CameraDeviceImpl: void createConstrainedHighSpeedCaptureSession(List<Surface>,StateCallback,Handler)>",27,28,"<android.hardware.camera2.impl.CameraDeviceImpl: void createConstrainedHighSpeedCaptureSession(List<Surface>,StateCallback,Handler)>","<android.hardware.camera2.impl.CameraDeviceImpl: void createConstrainedHighSpeedCaptureSession(List<Surface>,StateCallback,Handler)>",0,"{
    if (outputs == null || outputs.size() == 0 || outputs.size() > 2) {
        throw new IllegalArgumentException(""Output surface list must not be null and the size must be no more than 2"");
    }
    StreamConfigurationMap config = getCharacteristics().get(CameraCharacteristics.SCALER_STREAM_CONFIGURATION_MAP);
    SurfaceUtils.checkConstrainedHighSpeedSurfaces(outputs, /*fpsRange*/
    null, config);
    List<OutputConfiguration> outConfigurations = new ArrayList<>(outputs.size());
    for (Surface surface : outputs) {
        outConfigurations.add(new OutputConfiguration(surface));
    }
    createCaptureSessionInternal(null, outConfigurations, callback, handler, /*operatingMode*/
    ICameraDeviceUser.CONSTRAINED_HIGH_SPEED_MODE);
}","{
    if (outputs == null || outputs.size() == 0 || outputs.size() > 2) {
        throw new IllegalArgumentException(""Output surface list must not be null and the size must be no more than 2"");
    }
    List<OutputConfiguration> outConfigurations = new ArrayList<>(outputs.size());
    for (Surface surface : outputs) {
        outConfigurations.add(new OutputConfiguration(surface));
    }
    createCaptureSessionInternal(null, outConfigurations, callback, checkAndWrapHandler(handler), /*operatingMode*/
    ICameraDeviceUser.CONSTRAINED_HIGH_SPEED_MODE, /*sessionParams*/
    null);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"4,5",0,"The call to SurfaceUtils.checkConstrainedHighSpeedSurfaces() method has been removed, and there is an additional parameter with a value of null at the end of the call to createCaptureSessionInternal(). Since checkAndWrapHandler(handler) should not generally change the behavior of 'handler', the main change comes from the removal of the previous method call and the added parameter. The code change type is 4,5.","Since the SurfaceUtils.checkConstrainedHighSpeedSurfaces() method checks the validity of the surfaces and it was only removed, the removal does not directly impact the return type or the value returned by the API, as there is no return value involved in the void method, and no new potential exceptions are thrown. It can potentially result in the method accepting inputs that it would have previously thrown exceptions for, but as this would only broaden the acceptable inputs and would not directly change the behavior of the API's outputs or exceptions, it should not be considered a compatibility issue in the context given, so the CI type is 0."
612,<android.service.autofill.FillResponse: String toString()>,27,28,<android.service.autofill.FillResponse: String toString()>,<android.service.autofill.FillResponse: String toString()>,0,"{
    if (!sDebug)
        return super.toString();
    // TODO: create a dump() method instead
    return new StringBuilder(""FillResponse : [mRequestId="" + mRequestId).append("", datasets="").append(mDatasets == null ? ""N/A"" : mDatasets.getList()).append("", saveInfo="").append(mSaveInfo).append("", clientState="").append(mClientState != null).append("", hasPresentation="").append(mPresentation != null).append("", hasAuthentication="").append(mAuthentication != null).append("", authenticationIds="").append(Arrays.toString(mAuthenticationIds)).append("", ignoredIds="").append(Arrays.toString(mIgnoredIds)).append(""]"").toString();
}","{
    if (!sDebug)
        return super.toString();
    // TODO: create a dump() method instead
    final StringBuilder builder = new StringBuilder(""FillResponse : [mRequestId="" + mRequestId);
    if (mDatasets != null) {
        builder.append("", datasets="").append(mDatasets.getList());
    }
    if (mSaveInfo != null) {
        builder.append("", saveInfo="").append(mSaveInfo);
    }
    if (mClientState != null) {
        builder.append("", hasClientState"");
    }
    if (mPresentation != null) {
        builder.append("", hasPresentation"");
    }
    if (mHeader != null) {
        builder.append("", hasHeader"");
    }
    if (mFooter != null) {
        builder.append("", hasFooter"");
    }
    if (mAuthentication != null) {
        builder.append("", hasAuthentication"");
    }
    if (mAuthenticationIds != null) {
        builder.append("", authenticationIds="").append(Arrays.toString(mAuthenticationIds));
    }
    builder.append("", disableDuration="").append(mDisableDuration);
    if (mFlags != 0) {
        builder.append("", flags="").append(mFlags);
    }
    if (mFieldClassificationIds != null) {
        builder.append(Arrays.toString(mFieldClassificationIds));
    }
    return builder.append(""]"").toString();
}",1,"// ///////////////////////////////////
","// ///////////////////////////////////
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,4",0,"The late version introduces additional checks with 'if' statements for appending parts of the string and includes new data (like mHeader, mFooter, mDisableDuration, mFlags, and mFieldClassificationIds) which did not exist in the early version. Furthermore, there's a change in how the string is built (using a StringBuilder in a slightly different way), so the change type is 3 for the control dependency change, and 4 for other statement changes.","While the implementation has changed, the method's behavior (returning a string representation of the object) remains consistent, and the contract of the `toString()` method allows for different outputs across invocations or versions as it is typically used for logging or debugging purposes. So, there's no compatibility issue since the method is still fulfilling its purpose by returning a string description of the object."
613,<android.print.PrintFileDocumentAdapter.WriteFileAsyncTask: Void doInBackground(Void)>,27,28,<android.print.PrintFileDocumentAdapter.WriteFileAsyncTask: Void doInBackground(Void)>,<android.print.PrintFileDocumentAdapter.WriteFileAsyncTask: Void doInBackground(Void)>,0,"{
    InputStream in = null;
    OutputStream out = new FileOutputStream(mDestination.getFileDescriptor());
    final byte[] buffer = new byte[8192];
    try {
        in = new FileInputStream(mFile);
        while (true) {
            if (isCancelled()) {
                break;
            }
            final int readByteCount = in.read(buffer);
            if (readByteCount < 0) {
                break;
            }
            out.write(buffer, 0, readByteCount);
        }
    } catch (IOException ioe) {
        Log.e(LOG_TAG, ""Error writing data!"", ioe);
        mResultCallback.onWriteFailed(mContext.getString(R.string.write_fail_reason_cannot_write));
    } finally {
        IoUtils.closeQuietly(in);
        IoUtils.closeQuietly(out);
    }
    return null;
}","{
    try (InputStream in = new FileInputStream(mFile);
        OutputStream out = new FileOutputStream(mDestination.getFileDescriptor())) {
        FileUtils.copy(in, out, null, mCancellationSignal);
    } catch (OperationCanceledException e) {
    // Ignored; already handled below
    } catch (IOException e) {
        Log.e(LOG_TAG, ""Error writing data!"", e);
        mResultCallback.onWriteFailed(mContext.getString(R.string.write_fail_reason_cannot_write));
    }
    return null;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,3,4,5",1,"The method implementation has changed significantly between the early and late versions. The original implementation manually copied data from an input stream to an output stream inside a loop, while the late implementation uses the FileUtils.copy utility method for this purpose. Additionally, the try-with-resources statement is introduced to handle stream closure, and the handling of `OperationCanceledException` has been added, which was not present in the early version. The dependent API has changed as well since the `FileUtils.copy` method is now being used. Hence, the changes involve return statements (though both return null, their preceding execution paths have changed), control dependency, other statements, and dependent API.","The change in implementation could potentially lead to a different behavior. The use of `FileUtils.copy` may result in different handling of the copying process compared to manually reading and writing bytes in a loop, and it may handle interruption (cancellation) differently; thus, the result of the 'doInBackground' method and the side effects (like writing data) may also change between versions. Additionally, there was no specific handling of `OperationCanceledException` in the early version, which indicates a change in exception handling behavior. Therefore, this can lead to potentially different return values/types and different exception handlings, causing a compatibility issue of type 1."
614,"<android.bluetooth.BluetoothGattServer: boolean connect(BluetoothDevice,boolean)>",27,28,"<android.bluetooth.BluetoothGattServer: boolean connect(BluetoothDevice,boolean)>","<android.bluetooth.BluetoothGattServer: boolean connect(BluetoothDevice,boolean)>",0,"{
    if (DBG)
        Log.d(TAG, ""connect() - device: "" + device.getAddress() + "", auto: "" + autoConnect);
    if (mService == null || mServerIf == 0)
        return false;
    try {
        mService.serverConnect(mServerIf, device.getAddress(), autoConnect ? false : true, // autoConnect is inverse of ""isDirect""
        mTransport);
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
        return false;
    }
    return true;
}","{
    if (DBG) {
        Log.d(TAG, ""connect() - device: "" + device.getAddress() + "", auto: "" + autoConnect);
    }
    if (mService == null || mServerIf == 0)
        return false;
    try {
        // autoConnect is inverse of ""isDirect""
        mService.serverConnect(mServerIf, device.getAddress(), !autoConnect, mTransport);
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
        return false;
    }
    return true;
}",1,"/**
 * Initiate a connection to a Bluetooth GATT capable device.
 *
 * <p>The connection may not be established right away, but will be
 * completed when the remote device is available. A
 * {@link BluetoothGattServerCallback#onConnectionStateChange} callback will be
 * invoked when the connection state changes as a result of this function.
 *
 * <p>The autoConnect paramter determines whether to actively connect to
 * the remote device, or rather passively scan and finalize the connection
 * when the remote device is in range/available. Generally, the first ever
 * connection to a device should be direct (autoConnect set to false) and
 * subsequent connections to known devices should be invoked with the
 * autoConnect parameter set to true.
 *
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH} permission.
 *
 * @param autoConnect Whether to directly connect to the remote device (false)
 * or to automatically connect as soon as the remote
 * device becomes available (true).
 * @return true, if the connection attempt was initiated successfully
 */
","/**
 * Initiate a connection to a Bluetooth GATT capable device.
 *
 * <p>The connection may not be established right away, but will be
 * completed when the remote device is available. A
 * {@link BluetoothGattServerCallback#onConnectionStateChange} callback will be
 * invoked when the connection state changes as a result of this function.
 *
 * <p>The autoConnect paramter determines whether to actively connect to
 * the remote device, or rather passively scan and finalize the connection
 * when the remote device is in range/available. Generally, the first ever
 * connection to a device should be direct (autoConnect set to false) and
 * subsequent connections to known devices should be invoked with the
 * autoConnect parameter set to true.
 *
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH} permission.
 *
 * @param autoConnect Whether to directly connect to the remote device (false) or to
 * automatically connect as soon as the remote device becomes available (true).
 * @return true, if the connection attempt was initiated successfully
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The only change in the code is the replacement of the ternary operation (autoConnect ? false : true) with its equivalent (!autoConnect). This is a simple syntactical change that doesn't affect the program's logic, so the code change type is 4 (Other statement changed).","There is no Compatibility Issue since there are no changes in functionality or behavior. The method's signature remains the same, the return values are the same, and the exception handling has not changed."
616,"<android.provider.Settings.Secure: boolean putInt(ContentResolver,String,int)>",27,28,"<android.provider.Settings.Secure: boolean putInt(ContentResolver,String,int)>","<android.provider.Settings.Secure: boolean putInt(ContentResolver,String,int)>",0,"{
    return putIntForUser(cr, name, value, UserHandle.myUserId());
}","{
    return putIntForUser(cr, name, value, cr.getUserId());
}",1,"/**
 * Convenience function for updating a single settings value as an
 * integer. This will either create a new entry in the table if the
 * given name does not exist, or modify the value of the existing row
 * with that name.  Note that internally setting values are always
 * stored as strings, so this function converts the given value to a
 * string before storing it.
 *
 * @param cr The ContentResolver to access.
 * @param name The name of the setting to modify.
 * @param value The new value for the setting.
 * @return true if the value was set, false on database errors
 */
","/**
 * Convenience function for updating a single settings value as an
 * integer. This will either create a new entry in the table if the
 * given name does not exist, or modify the value of the existing row
 * with that name.  Note that internally setting values are always
 * stored as strings, so this function converts the given value to a
 * string before storing it.
 *
 * @param cr The ContentResolver to access.
 * @param name The name of the setting to modify.
 * @param value The new value for the setting.
 * @return true if the value was set, false on database errors
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The method `putIntForUser` that this API depends on has not changed in its name, but the way it gets the user ID has changed from `UserHandle.myUserId()` to `cr.getUserId()`. This is a dependent API change, so the code change type is 5.","Although the method used to retrieve the user ID has changed, there is no indication that this would lead to a different behavior regarding return values or thrown exceptions by this API. Both methods are likely to return the ID of the current user. Hence, there is no compatibility issue; the CI type is 0."
617,<android.text.format.DateFormat: DateFormat getMediumDateFormat(Context)>,27,28,<android.text.format.DateFormat: DateFormat getMediumDateFormat(Context)>,<android.text.format.DateFormat: DateFormat getMediumDateFormat(Context)>,0,"{
    return java.text.DateFormat.getDateInstance(java.text.DateFormat.MEDIUM);
}","{
    final Locale locale = context.getResources().getConfiguration().locale;
    return java.text.DateFormat.getDateInstance(java.text.DateFormat.MEDIUM, locale);
}",1,"/**
 * Returns a {@link java.text.DateFormat} object that can format the date
 * in medium form (such as {@code Jan 3, 2000}) for the current locale.
 * @param context the application context
 * @return the {@link java.text.DateFormat} object that formats the date in long form.
 */
","/**
 * Returns a {@link java.text.DateFormat} object that can format the date
 * in medium form (such as {@code Jan 3, 2000}) for the context's locale.
 * @param context the application context
 * @return the {@link java.text.DateFormat} object that formats the date in long form.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The return statement has changed to include a new parameter 'locale' from the context resources configuration in the date instance creation, and a new local variable 'locale' has been introduced, so the code change type is 1,5.","The change of return statement by including a specific locale in the late version means that the date format returned may be different depending on the locale specified by the context, which can lead to different values. Thus, the CI type is 1."
618,<android.app.Notification.Builder: Notification build()>,27,28,<android.app.Notification.Builder: Notification build()>,<android.app.Notification.Builder: Notification build()>,0,"{
    // first, add any extras from the calling code
    if (mUserExtras != null) {
        mN.extras = getAllExtras();
    }
    mN.creationTime = System.currentTimeMillis();
    // lazy stuff from mContext; see comment in Builder(Context, Notification)
    Notification.addFieldsFromContext(mContext, mN);
    buildUnstyled();
    if (mStyle != null) {
        mStyle.reduceImageSizes(mContext);
        mStyle.purgeResources();
        mStyle.buildStyled(mN);
    }
    mN.reduceImageSizes(mContext);
    if (mContext.getApplicationInfo().targetSdkVersion < Build.VERSION_CODES.N && (useExistingRemoteView())) {
        if (mN.contentView == null) {
            mN.contentView = createContentView();
            mN.extras.putInt(EXTRA_REBUILD_CONTENT_VIEW_ACTION_COUNT, mN.contentView.getSequenceNumber());
        }
        if (mN.bigContentView == null) {
            mN.bigContentView = createBigContentView();
            if (mN.bigContentView != null) {
                mN.extras.putInt(EXTRA_REBUILD_BIG_CONTENT_VIEW_ACTION_COUNT, mN.bigContentView.getSequenceNumber());
            }
        }
        if (mN.headsUpContentView == null) {
            mN.headsUpContentView = createHeadsUpContentView();
            if (mN.headsUpContentView != null) {
                mN.extras.putInt(EXTRA_REBUILD_HEADS_UP_CONTENT_VIEW_ACTION_COUNT, mN.headsUpContentView.getSequenceNumber());
            }
        }
    }
    if ((mN.defaults & DEFAULT_LIGHTS) != 0) {
        mN.flags |= FLAG_SHOW_LIGHTS;
    }
    return mN;
}","{
    // first, add any extras from the calling code
    if (mUserExtras != null) {
        mN.extras = getAllExtras();
    }
    mN.creationTime = System.currentTimeMillis();
    // lazy stuff from mContext; see comment in Builder(Context, Notification)
    Notification.addFieldsFromContext(mContext, mN);
    buildUnstyled();
    if (mStyle != null) {
        mStyle.reduceImageSizes(mContext);
        mStyle.purgeResources();
        mStyle.validate(mContext);
        mStyle.buildStyled(mN);
    }
    mN.reduceImageSizes(mContext);
    if (mContext.getApplicationInfo().targetSdkVersion < Build.VERSION_CODES.N && (useExistingRemoteView())) {
        if (mN.contentView == null) {
            mN.contentView = createContentView();
            mN.extras.putInt(EXTRA_REBUILD_CONTENT_VIEW_ACTION_COUNT, mN.contentView.getSequenceNumber());
        }
        if (mN.bigContentView == null) {
            mN.bigContentView = createBigContentView();
            if (mN.bigContentView != null) {
                mN.extras.putInt(EXTRA_REBUILD_BIG_CONTENT_VIEW_ACTION_COUNT, mN.bigContentView.getSequenceNumber());
            }
        }
        if (mN.headsUpContentView == null) {
            mN.headsUpContentView = createHeadsUpContentView();
            if (mN.headsUpContentView != null) {
                mN.extras.putInt(EXTRA_REBUILD_HEADS_UP_CONTENT_VIEW_ACTION_COUNT, mN.headsUpContentView.getSequenceNumber());
            }
        }
    }
    if ((mN.defaults & DEFAULT_LIGHTS) != 0) {
        mN.flags |= FLAG_SHOW_LIGHTS;
    }
    mN.allPendingIntents = null;
    return mN;
}",1,"/**
 * Combine all of the options that have been set and return a new {@link Notification}
 * object.
 */
","/**
 * Combine all of the options that have been set and return a new {@link Notification}
 * object.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The line 'mStyle.validate(mContext);' is added, and 'mN.allPendingIntents = null;' is also added before the return statement. These are both not return statements, exception handling, control dependency changes, or dependent API changes, thus this is of code change type 4.","Both changes do not affect the return value or exception behavior. The method still returns 'mN' and the call to 'validate' on 'mStyle' does not seem to alter the execution flow in a way that changes what 'mN' would be. Setting 'mN.allPendingIntents' to null directly before returning 'mN' wouldn't introduce different return values in the usual case because 'allPendingIntents' is typically not part of the expected API contract and does not affect the outcome of the method. Therefore, there's no Compatibility Issue, which is indicated by 0."
619,<android.content.ContentResolver: List<UriPermission> getPersistedUriPermissions()>,27,28,<android.content.ContentResolver: List<UriPermission> getPersistedUriPermissions()>,<android.content.ContentResolver: List<UriPermission> getPersistedUriPermissions()>,0,"{
    try {
        return ActivityManager.getService().getPersistedUriPermissions(mPackageName, true).getList();
    } catch (RemoteException e) {
        throw new RuntimeException(""Activity manager has died"", e);
    }
}","{
    try {
        return ActivityManager.getService().getPersistedUriPermissions(mPackageName, true).getList();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Return list of all URI permission grants that have been persisted by the
 * calling app. That is, the returned permissions have been granted
 * <em>to</em> the calling app. Only persistable grants taken with
 * {@link #takePersistableUriPermission(Uri, int)} are returned.
 * <p>Note: Some of the returned URIs may not be usable until after the user is unlocked.
 *
 * @see #takePersistableUriPermission(Uri, int)
 * @see #releasePersistableUriPermission(Uri, int)
 */
","/**
 * Return list of all URI permission grants that have been persisted by the
 * calling app. That is, the returned permissions have been granted
 * <em>to</em> the calling app. Only persistable grants taken with
 * {@link #takePersistableUriPermission(Uri, int)} are returned.
 * <p>Note: Some of the returned URIs may not be usable until after the user is unlocked.
 *
 * @see #takePersistableUriPermission(Uri, int)
 * @see #releasePersistableUriPermission(Uri, int)
 */
",-1,[@NonNull],[@NonNull],-1,-1,-1,-1,-1,-1,2,2,"The method keeps the same return type and statement, but the exception handling has changed from throwing a new RuntimeException to throwing the same RemoteException after calling rethrowFromSystemServer(), so the change type is 2.","Since the type of exception thrown by the API has changed, it could lead to different exception handling on the caller side. Previously, the caller might catch a RuntimeException, but now it must catch RemoteException (or handle a crash if not caught). Thus, the CI type is 2."
620,"<android.content.pm.LauncherApps: List<ShortcutInfo> getShortcuts(ShortcutQuery,UserHandle)>",27,28,"<android.content.pm.LauncherApps: List<ShortcutInfo> getShortcuts(ShortcutQuery,UserHandle)>","<android.content.pm.LauncherApps: List<ShortcutInfo> getShortcuts(ShortcutQuery,UserHandle)>",0,"{
    logErrorForInvalidProfileAccess(user);
    try {
        return mService.getShortcuts(mContext.getPackageName(), query.mChangedSince, query.mPackage, query.mShortcutIds, query.mActivity, query.mQueryFlags, user).getList();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}","{
    logErrorForInvalidProfileAccess(user);
    try {
        // that won't return disabled message.
        return maybeUpdateDisabledMessage(mService.getShortcuts(mContext.getPackageName(), query.mChangedSince, query.mPackage, query.mShortcutIds, query.mActivity, query.mQueryFlags, user).getList());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Returns {@link ShortcutInfo}s that match {@code query}.
 *
 * <p>Callers must be allowed to access the shortcut information, as defined in {@link
 * #hasShortcutHostPermission()}.
 *
 * @param query result includes shortcuts matching this query.
 * @param user The UserHandle of the profile.
 *
 * @return the IDs of {@link ShortcutInfo}s that match the query.
 * @throws IllegalStateException when the user is locked, or when the {@code user} user
 * is locked or not running.
 *
 * @see ShortcutManager
 */
","/**
 * Returns {@link ShortcutInfo}s that match {@code query}.
 *
 * <p>Callers must be allowed to access the shortcut information, as defined in {@link
 * #hasShortcutHostPermission()}.
 *
 * @param query result includes shortcuts matching this query.
 * @param user The UserHandle of the profile.
 *
 * @return the IDs of {@link ShortcutInfo}s that match the query.
 * @throws IllegalStateException when the user is locked, or when the {@code user} user
 * is locked or not running.
 *
 * @see ShortcutManager
 */
",-1,[@Nullable],[@Nullable],-1,-1,-1,-1,-1,-1,"1,4",0,"The method implementation has changed with additional processing of the result using maybeUpdateDisabledMessage. This alters what is returned by the method, so the change types involved are 1 (Return statement changed) and 4 (Other statement changed).","There is no change in the behavior of throwing exceptions, and even though the return value may be modified by maybeUpdateDisabledMessage, as long as it stays within the permissible values (including being `null`, as suggested by the `@Nullable` annotation which is present in both versions), this modification doesn't necessarily lead to a Compatibility Issue. Thus, CI is classified as 0 (No Compatibility Issue)."
621,"<android.content.pm.LauncherApps: ApplicationInfo getApplicationInfo(String,int,UserHandle)>",27,28,"<android.content.pm.LauncherApps: ApplicationInfo getApplicationInfo(String,int,UserHandle)>","<android.content.pm.LauncherApps: ApplicationInfo getApplicationInfo(String,int,UserHandle)>",0,"{
    Preconditions.checkNotNull(packageName, ""packageName"");
    Preconditions.checkNotNull(packageName, ""user"");
    logErrorForInvalidProfileAccess(user);
    try {
        final ApplicationInfo ai = mService.getApplicationInfo(mContext.getPackageName(), packageName, flags, user);
        if (ai == null) {
            throw new NameNotFoundException(""Package "" + packageName + "" not found for user "" + user.getIdentifier());
        }
        return ai;
    } catch (RemoteException re) {
        throw re.rethrowFromSystemServer();
    }
}","{
    Preconditions.checkNotNull(packageName, ""packageName"");
    Preconditions.checkNotNull(user, ""user"");
    logErrorForInvalidProfileAccess(user);
    try {
        final ApplicationInfo ai = mService.getApplicationInfo(mContext.getPackageName(), packageName, flags, user);
        if (ai == null) {
            throw new NameNotFoundException(""Package "" + packageName + "" not found for user "" + user.getIdentifier());
        }
        return ai;
    } catch (RemoteException re) {
        throw re.rethrowFromSystemServer();
    }
}",1,"/**
 * Returns {@link ApplicationInfo} about an application installed for a specific user profile.
 *
 * @param packageName The package name of the application
 * @param flags Additional option flags {@link PackageManager#getApplicationInfo}
 * @param user The UserHandle of the profile.
 *
 * @return {@link ApplicationInfo} containing information about the package. Returns
 * {@code null} if the package isn't installed for the given profile, or the profile
 * isn't enabled.
 */
","/**
 * Returns {@link ApplicationInfo} about an application installed for a specific user profile.
 *
 * @param packageName The package name of the application
 * @param flags Additional option flags {@link PackageManager#getApplicationInfo}
 * @param user The UserHandle of the profile.
 *
 * @return {@link ApplicationInfo} containing information about the package. Returns
 * {@code null} if the package isn't installed for the given profile, or the profile
 * isn't enabled.
 */
",-1,,,-1,-1,-1,-1,-1,-1,0,0,"There is no change in the method body. The only change is correcting the checkNotNull parameter from ""packageName"" to ""user"" for the second Preconditions.checkNotNull call, which does not affect the API behavior.","Since there is no behavioral change in the API, there is no Compatibility Issue."
622,"<android.text.format.Formatter: String formatFileSize(Context,long)>",27,28,"<android.text.format.Formatter: String formatFileSize(Context,long)>","<android.text.format.Formatter: String formatFileSize(Context,long)>",0,"{
    return formatFileSize(context, sizeBytes, FLAG_DEFAULT);
}","{
    if (context == null) {
        return """";
    }
    final BytesResult res = formatBytes(context.getResources(), sizeBytes, FLAG_SI_UNITS);
    return bidiWrap(context, context.getString(com.android.internal.R.string.fileSizeSuffix, res.value, res.units));
}",1,"/**
 * Formats a content size to be in the form of bytes, kilobytes, megabytes, etc.
 *
 * <p>As of O, the prefixes are used in their standard meanings in the SI system, so kB = 1000
 * bytes, MB = 1,000,000 bytes, etc.</p>
 *
 * <p class=""note"">In {@link android.os.Build.VERSION_CODES#N} and earlier, powers of 1024 are
 * used instead, with KB = 1024 bytes, MB = 1,048,576 bytes, etc.</p>
 *
 * <p>If the context has a right-to-left locale, the returned string is wrapped in bidi
 * formatting characters to make sure it's displayed correctly if inserted inside a
 * right-to-left string. (This is useful in cases where the unit strings, like ""MB"", are
 * left-to-right, but the locale is right-to-left.)</p>
 *
 * @param context Context to use to load the localized units
 * @param sizeBytes size value to be formatted, in bytes
 * @return formatted string with the number
 */
","/**
 * Formats a content size to be in the form of bytes, kilobytes, megabytes, etc.
 *
 * <p>As of O, the prefixes are used in their standard meanings in the SI system, so kB = 1000
 * bytes, MB = 1,000,000 bytes, etc.</p>
 *
 * <p class=""note"">In {@link android.os.Build.VERSION_CODES#N} and earlier, powers of 1024 are
 * used instead, with KB = 1024 bytes, MB = 1,048,576 bytes, etc.</p>
 *
 * <p>If the context has a right-to-left locale, the returned string is wrapped in bidi
 * formatting characters to make sure it's displayed correctly if inserted inside a
 * right-to-left string. (This is useful in cases where the unit strings, like ""MB"", are
 * left-to-right, but the locale is right-to-left.)</p>
 *
 * @param context Context to use to load the localized units
 * @param sizeBytes size value to be formatted, in bytes
 * @return formatted string with the number
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The method now includes a new control flow to check if the context is null and the logic to calculate the file size is different, relying on a new method formatBytes and bidiWrap instead of formatFileSize with a different flag. Therefore, the changed types are 1 and 5 because the return statement has changed and the API relies on different dependent APIs.","The introduction of a null context check and a change in the methodology to calculate and format the file size means that the method potentially returns different values in the late version, causing a CI type 1."
623,<android.bluetooth.le.AdvertisingSet: void setPeriodicAdvertisingData(AdvertiseData)>,27,28,<android.bluetooth.le.AdvertisingSet: void setPeriodicAdvertisingData(AdvertiseData)>,<android.bluetooth.le.AdvertisingSet: void setPeriodicAdvertisingData(AdvertiseData)>,0,"{
    try {
        gatt.setPeriodicAdvertisingData(this.advertiserId, periodicData);
    } catch (RemoteException e) {
        Log.e(TAG, ""remote exception - "", e);
    }
}","{
    try {
        mGatt.setPeriodicAdvertisingData(mAdvertiserId, periodicData);
    } catch (RemoteException e) {
        Log.e(TAG, ""remote exception - "", e);
    }
}",1,"/**
 * Used to set periodic advertising data, must be called after setPeriodicAdvertisingParameters,
 * or after advertising was started with periodic advertising data set. This method returns
 * immediately, the operation status is delivered through
 * {@code callback.onPeriodicAdvertisingDataSet()}.
 *
 * @param periodicData Periodic advertising data. Size must not exceed
 * {@link BluetoothAdapter#getLeMaximumAdvertisingDataLength}. If the
 * update takes place when the periodic advertising is enabled for this set,
 * the data can be maximum 251 bytes long.
 */
","/**
 * Used to set periodic advertising data, must be called after setPeriodicAdvertisingParameters,
 * or after advertising was started with periodic advertising data set. This method returns
 * immediately, the operation status is delivered through
 * {@code callback.onPeriodicAdvertisingDataSet()}.
 *
 * @param periodicData Periodic advertising data. Size must not exceed {@link
 * BluetoothAdapter#getLeMaximumAdvertisingDataLength}. If the update takes place when the
 * periodic advertising is enabled for this set, the data can be maximum 251 bytes long.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,The fields were renamed from `gatt` to `mGatt` and from `advertiserId` to `mAdvertiserId`. The change type is 4 as these are mere naming changes and do not affect the behavior of the method.,There is no Compatibility Issue since the changes to the field names do not alter the execution flow or behavior of the method  it still attempts to call `setPeriodicAdvertisingData` and catches a `RemoteException` without changes in exception handling or returned results.
625,<android.service.notification.NotificationListenerService: StatusBarNotification[] getActiveNotifications()>,27,28,<android.service.notification.NotificationListenerService: StatusBarNotification[] getActiveNotifications()>,<android.service.notification.NotificationListenerService: StatusBarNotification[] getActiveNotifications()>,0,"{
    return getActiveNotifications(null, TRIM_FULL);
}","{
    StatusBarNotification[] activeNotifications = getActiveNotifications(null, TRIM_FULL);
    return activeNotifications != null ? activeNotifications : new StatusBarNotification[0];
}",1,"/**
 * Request the list of outstanding notifications (that is, those that are visible to the
 * current user). Useful when you don't know what's already been posted.
 *
 * <p>The service should wait for the {@link #onListenerConnected()} event
 * before performing this operation.
 *
 * @return An array of active notifications, sorted in natural order.
 */
","/**
 * Request the list of outstanding notifications (that is, those that are visible to the
 * current user). Useful when you don't know what's already been posted.
 *
 * <p>The service should wait for the {@link #onListenerConnected()} event
 * before performing this operation.
 *
 * @return An array of active notifications, sorted in natural order.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,4",1,"The addition of a null check and the conditional operator before returning the result in the late implementation means an 'Other statement changed' took place. If 'getActiveNotifications' returns null, the late implementation now returns an empty array instead of null. This constitutes a change in the return statement because the method now returns a non-null value instead of null when there are no active notifications, which corresponds to code change type 1 as well.","The late version introduces a new behavior such that if 'getActiveNotifications' returns null, instead of returning null, it returns a new empty array. This is a change in return type or value, and hence the CI type is 1, indicating that there might be a Compatibility Issue due to a potential different return value."
626,"<android.text.TextUtils: CharSequence listEllipsize(Context,List<CharSequence>,String,TextPaint,float,int)>",27,28,"<android.text.TextUtils: CharSequence listEllipsize(Context,List<CharSequence>,String,TextPaint,float,int)>","<android.text.TextUtils: CharSequence listEllipsize(Context,List<CharSequence>,String,TextPaint,float,int)>",0,"{
    if (elements == null) {
        return """";
    }
    final int totalLen = elements.size();
    if (totalLen == 0) {
        return """";
    }
    final Resources res;
    final BidiFormatter bidiFormatter;
    if (context == null) {
        res = null;
        bidiFormatter = BidiFormatter.getInstance();
    } else {
        res = context.getResources();
        bidiFormatter = BidiFormatter.getInstance(res.getConfiguration().getLocales().get(0));
    }
    final SpannableStringBuilder output = new SpannableStringBuilder();
    final int[] endIndexes = new int[totalLen];
    for (int i = 0; i < totalLen; i++) {
        output.append(bidiFormatter.unicodeWrap(elements.get(i)));
        if (i != totalLen - 1) {
            // Insert a separator, except at the very end.
            output.append(separator);
        }
        endIndexes[i] = output.length();
    }
    for (int i = totalLen - 1; i >= 0; i--) {
        // Delete the tail of the string, cutting back to one less element.
        output.delete(endIndexes[i], output.length());
        final int remainingElements = totalLen - i - 1;
        if (remainingElements > 0) {
            CharSequence morePiece = (res == null) ? ELLIPSIS_STRING : res.getQuantityString(moreId, remainingElements, remainingElements);
            morePiece = bidiFormatter.unicodeWrap(morePiece);
            output.append(morePiece);
        }
        final float width = paint.measureText(output, 0, output.length());
        if (width <= avail) {
            // The string fits.
            return output;
        }
    }
    // Nothing fits.
    return """";
}","{
    if (elements == null) {
        return """";
    }
    final int totalLen = elements.size();
    if (totalLen == 0) {
        return """";
    }
    final Resources res;
    final BidiFormatter bidiFormatter;
    if (context == null) {
        res = null;
        bidiFormatter = BidiFormatter.getInstance();
    } else {
        res = context.getResources();
        bidiFormatter = BidiFormatter.getInstance(res.getConfiguration().getLocales().get(0));
    }
    final SpannableStringBuilder output = new SpannableStringBuilder();
    final int[] endIndexes = new int[totalLen];
    for (int i = 0; i < totalLen; i++) {
        output.append(bidiFormatter.unicodeWrap(elements.get(i)));
        if (i != totalLen - 1) {
            // Insert a separator, except at the very end.
            output.append(separator);
        }
        endIndexes[i] = output.length();
    }
    for (int i = totalLen - 1; i >= 0; i--) {
        // Delete the tail of the string, cutting back to one less element.
        output.delete(endIndexes[i], output.length());
        final int remainingElements = totalLen - i - 1;
        if (remainingElements > 0) {
            CharSequence morePiece = (res == null) ? ELLIPSIS_NORMAL : res.getQuantityString(moreId, remainingElements, remainingElements);
            morePiece = bidiFormatter.unicodeWrap(morePiece);
            output.append(morePiece);
        }
        final float width = paint.measureText(output, 0, output.length());
        if (width <= avail) {
            // The string fits.
            return output;
        }
    }
    // Nothing fits.
    return """";
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,4,0,"The constant used in a ternary operation has changed from `ELLIPSIS_STRING` to `ELLIPSIS_NORMAL`, so the code change type is 4.","The replacement of the constant `ELLIPSIS_STRING` with `ELLIPSIS_NORMAL` in a ternary operation does not imply a change to the method's control flow or to the exceptions it may throw. The method behavior will be the same in terms of its logic and flow, assuming `ELLIPSIS_STRING` and `ELLIPSIS_NORMAL` convey similar meanings in the context of this method. Therefore, this does not introduce a Compatibility Issue."
627,"<android.hardware.camera2.impl.CameraCaptureSessionImpl: int capture(CaptureRequest,CaptureCallback,Handler)>",27,28,"<android.hardware.camera2.impl.CameraCaptureSessionImpl: int capture(CaptureRequest,CaptureCallback,Handler)>","<android.hardware.camera2.impl.CameraCaptureSessionImpl: int capture(CaptureRequest,CaptureCallback,Handler)>",0,"{
    if (request == null) {
        throw new IllegalArgumentException(""request must not be null"");
    } else if (request.isReprocess() && !isReprocessable()) {
        throw new IllegalArgumentException(""this capture session cannot handle reprocess "" + ""requests"");
    } else if (request.isReprocess() && request.getReprocessableSessionId() != mId) {
        throw new IllegalArgumentException(""capture request was created for another session"");
    }
    synchronized (mDeviceImpl.mInterfaceLock) {
        checkNotClosed();
        handler = checkHandler(handler, callback);
        if (DEBUG) {
            Log.v(TAG, mIdString + ""capture - request "" + request + "", callback "" + callback + "" handler "" + handler);
        }
        return addPendingSequence(mDeviceImpl.capture(request, createCaptureCallbackProxy(handler, callback), mDeviceHandler));
    }
}","{
    checkCaptureRequest(request);
    synchronized (mDeviceImpl.mInterfaceLock) {
        checkNotClosed();
        handler = checkHandler(handler, callback);
        if (DEBUG) {
            Log.v(TAG, mIdString + ""capture - request "" + request + "", callback "" + callback + "" handler "" + handler);
        }
        return addPendingSequence(mDeviceImpl.capture(request, createCaptureCallbackProxy(handler, callback), mDeviceExecutor));
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"4,5",0,"The body of the if-else checks has been abstracted into a method named 'checkCaptureRequest(request)'. The 'mDeviceHandler' parameter in the 'addPendingSequence' method call has also been changed to 'mDeviceExecutor'. Therefore, the code change types are 4 for the refactoring into 'checkCaptureRequest' and 5 for the change in the dependent API parameter name from 'mDeviceHandler' to 'mDeviceExecutor'.","There is no evident Compatibility Issue because the refactoring does not alter the behavior or outcome, as long as the 'checkCaptureRequest' method performs the same checks as the replaced code. The change of the parameter from 'mDeviceHandler' to 'mDeviceExecutor' does not necessarily imply a Compatibility Issue as it is an internal change to the method parameter and depends on whether 'mDeviceHandler' and 'mDeviceExecutor' are interchangeable or functionally equivalent within the context of the API's implementation. Without evidence suggesting a difference in behavior, no Compatibility Issue is detected."
628,<android.view.textclassifier.logging.SmartSelectionEventTracker: void logEvent(SelectionEvent)>,27,28,<android.view.textclassifier.logging.SmartSelectionEventTracker: void logEvent(SelectionEvent)>,<android.view.textclassifier.logging.SmartSelectionEventTracker: void logEvent(SelectionEvent)>,0,"{
    Preconditions.checkNotNull(event);
    if (event.mEventType != SelectionEvent.EventType.SELECTION_STARTED && mSessionId == null && DEBUG_LOG_ENABLED) {
        Log.d(LOG_TAG, ""Selection session not yet started. Ignoring event"");
        return;
    }
    final long now = System.currentTimeMillis();
    switch(event.mEventType) {
        case SelectionEvent.EventType.SELECTION_STARTED:
            mSessionId = startNewSession();
            Preconditions.checkArgument(event.mEnd == event.mStart + 1);
            mOrigStart = event.mStart;
            mSessionStartTime = now;
            break;
        // fall through
        case SelectionEvent.EventType.SMART_SELECTION_SINGLE:
        case SelectionEvent.EventType.SMART_SELECTION_MULTI:
            mSmartSelectionTriggered = true;
            mVersionTag = getVersionTag(event);
            mSmartIndices[0] = event.mStart;
            mSmartIndices[1] = event.mEnd;
            break;
        // fall through
        case SelectionEvent.EventType.SELECTION_MODIFIED:
        case SelectionEvent.EventType.AUTO_SELECTION:
            if (mPrevIndices[0] == event.mStart && mPrevIndices[1] == event.mEnd) {
                // Selection did not change. Ignore event.
                return;
            }
    }
    writeEvent(event, now);
    if (event.isTerminal()) {
        endSession();
    }
}","{
    Preconditions.checkNotNull(event);
    if (event.mEventType != SelectionEvent.EventType.SELECTION_STARTED && mSessionId == null && DEBUG_LOG_ENABLED) {
        Log.d(LOG_TAG, ""Selection session not yet started. Ignoring event"");
        return;
    }
    final long now = System.currentTimeMillis();
    switch(event.mEventType) {
        case SelectionEvent.EventType.SELECTION_STARTED:
            mSessionId = startNewSession();
            Preconditions.checkArgument(event.mEnd == event.mStart + 1);
            mOrigStart = event.mStart;
            mSessionStartTime = now;
            break;
        // fall through
        case SelectionEvent.EventType.SMART_SELECTION_SINGLE:
        case SelectionEvent.EventType.SMART_SELECTION_MULTI:
            mSmartSelectionTriggered = true;
            mModelName = getModelName(event);
            mSmartIndices[0] = event.mStart;
            mSmartIndices[1] = event.mEnd;
            break;
        // fall through
        case SelectionEvent.EventType.SELECTION_MODIFIED:
        case SelectionEvent.EventType.AUTO_SELECTION:
            if (mPrevIndices[0] == event.mStart && mPrevIndices[1] == event.mEnd) {
                // Selection did not change. Ignore event.
                return;
            }
    }
    writeEvent(event, now);
    if (event.isTerminal()) {
        endSession();
    }
}",1,"/**
 * Logs a selection event.
 *
 * @param event the selection event
 */
","/**
 * Logs a selection event.
 *
 * @param event the selection event
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"As the only change is that `mVersionTag = getVersionTag(event);` was replaced by `mModelName = getModelName(event);`, this is an internal variable assignment change, which falls under the category of 'Other statement changed'.","There is no Compatibility Issue because the overall behavior of the method has not changed. The method still checks the event type and performs the same sequence of operations, and since there is no change in the return type/value, thrown exceptions, or control flow that would affect external callers, the change is internal and not affecting compatibility."
629,<android.content.res.AssetManager: CharSequence[] getResourceTextArray(int)>,27,28,<android.content.res.AssetManager: CharSequence[] getResourceTextArray(int)>,<android.content.res.AssetManager: CharSequence[] getResourceTextArray(int)>,0,"{
    synchronized (this) {
        final int[] rawInfoArray = getArrayStringInfo(resId);
        if (rawInfoArray == null) {
            return null;
        }
        final int rawInfoArrayLen = rawInfoArray.length;
        final int infoArrayLen = rawInfoArrayLen / 2;
        int block;
        int index;
        final CharSequence[] retArray = new CharSequence[infoArrayLen];
        for (int i = 0, j = 0; i < rawInfoArrayLen; i = i + 2, j++) {
            block = rawInfoArray[i];
            index = rawInfoArray[i + 1];
            retArray[j] = index >= 0 ? mStringBlocks[block].get(index) : null;
        }
        return retArray;
    }
}","{
    synchronized (this) {
        ensureValidLocked();
        final int[] rawInfoArray = nativeGetResourceStringArrayInfo(mObject, resId);
        if (rawInfoArray == null) {
            return null;
        }
        final int rawInfoArrayLen = rawInfoArray.length;
        final int infoArrayLen = rawInfoArrayLen / 2;
        final CharSequence[] retArray = new CharSequence[infoArrayLen];
        for (int i = 0, j = 0; i < rawInfoArrayLen; i = i + 2, j++) {
            int cookie = rawInfoArray[i];
            int index = rawInfoArray[i + 1];
            retArray[j] = (index >= 0 && cookie > 0) ? mApkAssets[cookie - 1].getStringFromPool(index) : null;
        }
        return retArray;
    }
}",1,"/**
 * Retrieve the text array associated with a particular resource
 * identifier.
 *
 * @param resId the resource id of the string array
 */
","/**
 * Retrieve the text array associated with a particular resource
 * identifier.
 *
 * @param resId the resource id of the string array
 */
",-1,[@Nullable],[@Nullable],-1,-1,-1,-1,-1,-1,"3,4,5",0,There are multiple changes between the early and late version implementations:,"3. Instead of accessing `mStringBlocks[block].get(index)`, the late version uses `mApkAssets[cookie - 1].getStringFromPool(index)`, indicating a change in how the CharSequence is retrieved from an internal structure, which is also an 'other statement changed' (4)."
630,"<android.widget.Editor.TextActionModeCallback: boolean onCreateActionMode(ActionMode,Menu)>",27,28,"<android.widget.Editor.TextActionModeCallback: boolean onCreateActionMode(ActionMode,Menu)>","<android.widget.Editor.TextActionModeCallback: boolean onCreateActionMode(ActionMode,Menu)>",0,"{
    mode.setTitle(null);
    mode.setSubtitle(null);
    mode.setTitleOptionalHint(true);
    populateMenuWithItems(menu);
    Callback customCallback = getCustomCallback();
    if (customCallback != null) {
        if (!customCallback.onCreateActionMode(mode, menu)) {
            // The custom mode can choose to cancel the action mode, dismiss selection.
            Selection.setSelection((Spannable) mTextView.getText(), mTextView.getSelectionEnd());
            return false;
        }
    }
    if (mTextView.canProcessText()) {
        mProcessTextIntentActionsHandler.onInitializeMenu(menu);
    }
    if (menu.hasVisibleItems() || mode.getCustomView() != null) {
        if (mHasSelection && !mTextView.hasTransientState()) {
            mTextView.setHasTransientState(true);
        }
        return true;
    } else {
        return false;
    }
}","{
    mAssistClickHandlers.clear();
    mode.setTitle(null);
    mode.setSubtitle(null);
    mode.setTitleOptionalHint(true);
    populateMenuWithItems(menu);
    Callback customCallback = getCustomCallback();
    if (customCallback != null) {
        if (!customCallback.onCreateActionMode(mode, menu)) {
            // The custom mode can choose to cancel the action mode, dismiss selection.
            Selection.setSelection((Spannable) mTextView.getText(), mTextView.getSelectionEnd());
            return false;
        }
    }
    if (mTextView.canProcessText()) {
        mProcessTextIntentActionsHandler.onInitializeMenu(menu);
    }
    if (mHasSelection && !mTextView.hasTransientState()) {
        mTextView.setHasTransientState(true);
    }
    return true;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,4",1,"The early implementation contains a return statement within a conditional block that is based on whether the menu has visible items or a custom view is set, this part is completely removed in the late implementation causing all code paths to return true. Additionally, there is a new line of code added at the beginning of the late implementation `mAssistClickHandlers.clear();`, signifying an 'Other statement changed' (code change type 4).","Given the removal of the earlier conditional block that could potentially return false, the late implementation will always return true, this change is significant in terms of API behavior. Since the condition that could cause a false to be returned has been completely dropped, clients calling this API will experience a change in behavior. Because the return value is now different with the potential to affect downstream execution, this constitutes a compatibility issue categorized as 1."
631,"<android.hardware.camera2.params.OutputConfiguration: void writeToParcel(Parcel,int)>",27,28,"<android.hardware.camera2.params.OutputConfiguration: void writeToParcel(Parcel,int)>","<android.hardware.camera2.params.OutputConfiguration: void writeToParcel(Parcel,int)>",0,"{
    if (dest == null) {
        throw new IllegalArgumentException(""dest must not be null"");
    }
    dest.writeInt(mRotation);
    dest.writeInt(mSurfaceGroupId);
    dest.writeInt(mSurfaceType);
    dest.writeInt(mConfiguredSize.getWidth());
    dest.writeInt(mConfiguredSize.getHeight());
    dest.writeInt(mIsDeferredConfig ? 1 : 0);
    dest.writeInt(mIsShared ? 1 : 0);
    dest.writeTypedList(mSurfaces);
}","{
    if (dest == null) {
        throw new IllegalArgumentException(""dest must not be null"");
    }
    dest.writeInt(mRotation);
    dest.writeInt(mSurfaceGroupId);
    dest.writeInt(mSurfaceType);
    dest.writeInt(mConfiguredSize.getWidth());
    dest.writeInt(mConfiguredSize.getHeight());
    dest.writeInt(mIsDeferredConfig ? 1 : 0);
    dest.writeInt(mIsShared ? 1 : 0);
    dest.writeTypedList(mSurfaces);
    dest.writeString(mPhysicalCameraId);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"A new line that writes mPhysicalCameraId to the parcel is added in the late version, so the code change type is 4.","Since the addition of dest.writeString(mPhysicalCameraId) would not alter the behavior of the existing method but is simply adding additional data to the parcel, there is no Compatibility Issue in this case. All the checks and other writes to the parcel remain the same, and the method signature is unchanged."
632,<android.bluetooth.BluetoothAdapter: Set<BluetoothDevice> getBondedDevices()>,27,28,<android.bluetooth.BluetoothAdapter: Set<BluetoothDevice> getBondedDevices()>,<android.bluetooth.BluetoothAdapter: Set<BluetoothDevice> getBondedDevices()>,0,"{
    if (getState() != STATE_ON) {
        return toDeviceSet(new BluetoothDevice[0]);
    }
    try {
        mServiceLock.readLock().lock();
        if (mService != null)
            return toDeviceSet(mService.getBondedDevices());
        return toDeviceSet(new BluetoothDevice[0]);
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
    } finally {
        mServiceLock.readLock().unlock();
    }
    return null;
}","{
    if (getState() != STATE_ON) {
        return toDeviceSet(new BluetoothDevice[0]);
    }
    try {
        mServiceLock.readLock().lock();
        if (mService != null) {
            return toDeviceSet(mService.getBondedDevices());
        }
        return toDeviceSet(new BluetoothDevice[0]);
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
    } finally {
        mServiceLock.readLock().unlock();
    }
    return null;
}",1,"/**
 * Return the set of {@link BluetoothDevice} objects that are bonded
 * (paired) to the local adapter.
 * <p>If Bluetooth state is not {@link #STATE_ON}, this API
 * will return an empty set. After turning on Bluetooth,
 * wait for {@link #ACTION_STATE_CHANGED} with {@link #STATE_ON}
 * to get the updated value.
 *
 * @return unmodifiable set of {@link BluetoothDevice}, or null on error
 */
","/**
 * Return the set of {@link BluetoothDevice} objects that are bonded
 * (paired) to the local adapter.
 * <p>If Bluetooth state is not {@link #STATE_ON}, this API
 * will return an empty set. After turning on Bluetooth,
 * wait for {@link #ACTION_STATE_CHANGED} with {@link #STATE_ON}
 * to get the updated value.
 *
 * @return unmodifiable set of {@link BluetoothDevice}, or null on error
 */
",-1,[@RequiresPermission(Manifest.permission.BLUETOOTH)],[@RequiresPermission(Manifest.permission.BLUETOOTH)],-1,-1,-1,-1,-1,-1,0,0,"There are no changes in the implementation of the method between the two versions. All code, including the control flow, return statements, exceptions, and annotations, remains the same.","Since there is no change in the code or annotations, there is no Compatibility Issue between these versions."
633,<android.text.StaticLayout: Directions getLineDirections(int)>,27,28,<android.text.StaticLayout: Directions getLineDirections(int)>,<android.text.StaticLayout: Directions getLineDirections(int)>,0,"{
    return mLineDirections[line];
}","{
    if (line > getLineCount()) {
        throw new ArrayIndexOutOfBoundsException();
    }
    return mLineDirections[line];
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"2,3",2,"A control dependency and an exception handling statement have been introduced. Now the late version throws an `ArrayIndexOutOfBoundsException` when `line > getLineCount()`, so the code change includes both types 2 and 3.","The new exception handling statement will cause a Compatibility Issue as the late version can now throw a new exception that did not exist in the early version if the condition for the exception being thrown is met. Therefore, the CI type is 2."
634,<android.net.TrafficStats: long getMobileTxPackets()>,27,28,<android.net.TrafficStats: long getMobileTxPackets()>,<android.net.TrafficStats: long getMobileTxPackets()>,0,"{
    long total = 0;
    for (String iface : getMobileIfaces()) {
        total += getTxPackets(iface);
    }
    return total;
}","{
    long total = 0;
    for (String iface : getMobileIfaces()) {
        total += addIfSupported(getTxPackets(iface));
    }
    return total;
}",1,"/**
 * Return number of packets transmitted across mobile networks since device
 * boot. Counts packets across all mobile network interfaces, and always
 * increases monotonically since device boot. Statistics are measured at the
 * network layer, so they include both TCP and UDP usage.
 * <p>
 * Before {@link android.os.Build.VERSION_CODES#JELLY_BEAN_MR2}, this may
 * return {@link #UNSUPPORTED} on devices where statistics aren't available.
 */
","/**
 * Return number of packets transmitted across mobile networks since device
 * boot. Counts packets across all mobile network interfaces, and always
 * increases monotonically since device boot. Statistics are measured at the
 * network layer, so they include both TCP and UDP usage.
 * <p>
 * Before {@link android.os.Build.VERSION_CODES#JELLY_BEAN_MR2}, this may
 * return {@link #UNSUPPORTED} on devices where statistics aren't available.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",1,"A new method `addIfSupported` is invoked within the loop, so the code change type is 4,5 (Other statement changed and Dependent API changed).","Since `addIfSupported` is called instead of directly adding the result of `getTxPackets(iface)`, which could potentially filter or modify the value returned by `getTxPackets(iface)`, the API could return a different value in the late version. Thus, the CI type is 1."
636,"<android.hardware.camera2.impl.CallbackProxies.SessionStateCallbackProxy: void onSurfacePrepared(CameraCaptureSession,Surface)>",27,28,"<android.hardware.camera2.impl.CallbackProxies.SessionStateCallbackProxy: void onSurfacePrepared(CameraCaptureSession,Surface)>","<android.hardware.camera2.impl.CallbackProxies.SessionStateCallbackProxy: void onSurfacePrepared(CameraCaptureSession,Surface)>",0,"{
    mProxy.invoke(""onSurfacePrepared"", session, surface);
}","{
    final long ident = Binder.clearCallingIdentity();
    try {
        mExecutor.execute(() -> mCallback.onSurfacePrepared(session, surface));
    } finally {
        Binder.restoreCallingIdentity(ident);
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"2,3,4",2,"The method's implementation has changed to include control flow changes with a try-finally block, an exception handling change due to Binder operation, and an introduction of a new execution mechanism through mExecutor.execute(). This is both a control dependency change (3) due to the new try-finally block and other statement changed (4) because the previous direct invoke call has been replaced by a lambda execution. The change also includes modifications relating to exception handling (2) since it alters the way the calling identity is managed and restored, which could lead to a different exception handling behavior.","CI is indeed caused by potential different exception handlings. The original code does not handle process identity changes or exceptions that might be thrown and caught during the execution of the task. The late version introduces Binder.clearCallingIdentity() and Binder.restoreCallingIdentity(ident), which manage the caller's identity for IPC calls and could potentially throw exceptions that were not previously accounted for. This could also result in interruptions to the intended flow if exceptions occur, hence, there is a potential Compatibility Issue of type 2."
637,<android.bluetooth.le.AdvertisingSetParameters.Builder: AdvertisingSetParameters build()>,27,28,<android.bluetooth.le.AdvertisingSetParameters.Builder: AdvertisingSetParameters build()>,<android.bluetooth.le.AdvertisingSetParameters.Builder: AdvertisingSetParameters build()>,0,"{
    if (isLegacy) {
        if (isAnonymous) {
            throw new IllegalArgumentException(""Legacy advertising can't be anonymous"");
        }
        if (connectable == true && scannable == false) {
            throw new IllegalStateException(""Legacy advertisement can't be connectable and non-scannable"");
        }
        if (includeTxPower) {
            throw new IllegalStateException(""Legacy advertising can't include TX power level in header"");
        }
    } else {
        if (connectable && scannable) {
            throw new IllegalStateException(""Advertising can't be both connectable and scannable"");
        }
        if (isAnonymous && connectable) {
            throw new IllegalStateException(""Advertising can't be both connectable and anonymous"");
        }
    }
    return new AdvertisingSetParameters(connectable, scannable, isLegacy, isAnonymous, includeTxPower, primaryPhy, secondaryPhy, interval, txPowerLevel);
}","{
    if (mIsLegacy) {
        if (mIsAnonymous) {
            throw new IllegalArgumentException(""Legacy advertising can't be anonymous"");
        }
        if (mConnectable && !mScannable) {
            throw new IllegalStateException(""Legacy advertisement can't be connectable and non-scannable"");
        }
        if (mIncludeTxPower) {
            throw new IllegalStateException(""Legacy advertising can't include TX power level in header"");
        }
    } else {
        if (mConnectable && mScannable) {
            throw new IllegalStateException(""Advertising can't be both connectable and scannable"");
        }
        if (mIsAnonymous && mConnectable) {
            throw new IllegalStateException(""Advertising can't be both connectable and anonymous"");
        }
    }
    return new AdvertisingSetParameters(mConnectable, mScannable, mIsLegacy, mIsAnonymous, mIncludeTxPower, mPrimaryPhy, mSecondaryPhy, mInterval, mTxPowerLevel);
}",1,"/**
 * Build the {@link AdvertisingSetParameters} object.
 * @throws IllegalStateException if invalid combination of parameters is used.
 */
","/**
 * Build the {@link AdvertisingSetParameters} object.
 *
 * @throws IllegalStateException if invalid combination of parameters is used.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"The method variables have been refactored (e.g., `isLegacy` to `mIsLegacy`, `connectable` to `mConnectable`, etc.), but the logic of the method remains the same. Additionally, the constructor call in the return statement has had corresponding variable names updated to match the renamed class member variables. Therefore, the code change type is 4 for variable renaming, and 5 for dependent API change as the constructor for `AdvertisingSetParameters` is called with different parameter names (though they are functionally the same values).",There is no compatibility issue since the behavior of the method has not been altered. All changes are internal to the method and do not affect the output or exception handling. The renaming of variables does not inherently introduce a compatibility issue if the semantics remain the same.
638,"<android.view.NotificationHeaderView.HeaderTouchListener: boolean onTouch(View,MotionEvent)>",27,28,"<android.view.NotificationHeaderView.HeaderTouchListener: boolean onTouch(View,MotionEvent)>","<android.view.NotificationHeaderView.HeaderTouchListener: boolean onTouch(View,MotionEvent)>",0,"{
    float x = event.getX();
    float y = event.getY();
    switch(event.getActionMasked() & MotionEvent.ACTION_MASK) {
        case MotionEvent.ACTION_DOWN:
            mTrackGesture = false;
            if (isInside(x, y)) {
                mDownX = x;
                mDownY = y;
                mTrackGesture = true;
                return true;
            }
            break;
        case MotionEvent.ACTION_MOVE:
            if (mTrackGesture) {
                if (Math.abs(mDownX - x) > mTouchSlop || Math.abs(mDownY - y) > mTouchSlop) {
                    mTrackGesture = false;
                }
            }
            break;
        case MotionEvent.ACTION_UP:
            if (mTrackGesture) {
                mExpandButton.performClick();
            }
            break;
    }
    return mTrackGesture;
}","{
    float x = event.getX();
    float y = event.getY();
    switch(event.getActionMasked() & MotionEvent.ACTION_MASK) {
        case MotionEvent.ACTION_DOWN:
            mTrackGesture = false;
            if (isInside(x, y)) {
                mDownX = x;
                mDownY = y;
                mTrackGesture = true;
                return true;
            }
            break;
        case MotionEvent.ACTION_MOVE:
            if (mTrackGesture) {
                if (Math.abs(mDownX - x) > mTouchSlop || Math.abs(mDownY - y) > mTouchSlop) {
                    mTrackGesture = false;
                }
            }
            break;
        case MotionEvent.ACTION_UP:
            if (mTrackGesture) {
                if (mAppOps.isVisibleToUser() && (mAppOpsRect.contains((int) x, (int) y) || mAppOpsRect.contains((int) mDownX, (int) mDownY))) {
                    mAppOps.performClick();
                    return true;
                }
                mExpandButton.performClick();
            }
            break;
    }
    return mTrackGesture;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,4",1,"In the late version, there are additional conditional checks before `mAppOps.performClick()` within the `MotionEvent.ACTION_UP` case, as well as a new return statement (`return true`) within this conditional block, so the change types are 3 and 4.","The changes in the late version introduce a new code path that can potentially return a value (`true`) which would not have been returned in the early version of the API. Therefore, there is a Compatibility Issue of type 1, indicating a potential difference in return values."
640,"<android.content.ContentResolver: void cancelSync(Account,String)>",27,28,"<android.content.ContentResolver: void cancelSync(Account,String)>","<android.content.ContentResolver: void cancelSync(Account,String)>",0,"{
    try {
        getContentService().cancelSync(account, authority, null);
    } catch (RemoteException e) {
    }
}","{
    try {
        getContentService().cancelSync(account, authority, null);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Cancel any active or pending syncs that match account and authority. The account and
 * authority can each independently be set to null, which means that syncs with any account
 * or authority, respectively, will match.
 *
 * @param account filters the syncs that match by this account
 * @param authority filters the syncs that match by this authority
 */
","/**
 * Cancel any active or pending syncs that match account and authority. The account and
 * authority can each independently be set to null, which means that syncs with any account
 * or authority, respectively, will match.
 *
 * @param account filters the syncs that match by this account
 * @param authority filters the syncs that match by this authority
 */
",-1,,,-1,-1,-1,-1,-1,-1,2,2,"The exception handling statement has changed, with a throw statement added in the late version, so the change type is 2.","The added throw statement (`throw e.rethrowFromSystemServer();`) in the late version may cause a RemoteException to propagate instead of being ignored as in the early version. This leads to a potential different exception handling behavior, and thus the CI type is 2."
643,<android.nfc.cardemulation.NfcFCardEmulation: String getSystemCodeForService(ComponentName)>,27,28,<android.nfc.cardemulation.NfcFCardEmulation: String getSystemCodeForService(ComponentName)>,<android.nfc.cardemulation.NfcFCardEmulation: String getSystemCodeForService(ComponentName)>,0,"{
    if (service == null) {
        throw new NullPointerException(""service is null"");
    }
    try {
        return sService.getSystemCodeForService(UserHandle.myUserId(), service);
    } catch (RemoteException e) {
        // Try one more time
        recoverService();
        if (sService == null) {
            Log.e(TAG, ""Failed to recover CardEmulationService."");
            return null;
        }
        try {
            return sService.getSystemCodeForService(UserHandle.myUserId(), service);
        } catch (RemoteException ee) {
            Log.e(TAG, ""Failed to reach CardEmulationService."");
            ee.rethrowAsRuntimeException();
            return null;
        }
    }
}","{
    if (service == null) {
        throw new NullPointerException(""service is null"");
    }
    try {
        return sService.getSystemCodeForService(mContext.getUserId(), service);
    } catch (RemoteException e) {
        // Try one more time
        recoverService();
        if (sService == null) {
            Log.e(TAG, ""Failed to recover CardEmulationService."");
            return null;
        }
        try {
            return sService.getSystemCodeForService(mContext.getUserId(), service);
        } catch (RemoteException ee) {
            Log.e(TAG, ""Failed to reach CardEmulationService."");
            ee.rethrowAsRuntimeException();
            return null;
        }
    }
}",1,"/**
 * Retrieves the current System Code for the specified service.
 *
 * <p>Before calling {@link #registerSystemCodeForService(ComponentName, String)},
 * the System Code contained in the Manifest file is returned. After calling
 * {@link #registerSystemCodeForService(ComponentName, String)}, the System Code
 * registered there is returned. After calling
 * {@link #unregisterSystemCodeForService(ComponentName)}, ""null"" is returned.
 *
 * @param service The component name of the service
 * @return the current System Code
 */
","/**
 * Retrieves the current System Code for the specified service.
 *
 * <p>Before calling {@link #registerSystemCodeForService(ComponentName, String)},
 * the System Code contained in the Manifest file is returned. After calling
 * {@link #registerSystemCodeForService(ComponentName, String)}, the System Code
 * registered there is returned. After calling
 * {@link #unregisterSystemCodeForService(ComponentName)}, ""null"" is returned.
 *
 * @param service The component name of the service
 * @return the current System Code
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The implementation has changed from using UserHandle.myUserId() to mContext.getUserId() as the first parameter in the getSystemCodeForService method. This is an example of a change in a dependent API, so the code change type is 5.","The change from UserHandle.myUserId() to mContext.getUserId() might be simply refactoring to use a context specific way to get the userId or an internal optimization. As long as the method mContext.getUserId() is providing the same userId which UserHandle.myUserId() was giving (which is typically expected), this should not lead to any compatibility issue. Hence, no compatibility issue is expected, and the CI type is 0."
645,<android.app.usage.UsageStats: void add(UsageStats)>,27,28,<android.app.usage.UsageStats: void add(UsageStats)>,<android.app.usage.UsageStats: void add(UsageStats)>,0,"{
    if (!mPackageName.equals(right.mPackageName)) {
        throw new IllegalArgumentException(""Can't merge UsageStats for package '"" + mPackageName + ""' with UsageStats for package '"" + right.mPackageName + ""'."");
    }
    // regards to their mEndTimeStamp.
    if (right.mBeginTimeStamp > mBeginTimeStamp) {
        // Even though incoming UsageStat begins after this one, its last time used fields
        // may somehow be empty or chronologically preceding the older UsageStat.
        mLastEvent = Math.max(mLastEvent, right.mLastEvent);
        mLastTimeUsed = Math.max(mLastTimeUsed, right.mLastTimeUsed);
    }
    mBeginTimeStamp = Math.min(mBeginTimeStamp, right.mBeginTimeStamp);
    mEndTimeStamp = Math.max(mEndTimeStamp, right.mEndTimeStamp);
    mTotalTimeInForeground += right.mTotalTimeInForeground;
    mLaunchCount += right.mLaunchCount;
    if (mChooserCounts == null) {
        mChooserCounts = right.mChooserCounts;
    } else if (right.mChooserCounts != null) {
        final int chooserCountsSize = right.mChooserCounts.size();
        for (int i = 0; i < chooserCountsSize; i++) {
            String action = right.mChooserCounts.keyAt(i);
            ArrayMap<String, Integer> counts = right.mChooserCounts.valueAt(i);
            if (!mChooserCounts.containsKey(action) || mChooserCounts.get(action) == null) {
                mChooserCounts.put(action, counts);
                continue;
            }
            final int annotationSize = counts.size();
            for (int j = 0; j < annotationSize; j++) {
                String key = counts.keyAt(j);
                int rightValue = counts.valueAt(j);
                int leftValue = mChooserCounts.get(action).getOrDefault(key, 0);
                mChooserCounts.get(action).put(key, leftValue + rightValue);
            }
        }
    }
}","{
    if (!mPackageName.equals(right.mPackageName)) {
        throw new IllegalArgumentException(""Can't merge UsageStats for package '"" + mPackageName + ""' with UsageStats for package '"" + right.mPackageName + ""'."");
    }
    // regards to their mEndTimeStamp.
    if (right.mBeginTimeStamp > mBeginTimeStamp) {
        // Even though incoming UsageStat begins after this one, its last time used fields
        // may somehow be empty or chronologically preceding the older UsageStat.
        mLastEvent = Math.max(mLastEvent, right.mLastEvent);
        mLastTimeUsed = Math.max(mLastTimeUsed, right.mLastTimeUsed);
    }
    mBeginTimeStamp = Math.min(mBeginTimeStamp, right.mBeginTimeStamp);
    mEndTimeStamp = Math.max(mEndTimeStamp, right.mEndTimeStamp);
    mTotalTimeInForeground += right.mTotalTimeInForeground;
    mLaunchCount += right.mLaunchCount;
    mAppLaunchCount += right.mAppLaunchCount;
    if (mChooserCounts == null) {
        mChooserCounts = right.mChooserCounts;
    } else if (right.mChooserCounts != null) {
        final int chooserCountsSize = right.mChooserCounts.size();
        for (int i = 0; i < chooserCountsSize; i++) {
            String action = right.mChooserCounts.keyAt(i);
            ArrayMap<String, Integer> counts = right.mChooserCounts.valueAt(i);
            if (!mChooserCounts.containsKey(action) || mChooserCounts.get(action) == null) {
                mChooserCounts.put(action, counts);
                continue;
            }
            final int annotationSize = counts.size();
            for (int j = 0; j < annotationSize; j++) {
                String key = counts.keyAt(j);
                int rightValue = counts.valueAt(j);
                int leftValue = mChooserCounts.get(action).getOrDefault(key, 0);
                mChooserCounts.get(action).put(key, leftValue + rightValue);
            }
        }
    }
}",1,"/**
 * Add the statistics from the right {@link UsageStats} to the left. The package name for
 * both {@link UsageStats} objects must be the same.
 * @param right The {@link UsageStats} object to merge into this one.
 * @throws java.lang.IllegalArgumentException if the package names of the two
 * {@link UsageStats} objects are different.
 */
","/**
 * Add the statistics from the right {@link UsageStats} to the left. The package name for
 * both {@link UsageStats} objects must be the same.
 * @param right The {@link UsageStats} object to merge into this one.
 * @throws java.lang.IllegalArgumentException if the package names of the two
 * {@link UsageStats} objects are different.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"One line has been added: `mAppLaunchCount += right.mAppLaunchCount;` which is an addition operation on the member variable `mAppLaunchCount`. This is an internal state change and does not affect the method signature or its outward behavior, so the change type is 4.","Since no return or exception handling statements have been added or modified, and the method's behavior from the caller's perspective remains consistent (it still merges the stats as before), there isn't a compatibility issue. Therefore, the CI type is 0."
646,<android.hardware.camera2.impl.CallbackProxies.SessionStateCallbackProxy: void onReady(CameraCaptureSession)>,27,28,<android.hardware.camera2.impl.CallbackProxies.SessionStateCallbackProxy: void onReady(CameraCaptureSession)>,<android.hardware.camera2.impl.CallbackProxies.SessionStateCallbackProxy: void onReady(CameraCaptureSession)>,0,"{
    mProxy.invoke(""onReady"", session);
}","{
    final long ident = Binder.clearCallingIdentity();
    try {
        mExecutor.execute(() -> mCallback.onReady(session));
    } finally {
        Binder.restoreCallingIdentity(ident);
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,4,5",1,"The method internals have seen significant changes, including control dependency changes with the addition of a try-finally block, modification of how the callback is invoked using an executor instead of a direct method invocation, and changes to the method's exception handling in terms of system identity management. This involves using a lambda expression as well. Additionally, the dependent API 'execute' of the Executor is now used instead of the direct method call 'invoke', hence the changes type is 3,4,5.","This change of the internal implementation can potentially affect the behavior of the API since now callbacks are scheduled on an Executor rather than being invoked immediately. This scheduling could potentially introduce a different behavior regarding when 'onReady' is actually executed, particularly as it respects threading and execution order. Changes in the calling identity management may also affect interactions with system facilities if the caller is using Binder tokens or similar mechanisms to cross process boundaries. Thus, the CI type is 1."
648,<android.hardware.usb.UsbManager: boolean hasPermission(UsbDevice)>,27,28,<android.hardware.usb.UsbManager: boolean hasPermission(UsbDevice)>,<android.hardware.usb.UsbManager: boolean hasPermission(UsbDevice)>,0,"{
    if (mService == null) {
        return false;
    }
    try {
        return mService.hasDevicePermission(device);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}","{
    if (mService == null) {
        return false;
    }
    try {
        return mService.hasDevicePermission(device, mContext.getPackageName());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Returns true if the caller has permission to access the device.
 * Permission might have been granted temporarily via
 * {@link #requestPermission(UsbDevice, PendingIntent)} or
 * by the user choosing the caller as the default application for the device.
 *
 * @param device to check permissions for
 * @return true if caller has permission
 */
","/**
 * Returns true if the caller has permission to access the device.
 * Permission might have been granted temporarily via
 * {@link #requestPermission(UsbDevice, PendingIntent)} or
 * by the user choosing the caller as the default application for the device.
 * Permission for USB devices of class {@link UsbConstants#USB_CLASS_VIDEO} for clients that
 * target SDK {@link android.os.Build.VERSION_CODES#P} and above can be granted only if they
 * have additionally the {@link android.Manifest.permission#CAMERA} permission.
 *
 * @param device to check permissions for
 * @return true if caller has permission
 */
",-1,,[@RequiresFeature(PackageManager.FEATURE_USB_HOST)],-1,-1,-1,-1,-1,-1,5,0,"The method call within the try block has changed from mService.hasDevicePermission(device) to mService.hasDevicePermission(device, mContext.getPackageName()), adding a second parameter, so the code change type is 5 (Dependent API changed).","The additional parameter is the package name which the context already has, and as such does not change the semantics of the permission check or the return value based purely on the code provided. It likely ensures that the permission is checked for the calling package specifically. Therefore, there is no Compatibility Issue, since the additional context should not affect the outcome of the permission check for apps already using this method correctly in context - it does not lead to a different return value or exception handling. Hence, the CI type is 0."
650,"<android.view.ViewGroup: void dispatchProvideAutofillStructure(ViewStructure,int)>",27,28,"<android.view.ViewGroup: void dispatchProvideAutofillStructure(ViewStructure,int)>","<android.view.ViewGroup: void dispatchProvideAutofillStructure(ViewStructure,int)>",0,"{
    super.dispatchProvideAutofillStructure(structure, flags);
    if (structure.getChildCount() != 0) {
        return;
    }
    if (!isLaidOut()) {
        Log.v(VIEW_LOG_TAG, ""dispatchProvideAutofillStructure(): not laid out, ignoring "" + mChildrenCount + "" children of "" + getAutofillId());
        return;
    }
    final ChildListForAutoFill children = getChildrenForAutofill(flags);
    final int childrenCount = children.size();
    structure.setChildCount(childrenCount);
    for (int i = 0; i < childrenCount; i++) {
        final View child = children.get(i);
        final ViewStructure cstructure = structure.newChild(i);
        child.dispatchProvideAutofillStructure(cstructure, flags);
    }
    children.recycle();
}","{
    super.dispatchProvideAutofillStructure(structure, flags);
    if (structure.getChildCount() != 0) {
        return;
    }
    if (!isLaidOut()) {
        if (Helper.sVerbose) {
            Log.v(VIEW_LOG_TAG, ""dispatchProvideAutofillStructure(): not laid out, ignoring "" + mChildrenCount + "" children of "" + getAutofillId());
        }
        return;
    }
    final ChildListForAutoFill children = getChildrenForAutofill(flags);
    final int childrenCount = children.size();
    structure.setChildCount(childrenCount);
    for (int i = 0; i < childrenCount; i++) {
        final View child = children.get(i);
        final ViewStructure cstructure = structure.newChild(i);
        child.dispatchProvideAutofillStructure(cstructure, flags);
    }
    children.recycle();
}",1,"/**
 * {@inheritDoc}
 *
 * <p>This implementation adds in all child views of the view group, in addition to calling the
 * default {@link View} implementation.
 */
","/**
 * {@inheritDoc}
 *
 * <p>This implementation adds in all child views of the view group, in addition to calling the
 * default {@link View} implementation.
 */
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,4",0,"The change in the code is the addition of a logging condition check `if (Helper.sVerbose)`. This is a change in a control dependency because it is wrapping an existing log statement, and it is an other statement change because the actual logging line `Log.v(...)` did not change but its execution condition did. However, this does not affect the return value or how exceptions are thrown.","Despite the change, there is no Compatibility Issue introduced, as the execution of the log statement does not affect the API's behavior regarding return values or exception handling. It is purely an additional debug information control, which won't cause the method to behave differently in terms of functionality."
651,<android.app.admin.ConnectEvent: InetAddress getInetAddress()>,27,28,<android.app.admin.ConnectEvent: InetAddress getInetAddress()>,<android.app.admin.ConnectEvent: InetAddress getInetAddress()>,0,"{
    try {
        // ipAddress is already an address, not a host name, no DNS resolution will happen.
        return InetAddress.getByName(ipAddress);
    } catch (UnknownHostException e) {
        // Should never happen as we aren't passing a host name.
        return InetAddress.getLoopbackAddress();
    }
}","{
    try {
        // ipAddress is already an address, not a host name, no DNS resolution will happen.
        return InetAddress.getByName(mIpAddress);
    } catch (UnknownHostException e) {
        // Should never happen as we aren't passing a host name.
        return InetAddress.getLoopbackAddress();
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,4,0,"The change is only in the variable name from 'ipAddress' to 'mIpAddress'. This does not constitute a change in the functionality, behavior, return type, or exception handling of the method. It's an internal variable renaming, so the code change type is 4.","There is no Compatibility Issue since the change in variable name has no impact on the return type, the exceptions being thrown, or the overall behavior of the API. The contract of the API as seen from an external perspective remains unchanged."
652,"<android.nfc.cardemulation.NfcFCardEmulation: boolean setNfcid2ForService(ComponentName,String)>",27,28,"<android.nfc.cardemulation.NfcFCardEmulation: boolean setNfcid2ForService(ComponentName,String)>","<android.nfc.cardemulation.NfcFCardEmulation: boolean setNfcid2ForService(ComponentName,String)>",0,"{
    if (service == null || nfcid2 == null) {
        throw new NullPointerException(""service or nfcid2 is null"");
    }
    try {
        return sService.setNfcid2ForService(UserHandle.myUserId(), service, nfcid2);
    } catch (RemoteException e) {
        // Try one more time
        recoverService();
        if (sService == null) {
            Log.e(TAG, ""Failed to recover CardEmulationService."");
            return false;
        }
        try {
            return sService.setNfcid2ForService(UserHandle.myUserId(), service, nfcid2);
        } catch (RemoteException ee) {
            Log.e(TAG, ""Failed to reach CardEmulationService."");
            ee.rethrowAsRuntimeException();
            return false;
        }
    }
}","{
    if (service == null || nfcid2 == null) {
        throw new NullPointerException(""service or nfcid2 is null"");
    }
    try {
        return sService.setNfcid2ForService(mContext.getUserId(), service, nfcid2);
    } catch (RemoteException e) {
        // Try one more time
        recoverService();
        if (sService == null) {
            Log.e(TAG, ""Failed to recover CardEmulationService."");
            return false;
        }
        try {
            return sService.setNfcid2ForService(mContext.getUserId(), service, nfcid2);
        } catch (RemoteException ee) {
            Log.e(TAG, ""Failed to reach CardEmulationService."");
            ee.rethrowAsRuntimeException();
            return false;
        }
    }
}",1,"/**
 * Set a NFCID2 for the specified service.
 *
 * <p>The NFCID2 must be in range from ""02FE000000000000"" to ""02FEFFFFFFFFFFFF"".
 *
 * <p>If a NFCID2 was previously set for this service
 * (either statically through the manifest, or dynamically by using this API),
 * it will be replaced.
 *
 * <p>Note that you can only set the NFCID2 for a service that
 * is running under the same UID as the caller of this API. Typically
 * this means you need to call this from the same
 * package as the service itself, though UIDs can also
 * be shared between packages using shared UIDs.
 *
 * @param service The component name of the service
 * @param nfcid2 The NFCID2 to be registered
 * @return whether the setting was successful.
 */
","/**
 * Set a NFCID2 for the specified service.
 *
 * <p>The NFCID2 must be in range from ""02FE000000000000"" to ""02FEFFFFFFFFFFFF"".
 *
 * <p>If a NFCID2 was previously set for this service
 * (either statically through the manifest, or dynamically by using this API),
 * it will be replaced.
 *
 * <p>Note that you can only set the NFCID2 for a service that
 * is running under the same UID as the caller of this API. Typically
 * this means you need to call this from the same
 * package as the service itself, though UIDs can also
 * be shared between packages using shared UIDs.
 *
 * @param service The component name of the service
 * @param nfcid2 The NFCID2 to be registered
 * @return whether the setting was successful.
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The only change observed is the replacement of UserHandle.myUserId() with mContext.getUserId() in the calls to the method setNfcid2ForService(). This change is related to how the user ID is retrieved, thus suggesting a change in the dependent API, therefore the code change type is 5.","There is no compatibility issue because the final outcome or handling of the sService.setNfcid2ForService() method call and the exceptions remain the same, and the change in how the user ID is obtained should have no effect on the method's behavior from a caller's perspective. The behavior and the output should remain consistent as long as both UserHandle.myUserId() and mContext.getUserId() return the correct user ID for the current context."
653,"<android.view.textclassifier.logging.SmartSelectionEventTracker.SelectionEvent: SelectionEvent selectionModified(int,int,TextSelection)>",27,28,"<android.view.textclassifier.logging.SmartSelectionEventTracker.SelectionEvent: SelectionEvent selectionModified(int,int,TextSelection)>","<android.view.textclassifier.logging.SmartSelectionEventTracker.SelectionEvent: SelectionEvent selectionModified(int,int,TextSelection)>",0,"{
    final boolean smartSelection = selection.getSourceClassifier().equals(TextClassifier.DEFAULT_LOG_TAG);
    final int eventType;
    if (smartSelection) {
        eventType = end - start > 1 ? EventType.SMART_SELECTION_MULTI : EventType.SMART_SELECTION_SINGLE;
    } else {
        eventType = EventType.AUTO_SELECTION;
    }
    final String entityType = selection.getEntityCount() > 0 ? selection.getEntity(0) : TextClassifier.TYPE_UNKNOWN;
    final String versionTag = selection.getVersionInfo();
    return new SelectionEvent(start, end, eventType, entityType, versionTag);
}","{
    final boolean smartSelection = getSourceClassifier(selection.getId()).equals(TextClassifier.DEFAULT_LOG_TAG);
    final int eventType;
    if (smartSelection) {
        eventType = end - start > 1 ? EventType.SMART_SELECTION_MULTI : EventType.SMART_SELECTION_SINGLE;
    } else {
        eventType = EventType.AUTO_SELECTION;
    }
    final String entityType = selection.getEntityCount() > 0 ? selection.getEntity(0) : TextClassifier.TYPE_UNKNOWN;
    final String versionTag = getVersionInfo(selection.getId());
    return new SelectionEvent(start, end, eventType, entityType, versionTag);
}",1,"/**
 * Creates a ""selection modified"" event.
 * Use when a TextClassifier modifies the selection.
 *
 * @param start  the start word (inclusive) index of the selection
 * @param end  the end word (exclusive) index of the selection
 * @param selection  the TextSelection object returned by the TextClassifier for the
 * specified selection
 */
","/**
 * Creates a ""selection modified"" event.
 * Use when a TextClassifier modifies the selection.
 *
 * @param start  the start word (inclusive) index of the selection
 * @param end  the end word (exclusive) index of the selection
 * @param selection  the TextSelection object returned by the TextClassifier for the
 * specified selection
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"The method calls within the return statements have changed from `selection.getSourceClassifier()` to `getSourceClassifier(selection.getId())`, and from `selection.getVersionInfo()` to `getVersionInfo(selection.getId())`, so the change type is 4,5.","There is no Compatibility Issue here, since the behavior of the end result is not affected by these changes. The `SelectionEvent` constructor is still being called with the same parameters in terms of behavior, so even though the source of the parameters has changed, the potential behavior and output of the method remain consistent. Thus, the API preserves backward compatibility."
654,<android.os.Looper: void loop()>,27,28,<android.os.Looper: void loop()>,<android.os.Looper: void loop()>,0,"{
    final Looper me = myLooper();
    if (me == null) {
        throw new RuntimeException(""No Looper; Looper.prepare() wasn't called on this thread."");
    }
    final MessageQueue queue = me.mQueue;
    // Make sure the identity of this thread is that of the local process,
    // and keep track of what that identity token actually is.
    Binder.clearCallingIdentity();
    final long ident = Binder.clearCallingIdentity();
    for (; ; ) {
        // might block
        Message msg = queue.next();
        if (msg == null) {
            // No message indicates that the message queue is quitting.
            return;
        }
        // This must be in a local variable, in case a UI event sets the logger
        final Printer logging = me.mLogging;
        if (logging != null) {
            logging.println("">>>>> Dispatching to "" + msg.target + "" "" + msg.callback + "": "" + msg.what);
        }
        final long slowDispatchThresholdMs = me.mSlowDispatchThresholdMs;
        final long traceTag = me.mTraceTag;
        if (traceTag != 0 && Trace.isTagEnabled(traceTag)) {
            Trace.traceBegin(traceTag, msg.target.getTraceName(msg));
        }
        final long start = (slowDispatchThresholdMs == 0) ? 0 : SystemClock.uptimeMillis();
        final long end;
        try {
            msg.target.dispatchMessage(msg);
            end = (slowDispatchThresholdMs == 0) ? 0 : SystemClock.uptimeMillis();
        } finally {
            if (traceTag != 0) {
                Trace.traceEnd(traceTag);
            }
        }
        if (slowDispatchThresholdMs > 0) {
            final long time = end - start;
            if (time > slowDispatchThresholdMs) {
                Slog.w(TAG, ""Dispatch took "" + time + ""ms on "" + Thread.currentThread().getName() + "", h="" + msg.target + "" cb="" + msg.callback + "" msg="" + msg.what);
            }
        }
        if (logging != null) {
            logging.println(""<<<<< Finished to "" + msg.target + "" "" + msg.callback);
        }
        // Make sure that during the course of dispatching the
        // identity of the thread wasn't corrupted.
        final long newIdent = Binder.clearCallingIdentity();
        if (ident != newIdent) {
            Log.wtf(TAG, ""Thread identity changed from 0x"" + Long.toHexString(ident) + "" to 0x"" + Long.toHexString(newIdent) + "" while dispatching to "" + msg.target.getClass().getName() + "" "" + msg.callback + "" what="" + msg.what);
        }
        msg.recycleUnchecked();
    }
}","{
    final Looper me = myLooper();
    if (me == null) {
        throw new RuntimeException(""No Looper; Looper.prepare() wasn't called on this thread."");
    }
    final MessageQueue queue = me.mQueue;
    // Make sure the identity of this thread is that of the local process,
    // and keep track of what that identity token actually is.
    Binder.clearCallingIdentity();
    final long ident = Binder.clearCallingIdentity();
    // Allow overriding a threshold with a system prop. e.g.
    // adb shell 'setprop log.looper.1000.main.slow 1 && stop && start'
    final int thresholdOverride = SystemProperties.getInt(""log.looper."" + Process.myUid() + ""."" + Thread.currentThread().getName() + "".slow"", 0);
    boolean slowDeliveryDetected = false;
    for (; ; ) {
        // might block
        Message msg = queue.next();
        if (msg == null) {
            // No message indicates that the message queue is quitting.
            return;
        }
        // This must be in a local variable, in case a UI event sets the logger
        final Printer logging = me.mLogging;
        if (logging != null) {
            logging.println("">>>>> Dispatching to "" + msg.target + "" "" + msg.callback + "": "" + msg.what);
        }
        final long traceTag = me.mTraceTag;
        long slowDispatchThresholdMs = me.mSlowDispatchThresholdMs;
        long slowDeliveryThresholdMs = me.mSlowDeliveryThresholdMs;
        if (thresholdOverride > 0) {
            slowDispatchThresholdMs = thresholdOverride;
            slowDeliveryThresholdMs = thresholdOverride;
        }
        final boolean logSlowDelivery = (slowDeliveryThresholdMs > 0) && (msg.when > 0);
        final boolean logSlowDispatch = (slowDispatchThresholdMs > 0);
        final boolean needStartTime = logSlowDelivery || logSlowDispatch;
        final boolean needEndTime = logSlowDispatch;
        if (traceTag != 0 && Trace.isTagEnabled(traceTag)) {
            Trace.traceBegin(traceTag, msg.target.getTraceName(msg));
        }
        final long dispatchStart = needStartTime ? SystemClock.uptimeMillis() : 0;
        final long dispatchEnd;
        try {
            msg.target.dispatchMessage(msg);
            dispatchEnd = needEndTime ? SystemClock.uptimeMillis() : 0;
        } finally {
            if (traceTag != 0) {
                Trace.traceEnd(traceTag);
            }
        }
        if (logSlowDelivery) {
            if (slowDeliveryDetected) {
                if ((dispatchStart - msg.when) <= 10) {
                    Slog.w(TAG, ""Drained"");
                    slowDeliveryDetected = false;
                }
            } else {
                if (showSlowLog(slowDeliveryThresholdMs, msg.when, dispatchStart, ""delivery"", msg)) {
                    // Once we write a slow delivery log, suppress until the queue drains.
                    slowDeliveryDetected = true;
                }
            }
        }
        if (logSlowDispatch) {
            showSlowLog(slowDispatchThresholdMs, dispatchStart, dispatchEnd, ""dispatch"", msg);
        }
        if (logging != null) {
            logging.println(""<<<<< Finished to "" + msg.target + "" "" + msg.callback);
        }
        // Make sure that during the course of dispatching the
        // identity of the thread wasn't corrupted.
        final long newIdent = Binder.clearCallingIdentity();
        if (ident != newIdent) {
            Log.wtf(TAG, ""Thread identity changed from 0x"" + Long.toHexString(ident) + "" to 0x"" + Long.toHexString(newIdent) + "" while dispatching to "" + msg.target.getClass().getName() + "" "" + msg.callback + "" what="" + msg.what);
        }
        msg.recycleUnchecked();
    }
}",1,"/**
 * Run the message queue in this thread. Be sure to call
 * {@link #quit()} to end the loop.
 */
","/**
 * Run the message queue in this thread. Be sure to call
 * {@link #quit()} to end the loop.
 */
",-1,,,-1,-1,-1,-1,-1,-1,,,,
655,"<android.view.inputmethod.InputMethodManager: void setInputMethodAndSubtype(IBinder,String,InputMethodSubtype)>",27,28,"<android.view.inputmethod.InputMethodManager: void setInputMethodAndSubtype(IBinder,String,InputMethodSubtype)>","<android.view.inputmethod.InputMethodManager: void setInputMethodAndSubtype(IBinder,String,InputMethodSubtype)>",0,"{
    try {
        mService.setInputMethodAndSubtype(token, id, subtype);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}","{
    setInputMethodAndSubtypeInternal(token, id, subtype);
}",1,"/**
 * Force switch to a new input method and subtype. This can only be called
 * from an application or a service which has a token of the currently active input method.
 * @param token Supplies the identifying token given to an input method
 * when it was started, which allows it to perform this operation on
 * itself.
 * @param id The unique identifier for the new input method to be switched to.
 * @param subtype The new subtype of the new input method to be switched to.
 */
","/**
 * Force switch to a new input method and subtype. This can only be called
 * from an application or a service which has a token of the currently active input method.
 * @param token Supplies the identifying token given to an input method
 * when it was started, which allows it to perform this operation on
 * itself.
 * @param id The unique identifier for the new input method to be switched to.
 * @param subtype The new subtype of the new input method to be switched to.
 * @deprecated Use
 * {@link InputMethodService#switchInputMethod(String, InputMethodSubtype)}
 * instead. This method was intended for IME developers who should be accessing APIs through
 * the service. APIs in this class are intended for app developers interacting with the IME.
 */
",-1,,[@Deprecated],-1,-1,-1,-1,-1,-1,5,0,"The early version directly calls `mService.setInputMethodAndSubtype`, while the late version calls a different method, `setInputMethodAndSubtypeInternal` with the same parameters. Because the body of `setInputMethodAndSubtypeInternal` is not visible, we assume this is a wrapper for the original service call or a refactored version that preserves functionality. This is a change in the dependent API, so the change type is 5.","There is no direct evidence of compatibility issues solely due to calling a different internal method, as long as the behavior of `setInputMethodAndSubtypeInternal` is consistent with the original service call. Therefore, we assume no CI, which is type 0, until proven otherwise. However, it is worth noting that without the body of the newly introduced method, we cannot fully ensure that no CI would occur."
656,<android.hardware.radio.RadioManager.ProgramInfo: boolean isTrafficAnnouncementActive()>,27,28,<android.hardware.radio.RadioManager.ProgramInfo: boolean isTrafficAnnouncementActive()>,<android.hardware.radio.RadioManager.ProgramInfo: boolean isTrafficAnnouncementActive()>,0,"{
    return (mFlags & FLAG_TRAFFIC_ANNOUNCEMENT) != 0;
}","{
    return (mInfoFlags & FLAG_TRAFFIC_ANNOUNCEMENT) != 0;
}",1,"/**
 * {@code true} if radio station transmits traffic information
 * at the very moment.
 */
","/**
 * {@code true} if radio station transmits traffic information
 * at the very moment.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The field name has changed within the same boolean expression from `mFlags` to `mInfoFlags`, but this change doesn't affect the type and value of the return variable, which still depends on the FLAG_TRAFFIC_ANNOUNCEMENT bit being set or not. Therefore, the code change type is 4.","Since the logic of checking whether the FLAG_TRAFFIC_ANNOUNCEMENT bit is set remains the same, the returned value will still be a boolean and will only depend on whether FLAG_TRAFFIC_ANNOUNCEMENT is set in the respective flag variable. Thus, no Compatibility Issue should arise, as the logic determining the return value has not changed."
657,<android.speech.tts.TextToSpeechService.SynthHandler: int stopForApp(Object)>,27,28,<android.speech.tts.TextToSpeechService.SynthHandler: int stopForApp(Object)>,<android.speech.tts.TextToSpeechService.SynthHandler: int stopForApp(Object)>,0,"{
    if (callerIdentity == null) {
        return TextToSpeech.ERROR;
    }
    // Flush pending messages from callerIdentity
    startFlushingSpeechItems(callerIdentity);
    // This stops writing data to the file / or publishing
    // items to the audio playback handler.
    // 
    // Note that the current speech item must be removed only if it
    // belongs to the callingApp, else the item will be ""orphaned"" and
    // not stopped correctly if a stop request comes along for the item
    // from the app it belongs to.
    SpeechItem current = maybeRemoveCurrentSpeechItem(callerIdentity);
    if (current != null) {
        current.stop();
    }
    // Remove any enqueued audio too.
    mAudioPlaybackHandler.stopForApp(callerIdentity);
    // Stop flushing pending messages
    Runnable runnable = new Runnable() {

        @Override
        public void run() {
            endFlushingSpeechItems(callerIdentity);
        }
    };
    sendMessage(Message.obtain(this, runnable));
    return TextToSpeech.SUCCESS;
}","{
    if (callerIdentity == null) {
        return TextToSpeech.ERROR;
    }
    // Flush pending messages from callerIdentity.
    // See setCurrentSpeechItem on a subtlety around a race condition.
    startFlushingSpeechItems(callerIdentity);
    // This stops writing data to the file / or publishing
    // items to the audio playback handler.
    // 
    // Note that the current speech item must be removed only if it
    // belongs to the callingApp, else the item will be ""orphaned"" and
    // not stopped correctly if a stop request comes along for the item
    // from the app it belongs to.
    SpeechItem current = maybeRemoveCurrentSpeechItem(callerIdentity);
    if (current != null) {
        current.stop();
    }
    // Remove any enqueued audio too.
    mAudioPlaybackHandler.stopForApp(callerIdentity);
    // Stop flushing pending messages
    Runnable runnable = new Runnable() {

        @Override
        public void run() {
            endFlushingSpeechItems(callerIdentity);
        }
    };
    sendMessage(Message.obtain(this, runnable));
    return TextToSpeech.SUCCESS;
}",1,"/**
 * Stops all speech output and removes any utterances still in the queue for
 * the calling app.
 *
 * Called on a service binder thread.
 */
","/**
 * Stops all speech output and removes any utterances still in the queue for
 * the calling app.
 *
 * Called on a service binder thread.
 */
",-1,,,-1,-1,-1,-1,-1,-1,0,0,There is no code change in the implementation of the method between the two versions.,No compatibility issue exists as there is no change in the method implementation between the versions.
658,<android.provider.BlockedNumberContract: boolean canCurrentUserBlockNumbers(Context)>,27,28,<android.provider.BlockedNumberContract: boolean canCurrentUserBlockNumbers(Context)>,<android.provider.BlockedNumberContract: boolean canCurrentUserBlockNumbers(Context)>,0,"{
    final Bundle res = context.getContentResolver().call(AUTHORITY_URI, METHOD_CAN_CURRENT_USER_BLOCK_NUMBERS, null, null);
    return res != null && res.getBoolean(RES_CAN_BLOCK_NUMBERS, false);
}","{
    try {
        final Bundle res = context.getContentResolver().call(AUTHORITY_URI, METHOD_CAN_CURRENT_USER_BLOCK_NUMBERS, null, null);
        return res != null && res.getBoolean(RES_CAN_BLOCK_NUMBERS, false);
    } catch (NullPointerException | IllegalArgumentException ex) {
        // The content resolver can throw an NPE or IAE; we don't want to crash Telecom if
        // either of these happen.
        Log.w(null, ""canCurrentUserBlockNumbers: provider not ready."");
        return false;
    }
}",1,"/**
 * Checks if blocking numbers is supported for the current user.
 * <p> Typically, blocking numbers is only supported for one user at a time.
 *
 * @return {@code true} if the current user can block numbers.
 */
","/**
 * Checks if blocking numbers is supported for the current user.
 * <p> Typically, blocking numbers is only supported for one user at a time.
 *
 * @return {@code true} if the current user can block numbers.
 */
",-1,,,-1,-1,-1,-1,-1,-1,2,2,"Exception handling statements have been added with a try-catch block around the content resolver call in the later version, so the change type is 2.","The addition of a try-catch for NullPointerException or IllegalArgumentException can change the behavior of the API because it now catches these exceptions and returns false, rather than potentially propagating the exception to the caller in the early version. Therefore, there is a Compatibility Issue caused by potentially different exception handlings, and the CI type is 2."
659,<android.util.MapCollections.MapIterator: boolean equals(Object)>,27,28,<android.util.MapCollections.MapIterator: boolean equals(Object)>,<android.util.MapCollections.MapIterator: boolean equals(Object)>,0,"{
    if (!mEntryValid) {
        throw new IllegalStateException(""This container does not support retaining Map.Entry objects"");
    }
    if (!(o instanceof Map.Entry)) {
        return false;
    }
    Map.Entry<?, ?> e = (Map.Entry<?, ?>) o;
    return Objects.equal(e.getKey(), colGetEntry(mIndex, 0)) && Objects.equal(e.getValue(), colGetEntry(mIndex, 1));
}","{
    if (!mEntryValid) {
        throw new IllegalStateException(""This container does not support retaining Map.Entry objects"");
    }
    if (!(o instanceof Map.Entry)) {
        return false;
    }
    Map.Entry<?, ?> e = (Map.Entry<?, ?>) o;
    return Objects.equals(e.getKey(), colGetEntry(mIndex, 0)) && Objects.equals(e.getValue(), colGetEntry(mIndex, 1));
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"The change is from using `Objects.equal` to `Objects.equals` which are actually the same method (common error in annotating the method in older Android code). There has been no functional change to the actual workings of the code, so the code change type is 4.","There's no Compatibility Issue since `Objects.equals` is functionally identical to `Objects.equal`, so there would be no change in behavior for the API users."
660,<android.net.Network: URLConnection openConnection(URL)>,27,28,<android.net.Network: URLConnection openConnection(URL)>,<android.net.Network: URLConnection openConnection(URL)>,0,"{
    final ConnectivityManager cm = ConnectivityManager.getInstanceOrNull();
    if (cm == null) {
        throw new IOException(""No ConnectivityManager yet constructed, please construct one"");
    }
    // TODO: Should this be optimized to avoid fetching the global proxy for every request?
    final ProxyInfo proxyInfo = cm.getProxyForNetwork(this);
    java.net.Proxy proxy = null;
    if (proxyInfo != null) {
        proxy = proxyInfo.makeProxy();
    } else {
        proxy = java.net.Proxy.NO_PROXY;
    }
    return openConnection(url, proxy);
}","{
    final ConnectivityManager cm = ConnectivityManager.getInstanceOrNull();
    if (cm == null) {
        throw new IOException(""No ConnectivityManager yet constructed, please construct one"");
    }
    // TODO: Should this be optimized to avoid fetching the global proxy for every request?
    final ProxyInfo proxyInfo = cm.getProxyForNetwork(this);
    final java.net.Proxy proxy;
    if (proxyInfo != null) {
        proxy = proxyInfo.makeProxy();
    } else {
        proxy = java.net.Proxy.NO_PROXY;
    }
    return openConnection(url, proxy);
}",1,"/**
 * Opens the specified {@link URL} on this {@code Network}, such that all traffic will be sent
 * on this Network. The URL protocol must be {@code HTTP} or {@code HTTPS}.
 *
 * @return a {@code URLConnection} to the resource referred to by this URL.
 * @throws MalformedURLException if the URL protocol is not HTTP or HTTPS.
 * @throws IOException if an error occurs while opening the connection.
 * @see java.net.URL#openConnection()
 */
","/**
 * Opens the specified {@link URL} on this {@code Network}, such that all traffic will be sent
 * on this Network. The URL protocol must be {@code HTTP} or {@code HTTPS}.
 *
 * @return a {@code URLConnection} to the resource referred to by this URL.
 * @throws MalformedURLException if the URL protocol is not HTTP or HTTPS.
 * @throws IOException if an error occurs while opening the connection.
 * @see java.net.URL#openConnection()
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The change is related to the local variable declaration of 'proxy'. In the early version, the variable is declared with an initial assignment of null, and then conditionally assigned a value. In the late version, the variable is declared without initial assignment and then assigned in the if-else construct. This is an ""Other statement changed"" type, specifically a change in the local variable declaration pattern.","The change in variable declaration does not affect the external behavior of the API, because the value assigned to 'proxy' remains the same based on the 'proxyInfo' condition in both versions. Therefore, this does not introduce a Compatibility Issue."
662,<android.widget.SelectionActionModeHelper.TextClassificationHelper: SelectionResult suggestSelection()>,27,28,<android.widget.SelectionActionModeHelper.TextClassificationHelper: SelectionResult suggestSelection()>,<android.widget.SelectionActionModeHelper.TextClassificationHelper: SelectionResult suggestSelection()>,0,"{
    mHot = true;
    trimText();
    final TextSelection selection = mTextClassifier.suggestSelection(mTrimmedText, mRelativeStart, mRelativeEnd, mLocales);
    // Do not classify new selection boundaries if TextClassifier should be dark launched.
    if (!mTextClassifier.getSettings().isDarkLaunch()) {
        mSelectionStart = Math.max(0, selection.getSelectionStartIndex() + mTrimStart);
        mSelectionEnd = Math.min(mText.length(), selection.getSelectionEndIndex() + mTrimStart);
    }
    return performClassification(selection);
}","{
    mHot = true;
    trimText();
    final TextSelection selection;
    if (mContext.getApplicationInfo().targetSdkVersion >= Build.VERSION_CODES.P) {
        final TextSelection.Request request = new TextSelection.Request.Builder(mTrimmedText, mRelativeStart, mRelativeEnd).setDefaultLocales(mDefaultLocales).setDarkLaunchAllowed(true).build();
        selection = mTextClassifier.get().suggestSelection(request);
    } else {
        // Use old APIs.
        selection = mTextClassifier.get().suggestSelection(mTrimmedText, mRelativeStart, mRelativeEnd, mDefaultLocales);
    }
    // Do not classify new selection boundaries if TextClassifier should be dark launched.
    if (!isDarkLaunchEnabled()) {
        mSelectionStart = Math.max(0, selection.getSelectionStartIndex() + mTrimStart);
        mSelectionEnd = Math.min(mText.length(), selection.getSelectionEndIndex() + mTrimStart);
    }
    return performClassification(selection);
}",1,,,-1,[@WorkerThread],[@WorkerThread],-1,-1,-1,-1,-1,-1,"3,4,5",0,"The late version introduces a conditional statement to check the target SDK version and thus decides which method to call for selecting text. A new class (TextSelection.Request.Builder) and new method call (suggestSelection(request)) are also introduced in the late version. These changes represent control dependency change (3), other statement change (4), and dependent API change (5).","However, regardless of which branch of the conditional is taken, the end result - the selection - will be provided to performClassification(selection), which hasn't changed. Moreover, the condition checking for the dark launch feature and the mechanism of adjusting the selection indices remain the same. Thus, even though there are significant code changes, they do not lead to a change in the API's behavior from the caller's perspective; therefore, there is no Compatibility Issue (0)."
663,<android.hardware.camera2.params.OutputConfiguration: int hashCode()>,27,28,<android.hardware.camera2.params.OutputConfiguration: int hashCode()>,<android.hardware.camera2.params.OutputConfiguration: int hashCode()>,0,"{
    // surface is set.
    if (mIsDeferredConfig) {
        return HashCodeHelpers.hashCode(mRotation, mConfiguredSize.hashCode(), mConfiguredFormat, mConfiguredDataspace, mSurfaceGroupId, mSurfaceType, mIsShared ? 1 : 0);
    }
    return HashCodeHelpers.hashCode(mRotation, mSurfaces.hashCode(), mConfiguredGenerationId, mConfiguredSize.hashCode(), mConfiguredFormat, mConfiguredDataspace, mSurfaceGroupId, mIsShared ? 1 : 0);
}","{
    // surface is set.
    if (mIsDeferredConfig) {
        return HashCodeHelpers.hashCode(mRotation, mConfiguredSize.hashCode(), mConfiguredFormat, mConfiguredDataspace, mSurfaceGroupId, mSurfaceType, mIsShared ? 1 : 0, mPhysicalCameraId == null ? 0 : mPhysicalCameraId.hashCode());
    }
    return HashCodeHelpers.hashCode(mRotation, mSurfaces.hashCode(), mConfiguredGenerationId, mConfiguredSize.hashCode(), mConfiguredFormat, mConfiguredDataspace, mSurfaceGroupId, mIsShared ? 1 : 0, mPhysicalCameraId == null ? 0 : mPhysicalCameraId.hashCode());
}",1,"/**
 * {@inheritDoc}
 */
","/**
 * {@inheritDoc}
 */
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,4",1,"There is an additional method call (mPhysicalCameraId.hashCode()) in the hash code calculation and a conditional check (mPhysicalCameraId == null ? 0 : ...) added; this affects the return value, so the change types are 1 and 4.","The return value from hashCode() can be different between the versions due to the additional terms in the hash code calculation involving mPhysicalCameraId, which can result in a different hash code (int value) being returned, and the CI type is 1."
665,<android.net.TrafficStats: long getUidRxPackets(int)>,27,28,<android.net.TrafficStats: long getUidRxPackets(int)>,<android.net.TrafficStats: long getUidRxPackets(int)>,0,"{
    // This isn't actually enforcing any security; it just returns the
    // unsupported value. The real filtering is done at the kernel level.
    final int callingUid = android.os.Process.myUid();
    if (callingUid == android.os.Process.SYSTEM_UID || callingUid == uid) {
        return nativeGetUidStat(uid, TYPE_RX_PACKETS);
    } else {
        return UNSUPPORTED;
    }
}","{
    // This isn't actually enforcing any security; it just returns the
    // unsupported value. The real filtering is done at the kernel level.
    final int callingUid = android.os.Process.myUid();
    if (callingUid == android.os.Process.SYSTEM_UID || callingUid == uid) {
        try {
            return getStatsService().getUidStats(uid, TYPE_RX_PACKETS);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    } else {
        return UNSUPPORTED;
    }
}",1,"/**
 * Return number of packets received by the given UID since device boot.
 * Counts packets across all network interfaces, and always increases
 * monotonically since device boot. Statistics are measured at the network
 * layer, so they include both TCP and UDP usage.
 * <p>
 * Before {@link android.os.Build.VERSION_CODES#JELLY_BEAN_MR2}, this may return
 * {@link #UNSUPPORTED} on devices where statistics aren't available.
 * <p>
 * Starting in {@link android.os.Build.VERSION_CODES#N} this will only
 * report traffic statistics for the calling UID. It will return
 * {@link #UNSUPPORTED} for all other UIDs for privacy reasons. To access
 * historical network statistics belonging to other UIDs, use
 * {@link NetworkStatsManager}.
 *
 * @see android.os.Process#myUid()
 * @see android.content.pm.ApplicationInfo#uid
 */
","/**
 * Return number of packets received by the given UID since device boot.
 * Counts packets across all network interfaces, and always increases
 * monotonically since device boot. Statistics are measured at the network
 * layer, so they include both TCP and UDP usage.
 * <p>
 * Before {@link android.os.Build.VERSION_CODES#JELLY_BEAN_MR2}, this may return
 * {@link #UNSUPPORTED} on devices where statistics aren't available.
 * <p>
 * Starting in {@link android.os.Build.VERSION_CODES#N} this will only
 * report traffic statistics for the calling UID. It will return
 * {@link #UNSUPPORTED} for all other UIDs for privacy reasons. To access
 * historical network statistics belonging to other UIDs, use
 * {@link NetworkStatsManager}.
 *
 * @see android.os.Process#myUid()
 * @see android.content.pm.ApplicationInfo#uid
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,2,5","1,2","The dependent API called within the 'if' condition changed from nativeGetUidStat(uid, TYPE_RX_PACKETS) to getStatsService().getUidStats(uid, TYPE_RX_PACKETS), and there is a new exception handling statement introduced using try-catch block with throw e.rethrowFromSystemServer(). This indicates changes in return statement, exception handling, and dependent API, so the code change type is 1, 2, 5.","The change in calling a different method to get the UID stats can potentially lead to different return values or types, and the new exception handling statement could result in different exceptions being thrown. This causes potential different behaviors in both return value and exception handling, so the CI types are 1,2."
667,<android.service.autofill.FillCallback: void onFailure(CharSequence)>,27,28,<android.service.autofill.FillCallback: void onFailure(CharSequence)>,<android.service.autofill.FillCallback: void onFailure(CharSequence)>,0,"{
    assertNotCalled();
    mCalled = true;
    try {
        mCallback.onFailure(message);
    } catch (RemoteException e) {
        e.rethrowAsRuntimeException();
    }
}","{
    assertNotCalled();
    mCalled = true;
    try {
        mCallback.onFailure(mRequestId, message);
    } catch (RemoteException e) {
        e.rethrowAsRuntimeException();
    }
}",1,"/**
 * Notifies the Android System that an
 * {@link AutofillService#onFillRequest(FillRequest, android.os.CancellationSignal,
 * FillCallback)} could not be fulfilled by the service.
 *
 * @param message error message to be displayed to the user.
 */
","/**
 * Notifies the Android System that an
 * {@link AutofillService#onFillRequest(FillRequest, android.os.CancellationSignal,
 * FillCallback)} could not be fulfilled by the service.
 *
 * @param message error message to be displayed to the user.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5","1,5","The method signature in the method implementation changed from mCallback.onFailure(message) to mCallback.onFailure(mRequestId, message), which means a dependent API has changed. Hence the code change types are 1,5.","The dependent API change could potentially lead to different behavior due to a change in the method signature, which affects the value passed to and the execution of the onFailure method. This could result in a compatibility issue because the interface that the API expects to call has been altered by including an additional parameter (mRequestId). Therefore, the CI type is 1,5."
668,<android.app.Activity: void stopLockTask()>,27,28,<android.app.Activity: void stopLockTask()>,<android.app.Activity: void stopLockTask()>,0,"{
    try {
        ActivityManager.getService().stopLockTaskMode();
    } catch (RemoteException e) {
    }
}","{
    try {
        ActivityManager.getService().stopLockTaskModeByToken(mToken);
    } catch (RemoteException e) {
    }
}",1,"/**
 * Allow the user to switch away from the current task.
 *
 * Called to end the mode started by {@link Activity#startLockTask}. This
 * can only be called by activities that have successfully called
 * startLockTask previously.
 *
 * This will allow the user to exit this app and move onto other activities.
 * <p>Note: This method should only be called when the activity is user-facing. That is,
 * between onResume() and onPause().
 * <p>Note: If there are other tasks below this one that are also locked then calling this
 * method will immediately finish this task and resume the previous locked one, remaining in
 * lockTask mode.
 *
 * @see android.R.attr#lockTaskMode
 * @see ActivityManager#getLockTaskModeState()
 */
","/**
 * Stop the current task from being locked.
 *
 * <p>Called to end the LockTask or screen pinning mode started by {@link #startLockTask()}.
 * This can only be called by activities that have called {@link #startLockTask()} previously.
 *
 * <p><strong>Note:</strong> If the device is in LockTask mode that is not initially started
 * by this activity, then calling this method will not terminate the LockTask mode, but only
 * finish its own task. The device will remain in LockTask mode, until the activity which
 * started the LockTask mode calls this method, or until its whitelist authorization is revoked
 * by {@link DevicePolicyManager#setLockTaskPackages(ComponentName, String[])}.
 *
 * @see #startLockTask()
 * @see android.R.attr#lockTaskMode
 * @see ActivityManager#getLockTaskModeState()
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The method call within the try block has changed from stopLockTaskMode() to stopLockTaskModeByToken(mToken), indicating that a dependent API has changed, thus the code change type is 5.","Despite the method call change, the API still captures all RemoteExceptions without different handling or rethrowing, so the change does not result in a Compatibility Issue in terms of exception handling or return values; thus, there is no CI."
669,<android.hardware.radio.RadioManager.ProgramInfo: int hashCode()>,27,28,<android.hardware.radio.RadioManager.ProgramInfo: int hashCode()>,<android.hardware.radio.RadioManager.ProgramInfo: int hashCode()>,0,"{
    final int prime = 31;
    int result = 1;
    result = prime * result + mSelector.hashCode();
    result = prime * result + (mTuned ? 1 : 0);
    result = prime * result + (mStereo ? 1 : 0);
    result = prime * result + (mDigital ? 1 : 0);
    result = prime * result + mFlags;
    result = prime * result + mSignalStrength;
    result = prime * result + ((mMetadata == null) ? 0 : mMetadata.hashCode());
    result = prime * result + mVendorInfo.hashCode();
    return result;
}","{
    return Objects.hash(mSelector, mLogicallyTunedTo, mPhysicallyTunedTo, mRelatedContent, mInfoFlags, mSignalQuality, mMetadata, mVendorInfo);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,4",1,"The method implementation is completely changed. It is using the static method Objects.hash() with a different set of member fields in the late version. Thus, the change type is 1 for the return statement changed and 4 for other statements changed.","The API now potentially returns a different hash code value due to the change in the algorithm and the fields included in the hash calculation. Therefore, the CI type is 1."
671,<android.view.ViewRootImpl.InputStage: boolean shouldDropInputEvent(QueuedInputEvent)>,27,28,<android.view.ViewRootImpl.InputStage: boolean shouldDropInputEvent(QueuedInputEvent)>,<android.view.ViewRootImpl.InputStage: boolean shouldDropInputEvent(QueuedInputEvent)>,0,"{
    if (mView == null || !mAdded) {
        Slog.w(mTag, ""Dropping event due to root view being removed: "" + q.mEvent);
        return true;
    } else if ((!mAttachInfo.mHasWindowFocus && !q.mEvent.isFromSource(InputDevice.SOURCE_CLASS_POINTER)) || mStopped || (mIsAmbientMode && !q.mEvent.isFromSource(InputDevice.SOURCE_CLASS_BUTTON)) || (mPausedForTransition && !isBack(q.mEvent))) {
        // but the window has lost focus or stopped in the meantime.
        if (isTerminalInputEvent(q.mEvent)) {
            // Don't drop terminal input events, however mark them as canceled.
            q.mEvent.cancel();
            Slog.w(mTag, ""Cancelling event due to no window focus: "" + q.mEvent);
            return false;
        }
        // Drop non-terminal input events.
        Slog.w(mTag, ""Dropping event due to no window focus: "" + q.mEvent);
        return true;
    }
    return false;
}","{
    if (mView == null || !mAdded) {
        Slog.w(mTag, ""Dropping event due to root view being removed: "" + q.mEvent);
        return true;
    } else if ((!mAttachInfo.mHasWindowFocus && !q.mEvent.isFromSource(InputDevice.SOURCE_CLASS_POINTER) && !isAutofillUiShowing()) || mStopped || (mIsAmbientMode && !q.mEvent.isFromSource(InputDevice.SOURCE_CLASS_BUTTON)) || (mPausedForTransition && !isBack(q.mEvent))) {
        // but the window has lost focus or stopped in the meantime.
        if (isTerminalInputEvent(q.mEvent)) {
            // Don't drop terminal input events, however mark them as canceled.
            q.mEvent.cancel();
            Slog.w(mTag, ""Cancelling event due to no window focus: "" + q.mEvent);
            return false;
        }
        // Drop non-terminal input events.
        Slog.w(mTag, ""Dropping event due to no window focus: "" + q.mEvent);
        return true;
    }
    return false;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,3,1,"The conditional `if` statement within the `else if` block has been extended with an additional check `&& !isAutofillUiShowing()`, which is a control dependency change type 3.","The inclusion of the `isAutofillUiShowing()` check in the conditional statement can change when `true` or `false` is returned based on the new condition, leading to a different behavior. Hence, this is a Compatibility Issue caused by potential different return values, so the CI type is 1."
672,"<android.text.method.LinkMovementMethod: boolean onTouchEvent(TextView,Spannable,MotionEvent)>",27,28,"<android.text.method.LinkMovementMethod: boolean onTouchEvent(TextView,Spannable,MotionEvent)>","<android.text.method.LinkMovementMethod: boolean onTouchEvent(TextView,Spannable,MotionEvent)>",0,"{
    int action = event.getAction();
    if (action == MotionEvent.ACTION_UP || action == MotionEvent.ACTION_DOWN) {
        int x = (int) event.getX();
        int y = (int) event.getY();
        x -= widget.getTotalPaddingLeft();
        y -= widget.getTotalPaddingTop();
        x += widget.getScrollX();
        y += widget.getScrollY();
        Layout layout = widget.getLayout();
        int line = layout.getLineForVertical(y);
        int off = layout.getOffsetForHorizontal(line, x);
        ClickableSpan[] links = buffer.getSpans(off, off, ClickableSpan.class);
        if (links.length != 0) {
            if (action == MotionEvent.ACTION_UP) {
                links[0].onClick(widget);
            } else if (action == MotionEvent.ACTION_DOWN) {
                Selection.setSelection(buffer, buffer.getSpanStart(links[0]), buffer.getSpanEnd(links[0]));
            }
            return true;
        } else {
            Selection.removeSelection(buffer);
        }
    }
    return super.onTouchEvent(widget, buffer, event);
}","{
    int action = event.getAction();
    if (action == MotionEvent.ACTION_UP || action == MotionEvent.ACTION_DOWN) {
        int x = (int) event.getX();
        int y = (int) event.getY();
        x -= widget.getTotalPaddingLeft();
        y -= widget.getTotalPaddingTop();
        x += widget.getScrollX();
        y += widget.getScrollY();
        Layout layout = widget.getLayout();
        int line = layout.getLineForVertical(y);
        int off = layout.getOffsetForHorizontal(line, x);
        ClickableSpan[] links = buffer.getSpans(off, off, ClickableSpan.class);
        if (links.length != 0) {
            ClickableSpan link = links[0];
            if (action == MotionEvent.ACTION_UP) {
                if (link instanceof TextLinkSpan) {
                    ((TextLinkSpan) link).onClick(widget, TextLinkSpan.INVOCATION_METHOD_TOUCH);
                } else {
                    link.onClick(widget);
                }
            } else if (action == MotionEvent.ACTION_DOWN) {
                if (widget.getContext().getApplicationInfo().targetSdkVersion >= Build.VERSION_CODES.P) {
                    // Selection change will reposition the toolbar. Hide it for a few ms for a
                    // smoother transition.
                    widget.hideFloatingToolbar(HIDE_FLOATING_TOOLBAR_DELAY_MS);
                }
                Selection.setSelection(buffer, buffer.getSpanStart(link), buffer.getSpanEnd(link));
            }
            return true;
        } else {
            Selection.removeSelection(buffer);
        }
    }
    return super.onTouchEvent(widget, buffer, event);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,4",1,"The late version has added a conditional check to determine the type of ClickableSpan (if it's an instance of TextLinkSpan) and cast it appropriately to call a different onClick method with an additional parameter (TextLinkSpan.INVOCATION_METHOD_TOUCH). Furthermore, there is a new conditional check against the targetSdkVersion and, if a certain condition is met, a call to widget.hideFloatingToolbar(HIDE_FLOATING_TOOLBAR_DELAY_MS) is added. These changes are classified under other statement changed (4) and control dependency change (3).","These changes lead to different interactions with the ClickableSpan and the widget's floating toolbar behavior, so there could be a Compatibility Issue in terms of different return values or types given that new code paths are introduced that affect the execution flow, which falls under CI type 1."
673,<android.text.Selection: int getSelectionStart(CharSequence)>,27,28,<android.text.Selection: int getSelectionStart(CharSequence)>,<android.text.Selection: int getSelectionStart(CharSequence)>,0,"{
    if (text instanceof Spanned)
        return ((Spanned) text).getSpanStart(SELECTION_START);
    else
        return -1;
}","{
    if (text instanceof Spanned) {
        return ((Spanned) text).getSpanStart(SELECTION_START);
    }
    return -1;
}",1,"/**
 * Return the offset of the selection anchor or cursor, or -1 if
 * there is no selection or cursor.
 */
","/**
 * Return the offset of the selection anchor or cursor, or -1 if
 * there is no selection or cursor.
 */
",-1,,,-1,-1,-1,-1,-1,-1,3,0,"The control structure has changed slightly with the removal of 'else', but the same logic is maintained, leading to an equivalent outcome, so the code change type is 3.",There is no Compatibility Issue because the change in control structure does not affect the returned value or the exception thrown by the method. The flow of the logic remains the same in both versions.
674,"<android.provider.Settings.Secure: boolean putLong(ContentResolver,String,long)>",27,28,"<android.provider.Settings.Secure: boolean putLong(ContentResolver,String,long)>","<android.provider.Settings.Secure: boolean putLong(ContentResolver,String,long)>",0,"{
    return putLongForUser(cr, name, value, UserHandle.myUserId());
}","{
    return putLongForUser(cr, name, value, cr.getUserId());
}",1,"/**
 * Convenience function for updating a secure settings value as a long
 * integer. This will either create a new entry in the table if the
 * given name does not exist, or modify the value of the existing row
 * with that name.  Note that internally setting values are always
 * stored as strings, so this function converts the given value to a
 * string before storing it.
 *
 * @param cr The ContentResolver to access.
 * @param name The name of the setting to modify.
 * @param value The new value for the setting.
 * @return true if the value was set, false on database errors
 */
","/**
 * Convenience function for updating a secure settings value as a long
 * integer. This will either create a new entry in the table if the
 * given name does not exist, or modify the value of the existing row
 * with that name.  Note that internally setting values are always
 * stored as strings, so this function converts the given value to a
 * string before storing it.
 *
 * @param cr The ContentResolver to access.
 * @param name The name of the setting to modify.
 * @param value The new value for the setting.
 * @return true if the value was set, false on database errors
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,1,"The dependent method has changed from putLongForUser(cr, name, value, UserHandle.myUserId()) to putLongForUser(cr, name, value, cr.getUserId()), including changes to the arguments passed to the method. So, the code change type is 5.","Since the method putLongForUser is now using a different user ID source, it could potentially store the value for a different user than before. This may result in different behavior affecting the caller, hence the CI type is 1."
675,"<android.service.notification.NotificationListenerService.RankingMap: boolean getRanking(String,Ranking)>",27,28,"<android.service.notification.NotificationListenerService.RankingMap: boolean getRanking(String,Ranking)>","<android.service.notification.NotificationListenerService.RankingMap: boolean getRanking(String,Ranking)>",0,"{
    int rank = getRank(key);
    outRanking.populate(key, rank, !isIntercepted(key), getVisibilityOverride(key), getSuppressedVisualEffects(key), getImportance(key), getImportanceExplanation(key), getOverrideGroupKey(key), getChannel(key), getOverridePeople(key), getSnoozeCriteria(key), getShowBadge(key));
    return rank >= 0;
}","{
    int rank = getRank(key);
    outRanking.populate(key, rank, !isIntercepted(key), getVisibilityOverride(key), getSuppressedVisualEffects(key), getImportance(key), getImportanceExplanation(key), getOverrideGroupKey(key), getChannel(key), getOverridePeople(key), getSnoozeCriteria(key), getShowBadge(key), getUserSentiment(key), getHidden(key));
    return rank >= 0;
}",1,"/**
 * Populates outRanking with ranking information for the notification
 * with the given key.
 *
 * @return true if a valid key has been passed and outRanking has
 * been populated; false otherwise
 */
","/**
 * Populates outRanking with ranking information for the notification
 * with the given key.
 *
 * @return true if a valid key has been passed and outRanking has
 * been populated; false otherwise
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The method `outRanking.populate()` has additional parameters (`getUserSentiment(key)` and `getHidden(key)`) in the late version, this indicates a change in method invocation, but the change type is 4 for Other statement changed since the return statement and exception handling are not affected.","No Compatibility Issue detected as the return statement (`return rank >= 0;`) is unchanged and no exception handling statement is altered, thus the behavior in terms of what it returns or exceptions it might throw has not been modified."
676,<android.app.NotificationManager.Policy: String toString()>,27,28,<android.app.NotificationManager.Policy: String toString()>,<android.app.NotificationManager.Policy: String toString()>,0,"{
    return ""NotificationManager.Policy["" + ""priorityCategories="" + priorityCategoriesToString(priorityCategories) + "",priorityCallSenders="" + prioritySendersToString(priorityCallSenders) + "",priorityMessageSenders="" + prioritySendersToString(priorityMessageSenders) + "",suppressedVisualEffects="" + suppressedEffectsToString(suppressedVisualEffects) + ""]"";
}","{
    return ""NotificationManager.Policy["" + ""priorityCategories="" + priorityCategoriesToString(priorityCategories) + "",priorityCallSenders="" + prioritySendersToString(priorityCallSenders) + "",priorityMessageSenders="" + prioritySendersToString(priorityMessageSenders) + "",suppressedVisualEffects="" + suppressedEffectsToString(suppressedVisualEffects) + "",areChannelsBypassingDnd="" + (((state & STATE_CHANNELS_BYPASSING_DND) != 0) ? ""true"" : ""false"") + ""]"";
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"A new string concatenation is added to the toString method, which appends the state of `areChannelsBypassingDnd` to the returned string. This is a change in other statements of the implementation, but not in the control flow or method signature, hence it falls under category 4.","Since this additional information is merely appending a new field value to the string representation of the object, it doesn't lead to a different behavior in terms of API's operational logic. Clients expecting a string format might need to adapt to the new format, but since the toString method is mainly for informational purposes and not computational, there's no functionality change that would cause a compatibility issue. Hence, there is no compatibility issue (CI type 0)."
678,<android.hardware.radio.TunerAdapter: void close()>,27,28,<android.hardware.radio.TunerAdapter: void close()>,<android.hardware.radio.TunerAdapter: void close()>,0,"{
    synchronized (mTuner) {
        if (mIsClosed) {
            Log.v(TAG, ""Tuner is already closed"");
            return;
        }
        mIsClosed = true;
    }
    try {
        mTuner.close();
    } catch (RemoteException e) {
        Log.e(TAG, ""Exception trying to close tuner"", e);
    }
}","{
    synchronized (mTuner) {
        if (mIsClosed) {
            Log.v(TAG, ""Tuner is already closed"");
            return;
        }
        mIsClosed = true;
        if (mLegacyListProxy != null) {
            mLegacyListProxy.close();
            mLegacyListProxy = null;
        }
        mCallback.close();
    }
    try {
        mTuner.close();
    } catch (RemoteException e) {
        Log.e(TAG, ""Exception trying to close tuner"", e);
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"The new statements added in the synchronized block only affect the state of `mLegacyListProxy` and `mCallback`, and don't change the return value or exception handling of the method, so the code change type is 4.","No return statements or exception handling statements were changed; the added statements do not alter the method's behavior in terms of what it returns or the exceptions it may throw, so there is no Compatibility Issue, and the CI type is 0."
679,"<android.view.inputmethod.InputMethodManager: void setInputMethod(IBinder,String)>",27,28,"<android.view.inputmethod.InputMethodManager: void setInputMethod(IBinder,String)>","<android.view.inputmethod.InputMethodManager: void setInputMethod(IBinder,String)>",0,"{
    try {
        mService.setInputMethod(token, id);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}","{
    setInputMethodInternal(token, id);
}",1,"/**
 * Force switch to a new input method component. This can only be called
 * from an application or a service which has a token of the currently active input method.
 * @param token Supplies the identifying token given to an input method
 * when it was started, which allows it to perform this operation on
 * itself.
 * @param id The unique identifier for the new input method to be switched to.
 */
","/**
 * Force switch to a new input method component. This can only be called
 * from an application or a service which has a token of the currently active input method.
 * @param token Supplies the identifying token given to an input method
 * when it was started, which allows it to perform this operation on
 * itself.
 * @param id The unique identifier for the new input method to be switched to.
 * @deprecated Use {@link InputMethodService#switchInputMethod(String)}
 * instead. This method was intended for IME developers who should be accessing APIs through
 * the service. APIs in this class are intended for app developers interacting with the IME.
 */
",-1,,[@Deprecated],-1,-1,-1,-1,-1,-1,"4,5",0,"The implementation has changed from a direct method call to a RemoteException-throwing block to a call to another internal method setInputMethodInternal(token, id), which represents a change type of 4,5. This indicates a change in the internal implementation of the method without knowledge of the behavior of the new method being called.","Without information on what setInputMethodInternal(token, id) does internally, it's not possible to determine if there's a change in the exception handling or the return type/value. Hence, based on the given information, no CI can be detected, so the CI type is 0."
680,"<android.net.IpSecTransform.Builder: Builder setIpv4Encapsulation(UdpEncapsulationSocket,int)>",27,28,"<android.net.IpSecTransform.Builder: Builder setIpv4Encapsulation(UdpEncapsulationSocket,int)>","<android.net.IpSecTransform.Builder: Builder setIpv4Encapsulation(UdpEncapsulationSocket,int)>",0,"{
    // TODO: check encap type is valid.
    mConfig.encapType = ENCAP_ESPINUDP;
    mConfig.encapLocalPortResourceId = localSocket.getResourceId();
    mConfig.encapRemotePort = remotePort;
    return this;
}","{
    Preconditions.checkNotNull(localSocket);
    mConfig.setEncapType(ENCAP_ESPINUDP);
    if (localSocket.getResourceId() == INVALID_RESOURCE_ID) {
        throw new IllegalArgumentException(""Invalid UdpEncapsulationSocket"");
    }
    mConfig.setEncapSocketResourceId(localSocket.getResourceId());
    mConfig.setEncapRemotePort(remotePort);
    return this;
}",1,"/**
 * Add UDP encapsulation to an IPv4 transform
 *
 * <p>This option allows IPsec traffic to pass through NAT. Refer to RFC 3947 and 3948 for
 * details on how UDP should be applied to IPsec.
 *
 * @param localSocket a {@link IpSecManager.UdpEncapsulationSocket} for sending and
 * receiving encapsulating traffic.
 * @param remotePort the UDP port number of the remote that will send and receive
 * encapsulated traffic. In the case of IKE, this is likely port 4500.
 */
","/**
 * Add UDP encapsulation to an IPv4 transform.
 *
 * <p>This allows IPsec traffic to pass through a NAT.
 *
 * @see <a href=""https://tools.ietf.org/html/rfc3948"">RFC 3948, UDP Encapsulation of IPsec
 * ESP Packets</a>
 * @see <a href=""https://tools.ietf.org/html/rfc7296#section-2.23"">RFC 7296 section 2.23,
 * NAT Traversal of IKEv2</a>
 * @param localSocket a socket for sending and receiving encapsulated traffic
 * @param remotePort the UDP port number of the remote host that will send and receive
 * encapsulated traffic. In the case of IKEv2, this should be port 4500.
 */
",-1,,[@NonNull],-1,-1,-1,-1,-1,-1,"1,2,4,5","1,2","The method now includes a check for the non-nullity of `localSocket` and checks for `localSocket.getResourceId()` to be not equal to `INVALID_RESOURCE_ID`, throwing an IllegalArgumentException if it is. Calls to set values in `mConfig` have been changed to method calls instead of direct field accesses, indicating a change in the implementation of how encapsulation configuration is being set. Also, the way how `encapType` is set has changed from a direct field assignment to a method call, which could change how the configuration is internally handled. Hence, the code change types are 1,2,4,5.","The introduction of Preconditions.checkNotNull() adds a new potential NullPointerException if `localSocket` is null, which did not exist before, this indicates a CI due to new exception handling - type 2. The IllegalArgumentException thrown when the `getResourceId()` returns an `INVALID_RESOURCE_ID` adds a new potential throw which did not exist before, thus introducing another CI due to different exception handling - type 2. "
681,<android.view.WindowInsets: boolean hasInsets()>,27,28,<android.view.WindowInsets: boolean hasInsets()>,<android.view.WindowInsets: boolean hasInsets()>,0,"{
    return hasSystemWindowInsets() || hasWindowDecorInsets() || hasStableInsets();
}","{
    return hasSystemWindowInsets() || hasWindowDecorInsets() || hasStableInsets() || mDisplayCutout != null;
}",1,"/**
 * Returns true if this WindowInsets has any nonzero insets.
 *
 * @return true if any inset values are nonzero
 */
","/**
 * Returns true if this WindowInsets has any nonzero insets.
 *
 * @return true if any inset values are nonzero
 */
",-1,,,-1,-1,-1,-1,-1,-1,1,1,"The return statement in the late version adds condition `mDisplayCutout != null`, which is not present in the early version. Hence, the change type is 1.","With the introduction of a new condition `mDisplayCutout != null`, the late version of the API could potentially return a different boolean value. Consequently, the CI type is 1."
683,<android.bluetooth.BluetoothAdapter: boolean isLeExtendedAdvertisingSupported()>,27,28,<android.bluetooth.BluetoothAdapter: boolean isLeExtendedAdvertisingSupported()>,<android.bluetooth.BluetoothAdapter: boolean isLeExtendedAdvertisingSupported()>,0,"{
    if (!getLeAccess())
        return false;
    try {
        mServiceLock.readLock().lock();
        if (mService != null)
            return mService.isLeExtendedAdvertisingSupported();
    } catch (RemoteException e) {
        Log.e(TAG, ""failed to get isLeExtendedAdvertisingSupported, error: "", e);
    } finally {
        mServiceLock.readLock().unlock();
    }
    return false;
}","{
    if (!getLeAccess()) {
        return false;
    }
    try {
        mServiceLock.readLock().lock();
        if (mService != null) {
            return mService.isLeExtendedAdvertisingSupported();
        }
    } catch (RemoteException e) {
        Log.e(TAG, ""failed to get isLeExtendedAdvertisingSupported, error: "", e);
    } finally {
        mServiceLock.readLock().unlock();
    }
    return false;
}",1,"/**
 * Return true if LE Extended Advertising feature is supported.
 *
 * @return true if chipset supports LE Extended Advertising feature
 */
","/**
 * Return true if LE Extended Advertising feature is supported.
 *
 * @return true if chipset supports LE Extended Advertising feature
 */
",-1,,,-1,-1,-1,-1,-1,-1,0,0,"The code has not changed, only the formatting of braces has been adjusted, which does not affect the functionality of the API at all.","As there is no change in the code's logic, return values, exception handling, or control structures, there are no compatibility issues between the early version and the late version."
684,<android.hardware.SystemSensorManager.BaseEventQueue: int flush()>,27,28,<android.hardware.SystemSensorManager.BaseEventQueue: int flush()>,<android.hardware.SystemSensorManager.BaseEventQueue: int flush()>,0,"{
    if (nSensorEventQueue == 0)
        throw new NullPointerException();
    return nativeFlushSensor(nSensorEventQueue);
}","{
    if (mNativeSensorEventQueue == 0)
        throw new NullPointerException();
    return nativeFlushSensor(mNativeSensorEventQueue);
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,4,0,"The variable name has changed from 'nSensorEventQueue' to 'mNativeSensorEventQueue', which is a refactoring that doesn't affect the behavior of the API. So the code change type is 4.","There is no Compatibility Issue; both versions throw the same exception under the same condition and return the result of the same method called with what is assumed to be an equivalent variable, just renamed. Thus, the CI type is 0."
685,"<android.bluetooth.BluetoothGattService: BluetoothGattCharacteristic getCharacteristic(UUID,int)>",27,28,"<android.bluetooth.BluetoothGattService: BluetoothGattCharacteristic getCharacteristic(UUID,int)>","<android.bluetooth.BluetoothGattService: BluetoothGattCharacteristic getCharacteristic(UUID,int)>",0,"{
    for (BluetoothGattCharacteristic characteristic : mCharacteristics) {
        if (uuid.equals(characteristic.getUuid()) && characteristic.getInstanceId() == instanceId)
            return characteristic;
    }
    return null;
}","{
    for (BluetoothGattCharacteristic characteristic : mCharacteristics) {
        if (uuid.equals(characteristic.getUuid()) && characteristic.getInstanceId() == instanceId) {
            return characteristic;
        }
    }
    return null;
}",1,"/*package*/
","/*package*/
",-1,,,-1,-1,-1,-1,-1,-1,0,0,The implementation between the two versions is functionally identical; only the code formatting has changed with the addition of braces around the return statement in the 'if' block. This change does not alter the behavior.,There is no Compatibility Issue as the logic and behavior of the method have not changed.
687,"<android.app.usage.UsageStatsManager: List<UsageStats> queryUsageStats(int,long,long)>",27,28,"<android.app.usage.UsageStatsManager: List<UsageStats> queryUsageStats(int,long,long)>","<android.app.usage.UsageStatsManager: List<UsageStats> queryUsageStats(int,long,long)>",0,"{
    try {
        @SuppressWarnings(""unchecked"") ParceledListSlice<UsageStats> slice = mService.queryUsageStats(intervalType, beginTime, endTime, mContext.getOpPackageName());
        if (slice != null) {
            return slice.getList();
        }
    } catch (RemoteException e) {
    // fallthrough and return null.
    }
    return Collections.emptyList();
}","{
    try {
        @SuppressWarnings(""unchecked"") ParceledListSlice<UsageStats> slice = mService.queryUsageStats(intervalType, beginTime, endTime, mContext.getOpPackageName());
        if (slice != null) {
            return slice.getList();
        }
    } catch (RemoteException e) {
    // fallthrough and return the empty list.
    }
    return Collections.emptyList();
}",1,"/**
 * Gets application usage stats for the given time range, aggregated by the specified interval.
 * <p>The returned list will contain a {@link UsageStats} object for each package that
 * has data for an interval that is a subset of the time range given. To illustrate:</p>
 * <pre>
 * intervalType = INTERVAL_YEARLY
 * beginTime = 2013
 * endTime = 2015 (exclusive)
 *
 * Results:
 * 2013 - com.example.alpha
 * 2013 - com.example.beta
 * 2014 - com.example.alpha
 * 2014 - com.example.beta
 * 2014 - com.example.charlie
 * </pre>
 *
 * @param intervalType The time interval by which the stats are aggregated.
 * @param beginTime The inclusive beginning of the range of stats to include in the results.
 * @param endTime The exclusive end of the range of stats to include in the results.
 * @return A list of {@link UsageStats} or null if none are available.
 *
 * @see #INTERVAL_DAILY
 * @see #INTERVAL_WEEKLY
 * @see #INTERVAL_MONTHLY
 * @see #INTERVAL_YEARLY
 * @see #INTERVAL_BEST
 */
","/**
 * Gets application usage stats for the given time range, aggregated by the specified interval.
 * <p>The returned list will contain a {@link UsageStats} object for each package that
 * has data for an interval that is a subset of the time range given. To illustrate:</p>
 * <pre>
 * intervalType = INTERVAL_YEARLY
 * beginTime = 2013
 * endTime = 2015 (exclusive)
 *
 * Results:
 * 2013 - com.example.alpha
 * 2013 - com.example.beta
 * 2014 - com.example.alpha
 * 2014 - com.example.beta
 * 2014 - com.example.charlie
 * </pre>
 *
 * <p> The caller must have {@link android.Manifest.permission#PACKAGE_USAGE_STATS} </p>
 *
 * @param intervalType The time interval by which the stats are aggregated.
 * @param beginTime The inclusive beginning of the range of stats to include in the results.
 * @param endTime The exclusive end of the range of stats to include in the results.
 * @return A list of {@link UsageStats}
 *
 * @see #INTERVAL_DAILY
 * @see #INTERVAL_WEEKLY
 * @see #INTERVAL_MONTHLY
 * @see #INTERVAL_YEARLY
 * @see #INTERVAL_BEST
 */
",-1,,,-1,-1,-1,-1,-1,-1,0,0,There is no actual code change; only a comment has been updated. The logic and flow of the API remain the same.,"As there is no code change, there is no Compatibility Issue between these two versions."
688,<android.view.WindowManager.LayoutParams: int copyFrom(LayoutParams)>,27,28,<android.view.WindowManager.LayoutParams: int copyFrom(LayoutParams)>,<android.view.WindowManager.LayoutParams: int copyFrom(LayoutParams)>,0,"{
    int changes = 0;
    if (width != o.width) {
        width = o.width;
        changes |= LAYOUT_CHANGED;
    }
    if (height != o.height) {
        height = o.height;
        changes |= LAYOUT_CHANGED;
    }
    if (x != o.x) {
        x = o.x;
        changes |= LAYOUT_CHANGED;
    }
    if (y != o.y) {
        y = o.y;
        changes |= LAYOUT_CHANGED;
    }
    if (horizontalWeight != o.horizontalWeight) {
        horizontalWeight = o.horizontalWeight;
        changes |= LAYOUT_CHANGED;
    }
    if (verticalWeight != o.verticalWeight) {
        verticalWeight = o.verticalWeight;
        changes |= LAYOUT_CHANGED;
    }
    if (horizontalMargin != o.horizontalMargin) {
        horizontalMargin = o.horizontalMargin;
        changes |= LAYOUT_CHANGED;
    }
    if (verticalMargin != o.verticalMargin) {
        verticalMargin = o.verticalMargin;
        changes |= LAYOUT_CHANGED;
    }
    if (type != o.type) {
        type = o.type;
        changes |= TYPE_CHANGED;
    }
    if (flags != o.flags) {
        final int diff = flags ^ o.flags;
        if ((diff & (FLAG_TRANSLUCENT_STATUS | FLAG_TRANSLUCENT_NAVIGATION)) != 0) {
            changes |= TRANSLUCENT_FLAGS_CHANGED;
        }
        flags = o.flags;
        changes |= FLAGS_CHANGED;
    }
    if (privateFlags != o.privateFlags) {
        privateFlags = o.privateFlags;
        changes |= PRIVATE_FLAGS_CHANGED;
    }
    if (softInputMode != o.softInputMode) {
        softInputMode = o.softInputMode;
        changes |= SOFT_INPUT_MODE_CHANGED;
    }
    if (gravity != o.gravity) {
        gravity = o.gravity;
        changes |= LAYOUT_CHANGED;
    }
    if (format != o.format) {
        format = o.format;
        changes |= FORMAT_CHANGED;
    }
    if (windowAnimations != o.windowAnimations) {
        windowAnimations = o.windowAnimations;
        changes |= ANIMATION_CHANGED;
    }
    if (token == null) {
        // NOTE: token only copied if the recipient doesn't
        // already have one.
        token = o.token;
    }
    if (packageName == null) {
        // NOTE: packageName only copied if the recipient doesn't
        // already have one.
        packageName = o.packageName;
    }
    if (!Objects.equals(mTitle, o.mTitle) && o.mTitle != null) {
        // NOTE: mTitle only copied if the originator set one.
        mTitle = o.mTitle;
        changes |= TITLE_CHANGED;
    }
    if (alpha != o.alpha) {
        alpha = o.alpha;
        changes |= ALPHA_CHANGED;
    }
    if (dimAmount != o.dimAmount) {
        dimAmount = o.dimAmount;
        changes |= DIM_AMOUNT_CHANGED;
    }
    if (screenBrightness != o.screenBrightness) {
        screenBrightness = o.screenBrightness;
        changes |= SCREEN_BRIGHTNESS_CHANGED;
    }
    if (buttonBrightness != o.buttonBrightness) {
        buttonBrightness = o.buttonBrightness;
        changes |= BUTTON_BRIGHTNESS_CHANGED;
    }
    if (rotationAnimation != o.rotationAnimation) {
        rotationAnimation = o.rotationAnimation;
        changes |= ROTATION_ANIMATION_CHANGED;
    }
    if (screenOrientation != o.screenOrientation) {
        screenOrientation = o.screenOrientation;
        changes |= SCREEN_ORIENTATION_CHANGED;
    }
    if (preferredRefreshRate != o.preferredRefreshRate) {
        preferredRefreshRate = o.preferredRefreshRate;
        changes |= PREFERRED_REFRESH_RATE_CHANGED;
    }
    if (preferredDisplayModeId != o.preferredDisplayModeId) {
        preferredDisplayModeId = o.preferredDisplayModeId;
        changes |= PREFERRED_DISPLAY_MODE_ID;
    }
    if (systemUiVisibility != o.systemUiVisibility || subtreeSystemUiVisibility != o.subtreeSystemUiVisibility) {
        systemUiVisibility = o.systemUiVisibility;
        subtreeSystemUiVisibility = o.subtreeSystemUiVisibility;
        changes |= SYSTEM_UI_VISIBILITY_CHANGED;
    }
    if (hasSystemUiListeners != o.hasSystemUiListeners) {
        hasSystemUiListeners = o.hasSystemUiListeners;
        changes |= SYSTEM_UI_LISTENER_CHANGED;
    }
    if (inputFeatures != o.inputFeatures) {
        inputFeatures = o.inputFeatures;
        changes |= INPUT_FEATURES_CHANGED;
    }
    if (userActivityTimeout != o.userActivityTimeout) {
        userActivityTimeout = o.userActivityTimeout;
        changes |= USER_ACTIVITY_TIMEOUT_CHANGED;
    }
    if (!surfaceInsets.equals(o.surfaceInsets)) {
        surfaceInsets.set(o.surfaceInsets);
        changes |= SURFACE_INSETS_CHANGED;
    }
    if (hasManualSurfaceInsets != o.hasManualSurfaceInsets) {
        hasManualSurfaceInsets = o.hasManualSurfaceInsets;
        changes |= SURFACE_INSETS_CHANGED;
    }
    if (preservePreviousSurfaceInsets != o.preservePreviousSurfaceInsets) {
        preservePreviousSurfaceInsets = o.preservePreviousSurfaceInsets;
        changes |= SURFACE_INSETS_CHANGED;
    }
    if (needsMenuKey != o.needsMenuKey) {
        needsMenuKey = o.needsMenuKey;
        changes |= NEEDS_MENU_KEY_CHANGED;
    }
    if (accessibilityIdOfAnchor != o.accessibilityIdOfAnchor) {
        accessibilityIdOfAnchor = o.accessibilityIdOfAnchor;
        changes |= ACCESSIBILITY_ANCHOR_CHANGED;
    }
    if (!Objects.equals(accessibilityTitle, o.accessibilityTitle) && o.accessibilityTitle != null) {
        // NOTE: accessibilityTitle only copied if the originator set one.
        accessibilityTitle = o.accessibilityTitle;
        changes |= ACCESSIBILITY_TITLE_CHANGED;
    }
    if (mColorMode != o.mColorMode) {
        mColorMode = o.mColorMode;
        changes |= COLOR_MODE_CHANGED;
    }
    // This can't change, it's only set at window creation time.
    hideTimeoutMilliseconds = o.hideTimeoutMilliseconds;
    return changes;
}","{
    int changes = 0;
    if (width != o.width) {
        width = o.width;
        changes |= LAYOUT_CHANGED;
    }
    if (height != o.height) {
        height = o.height;
        changes |= LAYOUT_CHANGED;
    }
    if (x != o.x) {
        x = o.x;
        changes |= LAYOUT_CHANGED;
    }
    if (y != o.y) {
        y = o.y;
        changes |= LAYOUT_CHANGED;
    }
    if (horizontalWeight != o.horizontalWeight) {
        horizontalWeight = o.horizontalWeight;
        changes |= LAYOUT_CHANGED;
    }
    if (verticalWeight != o.verticalWeight) {
        verticalWeight = o.verticalWeight;
        changes |= LAYOUT_CHANGED;
    }
    if (horizontalMargin != o.horizontalMargin) {
        horizontalMargin = o.horizontalMargin;
        changes |= LAYOUT_CHANGED;
    }
    if (verticalMargin != o.verticalMargin) {
        verticalMargin = o.verticalMargin;
        changes |= LAYOUT_CHANGED;
    }
    if (type != o.type) {
        type = o.type;
        changes |= TYPE_CHANGED;
    }
    if (flags != o.flags) {
        final int diff = flags ^ o.flags;
        if ((diff & (FLAG_TRANSLUCENT_STATUS | FLAG_TRANSLUCENT_NAVIGATION)) != 0) {
            changes |= TRANSLUCENT_FLAGS_CHANGED;
        }
        flags = o.flags;
        changes |= FLAGS_CHANGED;
    }
    if (privateFlags != o.privateFlags) {
        privateFlags = o.privateFlags;
        changes |= PRIVATE_FLAGS_CHANGED;
    }
    if (softInputMode != o.softInputMode) {
        softInputMode = o.softInputMode;
        changes |= SOFT_INPUT_MODE_CHANGED;
    }
    if (layoutInDisplayCutoutMode != o.layoutInDisplayCutoutMode) {
        layoutInDisplayCutoutMode = o.layoutInDisplayCutoutMode;
        changes |= LAYOUT_CHANGED;
    }
    if (gravity != o.gravity) {
        gravity = o.gravity;
        changes |= LAYOUT_CHANGED;
    }
    if (format != o.format) {
        format = o.format;
        changes |= FORMAT_CHANGED;
    }
    if (windowAnimations != o.windowAnimations) {
        windowAnimations = o.windowAnimations;
        changes |= ANIMATION_CHANGED;
    }
    if (token == null) {
        // NOTE: token only copied if the recipient doesn't
        // already have one.
        token = o.token;
    }
    if (packageName == null) {
        // NOTE: packageName only copied if the recipient doesn't
        // already have one.
        packageName = o.packageName;
    }
    if (!Objects.equals(mTitle, o.mTitle) && o.mTitle != null) {
        // NOTE: mTitle only copied if the originator set one.
        mTitle = o.mTitle;
        changes |= TITLE_CHANGED;
    }
    if (alpha != o.alpha) {
        alpha = o.alpha;
        changes |= ALPHA_CHANGED;
    }
    if (dimAmount != o.dimAmount) {
        dimAmount = o.dimAmount;
        changes |= DIM_AMOUNT_CHANGED;
    }
    if (screenBrightness != o.screenBrightness) {
        screenBrightness = o.screenBrightness;
        changes |= SCREEN_BRIGHTNESS_CHANGED;
    }
    if (buttonBrightness != o.buttonBrightness) {
        buttonBrightness = o.buttonBrightness;
        changes |= BUTTON_BRIGHTNESS_CHANGED;
    }
    if (rotationAnimation != o.rotationAnimation) {
        rotationAnimation = o.rotationAnimation;
        changes |= ROTATION_ANIMATION_CHANGED;
    }
    if (screenOrientation != o.screenOrientation) {
        screenOrientation = o.screenOrientation;
        changes |= SCREEN_ORIENTATION_CHANGED;
    }
    if (preferredRefreshRate != o.preferredRefreshRate) {
        preferredRefreshRate = o.preferredRefreshRate;
        changes |= PREFERRED_REFRESH_RATE_CHANGED;
    }
    if (preferredDisplayModeId != o.preferredDisplayModeId) {
        preferredDisplayModeId = o.preferredDisplayModeId;
        changes |= PREFERRED_DISPLAY_MODE_ID;
    }
    if (systemUiVisibility != o.systemUiVisibility || subtreeSystemUiVisibility != o.subtreeSystemUiVisibility) {
        systemUiVisibility = o.systemUiVisibility;
        subtreeSystemUiVisibility = o.subtreeSystemUiVisibility;
        changes |= SYSTEM_UI_VISIBILITY_CHANGED;
    }
    if (hasSystemUiListeners != o.hasSystemUiListeners) {
        hasSystemUiListeners = o.hasSystemUiListeners;
        changes |= SYSTEM_UI_LISTENER_CHANGED;
    }
    if (inputFeatures != o.inputFeatures) {
        inputFeatures = o.inputFeatures;
        changes |= INPUT_FEATURES_CHANGED;
    }
    if (userActivityTimeout != o.userActivityTimeout) {
        userActivityTimeout = o.userActivityTimeout;
        changes |= USER_ACTIVITY_TIMEOUT_CHANGED;
    }
    if (!surfaceInsets.equals(o.surfaceInsets)) {
        surfaceInsets.set(o.surfaceInsets);
        changes |= SURFACE_INSETS_CHANGED;
    }
    if (hasManualSurfaceInsets != o.hasManualSurfaceInsets) {
        hasManualSurfaceInsets = o.hasManualSurfaceInsets;
        changes |= SURFACE_INSETS_CHANGED;
    }
    if (preservePreviousSurfaceInsets != o.preservePreviousSurfaceInsets) {
        preservePreviousSurfaceInsets = o.preservePreviousSurfaceInsets;
        changes |= SURFACE_INSETS_CHANGED;
    }
    if (needsMenuKey != o.needsMenuKey) {
        needsMenuKey = o.needsMenuKey;
        changes |= NEEDS_MENU_KEY_CHANGED;
    }
    if (accessibilityIdOfAnchor != o.accessibilityIdOfAnchor) {
        accessibilityIdOfAnchor = o.accessibilityIdOfAnchor;
        changes |= ACCESSIBILITY_ANCHOR_CHANGED;
    }
    if (!Objects.equals(accessibilityTitle, o.accessibilityTitle) && o.accessibilityTitle != null) {
        // NOTE: accessibilityTitle only copied if the originator set one.
        accessibilityTitle = o.accessibilityTitle;
        changes |= ACCESSIBILITY_TITLE_CHANGED;
    }
    if (mColorMode != o.mColorMode) {
        mColorMode = o.mColorMode;
        changes |= COLOR_MODE_CHANGED;
    }
    // This can't change, it's only set at window creation time.
    hideTimeoutMilliseconds = o.hideTimeoutMilliseconds;
    return changes;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,,,,
689,<android.app.job.JobWorkItem: String toString()>,27,28,<android.app.job.JobWorkItem: String toString()>,<android.app.job.JobWorkItem: String toString()>,0,"{
    StringBuilder sb = new StringBuilder(64);
    sb.append(""JobWorkItem{id="");
    sb.append(mWorkId);
    sb.append("" intent="");
    sb.append(mIntent);
    if (mDeliveryCount != 0) {
        sb.append("" dcount="");
        sb.append(mDeliveryCount);
    }
    sb.append(""}"");
    return sb.toString();
}","{
    StringBuilder sb = new StringBuilder(64);
    sb.append(""JobWorkItem{id="");
    sb.append(mWorkId);
    sb.append("" intent="");
    sb.append(mIntent);
    if (mNetworkDownloadBytes != NETWORK_BYTES_UNKNOWN) {
        sb.append("" downloadBytes="");
        sb.append(mNetworkDownloadBytes);
    }
    if (mNetworkUploadBytes != NETWORK_BYTES_UNKNOWN) {
        sb.append("" uploadBytes="");
        sb.append(mNetworkUploadBytes);
    }
    if (mDeliveryCount != 0) {
        sb.append("" dcount="");
        sb.append(mDeliveryCount);
    }
    sb.append(""}"");
    return sb.toString();
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"3,4",0,"The implementation of the toString() method has been revised to include additional information about network bytes for download and upload if conditions are met, while keeping previous information about the delivery count as well. This includes introducing new control dependencies for appending download and upload bytes, as well as other statement changes for adding this new data. Hence, the change types are 3 for the control dependency change and 4 for the other statement changes.","There is no Compatibility Issue because the changes to the toString() method only affect the output string, which does not influence the behavior or functionality of the API. It purely affects the string representation of the object, which is typically used for logging or debugging purposes. Therefore, this change should not affect existing code that uses this API for its intended functionality, and the calling code should not have to handle different types of return values or exceptions as a consequence of the change."
690,<android.app.NotificationChannelGroup: NotificationChannelGroup clone()>,27,28,<android.app.NotificationChannelGroup: NotificationChannelGroup clone()>,<android.app.NotificationChannelGroup: NotificationChannelGroup clone()>,0,"{
    return new NotificationChannelGroup(getId(), getName());
}","{
    NotificationChannelGroup cloned = new NotificationChannelGroup(getId(), getName());
    cloned.setDescription(getDescription());
    cloned.setBlocked(isBlocked());
    cloned.setChannels(getChannels());
    return cloned;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,4",1,"In the late implementation, there are additional statements to set the description, blocked state, and channels of the cloned object, which were not present in the early version. This constitutes other statement changes and a change in the return statement, because the returned object now has more fields set than in the early version, so the code change types are 1 and 4.","The cloned object in the late version has more fields set (description, blocked state, and channels) than in the early version. This leads to a CI caused by potentially different return values (in this case, different state of the returned object), so the CI type is 1."
691,<android.view.textclassifier.TextClassification.Builder: Builder setIcon(Drawable)>,27,28,<android.view.textclassifier.TextClassification.Builder: Builder setIcon(Drawable)>,<android.view.textclassifier.TextClassification.Builder: Builder setIcon(Drawable)>,0,"{
    mIcon = icon;
    return this;
}","{
    mLegacyIcon = icon;
    return this;
}",1,"/**
 * Sets an icon that may be rendered on a widget used to act on the classified text.
 */
","/**
 * Sets the icon for the <i>primary</i> action that may be rendered on a widget used to act
 * on the classified text.
 *
 * <p><strong>NOTE: </strong>This field is not parcelled. If read from a parcel, the
 * returned icon represents the icon of the first {@link RemoteAction} (if one exists).
 *
 * @deprecated Use {@link #addAction(RemoteAction)} instead.
 */
",-1,,"[@Deprecated, @NonNull]",-1,-1,-1,-1,-1,-1,4,0,"The field that gets assigned has changed from `mIcon` to `mLegacyIcon`, which indicates that while a different field is now set, the method's return type and behavior haven't changed because it still returns `this`. This change falls under the category of 'Other statement changed'.","There is no compatibility issue here as the method's contract remains the same. It takes the same input and its observable behavior (from the perspective of the method's return value and exception handling) remains consistent with the previous version, despite the internal state that is being changed."
692,"<android.transition.ArcMotion: Path getPath(float,float,float,float)>",27,28,"<android.transition.ArcMotion: Path getPath(float,float,float,float)>","<android.transition.ArcMotion: Path getPath(float,float,float,float)>",0,"{
    // Here's a little ascii art to show how this is calculated:
    // c---------- b
    // \        / |
    // \     d  |
    // \  /   e
    // a----f
    // This diagram assumes that the horizontal distance is less than the vertical
    // distance between The start point (a) and end point (b).
    // d is the midpoint between a and b. c is the center point of the circle with
    // This path is formed by assuming that start and end points are in
    // an arc on a circle. The end point is centered in the circle vertically
    // and start is a point on the circle.
    // Triangles bfa and bde form similar right triangles. The control points
    // for the cubic Bezier arc path are the midpoints between a and e and e and b.
    Path path = new Path();
    path.moveTo(startX, startY);
    float ex;
    float ey;
    float deltaX = endX - startX;
    float deltaY = endY - startY;
    // hypotenuse squared.
    float h2 = deltaX * deltaX + deltaY * deltaY;
    // Midpoint between start and end
    float dx = (startX + endX) / 2;
    float dy = (startY + endY) / 2;
    // Distance squared between end point and mid point is (1/2 hypotenuse)^2
    float midDist2 = h2 * 0.25f;
    float minimumArcDist2 = 0;
    boolean isMovingUpwards = startY > endY;
    if ((Math.abs(deltaX) < Math.abs(deltaY))) {
        // Similar triangles bfa and bde mean that (ab/fb = eb/bd)
        // Therefore, eb = ab * bd / fb
        // ab = hypotenuse
        // bd = hypotenuse/2
        // fb = deltaY
        float eDistY = Math.abs(h2 / (2 * deltaY));
        if (isMovingUpwards) {
            ey = endY + eDistY;
            ex = endX;
        } else {
            ey = startY + eDistY;
            ex = startX;
        }
        minimumArcDist2 = midDist2 * mMinimumVerticalTangent * mMinimumVerticalTangent;
    } else {
        // Same as above, but flip X & Y and account for negative eDist
        float eDistX = h2 / (2 * deltaX);
        if (isMovingUpwards) {
            ex = startX + eDistX;
            ey = startY;
        } else {
            ex = endX - eDistX;
            ey = endY;
        }
        minimumArcDist2 = midDist2 * mMinimumHorizontalTangent * mMinimumHorizontalTangent;
    }
    float arcDistX = dx - ex;
    float arcDistY = dy - ey;
    float arcDist2 = arcDistX * arcDistX + arcDistY * arcDistY;
    float maximumArcDist2 = midDist2 * mMaximumTangent * mMaximumTangent;
    float newArcDistance2 = 0;
    if (arcDist2 < minimumArcDist2) {
        newArcDistance2 = minimumArcDist2;
    } else if (arcDist2 > maximumArcDist2) {
        newArcDistance2 = maximumArcDist2;
    }
    if (newArcDistance2 != 0) {
        float ratio2 = newArcDistance2 / arcDist2;
        float ratio = (float) Math.sqrt(ratio2);
        ex = dx + (ratio * (ex - dx));
        ey = dy + (ratio * (ey - dy));
    }
    float control1X = (startX + ex) / 2;
    float control1Y = (startY + ey) / 2;
    float control2X = (ex + endX) / 2;
    float control2Y = (ey + endY) / 2;
    path.cubicTo(control1X, control1Y, control2X, control2Y, endX, endY);
    return path;
}","{
    // Here's a little ascii art to show how this is calculated:
    // c---------- b
    // \        / |
    // \     d  |
    // \  /   e
    // a----f
    // This diagram assumes that the horizontal distance is less than the vertical
    // distance between The start point (a) and end point (b).
    // d is the midpoint between a and b. c is the center point of the circle with
    // This path is formed by assuming that start and end points are in
    // an arc on a circle. The end point is centered in the circle vertically
    // and start is a point on the circle.
    // Triangles bfa and bde form similar right triangles. The control points
    // for the cubic Bezier arc path are the midpoints between a and e and e and b.
    Path path = new Path();
    path.moveTo(startX, startY);
    float ex;
    float ey;
    float deltaX = endX - startX;
    float deltaY = endY - startY;
    // hypotenuse squared.
    float h2 = deltaX * deltaX + deltaY * deltaY;
    // Midpoint between start and end
    float dx = (startX + endX) / 2;
    float dy = (startY + endY) / 2;
    // Distance squared between end point and mid point is (1/2 hypotenuse)^2
    float midDist2 = h2 * 0.25f;
    float minimumArcDist2 = 0;
    boolean isMovingUpwards = startY > endY;
    if (deltaY == 0) {
        ex = dx;
        ey = dy + (Math.abs(deltaX) * 0.5f * mMinimumHorizontalTangent);
    } else if (deltaX == 0) {
        ex = dx + (Math.abs(deltaY) * 0.5f * mMinimumVerticalTangent);
        ey = dy;
    } else if ((Math.abs(deltaX) < Math.abs(deltaY))) {
        // Similar triangles bfa and bde mean that (ab/fb = eb/bd)
        // Therefore, eb = ab * bd / fb
        // ab = hypotenuse
        // bd = hypotenuse/2
        // fb = deltaY
        float eDistY = Math.abs(h2 / (2 * deltaY));
        if (isMovingUpwards) {
            ey = endY + eDistY;
            ex = endX;
        } else {
            ey = startY + eDistY;
            ex = startX;
        }
        minimumArcDist2 = midDist2 * mMinimumVerticalTangent * mMinimumVerticalTangent;
    } else {
        // Same as above, but flip X & Y and account for negative eDist
        float eDistX = h2 / (2 * deltaX);
        if (isMovingUpwards) {
            ex = startX + eDistX;
            ey = startY;
        } else {
            ex = endX - eDistX;
            ey = endY;
        }
        minimumArcDist2 = midDist2 * mMinimumHorizontalTangent * mMinimumHorizontalTangent;
    }
    float arcDistX = dx - ex;
    float arcDistY = dy - ey;
    float arcDist2 = arcDistX * arcDistX + arcDistY * arcDistY;
    float maximumArcDist2 = midDist2 * mMaximumTangent * mMaximumTangent;
    float newArcDistance2 = 0;
    if (arcDist2 != 0 && arcDist2 < minimumArcDist2) {
        newArcDistance2 = minimumArcDist2;
    } else if (arcDist2 > maximumArcDist2) {
        newArcDistance2 = maximumArcDist2;
    }
    if (newArcDistance2 != 0) {
        float ratio2 = newArcDistance2 / arcDist2;
        float ratio = (float) Math.sqrt(ratio2);
        ex = dx + (ratio * (ex - dx));
        ey = dy + (ratio * (ey - dy));
    }
    float control1X = (startX + ex) / 2;
    float control1Y = (startY + ey) / 2;
    float control2X = (ex + endX) / 2;
    float control2Y = (ey + endY) / 2;
    path.cubicTo(control1X, control1Y, control2X, control2Y, endX, endY);
    return path;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,,,,
693,<android.app.Activity: void performPause()>,27,28,<android.app.Activity: void performPause()>,<android.app.Activity: void performPause()>,0,"{
    mDoReportFullyDrawn = false;
    mFragments.dispatchPause();
    mCalled = false;
    onPause();
    mResumed = false;
    if (!mCalled && getApplicationInfo().targetSdkVersion >= android.os.Build.VERSION_CODES.GINGERBREAD) {
        throw new SuperNotCalledException(""Activity "" + mComponent.toShortString() + "" did not call through to super.onPause()"");
    }
    mResumed = false;
}","{
    mDoReportFullyDrawn = false;
    mFragments.dispatchPause();
    mCalled = false;
    onPause();
    writeEventLog(LOG_AM_ON_PAUSE_CALLED, ""performPause"");
    mResumed = false;
    if (!mCalled && getApplicationInfo().targetSdkVersion >= android.os.Build.VERSION_CODES.GINGERBREAD) {
        throw new SuperNotCalledException(""Activity "" + mComponent.toShortString() + "" did not call through to super.onPause()"");
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,4,0,"The late implementation includes an additional call to writeEventLog(LOG_AM_ON_PAUSE_CALLED, ""performPause"") that the early version does not have, which is an other statement change, so the code change type is 4.","The added call to writeEventLog does not affect the return value or exception that the method may throw; it just logs an event. Therefore, there is no Compatibility Issue, and CI type is 0."
695,"<android.app.usage.NetworkStatsManager: NetworkStats querySummary(int,String,long,long)>",27,28,"<android.app.usage.NetworkStatsManager: NetworkStats querySummary(int,String,long,long)>","<android.app.usage.NetworkStatsManager: NetworkStats querySummary(int,String,long,long)>",0,"{
    NetworkTemplate template;
    try {
        template = createTemplate(networkType, subscriberId);
    } catch (IllegalArgumentException e) {
        if (DBG)
            Log.e(TAG, ""Cannot create template"", e);
        return null;
    }
    NetworkStats result;
    result = new NetworkStats(mContext, template, mFlags, startTime, endTime);
    result.startSummaryEnumeration();
    return result;
}","{
    NetworkTemplate template;
    try {
        template = createTemplate(networkType, subscriberId);
    } catch (IllegalArgumentException e) {
        if (DBG)
            Log.e(TAG, ""Cannot create template"", e);
        return null;
    }
    NetworkStats result;
    result = new NetworkStats(mContext, template, mFlags, startTime, endTime, mService);
    result.startSummaryEnumeration();
    return result;
}",1,"/**
 * Query network usage statistics summaries. Result filtered to include only uids belonging to
 * calling user. Result is aggregated over time, hence all buckets will have the same start and
 * end timestamps. Not aggregated over state, uid, metered, or roaming. This means buckets'
 * start and end timestamps are going to be the same as the 'startTime' and 'endTime'
 * parameters. State, uid, metered, and roaming are going to vary, and tag is going to be the
 * same.
 *
 * @param networkType As defined in {@link ConnectivityManager}, e.g.
 * {@link ConnectivityManager#TYPE_MOBILE}, {@link ConnectivityManager#TYPE_WIFI}
 * etc.
 * @param subscriberId If applicable, the subscriber id of the network interface.
 * @param startTime Start of period. Defined in terms of ""Unix time"", see
 * {@link java.lang.System#currentTimeMillis}.
 * @param endTime End of period. Defined in terms of ""Unix time"", see
 * {@link java.lang.System#currentTimeMillis}.
 * @return Statistics object or null if permissions are insufficient or error happened during
 * statistics collection.
 */
","/**
 * Query network usage statistics summaries. Result filtered to include only uids belonging to
 * calling user. Result is aggregated over time, hence all buckets will have the same start and
 * end timestamps. Not aggregated over state, uid, default network, metered, or roaming. This
 * means buckets' start and end timestamps are going to be the same as the 'startTime' and
 * 'endTime' parameters. State, uid, metered, and roaming are going to vary, and tag is going to
 * be the same.
 *
 * @param networkType As defined in {@link ConnectivityManager}, e.g.
 * {@link ConnectivityManager#TYPE_MOBILE}, {@link ConnectivityManager#TYPE_WIFI}
 * etc.
 * @param subscriberId If applicable, the subscriber id of the network interface.
 * @param startTime Start of period. Defined in terms of ""Unix time"", see
 * {@link java.lang.System#currentTimeMillis}.
 * @param endTime End of period. Defined in terms of ""Unix time"", see
 * {@link java.lang.System#currentTimeMillis}.
 * @return Statistics object or null if permissions are insufficient or error happened during
 * statistics collection.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"The constructor call for `NetworkStats` has an additional parameter `mService` in the late version. So the dependent API (`NetworkStats` constructor) has changed. Therefore, the change type is 4,5.","This change modifies how the `NetworkStats` object is instantiated but does not affect the behavior of the `querySummary` method in terms of its return value or the exceptions it throws. The constructor is expected to handle the extra parameter internally without altering the behavior observed by the client code using the `querySummary` method. As such, there's no Compatibility Issue based on the information given; hence, the CI type is 0."
696,"<android.app.usage.NetworkStatsManager: void registerUsageCallback(int,String,long,UsageCallback,Handler)>",27,28,"<android.app.usage.NetworkStatsManager: void registerUsageCallback(int,String,long,UsageCallback,Handler)>","<android.app.usage.NetworkStatsManager: void registerUsageCallback(int,String,long,UsageCallback,Handler)>",0,"{
    checkNotNull(callback, ""UsageCallback cannot be null"");
    final Looper looper;
    if (handler == null) {
        looper = Looper.myLooper();
    } else {
        looper = handler.getLooper();
    }
    if (DBG) {
        Log.d(TAG, ""registerUsageCallback called with: {"" + "" networkType="" + networkType + "" subscriberId="" + subscriberId + "" thresholdBytes="" + thresholdBytes + "" }"");
    }
    NetworkTemplate template = createTemplate(networkType, subscriberId);
    DataUsageRequest request = new DataUsageRequest(DataUsageRequest.REQUEST_ID_UNSET, template, thresholdBytes);
    try {
        CallbackHandler callbackHandler = new CallbackHandler(looper, networkType, subscriberId, callback);
        callback.request = mService.registerUsageCallback(mContext.getOpPackageName(), request, new Messenger(callbackHandler), new Binder());
        if (DBG)
            Log.d(TAG, ""registerUsageCallback returned "" + callback.request);
        if (callback.request == null) {
            Log.e(TAG, ""Request from callback is null; should not happen"");
        }
    } catch (RemoteException e) {
        if (DBG)
            Log.d(TAG, ""Remote exception when registering callback"");
        throw e.rethrowFromSystemServer();
    }
}","{
    NetworkTemplate template = createTemplate(networkType, subscriberId);
    if (DBG) {
        Log.d(TAG, ""registerUsageCallback called with: {"" + "" networkType="" + networkType + "" subscriberId="" + subscriberId + "" thresholdBytes="" + thresholdBytes + "" }"");
    }
    registerUsageCallback(template, networkType, thresholdBytes, callback, handler);
}",1,"/**
 * Registers to receive notifications about data usage on specified networks.
 *
 * <p>The callbacks will continue to be called as long as the process is live or
 * {@link #unregisterUsageCallback} is called.
 *
 * @param networkType Type of network to monitor. Either
 * {@link ConnectivityManager#TYPE_MOBILE} or {@link ConnectivityManager#TYPE_WIFI}.
 * @param subscriberId If applicable, the subscriber id of the network interface.
 * @param thresholdBytes Threshold in bytes to be notified on.
 * @param callback The {@link UsageCallback} that the system will call when data usage
 * has exceeded the specified threshold.
 * @param handler to dispatch callback events through, otherwise if {@code null} it uses
 * the calling thread.
 */
","/**
 * Registers to receive notifications about data usage on specified networks.
 *
 * <p>The callbacks will continue to be called as long as the process is live or
 * {@link #unregisterUsageCallback} is called.
 *
 * @param networkType Type of network to monitor. Either
 * {@link ConnectivityManager#TYPE_MOBILE} or {@link ConnectivityManager#TYPE_WIFI}.
 * @param subscriberId If applicable, the subscriber id of the network interface.
 * @param thresholdBytes Threshold in bytes to be notified on.
 * @param callback The {@link UsageCallback} that the system will call when data usage
 * has exceeded the specified threshold.
 * @param handler to dispatch callback events through, otherwise if {@code null} it uses
 * the calling thread.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4,5",0,"The method implementation has been substantially refactored, including the removal of null checks and logging statements. Additionally, a direct service call has been replaced with another internal method call registerUsageCallback(template, networkType, thresholdBytes, callback, handler). The control flow has been changed with the direct calls to registerUsageCallback method without previous null checks for handler or callback. The code for constructing DataUsageRequest and the callbackHandler has been moved, which may be part of the newly referenced internal method. There are changes in control dependency (3) due to removal of null checks and logging condition, other statement changed (4), and a call to another method indicating a dependent API changed (5).","There is no Compatibility Issue detected since the refactor does not seem to affect the exposed behavior of the method to the callers. The creation of a NetworkTemplate, as well as the main logic behind the registration of usage callback, appears to be preserved. The changes primarily relate to internal code organization and logging which should not have an impact on the calling code or behavioral contract of the method."
697,<android.bluetooth.BluetoothAdapter: int getState()>,27,28,<android.bluetooth.BluetoothAdapter: int getState()>,<android.bluetooth.BluetoothAdapter: int getState()>,0,"{
    int state = BluetoothAdapter.STATE_OFF;
    try {
        mServiceLock.readLock().lock();
        if (mService != null) {
            state = mService.getState();
        }
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
    } finally {
        mServiceLock.readLock().unlock();
    }
    // Consider all internal states as OFF
    if (state == BluetoothAdapter.STATE_BLE_ON || state == BluetoothAdapter.STATE_BLE_TURNING_ON || state == BluetoothAdapter.STATE_BLE_TURNING_OFF) {
        if (VDBG)
            Log.d(TAG, ""Consider "" + BluetoothAdapter.nameForState(state) + "" state as OFF"");
        state = BluetoothAdapter.STATE_OFF;
    }
    if (VDBG)
        Log.d(TAG, """" + hashCode() + "": getState(). Returning "" + BluetoothAdapter.nameForState(state));
    return state;
}","{
    int state = BluetoothAdapter.STATE_OFF;
    try {
        mServiceLock.readLock().lock();
        if (mService != null) {
            state = mService.getState();
        }
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
    } finally {
        mServiceLock.readLock().unlock();
    }
    // Consider all internal states as OFF
    if (state == BluetoothAdapter.STATE_BLE_ON || state == BluetoothAdapter.STATE_BLE_TURNING_ON || state == BluetoothAdapter.STATE_BLE_TURNING_OFF) {
        if (VDBG) {
            Log.d(TAG, ""Consider "" + BluetoothAdapter.nameForState(state) + "" state as OFF"");
        }
        state = BluetoothAdapter.STATE_OFF;
    }
    if (VDBG) {
        Log.d(TAG, """" + hashCode() + "": getState(). Returning "" + BluetoothAdapter.nameForState(state));
    }
    return state;
}",1,"/**
 * Get the current state of the local Bluetooth adapter.
 * <p>Possible return values are
 * {@link #STATE_OFF},
 * {@link #STATE_TURNING_ON},
 * {@link #STATE_ON},
 * {@link #STATE_TURNING_OFF}.
 *
 * @return current state of Bluetooth adapter
 */
","/**
 * Get the current state of the local Bluetooth adapter.
 * <p>Possible return values are
 * {@link #STATE_OFF},
 * {@link #STATE_TURNING_ON},
 * {@link #STATE_ON},
 * {@link #STATE_TURNING_OFF}.
 *
 * @return current state of Bluetooth adapter
 */
",-1,"[@RequiresPermission(Manifest.permission.BLUETOOTH), @AdapterState]","[@RequiresPermission(Manifest.permission.BLUETOOTH), @AdapterState]",-1,-1,-1,-1,-1,-1,0,0,"There are no changes to the implementation of the code between early and late versions. The only differences are formatting changes, specifically the placement of braces for if statements, which do not affect the logic or behavior of the method.","As there are no changes in functionality or logic of the code, there is no Compatibility Issue between the two versions."
701,<android.content.res.AssetManager: long createTheme()>,27,28,<android.content.res.AssetManager: long createTheme()>,<android.content.res.AssetManager: long createTheme()>,0,"{
    synchronized (this) {
        if (!mOpen) {
            throw new RuntimeException(""Assetmanager has been closed"");
        }
        long res = newTheme();
        incRefsLocked(res);
        return res;
    }
}","{
    synchronized (this) {
        ensureValidLocked();
        long themePtr = nativeThemeCreate(mObject);
        incRefsLocked(themePtr);
        return themePtr;
    }
}",1,"/*package*/
",,-1,,,-1,-1,-1,-1,-1,-1,"1,3,4,5",1,"The createTheme() method has several changes. The early version used a check on the variable 'mOpen' with a manual throw of RuntimeException, while the later version uses a method call to 'ensureValidLocked()', which presumably does a similar validation check. The actual theme creation is changed from 'newTheme()' to 'nativeThemeCreate(mObject)', and the variable name for the theme pointer has been updated from 'res' to 'themePtr'. The method call to increment the reference count, 'incRefsLocked()', remains the same but with the updated variable as its argument. Therefore, the changes include return statement change, control dependency change, other statement change, and dependent API changed.","The replaced 'if' check with a different call to 'ensureValidLocked()' could potentially lead to different exceptions being thrown since the behavior within 'ensureValidLocked()' is not specified and could vary from the previous 'if' check. Additionally, the change from 'newTheme()' to 'nativeThemeCreate(mObject)' suggests a different mechanism of theme creation that could also result in a different return value. Therefore, a compatibility issue due to potentially different return values or types may arise."
702,<android.net.LinkProperties: String toString()>,27,28,<android.net.LinkProperties: String toString()>,<android.net.LinkProperties: String toString()>,0,"{
    String ifaceName = (mIfaceName == null ? """" : ""InterfaceName: "" + mIfaceName + "" "");
    String linkAddresses = ""LinkAddresses: ["";
    for (LinkAddress addr : mLinkAddresses) linkAddresses += addr.toString() + "","";
    linkAddresses += ""] "";
    String dns = ""DnsAddresses: ["";
    for (InetAddress addr : mDnses) dns += addr.getHostAddress() + "","";
    dns += ""] "";
    String domainName = ""Domains: "" + mDomains;
    String mtu = "" MTU: "" + mMtu;
    String tcpBuffSizes = """";
    if (mTcpBufferSizes != null) {
        tcpBuffSizes = "" TcpBufferSizes: "" + mTcpBufferSizes;
    }
    String routes = "" Routes: ["";
    for (RouteInfo route : mRoutes) routes += route.toString() + "","";
    routes += ""] "";
    String proxy = (mHttpProxy == null ? """" : "" HttpProxy: "" + mHttpProxy.toString() + "" "");
    String stacked = """";
    if (mStackedLinks.values().size() > 0) {
        stacked += "" Stacked: ["";
        for (LinkProperties link : mStackedLinks.values()) {
            stacked += "" ["" + link.toString() + "" ],"";
        }
        stacked += ""] "";
    }
    return ""{"" + ifaceName + linkAddresses + routes + dns + domainName + mtu + tcpBuffSizes + proxy + stacked + ""}"";
}","{
    String ifaceName = (mIfaceName == null ? """" : ""InterfaceName: "" + mIfaceName + "" "");
    String linkAddresses = ""LinkAddresses: ["";
    for (LinkAddress addr : mLinkAddresses) linkAddresses += addr.toString() + "","";
    linkAddresses += ""] "";
    String dns = ""DnsAddresses: ["";
    for (InetAddress addr : mDnses) dns += addr.getHostAddress() + "","";
    dns += ""] "";
    String usePrivateDns = ""UsePrivateDns: "" + mUsePrivateDns + "" "";
    String privateDnsServerName = """";
    if (privateDnsServerName != null) {
        privateDnsServerName = ""PrivateDnsServerName: "" + mPrivateDnsServerName + "" "";
    }
    String validatedPrivateDns = """";
    if (!mValidatedPrivateDnses.isEmpty()) {
        validatedPrivateDns = ""ValidatedPrivateDnsAddresses: ["";
        for (InetAddress addr : mValidatedPrivateDnses) {
            validatedPrivateDns += addr.getHostAddress() + "","";
        }
        validatedPrivateDns += ""] "";
    }
    String domainName = ""Domains: "" + mDomains;
    String mtu = "" MTU: "" + mMtu;
    String tcpBuffSizes = """";
    if (mTcpBufferSizes != null) {
        tcpBuffSizes = "" TcpBufferSizes: "" + mTcpBufferSizes;
    }
    String routes = "" Routes: ["";
    for (RouteInfo route : mRoutes) routes += route.toString() + "","";
    routes += ""] "";
    String proxy = (mHttpProxy == null ? """" : "" HttpProxy: "" + mHttpProxy.toString() + "" "");
    String stacked = """";
    if (mStackedLinks.values().size() > 0) {
        stacked += "" Stacked: ["";
        for (LinkProperties link : mStackedLinks.values()) {
            stacked += "" ["" + link.toString() + "" ],"";
        }
        stacked += ""] "";
    }
    return ""{"" + ifaceName + linkAddresses + routes + dns + usePrivateDns + privateDnsServerName + domainName + mtu + tcpBuffSizes + proxy + stacked + ""}"";
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,4",1,"Additional string concatenation operations for `usePrivateDns`, `privateDnsServerName`, and `validatedPrivateDns` are included in the late implementation, leading to additional information in the returned String. Also, the `domainName`, `mtu`, `tcpBuffSizes`, `proxy`, and `stacked` string concatenations have been reordered. This is regarded as Other statement changed (type 4) because it involves appending strings in different orders and adding new information (Return statement changed, type 1) since it affects the output of the `toString()` method.","The returned String of the `toString()` method will contain additional information and has a different order of the existing information, which introduces a Compatibility Issue by potentially returning a different value (type 1)."
703,<android.hardware.camera2.impl.CameraDeviceImpl: Builder createCaptureRequest(int)>,27,28,<android.hardware.camera2.impl.CameraDeviceImpl: Builder createCaptureRequest(int)>,<android.hardware.camera2.impl.CameraDeviceImpl: Builder createCaptureRequest(int)>,0,"{
    synchronized (mInterfaceLock) {
        checkIfCameraClosedOrInError();
        CameraMetadataNative templatedRequest = null;
        templatedRequest = mRemoteDevice.createDefaultRequest(templateType);
        // must be false in the default request.
        if (mAppTargetSdkVersion < Build.VERSION_CODES.O || templateType != TEMPLATE_STILL_CAPTURE) {
            overrideEnableZsl(templatedRequest, false);
        }
        CaptureRequest.Builder builder = new CaptureRequest.Builder(templatedRequest, /*reprocess*/
        false, CameraCaptureSession.SESSION_ID_NONE);
        return builder;
    }
}","{
    synchronized (mInterfaceLock) {
        checkIfCameraClosedOrInError();
        CameraMetadataNative templatedRequest = null;
        templatedRequest = mRemoteDevice.createDefaultRequest(templateType);
        // must be false in the default request.
        if (mAppTargetSdkVersion < Build.VERSION_CODES.O || templateType != TEMPLATE_STILL_CAPTURE) {
            overrideEnableZsl(templatedRequest, false);
        }
        CaptureRequest.Builder builder = new CaptureRequest.Builder(templatedRequest, /*reprocess*/
        false, CameraCaptureSession.SESSION_ID_NONE, getId(), /*physicalCameraIdSet*/
        null);
        return builder;
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,5",1,"The constructor call for `CaptureRequest.Builder` in the late implementation adds two more parameters: `getId()` and a `null` value for `physicalCameraIdSet`, which were not present in the early version. This means the dependent API `CaptureRequest.Builder` constructor has changed, so the code change types are 1 and 5.","Since the constructor for creating a new `CaptureRequest.Builder` instance now includes additional parameters, this could potentially lead to different behavior when the API is used. This counts as a Compatibility Issue due to the potential for different return values or types, thus the CI type is 1."
704,<android.hardware.camera2.impl.CallbackProxies.SessionStateCallbackProxy: void onConfigureFailed(CameraCaptureSession)>,27,28,<android.hardware.camera2.impl.CallbackProxies.SessionStateCallbackProxy: void onConfigureFailed(CameraCaptureSession)>,<android.hardware.camera2.impl.CallbackProxies.SessionStateCallbackProxy: void onConfigureFailed(CameraCaptureSession)>,0,"{
    mProxy.invoke(""onConfigureFailed"", session);
}","{
    final long ident = Binder.clearCallingIdentity();
    try {
        mExecutor.execute(() -> mCallback.onConfigureFailed(session));
    } finally {
        Binder.restoreCallingIdentity(ident);
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,4",0,"The implementation changed from using mProxy.invoke to using mExecutor.execute with a lambda expression and surrounding this change with Binder token management to preserve calling identity. The change types are 3, for the introduction of try-finally block, and 4 for changing the method of executing the callback.","Despite these changes, the behavior seen by the end user of this API would not be superficially altered, as the method still ultimately invokes the onConfigureFailed callback on the session. The changes are internal to how the callback is dispatched and does not affect the outward-facing API contract. Thus, there is no Compatibility Issue as the outward behavior of the method on being invoked should remain consistent with the previous implementation, and the return type is void, meaning no change to potential return values."
705,"<android.app.SharedPreferencesImpl.EditorImpl: Editor putString(String,String)>",27,28,"<android.app.SharedPreferencesImpl.EditorImpl: Editor putString(String,String)>","<android.app.SharedPreferencesImpl.EditorImpl: Editor putString(String,String)>",0,"{
    synchronized (mLock) {
        mModified.put(key, value);
        return this;
    }
}","{
    synchronized (mEditorLock) {
        mModified.put(key, value);
        return this;
    }
}",1,,,-1,,[@Override],-1,-1,-1,-1,-1,-1,4,0,"The change is related to the lock object in the synchronized block, which switched from `mLock` to `mEditorLock`. This is categorized as an ""Other statement changed"" since it does not fall into the other specified change types.","This change does not lead to a Compatibility Issue as it does not affect the return value, exception handling, or the control flow of the method. The method's behavior from the caller's perspective remains the same; it still puts a key-value pair in `mModified` and returns the `Editor` object."
707,"<android.provider.Settings.NameValueCache: String getStringForUser(ContentResolver,String,int)>",27,28,"<android.provider.Settings.NameValueCache: String getStringForUser(ContentResolver,String,int)>","<android.provider.Settings.NameValueCache: String getStringForUser(ContentResolver,String,int)>",0,"{
    final boolean isSelf = (userHandle == UserHandle.myUserId());
    if (isSelf) {
        synchronized (NameValueCache.this) {
            if (mGenerationTracker != null) {
                if (mGenerationTracker.isGenerationChanged()) {
                    if (DEBUG) {
                        Log.i(TAG, ""Generation changed for type:"" + mUri.getPath() + "" in package:"" + cr.getPackageName() + "" and user:"" + userHandle);
                    }
                    mValues.clear();
                } else if (mValues.containsKey(name)) {
                    return mValues.get(name);
                }
            }
        }
    } else {
        if (LOCAL_LOGV)
            Log.v(TAG, ""get setting for user "" + userHandle + "" by user "" + UserHandle.myUserId() + "" so skipping cache"");
    }
    IContentProvider cp = mProviderHolder.getProvider(cr);
    // interface.
    if (mCallGetCommand != null) {
        try {
            Bundle args = null;
            if (!isSelf) {
                args = new Bundle();
                args.putInt(CALL_METHOD_USER_KEY, userHandle);
            }
            boolean needsGenerationTracker = false;
            synchronized (NameValueCache.this) {
                if (isSelf && mGenerationTracker == null) {
                    needsGenerationTracker = true;
                    if (args == null) {
                        args = new Bundle();
                    }
                    args.putString(CALL_METHOD_TRACK_GENERATION_KEY, null);
                    if (DEBUG) {
                        Log.i(TAG, ""Requested generation tracker for type: "" + mUri.getPath() + "" in package:"" + cr.getPackageName() + "" and user:"" + userHandle);
                    }
                }
            }
            Bundle b;
            // clearCallingIdentity or use a ContentResolver from the caller as needed.
            if (Settings.isInSystemServer() && Binder.getCallingUid() != Process.myUid()) {
                final long token = Binder.clearCallingIdentity();
                try {
                    b = cp.call(cr.getPackageName(), mCallGetCommand, name, args);
                } finally {
                    Binder.restoreCallingIdentity(token);
                }
            } else {
                b = cp.call(cr.getPackageName(), mCallGetCommand, name, args);
            }
            if (b != null) {
                String value = b.getString(Settings.NameValueTable.VALUE);
                // Don't update our cache for reads of other users' data
                if (isSelf) {
                    synchronized (NameValueCache.this) {
                        if (needsGenerationTracker) {
                            MemoryIntArray array = b.getParcelable(CALL_METHOD_TRACK_GENERATION_KEY);
                            final int index = b.getInt(CALL_METHOD_GENERATION_INDEX_KEY, -1);
                            if (array != null && index >= 0) {
                                final int generation = b.getInt(CALL_METHOD_GENERATION_KEY, 0);
                                if (DEBUG) {
                                    Log.i(TAG, ""Received generation tracker for type:"" + mUri.getPath() + "" in package:"" + cr.getPackageName() + "" and user:"" + userHandle + "" with index:"" + index);
                                }
                                if (mGenerationTracker != null) {
                                    mGenerationTracker.destroy();
                                }
                                mGenerationTracker = new GenerationTracker(array, index, generation, () -> {
                                    synchronized (NameValueCache.this) {
                                        Log.e(TAG, ""Error accessing generation"" + "" tracker - removing"");
                                        if (mGenerationTracker != null) {
                                            GenerationTracker generationTracker = mGenerationTracker;
                                            mGenerationTracker = null;
                                            generationTracker.destroy();
                                            mValues.clear();
                                        }
                                    }
                                });
                            }
                        }
                        mValues.put(name, value);
                    }
                } else {
                    if (LOCAL_LOGV)
                        Log.i(TAG, ""call-query of user "" + userHandle + "" by "" + UserHandle.myUserId() + "" so not updating cache"");
                }
                return value;
            }
        // If the response Bundle is null, we fall through
        // to the query interface below.
        } catch (RemoteException e) {
        // Not supported by the remote side?  Fall through
        // to query().
        }
    }
    Cursor c = null;
    try {
        Bundle queryArgs = ContentResolver.createSqlQueryBundle(NAME_EQ_PLACEHOLDER, new String[] { name }, null);
        // Same workaround as above.
        if (Settings.isInSystemServer() && Binder.getCallingUid() != Process.myUid()) {
            final long token = Binder.clearCallingIdentity();
            try {
                c = cp.query(cr.getPackageName(), mUri, SELECT_VALUE_PROJECTION, queryArgs, null);
            } finally {
                Binder.restoreCallingIdentity(token);
            }
        } else {
            c = cp.query(cr.getPackageName(), mUri, SELECT_VALUE_PROJECTION, queryArgs, null);
        }
        if (c == null) {
            Log.w(TAG, ""Can't get key "" + name + "" from "" + mUri);
            return null;
        }
        String value = c.moveToNext() ? c.getString(0) : null;
        synchronized (NameValueCache.this) {
            mValues.put(name, value);
        }
        if (LOCAL_LOGV) {
            Log.v(TAG, ""cache miss ["" + mUri.getLastPathSegment() + ""]: "" + name + "" = "" + (value == null ? ""(null)"" : value));
        }
        return value;
    } catch (RemoteException e) {
        Log.w(TAG, ""Can't get key "" + name + "" from "" + mUri, e);
        // Return null, but don't cache it.
        return null;
    } finally {
        if (c != null)
            c.close();
    }
}","{
    final boolean isSelf = (userHandle == UserHandle.myUserId());
    int currentGeneration = -1;
    if (isSelf) {
        synchronized (NameValueCache.this) {
            if (mGenerationTracker != null) {
                if (mGenerationTracker.isGenerationChanged()) {
                    if (DEBUG) {
                        Log.i(TAG, ""Generation changed for type:"" + mUri.getPath() + "" in package:"" + cr.getPackageName() + "" and user:"" + userHandle);
                    }
                    mValues.clear();
                } else if (mValues.containsKey(name)) {
                    return mValues.get(name);
                }
                if (mGenerationTracker != null) {
                    currentGeneration = mGenerationTracker.getCurrentGeneration();
                }
            }
        }
    } else {
        if (LOCAL_LOGV)
            Log.v(TAG, ""get setting for user "" + userHandle + "" by user "" + UserHandle.myUserId() + "" so skipping cache"");
    }
    IContentProvider cp = mProviderHolder.getProvider(cr);
    // interface.
    if (mCallGetCommand != null) {
        try {
            Bundle args = null;
            if (!isSelf) {
                args = new Bundle();
                args.putInt(CALL_METHOD_USER_KEY, userHandle);
            }
            boolean needsGenerationTracker = false;
            synchronized (NameValueCache.this) {
                if (isSelf && mGenerationTracker == null) {
                    needsGenerationTracker = true;
                    if (args == null) {
                        args = new Bundle();
                    }
                    args.putString(CALL_METHOD_TRACK_GENERATION_KEY, null);
                    if (DEBUG) {
                        Log.i(TAG, ""Requested generation tracker for type: "" + mUri.getPath() + "" in package:"" + cr.getPackageName() + "" and user:"" + userHandle);
                    }
                }
            }
            Bundle b;
            // clearCallingIdentity or use a ContentResolver from the caller as needed.
            if (Settings.isInSystemServer() && Binder.getCallingUid() != Process.myUid()) {
                final long token = Binder.clearCallingIdentity();
                try {
                    b = cp.call(cr.getPackageName(), mCallGetCommand, name, args);
                } finally {
                    Binder.restoreCallingIdentity(token);
                }
            } else {
                b = cp.call(cr.getPackageName(), mCallGetCommand, name, args);
            }
            if (b != null) {
                String value = b.getString(Settings.NameValueTable.VALUE);
                // Don't update our cache for reads of other users' data
                if (isSelf) {
                    synchronized (NameValueCache.this) {
                        if (needsGenerationTracker) {
                            MemoryIntArray array = b.getParcelable(CALL_METHOD_TRACK_GENERATION_KEY);
                            final int index = b.getInt(CALL_METHOD_GENERATION_INDEX_KEY, -1);
                            if (array != null && index >= 0) {
                                final int generation = b.getInt(CALL_METHOD_GENERATION_KEY, 0);
                                if (DEBUG) {
                                    Log.i(TAG, ""Received generation tracker for type:"" + mUri.getPath() + "" in package:"" + cr.getPackageName() + "" and user:"" + userHandle + "" with index:"" + index);
                                }
                                if (mGenerationTracker != null) {
                                    mGenerationTracker.destroy();
                                }
                                mGenerationTracker = new GenerationTracker(array, index, generation, () -> {
                                    synchronized (NameValueCache.this) {
                                        Log.e(TAG, ""Error accessing generation"" + "" tracker - removing"");
                                        if (mGenerationTracker != null) {
                                            GenerationTracker generationTracker = mGenerationTracker;
                                            mGenerationTracker = null;
                                            generationTracker.destroy();
                                            mValues.clear();
                                        }
                                    }
                                });
                            }
                        }
                        if (mGenerationTracker != null && currentGeneration == mGenerationTracker.getCurrentGeneration()) {
                            mValues.put(name, value);
                        }
                    }
                } else {
                    if (LOCAL_LOGV)
                        Log.i(TAG, ""call-query of user "" + userHandle + "" by "" + UserHandle.myUserId() + "" so not updating cache"");
                }
                return value;
            }
        // If the response Bundle is null, we fall through
        // to the query interface below.
        } catch (RemoteException e) {
        // Not supported by the remote side?  Fall through
        // to query().
        }
    }
    Cursor c = null;
    try {
        Bundle queryArgs = ContentResolver.createSqlQueryBundle(NAME_EQ_PLACEHOLDER, new String[] { name }, null);
        // Same workaround as above.
        if (Settings.isInSystemServer() && Binder.getCallingUid() != Process.myUid()) {
            final long token = Binder.clearCallingIdentity();
            try {
                c = cp.query(cr.getPackageName(), mUri, SELECT_VALUE_PROJECTION, queryArgs, null);
            } finally {
                Binder.restoreCallingIdentity(token);
            }
        } else {
            c = cp.query(cr.getPackageName(), mUri, SELECT_VALUE_PROJECTION, queryArgs, null);
        }
        if (c == null) {
            Log.w(TAG, ""Can't get key "" + name + "" from "" + mUri);
            return null;
        }
        String value = c.moveToNext() ? c.getString(0) : null;
        synchronized (NameValueCache.this) {
            if (mGenerationTracker != null && currentGeneration == mGenerationTracker.getCurrentGeneration()) {
                mValues.put(name, value);
            }
        }
        if (LOCAL_LOGV) {
            Log.v(TAG, ""cache miss ["" + mUri.getLastPathSegment() + ""]: "" + name + "" = "" + (value == null ? ""(null)"" : value));
        }
        return value;
    } catch (RemoteException e) {
        Log.w(TAG, ""Can't get key "" + name + "" from "" + mUri, e);
        // Return null, but don't cache it.
        return null;
    } finally {
        if (c != null)
            c.close();
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,,,,
708,<android.net.NetworkCapabilities: String toString()>,27,28,<android.net.NetworkCapabilities: String toString()>,<android.net.NetworkCapabilities: String toString()>,0,"{
    // TODO: enumerate bits for transports and capabilities instead of creating arrays.
    // TODO: use a StringBuilder instead of string concatenation.
    int[] types = getTransportTypes();
    String transports = (types.length > 0) ? "" Transports: "" + transportNamesOf(types) : """";
    types = getCapabilities();
    String capabilities = (types.length > 0 ? "" Capabilities: "" : """");
    for (int i = 0; i < types.length; ) {
        capabilities += capabilityNameOf(types[i]);
        if (++i < types.length)
            capabilities += ""&"";
    }
    String upBand = ((mLinkUpBandwidthKbps > 0) ? "" LinkUpBandwidth>="" + mLinkUpBandwidthKbps + ""Kbps"" : """");
    String dnBand = ((mLinkDownBandwidthKbps > 0) ? "" LinkDnBandwidth>="" + mLinkDownBandwidthKbps + ""Kbps"" : """");
    String specifier = (mNetworkSpecifier == null ? """" : "" Specifier: <"" + mNetworkSpecifier + "">"");
    String signalStrength = (hasSignalStrength() ? "" SignalStrength: "" + mSignalStrength : """");
    return ""["" + transports + capabilities + upBand + dnBand + specifier + signalStrength + ""]"";
}","{
    final StringBuilder sb = new StringBuilder(""["");
    if (0 != mTransportTypes) {
        sb.append("" Transports: "");
        appendStringRepresentationOfBitMaskToStringBuilder(sb, mTransportTypes, NetworkCapabilities::transportNameOf, ""|"");
    }
    if (0 != mNetworkCapabilities) {
        sb.append("" Capabilities: "");
        appendStringRepresentationOfBitMaskToStringBuilder(sb, mNetworkCapabilities, NetworkCapabilities::capabilityNameOf, ""&"");
    }
    if (0 != mNetworkCapabilities) {
        sb.append("" Unwanted: "");
        appendStringRepresentationOfBitMaskToStringBuilder(sb, mUnwantedNetworkCapabilities, NetworkCapabilities::capabilityNameOf, ""&"");
    }
    if (mLinkUpBandwidthKbps > 0) {
        sb.append("" LinkUpBandwidth>="").append(mLinkUpBandwidthKbps).append(""Kbps"");
    }
    if (mLinkDownBandwidthKbps > 0) {
        sb.append("" LinkDnBandwidth>="").append(mLinkDownBandwidthKbps).append(""Kbps"");
    }
    if (mNetworkSpecifier != null) {
        sb.append("" Specifier: <"").append(mNetworkSpecifier).append("">"");
    }
    if (hasSignalStrength()) {
        sb.append("" SignalStrength: "").append(mSignalStrength);
    }
    if (null != mUids) {
        if ((1 == mUids.size()) && (mUids.valueAt(0).count() == 1)) {
            sb.append("" Uid: "").append(mUids.valueAt(0).start);
        } else {
            sb.append("" Uids: <"").append(mUids).append("">"");
        }
    }
    if (mEstablishingVpnAppUid != INVALID_UID) {
        sb.append("" EstablishingAppUid: "").append(mEstablishingVpnAppUid);
    }
    if (null != mSSID) {
        sb.append("" SSID: "").append(mSSID);
    }
    sb.append(""]"");
    return sb.toString();
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,3,4",1,The method implementation has been significantly refactored between versions:,2. There's a new way to append the transport and capability strings to the `StringBuilder`.
709,<android.os.WorkSource: void set(WorkSource)>,27,28,<android.os.WorkSource: void set(WorkSource)>,<android.os.WorkSource: void set(WorkSource)>,0,"{
    if (other == null) {
        mNum = 0;
        return;
    }
    mNum = other.mNum;
    if (other.mUids != null) {
        if (mUids != null && mUids.length >= mNum) {
            System.arraycopy(other.mUids, 0, mUids, 0, mNum);
        } else {
            mUids = other.mUids.clone();
        }
        if (other.mNames != null) {
            if (mNames != null && mNames.length >= mNum) {
                System.arraycopy(other.mNames, 0, mNames, 0, mNum);
            } else {
                mNames = other.mNames.clone();
            }
        } else {
            mNames = null;
        }
    } else {
        mUids = null;
        mNames = null;
    }
}","{
    if (other == null) {
        mNum = 0;
        if (mChains != null) {
            mChains.clear();
        }
        return;
    }
    mNum = other.mNum;
    if (other.mUids != null) {
        if (mUids != null && mUids.length >= mNum) {
            System.arraycopy(other.mUids, 0, mUids, 0, mNum);
        } else {
            mUids = other.mUids.clone();
        }
        if (other.mNames != null) {
            if (mNames != null && mNames.length >= mNum) {
                System.arraycopy(other.mNames, 0, mNames, 0, mNum);
            } else {
                mNames = other.mNames.clone();
            }
        } else {
            mNames = null;
        }
    } else {
        mUids = null;
        mNames = null;
    }
    if (other.mChains != null) {
        if (mChains != null) {
            mChains.clear();
        } else {
            mChains = new ArrayList<>(other.mChains.size());
        }
        for (WorkChain chain : other.mChains) {
            mChains.add(new WorkChain(chain));
        }
    }
}",1,"/**
 * Replace the current contents of this work source with the given
 * work source.  If <var>other</var> is null, the current work source
 * will be made empty.
 */
","/**
 * Replace the current contents of this work source with the given
 * work source.  If {@code other} is null, the current work source
 * will be made empty.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",0,"Additional operations on the mChains field have been added in the late version. Theres a new conditional block to clear or initialize mChains if the other.mChains is not null and copy WorkChain objects from other.mChains. This change is not observed in return statement nor exception handling, so the code changes are classified as 3 (Control dependency changed) and 4 (Other statement changed).","Though there's a modification in the method's body, these changes do not affect the return type or value, nor do they alter the exceptions thrown by the method. The method's signature and return type remain void, and it does not throw any checked exceptions. Therefore, no Compatibility Issue exists."
710,<android.view.autofill.AutofillManager: void notifyViewExited(View)>,27,28,<android.view.autofill.AutofillManager: void notifyViewExited(View)>,<android.view.autofill.AutofillManager: void notifyViewExited(View)>,0,"{
    if (!hasAutofillFeature()) {
        return;
    }
    synchronized (mLock) {
        ensureServiceClientAddedIfNeededLocked();
        if (mEnabled && isActiveLocked()) {
            final AutofillId id = getAutofillId(view);
            // Update focus on existing session.
            updateSessionLocked(id, null, null, ACTION_VIEW_EXITED, 0);
        }
    }
}","{
    if (!hasAutofillFeature()) {
        return;
    }
    synchronized (mLock) {
        notifyViewExitedLocked(view);
    }
}",1,"/**
 * Called when a {@link View} that supports autofill is exited.
 *
 * @param view {@link View} that was exited.
 */
","/**
 * Called when a {@link View} that supports autofill is exited.
 *
 * @param view {@link View} that was exited.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"The change consists of removing several method calls within the synchronized block and replacing them with a single method call to notifyViewExitedLocked(view). Since it is replaced with a new method and not just a change in the existing logic, the dependent API has also changed; hence it is categorized as 4,5.","There's no direct indication that the behavior has changed in terms of what the method returns or the exceptions it throws, assuming notifyViewExitedLocked(view) encapsulates the previous logic exactly. Therefore, without further information indicating that notifyViewExitedLocked(view) behaves differently, we cannot claim a Compatibility Issue based solely on the available code snippets. Thus, the CI type is 0."
711,"<android.content.ContentResolver: void releasePersistableUriPermission(Uri,int)>",27,28,"<android.content.ContentResolver: void releasePersistableUriPermission(Uri,int)>","<android.content.ContentResolver: void releasePersistableUriPermission(Uri,int)>",0,"{
    Preconditions.checkNotNull(uri, ""uri"");
    try {
        ActivityManager.getService().releasePersistableUriPermission(ContentProvider.getUriWithoutUserId(uri), modeFlags, resolveUserId(uri));
    } catch (RemoteException e) {
    }
}","{
    Preconditions.checkNotNull(uri, ""uri"");
    try {
        ActivityManager.getService().releasePersistableUriPermission(ContentProvider.getUriWithoutUserId(uri), modeFlags, /* toPackage= */
        null, resolveUserId(uri));
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Relinquish a persisted URI permission grant. The URI must have been
 * previously made persistent with
 * {@link #takePersistableUriPermission(Uri, int)}. Any non-persistent
 * grants to the calling package will remain intact.
 *
 * @see #getPersistedUriPermissions()
 */
","/**
 * Relinquish a persisted URI permission grant. The URI must have been
 * previously made persistent with
 * {@link #takePersistableUriPermission(Uri, int)}. Any non-persistent
 * grants to the calling package will remain intact.
 *
 * @see #getPersistedUriPermissions()
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,4,5",2,"The implementation of the method releasePersistableUriPermission adds a new parameter to the method call within the try block and has modified the exception handling by throwing an exception where it previously did not, so the types are 2, 4, 5.","The late version of the API can now throw a RemoteException which is propagated up by the `throw e.rethrowFromSystemServer();`. In the early version, any RemoteException was caught and ignored within the catch block. This change could lead to different exception handling behavior in the calling code, which could be a compatibility issue for clients that were not expecting an exception to be thrown by this method, so the CI type is 2."
712,<android.content.res.Resources: int[] getIntArray(int)>,27,28,<android.content.res.Resources: int[] getIntArray(int)>,<android.content.res.Resources: int[] getIntArray(int)>,0,"{
    int[] res = mResourcesImpl.getAssets().getArrayIntResource(id);
    if (res != null) {
        return res;
    }
    throw new NotFoundException(""Int array resource ID #0x"" + Integer.toHexString(id));
}","{
    int[] res = mResourcesImpl.getAssets().getResourceIntArray(id);
    if (res != null) {
        return res;
    }
    throw new NotFoundException(""Int array resource ID #0x"" + Integer.toHexString(id));
}",1,"/**
 * Return the int array associated with a particular resource ID.
 *
 * @param id The desired resource identifier, as generated by the aapt
 * tool. This integer encodes the package, type, and resource
 * entry. The value 0 is an invalid identifier.
 *
 * @throws NotFoundException Throws NotFoundException if the given ID does not exist.
 *
 * @return The int array associated with the resource.
 */
","/**
 * Return the int array associated with a particular resource ID.
 *
 * @param id The desired resource identifier, as generated by the aapt
 * tool. This integer encodes the package, type, and resource
 * entry. The value 0 is an invalid identifier.
 *
 * @throws NotFoundException Throws NotFoundException if the given ID does not exist.
 *
 * @return The int array associated with the resource.
 */
",-1,[@NonNull],[@NonNull],-1,-1,-1,-1,-1,-1,5,0,"The dependent API being called has changed from `getArrayIntResource(id)` to `getResourceIntArray(id)`, which indicates that the resources implementation is using a different method to retrieve the integer array resource, so the code change type is 5.",There is no Compatibility Issue because the method interface and behavior remain unchanged from the perspective of the caller. Both methods throw a NotFoundException if the resource is not found and return the integer array resource if it is. The change in the method being called (dependent API) does not alter the contract of the `getIntArray` method.
713,"<android.service.wallpaper.WallpaperService.Engine: void updateSurface(boolean,boolean,boolean)>",27,28,"<android.service.wallpaper.WallpaperService.Engine: void updateSurface(boolean,boolean,boolean)>","<android.service.wallpaper.WallpaperService.Engine: void updateSurface(boolean,boolean,boolean)>",0,"{
    if (mDestroyed) {
        Log.w(TAG, ""Ignoring updateSurface: destroyed"");
    }
    boolean fixedSize = false;
    int myWidth = mSurfaceHolder.getRequestedWidth();
    if (myWidth <= 0)
        myWidth = ViewGroup.LayoutParams.MATCH_PARENT;
    else
        fixedSize = true;
    int myHeight = mSurfaceHolder.getRequestedHeight();
    if (myHeight <= 0)
        myHeight = ViewGroup.LayoutParams.MATCH_PARENT;
    else
        fixedSize = true;
    final boolean creating = !mCreated;
    final boolean surfaceCreating = !mSurfaceCreated;
    final boolean formatChanged = mFormat != mSurfaceHolder.getRequestedFormat();
    boolean sizeChanged = mWidth != myWidth || mHeight != myHeight;
    boolean insetsChanged = !mCreated;
    final boolean typeChanged = mType != mSurfaceHolder.getRequestedType();
    final boolean flagsChanged = mCurWindowFlags != mWindowFlags || mCurWindowPrivateFlags != mWindowPrivateFlags;
    if (forceRelayout || creating || surfaceCreating || formatChanged || sizeChanged || typeChanged || flagsChanged || redrawNeeded || !mIWallpaperEngine.mShownReported) {
        if (DEBUG)
            Log.v(TAG, ""Changes: creating="" + creating + "" format="" + formatChanged + "" size="" + sizeChanged);
        try {
            mWidth = myWidth;
            mHeight = myHeight;
            mFormat = mSurfaceHolder.getRequestedFormat();
            mType = mSurfaceHolder.getRequestedType();
            mLayout.x = 0;
            mLayout.y = 0;
            mLayout.width = myWidth;
            mLayout.height = myHeight;
            mLayout.format = mFormat;
            mCurWindowFlags = mWindowFlags;
            mLayout.flags = mWindowFlags | WindowManager.LayoutParams.FLAG_LAYOUT_NO_LIMITS | WindowManager.LayoutParams.FLAG_LAYOUT_INSET_DECOR | WindowManager.LayoutParams.FLAG_LAYOUT_IN_SCREEN | WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE;
            mCurWindowPrivateFlags = mWindowPrivateFlags;
            mLayout.privateFlags = mWindowPrivateFlags;
            mLayout.memoryType = mType;
            mLayout.token = mWindowToken;
            if (!mCreated) {
                // Retrieve watch round info
                TypedArray windowStyle = obtainStyledAttributes(com.android.internal.R.styleable.Window);
                windowStyle.recycle();
                // Add window
                mLayout.type = mIWallpaperEngine.mWindowType;
                mLayout.gravity = Gravity.START | Gravity.TOP;
                mLayout.setTitle(WallpaperService.this.getClass().getName());
                mLayout.windowAnimations = com.android.internal.R.style.Animation_Wallpaper;
                mInputChannel = new InputChannel();
                if (mSession.addToDisplay(mWindow, mWindow.mSeq, mLayout, View.VISIBLE, Display.DEFAULT_DISPLAY, mContentInsets, mStableInsets, mOutsets, mInputChannel) < 0) {
                    Log.w(TAG, ""Failed to add window while updating wallpaper surface."");
                    return;
                }
                mCreated = true;
                mInputEventReceiver = new WallpaperInputEventReceiver(mInputChannel, Looper.myLooper());
            }
            mSurfaceHolder.mSurfaceLock.lock();
            mDrawingAllowed = true;
            if (!fixedSize) {
                mLayout.surfaceInsets.set(mIWallpaperEngine.mDisplayPadding);
                mLayout.surfaceInsets.left += mOutsets.left;
                mLayout.surfaceInsets.top += mOutsets.top;
                mLayout.surfaceInsets.right += mOutsets.right;
                mLayout.surfaceInsets.bottom += mOutsets.bottom;
            } else {
                mLayout.surfaceInsets.set(0, 0, 0, 0);
            }
            final int relayoutResult = mSession.relayout(mWindow, mWindow.mSeq, mLayout, mWidth, mHeight, View.VISIBLE, 0, mWinFrame, mOverscanInsets, mContentInsets, mVisibleInsets, mStableInsets, mOutsets, mBackdropFrame, mMergedConfiguration, mSurfaceHolder.mSurface);
            if (DEBUG)
                Log.v(TAG, ""New surface: "" + mSurfaceHolder.mSurface + "", frame="" + mWinFrame);
            int w = mWinFrame.width();
            int h = mWinFrame.height();
            if (!fixedSize) {
                final Rect padding = mIWallpaperEngine.mDisplayPadding;
                w += padding.left + padding.right + mOutsets.left + mOutsets.right;
                h += padding.top + padding.bottom + mOutsets.top + mOutsets.bottom;
                mOverscanInsets.left += padding.left;
                mOverscanInsets.top += padding.top;
                mOverscanInsets.right += padding.right;
                mOverscanInsets.bottom += padding.bottom;
                mContentInsets.left += padding.left;
                mContentInsets.top += padding.top;
                mContentInsets.right += padding.right;
                mContentInsets.bottom += padding.bottom;
                mStableInsets.left += padding.left;
                mStableInsets.top += padding.top;
                mStableInsets.right += padding.right;
                mStableInsets.bottom += padding.bottom;
            }
            if (mCurWidth != w) {
                sizeChanged = true;
                mCurWidth = w;
            }
            if (mCurHeight != h) {
                sizeChanged = true;
                mCurHeight = h;
            }
            if (DEBUG) {
                Log.v(TAG, ""Wallpaper size has changed: ("" + mCurWidth + "", "" + mCurHeight);
            }
            insetsChanged |= !mDispatchedOverscanInsets.equals(mOverscanInsets);
            insetsChanged |= !mDispatchedContentInsets.equals(mContentInsets);
            insetsChanged |= !mDispatchedStableInsets.equals(mStableInsets);
            insetsChanged |= !mDispatchedOutsets.equals(mOutsets);
            mSurfaceHolder.setSurfaceFrameSize(w, h);
            mSurfaceHolder.mSurfaceLock.unlock();
            if (!mSurfaceHolder.mSurface.isValid()) {
                reportSurfaceDestroyed();
                if (DEBUG)
                    Log.v(TAG, ""Layout: Surface destroyed"");
                return;
            }
            boolean didSurface = false;
            try {
                mSurfaceHolder.ungetCallbacks();
                if (surfaceCreating) {
                    mIsCreating = true;
                    didSurface = true;
                    if (DEBUG)
                        Log.v(TAG, ""onSurfaceCreated("" + mSurfaceHolder + ""): "" + this);
                    onSurfaceCreated(mSurfaceHolder);
                    SurfaceHolder.Callback[] callbacks = mSurfaceHolder.getCallbacks();
                    if (callbacks != null) {
                        for (SurfaceHolder.Callback c : callbacks) {
                            c.surfaceCreated(mSurfaceHolder);
                        }
                    }
                }
                redrawNeeded |= creating || (relayoutResult & WindowManagerGlobal.RELAYOUT_RES_FIRST_TIME) != 0;
                if (forceReport || creating || surfaceCreating || formatChanged || sizeChanged) {
                    if (DEBUG) {
                        RuntimeException e = new RuntimeException();
                        e.fillInStackTrace();
                        Log.w(TAG, ""forceReport="" + forceReport + "" creating="" + creating + "" formatChanged="" + formatChanged + "" sizeChanged="" + sizeChanged, e);
                    }
                    if (DEBUG)
                        Log.v(TAG, ""onSurfaceChanged("" + mSurfaceHolder + "", "" + mFormat + "", "" + mCurWidth + "", "" + mCurHeight + ""): "" + this);
                    didSurface = true;
                    onSurfaceChanged(mSurfaceHolder, mFormat, mCurWidth, mCurHeight);
                    SurfaceHolder.Callback[] callbacks = mSurfaceHolder.getCallbacks();
                    if (callbacks != null) {
                        for (SurfaceHolder.Callback c : callbacks) {
                            c.surfaceChanged(mSurfaceHolder, mFormat, mCurWidth, mCurHeight);
                        }
                    }
                }
                if (insetsChanged) {
                    mDispatchedOverscanInsets.set(mOverscanInsets);
                    mDispatchedOverscanInsets.left += mOutsets.left;
                    mDispatchedOverscanInsets.top += mOutsets.top;
                    mDispatchedOverscanInsets.right += mOutsets.right;
                    mDispatchedOverscanInsets.bottom += mOutsets.bottom;
                    mDispatchedContentInsets.set(mContentInsets);
                    mDispatchedStableInsets.set(mStableInsets);
                    mDispatchedOutsets.set(mOutsets);
                    mFinalSystemInsets.set(mDispatchedOverscanInsets);
                    mFinalStableInsets.set(mDispatchedStableInsets);
                    WindowInsets insets = new WindowInsets(mFinalSystemInsets, null, mFinalStableInsets, getResources().getConfiguration().isScreenRound(), false);
                    if (DEBUG) {
                        Log.v(TAG, ""dispatching insets="" + insets);
                    }
                    onApplyWindowInsets(insets);
                }
                if (redrawNeeded) {
                    onSurfaceRedrawNeeded(mSurfaceHolder);
                    SurfaceHolder.Callback[] callbacks = mSurfaceHolder.getCallbacks();
                    if (callbacks != null) {
                        for (SurfaceHolder.Callback c : callbacks) {
                            if (c instanceof SurfaceHolder.Callback2) {
                                ((SurfaceHolder.Callback2) c).surfaceRedrawNeeded(mSurfaceHolder);
                            }
                        }
                    }
                }
                if (didSurface && !mReportedVisible) {
                    // don't want wallpapers running when not visible.
                    if (mIsCreating) {
                        // the state to get them to notice.
                        if (DEBUG)
                            Log.v(TAG, ""onVisibilityChanged(true) at surface: "" + this);
                        onVisibilityChanged(true);
                    }
                    if (DEBUG)
                        Log.v(TAG, ""onVisibilityChanged(false) at surface: "" + this);
                    onVisibilityChanged(false);
                }
            } finally {
                mIsCreating = false;
                mSurfaceCreated = true;
                if (redrawNeeded) {
                    mSession.finishDrawing(mWindow);
                }
                mIWallpaperEngine.reportShown();
            }
        } catch (RemoteException ex) {
        }
        if (DEBUG)
            Log.v(TAG, ""Layout: x="" + mLayout.x + "" y="" + mLayout.y + "" w="" + mLayout.width + "" h="" + mLayout.height);
    }
}","{
    if (mDestroyed) {
        Log.w(TAG, ""Ignoring updateSurface: destroyed"");
    }
    boolean fixedSize = false;
    int myWidth = mSurfaceHolder.getRequestedWidth();
    if (myWidth <= 0)
        myWidth = ViewGroup.LayoutParams.MATCH_PARENT;
    else
        fixedSize = true;
    int myHeight = mSurfaceHolder.getRequestedHeight();
    if (myHeight <= 0)
        myHeight = ViewGroup.LayoutParams.MATCH_PARENT;
    else
        fixedSize = true;
    final boolean creating = !mCreated;
    final boolean surfaceCreating = !mSurfaceCreated;
    final boolean formatChanged = mFormat != mSurfaceHolder.getRequestedFormat();
    boolean sizeChanged = mWidth != myWidth || mHeight != myHeight;
    boolean insetsChanged = !mCreated;
    final boolean typeChanged = mType != mSurfaceHolder.getRequestedType();
    final boolean flagsChanged = mCurWindowFlags != mWindowFlags || mCurWindowPrivateFlags != mWindowPrivateFlags;
    if (forceRelayout || creating || surfaceCreating || formatChanged || sizeChanged || typeChanged || flagsChanged || redrawNeeded || !mIWallpaperEngine.mShownReported) {
        if (DEBUG)
            Log.v(TAG, ""Changes: creating="" + creating + "" format="" + formatChanged + "" size="" + sizeChanged);
        try {
            mWidth = myWidth;
            mHeight = myHeight;
            mFormat = mSurfaceHolder.getRequestedFormat();
            mType = mSurfaceHolder.getRequestedType();
            mLayout.x = 0;
            mLayout.y = 0;
            mLayout.width = myWidth;
            mLayout.height = myHeight;
            mLayout.format = mFormat;
            mCurWindowFlags = mWindowFlags;
            mLayout.flags = mWindowFlags | WindowManager.LayoutParams.FLAG_LAYOUT_NO_LIMITS | WindowManager.LayoutParams.FLAG_LAYOUT_INSET_DECOR | WindowManager.LayoutParams.FLAG_LAYOUT_IN_SCREEN | WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE;
            mCurWindowPrivateFlags = mWindowPrivateFlags;
            mLayout.privateFlags = mWindowPrivateFlags;
            mLayout.memoryType = mType;
            mLayout.token = mWindowToken;
            if (!mCreated) {
                // Retrieve watch round info
                TypedArray windowStyle = obtainStyledAttributes(com.android.internal.R.styleable.Window);
                windowStyle.recycle();
                // Add window
                mLayout.type = mIWallpaperEngine.mWindowType;
                mLayout.gravity = Gravity.START | Gravity.TOP;
                mLayout.setTitle(WallpaperService.this.getClass().getName());
                mLayout.windowAnimations = com.android.internal.R.style.Animation_Wallpaper;
                mInputChannel = new InputChannel();
                if (mSession.addToDisplay(mWindow, mWindow.mSeq, mLayout, View.VISIBLE, Display.DEFAULT_DISPLAY, mWinFrame, mContentInsets, mStableInsets, mOutsets, mDisplayCutout, mInputChannel) < 0) {
                    Log.w(TAG, ""Failed to add window while updating wallpaper surface."");
                    return;
                }
                mCreated = true;
                mInputEventReceiver = new WallpaperInputEventReceiver(mInputChannel, Looper.myLooper());
            }
            mSurfaceHolder.mSurfaceLock.lock();
            mDrawingAllowed = true;
            if (!fixedSize) {
                mLayout.surfaceInsets.set(mIWallpaperEngine.mDisplayPadding);
                mLayout.surfaceInsets.left += mOutsets.left;
                mLayout.surfaceInsets.top += mOutsets.top;
                mLayout.surfaceInsets.right += mOutsets.right;
                mLayout.surfaceInsets.bottom += mOutsets.bottom;
            } else {
                mLayout.surfaceInsets.set(0, 0, 0, 0);
            }
            final int relayoutResult = mSession.relayout(mWindow, mWindow.mSeq, mLayout, mWidth, mHeight, View.VISIBLE, 0, -1, mWinFrame, mOverscanInsets, mContentInsets, mVisibleInsets, mStableInsets, mOutsets, mBackdropFrame, mDisplayCutout, mMergedConfiguration, mSurfaceHolder.mSurface);
            if (DEBUG)
                Log.v(TAG, ""New surface: "" + mSurfaceHolder.mSurface + "", frame="" + mWinFrame);
            int w = mWinFrame.width();
            int h = mWinFrame.height();
            if (!fixedSize) {
                final Rect padding = mIWallpaperEngine.mDisplayPadding;
                w += padding.left + padding.right + mOutsets.left + mOutsets.right;
                h += padding.top + padding.bottom + mOutsets.top + mOutsets.bottom;
                mOverscanInsets.left += padding.left;
                mOverscanInsets.top += padding.top;
                mOverscanInsets.right += padding.right;
                mOverscanInsets.bottom += padding.bottom;
                mContentInsets.left += padding.left;
                mContentInsets.top += padding.top;
                mContentInsets.right += padding.right;
                mContentInsets.bottom += padding.bottom;
                mStableInsets.left += padding.left;
                mStableInsets.top += padding.top;
                mStableInsets.right += padding.right;
                mStableInsets.bottom += padding.bottom;
                mDisplayCutout.set(mDisplayCutout.get().inset(-padding.left, -padding.top, -padding.right, -padding.bottom));
            }
            if (mCurWidth != w) {
                sizeChanged = true;
                mCurWidth = w;
            }
            if (mCurHeight != h) {
                sizeChanged = true;
                mCurHeight = h;
            }
            if (DEBUG) {
                Log.v(TAG, ""Wallpaper size has changed: ("" + mCurWidth + "", "" + mCurHeight);
            }
            insetsChanged |= !mDispatchedOverscanInsets.equals(mOverscanInsets);
            insetsChanged |= !mDispatchedContentInsets.equals(mContentInsets);
            insetsChanged |= !mDispatchedStableInsets.equals(mStableInsets);
            insetsChanged |= !mDispatchedOutsets.equals(mOutsets);
            insetsChanged |= !mDispatchedDisplayCutout.equals(mDisplayCutout.get());
            mSurfaceHolder.setSurfaceFrameSize(w, h);
            mSurfaceHolder.mSurfaceLock.unlock();
            if (!mSurfaceHolder.mSurface.isValid()) {
                reportSurfaceDestroyed();
                if (DEBUG)
                    Log.v(TAG, ""Layout: Surface destroyed"");
                return;
            }
            boolean didSurface = false;
            try {
                mSurfaceHolder.ungetCallbacks();
                if (surfaceCreating) {
                    mIsCreating = true;
                    didSurface = true;
                    if (DEBUG)
                        Log.v(TAG, ""onSurfaceCreated("" + mSurfaceHolder + ""): "" + this);
                    onSurfaceCreated(mSurfaceHolder);
                    SurfaceHolder.Callback[] callbacks = mSurfaceHolder.getCallbacks();
                    if (callbacks != null) {
                        for (SurfaceHolder.Callback c : callbacks) {
                            c.surfaceCreated(mSurfaceHolder);
                        }
                    }
                }
                redrawNeeded |= creating || (relayoutResult & WindowManagerGlobal.RELAYOUT_RES_FIRST_TIME) != 0;
                if (forceReport || creating || surfaceCreating || formatChanged || sizeChanged) {
                    if (DEBUG) {
                        RuntimeException e = new RuntimeException();
                        e.fillInStackTrace();
                        Log.w(TAG, ""forceReport="" + forceReport + "" creating="" + creating + "" formatChanged="" + formatChanged + "" sizeChanged="" + sizeChanged, e);
                    }
                    if (DEBUG)
                        Log.v(TAG, ""onSurfaceChanged("" + mSurfaceHolder + "", "" + mFormat + "", "" + mCurWidth + "", "" + mCurHeight + ""): "" + this);
                    didSurface = true;
                    onSurfaceChanged(mSurfaceHolder, mFormat, mCurWidth, mCurHeight);
                    SurfaceHolder.Callback[] callbacks = mSurfaceHolder.getCallbacks();
                    if (callbacks != null) {
                        for (SurfaceHolder.Callback c : callbacks) {
                            c.surfaceChanged(mSurfaceHolder, mFormat, mCurWidth, mCurHeight);
                        }
                    }
                }
                if (insetsChanged) {
                    mDispatchedOverscanInsets.set(mOverscanInsets);
                    mDispatchedOverscanInsets.left += mOutsets.left;
                    mDispatchedOverscanInsets.top += mOutsets.top;
                    mDispatchedOverscanInsets.right += mOutsets.right;
                    mDispatchedOverscanInsets.bottom += mOutsets.bottom;
                    mDispatchedContentInsets.set(mContentInsets);
                    mDispatchedStableInsets.set(mStableInsets);
                    mDispatchedOutsets.set(mOutsets);
                    mDispatchedDisplayCutout = mDisplayCutout.get();
                    mFinalSystemInsets.set(mDispatchedOverscanInsets);
                    mFinalStableInsets.set(mDispatchedStableInsets);
                    WindowInsets insets = new WindowInsets(mFinalSystemInsets, null, mFinalStableInsets, getResources().getConfiguration().isScreenRound(), false, mDispatchedDisplayCutout);
                    if (DEBUG) {
                        Log.v(TAG, ""dispatching insets="" + insets);
                    }
                    onApplyWindowInsets(insets);
                }
                if (redrawNeeded) {
                    onSurfaceRedrawNeeded(mSurfaceHolder);
                    SurfaceHolder.Callback[] callbacks = mSurfaceHolder.getCallbacks();
                    if (callbacks != null) {
                        for (SurfaceHolder.Callback c : callbacks) {
                            if (c instanceof SurfaceHolder.Callback2) {
                                ((SurfaceHolder.Callback2) c).surfaceRedrawNeeded(mSurfaceHolder);
                            }
                        }
                    }
                }
                if (didSurface && !mReportedVisible) {
                    // don't want wallpapers running when not visible.
                    if (mIsCreating) {
                        // the state to get them to notice.
                        if (DEBUG)
                            Log.v(TAG, ""onVisibilityChanged(true) at surface: "" + this);
                        onVisibilityChanged(true);
                    }
                    if (DEBUG)
                        Log.v(TAG, ""onVisibilityChanged(false) at surface: "" + this);
                    onVisibilityChanged(false);
                }
            } finally {
                mIsCreating = false;
                mSurfaceCreated = true;
                if (redrawNeeded) {
                    mSession.finishDrawing(mWindow);
                }
                mIWallpaperEngine.reportShown();
            }
        } catch (RemoteException ex) {
        }
        if (DEBUG)
            Log.v(TAG, ""Layout: x="" + mLayout.x + "" y="" + mLayout.y + "" w="" + mLayout.width + "" h="" + mLayout.height);
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,,,,
714,<android.bluetooth.BluetoothAdapter: boolean setName(String)>,27,28,<android.bluetooth.BluetoothAdapter: boolean setName(String)>,<android.bluetooth.BluetoothAdapter: boolean setName(String)>,0,"{
    if (getState() != STATE_ON)
        return false;
    try {
        mServiceLock.readLock().lock();
        if (mService != null)
            return mService.setName(name);
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
    } finally {
        mServiceLock.readLock().unlock();
    }
    return false;
}","{
    if (getState() != STATE_ON) {
        return false;
    }
    try {
        mServiceLock.readLock().lock();
        if (mService != null) {
            return mService.setName(name);
        }
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
    } finally {
        mServiceLock.readLock().unlock();
    }
    return false;
}",1,"/**
 * Set the friendly Bluetooth name of the local Bluetooth adapter.
 * <p>This name is visible to remote Bluetooth devices.
 * <p>Valid Bluetooth names are a maximum of 248 bytes using UTF-8
 * encoding, although many remote devices can only display the first
 * 40 characters, and some may be limited to just 20.
 * <p>If Bluetooth state is not {@link #STATE_ON}, this API
 * will return false. After turning on Bluetooth,
 * wait for {@link #ACTION_STATE_CHANGED} with {@link #STATE_ON}
 * to get the updated value.
 *
 * @param name a valid Bluetooth name
 * @return     true if the name was set, false otherwise
 */
","/**
 * Set the friendly Bluetooth name of the local Bluetooth adapter.
 * <p>This name is visible to remote Bluetooth devices.
 * <p>Valid Bluetooth names are a maximum of 248 bytes using UTF-8
 * encoding, although many remote devices can only display the first
 * 40 characters, and some may be limited to just 20.
 * <p>If Bluetooth state is not {@link #STATE_ON}, this API
 * will return false. After turning on Bluetooth,
 * wait for {@link #ACTION_STATE_CHANGED} with {@link #STATE_ON}
 * to get the updated value.
 *
 * @param name a valid Bluetooth name
 * @return true if the name was set, false otherwise
 */
",-1,[@RequiresPermission(Manifest.permission.BLUETOOTH_ADMIN)],[@RequiresPermission(Manifest.permission.BLUETOOTH_ADMIN)],-1,-1,-1,-1,-1,-1,0,0,There is no actual code change between the early and late versions of the implementation; the change is merely stylistic with the addition of braces for clarity.,"There are no Compatibility Issues because there were no changes in the implementation logic, return values, or exception handling between the versions."
715,<android.view.ViewGroup: boolean dispatchTouchEvent(MotionEvent)>,27,28,<android.view.ViewGroup: boolean dispatchTouchEvent(MotionEvent)>,<android.view.ViewGroup: boolean dispatchTouchEvent(MotionEvent)>,0,"{
    if (mInputEventConsistencyVerifier != null) {
        mInputEventConsistencyVerifier.onTouchEvent(ev, 1);
    }
    // normal event dispatch. Maybe a descendant is what will handle the click.
    if (ev.isTargetAccessibilityFocus() && isAccessibilityFocusedViewOrHost()) {
        ev.setTargetAccessibilityFocus(false);
    }
    boolean handled = false;
    if (onFilterTouchEventForSecurity(ev)) {
        final int action = ev.getAction();
        final int actionMasked = action & MotionEvent.ACTION_MASK;
        // Handle an initial down.
        if (actionMasked == MotionEvent.ACTION_DOWN) {
            // Throw away all previous state when starting a new touch gesture.
            // The framework may have dropped the up or cancel event for the previous gesture
            // due to an app switch, ANR, or some other state change.
            cancelAndClearTouchTargets(ev);
            resetTouchState();
        }
        // Check for interception.
        final boolean intercepted;
        if (actionMasked == MotionEvent.ACTION_DOWN || mFirstTouchTarget != null) {
            final boolean disallowIntercept = (mGroupFlags & FLAG_DISALLOW_INTERCEPT) != 0;
            if (!disallowIntercept) {
                intercepted = onInterceptTouchEvent(ev);
                // restore action in case it was changed
                ev.setAction(action);
            } else {
                intercepted = false;
            }
        } else {
            // There are no touch targets and this action is not an initial down
            // so this view group continues to intercept touches.
            intercepted = true;
        }
        // a view that is handling the gesture, do normal event dispatch.
        if (intercepted || mFirstTouchTarget != null) {
            ev.setTargetAccessibilityFocus(false);
        }
        // Check for cancelation.
        final boolean canceled = resetCancelNextUpFlag(this) || actionMasked == MotionEvent.ACTION_CANCEL;
        // Update list of touch targets for pointer down, if needed.
        final boolean split = (mGroupFlags & FLAG_SPLIT_MOTION_EVENTS) != 0;
        TouchTarget newTouchTarget = null;
        boolean alreadyDispatchedToNewTouchTarget = false;
        if (!canceled && !intercepted) {
            // If the event is targeting accessiiblity focus we give it to the
            // view that has accessibility focus and if it does not handle it
            // we clear the flag and dispatch the event to all children as usual.
            // We are looking up the accessibility focused host to avoid keeping
            // state since these events are very rare.
            View childWithAccessibilityFocus = ev.isTargetAccessibilityFocus() ? findChildWithAccessibilityFocus() : null;
            if (actionMasked == MotionEvent.ACTION_DOWN || (split && actionMasked == MotionEvent.ACTION_POINTER_DOWN) || actionMasked == MotionEvent.ACTION_HOVER_MOVE) {
                // always 0 for down
                final int actionIndex = ev.getActionIndex();
                final int idBitsToAssign = split ? 1 << ev.getPointerId(actionIndex) : TouchTarget.ALL_POINTER_IDS;
                // Clean up earlier touch targets for this pointer id in case they
                // have become out of sync.
                removePointersFromTouchTargets(idBitsToAssign);
                final int childrenCount = mChildrenCount;
                if (newTouchTarget == null && childrenCount != 0) {
                    final float x = ev.getX(actionIndex);
                    final float y = ev.getY(actionIndex);
                    // Find a child that can receive the event.
                    // Scan children from front to back.
                    final ArrayList<View> preorderedList = buildTouchDispatchChildList();
                    final boolean customOrder = preorderedList == null && isChildrenDrawingOrderEnabled();
                    final View[] children = mChildren;
                    for (int i = childrenCount - 1; i >= 0; i--) {
                        final int childIndex = getAndVerifyPreorderedIndex(childrenCount, i, customOrder);
                        final View child = getAndVerifyPreorderedView(preorderedList, children, childIndex);
                        // safer given the timeframe.
                        if (childWithAccessibilityFocus != null) {
                            if (childWithAccessibilityFocus != child) {
                                continue;
                            }
                            childWithAccessibilityFocus = null;
                            i = childrenCount - 1;
                        }
                        if (!canViewReceivePointerEvents(child) || !isTransformedTouchPointInView(x, y, child, null)) {
                            ev.setTargetAccessibilityFocus(false);
                            continue;
                        }
                        newTouchTarget = getTouchTarget(child);
                        if (newTouchTarget != null) {
                            // Child is already receiving touch within its bounds.
                            // Give it the new pointer in addition to the ones it is handling.
                            newTouchTarget.pointerIdBits |= idBitsToAssign;
                            break;
                        }
                        resetCancelNextUpFlag(child);
                        if (dispatchTransformedTouchEvent(ev, false, child, idBitsToAssign)) {
                            // Child wants to receive touch within its bounds.
                            mLastTouchDownTime = ev.getDownTime();
                            if (preorderedList != null) {
                                // childIndex points into presorted list, find original index
                                for (int j = 0; j < childrenCount; j++) {
                                    if (children[childIndex] == mChildren[j]) {
                                        mLastTouchDownIndex = j;
                                        break;
                                    }
                                }
                            } else {
                                mLastTouchDownIndex = childIndex;
                            }
                            mLastTouchDownX = ev.getX();
                            mLastTouchDownY = ev.getY();
                            newTouchTarget = addTouchTarget(child, idBitsToAssign);
                            alreadyDispatchedToNewTouchTarget = true;
                            break;
                        }
                        // The accessibility focus didn't handle the event, so clear
                        // the flag and do a normal dispatch to all children.
                        ev.setTargetAccessibilityFocus(false);
                    }
                    if (preorderedList != null)
                        preorderedList.clear();
                }
                if (newTouchTarget == null && mFirstTouchTarget != null) {
                    // Did not find a child to receive the event.
                    // Assign the pointer to the least recently added target.
                    newTouchTarget = mFirstTouchTarget;
                    while (newTouchTarget.next != null) {
                        newTouchTarget = newTouchTarget.next;
                    }
                    newTouchTarget.pointerIdBits |= idBitsToAssign;
                }
            }
        }
        // Dispatch to touch targets.
        if (mFirstTouchTarget == null) {
            // No touch targets so treat this as an ordinary view.
            handled = dispatchTransformedTouchEvent(ev, canceled, null, TouchTarget.ALL_POINTER_IDS);
        } else {
            // Dispatch to touch targets, excluding the new touch target if we already
            // dispatched to it.  Cancel touch targets if necessary.
            TouchTarget predecessor = null;
            TouchTarget target = mFirstTouchTarget;
            while (target != null) {
                final TouchTarget next = target.next;
                if (alreadyDispatchedToNewTouchTarget && target == newTouchTarget) {
                    handled = true;
                } else {
                    final boolean cancelChild = resetCancelNextUpFlag(target.child) || intercepted;
                    if (dispatchTransformedTouchEvent(ev, cancelChild, target.child, target.pointerIdBits)) {
                        handled = true;
                    }
                    if (cancelChild) {
                        if (predecessor == null) {
                            mFirstTouchTarget = next;
                        } else {
                            predecessor.next = next;
                        }
                        target.recycle();
                        target = next;
                        continue;
                    }
                }
                predecessor = target;
                target = next;
            }
        }
        // Update list of touch targets for pointer up or cancel, if needed.
        if (canceled || actionMasked == MotionEvent.ACTION_UP || actionMasked == MotionEvent.ACTION_HOVER_MOVE) {
            resetTouchState();
        } else if (split && actionMasked == MotionEvent.ACTION_POINTER_UP) {
            final int actionIndex = ev.getActionIndex();
            final int idBitsToRemove = 1 << ev.getPointerId(actionIndex);
            removePointersFromTouchTargets(idBitsToRemove);
        }
    }
    if (!handled && mInputEventConsistencyVerifier != null) {
        mInputEventConsistencyVerifier.onUnhandledEvent(ev, 1);
    }
    return handled;
}","{
    if (mInputEventConsistencyVerifier != null) {
        mInputEventConsistencyVerifier.onTouchEvent(ev, 1);
    }
    // normal event dispatch. Maybe a descendant is what will handle the click.
    if (ev.isTargetAccessibilityFocus() && isAccessibilityFocusedViewOrHost()) {
        ev.setTargetAccessibilityFocus(false);
    }
    boolean handled = false;
    if (onFilterTouchEventForSecurity(ev)) {
        final int action = ev.getAction();
        final int actionMasked = action & MotionEvent.ACTION_MASK;
        // Handle an initial down.
        if (actionMasked == MotionEvent.ACTION_DOWN) {
            // Throw away all previous state when starting a new touch gesture.
            // The framework may have dropped the up or cancel event for the previous gesture
            // due to an app switch, ANR, or some other state change.
            cancelAndClearTouchTargets(ev);
            resetTouchState();
        }
        // Check for interception.
        final boolean intercepted;
        if (actionMasked == MotionEvent.ACTION_DOWN || mFirstTouchTarget != null) {
            final boolean disallowIntercept = (mGroupFlags & FLAG_DISALLOW_INTERCEPT) != 0;
            if (!disallowIntercept) {
                intercepted = onInterceptTouchEvent(ev);
                // restore action in case it was changed
                ev.setAction(action);
            } else {
                intercepted = false;
            }
        } else {
            // There are no touch targets and this action is not an initial down
            // so this view group continues to intercept touches.
            intercepted = true;
        }
        // a view that is handling the gesture, do normal event dispatch.
        if (intercepted || mFirstTouchTarget != null) {
            ev.setTargetAccessibilityFocus(false);
        }
        // Check for cancelation.
        final boolean canceled = resetCancelNextUpFlag(this) || actionMasked == MotionEvent.ACTION_CANCEL;
        // Update list of touch targets for pointer down, if needed.
        final boolean split = (mGroupFlags & FLAG_SPLIT_MOTION_EVENTS) != 0;
        TouchTarget newTouchTarget = null;
        boolean alreadyDispatchedToNewTouchTarget = false;
        if (!canceled && !intercepted) {
            // If the event is targeting accessibility focus we give it to the
            // view that has accessibility focus and if it does not handle it
            // we clear the flag and dispatch the event to all children as usual.
            // We are looking up the accessibility focused host to avoid keeping
            // state since these events are very rare.
            View childWithAccessibilityFocus = ev.isTargetAccessibilityFocus() ? findChildWithAccessibilityFocus() : null;
            if (actionMasked == MotionEvent.ACTION_DOWN || (split && actionMasked == MotionEvent.ACTION_POINTER_DOWN) || actionMasked == MotionEvent.ACTION_HOVER_MOVE) {
                // always 0 for down
                final int actionIndex = ev.getActionIndex();
                final int idBitsToAssign = split ? 1 << ev.getPointerId(actionIndex) : TouchTarget.ALL_POINTER_IDS;
                // Clean up earlier touch targets for this pointer id in case they
                // have become out of sync.
                removePointersFromTouchTargets(idBitsToAssign);
                final int childrenCount = mChildrenCount;
                if (newTouchTarget == null && childrenCount != 0) {
                    final float x = ev.getX(actionIndex);
                    final float y = ev.getY(actionIndex);
                    // Find a child that can receive the event.
                    // Scan children from front to back.
                    final ArrayList<View> preorderedList = buildTouchDispatchChildList();
                    final boolean customOrder = preorderedList == null && isChildrenDrawingOrderEnabled();
                    final View[] children = mChildren;
                    for (int i = childrenCount - 1; i >= 0; i--) {
                        final int childIndex = getAndVerifyPreorderedIndex(childrenCount, i, customOrder);
                        final View child = getAndVerifyPreorderedView(preorderedList, children, childIndex);
                        // safer given the timeframe.
                        if (childWithAccessibilityFocus != null) {
                            if (childWithAccessibilityFocus != child) {
                                continue;
                            }
                            childWithAccessibilityFocus = null;
                            i = childrenCount - 1;
                        }
                        if (!canViewReceivePointerEvents(child) || !isTransformedTouchPointInView(x, y, child, null)) {
                            ev.setTargetAccessibilityFocus(false);
                            continue;
                        }
                        newTouchTarget = getTouchTarget(child);
                        if (newTouchTarget != null) {
                            // Child is already receiving touch within its bounds.
                            // Give it the new pointer in addition to the ones it is handling.
                            newTouchTarget.pointerIdBits |= idBitsToAssign;
                            break;
                        }
                        resetCancelNextUpFlag(child);
                        if (dispatchTransformedTouchEvent(ev, false, child, idBitsToAssign)) {
                            // Child wants to receive touch within its bounds.
                            mLastTouchDownTime = ev.getDownTime();
                            if (preorderedList != null) {
                                // childIndex points into presorted list, find original index
                                for (int j = 0; j < childrenCount; j++) {
                                    if (children[childIndex] == mChildren[j]) {
                                        mLastTouchDownIndex = j;
                                        break;
                                    }
                                }
                            } else {
                                mLastTouchDownIndex = childIndex;
                            }
                            mLastTouchDownX = ev.getX();
                            mLastTouchDownY = ev.getY();
                            newTouchTarget = addTouchTarget(child, idBitsToAssign);
                            alreadyDispatchedToNewTouchTarget = true;
                            break;
                        }
                        // The accessibility focus didn't handle the event, so clear
                        // the flag and do a normal dispatch to all children.
                        ev.setTargetAccessibilityFocus(false);
                    }
                    if (preorderedList != null)
                        preorderedList.clear();
                }
                if (newTouchTarget == null && mFirstTouchTarget != null) {
                    // Did not find a child to receive the event.
                    // Assign the pointer to the least recently added target.
                    newTouchTarget = mFirstTouchTarget;
                    while (newTouchTarget.next != null) {
                        newTouchTarget = newTouchTarget.next;
                    }
                    newTouchTarget.pointerIdBits |= idBitsToAssign;
                }
            }
        }
        // Dispatch to touch targets.
        if (mFirstTouchTarget == null) {
            // No touch targets so treat this as an ordinary view.
            handled = dispatchTransformedTouchEvent(ev, canceled, null, TouchTarget.ALL_POINTER_IDS);
        } else {
            // Dispatch to touch targets, excluding the new touch target if we already
            // dispatched to it.  Cancel touch targets if necessary.
            TouchTarget predecessor = null;
            TouchTarget target = mFirstTouchTarget;
            while (target != null) {
                final TouchTarget next = target.next;
                if (alreadyDispatchedToNewTouchTarget && target == newTouchTarget) {
                    handled = true;
                } else {
                    final boolean cancelChild = resetCancelNextUpFlag(target.child) || intercepted;
                    if (dispatchTransformedTouchEvent(ev, cancelChild, target.child, target.pointerIdBits)) {
                        handled = true;
                    }
                    if (cancelChild) {
                        if (predecessor == null) {
                            mFirstTouchTarget = next;
                        } else {
                            predecessor.next = next;
                        }
                        target.recycle();
                        target = next;
                        continue;
                    }
                }
                predecessor = target;
                target = next;
            }
        }
        // Update list of touch targets for pointer up or cancel, if needed.
        if (canceled || actionMasked == MotionEvent.ACTION_UP || actionMasked == MotionEvent.ACTION_HOVER_MOVE) {
            resetTouchState();
        } else if (split && actionMasked == MotionEvent.ACTION_POINTER_UP) {
            final int actionIndex = ev.getActionIndex();
            final int idBitsToRemove = 1 << ev.getPointerId(actionIndex);
            removePointersFromTouchTargets(idBitsToRemove);
        }
    }
    if (!handled && mInputEventConsistencyVerifier != null) {
        mInputEventConsistencyVerifier.onUnhandledEvent(ev, 1);
    }
    return handled;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,,,,
716,"<android.provider.Settings.System: boolean putConfiguration(ContentResolver,Configuration)>",27,28,"<android.provider.Settings.System: boolean putConfiguration(ContentResolver,Configuration)>","<android.provider.Settings.System: boolean putConfiguration(ContentResolver,Configuration)>",0,"{
    return putConfigurationForUser(cr, config, UserHandle.myUserId());
}","{
    return putConfigurationForUser(cr, config, cr.getUserId());
}",1,"/**
 * Convenience function to write a batch of configuration-related
 * settings from a {@link Configuration} object.
 *
 * @param cr The ContentResolver to access.
 * @param config The settings to write.
 * @return true if the values were set, false on database errors
 */
","/**
 * Convenience function to write a batch of configuration-related
 * settings from a {@link Configuration} object.
 *
 * @param cr The ContentResolver to access.
 * @param config The settings to write.
 * @return true if the values were set, false on database errors
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The implementation has changed the way the user ID is obtained, from using UserHandle.myUserId() to using cr.getUserId(). This represents a change in a dependent API, so the code change type is 5.","There is no compatibility issue detected because the change from UserHandle.myUserId() to cr.getUserId() does not inherently suggest that the behavior of the API will be different. The change seems to be an alternative way to retrieve the user ID, and unless cr.getUserId() returns a different value than UserHandle.myUserId(), which we cannot determine from the information provided, there is no indication that this change will lead to different return values or exceptions being thrown. Therefore, the CI type is 0."
717,<android.net.TrafficStats: long getMobileRxBytes()>,27,28,<android.net.TrafficStats: long getMobileRxBytes()>,<android.net.TrafficStats: long getMobileRxBytes()>,0,"{
    long total = 0;
    for (String iface : getMobileIfaces()) {
        total += getRxBytes(iface);
    }
    return total;
}","{
    long total = 0;
    for (String iface : getMobileIfaces()) {
        total += addIfSupported(getRxBytes(iface));
    }
    return total;
}",1,"/**
 * Return number of bytes received across mobile networks since device boot.
 * Counts packets across all mobile network interfaces, and always increases
 * monotonically since device boot. Statistics are measured at the network
 * layer, so they include both TCP and UDP usage.
 * <p>
 * Before {@link android.os.Build.VERSION_CODES#JELLY_BEAN_MR2}, this may
 * return {@link #UNSUPPORTED} on devices where statistics aren't available.
 */
","/**
 * Return number of bytes received across mobile networks since device boot.
 * Counts packets across all mobile network interfaces, and always increases
 * monotonically since device boot. Statistics are measured at the network
 * layer, so they include both TCP and UDP usage.
 * <p>
 * Before {@link android.os.Build.VERSION_CODES#JELLY_BEAN_MR2}, this may
 * return {@link #UNSUPPORTED} on devices where statistics aren't available.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",1,"The change here is that the `getRxBytes(iface)` method call is replaced with `addIfSupported(getRxBytes(iface))` within the loop. This likely involves a change to how receive bytes are being calculated or some condition introduced in the `addIfSupported` method, which indicates a method implementation change but not in this API directly. Therefore, the code change types are 4 (Other statement changed) and 5 (Dependent API changed).","Since the logic for totaling the bytes has been altered by introducing the `addIfSupported` method, which might filter or process the result of `getRxBytes` differently, there is a potential for different return values. Thus, the CI type is 1 (Compatibility Issue caused by potential different return values)."
718,<android.view.ViewRootImpl.ViewRootHandler: String getMessageName(Message)>,27,28,<android.view.ViewRootImpl.ViewRootHandler: String getMessageName(Message)>,<android.view.ViewRootImpl.ViewRootHandler: String getMessageName(Message)>,0,"{
    switch(message.what) {
        case MSG_INVALIDATE:
            return ""MSG_INVALIDATE"";
        case MSG_INVALIDATE_RECT:
            return ""MSG_INVALIDATE_RECT"";
        case MSG_DIE:
            return ""MSG_DIE"";
        case MSG_RESIZED:
            return ""MSG_RESIZED"";
        case MSG_RESIZED_REPORT:
            return ""MSG_RESIZED_REPORT"";
        case MSG_WINDOW_FOCUS_CHANGED:
            return ""MSG_WINDOW_FOCUS_CHANGED"";
        case MSG_DISPATCH_INPUT_EVENT:
            return ""MSG_DISPATCH_INPUT_EVENT"";
        case MSG_DISPATCH_APP_VISIBILITY:
            return ""MSG_DISPATCH_APP_VISIBILITY"";
        case MSG_DISPATCH_GET_NEW_SURFACE:
            return ""MSG_DISPATCH_GET_NEW_SURFACE"";
        case MSG_DISPATCH_KEY_FROM_IME:
            return ""MSG_DISPATCH_KEY_FROM_IME"";
        case MSG_CHECK_FOCUS:
            return ""MSG_CHECK_FOCUS"";
        case MSG_CLOSE_SYSTEM_DIALOGS:
            return ""MSG_CLOSE_SYSTEM_DIALOGS"";
        case MSG_DISPATCH_DRAG_EVENT:
            return ""MSG_DISPATCH_DRAG_EVENT"";
        case MSG_DISPATCH_DRAG_LOCATION_EVENT:
            return ""MSG_DISPATCH_DRAG_LOCATION_EVENT"";
        case MSG_DISPATCH_SYSTEM_UI_VISIBILITY:
            return ""MSG_DISPATCH_SYSTEM_UI_VISIBILITY"";
        case MSG_UPDATE_CONFIGURATION:
            return ""MSG_UPDATE_CONFIGURATION"";
        case MSG_PROCESS_INPUT_EVENTS:
            return ""MSG_PROCESS_INPUT_EVENTS"";
        case MSG_CLEAR_ACCESSIBILITY_FOCUS_HOST:
            return ""MSG_CLEAR_ACCESSIBILITY_FOCUS_HOST"";
        case MSG_WINDOW_MOVED:
            return ""MSG_WINDOW_MOVED"";
        case MSG_SYNTHESIZE_INPUT_EVENT:
            return ""MSG_SYNTHESIZE_INPUT_EVENT"";
        case MSG_DISPATCH_WINDOW_SHOWN:
            return ""MSG_DISPATCH_WINDOW_SHOWN"";
        case MSG_UPDATE_POINTER_ICON:
            return ""MSG_UPDATE_POINTER_ICON"";
        case MSG_POINTER_CAPTURE_CHANGED:
            return ""MSG_POINTER_CAPTURE_CHANGED"";
        case MSG_DRAW_FINISHED:
            return ""MSG_DRAW_FINISHED"";
    }
    return super.getMessageName(message);
}","{
    switch(message.what) {
        case MSG_INVALIDATE:
            return ""MSG_INVALIDATE"";
        case MSG_INVALIDATE_RECT:
            return ""MSG_INVALIDATE_RECT"";
        case MSG_DIE:
            return ""MSG_DIE"";
        case MSG_RESIZED:
            return ""MSG_RESIZED"";
        case MSG_RESIZED_REPORT:
            return ""MSG_RESIZED_REPORT"";
        case MSG_WINDOW_FOCUS_CHANGED:
            return ""MSG_WINDOW_FOCUS_CHANGED"";
        case MSG_DISPATCH_INPUT_EVENT:
            return ""MSG_DISPATCH_INPUT_EVENT"";
        case MSG_DISPATCH_APP_VISIBILITY:
            return ""MSG_DISPATCH_APP_VISIBILITY"";
        case MSG_DISPATCH_GET_NEW_SURFACE:
            return ""MSG_DISPATCH_GET_NEW_SURFACE"";
        case MSG_DISPATCH_KEY_FROM_IME:
            return ""MSG_DISPATCH_KEY_FROM_IME"";
        case MSG_DISPATCH_KEY_FROM_AUTOFILL:
            return ""MSG_DISPATCH_KEY_FROM_AUTOFILL"";
        case MSG_CHECK_FOCUS:
            return ""MSG_CHECK_FOCUS"";
        case MSG_CLOSE_SYSTEM_DIALOGS:
            return ""MSG_CLOSE_SYSTEM_DIALOGS"";
        case MSG_DISPATCH_DRAG_EVENT:
            return ""MSG_DISPATCH_DRAG_EVENT"";
        case MSG_DISPATCH_DRAG_LOCATION_EVENT:
            return ""MSG_DISPATCH_DRAG_LOCATION_EVENT"";
        case MSG_DISPATCH_SYSTEM_UI_VISIBILITY:
            return ""MSG_DISPATCH_SYSTEM_UI_VISIBILITY"";
        case MSG_UPDATE_CONFIGURATION:
            return ""MSG_UPDATE_CONFIGURATION"";
        case MSG_PROCESS_INPUT_EVENTS:
            return ""MSG_PROCESS_INPUT_EVENTS"";
        case MSG_CLEAR_ACCESSIBILITY_FOCUS_HOST:
            return ""MSG_CLEAR_ACCESSIBILITY_FOCUS_HOST"";
        case MSG_WINDOW_MOVED:
            return ""MSG_WINDOW_MOVED"";
        case MSG_SYNTHESIZE_INPUT_EVENT:
            return ""MSG_SYNTHESIZE_INPUT_EVENT"";
        case MSG_DISPATCH_WINDOW_SHOWN:
            return ""MSG_DISPATCH_WINDOW_SHOWN"";
        case MSG_UPDATE_POINTER_ICON:
            return ""MSG_UPDATE_POINTER_ICON"";
        case MSG_POINTER_CAPTURE_CHANGED:
            return ""MSG_POINTER_CAPTURE_CHANGED"";
        case MSG_DRAW_FINISHED:
            return ""MSG_DRAW_FINISHED"";
    }
    return super.getMessageName(message);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,4",1,"A new case statement for MSG_DISPATCH_KEY_FROM_AUTOFILL was added, which can affect control flow by introducing a new control path in the switch statement. The statements within the switch are control dependent on the message.what value thus we consider this a control dependency change. As there are no other notable changes outside the switch construct, it is also an ""other statement changed"".","The addition of a new case statement for the MSG_DISPATCH_KEY_FROM_AUTOFILL will change the return value of the method when the message.what is equal to MSG_DISPATCH_KEY_FROM_AUTOFILL. Hence, there is a potential different return value, making the CI type 1."
719,<android.content.res.TypedArray: boolean hasValue(int)>,27,28,<android.content.res.TypedArray: boolean hasValue(int)>,<android.content.res.TypedArray: boolean hasValue(int)>,0,"{
    if (mRecycled) {
        throw new RuntimeException(""Cannot make calls to a recycled instance!"");
    }
    index *= AssetManager.STYLE_NUM_ENTRIES;
    final int[] data = mData;
    final int type = data[index + AssetManager.STYLE_TYPE];
    return type != TypedValue.TYPE_NULL;
}","{
    if (mRecycled) {
        throw new RuntimeException(""Cannot make calls to a recycled instance!"");
    }
    index *= STYLE_NUM_ENTRIES;
    final int[] data = mData;
    final int type = data[index + STYLE_TYPE];
    return type != TypedValue.TYPE_NULL;
}",1,"/**
 * Determines whether there is an attribute at <var>index</var>.
 * <p>
 * <strong>Note:</strong> If the attribute was set to {@code @empty} or
 * {@code @undefined}, this method returns {@code false}.
 *
 * @param index Index of attribute to retrieve.
 *
 * @return True if the attribute has a value, false otherwise.
 * @throws RuntimeException if the TypedArray has already been recycled.
 */
","/**
 * Determines whether there is an attribute at <var>index</var>.
 * <p>
 * <strong>Note:</strong> If the attribute was set to {@code @empty} or
 * {@code @undefined}, this method returns {@code false}.
 *
 * @param index Index of attribute to retrieve.
 *
 * @return True if the attribute has a value, false otherwise.
 * @throws RuntimeException if the TypedArray has already been recycled.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The only change in the implementation is the removal of the `AssetManager` class scope from `STYLE_NUM_ENTRIES` and `STYLE_TYPE`. This is a reference change and not a functional change assuming `STYLE_NUM_ENTRIES` and `STYLE_TYPE` remain constant in `AssetManager`. Therefore, the code change type is 4.","Because only the scope of the reference to `STYLE_NUM_ENTRIES` and `STYLE_TYPE` has changed and this doesn't affect the behavior of the method, there is no Compatibility Issue. The method's return value and the exceptions it can throw remain unchanged. The CI type is 0."
720,<android.net.TrafficStats: long getTotalTxBytes()>,27,28,<android.net.TrafficStats: long getTotalTxBytes()>,<android.net.TrafficStats: long getTotalTxBytes()>,0,"{
    return nativeGetTotalStat(TYPE_TX_BYTES);
}","{
    try {
        return getStatsService().getTotalStats(TYPE_TX_BYTES);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Return number of bytes transmitted since device boot. Counts packets
 * across all network interfaces, and always increases monotonically since
 * device boot. Statistics are measured at the network layer, so they
 * include both TCP and UDP usage.
 * <p>
 * Before {@link android.os.Build.VERSION_CODES#JELLY_BEAN_MR2}, this may
 * return {@link #UNSUPPORTED} on devices where statistics aren't available.
 */
","/**
 * Return number of bytes transmitted since device boot. Counts packets
 * across all network interfaces, and always increases monotonically since
 * device boot. Statistics are measured at the network layer, so they
 * include both TCP and UDP usage.
 * <p>
 * Before {@link android.os.Build.VERSION_CODES#JELLY_BEAN_MR2}, this may
 * return {@link #UNSUPPORTED} on devices where statistics aren't available.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,2,5","1,2","The return statement has changed from a direct call to a native method to a call to getStatsService with a try-catch block that handles RemoteException, and the way the data is retrieved has changed, so the change types are 1,2,5.","The late version introduces a new try-catch block that catches RemoteException and rethrows it using rethrowFromSystemServer(), which means it will behave differently in terms of exception handling when faced with communication issues. Additionally, since the source of data retrieval has been altered, it may result in returning a different value. Therefore, the CI types are 1,2."
721,"<android.hardware.camera2.impl.CameraDeviceImpl: void createReprocessableCaptureSessionByConfigurations(InputConfiguration,List<OutputConfiguration>,StateCallback,Handler)>",27,28,"<android.hardware.camera2.impl.CameraDeviceImpl: void createReprocessableCaptureSessionByConfigurations(InputConfiguration,List<OutputConfiguration>,StateCallback,Handler)>","<android.hardware.camera2.impl.CameraDeviceImpl: void createReprocessableCaptureSessionByConfigurations(InputConfiguration,List<OutputConfiguration>,StateCallback,Handler)>",0,"{
    if (DEBUG) {
        Log.d(TAG, ""createReprocessableCaptureSessionWithConfigurations"");
    }
    if (inputConfig == null) {
        throw new IllegalArgumentException(""inputConfig cannot be null when creating a "" + ""reprocessable capture session"");
    }
    if (outputs == null) {
        throw new IllegalArgumentException(""Output configurations cannot be null when "" + ""creating a reprocessable capture session"");
    }
    // OutputConfiguration objects aren't immutable, make a copy before using.
    List<OutputConfiguration> currentOutputs = new ArrayList<OutputConfiguration>();
    for (OutputConfiguration output : outputs) {
        currentOutputs.add(new OutputConfiguration(output));
    }
    createCaptureSessionInternal(inputConfig, currentOutputs, callback, handler, /*operatingMode*/
    ICameraDeviceUser.NORMAL_MODE);
}","{
    if (DEBUG) {
        Log.d(TAG, ""createReprocessableCaptureSessionWithConfigurations"");
    }
    if (inputConfig == null) {
        throw new IllegalArgumentException(""inputConfig cannot be null when creating a "" + ""reprocessable capture session"");
    }
    if (outputs == null) {
        throw new IllegalArgumentException(""Output configurations cannot be null when "" + ""creating a reprocessable capture session"");
    }
    // OutputConfiguration objects aren't immutable, make a copy before using.
    List<OutputConfiguration> currentOutputs = new ArrayList<OutputConfiguration>();
    for (OutputConfiguration output : outputs) {
        currentOutputs.add(new OutputConfiguration(output));
    }
    createCaptureSessionInternal(inputConfig, currentOutputs, callback, checkAndWrapHandler(handler), /*operatingMode*/
    ICameraDeviceUser.NORMAL_MODE, /*sessionParams*/
    null);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"4,5",0,"In the late implementation, an additional argument `null` for the `sessionParams` parameter is passed to `createCaptureSessionInternal`, and there is a call to `checkAndWrapHandler(handler)` where `handler` was used directly in the early implementation. Thus, the change types are 4 and 5.","There is no Compatibility Issue because the added `null` value for `sessionParams` parameter and the wrapped `handler` by the `checkAndWrapHandler` method do not affect the current APIs return type, exception handling, or functional control flow as visible in the provided context."
722,<android.view.View: void draw(Canvas)>,27,28,<android.view.View: void draw(Canvas)>,<android.view.View: void draw(Canvas)>,0,"{
    final int privateFlags = mPrivateFlags;
    final boolean dirtyOpaque = (privateFlags & PFLAG_DIRTY_MASK) == PFLAG_DIRTY_OPAQUE && (mAttachInfo == null || !mAttachInfo.mIgnoreDirtyState);
    mPrivateFlags = (privateFlags & ~PFLAG_DIRTY_MASK) | PFLAG_DRAWN;
    /*
         * Draw traversal performs several drawing steps which must be executed
         * in the appropriate order:
         *
         *      1. Draw the background
         *      2. If necessary, save the canvas' layers to prepare for fading
         *      3. Draw view's content
         *      4. Draw children
         *      5. If necessary, draw the fading edges and restore layers
         *      6. Draw decorations (scrollbars for instance)
         */
    // Step 1, draw the background, if needed
    int saveCount;
    if (!dirtyOpaque) {
        drawBackground(canvas);
    }
    // skip step 2 & 5 if possible (common case)
    final int viewFlags = mViewFlags;
    boolean horizontalEdges = (viewFlags & FADING_EDGE_HORIZONTAL) != 0;
    boolean verticalEdges = (viewFlags & FADING_EDGE_VERTICAL) != 0;
    if (!verticalEdges && !horizontalEdges) {
        // Step 3, draw the content
        if (!dirtyOpaque)
            onDraw(canvas);
        // Step 4, draw the children
        dispatchDraw(canvas);
        drawAutofilledHighlight(canvas);
        // Overlay is part of the content and draws beneath Foreground
        if (mOverlay != null && !mOverlay.isEmpty()) {
            mOverlay.getOverlayView().dispatchDraw(canvas);
        }
        // Step 6, draw decorations (foreground, scrollbars)
        onDrawForeground(canvas);
        // Step 7, draw the default focus highlight
        drawDefaultFocusHighlight(canvas);
        if (debugDraw()) {
            debugDrawFocus(canvas);
        }
        // we're done...
        return;
    }
    /*
         * Here we do the full fledged routine...
         * (this is an uncommon case where speed matters less,
         * this is why we repeat some of the tests that have been
         * done above)
         */
    boolean drawTop = false;
    boolean drawBottom = false;
    boolean drawLeft = false;
    boolean drawRight = false;
    float topFadeStrength = 0.0f;
    float bottomFadeStrength = 0.0f;
    float leftFadeStrength = 0.0f;
    float rightFadeStrength = 0.0f;
    // Step 2, save the canvas' layers
    int paddingLeft = mPaddingLeft;
    final boolean offsetRequired = isPaddingOffsetRequired();
    if (offsetRequired) {
        paddingLeft += getLeftPaddingOffset();
    }
    int left = mScrollX + paddingLeft;
    int right = left + mRight - mLeft - mPaddingRight - paddingLeft;
    int top = mScrollY + getFadeTop(offsetRequired);
    int bottom = top + getFadeHeight(offsetRequired);
    if (offsetRequired) {
        right += getRightPaddingOffset();
        bottom += getBottomPaddingOffset();
    }
    final ScrollabilityCache scrollabilityCache = mScrollCache;
    final float fadeHeight = scrollabilityCache.fadingEdgeLength;
    int length = (int) fadeHeight;
    // overlapping fades produce odd-looking artifacts
    if (verticalEdges && (top + length > bottom - length)) {
        length = (bottom - top) / 2;
    }
    // also clip horizontal fades if necessary
    if (horizontalEdges && (left + length > right - length)) {
        length = (right - left) / 2;
    }
    if (verticalEdges) {
        topFadeStrength = Math.max(0.0f, Math.min(1.0f, getTopFadingEdgeStrength()));
        drawTop = topFadeStrength * fadeHeight > 1.0f;
        bottomFadeStrength = Math.max(0.0f, Math.min(1.0f, getBottomFadingEdgeStrength()));
        drawBottom = bottomFadeStrength * fadeHeight > 1.0f;
    }
    if (horizontalEdges) {
        leftFadeStrength = Math.max(0.0f, Math.min(1.0f, getLeftFadingEdgeStrength()));
        drawLeft = leftFadeStrength * fadeHeight > 1.0f;
        rightFadeStrength = Math.max(0.0f, Math.min(1.0f, getRightFadingEdgeStrength()));
        drawRight = rightFadeStrength * fadeHeight > 1.0f;
    }
    saveCount = canvas.getSaveCount();
    int solidColor = getSolidColor();
    if (solidColor == 0) {
        final int flags = Canvas.HAS_ALPHA_LAYER_SAVE_FLAG;
        if (drawTop) {
            canvas.saveLayer(left, top, right, top + length, null, flags);
        }
        if (drawBottom) {
            canvas.saveLayer(left, bottom - length, right, bottom, null, flags);
        }
        if (drawLeft) {
            canvas.saveLayer(left, top, left + length, bottom, null, flags);
        }
        if (drawRight) {
            canvas.saveLayer(right - length, top, right, bottom, null, flags);
        }
    } else {
        scrollabilityCache.setFadeColor(solidColor);
    }
    // Step 3, draw the content
    if (!dirtyOpaque)
        onDraw(canvas);
    // Step 4, draw the children
    dispatchDraw(canvas);
    // Step 5, draw the fade effect and restore layers
    final Paint p = scrollabilityCache.paint;
    final Matrix matrix = scrollabilityCache.matrix;
    final Shader fade = scrollabilityCache.shader;
    if (drawTop) {
        matrix.setScale(1, fadeHeight * topFadeStrength);
        matrix.postTranslate(left, top);
        fade.setLocalMatrix(matrix);
        p.setShader(fade);
        canvas.drawRect(left, top, right, top + length, p);
    }
    if (drawBottom) {
        matrix.setScale(1, fadeHeight * bottomFadeStrength);
        matrix.postRotate(180);
        matrix.postTranslate(left, bottom);
        fade.setLocalMatrix(matrix);
        p.setShader(fade);
        canvas.drawRect(left, bottom - length, right, bottom, p);
    }
    if (drawLeft) {
        matrix.setScale(1, fadeHeight * leftFadeStrength);
        matrix.postRotate(-90);
        matrix.postTranslate(left, top);
        fade.setLocalMatrix(matrix);
        p.setShader(fade);
        canvas.drawRect(left, top, left + length, bottom, p);
    }
    if (drawRight) {
        matrix.setScale(1, fadeHeight * rightFadeStrength);
        matrix.postRotate(90);
        matrix.postTranslate(right, top);
        fade.setLocalMatrix(matrix);
        p.setShader(fade);
        canvas.drawRect(right - length, top, right, bottom, p);
    }
    canvas.restoreToCount(saveCount);
    drawAutofilledHighlight(canvas);
    // Overlay is part of the content and draws beneath Foreground
    if (mOverlay != null && !mOverlay.isEmpty()) {
        mOverlay.getOverlayView().dispatchDraw(canvas);
    }
    // Step 6, draw decorations (foreground, scrollbars)
    onDrawForeground(canvas);
    if (debugDraw()) {
        debugDrawFocus(canvas);
    }
}","{
    final int privateFlags = mPrivateFlags;
    final boolean dirtyOpaque = (privateFlags & PFLAG_DIRTY_MASK) == PFLAG_DIRTY_OPAQUE && (mAttachInfo == null || !mAttachInfo.mIgnoreDirtyState);
    mPrivateFlags = (privateFlags & ~PFLAG_DIRTY_MASK) | PFLAG_DRAWN;
    /*
         * Draw traversal performs several drawing steps which must be executed
         * in the appropriate order:
         *
         *      1. Draw the background
         *      2. If necessary, save the canvas' layers to prepare for fading
         *      3. Draw view's content
         *      4. Draw children
         *      5. If necessary, draw the fading edges and restore layers
         *      6. Draw decorations (scrollbars for instance)
         */
    // Step 1, draw the background, if needed
    int saveCount;
    if (!dirtyOpaque) {
        drawBackground(canvas);
    }
    // skip step 2 & 5 if possible (common case)
    final int viewFlags = mViewFlags;
    boolean horizontalEdges = (viewFlags & FADING_EDGE_HORIZONTAL) != 0;
    boolean verticalEdges = (viewFlags & FADING_EDGE_VERTICAL) != 0;
    if (!verticalEdges && !horizontalEdges) {
        // Step 3, draw the content
        if (!dirtyOpaque)
            onDraw(canvas);
        // Step 4, draw the children
        dispatchDraw(canvas);
        drawAutofilledHighlight(canvas);
        // Overlay is part of the content and draws beneath Foreground
        if (mOverlay != null && !mOverlay.isEmpty()) {
            mOverlay.getOverlayView().dispatchDraw(canvas);
        }
        // Step 6, draw decorations (foreground, scrollbars)
        onDrawForeground(canvas);
        // Step 7, draw the default focus highlight
        drawDefaultFocusHighlight(canvas);
        if (debugDraw()) {
            debugDrawFocus(canvas);
        }
        // we're done...
        return;
    }
    /*
         * Here we do the full fledged routine...
         * (this is an uncommon case where speed matters less,
         * this is why we repeat some of the tests that have been
         * done above)
         */
    boolean drawTop = false;
    boolean drawBottom = false;
    boolean drawLeft = false;
    boolean drawRight = false;
    float topFadeStrength = 0.0f;
    float bottomFadeStrength = 0.0f;
    float leftFadeStrength = 0.0f;
    float rightFadeStrength = 0.0f;
    // Step 2, save the canvas' layers
    int paddingLeft = mPaddingLeft;
    final boolean offsetRequired = isPaddingOffsetRequired();
    if (offsetRequired) {
        paddingLeft += getLeftPaddingOffset();
    }
    int left = mScrollX + paddingLeft;
    int right = left + mRight - mLeft - mPaddingRight - paddingLeft;
    int top = mScrollY + getFadeTop(offsetRequired);
    int bottom = top + getFadeHeight(offsetRequired);
    if (offsetRequired) {
        right += getRightPaddingOffset();
        bottom += getBottomPaddingOffset();
    }
    final ScrollabilityCache scrollabilityCache = mScrollCache;
    final float fadeHeight = scrollabilityCache.fadingEdgeLength;
    int length = (int) fadeHeight;
    // overlapping fades produce odd-looking artifacts
    if (verticalEdges && (top + length > bottom - length)) {
        length = (bottom - top) / 2;
    }
    // also clip horizontal fades if necessary
    if (horizontalEdges && (left + length > right - length)) {
        length = (right - left) / 2;
    }
    if (verticalEdges) {
        topFadeStrength = Math.max(0.0f, Math.min(1.0f, getTopFadingEdgeStrength()));
        drawTop = topFadeStrength * fadeHeight > 1.0f;
        bottomFadeStrength = Math.max(0.0f, Math.min(1.0f, getBottomFadingEdgeStrength()));
        drawBottom = bottomFadeStrength * fadeHeight > 1.0f;
    }
    if (horizontalEdges) {
        leftFadeStrength = Math.max(0.0f, Math.min(1.0f, getLeftFadingEdgeStrength()));
        drawLeft = leftFadeStrength * fadeHeight > 1.0f;
        rightFadeStrength = Math.max(0.0f, Math.min(1.0f, getRightFadingEdgeStrength()));
        drawRight = rightFadeStrength * fadeHeight > 1.0f;
    }
    saveCount = canvas.getSaveCount();
    int solidColor = getSolidColor();
    if (solidColor == 0) {
        if (drawTop) {
            canvas.saveUnclippedLayer(left, top, right, top + length);
        }
        if (drawBottom) {
            canvas.saveUnclippedLayer(left, bottom - length, right, bottom);
        }
        if (drawLeft) {
            canvas.saveUnclippedLayer(left, top, left + length, bottom);
        }
        if (drawRight) {
            canvas.saveUnclippedLayer(right - length, top, right, bottom);
        }
    } else {
        scrollabilityCache.setFadeColor(solidColor);
    }
    // Step 3, draw the content
    if (!dirtyOpaque)
        onDraw(canvas);
    // Step 4, draw the children
    dispatchDraw(canvas);
    // Step 5, draw the fade effect and restore layers
    final Paint p = scrollabilityCache.paint;
    final Matrix matrix = scrollabilityCache.matrix;
    final Shader fade = scrollabilityCache.shader;
    if (drawTop) {
        matrix.setScale(1, fadeHeight * topFadeStrength);
        matrix.postTranslate(left, top);
        fade.setLocalMatrix(matrix);
        p.setShader(fade);
        canvas.drawRect(left, top, right, top + length, p);
    }
    if (drawBottom) {
        matrix.setScale(1, fadeHeight * bottomFadeStrength);
        matrix.postRotate(180);
        matrix.postTranslate(left, bottom);
        fade.setLocalMatrix(matrix);
        p.setShader(fade);
        canvas.drawRect(left, bottom - length, right, bottom, p);
    }
    if (drawLeft) {
        matrix.setScale(1, fadeHeight * leftFadeStrength);
        matrix.postRotate(-90);
        matrix.postTranslate(left, top);
        fade.setLocalMatrix(matrix);
        p.setShader(fade);
        canvas.drawRect(left, top, left + length, bottom, p);
    }
    if (drawRight) {
        matrix.setScale(1, fadeHeight * rightFadeStrength);
        matrix.postRotate(90);
        matrix.postTranslate(right, top);
        fade.setLocalMatrix(matrix);
        p.setShader(fade);
        canvas.drawRect(right - length, top, right, bottom, p);
    }
    canvas.restoreToCount(saveCount);
    drawAutofilledHighlight(canvas);
    // Overlay is part of the content and draws beneath Foreground
    if (mOverlay != null && !mOverlay.isEmpty()) {
        mOverlay.getOverlayView().dispatchDraw(canvas);
    }
    // Step 6, draw decorations (foreground, scrollbars)
    onDrawForeground(canvas);
    if (debugDraw()) {
        debugDrawFocus(canvas);
    }
}",1,"/**
 * Manually render this view (and all of its children) to the given Canvas.
 * The view must have already done a full layout before this function is
 * called.  When implementing a view, implement
 * {@link #onDraw(android.graphics.Canvas)} instead of overriding this method.
 * If you do need to override this method, call the superclass version.
 *
 * @param canvas The Canvas to which the View is rendered.
 */
","/**
 * Manually render this view (and all of its children) to the given Canvas.
 * The view must have already done a full layout before this function is
 * called.  When implementing a view, implement
 * {@link #onDraw(android.graphics.Canvas)} instead of overriding this method.
 * If you do need to override this method, call the superclass version.
 *
 * @param canvas The Canvas to which the View is rendered.
 */
",-1,[@CallSuper],[@CallSuper],-1,-1,-1,-1,-1,-1,,,,
725,<android.view.textclassifier.TextClassification: int getEntityCount()>,27,28,<android.view.textclassifier.TextClassification: int getEntityCount()>,<android.view.textclassifier.TextClassification: int getEntityCount()>,0,"{
    return mEntities.size();
}","{
    return mEntityConfidence.getEntities().size();
}",1,"/**
 * Returns the number of entities found in the classified text.
 */
","/**
 * Returns the number of entities found in the classified text.
 */
",-1,[@IntRange(from = 0)],[@IntRange(from = 0)],-1,-1,-1,-1,-1,-1,5,1,"The method that is being called to obtain the size value has changed from mEntities.size() to mEntityConfidence.getEntities().size(). This indicates that there's a change in the dependent API, hence the code change type is 5.","Since the entity confidence retrieval method is now different, it can potentially return a different count of entities which means the return value could differ between the versions. The CI type is 1."
726,"<android.app.SharedPreferencesImpl.EditorImpl: Editor putLong(String,long)>",27,28,"<android.app.SharedPreferencesImpl.EditorImpl: Editor putLong(String,long)>","<android.app.SharedPreferencesImpl.EditorImpl: Editor putLong(String,long)>",0,"{
    synchronized (mLock) {
        mModified.put(key, value);
        return this;
    }
}","{
    synchronized (mEditorLock) {
        mModified.put(key, value);
        return this;
    }
}",1,,,-1,,[@Override],-1,-1,-1,-1,-1,-1,4,0,"The change is in the object used for synchronization: from `mLock` to `mEditorLock`. This change does not alter the method's return value or the exceptions it might throw, so the change type is 4.","This change will not cause Compatibility Issues since the synchronization mechanism change doesn't affect the external behavior of `putLong` method. The return value remains unchanged and there is no modification in exception handling. Thus, the CI type is 0."
727,<android.view.accessibility.AccessibilityWindowInfo: boolean isInPictureInPictureMode()>,27,28,<android.view.accessibility.AccessibilityWindowInfo: boolean isInPictureInPictureMode()>,<android.view.accessibility.AccessibilityWindowInfo: boolean isInPictureInPictureMode()>,0,"{
    return mInPictureInPicture;
}","{
    return getBooleanProperty(BOOLEAN_PROPERTY_PICTURE_IN_PICTURE);
}",1,"/**
 * Check if the window is in picture-in-picture mode.
 *
 * @return {@code true} if the window is in picture-in-picture mode, {@code false} otherwise.
 */
","/**
 * Check if the window is in picture-in-picture mode.
 *
 * @return {@code true} if the window is in picture-in-picture mode, {@code false} otherwise.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The implementation changed from directly returning the value of the variable 'mInPictureInPicture' to invoking a method 'getBooleanProperty' with a specific property, so the change type is 1,5.","The change of implementation implies that the method now relies on a different mechanism to determine the picture-in-picture status which could potentially return a different value. This constitutes a change in the return value or type of the method, indicating a CI type of 1."
728,<android.provider.Settings.System: boolean getShowGTalkServiceStatus(ContentResolver)>,27,28,<android.provider.Settings.System: boolean getShowGTalkServiceStatus(ContentResolver)>,<android.provider.Settings.System: boolean getShowGTalkServiceStatus(ContentResolver)>,0,"{
    return getShowGTalkServiceStatusForUser(cr, UserHandle.myUserId());
}","{
    return getShowGTalkServiceStatusForUser(cr, cr.getUserId());
}",1,"/**
 * @deprecated - Do not use
 */
","/**
 * @deprecated - Do not use
 */
",-1,[@Deprecated],[@Deprecated],-1,-1,-1,-1,-1,-1,5,0,"The dependent API call has changed from getShowGTalkServiceStatusForUser(cr, UserHandle.myUserId()) to getShowGTalkServiceStatusForUser(cr, cr.getUserId()), hence the code change type is 5.","There is no Compatibility Issue because the method signature has not changed and the return type remains the same. Furthermore, there is no indication that changing from UserHandle.myUserId() to cr.getUserId() would lead to a different behavior, since both are likely to be retrieving the ID of the current user. It appears to be a refactoring to access the user ID via a different method, which should not have any impact on the API's external behavior as long as it returns the correct user ID. Therefore, the CI type is 0."
730,"<android.text.TextUtils: CharSequence ellipsize(CharSequence,TextPaint,float,TruncateAt,boolean,EllipsizeCallback)>",27,28,"<android.text.TextUtils: CharSequence ellipsize(CharSequence,TextPaint,float,TruncateAt,boolean,EllipsizeCallback)>","<android.text.TextUtils: CharSequence ellipsize(CharSequence,TextPaint,float,TruncateAt,boolean,EllipsizeCallback)>",0,"{
    return ellipsize(text, paint, avail, where, preserveLength, callback, TextDirectionHeuristics.FIRSTSTRONG_LTR, (where == TruncateAt.END_SMALL) ? ELLIPSIS_TWO_DOTS_STRING : ELLIPSIS_STRING);
}","{
    return ellipsize(text, paint, avail, where, preserveLength, callback, TextDirectionHeuristics.FIRSTSTRONG_LTR, getEllipsisString(where));
}",1,"/**
 * Returns the original text if it fits in the specified width
 * given the properties of the specified Paint,
 * or, if it does not fit, a copy with ellipsis character added
 * at the specified edge or center.
 * If <code>preserveLength</code> is specified, the returned copy
 * will be padded with zero-width spaces to preserve the original
 * length and offsets instead of truncating.
 * If <code>callback</code> is non-null, it will be called to
 * report the start and end of the ellipsized range.  TextDirection
 * is determined by the first strong directional character.
 */
","/**
 * Returns the original text if it fits in the specified width
 * given the properties of the specified Paint,
 * or, if it does not fit, a copy with ellipsis character added
 * at the specified edge or center.
 * If <code>preserveLength</code> is specified, the returned copy
 * will be padded with zero-width spaces to preserve the original
 * length and offsets instead of truncating.
 * If <code>callback</code> is non-null, it will be called to
 * report the start and end of the ellipsized range.  TextDirection
 * is determined by the first strong directional character.
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The change involves replacing a ternary operator inline calculation with a call to the method `getEllipsisString(where)`. This indicates that the detail of deciding which ellipsis string to use is now wrapped within a method instead of directly within the `ellipsize` method, which is considered a dependency change, so the code change category is 5.","However, this does not constitute a Compatibility Issue, assuming that the `getEllipsisString(where)` method returns the same result as the ternary operator it replaces. There is no indication that there is either a return value/type change or a change in exception handling because of this modification, as the overarching behavior of obtaining the ellipsis string should remain the same. Thus, the pred_CI is 0."
733,"<android.content.res.TypedArray: boolean getValue(int,TypedValue)>",27,28,"<android.content.res.TypedArray: boolean getValue(int,TypedValue)>","<android.content.res.TypedArray: boolean getValue(int,TypedValue)>",0,"{
    if (mRecycled) {
        throw new RuntimeException(""Cannot make calls to a recycled instance!"");
    }
    return getValueAt(index * AssetManager.STYLE_NUM_ENTRIES, outValue);
}","{
    if (mRecycled) {
        throw new RuntimeException(""Cannot make calls to a recycled instance!"");
    }
    return getValueAt(index * STYLE_NUM_ENTRIES, outValue);
}",1,"/**
 * Retrieve the raw TypedValue for the attribute at <var>index</var>.
 *
 * @param index Index of attribute to retrieve.
 * @param outValue TypedValue object in which to place the attribute's
 * data.
 *
 * @return {@code true} if the value was retrieved and not @empty, {@code false} otherwise.
 * @throws RuntimeException if the TypedArray has already been recycled.
 */
","/**
 * Retrieve the raw TypedValue for the attribute at <var>index</var>.
 *
 * @param index Index of attribute to retrieve.
 * @param outValue TypedValue object in which to place the attribute's
 * data.
 *
 * @return {@code true} if the value was retrieved and not @empty, {@code false} otherwise.
 * @throws RuntimeException if the TypedArray has already been recycled.
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"There is a subtle change in the code with the removal of AssetManager qualifier from STYLE_NUM_ENTRIES. This is a reference change in terms of how the variable is accessed, making the code change type a 5.","There are no changes in the function's signature, return statement, exception handling, or control flow. The underlying behaviour of the function is presumably the same if STYLE_NUM_ENTRIES has the same value as AssetManager.STYLE_NUM_ENTRIES. Therefore this change should not introduce any compatibility issues, so the CI type is 0."
735,"<android.app.Instrumentation: Activity newActivity(ClassLoader,String,Intent)>",27,28,"<android.app.Instrumentation: Activity newActivity(ClassLoader,String,Intent)>","<android.app.Instrumentation: Activity newActivity(ClassLoader,String,Intent)>",0,"{
    return (Activity) cl.loadClass(className).newInstance();
}","{
    String pkg = intent != null && intent.getComponent() != null ? intent.getComponent().getPackageName() : null;
    return getFactory(pkg).instantiateActivity(cl, className, intent);
}",1,"/**
 * Perform instantiation of the process's {@link Activity} object.  The
 * default implementation provides the normal system behavior.
 *
 * @param cl The ClassLoader with which to instantiate the object.
 * @param className The name of the class implementing the Activity
 * object.
 * @param intent The Intent object that specified the activity class being
 * instantiated.
 *
 * @return The newly instantiated Activity object.
 */
","/**
 * Perform instantiation of the process's {@link Activity} object.  The
 * default implementation provides the normal system behavior.
 *
 * @param cl The ClassLoader with which to instantiate the object.
 * @param className The name of the class implementing the Activity
 * object.
 * @param intent The Intent object that specified the activity class being
 * instantiated.
 *
 * @return The newly instantiated Activity object.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,4,5",1,"The late version introduces new local variables and changes the mechanism used to instantiate the Activity  from directly using the ClassLoader and calling newInstance(), to using a getFactory(pkg) method with the intent parameter. It's both a change in the statement and in the dependent API that is being used to instantiate the Activity. Thus, this is a 1,4,5 type change.","The changes could lead to the API returning a different Activity instance because the instantiation process relies on the potentially different factory method getFactory(pkg). Additionally, the new code takes the 'intent' parameter into account, which was not used in the early version. These changes could affect the behavior of the returned Activity, thus making the change a type 1 CI."
738,<android.widget.TextView: AutofillValue getAutofillValue()>,27,28,<android.widget.TextView: AutofillValue getAutofillValue()>,<android.widget.TextView: AutofillValue getAutofillValue()>,0,"{
    return isTextEditable() ? AutofillValue.forText(getText()) : null;
}","{
    if (isTextEditable()) {
        final CharSequence text = TextUtils.trimToParcelableSize(getText());
        return AutofillValue.forText(text);
    }
    return null;
}",1,,"/**
 * Gets the {@link TextView}'s current text for AutoFill. The value is trimmed to 100K
 * {@code char}s if longer.
 *
 * @return current text, {@code null} if the text is not editable
 *
 * @see View#getAutofillValue()
 */
",-1,"[@Override, @Nullable]","[@Override, @Nullable]",-1,-1,-1,-1,-1,-1,"3,4",0,"The code change includes wrapping the call to getText() with TextUtils.trimToParcelableSize() when isTextEditable() is true, which is the addition of a method call without changing the control flow, and since the return type and logic have not fundamentally changed, it's categorized as 3,4 since there is a control dependency change regarding the if condition (though it does not affect the logic flow) and an additional method call that does not introduce any new behavior affecting compatibility.","Although the way that the text is processed before being passed to AutofillValue.forText() has changed, this does not constitute a compatibility issue because the return types and the condition for returning either text or null have not changededitable text still returns the trimmed text, otherwise, null is returned. The meaning of 'isTextEditable()' and the contract of 'AutofillValue.forText()' have not been altered, so there is No Compatibility Issue (0)."
739,"<android.content.res.TypedArray: float getFloat(int,float)>",27,28,"<android.content.res.TypedArray: float getFloat(int,float)>","<android.content.res.TypedArray: float getFloat(int,float)>",0,"{
    if (mRecycled) {
        throw new RuntimeException(""Cannot make calls to a recycled instance!"");
    }
    index *= AssetManager.STYLE_NUM_ENTRIES;
    final int[] data = mData;
    final int type = data[index + AssetManager.STYLE_TYPE];
    if (type == TypedValue.TYPE_NULL) {
        return defValue;
    } else if (type == TypedValue.TYPE_FLOAT) {
        return Float.intBitsToFloat(data[index + AssetManager.STYLE_DATA]);
    } else if (type >= TypedValue.TYPE_FIRST_INT && type <= TypedValue.TYPE_LAST_INT) {
        return data[index + AssetManager.STYLE_DATA];
    }
    final TypedValue v = mValue;
    if (getValueAt(index, v)) {
        final CharSequence str = v.coerceToString();
        if (str != null) {
            StrictMode.noteResourceMismatch(v);
            return Float.parseFloat(str.toString());
        }
    }
    // We already checked for TYPE_NULL. This should never happen.
    throw new RuntimeException(""getFloat of bad type: 0x"" + Integer.toHexString(type));
}","{
    if (mRecycled) {
        throw new RuntimeException(""Cannot make calls to a recycled instance!"");
    }
    index *= STYLE_NUM_ENTRIES;
    final int[] data = mData;
    final int type = data[index + STYLE_TYPE];
    if (type == TypedValue.TYPE_NULL) {
        return defValue;
    } else if (type == TypedValue.TYPE_FLOAT) {
        return Float.intBitsToFloat(data[index + STYLE_DATA]);
    } else if (type >= TypedValue.TYPE_FIRST_INT && type <= TypedValue.TYPE_LAST_INT) {
        return data[index + STYLE_DATA];
    }
    final TypedValue v = mValue;
    if (getValueAt(index, v)) {
        final CharSequence str = v.coerceToString();
        if (str != null) {
            StrictMode.noteResourceMismatch(v);
            return Float.parseFloat(str.toString());
        }
    }
    // We already checked for TYPE_NULL. This should never happen.
    throw new RuntimeException(""getFloat of bad type: 0x"" + Integer.toHexString(type));
}",1,"/**
 * Retrieve the float value for the attribute at <var>index</var>.
 * <p>
 * If the attribute is not a float or an integer, this method will attempt
 * to coerce it to a float using {@link Float#parseFloat(String)}.
 *
 * @param index Index of attribute to retrieve.
 *
 * @return Attribute float value, or defValue if the attribute was
 * not defined or could not be coerced to a float.
 * @throws RuntimeException if the TypedArray has already been recycled.
 */
","/**
 * Retrieve the float value for the attribute at <var>index</var>.
 * <p>
 * If the attribute is not a float or an integer, this method will attempt
 * to coerce it to a float using {@link Float#parseFloat(String)}.
 *
 * @param index Index of attribute to retrieve.
 *
 * @return Attribute float value, or defValue if the attribute was
 * not defined or could not be coerced to a float.
 * @throws RuntimeException if the TypedArray has already been recycled.
 */
",-1,,,-1,-1,-1,-1,-1,-1,0,0,"There is no code change between the two versions; the only change is in the way constants (e.g., STYLE_NUM_ENTRIES) are referenced, possibly due to import changes which are not described in the provided information and would not affect the logic and functionality of the implementation.","Since the code behavior has not changed, no Compatibility Issue arises."
741,"<android.content.res.Resources: TypedArray obtainAttributes(AttributeSet,int[])>",27,28,"<android.content.res.Resources: TypedArray obtainAttributes(AttributeSet,int[])>","<android.content.res.Resources: TypedArray obtainAttributes(AttributeSet,int[])>",0,"{
    int len = attrs.length;
    TypedArray array = TypedArray.obtain(this, len);
    // XXX note that for now we only work with compiled XML files.
    // To support generic XML files we will need to manually parse
    // out the attributes from the XML file (applying type information
    // contained in the resources and such).
    XmlBlock.Parser parser = (XmlBlock.Parser) set;
    mResourcesImpl.getAssets().retrieveAttributes(parser.mParseState, attrs, array.mData, array.mIndices);
    array.mXml = parser;
    return array;
}","{
    int len = attrs.length;
    TypedArray array = TypedArray.obtain(this, len);
    // XXX note that for now we only work with compiled XML files.
    // To support generic XML files we will need to manually parse
    // out the attributes from the XML file (applying type information
    // contained in the resources and such).
    XmlBlock.Parser parser = (XmlBlock.Parser) set;
    mResourcesImpl.getAssets().retrieveAttributes(parser, attrs, array.mData, array.mIndices);
    array.mXml = parser;
    return array;
}",1,"/**
 * Retrieve a set of basic attribute values from an AttributeSet, not
 * performing styling of them using a theme and/or style resources.
 *
 * @param set The current attribute values to retrieve.
 * @param attrs The specific attributes to be retrieved. These attribute IDs must be sorted in
 * ascending order.
 * @return Returns a TypedArray holding an array of the attribute values.
 * Be sure to call {@link TypedArray#recycle() TypedArray.recycle()}
 * when done with it.
 *
 * @see Theme#obtainStyledAttributes(AttributeSet, int[], int, int)
 */
","/**
 * Retrieve a set of basic attribute values from an AttributeSet, not
 * performing styling of them using a theme and/or style resources.
 *
 * @param set The current attribute values to retrieve.
 * @param attrs The specific attributes to be retrieved. These attribute IDs must be sorted in
 * ascending order.
 * @return Returns a TypedArray holding an array of the attribute values.
 * Be sure to call {@link TypedArray#recycle() TypedArray.recycle()}
 * when done with it.
 *
 * @see Theme#obtainStyledAttributes(AttributeSet, int[], int, int)
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The change is in the method call retrieveAttributes where the parameter passed has changed from parser.mParseState to parser. However, since the parser is still the same object, just the way it's being accessed has changed, which does not affect the behaviour of the method or the returned value. So the code change type is 4.","There is no Compatibility Issue since this internal change doesn't affect the contract of the method or the returned value. The method continues to return a TypedArray based on the given AttributeSet and int[], and no other behavior or exception handling has changed."
743,<android.os.SystemClock: boolean setCurrentTimeMillis(long)>,27,28,<android.os.SystemClock: boolean setCurrentTimeMillis(long)>,<android.os.SystemClock: boolean setCurrentTimeMillis(long)>,0,"{
    IBinder b = ServiceManager.getService(Context.ALARM_SERVICE);
    IAlarmManager mgr = IAlarmManager.Stub.asInterface(b);
    if (mgr == null) {
        return false;
    }
    try {
        return mgr.setTime(millis);
    } catch (RemoteException e) {
        Slog.e(TAG, ""Unable to set RTC"", e);
    } catch (SecurityException e) {
        Slog.e(TAG, ""Unable to set RTC"", e);
    }
    return false;
}","{
    final IAlarmManager mgr = IAlarmManager.Stub.asInterface(ServiceManager.getService(Context.ALARM_SERVICE));
    if (mgr == null) {
        return false;
    }
    try {
        return mgr.setTime(millis);
    } catch (RemoteException e) {
        Slog.e(TAG, ""Unable to set RTC"", e);
    } catch (SecurityException e) {
        Slog.e(TAG, ""Unable to set RTC"", e);
    }
    return false;
}",1,"/**
 * Sets the current wall time, in milliseconds.  Requires the calling
 * process to have appropriate permissions.
 *
 * @return if the clock was successfully set to the specified time.
 */
","/**
 * Sets the current wall time, in milliseconds.  Requires the calling
 * process to have appropriate permissions.
 *
 * @return if the clock was successfully set to the specified time.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The code has been refactored to inline the retrieval of the `IAlarmManager` service, but the functionality and control flow remain the same, so the change type is 4.","There are no changes in behaviour, return values, control flow, or exception handling; it is merely a simplification of the code without affecting external behaviour, so there is no Compatibility Issue."
745,<android.app.UiAutomation: Bitmap takeScreenshot()>,27,28,<android.app.UiAutomation: Bitmap takeScreenshot()>,<android.app.UiAutomation: Bitmap takeScreenshot()>,0,"{
    synchronized (mLock) {
        throwIfNotConnectedLocked();
    }
    Display display = DisplayManagerGlobal.getInstance().getRealDisplay(Display.DEFAULT_DISPLAY);
    Point displaySize = new Point();
    display.getRealSize(displaySize);
    final int displayWidth = displaySize.x;
    final int displayHeight = displaySize.y;
    final float screenshotWidth;
    final float screenshotHeight;
    final int rotation = display.getRotation();
    switch(rotation) {
        case ROTATION_FREEZE_0:
            {
                screenshotWidth = displayWidth;
                screenshotHeight = displayHeight;
            }
            break;
        case ROTATION_FREEZE_90:
            {
                screenshotWidth = displayHeight;
                screenshotHeight = displayWidth;
            }
            break;
        case ROTATION_FREEZE_180:
            {
                screenshotWidth = displayWidth;
                screenshotHeight = displayHeight;
            }
            break;
        case ROTATION_FREEZE_270:
            {
                screenshotWidth = displayHeight;
                screenshotHeight = displayWidth;
            }
            break;
        default:
            {
                throw new IllegalArgumentException(""Invalid rotation: "" + rotation);
            }
    }
    // Take the screenshot
    Bitmap screenShot = null;
    try {
        // Calling out without a lock held.
        screenShot = mUiAutomationConnection.takeScreenshot((int) screenshotWidth, (int) screenshotHeight);
        if (screenShot == null) {
            return null;
        }
    } catch (RemoteException re) {
        Log.e(LOG_TAG, ""Error while taking screnshot!"", re);
        return null;
    }
    // Rotate the screenshot to the current orientation
    if (rotation != ROTATION_FREEZE_0) {
        Bitmap unrotatedScreenShot = Bitmap.createBitmap(displayWidth, displayHeight, Bitmap.Config.ARGB_8888);
        Canvas canvas = new Canvas(unrotatedScreenShot);
        canvas.translate(unrotatedScreenShot.getWidth() / 2, unrotatedScreenShot.getHeight() / 2);
        canvas.rotate(getDegreesForRotation(rotation));
        canvas.translate(-screenshotWidth / 2, -screenshotHeight / 2);
        canvas.drawBitmap(screenShot, 0, 0, null);
        canvas.setBitmap(null);
        screenShot.recycle();
        screenShot = unrotatedScreenShot;
    }
    // Optimization
    screenShot.setHasAlpha(false);
    return screenShot;
}","{
    synchronized (mLock) {
        throwIfNotConnectedLocked();
    }
    Display display = DisplayManagerGlobal.getInstance().getRealDisplay(Display.DEFAULT_DISPLAY);
    Point displaySize = new Point();
    display.getRealSize(displaySize);
    int rotation = display.getRotation();
    // Take the screenshot
    Bitmap screenShot = null;
    try {
        // Calling out without a lock held.
        screenShot = mUiAutomationConnection.takeScreenshot(new Rect(0, 0, displaySize.x, displaySize.y), rotation);
        if (screenShot == null) {
            return null;
        }
    } catch (RemoteException re) {
        Log.e(LOG_TAG, ""Error while taking screnshot!"", re);
        return null;
    }
    // Optimization
    screenShot.setHasAlpha(false);
    return screenShot;
}",1,"/**
 * Takes a screenshot.
 *
 * @return The screenshot bitmap on success, null otherwise.
 */
","/**
 * Takes a screenshot.
 *
 * @return The screenshot bitmap on success, null otherwise.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3,4",1,"A block of code responsible for calculating screenshot dimensions and manually handling rotation has been removed. A single line now takes a screenshot using the new Rect(), and passes the rotation directly to the mUiAutomationConnection.takeScreenshot() method, resulting in three types of changes: 1) Return statement changed, because the bitmap returned may be different due to the simplified screenshot handling; 3) Control dependency changed, because the code inside the switch-case for handling rotations is removed; 4) Other statement changed, due to the removal of the screenshot width and height calculation and the new way of taking a screenshot.","As substantial parts of the screenshot-taking logic have been changed, which includes removing manual rotation handling and directly passing rotation to the API call, these changes can lead to different behavior in the late version. Particularly, the bitmap that is returned could have a different content due to the different handling of rotations and dimensions, which might cause a CI type 1."
748,"<android.hardware.usb.UsbDeviceConnection: int bulkTransfer(UsbEndpoint,byte[],int,int,int)>",27,28,"<android.hardware.usb.UsbDeviceConnection: int bulkTransfer(UsbEndpoint,byte[],int,int,int)>","<android.hardware.usb.UsbDeviceConnection: int bulkTransfer(UsbEndpoint,byte[],int,int,int)>",0,"{
    checkBounds(buffer, offset, length);
    return native_bulk_request(endpoint.getAddress(), buffer, offset, length, timeout);
}","{
    checkBounds(buffer, offset, length);
    if (mContext.getApplicationInfo().targetSdkVersion < Build.VERSION_CODES.P && length > UsbRequest.MAX_USBFS_BUFFER_SIZE) {
        length = UsbRequest.MAX_USBFS_BUFFER_SIZE;
    }
    return native_bulk_request(endpoint.getAddress(), buffer, offset, length, timeout);
}",1,"/**
 * Performs a bulk transaction on the given endpoint.
 * The direction of the transfer is determined by the direction of the endpoint.
 *
 * @param endpoint the endpoint for this transaction
 * @param buffer buffer for data to send or receive
 * @param offset the index of the first byte in the buffer to send or receive
 * @param length the length of the data to send or receive
 * @param timeout in milliseconds, 0 is infinite
 * @return length of data transferred (or zero) for success,
 * or negative value for failure
 */
","/**
 * Performs a bulk transaction on the given endpoint.
 * The direction of the transfer is determined by the direction of the endpoint.
 *
 * @param endpoint the endpoint for this transaction
 * @param buffer buffer for data to send or receive
 * @param offset the index of the first byte in the buffer to send or receive
 * @param length the length of the data to send or receive. Before
 * {@value Build.VERSION_CODES#P}, a value larger than 16384 bytes
 * would be truncated down to 16384. In API {@value Build.VERSION_CODES#P}
 * and after, any value of length is valid.
 * @param timeout in milliseconds, 0 is infinite
 * @return length of data transferred (or zero) for success,
 * or negative value for failure
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",1,"The code change includes adding a new if condition that potentially alters the 'length' variable, which is a parameter of the subsequent method call. So the changes are control dependency change (3) and other statement change (4).","The change potentially affects the 'length' variable being passed to native_bulk_request(), causing the API to return a different result based on the modified 'length' when the conditions of the if statement are met. The API would potentially return a different value due to the variable 'length' being changed; therefore, the CI type is 1."
749,<android.bluetooth.BluetoothAdapter: boolean isEnabled()>,27,28,<android.bluetooth.BluetoothAdapter: boolean isEnabled()>,<android.bluetooth.BluetoothAdapter: boolean isEnabled()>,0,"{
    try {
        mServiceLock.readLock().lock();
        if (mService != null)
            return mService.isEnabled();
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
    } finally {
        mServiceLock.readLock().unlock();
    }
    return false;
}","{
    try {
        mServiceLock.readLock().lock();
        if (mService != null) {
            return mService.isEnabled();
        }
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
    } finally {
        mServiceLock.readLock().unlock();
    }
    return false;
}",1,"/**
 * Return true if Bluetooth is currently enabled and ready for use.
 * <p>Equivalent to:
 * <code>getBluetoothState() == STATE_ON</code>
 *
 * @return true if the local adapter is turned on
 */
","/**
 * Return true if Bluetooth is currently enabled and ready for use.
 * <p>Equivalent to:
 * <code>getBluetoothState() == STATE_ON</code>
 *
 * @return true if the local adapter is turned on
 */
",-1,[@RequiresPermission(Manifest.permission.BLUETOOTH)],[@RequiresPermission(Manifest.permission.BLUETOOTH)],-1,-1,-1,-1,-1,-1,0,0,There is no change in the implementation of the method between the two versions.,"Since there is no change in the implementation or in the annotations, there is no compatibility issue."
750,<android.hardware.fingerprint.FingerprintManager.CryptoObject: Signature getSignature()>,27,28,<android.hardware.fingerprint.FingerprintManager.CryptoObject: Signature getSignature()>,<android.hardware.fingerprint.FingerprintManager.CryptoObject: Signature getSignature()>,0,"{
    return mCrypto instanceof Signature ? (Signature) mCrypto : null;
}","{
    return super.getSignature();
}",1,"/**
 * Get {@link Signature} object.
 * @return {@link Signature} object or null if this doesn't contain one.
 */
","/**
 * Get {@link Signature} object.
 * @return {@link Signature} object or null if this doesn't contain one.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",1,"The implementation changes from an inline ternary operation directly returning the object or null to a call to super.getSignature(), and it relies on an overridden implementation of the getSignature() method in a superclass or parent class. This is both an 'Other statement changed' (code change type 4) and 'Dependent API changed' (code change type 5).","Since the functionality now depends on the superclass's implementation of getSignature(), which may be different from the previous inline implementation, it is possible that the API would return different results, so the CI is of type 1."
751,<android.bluetooth.BluetoothAdapter: BluetoothLeScanner getBluetoothLeScanner()>,27,28,<android.bluetooth.BluetoothAdapter: BluetoothLeScanner getBluetoothLeScanner()>,<android.bluetooth.BluetoothAdapter: BluetoothLeScanner getBluetoothLeScanner()>,0,"{
    if (!getLeAccess())
        return null;
    synchronized (mLock) {
        if (sBluetoothLeScanner == null) {
            sBluetoothLeScanner = new BluetoothLeScanner(mManagerService);
        }
    }
    return sBluetoothLeScanner;
}","{
    if (!getLeAccess()) {
        return null;
    }
    synchronized (mLock) {
        if (sBluetoothLeScanner == null) {
            sBluetoothLeScanner = new BluetoothLeScanner(mManagerService);
        }
    }
    return sBluetoothLeScanner;
}",1,"/**
 * Returns a {@link BluetoothLeScanner} object for Bluetooth LE scan operations.
 */
","/**
 * Returns a {@link BluetoothLeScanner} object for Bluetooth LE scan operations.
 */
",-1,,,-1,-1,-1,-1,-1,-1,0,0,"There are no changes to the method's implementation, only formatting changes (adding braces to the 'if' statement) that do not affect the method's behavior.",There is no compatibility issue since there are no changes in the actual code execution or logic that would lead to a different outcome when the method is invoked.
752,"<android.hardware.usb.UsbRequest: boolean queue(ByteBuffer,int)>",27,28,"<android.hardware.usb.UsbRequest: boolean queue(ByteBuffer,int)>","<android.hardware.usb.UsbRequest: boolean queue(ByteBuffer,int)>",0,"{
    boolean out = (mEndpoint.getDirection() == UsbConstants.USB_DIR_OUT);
    boolean result;
    synchronized (mLock) {
        // save our buffer for when the request has completed
        mBuffer = buffer;
        mLength = length;
        if (buffer.isDirect()) {
            result = native_queue_direct(buffer, length, out);
        } else if (buffer.hasArray()) {
            result = native_queue_array(buffer.array(), length, out);
        } else {
            throw new IllegalArgumentException(""buffer is not direct and has no array"");
        }
        if (!result) {
            mBuffer = null;
            mLength = 0;
        }
    }
    return result;
}","{
    boolean out = (mEndpoint.getDirection() == UsbConstants.USB_DIR_OUT);
    boolean result;
    if (mConnection.getContext().getApplicationInfo().targetSdkVersion < Build.VERSION_CODES.P && length > MAX_USBFS_BUFFER_SIZE) {
        length = MAX_USBFS_BUFFER_SIZE;
    }
    synchronized (mLock) {
        // save our buffer for when the request has completed
        mBuffer = buffer;
        mLength = length;
        if (buffer.isDirect()) {
            result = native_queue_direct(buffer, length, out);
        } else if (buffer.hasArray()) {
            result = native_queue_array(buffer.array(), length, out);
        } else {
            throw new IllegalArgumentException(""buffer is not direct and has no array"");
        }
        if (!result) {
            mBuffer = null;
            mLength = 0;
        }
    }
    return result;
}",1,"/**
 * Queues the request to send or receive data on its endpoint.
 * <p>For OUT endpoints, the given buffer data will be sent on the endpoint. For IN endpoints,
 * the endpoint will attempt to read the given number of bytes into the specified buffer. If the
 * queueing operation is successful, return true. The result will be returned via
 * {@link UsbDeviceConnection#requestWait}</p>
 *
 * @param buffer the buffer containing the bytes to write, or location to store the results of a
 * read. Position and array offset will be ignored and assumed to be 0. Limit and
 * capacity will be ignored. Once the request
 * {@link UsbDeviceConnection#requestWait() is processed} the position will be set
 * to the number of bytes read/written.
 * @param length number of bytes to read or write.
 *
 * @return true if the queueing operation succeeded
 *
 * @deprecated Use {@link #queue(ByteBuffer)} instead.
 */
","/**
 * Queues the request to send or receive data on its endpoint.
 * <p>For OUT endpoints, the given buffer data will be sent on the endpoint. For IN endpoints,
 * the endpoint will attempt to read the given number of bytes into the specified buffer. If the
 * queueing operation is successful, return true. The result will be returned via
 * {@link UsbDeviceConnection#requestWait}</p>
 *
 * @param buffer the buffer containing the bytes to write, or location to store the results of a
 * read. Position and array offset will be ignored and assumed to be 0. Limit and
 * capacity will be ignored. Once the request
 * {@link UsbDeviceConnection#requestWait() is processed} the position will be set
 * to the number of bytes read/written.
 * @param length number of bytes to read or write. Before {@value Build.VERSION_CODES#P}, a
 * value larger than 16384 bytes would be truncated down to 16384. In API
 * {@value Build.VERSION_CODES#P} and after, any value of length is valid.
 *
 * @return true if the queueing operation succeeded
 *
 * @deprecated Use {@link #queue(ByteBuffer)} instead.
 */
",-1,[@Deprecated],[@Deprecated],-1,-1,-1,-1,-1,-1,"3,4",1,"A new if statement has been introduced that modifies the 'length' variable depending on the condition, which affects the control flow. Thus, the code change type is 3 for control dependency changed and 4 for the other statement change (introduction of new if condition).","The new if condition that modifies the 'length' variable before the 'synchronized' block may result in a change in the data being queued and thus the return value of the method, which means that the API could potentially return different values. Hence, the CI type is 1."
754,"<android.bluetooth.le.BluetoothLeAdvertiser: AdvertisingSetCallback wrapOldCallback(AdvertiseCallback,AdvertiseSettings)>",27,28,"<android.bluetooth.le.BluetoothLeAdvertiser: AdvertisingSetCallback wrapOldCallback(AdvertiseCallback,AdvertiseSettings)>","<android.bluetooth.le.BluetoothLeAdvertiser: AdvertisingSetCallback wrapOldCallback(AdvertiseCallback,AdvertiseSettings)>",0,"{
    return new AdvertisingSetCallback() {

        @Override
        public void onAdvertisingSetStarted(AdvertisingSet advertisingSet, int txPower, int status) {
            if (status != AdvertisingSetCallback.ADVERTISE_SUCCESS) {
                postStartFailure(callback, status);
                return;
            }
            postStartSuccess(callback, settings);
        }

        /* Legacy advertiser is disabled on timeout */
        @Override
        public void onAdvertisingEnabled(AdvertisingSet advertisingSet, boolean enabled, int status) {
            if (enabled == true) {
                Log.e(TAG, ""Legacy advertiser should be only disabled on timeout,"" + "" but was enabled!"");
                return;
            }
            stopAdvertising(callback);
        }
    };
}","{
    return new AdvertisingSetCallback() {

        @Override
        public void onAdvertisingSetStarted(AdvertisingSet advertisingSet, int txPower, int status) {
            if (status != AdvertisingSetCallback.ADVERTISE_SUCCESS) {
                postStartFailure(callback, status);
                return;
            }
            postStartSuccess(callback, settings);
        }

        /* Legacy advertiser is disabled on timeout */
        @Override
        public void onAdvertisingEnabled(AdvertisingSet advertisingSet, boolean enabled, int status) {
            if (enabled) {
                Log.e(TAG, ""Legacy advertiser should be only disabled on timeout,"" + "" but was enabled!"");
                return;
            }
            stopAdvertising(callback);
        }
    };
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,0,0,There are no significant code changes between the two versions; only a simplification of the boolean condition (`enabled == true` to `enabled`) which does not alter the behavior.,There is no Compatibility Issue since the code change does not affect the behavior of the API; it's merely a syntactic simplification.
755,<android.hardware.camera2.impl.CallbackProxies.SessionStateCallbackProxy: void onConfigured(CameraCaptureSession)>,27,28,<android.hardware.camera2.impl.CallbackProxies.SessionStateCallbackProxy: void onConfigured(CameraCaptureSession)>,<android.hardware.camera2.impl.CallbackProxies.SessionStateCallbackProxy: void onConfigured(CameraCaptureSession)>,0,"{
    mProxy.invoke(""onConfigured"", session);
}","{
    final long ident = Binder.clearCallingIdentity();
    try {
        mExecutor.execute(() -> mCallback.onConfigured(session));
    } finally {
        Binder.restoreCallingIdentity(ident);
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,4",2,"The late version introduces new variable declaration, a try-finally block, and executes a lambda expression on a separate mExecutor, instead of directly invoking a method on mProxy. Hence, the code change is classified under types 3 and 4.","The early version does not have the potential of throwing any exception related to threads or executor services since it calls 'invoke' directly; however, the late version can throw unchecked exceptions due to the lambda execution within the mExecutor, which could lead to different exception handling behavior. Therefore, the CI type is 2."
756,"<android.content.res.TypedArray: float getFraction(int,int,int,float)>",27,28,"<android.content.res.TypedArray: float getFraction(int,int,int,float)>","<android.content.res.TypedArray: float getFraction(int,int,int,float)>",0,"{
    if (mRecycled) {
        throw new RuntimeException(""Cannot make calls to a recycled instance!"");
    }
    final int attrIndex = index;
    index *= AssetManager.STYLE_NUM_ENTRIES;
    final int[] data = mData;
    final int type = data[index + AssetManager.STYLE_TYPE];
    if (type == TypedValue.TYPE_NULL) {
        return defValue;
    } else if (type == TypedValue.TYPE_FRACTION) {
        return TypedValue.complexToFraction(data[index + AssetManager.STYLE_DATA], base, pbase);
    } else if (type == TypedValue.TYPE_ATTRIBUTE) {
        final TypedValue value = mValue;
        getValueAt(index, value);
        throw new UnsupportedOperationException(""Failed to resolve attribute at index "" + attrIndex + "": "" + value);
    }
    throw new UnsupportedOperationException(""Can't convert value at index "" + attrIndex + "" to fraction: type=0x"" + Integer.toHexString(type));
}","{
    if (mRecycled) {
        throw new RuntimeException(""Cannot make calls to a recycled instance!"");
    }
    final int attrIndex = index;
    index *= STYLE_NUM_ENTRIES;
    final int[] data = mData;
    final int type = data[index + STYLE_TYPE];
    if (type == TypedValue.TYPE_NULL) {
        return defValue;
    } else if (type == TypedValue.TYPE_FRACTION) {
        return TypedValue.complexToFraction(data[index + STYLE_DATA], base, pbase);
    } else if (type == TypedValue.TYPE_ATTRIBUTE) {
        final TypedValue value = mValue;
        getValueAt(index, value);
        throw new UnsupportedOperationException(""Failed to resolve attribute at index "" + attrIndex + "": "" + value);
    }
    throw new UnsupportedOperationException(""Can't convert value at index "" + attrIndex + "" to fraction: type=0x"" + Integer.toHexString(type));
}",1,"/**
 * Retrieves a fractional unit attribute at <var>index</var>.
 *
 * @param index Index of attribute to retrieve.
 * @param base The base value of this fraction.  In other words, a
 * standard fraction is multiplied by this value.
 * @param pbase The parent base value of this fraction.  In other
 * words, a parent fraction (nn%p) is multiplied by this
 * value.
 * @param defValue Value to return if the attribute is not defined or
 * not a resource.
 *
 * @return Attribute fractional value multiplied by the appropriate
 * base value, or defValue if not defined.
 * @throws RuntimeException if the TypedArray has already been recycled.
 * @throws UnsupportedOperationException if the attribute is defined but is
 * not a fraction.
 */
","/**
 * Retrieves a fractional unit attribute at <var>index</var>.
 *
 * @param index Index of attribute to retrieve.
 * @param base The base value of this fraction.  In other words, a
 * standard fraction is multiplied by this value.
 * @param pbase The parent base value of this fraction.  In other
 * words, a parent fraction (nn%p) is multiplied by this
 * value.
 * @param defValue Value to return if the attribute is not defined or
 * not a resource.
 *
 * @return Attribute fractional value multiplied by the appropriate
 * base value, or defValue if not defined.
 * @throws RuntimeException if the TypedArray has already been recycled.
 * @throws UnsupportedOperationException if the attribute is defined but is
 * not a fraction.
 */
",-1,,,-1,-1,-1,-1,-1,-1,0,0,"There is no actual change in the implementation code, only the use of `AssetManager.STYLE_NUM_ENTRIES` has been changed to `STYLE_NUM_ENTRIES` and `AssetManager.STYLE_TYPE` has been changed to `STYLE_TYPE`. These are likely simple changes in the structure of the code where the same constants are now being referenced without the class name prefix due to a change in the class's import statements.",No Compatibility Issue is expected as there's no actual change to the behavior of the code.
757,<android.widget.TextView: boolean selectAllText()>,27,28,<android.widget.TextView: boolean selectAllText()>,<android.widget.TextView: boolean selectAllText()>,0,"{
    if (mEditor != null) {
        // Hide the toolbar before changing the selection to avoid flickering.
        mEditor.hideFloatingToolbar(FLOATING_TOOLBAR_SELECT_ALL_REFRESH_DELAY);
    }
    final int length = mText.length();
    Selection.setSelection((Spannable) mText, 0, length);
    return length > 0;
}","{
    if (mEditor != null) {
        // Hide the toolbar before changing the selection to avoid flickering.
        hideFloatingToolbar(FLOATING_TOOLBAR_SELECT_ALL_REFRESH_DELAY);
    }
    final int length = mText.length();
    Selection.setSelection(mSpannable, 0, length);
    return length > 0;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"The change is an invocation of a method call from mEditor.hideFloatingToolbar(...) to hideFloatingToolbar(...) without specifying mEditor, and a change from an implicit cast of mText to a Spannable to an explicit use of mSpannable. There is also a method name correction from hideFloatingToolbar(...) to Selection.setSelection(...) with a variable change, which are changes in dependent API calls and fall under the 'Other statement changed' category. Therefore, the code change types are 4 and 5.","Despite these changes, the behavior of the method remains the same. The delay for hiding the floating toolbar is still applied, and the selection of all the text is performed the same way with a check for the length being greater than 0. There are no changes in return values, exception handlings, or control statement dependencies that could lead to a difference in behavior for the API consumer. Therefore, there is no Compatibility Issue."
758,<android.hardware.Camera: boolean enableShutterSound(boolean)>,27,28,<android.hardware.Camera: boolean enableShutterSound(boolean)>,<android.hardware.Camera: boolean enableShutterSound(boolean)>,0,"{
    if (!enabled) {
        IBinder b = ServiceManager.getService(Context.AUDIO_SERVICE);
        IAudioService audioService = IAudioService.Stub.asInterface(b);
        try {
            if (audioService.isCameraSoundForced())
                return false;
        } catch (RemoteException e) {
            Log.e(TAG, ""Audio service is unavailable for queries"");
        }
    }
    return _enableShutterSound(enabled);
}","{
    boolean canDisableShutterSound = true;
    IBinder b = ServiceManager.getService(Context.AUDIO_SERVICE);
    IAudioService audioService = IAudioService.Stub.asInterface(b);
    try {
        if (audioService.isCameraSoundForced()) {
            canDisableShutterSound = false;
        }
    } catch (RemoteException e) {
        Log.e(TAG, ""Audio service is unavailable for queries"");
    }
    if (!enabled && !canDisableShutterSound) {
        return false;
    }
    synchronized (mShutterSoundLock) {
        mShutterSoundEnabledFromApp = enabled;
        // Return the result of _enableShutterSound(enabled) in all cases.
        // If the shutter sound can be disabled, disable it when the device is in DnD mode.
        boolean ret = _enableShutterSound(enabled);
        if (enabled && !mHasAppOpsPlayAudio) {
            Log.i(TAG, ""Shutter sound is not allowed by AppOpsManager"");
            if (canDisableShutterSound) {
                _enableShutterSound(false);
            }
        }
        return ret;
    }
}",1,"/**
 * <p>Enable or disable the default shutter sound when taking a picture.</p>
 *
 * <p>By default, the camera plays the system-defined camera shutter sound
 * when {@link #takePicture} is called. Using this method, the shutter sound
 * can be disabled. It is strongly recommended that an alternative shutter
 * sound is played in the {@link ShutterCallback} when the system shutter
 * sound is disabled.</p>
 *
 * <p>Note that devices may not always allow disabling the camera shutter
 * sound. If the shutter sound state cannot be set to the desired value,
 * this method will return false. {@link CameraInfo#canDisableShutterSound}
 * can be used to determine whether the device will allow the shutter sound
 * to be disabled.</p>
 *
 * @param enabled whether the camera should play the system shutter sound
 * when {@link #takePicture takePicture} is called.
 * @return {@code true} if the shutter sound state was successfully
 * changed. {@code false} if the shutter sound state could not be
 * changed. {@code true} is also returned if shutter sound playback
 * is already set to the requested state.
 * @throws RuntimeException if the call fails; usually this would be because
 * of a hardware or other low-level error, or because release() has been
 * called on this Camera instance.
 * @see #takePicture
 * @see CameraInfo#canDisableShutterSound
 * @see ShutterCallback
 */
","/**
 * <p>Enable or disable the default shutter sound when taking a picture.</p>
 *
 * <p>By default, the camera plays the system-defined camera shutter sound
 * when {@link #takePicture} is called. Using this method, the shutter sound
 * can be disabled. It is strongly recommended that an alternative shutter
 * sound is played in the {@link ShutterCallback} when the system shutter
 * sound is disabled.</p>
 *
 * <p>Note that devices may not always allow disabling the camera shutter
 * sound. If the shutter sound state cannot be set to the desired value,
 * this method will return false. {@link CameraInfo#canDisableShutterSound}
 * can be used to determine whether the device will allow the shutter sound
 * to be disabled.</p>
 *
 * @param enabled whether the camera should play the system shutter sound
 * when {@link #takePicture takePicture} is called.
 * @return {@code true} if the shutter sound state was successfully
 * changed. {@code false} if the shutter sound state could not be
 * changed. {@code true} is also returned if shutter sound playback
 * is already set to the requested state.
 * @throws RuntimeException if the call fails; usually this would be because
 * of a hardware or other low-level error, or because release() has been
 * called on this Camera instance.
 * @see #takePicture
 * @see CameraInfo#canDisableShutterSound
 * @see ShutterCallback
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3,4,5","1,2","The implementation of the method has been changed significantly, which includes:","- A 'synchronized' block has been added, which changes the control flow."
759,<android.content.pm.SharedLibraryInfo: int getVersion()>,27,28,<android.content.pm.SharedLibraryInfo: int getVersion()>,<android.content.pm.SharedLibraryInfo: int getVersion()>,0,"{
    return mVersion;
}","{
    return mVersion < 0 ? (int) mVersion : (int) (mVersion & 0x7fffffff);
}",1,"/**
 * Gets the version of the library. For {@link #TYPE_STATIC static} libraries
 * this is the declared version and for {@link #TYPE_DYNAMIC dynamic} and
 * {@link #TYPE_BUILTIN builtin} it is {@link #VERSION_UNDEFINED} as these
 * are not versioned.
 *
 * @return The version.
 */
","/**
 * @deprecated Use {@link #getLongVersion()} instead.
 */
",-1,[@IntRange(from = -1)],"[@Deprecated, @IntRange(from = -1)]",-1,-1,-1,-1,-1,-1,"1,4",1,"The return statement has been modified to include a ternary conditional operator that alters the return value based on the condition checked, resulting in a potential change of the type or value being returned. The bit manipulation operation '&' is also a new addition. Thus, the changes fall under the categories of a return statement change (1) and other statement change (4).","The implementation now includes a conditional check that applies a bitmask to the version number if it is non-negative. This represents a change that could result in a different returned value from the method. Thus, the compatibility issue is due to a potential different return value (CI type 1)."
761,"<android.app.usage.NetworkStatsManager: NetworkStats queryDetailsForUidTag(int,String,long,long,int,int)>",27,28,"<android.app.usage.NetworkStatsManager: NetworkStats queryDetailsForUidTag(int,String,long,long,int,int)>","<android.app.usage.NetworkStatsManager: NetworkStats queryDetailsForUidTag(int,String,long,long,int,int)>",0,"{
    NetworkTemplate template;
    template = createTemplate(networkType, subscriberId);
    NetworkStats result;
    try {
        result = new NetworkStats(mContext, template, mFlags, startTime, endTime);
        result.startHistoryEnumeration(uid, tag);
    } catch (RemoteException e) {
        Log.e(TAG, ""Error while querying stats for uid="" + uid + "" tag="" + tag, e);
        return null;
    }
    return result;
}","{
    return queryDetailsForUidTagState(networkType, subscriberId, startTime, endTime, uid, tag, NetworkStats.Bucket.STATE_ALL);
}",1,"/**
 * Query network usage statistics details for a given uid and tag. Only usable for uids
 * belonging to calling user. Result is aggregated over state but not aggregated over time.
 * This means buckets' start and end timestamps are going to be between 'startTime' and
 * 'endTime' parameters. State is going to be {@link NetworkStats.Bucket#STATE_ALL}, uid the
 * same as the 'uid' parameter and tag the same as 'tag' parameter. metered is going to be
 * {@link NetworkStats.Bucket#METERED_ALL}, and roaming is going to be
 * {@link NetworkStats.Bucket#ROAMING_ALL}.
 * <p>Only includes buckets that atomically occur in the inclusive time range. Doesn't
 * interpolate across partial buckets. Since bucket length is in the order of hours, this
 * method cannot be used to measure data usage on a fine grained time scale.
 *
 * @param networkType As defined in {@link ConnectivityManager}, e.g.
 * {@link ConnectivityManager#TYPE_MOBILE}, {@link ConnectivityManager#TYPE_WIFI}
 * etc.
 * @param subscriberId If applicable, the subscriber id of the network interface.
 * @param startTime Start of period. Defined in terms of ""Unix time"", see
 * {@link java.lang.System#currentTimeMillis}.
 * @param endTime End of period. Defined in terms of ""Unix time"", see
 * {@link java.lang.System#currentTimeMillis}.
 * @param uid UID of app
 * @param tag TAG of interest. Use {@link NetworkStats.Bucket#TAG_NONE} for no tags.
 * @return Statistics object or null if an error happened during statistics collection.
 * @throws SecurityException if permissions are insufficient to read network statistics.
 */
","/**
 * Query network usage statistics details for a given uid and tag.
 *
 * #see queryDetailsForUidTagState(int, String, long, long, int, int, int)
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The whole implementation has changed to a call to a different method (queryDetailsForUidTagState) with additional parameter (NetworkStats.Bucket.STATE_ALL). The change type is 1,5 since the method being called is different, and the parameter passed includes an additional one (state), which was not there in the early version.","The change in the method being called can potentially lead to a different return value since the new method has an extra parameter that wasn't part of the original method's signature. Thus, the CI type is 1."
762,<android.text.style.QuoteSpan: int getLeadingMargin(boolean)>,27,28,<android.text.style.QuoteSpan: int getLeadingMargin(boolean)>,<android.text.style.QuoteSpan: int getLeadingMargin(boolean)>,0,"{
    return STRIPE_WIDTH + GAP_WIDTH;
}","{
    return mStripeWidth + mGapWidth;
}",1,,,-1,,[@Override],-1,-1,-1,-1,-1,-1,"4,5",1,"The implementation uses different member variables (`STRIPE_WIDTH + GAP_WIDTH` changed to `mStripeWidth + mGapWidth`) for the calculation, representing a change in the dependent API (change in the internal state representation of the QuoteSpan class). Therefore, the change type is 4,5.","The change from using constant values to instance variables for `mStripeWidth` and `mGapWidth` could potentially lead to a different return value if these instance variables are set differently from the constants. Hence, the CI type is 1."
764,"<android.net.Network: URLConnection openConnection(URL,Proxy)>",27,28,"<android.net.Network: URLConnection openConnection(URL,Proxy)>","<android.net.Network: URLConnection openConnection(URL,Proxy)>",0,"{
    if (proxy == null)
        throw new IllegalArgumentException(""proxy is null"");
    maybeInitHttpClient();
    String protocol = url.getProtocol();
    OkUrlFactory okUrlFactory;
    // Could this cause unexpected behavior?
    if (protocol.equals(""http"")) {
        okUrlFactory = HttpHandler.createHttpOkUrlFactory(proxy);
    } else if (protocol.equals(""https"")) {
        okUrlFactory = HttpsHandler.createHttpsOkUrlFactory(proxy);
    } else {
        // passed another protocol.
        throw new MalformedURLException(""Invalid URL or unrecognized protocol "" + protocol);
    }
    OkHttpClient client = okUrlFactory.client();
    client.setSocketFactory(getSocketFactory()).setConnectionPool(mConnectionPool);
    // Let network traffic go via mDns
    client.setDns(mDns);
    return okUrlFactory.open(url);
}","{
    if (proxy == null)
        throw new IllegalArgumentException(""proxy is null"");
    maybeInitUrlConnectionFactory();
    SocketFactory socketFactory = getSocketFactory();
    return mUrlConnectionFactory.openConnection(url, socketFactory, proxy);
}",1,"/**
 * Opens the specified {@link URL} on this {@code Network}, such that all traffic will be sent
 * on this Network. The URL protocol must be {@code HTTP} or {@code HTTPS}.
 *
 * @param proxy the proxy through which the connection will be established.
 * @return a {@code URLConnection} to the resource referred to by this URL.
 * @throws MalformedURLException if the URL protocol is not HTTP or HTTPS.
 * @throws IllegalArgumentException if the argument proxy is null.
 * @throws IOException if an error occurs while opening the connection.
 * @see java.net.URL#openConnection()
 */
","/**
 * Opens the specified {@link URL} on this {@code Network}, such that all traffic will be sent
 * on this Network. The URL protocol must be {@code HTTP} or {@code HTTPS}.
 *
 * @param proxy the proxy through which the connection will be established.
 * @return a {@code URLConnection} to the resource referred to by this URL.
 * @throws MalformedURLException if the URL protocol is not HTTP or HTTPS.
 * @throws IllegalArgumentException if the argument proxy is null.
 * @throws IOException if an error occurs while opening the connection.
 * @see java.net.URL#openConnection()
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3,5",1,"The method body has been significantly changed between the two versions. In the early version, it initializes an HttpClient and uses OkUrlFactory to create and configure the connection, while in the late version it directly calls the mUrlConnectionFactory to open the connection. As a result, changes include the removal of control structure (the if-else checks for ""http"" and ""https""), significant changes to the logic by initializing (maybeInitHttpClient vs. maybeInitUrlConnectionFactory), and also dependent API changes (calls to createHttpOkUrlFactory, createHttpsOkUrlFactory, and methods on the obtained OkHttpClient instance versus the use of mUrlConnectionFactory.openConnection). Therefore, the code change types are 1,3,5.","The restructured implementation switches from HttpClient and OkUrlFactory to another unknown 'mUrlConnectionFactory', which likely leads to different behaviors since the underlying client used to open the connection has changed. Additionally, the control dependency on URL's protocol has been removed, possibly altering the return value. Due to these changes, there is a possibility of the API returning different types or values and the CI type is 1."
765,<android.app.job.JobInfo.Builder: Builder setRequiredNetworkType(int)>,27,28,<android.app.job.JobInfo.Builder: Builder setRequiredNetworkType(int)>,<android.app.job.JobInfo.Builder: Builder setRequiredNetworkType(int)>,0,"{
    mNetworkType = networkType;
    return this;
}","{
    if (networkType == NETWORK_TYPE_NONE) {
        return setRequiredNetwork(null);
    } else {
        final NetworkRequest.Builder builder = new NetworkRequest.Builder();
        // All types require validated Internet
        builder.addCapability(NET_CAPABILITY_INTERNET);
        builder.addCapability(NET_CAPABILITY_VALIDATED);
        builder.removeCapability(NET_CAPABILITY_NOT_VPN);
        if (networkType == NETWORK_TYPE_ANY) {
        // No other capabilities
        } else if (networkType == NETWORK_TYPE_UNMETERED) {
            builder.addCapability(NET_CAPABILITY_NOT_METERED);
        } else if (networkType == NETWORK_TYPE_NOT_ROAMING) {
            builder.addCapability(NET_CAPABILITY_NOT_ROAMING);
        } else if (networkType == NETWORK_TYPE_CELLULAR) {
            builder.addTransportType(TRANSPORT_CELLULAR);
        }
        return setRequiredNetwork(builder.build());
    }
}",1,"/**
 * Set some description of the kind of network type your job needs to have.
 * Not calling this function means the network is not necessary, as the default is
 * {@link #NETWORK_TYPE_NONE}.
 * Bear in mind that calling this function defines network as a strict requirement for your
 * job. If the network requested is not available your job will never run. See
 * {@link #setOverrideDeadline(long)} to change this behaviour.
 */
","/**
 * Set basic description of the kind of network your job requires. If
 * you need more precise control over network capabilities, see
 * {@link #setRequiredNetwork(NetworkRequest)}.
 * <p>
 * If your job doesn't need a network connection, you don't need to call
 * this method, as the default value is {@link #NETWORK_TYPE_NONE}.
 * <p>
 * Calling this method defines network as a strict requirement for your
 * job. If the network requested is not available your job will never
 * run. See {@link #setOverrideDeadline(long)} to change this behavior.
 * Calling this method will override any requirements previously defined
 * by {@link #setRequiredNetwork(NetworkRequest)}; you typically only
 * want to call one of these methods.
 * <p class=""note"">
 * When your job executes in
 * {@link JobService#onStartJob(JobParameters)}, be sure to use the
 * specific network returned by {@link JobParameters#getNetwork()},
 * otherwise you'll use the default network which may not meet this
 * constraint.
 *
 * @see #setRequiredNetwork(NetworkRequest)
 * @see JobInfo#getNetworkType()
 * @see JobParameters#getNetwork()
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3,4,5",1,"The late implementation adds conditional logic to differentiate between network types, creates a new NetworkRequest object, sets various network capabilities and transports based on the network type, and calls setRequiredNetwork with that request instead of just setting the mNetworkType. Changes occur in return statements, control dependencies, and other statements. Additionally, the late implementation relies on a new dependent API, NetworkRequest.Builder and its methods. Hence, code change types are 1,3,4,5.","Since the implementation now builds different network requests based on the `networkType`, it changes the behavior of the method, potentially causing it to return a different `JobInfo.Builder` object initialized with different `NetworkRequest` parameters. This difference affects the final `JobInfo` object created by the `Builder`, leading to a CI of type 1."
766,<android.content.res.TypedArray: ColorStateList getColorStateList(int)>,27,28,<android.content.res.TypedArray: ColorStateList getColorStateList(int)>,<android.content.res.TypedArray: ColorStateList getColorStateList(int)>,0,"{
    if (mRecycled) {
        throw new RuntimeException(""Cannot make calls to a recycled instance!"");
    }
    final TypedValue value = mValue;
    if (getValueAt(index * AssetManager.STYLE_NUM_ENTRIES, value)) {
        if (value.type == TypedValue.TYPE_ATTRIBUTE) {
            throw new UnsupportedOperationException(""Failed to resolve attribute at index "" + index + "": "" + value);
        }
        return mResources.loadColorStateList(value, value.resourceId, mTheme);
    }
    return null;
}","{
    if (mRecycled) {
        throw new RuntimeException(""Cannot make calls to a recycled instance!"");
    }
    final TypedValue value = mValue;
    if (getValueAt(index * STYLE_NUM_ENTRIES, value)) {
        if (value.type == TypedValue.TYPE_ATTRIBUTE) {
            throw new UnsupportedOperationException(""Failed to resolve attribute at index "" + index + "": "" + value);
        }
        return mResources.loadColorStateList(value, value.resourceId, mTheme);
    }
    return null;
}",1,"/**
 * Retrieve the ColorStateList for the attribute at <var>index</var>.
 * The value may be either a single solid color or a reference to
 * a color or complex {@link android.content.res.ColorStateList}
 * description.
 * <p>
 * This method will return {@code null} if the attribute is not defined or
 * is not an integer color or color state list.
 *
 * @param index Index of attribute to retrieve.
 *
 * @return ColorStateList for the attribute, or {@code null} if not
 * defined.
 * @throws RuntimeException if the attribute if the TypedArray has already
 * been recycled.
 * @throws UnsupportedOperationException if the attribute is defined but is
 * not an integer color or color state list.
 */
","/**
 * Retrieve the ColorStateList for the attribute at <var>index</var>.
 * The value may be either a single solid color or a reference to
 * a color or complex {@link android.content.res.ColorStateList}
 * description.
 * <p>
 * This method will return {@code null} if the attribute is not defined or
 * is not an integer color or color state list.
 *
 * @param index Index of attribute to retrieve.
 *
 * @return ColorStateList for the attribute, or {@code null} if not
 * defined.
 * @throws RuntimeException if the attribute if the TypedArray has already
 * been recycled.
 * @throws UnsupportedOperationException if the attribute is defined but is
 * not an integer color or color state list.
 */
",-1,[@Nullable],[@Nullable],-1,-1,-1,-1,-1,-1,0,0,There are no changes in the implementation between the two versions.,No Compatibility Issue detected as there is no change in the code.
767,<android.app.SystemServiceRegistry.CachedServiceFetcher: T getService(ContextImpl)>,27,28,<android.app.SystemServiceRegistry.CachedServiceFetcher: T getService(ContextImpl)>,<android.app.SystemServiceRegistry.CachedServiceFetcher: T getService(ContextImpl)>,0,"{
    final Object[] cache = ctx.mServiceCache;
    synchronized (cache) {
        // Fetch or create the service.
        Object service = cache[mCacheIndex];
        if (service == null) {
            try {
                service = createService(ctx);
                cache[mCacheIndex] = service;
            } catch (ServiceNotFoundException e) {
                onServiceNotFound(e);
            }
        }
        return (T) service;
    }
}","{
    final Object[] cache = ctx.mServiceCache;
    final int[] gates = ctx.mServiceInitializationStateArray;
    for (; ; ) {
        boolean doInitialize = false;
        synchronized (cache) {
            // Return it if we already have a cached instance.
            T service = (T) cache[mCacheIndex];
            if (service != null || gates[mCacheIndex] == ContextImpl.STATE_NOT_FOUND) {
                return service;
            }
            // We start over from STATE_UNINITIALIZED.
            if (gates[mCacheIndex] == ContextImpl.STATE_READY) {
                gates[mCacheIndex] = ContextImpl.STATE_UNINITIALIZED;
            }
            // At this point, the gate must be either UNINITIALIZED or INITIALIZING.
            if (gates[mCacheIndex] == ContextImpl.STATE_UNINITIALIZED) {
                doInitialize = true;
                gates[mCacheIndex] = ContextImpl.STATE_INITIALIZING;
            }
        }
        if (doInitialize) {
            // Only the first thread gets here.
            T service = null;
            @ServiceInitializationState int newState = ContextImpl.STATE_NOT_FOUND;
            try {
                // This thread is the first one to get here. Instantiate the service
                // *without* the cache lock held.
                service = createService(ctx);
                newState = ContextImpl.STATE_READY;
            } catch (ServiceNotFoundException e) {
                onServiceNotFound(e);
            } finally {
                synchronized (cache) {
                    cache[mCacheIndex] = service;
                    gates[mCacheIndex] = newState;
                    cache.notifyAll();
                }
            }
            return service;
        }
        // and go back to the top and retry.
        synchronized (cache) {
            while (gates[mCacheIndex] < ContextImpl.STATE_READY) {
                try {
                    cache.wait();
                } catch (InterruptedException e) {
                    Log.w(TAG, ""getService() interrupted"");
                    Thread.currentThread().interrupt();
                    return null;
                }
            }
        }
    }
}",1,,,-1,"[@Override, @SuppressWarnings(""unchecked"")]","[@Override, @SuppressWarnings(""unchecked"")]",-1,-1,-1,-1,-1,-1,"1,3,4","1,2","The code changes encompass the introduction of new control structures (`for` loop and new `if` conditions), the change in exception handling (the `finally` block, notification via `cache.notifyAll()`), and a new waiting loop at the end of the method. Therefore, the change types are 1, 3, and 4.","With different control flows and handling of cache initialization states, and the addition of a waiting mechanism, the API could return different values or even null in case of interruption, which was not possible in the early version. Additionally, there could be different exception handlings due to the restructuring. Thus, both CI types 1 and 2 are possible."
768,<android.hardware.radio.RadioManager.ProgramInfo: boolean equals(Object)>,27,28,<android.hardware.radio.RadioManager.ProgramInfo: boolean equals(Object)>,<android.hardware.radio.RadioManager.ProgramInfo: boolean equals(Object)>,0,"{
    if (this == obj)
        return true;
    if (!(obj instanceof ProgramInfo))
        return false;
    ProgramInfo other = (ProgramInfo) obj;
    if (!mSelector.equals(other.getSelector()))
        return false;
    if (mTuned != other.isTuned())
        return false;
    if (mStereo != other.isStereo())
        return false;
    if (mDigital != other.isDigital())
        return false;
    if (mFlags != other.mFlags)
        return false;
    if (mSignalStrength != other.getSignalStrength())
        return false;
    if (mMetadata == null) {
        if (other.getMetadata() != null)
            return false;
    } else if (!mMetadata.equals(other.getMetadata()))
        return false;
    if (!mVendorInfo.equals(other.mVendorInfo))
        return false;
    return true;
}","{
    if (this == obj)
        return true;
    if (!(obj instanceof ProgramInfo))
        return false;
    ProgramInfo other = (ProgramInfo) obj;
    if (!Objects.equals(mSelector, other.mSelector))
        return false;
    if (!Objects.equals(mLogicallyTunedTo, other.mLogicallyTunedTo))
        return false;
    if (!Objects.equals(mPhysicallyTunedTo, other.mPhysicallyTunedTo))
        return false;
    if (!Objects.equals(mRelatedContent, other.mRelatedContent))
        return false;
    if (mInfoFlags != other.mInfoFlags)
        return false;
    if (mSignalQuality != other.mSignalQuality)
        return false;
    if (!Objects.equals(mMetadata, other.mMetadata))
        return false;
    if (!Objects.equals(mVendorInfo, other.mVendorInfo))
        return false;
    return true;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,3,5",1,"The implementation of the equals method has several changes. The method ""Objects.equals"" is used instead of object's own equal methods, which indicates a change in how the equality is verified (dependent API changed). Additionally, the fields being compared are also different; fields like mTuned, mStereo, mDigital, and mFlags from the early version have been replaced with mLogicallyTunedTo, mPhysicallyTunedTo, mRelatedContent, and mInfoFlags in the late version. These changes in the fields being compared imply that the objects' state comparison logic has been altered significantly (return statement changed). There is also a change in the structure of the if conditions which indicates a control dependency change.","Given the change in the fields being compared, the output of the equals method could potentially differ even for the same input between early and late versions (for instance, if one version considers mTuned while the other considers mLogicallyTunedTo). Thus, this is a compatibility issue due to potential different return values, which is type 1."
769,<android.app.admin.DnsEvent: List<InetAddress> getInetAddresses()>,27,28,<android.app.admin.DnsEvent: List<InetAddress> getInetAddresses()>,<android.app.admin.DnsEvent: List<InetAddress> getInetAddresses()>,0,"{
    if (ipAddresses == null || ipAddresses.length == 0) {
        return Collections.emptyList();
    }
    final List<InetAddress> inetAddresses = new ArrayList<>(ipAddresses.length);
    for (final String ipAddress : ipAddresses) {
        try {
            // ipAddress is already an address, not a host name, no DNS resolution will happen.
            inetAddresses.add(InetAddress.getByName(ipAddress));
        } catch (UnknownHostException e) {
        // Should never happen as we aren't passing a host name.
        }
    }
    return inetAddresses;
}","{
    if (mIpAddresses == null || mIpAddresses.length == 0) {
        return Collections.emptyList();
    }
    final List<InetAddress> inetAddresses = new ArrayList<>(mIpAddresses.length);
    for (final String ipAddress : mIpAddresses) {
        try {
            // ipAddress is already an address, not a host name, no DNS resolution will happen.
            inetAddresses.add(InetAddress.getByName(ipAddress));
        } catch (UnknownHostException e) {
        // Should never happen as we aren't passing a host name.
        }
    }
    return inetAddresses;
}",1,"/**
 * Returns (possibly a subset of) the IP addresses returned.
 */
","/**
 * Returns (possibly a subset of) the IP addresses returned.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The change is merely a renaming of the variable from `ipAddresses` to `mIpAddresses`, which does not affect the return type or the logic of the function. No changes in the control flow, return statements, or exception handling have been made. Therefore, this change type is 4.","There is no compatibility issue arising from this change, as the method's behavior remains the same. The change in the variable name does not affect clients of the API since it is internal to the method's implementation. Thus, the CI type is 0."
770,<android.hardware.fingerprint.FingerprintManager: boolean isHardwareDetected()>,27,28,<android.hardware.fingerprint.FingerprintManager: boolean isHardwareDetected()>,<android.hardware.fingerprint.FingerprintManager: boolean isHardwareDetected()>,0,"{
    if (mService != null) {
        try {
            long deviceId = 0;
            /* TODO: plumb hardware id to FPMS */
            return mService.isHardwareDetected(deviceId, mContext.getOpPackageName());
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    } else {
        Log.w(TAG, ""isFingerprintHardwareDetected(): Service not connected!"");
    }
    return false;
}","{
    if (mService != null) {
        try {
            long deviceId = 0;
            /* TODO: plumb hardware id to FPMS */
            return mService.isHardwareDetected(deviceId, mContext.getOpPackageName());
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    } else {
        Slog.w(TAG, ""isFingerprintHardwareDetected(): Service not connected!"");
    }
    return false;
}",1,"/**
 * Determine if fingerprint hardware is present and functional.
 *
 * @return true if hardware is present and functional, false otherwise.
 */
","/**
 * Determine if fingerprint hardware is present and functional.
 *
 * @return true if hardware is present and functional, false otherwise.
 * @deprecated See {@link BiometricPrompt} and
 * {@link FingerprintManager#FINGERPRINT_ERROR_HW_UNAVAILABLE}
 */
",-1,[@RequiresPermission(USE_FINGERPRINT)],"[@Deprecated, @RequiresPermission(USE_FINGERPRINT)]",-1,-1,-1,-1,-1,-1,4,0,"The only change is the class name used for logging from Log to Slog, which does not affect the behavior of the method, so the change type is 4.","Since the method's functionality and return value are unchanged, there is no Compatibility Issue. Therefore, the CI type is 0."
771,<android.appwidget.AppWidgetProviderInfo: AppWidgetProviderInfo clone()>,27,28,<android.appwidget.AppWidgetProviderInfo: AppWidgetProviderInfo clone()>,<android.appwidget.AppWidgetProviderInfo: AppWidgetProviderInfo clone()>,0,"{
    AppWidgetProviderInfo that = new AppWidgetProviderInfo();
    that.provider = this.provider == null ? null : this.provider.clone();
    that.minWidth = this.minWidth;
    that.minHeight = this.minHeight;
    that.minResizeWidth = this.minResizeHeight;
    that.minResizeHeight = this.minResizeHeight;
    that.updatePeriodMillis = this.updatePeriodMillis;
    that.initialLayout = this.initialLayout;
    that.initialKeyguardLayout = this.initialKeyguardLayout;
    that.configure = this.configure == null ? null : this.configure.clone();
    that.label = this.label == null ? null : this.label.substring(0);
    that.icon = this.icon;
    that.previewImage = this.previewImage;
    that.autoAdvanceViewId = this.autoAdvanceViewId;
    that.resizeMode = this.resizeMode;
    that.widgetCategory = this.widgetCategory;
    that.providerInfo = this.providerInfo;
    return that;
}","{
    AppWidgetProviderInfo that = new AppWidgetProviderInfo();
    that.provider = this.provider == null ? null : this.provider.clone();
    that.minWidth = this.minWidth;
    that.minHeight = this.minHeight;
    that.minResizeWidth = this.minResizeHeight;
    that.minResizeHeight = this.minResizeHeight;
    that.updatePeriodMillis = this.updatePeriodMillis;
    that.initialLayout = this.initialLayout;
    that.initialKeyguardLayout = this.initialKeyguardLayout;
    that.configure = this.configure == null ? null : this.configure.clone();
    that.label = this.label == null ? null : this.label.substring(0);
    that.icon = this.icon;
    that.previewImage = this.previewImage;
    that.autoAdvanceViewId = this.autoAdvanceViewId;
    that.resizeMode = this.resizeMode;
    that.widgetCategory = this.widgetCategory;
    that.providerInfo = this.providerInfo;
    that.widgetFeatures = this.widgetFeatures;
    return that;
}",1,,,-1,"[@Override, @SuppressWarnings(""deprecation"")]","[@Override, @SuppressWarnings(""deprecation"")]",-1,-1,-1,-1,-1,-1,4,0,"The line that.widgetFeatures = this.widgetFeatures; has been added in the late version. Therefore, a new assignment statement is introduced to the method. So the change type is 4.","The added line of assignment does not change the existing behavior or introduce the potential to throw a new type of exception. It simply adds a new field copy to the 'that' object, which doesn't affect how the method works. Therefore, there is no compatibility issue, and the CI type is 0."
772,<android.bluetooth.le.AdvertisingSetParameters.Builder: Builder setScannable(boolean)>,27,28,<android.bluetooth.le.AdvertisingSetParameters.Builder: Builder setScannable(boolean)>,<android.bluetooth.le.AdvertisingSetParameters.Builder: Builder setScannable(boolean)>,0,"{
    this.scannable = scannable;
    return this;
}","{
    mScannable = scannable;
    return this;
}",1,"/**
 * Set whether the advertisement type should be scannable.
 * Legacy advertisements can be both connectable and scannable. Non-legacy
 * advertisements can be only scannable or only connectable.
 * @param scannable Controls whether the advertisement type will be
 * scannable (true) or non-scannable (false).
 */
","/**
 * Set whether the advertisement type should be scannable.
 * Legacy advertisements can be both connectable and scannable. Non-legacy
 * advertisements can be only scannable or only connectable.
 *
 * @param scannable Controls whether the advertisement type will be scannable (true) or
 * non-scannable (false).
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The only change is the name of the instance variable from ""this.scannable"" to ""mScannable"", which is an internal change and does not affect the method's signature or its externally observable behavior. The code change type is 4.","There is no Compatibility Issue, as renaming a variable does not change the behavior of the method with respect to its inputs and outputs. The method still sets a value and returns the same object, so the CI type is 0."
774,<android.widget.TextView: boolean hasSelection()>,27,28,<android.widget.TextView: boolean hasSelection()>,<android.widget.TextView: boolean hasSelection()>,0,"{
    final int selectionStart = getSelectionStart();
    final int selectionEnd = getSelectionEnd();
    return selectionStart >= 0 && selectionStart != selectionEnd;
}","{
    final int selectionStart = getSelectionStart();
    final int selectionEnd = getSelectionEnd();
    return selectionStart >= 0 && selectionEnd > 0 && selectionStart != selectionEnd;
}",1,"/**
 * Return true iff there is a selection inside this text view.
 */
","/**
 * Return true iff there is a selection inside this text view.
 */
",-1,,,-1,-1,-1,-1,-1,-1,3,1,"The control dependency has changed as an additional condition '`selectionEnd > 0`' is added to the return statement, so the code change type is 3.","The added condition '`selectionEnd > 0`' means that the late version of the method could return a different value, by potentially returning `false` when `selectionEnd` is `0`, where the early version would have returned `true` if `selectionStart` was not `0` and `selectionStart` did not equal `selectionEnd`. Therefore, the CI type is 1 due to a potential difference in the returned value."
777,"<android.provider.Settings.System: int getInt(ContentResolver,String,int)>",27,28,"<android.provider.Settings.System: int getInt(ContentResolver,String,int)>","<android.provider.Settings.System: int getInt(ContentResolver,String,int)>",0,"{
    return getIntForUser(cr, name, def, UserHandle.myUserId());
}","{
    return getIntForUser(cr, name, def, cr.getUserId());
}",1,"/**
 * Convenience function for retrieving a single system settings value
 * as an integer.  Note that internally setting values are always
 * stored as strings; this function converts the string to an integer
 * for you.  The default value will be returned if the setting is
 * not defined or not an integer.
 *
 * @param cr The ContentResolver to access.
 * @param name The name of the setting to retrieve.
 * @param def Value to return if the setting is not defined.
 *
 * @return The setting's current value, or 'def' if it is not defined
 * or not a valid integer.
 */
","/**
 * Convenience function for retrieving a single system settings value
 * as an integer.  Note that internally setting values are always
 * stored as strings; this function converts the string to an integer
 * for you.  The default value will be returned if the setting is
 * not defined or not an integer.
 *
 * @param cr The ContentResolver to access.
 * @param name The name of the setting to retrieve.
 * @param def Value to return if the setting is not defined.
 *
 * @return The setting's current value, or 'def' if it is not defined
 * or not a valid integer.
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The change from UserHandle.myUserId() to cr.getUserId() indicates that there is a change in the way the user ID is obtained for the API call. Hence, the code change type is 5 (Dependent API changed).","Despite a change in the dependent API, there is no Compatibility Issue as the method signature and the behavior of getInt remain the same, intending to return an integer setting value for the specified name and user. As long as cr.getUserId() returns the correct user ID as UserHandle.myUserId() did, which is the expected behavior, the functionality of getInt remains unchanged for the caller. Thus, no CI caused by potential different return values, types or exception handlings is expected."
778,<android.app.Notification.MessagingStyle.Message: CharSequence getSender()>,27,28,<android.app.Notification.MessagingStyle.Message: CharSequence getSender()>,<android.app.Notification.MessagingStyle.Message: CharSequence getSender()>,0,"{
    return mSender;
}","{
    return mSender == null ? null : mSender.getName();
}",1,"/**
 * Get the text used to display the contact's name in the messaging experience
 */
","/**
 * Get the text used to display the contact's name in the messaging experience
 *
 * @deprecated use {@link #getSenderPerson()}
 */
",-1,,,-1,-1,-1,-1,-1,-1,1,1,"The return statement is changed, including a conditional operator that alters the value being returned based on the condition `mSender == null`, so the code change type is 1.","The modification in the return statement may potentially lead to a different return value since it now returns either `null` or `mSender.getName()` instead of just `mSender`, and therefore the CI type is 1."
779,<android.hardware.radio.TunerAdapter: void setAnalogForced(boolean)>,27,28,<android.hardware.radio.TunerAdapter: void setAnalogForced(boolean)>,<android.hardware.radio.TunerAdapter: void setAnalogForced(boolean)>,0,"{
    try {
        mTuner.setAnalogForced(isForced);
    } catch (RemoteException e) {
        throw new RuntimeException(""service died"", e);
    }
}","{
    try {
        setConfigFlag(RadioManager.CONFIG_FORCE_ANALOG, isForced);
    } catch (UnsupportedOperationException ex) {
        throw new IllegalStateException(ex);
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"2,4,5","1,2","There has been a change in the body of the try block from invoking mTuner.setAnalogForced(isForced) to setConfigFlag(RadioManager.CONFIG_FORCE_ANALOG, isForced). The catch block has changed from catching RemoteException to catching UnsupportedOperationException, and the thrown exception type inside the catch block has changed from RuntimeException to IllegalStateException. The dependent API setAnalogForced(boolean) is replaced with setConfigFlag(int, boolean). Thus, the code change types are 2,4,5.","The method now relies on a different dependent API, setConfigFlag, which could exhibit different behaviors compared to the original method mTuner.setAnalogForced(isForced), resulting in a potential different outcome (CI type 1). Moreover, by catching a different exception type and throwing a different type of RuntimeException, the exception handling has significantly changed which may cause a different exception to be thrown to the callers of the method (CI type 2)."
780,<android.bluetooth.le.PeriodicAdvertisingParameters: boolean getIncludeTxPower()>,27,28,<android.bluetooth.le.PeriodicAdvertisingParameters: boolean getIncludeTxPower()>,<android.bluetooth.le.PeriodicAdvertisingParameters: boolean getIncludeTxPower()>,0,"{
    return includeTxPower;
}","{
    return mIncludeTxPower;
}",1,"/**
 * Returns whether the TX Power will be included.
 */
","/**
 * Returns whether the TX Power will be included.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The code has only changed the variable name from 'includeTxPower' to 'mIncludeTxPower'. This change is related to the internal representation but does not affect the method's behavior, so the code change type is 4.","The change in the variable name does not lead to a compatibility issue because it does not alter the behavior of the API or how it is used. Therefore, the CI type is 0."
782,<android.net.NetworkStats.Entry: boolean equals(Object)>,27,28,<android.net.NetworkStats.Entry: boolean equals(Object)>,<android.net.NetworkStats.Entry: boolean equals(Object)>,0,"{
    if (o instanceof Entry) {
        final Entry e = (Entry) o;
        return uid == e.uid && set == e.set && tag == e.tag && metered == e.metered && roaming == e.roaming && rxBytes == e.rxBytes && rxPackets == e.rxPackets && txBytes == e.txBytes && txPackets == e.txPackets && operations == e.operations && iface.equals(e.iface);
    }
    return false;
}","{
    if (o instanceof Entry) {
        final Entry e = (Entry) o;
        return uid == e.uid && set == e.set && tag == e.tag && metered == e.metered && roaming == e.roaming && defaultNetwork == e.defaultNetwork && rxBytes == e.rxBytes && rxPackets == e.rxPackets && txBytes == e.txBytes && txPackets == e.txPackets && operations == e.operations && iface.equals(e.iface);
    }
    return false;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,4",1,"The method implementation has changed; it now includes an additional field `defaultNetwork == e.defaultNetwork` in the return statement, and consequently, it removes another field `&& operations == e.operations` from the set of conditions. These changes will cause the method to produce different results for the `equals` comparison, thus the code change types are 1,4.","Since the `equals` method's behavior has been altered to consider a new field `defaultNetwork` and to no longer consider `operations`, it will return a different value for objects that might previously have been considered equal or not equal. This constitutes a Compatibility Issue of type 1."
784,"<android.widget.TextView: void onFocusChanged(boolean,int,Rect)>",27,28,"<android.widget.TextView: void onFocusChanged(boolean,int,Rect)>","<android.widget.TextView: void onFocusChanged(boolean,int,Rect)>",0,"{
    if (isTemporarilyDetached()) {
        // If we are temporarily in the detach state, then do nothing.
        super.onFocusChanged(focused, direction, previouslyFocusedRect);
        return;
    }
    if (mEditor != null)
        mEditor.onFocusChanged(focused, direction);
    if (focused) {
        if (mText instanceof Spannable) {
            Spannable sp = (Spannable) mText;
            MetaKeyKeyListener.resetMetaState(sp);
        }
    }
    startStopMarquee(focused);
    if (mTransformation != null) {
        mTransformation.onFocusChanged(this, mText, focused, direction, previouslyFocusedRect);
    }
    super.onFocusChanged(focused, direction, previouslyFocusedRect);
}","{
    if (isTemporarilyDetached()) {
        // If we are temporarily in the detach state, then do nothing.
        super.onFocusChanged(focused, direction, previouslyFocusedRect);
        return;
    }
    if (mEditor != null)
        mEditor.onFocusChanged(focused, direction);
    if (focused) {
        if (mSpannable != null) {
            MetaKeyKeyListener.resetMetaState(mSpannable);
        }
    }
    startStopMarquee(focused);
    if (mTransformation != null) {
        mTransformation.onFocusChanged(this, mText, focused, direction, previouslyFocusedRect);
    }
    super.onFocusChanged(focused, direction, previouslyFocusedRect);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,5",0,"The variable used inside the 'if (focused)' block changed from mText to mSpannable and the associated cast operation is removed, thus the control dependency inside this block changed. Furthermore, since mSpannable is likely derived from mText or refers to the same Spannable part of the text but without the explicit cast, it indicates a change in a dependent API (mSpannable). Therefore, the code change type is 3,5.","Although the implementation has changed, this would not introduce a compatibility issue as long as mSpannable refers to the same data portion previously referred to by the cast of mText to Spannable. Since the behaviour when 'focused' is true does not change the actual behaviour of the method (no new branching logic is introduced, exception handling is the same, and no new or changed return types or values are introduced), there's no compatibility issue. Hence, the CI type is 0."
785,<android.os.StrictMode.AndroidBlockGuardPolicy: void onCustomSlowCall(String)>,27,28,<android.os.StrictMode.AndroidBlockGuardPolicy: void onCustomSlowCall(String)>,<android.os.StrictMode.AndroidBlockGuardPolicy: void onCustomSlowCall(String)>,0,"{
    if ((mPolicyMask & DETECT_CUSTOM) == 0) {
        return;
    }
    if (tooManyViolationsThisLoop()) {
        return;
    }
    BlockGuard.BlockGuardPolicyException e = new StrictModeCustomViolation(mPolicyMask, name);
    e.fillInStackTrace();
    startHandlingViolationException(e);
}","{
    if ((mPolicyMask & DETECT_CUSTOM) == 0) {
        return;
    }
    if (tooManyViolationsThisLoop()) {
        return;
    }
    startHandlingViolationException(new CustomViolation(name));
}",1,"// Not part of BlockGuard.Policy; just part of StrictMode:
","// Not part of BlockGuard.Policy; just part of StrictMode:
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",0,"The instantiation of the exception object has changed from new StrictModeCustomViolation(mPolicyMask, name) to new CustomViolation(name), and there is no longer a call to e.fillInStackTrace(). These are changes in the exception handling statement (despite no changes in the control flow for exception throwing) and other statements, which leads to the code change type 3,4.","There's no Compatibility Issue here, since the method signature hasn't changed, exceptions are handled internally without affecting the callers, and the control flow hasn't changed which would lead to different exceptions being thrown. The method's behavior, in terms of how it interacts with the caller, remains consistent despite the change in the internal construction of the exception object. Therefore, the CI type is 0."
786,"<android.widget.Editor.InsertionHandleView: int getCursorHorizontalPosition(Layout,int)>",27,28,"<android.widget.Editor.InsertionHandleView: int getCursorHorizontalPosition(Layout,int)>","<android.widget.Editor.InsertionHandleView: int getCursorHorizontalPosition(Layout,int)>",0,"{
    final Drawable drawable = mCursorCount > 0 ? mCursorDrawable[0] : null;
    if (drawable != null) {
        final float horizontal = getHorizontal(layout, offset);
        return clampHorizontalPosition(drawable, horizontal) + mTempRect.left;
    }
    return super.getCursorHorizontalPosition(layout, offset);
}","{
    if (mDrawableForCursor != null) {
        final float horizontal = getHorizontal(layout, offset);
        return clampHorizontalPosition(mDrawableForCursor, horizontal) + mTempRect.left;
    }
    return super.getCursorHorizontalPosition(layout, offset);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"4,5",1,"The reference to the drawable object has changed from accessing mCursorDrawable[0] to directly using mDrawableForCursor. Since how the drawable is accessed has been altered, this indicates that the dependent API or the way the drawable for the cursor is accessed has been changed. Additionally, the check for mCursorCount > 0 has been removed, which is another statement change; hence the change types are 4 and 5.","The mDrawableForCursor might refer to a different drawable compared to mCursorDrawable[0], and since the condition mCursorCount > 0 is removed, it could result in the method returning a different horizontal position even for the same input values, so the CI type is 1."
787,"<android.widget.AbsListView: boolean trackMotionScroll(int,int)>",27,28,"<android.widget.AbsListView: boolean trackMotionScroll(int,int)>","<android.widget.AbsListView: boolean trackMotionScroll(int,int)>",0,"{
    final int childCount = getChildCount();
    if (childCount == 0) {
        return true;
    }
    final int firstTop = getChildAt(0).getTop();
    final int lastBottom = getChildAt(childCount - 1).getBottom();
    final Rect listPadding = mListPadding;
    // ""effective padding"" In this case is the amount of padding that affects
    // how much space should not be filled by items. If we don't clip to padding
    // there is no effective padding.
    int effectivePaddingTop = 0;
    int effectivePaddingBottom = 0;
    if ((mGroupFlags & CLIP_TO_PADDING_MASK) == CLIP_TO_PADDING_MASK) {
        effectivePaddingTop = listPadding.top;
        effectivePaddingBottom = listPadding.bottom;
    }
    // FIXME account for grid vertical spacing too?
    final int spaceAbove = effectivePaddingTop - firstTop;
    final int end = getHeight() - effectivePaddingBottom;
    final int spaceBelow = lastBottom - end;
    final int height = getHeight() - mPaddingBottom - mPaddingTop;
    if (deltaY < 0) {
        deltaY = Math.max(-(height - 1), deltaY);
    } else {
        deltaY = Math.min(height - 1, deltaY);
    }
    if (incrementalDeltaY < 0) {
        incrementalDeltaY = Math.max(-(height - 1), incrementalDeltaY);
    } else {
        incrementalDeltaY = Math.min(height - 1, incrementalDeltaY);
    }
    final int firstPosition = mFirstPosition;
    // Update our guesses for where the first and last views are
    if (firstPosition == 0) {
        mFirstPositionDistanceGuess = firstTop - listPadding.top;
    } else {
        mFirstPositionDistanceGuess += incrementalDeltaY;
    }
    if (firstPosition + childCount == mItemCount) {
        mLastPositionDistanceGuess = lastBottom + listPadding.bottom;
    } else {
        mLastPositionDistanceGuess += incrementalDeltaY;
    }
    final boolean cannotScrollDown = (firstPosition == 0 && firstTop >= listPadding.top && incrementalDeltaY >= 0);
    final boolean cannotScrollUp = (firstPosition + childCount == mItemCount && lastBottom <= getHeight() - listPadding.bottom && incrementalDeltaY <= 0);
    if (cannotScrollDown || cannotScrollUp) {
        return incrementalDeltaY != 0;
    }
    final boolean down = incrementalDeltaY < 0;
    final boolean inTouchMode = isInTouchMode();
    if (inTouchMode) {
        hideSelector();
    }
    final int headerViewsCount = getHeaderViewsCount();
    final int footerViewsStart = mItemCount - getFooterViewsCount();
    int start = 0;
    int count = 0;
    if (down) {
        int top = -incrementalDeltaY;
        if ((mGroupFlags & CLIP_TO_PADDING_MASK) == CLIP_TO_PADDING_MASK) {
            top += listPadding.top;
        }
        for (int i = 0; i < childCount; i++) {
            final View child = getChildAt(i);
            if (child.getBottom() >= top) {
                break;
            } else {
                count++;
                int position = firstPosition + i;
                if (position >= headerViewsCount && position < footerViewsStart) {
                    // The view will be rebound to new data, clear any
                    // system-managed transient state.
                    child.clearAccessibilityFocus();
                    mRecycler.addScrapView(child, position);
                }
            }
        }
    } else {
        int bottom = getHeight() - incrementalDeltaY;
        if ((mGroupFlags & CLIP_TO_PADDING_MASK) == CLIP_TO_PADDING_MASK) {
            bottom -= listPadding.bottom;
        }
        for (int i = childCount - 1; i >= 0; i--) {
            final View child = getChildAt(i);
            if (child.getTop() <= bottom) {
                break;
            } else {
                start = i;
                count++;
                int position = firstPosition + i;
                if (position >= headerViewsCount && position < footerViewsStart) {
                    // The view will be rebound to new data, clear any
                    // system-managed transient state.
                    child.clearAccessibilityFocus();
                    mRecycler.addScrapView(child, position);
                }
            }
        }
    }
    mMotionViewNewTop = mMotionViewOriginalTop + deltaY;
    mBlockLayoutRequests = true;
    if (count > 0) {
        detachViewsFromParent(start, count);
        mRecycler.removeSkippedScrap();
    }
    // calls to bubble up from the children all the way to the top
    if (!awakenScrollBars()) {
        invalidate();
    }
    offsetChildrenTopAndBottom(incrementalDeltaY);
    if (down) {
        mFirstPosition += count;
    }
    final int absIncrementalDeltaY = Math.abs(incrementalDeltaY);
    if (spaceAbove < absIncrementalDeltaY || spaceBelow < absIncrementalDeltaY) {
        fillGap(down);
    }
    mRecycler.fullyDetachScrapViews();
    if (!inTouchMode && mSelectedPosition != INVALID_POSITION) {
        final int childIndex = mSelectedPosition - mFirstPosition;
        if (childIndex >= 0 && childIndex < getChildCount()) {
            positionSelector(mSelectedPosition, getChildAt(childIndex));
        }
    } else if (mSelectorPosition != INVALID_POSITION) {
        final int childIndex = mSelectorPosition - mFirstPosition;
        if (childIndex >= 0 && childIndex < getChildCount()) {
            positionSelector(INVALID_POSITION, getChildAt(childIndex));
        }
    } else {
        mSelectorRect.setEmpty();
    }
    mBlockLayoutRequests = false;
    invokeOnItemScrollListener();
    return false;
}","{
    final int childCount = getChildCount();
    if (childCount == 0) {
        return true;
    }
    final int firstTop = getChildAt(0).getTop();
    final int lastBottom = getChildAt(childCount - 1).getBottom();
    final Rect listPadding = mListPadding;
    // ""effective padding"" In this case is the amount of padding that affects
    // how much space should not be filled by items. If we don't clip to padding
    // there is no effective padding.
    int effectivePaddingTop = 0;
    int effectivePaddingBottom = 0;
    if ((mGroupFlags & CLIP_TO_PADDING_MASK) == CLIP_TO_PADDING_MASK) {
        effectivePaddingTop = listPadding.top;
        effectivePaddingBottom = listPadding.bottom;
    }
    // FIXME account for grid vertical spacing too?
    final int spaceAbove = effectivePaddingTop - firstTop;
    final int end = getHeight() - effectivePaddingBottom;
    final int spaceBelow = lastBottom - end;
    final int height = getHeight() - mPaddingBottom - mPaddingTop;
    if (deltaY < 0) {
        deltaY = Math.max(-(height - 1), deltaY);
    } else {
        deltaY = Math.min(height - 1, deltaY);
    }
    if (incrementalDeltaY < 0) {
        incrementalDeltaY = Math.max(-(height - 1), incrementalDeltaY);
    } else {
        incrementalDeltaY = Math.min(height - 1, incrementalDeltaY);
    }
    final int firstPosition = mFirstPosition;
    // Update our guesses for where the first and last views are
    if (firstPosition == 0) {
        mFirstPositionDistanceGuess = firstTop - listPadding.top;
    } else {
        mFirstPositionDistanceGuess += incrementalDeltaY;
    }
    if (firstPosition + childCount == mItemCount) {
        mLastPositionDistanceGuess = lastBottom + listPadding.bottom;
    } else {
        mLastPositionDistanceGuess += incrementalDeltaY;
    }
    final boolean cannotScrollDown = (firstPosition == 0 && firstTop >= listPadding.top && incrementalDeltaY >= 0);
    final boolean cannotScrollUp = (firstPosition + childCount == mItemCount && lastBottom <= getHeight() - listPadding.bottom && incrementalDeltaY <= 0);
    if (cannotScrollDown || cannotScrollUp) {
        return incrementalDeltaY != 0;
    }
    final boolean down = incrementalDeltaY < 0;
    final boolean inTouchMode = isInTouchMode();
    if (inTouchMode) {
        hideSelector();
    }
    final int headerViewsCount = getHeaderViewsCount();
    final int footerViewsStart = mItemCount - getFooterViewsCount();
    int start = 0;
    int count = 0;
    if (down) {
        int top = -incrementalDeltaY;
        if ((mGroupFlags & CLIP_TO_PADDING_MASK) == CLIP_TO_PADDING_MASK) {
            top += listPadding.top;
        }
        for (int i = 0; i < childCount; i++) {
            final View child = getChildAt(i);
            if (child.getBottom() >= top) {
                break;
            } else {
                count++;
                int position = firstPosition + i;
                if (position >= headerViewsCount && position < footerViewsStart) {
                    // The view will be rebound to new data, clear any
                    // system-managed transient state.
                    child.clearAccessibilityFocus();
                    mRecycler.addScrapView(child, position);
                }
            }
        }
    } else {
        int bottom = getHeight() - incrementalDeltaY;
        if ((mGroupFlags & CLIP_TO_PADDING_MASK) == CLIP_TO_PADDING_MASK) {
            bottom -= listPadding.bottom;
        }
        for (int i = childCount - 1; i >= 0; i--) {
            final View child = getChildAt(i);
            if (child.getTop() <= bottom) {
                break;
            } else {
                start = i;
                count++;
                int position = firstPosition + i;
                if (position >= headerViewsCount && position < footerViewsStart) {
                    // The view will be rebound to new data, clear any
                    // system-managed transient state.
                    child.clearAccessibilityFocus();
                    mRecycler.addScrapView(child, position);
                }
            }
        }
    }
    mMotionViewNewTop = mMotionViewOriginalTop + deltaY;
    mBlockLayoutRequests = true;
    if (count > 0) {
        detachViewsFromParent(start, count);
        mRecycler.removeSkippedScrap();
    }
    // calls to bubble up from the children all the way to the top
    if (!awakenScrollBars()) {
        invalidate();
    }
    offsetChildrenTopAndBottom(incrementalDeltaY);
    if (down) {
        mFirstPosition += count;
    }
    final int absIncrementalDeltaY = Math.abs(incrementalDeltaY);
    if (spaceAbove < absIncrementalDeltaY || spaceBelow < absIncrementalDeltaY) {
        fillGap(down);
    }
    mRecycler.fullyDetachScrapViews();
    boolean selectorOnScreen = false;
    if (!inTouchMode && mSelectedPosition != INVALID_POSITION) {
        final int childIndex = mSelectedPosition - mFirstPosition;
        if (childIndex >= 0 && childIndex < getChildCount()) {
            positionSelector(mSelectedPosition, getChildAt(childIndex));
            selectorOnScreen = true;
        }
    } else if (mSelectorPosition != INVALID_POSITION) {
        final int childIndex = mSelectorPosition - mFirstPosition;
        if (childIndex >= 0 && childIndex < getChildCount()) {
            positionSelector(mSelectorPosition, getChildAt(childIndex));
            selectorOnScreen = true;
        }
    }
    if (!selectorOnScreen) {
        mSelectorRect.setEmpty();
    }
    mBlockLayoutRequests = false;
    invokeOnItemScrollListener();
    return false;
}",1,"/**
 * Track a motion scroll
 *
 * @param deltaY Amount to offset mMotionView. This is the accumulated delta since the motion
 * began. Positive numbers mean the user's finger is moving down the screen.
 * @param incrementalDeltaY Change in deltaY from the previous event.
 * @return true if we're already at the beginning/end of the list and have nothing to do.
 */
","/**
 * Track a motion scroll
 *
 * @param deltaY Amount to offset mMotionView. This is the accumulated delta since the motion
 * began. Positive numbers mean the user's finger is moving down the screen.
 * @param incrementalDeltaY Change in deltaY from the previous event.
 * @return true if we're already at the beginning/end of the list and have nothing to do.
 */
",-1,,,-1,-1,-1,-1,-1,-1,,,,
788,"<android.text.TextUtils: String join(CharSequence,Iterable)>",27,28,"<android.text.TextUtils: String join(CharSequence,Iterable)>","<android.text.TextUtils: String join(CharSequence,Iterable)>",0,"{
    StringBuilder sb = new StringBuilder();
    Iterator<?> it = tokens.iterator();
    if (it.hasNext()) {
        sb.append(it.next());
        while (it.hasNext()) {
            sb.append(delimiter);
            sb.append(it.next());
        }
    }
    return sb.toString();
}","{
    final Iterator<?> it = tokens.iterator();
    if (!it.hasNext()) {
        return """";
    }
    final StringBuilder sb = new StringBuilder();
    sb.append(it.next());
    while (it.hasNext()) {
        sb.append(delimiter);
        sb.append(it.next());
    }
    return sb.toString();
}",1,"/**
 * Returns a string containing the tokens joined by delimiters.
 * @param tokens an array objects to be joined. Strings will be formed from
 * the objects by calling object.toString().
 */
","/**
 * Returns a string containing the tokens joined by delimiters.
 *
 * @param delimiter a CharSequence that will be inserted between the tokens. If null, the string
 * ""null"" will be used as the delimiter.
 * @param tokens an array objects to be joined. Strings will be formed from the objects by
 * calling object.toString(). If tokens is null, a NullPointerException will be thrown. If
 * tokens is empty, an empty string will be returned.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3",1,"The late implementation includes a new early return statement (return """") when the iterator has no elements, and the StringBuilder initialization is now inside the condition. Additionally, there's a change in control dependency where the check to see if the iterator has next element has been inverted. Thus, the changes are of type 1 and 3.","The addition of the early return statement could lead the method to return an empty string in scenarios where the early version would have progressed to initialize the StringBuilder. Thus, this introduces a potential Compatibility Issue caused by different return values or types between versions, marking it as type 1."
789,"<android.view.View: boolean onKeyUp(int,KeyEvent)>",27,28,"<android.view.View: boolean onKeyUp(int,KeyEvent)>","<android.view.View: boolean onKeyUp(int,KeyEvent)>",0,"{
    if (KeyEvent.isConfirmKey(keyCode)) {
        if ((mViewFlags & ENABLED_MASK) == DISABLED) {
            return true;
        }
        if ((mViewFlags & CLICKABLE) == CLICKABLE && isPressed()) {
            setPressed(false);
            if (!mHasPerformedLongPress) {
                // This is a tap, so remove the longpress check
                removeLongPressCallback();
                if (!event.isCanceled()) {
                    return performClick();
                }
            }
        }
    }
    return false;
}","{
    if (KeyEvent.isConfirmKey(keyCode)) {
        if ((mViewFlags & ENABLED_MASK) == DISABLED) {
            return true;
        }
        if ((mViewFlags & CLICKABLE) == CLICKABLE && isPressed()) {
            setPressed(false);
            if (!mHasPerformedLongPress) {
                // This is a tap, so remove the longpress check
                removeLongPressCallback();
                if (!event.isCanceled()) {
                    return performClickInternal();
                }
            }
        }
    }
    return false;
}",1,"/**
 * Default implementation of {@link KeyEvent.Callback#onKeyUp(int, KeyEvent)
 * KeyEvent.Callback.onKeyUp()}: perform clicking of the view
 * when {@link KeyEvent#KEYCODE_DPAD_CENTER}, {@link KeyEvent#KEYCODE_ENTER}
 * or {@link KeyEvent#KEYCODE_SPACE} is released.
 * <p>Key presses in software keyboards will generally NOT trigger this listener,
 * although some may elect to do so in some situations. Do not rely on this to
 * catch software key presses.
 *
 * @param keyCode A key code that represents the button pressed, from
 * {@link android.view.KeyEvent}.
 * @param event   The KeyEvent object that defines the button action.
 */
","/**
 * Default implementation of {@link KeyEvent.Callback#onKeyUp(int, KeyEvent)
 * KeyEvent.Callback.onKeyUp()}: perform clicking of the view
 * when {@link KeyEvent#KEYCODE_DPAD_CENTER}, {@link KeyEvent#KEYCODE_ENTER}
 * or {@link KeyEvent#KEYCODE_SPACE} is released.
 * <p>Key presses in software keyboards will generally NOT trigger this listener,
 * although some may elect to do so in some situations. Do not rely on this to
 * catch software key presses.
 *
 * @param keyCode A key code that represents the button pressed, from
 * {@link android.view.KeyEvent}.
 * @param event   The KeyEvent object that defines the button action.
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The dependent API within the return statement has changed from performClick() to performClickInternal(), so the code change type is 5. ","There is no Compatibility Issue caused by potential different return values or exception handling since the return statement itself is not altered in behaviorit still returns the result of a perform click action, and no exception handling is modified. It's presumed that performClickInternal() behaves identically to performClick() from the caller's perspective regarding return values and exceptions, albeit the actual internal implementation might have changed. Hence, the CI type is 0."
791,<android.widget.TextView: boolean hasOverlappingRendering()>,27,28,<android.widget.TextView: boolean hasOverlappingRendering()>,<android.widget.TextView: boolean hasOverlappingRendering()>,0,"{
    // horizontal fading edge causes SaveLayerAlpha, which doesn't support alpha modulation
    return ((getBackground() != null && getBackground().getCurrent() != null) || mText instanceof Spannable || hasSelection() || isHorizontalFadingEdgeEnabled());
}","{
    // horizontal fading edge causes SaveLayerAlpha, which doesn't support alpha modulation
    return ((getBackground() != null && getBackground().getCurrent() != null) || mSpannable != null || hasSelection() || isHorizontalFadingEdgeEnabled());
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,4",1,"The early implementation checks if mText is an instance of Spannable, whereas the late implementation checks if mSpannable is not null. There's also a variable name change, so the code change types are 1 and 4.","Since the code change replaces `mText instanceof Spannable` with `mSpannable != null`, this could potentially return different values depending on the state of the TextView. If mText is a Spannable but mSpannable is null, or vice versa, the result could differ between versions, hence the CI type is 1."
792,<android.widget.RemoteViewsAdapter.RemoteViewsFrameLayoutRefSet: void removeView(RemoteViewsFrameLayout)>,27,28,<android.widget.RemoteViewsAdapter.RemoteViewsFrameLayoutRefSet: void removeView(RemoteViewsFrameLayout)>,<android.widget.RemoteViewsAdapter.RemoteViewsFrameLayoutRefSet: void removeView(RemoteViewsFrameLayout)>,0,"{
    if (mViewToLinkedList.containsKey(rvfl)) {
        mViewToLinkedList.get(rvfl).remove(rvfl);
        mViewToLinkedList.remove(rvfl);
    }
}","{
    if (rvfl.cacheIndex < 0) {
        return;
    }
    final LinkedList<RemoteViewsFrameLayout> refs = get(rvfl.cacheIndex);
    if (refs != null) {
        refs.remove(rvfl);
    }
    rvfl.cacheIndex = -1;
}",1,"/**
 * We need to remove views from this set if they have been recycled by the AdapterView.
 */
","/**
 * We need to remove views from this set if they have been recycled by the AdapterView.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3",1,"The control dependency and the return statements have changed. In the early version, it checks if the key exists in the map before removing, while the late version returns early if rvfl.cacheIndex is less than 0. Additionally, a different method is used to retrieve the list, and the removal is based on cacheIndex. At the end of the late implementation, it sets rvfl.cacheIndex to -1 directly, which is a new line of operation not present in the early version.","The logic for determining whether a view is removed has changed, potentially resulting in different views being removed, or not removed at all, compared to the earlier version. Specifically, the use of a return statement based on rvfl.cacheIndex can lead to an early exit in the late implementation, which alters the behavior of the method. Furthermore, settings the cacheIndex to -1 is a new operation that changes the state of the argument passed to the method. Hence, there is a Compatibility Issue due to the potential of different return values or types (since the early implementation could potentially leave rvfl.cacheIndex unchanged, while the late implementation always sets it to -1)."
793,<android.widget.Editor.InsertionHandleView: int getCursorOffset()>,27,28,<android.widget.Editor.InsertionHandleView: int getCursorOffset()>,<android.widget.Editor.InsertionHandleView: int getCursorOffset()>,0,"{
    int offset = super.getCursorOffset();
    final Drawable cursor = mCursorCount > 0 ? mCursorDrawable[0] : null;
    if (cursor != null) {
        cursor.getPadding(mTempRect);
        offset += (cursor.getIntrinsicWidth() - mTempRect.left - mTempRect.right) / 2;
    }
    return offset;
}","{
    int offset = super.getCursorOffset();
    if (mDrawableForCursor != null) {
        mDrawableForCursor.getPadding(mTempRect);
        offset += (mDrawableForCursor.getIntrinsicWidth() - mTempRect.left - mTempRect.right) / 2;
    }
    return offset;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"4,5",1,"The variable used within the method has changed from an array `mCursorDrawable[0]` to a single drawable `mDrawableForCursor`. Although the overall structure of the method remains,",#CI_description
795,"<android.app.SharedPreferencesImpl.EditorImpl: Editor putStringSet(String,Set<String>)>",27,28,"<android.app.SharedPreferencesImpl.EditorImpl: Editor putStringSet(String,Set<String>)>","<android.app.SharedPreferencesImpl.EditorImpl: Editor putStringSet(String,Set<String>)>",0,"{
    synchronized (mLock) {
        mModified.put(key, (values == null) ? null : new HashSet<String>(values));
        return this;
    }
}","{
    synchronized (mEditorLock) {
        mModified.put(key, (values == null) ? null : new HashSet<String>(values));
        return this;
    }
}",1,,,-1,,[@Override],-1,-1,-1,-1,-1,-1,3,0,The only change is in the synchronization lock object from `mLock` to `mEditorLock`. This change type is categorized under control dependency changes (type 3).,"The modification of the lock object used for synchronization doesn't change the external behavior of the method. The method's logic remains unchanged; it still reads the input parameters and modifies the internal `mModified` map the same way, and returns `this`. Therefore, there is no compatibility issue (type 0)."
796,<android.os.storage.StorageManager: StorageVolume getPrimaryStorageVolume()>,27,28,<android.os.storage.StorageManager: StorageVolume getPrimaryStorageVolume()>,<android.os.storage.StorageManager: StorageVolume getPrimaryStorageVolume()>,0,"{
    return getVolumeList(UserHandle.myUserId(), FLAG_REAL_STATE | FLAG_INCLUDE_INVISIBLE)[0];
}","{
    return getVolumeList(mContext.getUserId(), FLAG_REAL_STATE | FLAG_INCLUDE_INVISIBLE)[0];
}",1,"/**
 * Return the primary shared/external storage volume available to the
 * current user. This volume is the same storage device returned by
 * {@link Environment#getExternalStorageDirectory()} and
 * {@link Context#getExternalFilesDir(String)}.
 */
","/**
 * Return the primary shared/external storage volume available to the
 * current user. This volume is the same storage device returned by
 * {@link Environment#getExternalStorageDirectory()} and
 * {@link Context#getExternalFilesDir(String)}.
 */
",-1,[@NonNull],[@NonNull],-1,-1,-1,-1,-1,-1,"4,5",0,"The implementation change involves a different method being called for getting the user ID (from UserHandle.myUserId() to mContext.getUserId()). This change is in method invocation parameters which correspond to code change types 4,5.","While the method being used to obtain the user ID is different, the change should not cause a compatibility issue as long as both methods return the same user ID for the context in which this API is used. Based on the provided code and annotations, there is no indication that the behavior of getting the primary storage volume has changed. Hence, there is no compatibility issue."
797,<android.hardware.radio.RadioManager.ProgramInfo: boolean isMuted()>,27,28,<android.hardware.radio.RadioManager.ProgramInfo: boolean isMuted()>,<android.hardware.radio.RadioManager.ProgramInfo: boolean isMuted()>,0,"{
    return (mFlags & FLAG_MUTED) != 0;
}","{
    return (mInfoFlags & FLAG_MUTED) != 0;
}",1,"/**
 * {@code true} if radio stream is not playing, ie. due to bad reception
 * conditions or buffering. In this state volume knob MAY be disabled to
 * prevent user increasing volume too much.
 * It does NOT mean the user has muted audio.
 */
","/**
 * {@code true} if radio stream is not playing, ie. due to bad reception
 * conditions or buffering. In this state volume knob MAY be disabled to
 * prevent user increasing volume too much.
 * It does NOT mean the user has muted audio.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The field name in the return statement has been changed from `mFlags` to `mInfoFlags`. This is classified as a change in the other statement category, so the code change type is 4.","The change in the field name does not automatically indicate a compatibility issue, as it depends on whether the semantics of the fields `mFlags` and `mInfoFlags` are the same. If `mInfoFlags` simply represents a renamed version of `mFlags` without changing the bitmask values it represents, then the behavior of the method should remain unchanged. As the change does not inherently indicate a behavior difference without further information on the intention and the context of the field renaming, the CI type is presumed to be 0 (no compatibility issue) based on the provided information."
798,"<android.bluetooth.BluetoothAdapter: void closeProfileProxy(int,BluetoothProfile)>",27,28,"<android.bluetooth.BluetoothAdapter: void closeProfileProxy(int,BluetoothProfile)>","<android.bluetooth.BluetoothAdapter: void closeProfileProxy(int,BluetoothProfile)>",0,"{
    if (proxy == null)
        return;
    switch(profile) {
        case BluetoothProfile.HEADSET:
            BluetoothHeadset headset = (BluetoothHeadset) proxy;
            headset.close();
            break;
        case BluetoothProfile.A2DP:
            BluetoothA2dp a2dp = (BluetoothA2dp) proxy;
            a2dp.close();
            break;
        case BluetoothProfile.A2DP_SINK:
            BluetoothA2dpSink a2dpSink = (BluetoothA2dpSink) proxy;
            a2dpSink.close();
            break;
        case BluetoothProfile.AVRCP_CONTROLLER:
            BluetoothAvrcpController avrcp = (BluetoothAvrcpController) proxy;
            avrcp.close();
            break;
        case BluetoothProfile.INPUT_DEVICE:
            BluetoothInputDevice iDev = (BluetoothInputDevice) proxy;
            iDev.close();
            break;
        case BluetoothProfile.PAN:
            BluetoothPan pan = (BluetoothPan) proxy;
            pan.close();
            break;
        case BluetoothProfile.HEALTH:
            BluetoothHealth health = (BluetoothHealth) proxy;
            health.close();
            break;
        case BluetoothProfile.GATT:
            BluetoothGatt gatt = (BluetoothGatt) proxy;
            gatt.close();
            break;
        case BluetoothProfile.GATT_SERVER:
            BluetoothGattServer gattServer = (BluetoothGattServer) proxy;
            gattServer.close();
            break;
        case BluetoothProfile.MAP:
            BluetoothMap map = (BluetoothMap) proxy;
            map.close();
            break;
        case BluetoothProfile.HEADSET_CLIENT:
            BluetoothHeadsetClient headsetClient = (BluetoothHeadsetClient) proxy;
            headsetClient.close();
            break;
        case BluetoothProfile.SAP:
            BluetoothSap sap = (BluetoothSap) proxy;
            sap.close();
            break;
        case BluetoothProfile.PBAP_CLIENT:
            BluetoothPbapClient pbapClient = (BluetoothPbapClient) proxy;
            pbapClient.close();
            break;
        case BluetoothProfile.MAP_CLIENT:
            BluetoothMapClient mapClient = (BluetoothMapClient) proxy;
            mapClient.close();
            break;
        case BluetoothProfile.INPUT_HOST:
            BluetoothInputHost iHost = (BluetoothInputHost) proxy;
            iHost.close();
            break;
    }
}","{
    if (proxy == null) {
        return;
    }
    switch(profile) {
        case BluetoothProfile.HEADSET:
            BluetoothHeadset headset = (BluetoothHeadset) proxy;
            headset.close();
            break;
        case BluetoothProfile.A2DP:
            BluetoothA2dp a2dp = (BluetoothA2dp) proxy;
            a2dp.close();
            break;
        case BluetoothProfile.A2DP_SINK:
            BluetoothA2dpSink a2dpSink = (BluetoothA2dpSink) proxy;
            a2dpSink.close();
            break;
        case BluetoothProfile.AVRCP_CONTROLLER:
            BluetoothAvrcpController avrcp = (BluetoothAvrcpController) proxy;
            avrcp.close();
            break;
        case BluetoothProfile.HID_HOST:
            BluetoothHidHost iDev = (BluetoothHidHost) proxy;
            iDev.close();
            break;
        case BluetoothProfile.PAN:
            BluetoothPan pan = (BluetoothPan) proxy;
            pan.close();
            break;
        case BluetoothProfile.HEALTH:
            BluetoothHealth health = (BluetoothHealth) proxy;
            health.close();
            break;
        case BluetoothProfile.GATT:
            BluetoothGatt gatt = (BluetoothGatt) proxy;
            gatt.close();
            break;
        case BluetoothProfile.GATT_SERVER:
            BluetoothGattServer gattServer = (BluetoothGattServer) proxy;
            gattServer.close();
            break;
        case BluetoothProfile.MAP:
            BluetoothMap map = (BluetoothMap) proxy;
            map.close();
            break;
        case BluetoothProfile.HEADSET_CLIENT:
            BluetoothHeadsetClient headsetClient = (BluetoothHeadsetClient) proxy;
            headsetClient.close();
            break;
        case BluetoothProfile.SAP:
            BluetoothSap sap = (BluetoothSap) proxy;
            sap.close();
            break;
        case BluetoothProfile.PBAP_CLIENT:
            BluetoothPbapClient pbapClient = (BluetoothPbapClient) proxy;
            pbapClient.close();
            break;
        case BluetoothProfile.MAP_CLIENT:
            BluetoothMapClient mapClient = (BluetoothMapClient) proxy;
            mapClient.close();
            break;
        case BluetoothProfile.HID_DEVICE:
            BluetoothHidDevice hidDevice = (BluetoothHidDevice) proxy;
            hidDevice.close();
            break;
        case BluetoothProfile.HEARING_AID:
            BluetoothHearingAid hearingAid = (BluetoothHearingAid) proxy;
            hearingAid.close();
    }
}",1,"/**
 * Close the connection of the profile proxy to the Service.
 *
 * <p> Clients should call this when they are no longer using
 * the proxy obtained from {@link #getProfileProxy}.
 * Profile can be one of  {@link BluetoothProfile#HEALTH}, {@link BluetoothProfile#HEADSET} or
 * {@link BluetoothProfile#A2DP}
 *
 * @param profile
 * @param proxy Profile proxy object
 */
","/**
 * Close the connection of the profile proxy to the Service.
 *
 * <p> Clients should call this when they are no longer using
 * the proxy obtained from {@link #getProfileProxy}.
 * Profile can be one of  {@link BluetoothProfile#HEALTH}, {@link BluetoothProfile#HEADSET} or
 * {@link BluetoothProfile#A2DP}
 *
 * @param profile
 * @param proxy Profile proxy object
 */
",-1,,,-1,-1,-1,-1,-1,-1,3,0,"The switch-case block has changed to handle additional or different Bluetooth profiles, such as adding BluetoothProfile.HEARING_AID and changing BluetoothProfile.INPUT_DEVICE to BluetoothProfile.HID_HOST. This indicates a change in the control dependency as it affects which block of code will be executed depending on the value of 'profile'.","No compatibility issue could arise from these changes as the method signature and return type remain the same, and the behavior for a given 'profile' input does not appear to throw new exceptions or change the returned value. It merely provides appropriate handling for additional types of BluetoothProfile objects without altering the existing control flow for profiles that were already handled."
800,"<android.widget.TextView: PointerIcon onResolvePointerIcon(MotionEvent,int)>",27,28,"<android.widget.TextView: PointerIcon onResolvePointerIcon(MotionEvent,int)>","<android.widget.TextView: PointerIcon onResolvePointerIcon(MotionEvent,int)>",0,"{
    if (mText instanceof Spannable && mLinksClickable) {
        final float x = event.getX(pointerIndex);
        final float y = event.getY(pointerIndex);
        final int offset = getOffsetForPosition(x, y);
        final ClickableSpan[] clickables = ((Spannable) mText).getSpans(offset, offset, ClickableSpan.class);
        if (clickables.length > 0) {
            return PointerIcon.getSystemIcon(mContext, PointerIcon.TYPE_HAND);
        }
    }
    if (isTextSelectable() || isTextEditable()) {
        return PointerIcon.getSystemIcon(mContext, PointerIcon.TYPE_TEXT);
    }
    return super.onResolvePointerIcon(event, pointerIndex);
}","{
    if (mSpannable != null && mLinksClickable) {
        final float x = event.getX(pointerIndex);
        final float y = event.getY(pointerIndex);
        final int offset = getOffsetForPosition(x, y);
        final ClickableSpan[] clickables = mSpannable.getSpans(offset, offset, ClickableSpan.class);
        if (clickables.length > 0) {
            return PointerIcon.getSystemIcon(mContext, PointerIcon.TYPE_HAND);
        }
    }
    if (isTextSelectable() || isTextEditable()) {
        return PointerIcon.getSystemIcon(mContext, PointerIcon.TYPE_TEXT);
    }
    return super.onResolvePointerIcon(event, pointerIndex);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,5",0,"The control dependency has changed as the code now checks `mSpannable` instead of `mText instanceof Spannable`. Additionally, `mSpannable.getSpans` replaces `((Spannable) mText).getSpans`, so the dependent API has also changed. These are classified as 3 and 5, respectively.","There is no Compatibility Issue detected because the change from `mText instanceof Spannable` to `mSpannable` does not inherently imply that the behavior of the method has changed; presumably `mSpannable` is just a cast or reference of `mText` as a `Spannable`. The usage of `mSpannable.getSpans` instead of `((Spannable) mText).getSpans` suggests a refactoring without behavior change. If `mSpannable` accurately reflects whether `mText` is a `Spannable`, then the existing logic still applies and will not lead to a different return value or exception thrown by the method."
805,<android.bluetooth.BluetoothGatt: boolean readCharacteristic(BluetoothGattCharacteristic)>,27,28,<android.bluetooth.BluetoothGatt: boolean readCharacteristic(BluetoothGattCharacteristic)>,<android.bluetooth.BluetoothGatt: boolean readCharacteristic(BluetoothGattCharacteristic)>,0,"{
    if ((characteristic.getProperties() & BluetoothGattCharacteristic.PROPERTY_READ) == 0)
        return false;
    if (VDBG)
        Log.d(TAG, ""readCharacteristic() - uuid: "" + characteristic.getUuid());
    if (mService == null || mClientIf == 0)
        return false;
    BluetoothGattService service = characteristic.getService();
    if (service == null)
        return false;
    BluetoothDevice device = service.getDevice();
    if (device == null)
        return false;
    synchronized (mDeviceBusy) {
        if (mDeviceBusy)
            return false;
        mDeviceBusy = true;
    }
    try {
        mService.readCharacteristic(mClientIf, device.getAddress(), characteristic.getInstanceId(), AUTHENTICATION_NONE);
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
        mDeviceBusy = false;
        return false;
    }
    return true;
}","{
    if ((characteristic.getProperties() & BluetoothGattCharacteristic.PROPERTY_READ) == 0) {
        return false;
    }
    if (VDBG)
        Log.d(TAG, ""readCharacteristic() - uuid: "" + characteristic.getUuid());
    if (mService == null || mClientIf == 0)
        return false;
    BluetoothGattService service = characteristic.getService();
    if (service == null)
        return false;
    BluetoothDevice device = service.getDevice();
    if (device == null)
        return false;
    synchronized (mDeviceBusy) {
        if (mDeviceBusy)
            return false;
        mDeviceBusy = true;
    }
    try {
        mService.readCharacteristic(mClientIf, device.getAddress(), characteristic.getInstanceId(), AUTHENTICATION_NONE);
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
        mDeviceBusy = false;
        return false;
    }
    return true;
}",1,"/**
 * Reads the requested characteristic from the associated remote device.
 *
 * <p>This is an asynchronous operation. The result of the read operation
 * is reported by the {@link BluetoothGattCallback#onCharacteristicRead}
 * callback.
 *
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH} permission.
 *
 * @param characteristic Characteristic to read from the remote device
 * @return true, if the read operation was initiated successfully
 */
","/**
 * Reads the requested characteristic from the associated remote device.
 *
 * <p>This is an asynchronous operation. The result of the read operation
 * is reported by the {@link BluetoothGattCallback#onCharacteristicRead}
 * callback.
 *
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH} permission.
 *
 * @param characteristic Characteristic to read from the remote device
 * @return true, if the read operation was initiated successfully
 */
",-1,,,-1,-1,-1,-1,-1,-1,0,0,There are no changes in the implementation from the early version to the late version of the API.,No Compatibility Issue could arise due to there being no changes between the versions.
806,<android.app.SharedPreferencesImpl.EditorImpl: Editor clear()>,27,28,<android.app.SharedPreferencesImpl.EditorImpl: Editor clear()>,<android.app.SharedPreferencesImpl.EditorImpl: Editor clear()>,0,"{
    synchronized (mLock) {
        mClear = true;
        return this;
    }
}","{
    synchronized (mEditorLock) {
        mClear = true;
        return this;
    }
}",1,,,-1,,[@Override],-1,-1,-1,-1,-1,-1,4,0,"The object on which synchronization is done changed from mLock to mEditorLock (renaming of synchronized lock variable), which constitutes an 'Other statement changed' (change type 4). But this change will not affect the external behavior of the method itself since it's just a change of the variable name and does not affect the method contract or functionality.","Despite the change in the synchronized lock variable name, it will not introduce any compatibility issue because the synchronized block's behavior remains the same, and hence there is no change from an API consumer perspective. Therefore, the CI type is 0."
807,<android.view.inputmethod.InputMethodManager: boolean switchToLastInputMethod(IBinder)>,27,28,<android.view.inputmethod.InputMethodManager: boolean switchToLastInputMethod(IBinder)>,<android.view.inputmethod.InputMethodManager: boolean switchToLastInputMethod(IBinder)>,0,"{
    synchronized (mH) {
        try {
            return mService.switchToLastInputMethod(imeToken);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }
}","{
    return switchToPreviousInputMethodInternal(imeToken);
}",1,"/**
 * Force switch to the last used input method and subtype. If the last input method didn't have
 * any subtypes, the framework will simply switch to the last input method with no subtype
 * specified.
 * @param imeToken Supplies the identifying token given to an input method when it was started,
 * which allows it to perform this operation on itself.
 * @return true if the current input method and subtype was successfully switched to the last
 * used input method and subtype.
 */
","/**
 * Force switch to the last used input method and subtype. If the last input method didn't have
 * any subtypes, the framework will simply switch to the last input method with no subtype
 * specified.
 * @param imeToken Supplies the identifying token given to an input method when it was started,
 * which allows it to perform this operation on itself.
 * @return true if the current input method and subtype was successfully switched to the last
 * used input method and subtype.
 * @deprecated Use {@link InputMethodService#switchToPreviousInputMethod()} instead. This method
 * was intended for IME developers who should be accessing APIs through the service. APIs in
 * this class are intended for app developers interacting with the IME.
 */
",-1,,[@Deprecated],-1,-1,-1,-1,-1,-1,"1,5",1,"The early version of the API directly uses the mService.switchToLastInputMethod within a synchronized block, while the late version uses a different method switchToPreviousInputMethodInternal without synchronization. Additionally, the dependent method that is being called has changed from mService.switchToLastInputMethod to switchToPreviousInputMethodInternal, indicating a change in the dependent API. Therefore, the change types include both a return statement change (1) and a dependent API change (5).","Since switchToLastInputMethod and switchToPreviousInputMethodInternal may not exhibit the same behavior, the change can potentially return a different value. This would constitute a compatibility issue due to potentially different return values or types, thus the CI type is 1."
808,"<android.hardware.camera2.impl.CameraDeviceImpl: void createReprocessableCaptureSession(InputConfiguration,List<Surface>,StateCallback,Handler)>",27,28,"<android.hardware.camera2.impl.CameraDeviceImpl: void createReprocessableCaptureSession(InputConfiguration,List<Surface>,StateCallback,Handler)>","<android.hardware.camera2.impl.CameraDeviceImpl: void createReprocessableCaptureSession(InputConfiguration,List<Surface>,StateCallback,Handler)>",0,"{
    if (DEBUG) {
        Log.d(TAG, ""createReprocessableCaptureSession"");
    }
    if (inputConfig == null) {
        throw new IllegalArgumentException(""inputConfig cannot be null when creating a "" + ""reprocessable capture session"");
    }
    List<OutputConfiguration> outConfigurations = new ArrayList<>(outputs.size());
    for (Surface surface : outputs) {
        outConfigurations.add(new OutputConfiguration(surface));
    }
    createCaptureSessionInternal(inputConfig, outConfigurations, callback, handler, /*operatingMode*/
    ICameraDeviceUser.NORMAL_MODE);
}","{
    if (DEBUG) {
        Log.d(TAG, ""createReprocessableCaptureSession"");
    }
    if (inputConfig == null) {
        throw new IllegalArgumentException(""inputConfig cannot be null when creating a "" + ""reprocessable capture session"");
    }
    List<OutputConfiguration> outConfigurations = new ArrayList<>(outputs.size());
    for (Surface surface : outputs) {
        outConfigurations.add(new OutputConfiguration(surface));
    }
    createCaptureSessionInternal(inputConfig, outConfigurations, callback, checkAndWrapHandler(handler), /*operatingMode*/
    ICameraDeviceUser.NORMAL_MODE, /*sessionParams*/
    null);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"4,5",0,"The method `createCaptureSessionInternal` was called with an additional parameter 'null' for 'sessionParams' in the late version. However, since 'handler' was replaced by `checkAndWrapHandler(handler)` in the method call, the changes belong to 4,5.","There is no Compatibility Issue in this case because the changes do not modify the behavior of exception throwing or returning values from the API. The method `checkAndWrapHandler(handler)` suggests a refinement or check, but it does not affect the value the API would return or cause the API to throw a different exception under the same conditions. Also, the added 'null' parameter for 'sessionParams' does not introduce a behavior change in the output of the method assuming 'createCaptureSessionInternal' handles this added parameter appropriately as part of its design (an assumption based on the lack of further context). Therefore, the API still guarantees the same promise as before."
809,<android.util.proto.ProtoOutputStream: long startObject(long)>,27,28,<android.util.proto.ProtoOutputStream: long startObject(long)>,<android.util.proto.ProtoOutputStream: long startObject(long)>,0,"{
    assertNotCompacted();
    final int id = checkFieldId(fieldId, FIELD_COUNT_SINGLE | FIELD_TYPE_OBJECT);
    return startObjectImpl(id, false);
}","{
    assertNotCompacted();
    final int id = checkFieldId(fieldId, FIELD_COUNT_SINGLE | FIELD_TYPE_MESSAGE);
    return startObjectImpl(id, false);
}",1,"/**
 * Start a child object.
 *
 * Returns a token which should be passed to endObject.  Calls to endObject must be
 * nested properly.
 *
 * @deprecated Use #start() instead.
 */
","/**
 * Start a child object.
 *
 * Returns a token which should be passed to endObject.  Calls to endObject must be
 * nested properly.
 *
 * @deprecated Use #start() instead.
 */
",-1,[@Deprecated],[@Deprecated],-1,-1,-1,-1,-1,-1,"4,5",0,"The only change here is a constant value passed to the method checkFieldId: from FIELD_TYPE_OBJECT to FIELD_TYPE_MESSAGE. This constitutes change 4, an ""Other statement changed"" because it's a modification of an argument value. Since FIELD_TYPE_OBJECT and FIELD_TYPE_MESSAGE are constants, there is also a dependent API changed, which is change type 5. However, without knowing whether the constants represent different values or are just a rename of the same value, we cannot definitively say what behavior change, if any, this would cause.","There is no immediate evidence that this change will cause the API to behave differently, as FIELD_TYPE_OBJECT and FIELD_TYPE_MESSAGE are symbolic constant names whose actual values are not specified and might even represent the same underlying value. It's possible that the renaming reflects a clarification rather than a change in behavior. Without further information regarding the actual values of these constants, we cannot assume a compatibility issue. Thus, the pred_CI is 0, no Compatibility Issue detected."
810,"<android.hardware.camera2.CameraManager: void registerTorchCallback(TorchCallback,Handler)>",27,28,"<android.hardware.camera2.CameraManager: void registerTorchCallback(TorchCallback,Handler)>","<android.hardware.camera2.CameraManager: void registerTorchCallback(TorchCallback,Handler)>",0,"{
    if (handler == null) {
        Looper looper = Looper.myLooper();
        if (looper == null) {
            throw new IllegalArgumentException(""No handler given, and current thread has no looper!"");
        }
        handler = new Handler(looper);
    }
    CameraManagerGlobal.get().registerTorchCallback(callback, handler);
}","{
    CameraManagerGlobal.get().registerTorchCallback(callback, CameraDeviceImpl.checkAndWrapHandler(handler));
}",1,"/**
 * Register a callback to be notified about torch mode status.
 *
 * <p>Registering the same callback again will replace the handler with the
 * new one provided.</p>
 *
 * <p>The first time a callback is registered, it is immediately called
 * with the torch mode status of all currently known camera devices with a flash unit.</p>
 *
 * <p>Since this callback will be registered with the camera service, remember to unregister it
 * once it is no longer needed; otherwise the callback will continue to receive events
 * indefinitely and it may prevent other resources from being released. Specifically, the
 * callbacks will be invoked independently of the general activity lifecycle and independently
 * of the state of individual CameraManager instances.</p>
 *
 * @param callback The new callback to send torch mode status to
 * @param handler The handler on which the callback should be invoked, or {@code null} to use
 * the current thread's {@link android.os.Looper looper}.
 *
 * @throws IllegalArgumentException if the handler is {@code null} but the current thread has
 * no looper.
 */
","/**
 * Register a callback to be notified about torch mode status.
 *
 * <p>Registering the same callback again will replace the handler with the
 * new one provided.</p>
 *
 * <p>The first time a callback is registered, it is immediately called
 * with the torch mode status of all currently known camera devices with a flash unit.</p>
 *
 * <p>Since this callback will be registered with the camera service, remember to unregister it
 * once it is no longer needed; otherwise the callback will continue to receive events
 * indefinitely and it may prevent other resources from being released. Specifically, the
 * callbacks will be invoked independently of the general activity lifecycle and independently
 * of the state of individual CameraManager instances.</p>
 *
 * @param callback The new callback to send torch mode status to
 * @param handler The handler on which the callback should be invoked, or {@code null} to use
 * the current thread's {@link android.os.Looper looper}.
 *
 * @throws IllegalArgumentException if the handler is {@code null} but the current thread has
 * no looper.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"The method now uses a different way to ensure a valid Handler is provided by calling CameraDeviceImpl.checkAndWrapHandler(handler) instead of the inline code as before. Additionally, the dependent API CameraDeviceImpl.checkAndWrapHandler(handler) is used in place of the previous implementation's logic, so the code change type is 4,5. ","There is no change in the behavior in terms of exceptions or return values, assuming the `checkAndWrapHandler` method provides an equivalent functionality to the original inline code. The refactoring was likely done for code reuse and simplification without altering the external behavior. Hence, there is no compatibility issue."
811,"<android.view.inputmethod.InputMethodManager: void hideSoftInputFromInputMethod(IBinder,int)>",27,28,"<android.view.inputmethod.InputMethodManager: void hideSoftInputFromInputMethod(IBinder,int)>","<android.view.inputmethod.InputMethodManager: void hideSoftInputFromInputMethod(IBinder,int)>",0,"{
    try {
        mService.hideMySoftInput(token, flags);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}","{
    hideSoftInputFromInputMethodInternal(token, flags);
}",1,"/**
 * Close/hide the input method's soft input area, so the user no longer
 * sees it or can interact with it.  This can only be called
 * from the currently active input method, as validated by the given token.
 *
 * @param token Supplies the identifying token given to an input method
 * when it was started, which allows it to perform this operation on
 * itself.
 * @param flags Provides additional operating flags.  Currently may be
 * 0 or have the {@link #HIDE_IMPLICIT_ONLY},
 * {@link #HIDE_NOT_ALWAYS} bit set.
 */
","/**
 * Close/hide the input method's soft input area, so the user no longer
 * sees it or can interact with it.  This can only be called
 * from the currently active input method, as validated by the given token.
 *
 * @param token Supplies the identifying token given to an input method
 * when it was started, which allows it to perform this operation on
 * itself.
 * @param flags Provides additional operating flags.  Currently may be
 * 0 or have the {@link #HIDE_IMPLICIT_ONLY},
 * {@link #HIDE_NOT_ALWAYS} bit set.
 * @deprecated Use {@link InputMethodService#requestHideSelf(int)} instead. This method was
 * intended for IME developers who should be accessing APIs through the service. APIs in this
 * class are intended for app developers interacting with the IME.
 */
",-1,,[@Deprecated],-1,-1,-1,-1,-1,-1,5,0,"The call to hideMySoftInput(token, flags) is changed to a call to hideSoftInputFromInputMethodInternal(token, flags), which is an example of a dependent API change, hence the change type is 5.","There is no compatibility issue detected because the method's purpose and its signature remain unchanged. The internal implementation has changed, but without more information about the new method (hideSoftInputFromInputMethodInternal), such as whether the method signature or behavior has changed in a way that would impact this API's functionality, we cannot assume a CI."
815,"<android.widget.SelectionActionModeHelper.SelectionTracker: boolean resetSelection(int,Editor)>",27,28,"<android.widget.SelectionActionModeHelper.SelectionTracker: boolean resetSelection(int,Editor)>","<android.widget.SelectionActionModeHelper.SelectionTracker: boolean resetSelection(int,Editor)>",0,"{
    final TextView textView = editor.getTextView();
    if (isSelectionStarted() && mAllowReset && textIndex >= mSelectionStart && textIndex <= mSelectionEnd && getText(textView) instanceof Spannable) {
        mAllowReset = false;
        boolean selected = editor.selectCurrentWord();
        if (selected) {
            mSelectionStart = editor.getTextView().getSelectionStart();
            mSelectionEnd = editor.getTextView().getSelectionEnd();
            mLogger.logSelectionAction(textView.getSelectionStart(), textView.getSelectionEnd(), SelectionEvent.ActionType.RESET, null);
        }
        return selected;
    }
    return false;
}","{
    final TextView textView = editor.getTextView();
    if (isSelectionStarted() && mAllowReset && textIndex >= mSelectionStart && textIndex <= mSelectionEnd && getText(textView) instanceof Spannable) {
        mAllowReset = false;
        boolean selected = editor.selectCurrentWord();
        if (selected) {
            mSelectionStart = editor.getTextView().getSelectionStart();
            mSelectionEnd = editor.getTextView().getSelectionEnd();
            mLogger.logSelectionAction(textView.getSelectionStart(), textView.getSelectionEnd(), SelectionEvent.ACTION_RESET, null);
        }
        return selected;
    }
    return false;
}",1,"/**
 * Returns true if the current smart selection should be reset to normal selection based on
 * information that has been recorded about the original selection and the smart selection.
 * The expected UX here is to allow the user to select a word inside of the smart selection
 * on a single tap.
 */
","/**
 * Returns true if the current smart selection should be reset to normal selection based on
 * information that has been recorded about the original selection and the smart selection.
 * The expected UX here is to allow the user to select a word inside of the smart selection
 * on a single tap.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The code change is in the parameter of the method `logSelectionAction` from `SelectionEvent.ActionType.RESET` to `SelectionEvent.ACTION_RESET`. This is not a change in a return statement, exception handling statement, or control dependency, thus the code change type is 4.","The change does not affect the variable returned by the method `resetSelection` nor does it change exception handling. It's merely changing a constant value passed to another method, and this constant is likely to represent the same value, assuming the constant `ACTION_RESET` corresponds to `ActionType.RESET`. Thus, there is no compatibility issue, and the CI type is 0."
816,"<android.bluetooth.BluetoothGatt: BluetoothGattCharacteristic getCharacteristicById(BluetoothDevice,int)>",27,28,"<android.bluetooth.BluetoothGatt: BluetoothGattCharacteristic getCharacteristicById(BluetoothDevice,int)>","<android.bluetooth.BluetoothGatt: BluetoothGattCharacteristic getCharacteristicById(BluetoothDevice,int)>",0,"{
    for (BluetoothGattService svc : mServices) {
        for (BluetoothGattCharacteristic charac : svc.getCharacteristics()) {
            if (charac.getInstanceId() == instanceId)
                return charac;
        }
    }
    return null;
}","{
    for (BluetoothGattService svc : mServices) {
        for (BluetoothGattCharacteristic charac : svc.getCharacteristics()) {
            if (charac.getInstanceId() == instanceId) {
                return charac;
            }
        }
    }
    return null;
}",1,"/*package*/
","/*package*/
",-1,,,-1,-1,-1,-1,-1,-1,0,0,"There is no change in the implementations between the two versions, only formatting changes without any functional difference (addition of curly braces which does not affect the behavior).",No compatibility issue arises since there has been no change to the method's functionality between the two versions.
817,<android.os.Parcel: ArrayList<T> createTypedArrayList(Creator<T>)>,27,28,<android.os.Parcel: ArrayList<T> createTypedArrayList(Creator<T>)>,<android.os.Parcel: ArrayList<T> createTypedArrayList(Creator<T>)>,0,"{
    int N = readInt();
    if (N < 0) {
        return null;
    }
    ArrayList<T> l = new ArrayList<T>(N);
    while (N > 0) {
        if (readInt() != 0) {
            l.add(c.createFromParcel(this));
        } else {
            l.add(null);
        }
        N--;
    }
    return l;
}","{
    int N = readInt();
    if (N < 0) {
        return null;
    }
    ArrayList<T> l = new ArrayList<T>(N);
    while (N > 0) {
        l.add(readTypedObject(c));
        N--;
    }
    return l;
}",1,"/**
 * Read and return a new ArrayList containing a particular object type from
 * the parcel that was written with {@link #writeTypedList} at the
 * current dataPosition().  Returns null if the
 * previously written list object was null.  The list <em>must</em> have
 * previously been written via {@link #writeTypedList} with the same object
 * type.
 *
 * @return A newly created ArrayList containing objects with the same data
 * as those that were previously written.
 *
 * @see #writeTypedList
 */
","/**
 * Read and return a new ArrayList containing a particular object type from
 * the parcel that was written with {@link #writeTypedList} at the
 * current dataPosition().  Returns null if the
 * previously written list object was null.  The list <em>must</em> have
 * previously been written via {@link #writeTypedList} with the same object
 * type.
 *
 * @return A newly created ArrayList containing objects with the same data
 * as those that were previously written.
 *
 * @see #writeTypedList
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The method of adding elements into the ArrayList changed from an inline check (readInt() != 0) and conditionally adding either a new object from the Creator or null, to using the method readTypedObject(c). This is a change in the code body which affects how the elements are read and added to the list, so the code change types are 1,5.","This change can potentially lead to a difference in the behavior of the method as the new implementation delegates the object creation to readTypedObject(c), which could possibly behave differently than the inline creation used previously. This can lead to the API returning a different ArrayList, and hence the CI type is 1."
818,<android.content.ContentResolver: void requestSync(SyncRequest)>,27,28,<android.content.ContentResolver: void requestSync(SyncRequest)>,<android.content.ContentResolver: void requestSync(SyncRequest)>,0,"{
    try {
        getContentService().sync(request);
    } catch (RemoteException e) {
    // Shouldn't happen.
    }
}","{
    try {
        getContentService().sync(request);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Register a sync with the SyncManager. These requests are built using the
 * {@link SyncRequest.Builder}.
 */
","/**
 * Register a sync with the SyncManager. These requests are built using the
 * {@link SyncRequest.Builder}.
 */
",-1,,,-1,-1,-1,-1,-1,-1,2,2,"The catch block in the late version has introduced a new exception handling statement with 'throw e.rethrowFromSystemServer()', while the early version does not rethrow the exception, hence the change type is 2.","Since a RemoteException caught in the late version is rethrown as a RuntimeException, while in the early version it is swallowed, the behavior of the method when encountering an exception could be different. This difference represents a change in how exceptions are handled by the API, which could potentially lead to a different exception being thrown to the caller, hence the CI type is 2."
819,<android.app.job.JobInfo: long getFlexMillis()>,27,28,<android.app.job.JobInfo: long getFlexMillis()>,<android.app.job.JobInfo: long getFlexMillis()>,0,"{
    long interval = getIntervalMillis();
    long percentClamp = 5 * interval / 100;
    long clampedFlex = Math.max(flexMillis, Math.max(percentClamp, getMinFlexMillis()));
    return clampedFlex <= interval ? clampedFlex : interval;
}","{
    return flexMillis;
}",1,"/**
 * Flex time for this job. Only valid if this is a periodic job.  The job can
 * execute at any time in a window of flex length at the end of the period.
 */
","/**
 * Flex time for this job. Only valid if this is a periodic job.  The job can
 * execute at any time in a window of flex length at the end of the period.
 * @see JobInfo.Builder#setPeriodic(long)
 * @see JobInfo.Builder#setPeriodic(long, long)
 */
",-1,,,-1,-1,-1,-1,-1,-1,1,1,"The method implementation has changed from performing a calculation on the value of `flexMillis` to simply returning `flexMillis`, so the code change type is 1.","Due to the change in the return valuepreviously, a calculation to clamp the value was performed, but in the late version, the raw value of `flexMillis` is returned without clampingthis could lead to the API returning a different value, so the CI type is 1."
820,"<android.os.Parcel: void readTypedArray(T[],Creator<T>)>",27,28,"<android.os.Parcel: void readTypedArray(T[],Creator<T>)>","<android.os.Parcel: void readTypedArray(T[],Creator<T>)>",0,"{
    int N = readInt();
    if (N == val.length) {
        for (int i = 0; i < N; i++) {
            if (readInt() != 0) {
                val[i] = c.createFromParcel(this);
            } else {
                val[i] = null;
            }
        }
    } else {
        throw new RuntimeException(""bad array lengths"");
    }
}","{
    int N = readInt();
    if (N == val.length) {
        for (int i = 0; i < N; i++) {
            val[i] = readTypedObject(c);
        }
    } else {
        throw new RuntimeException(""bad array lengths"");
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"1,5",0,"The code change lies in how elements are read into the array. The early version uses `if (readInt() != 0)` to check for non-zero values and then read the objects accordingly, while the late version uses `readTypedObject(c)` directly. The implementation details of `readTypedObject` method aren't provided, but assuming it preserves the exact behavior of the previous if-else logic for reading objects, the core logic has been offloaded to another method within the same class (hence the Dependent API Changed). However, since the behavior is assumed to be preserved, there isn't an apparent compatibility issue, therefore the code change type is 1,5.","Without additional information, it's assumed that `readTypedObject(c)` correctly handles the reading process similarly to the prior conditional read-and-assign logic, and thus does not lead to a compatibility issue because the conditions under which values are read have not changed. The contract of the method seems to remain the same  it still reads an array of typed objects from the Parcel based on the input length without altering the expected output. Therefore, pred_CI is 0, indicating no compatibility issue."
821,"<android.content.res.TypedArray: int getInteger(int,int)>",27,28,"<android.content.res.TypedArray: int getInteger(int,int)>","<android.content.res.TypedArray: int getInteger(int,int)>",0,"{
    if (mRecycled) {
        throw new RuntimeException(""Cannot make calls to a recycled instance!"");
    }
    final int attrIndex = index;
    index *= AssetManager.STYLE_NUM_ENTRIES;
    final int[] data = mData;
    final int type = data[index + AssetManager.STYLE_TYPE];
    if (type == TypedValue.TYPE_NULL) {
        return defValue;
    } else if (type >= TypedValue.TYPE_FIRST_INT && type <= TypedValue.TYPE_LAST_INT) {
        return data[index + AssetManager.STYLE_DATA];
    } else if (type == TypedValue.TYPE_ATTRIBUTE) {
        final TypedValue value = mValue;
        getValueAt(index, value);
        throw new UnsupportedOperationException(""Failed to resolve attribute at index "" + attrIndex + "": "" + value);
    }
    throw new UnsupportedOperationException(""Can't convert value at index "" + attrIndex + "" to integer: type=0x"" + Integer.toHexString(type));
}","{
    if (mRecycled) {
        throw new RuntimeException(""Cannot make calls to a recycled instance!"");
    }
    final int attrIndex = index;
    index *= STYLE_NUM_ENTRIES;
    final int[] data = mData;
    final int type = data[index + STYLE_TYPE];
    if (type == TypedValue.TYPE_NULL) {
        return defValue;
    } else if (type >= TypedValue.TYPE_FIRST_INT && type <= TypedValue.TYPE_LAST_INT) {
        return data[index + STYLE_DATA];
    } else if (type == TypedValue.TYPE_ATTRIBUTE) {
        final TypedValue value = mValue;
        getValueAt(index, value);
        throw new UnsupportedOperationException(""Failed to resolve attribute at index "" + attrIndex + "": "" + value);
    }
    throw new UnsupportedOperationException(""Can't convert value at index "" + attrIndex + "" to integer: type=0x"" + Integer.toHexString(type));
}",1,"/**
 * Retrieve the integer value for the attribute at <var>index</var>.
 * <p>
 * Unlike {@link #getInt(int, int)}, this method will throw an exception if
 * the attribute is defined but is not an integer.
 *
 * @param index Index of attribute to retrieve.
 * @param defValue Value to return if the attribute is not defined or
 * not a resource.
 *
 * @return Attribute integer value, or defValue if not defined.
 * @throws RuntimeException if the TypedArray has already been recycled.
 * @throws UnsupportedOperationException if the attribute is defined but is
 * not an integer.
 */
","/**
 * Retrieve the integer value for the attribute at <var>index</var>.
 * <p>
 * Unlike {@link #getInt(int, int)}, this method will throw an exception if
 * the attribute is defined but is not an integer.
 *
 * @param index Index of attribute to retrieve.
 * @param defValue Value to return if the attribute is not defined or
 * not a resource.
 *
 * @return Attribute integer value, or defValue if not defined.
 * @throws RuntimeException if the TypedArray has already been recycled.
 * @throws UnsupportedOperationException if the attribute is defined but is
 * not an integer.
 */
",-1,,,-1,-1,-1,-1,-1,-1,0,0,"There are no changes in the implementation of the method when comparing the early version with the late version. The only difference observed is the removal of the AssetManager qualifier from STYLE_NUM_ENTRIES and STYLE_DATA, which is likely due to both versions having an import statement that makes specifying AssetManager unnecessary. The behavior and the signature of the method remain the same.","Since there are no effective changes in how the method behaves between the two versions, there is no compatibility issue. The logic, return statements, and exception handling remain identical."
823,<android.hardware.radio.TunerAdapter: int getProgramInformation(ProgramInfo[])>,27,28,<android.hardware.radio.TunerAdapter: int getProgramInformation(ProgramInfo[])>,<android.hardware.radio.TunerAdapter: int getProgramInformation(ProgramInfo[])>,0,"{
    if (info == null || info.length != 1) {
        throw new IllegalArgumentException(""The argument must be an array of length 1"");
    }
    try {
        info[0] = mTuner.getProgramInformation();
        return RadioManager.STATUS_OK;
    } catch (RemoteException e) {
        Log.e(TAG, ""service died"", e);
        return RadioManager.STATUS_DEAD_OBJECT;
    }
}","{
    if (info == null || info.length != 1) {
        Log.e(TAG, ""The argument must be an array of length 1"");
        return RadioManager.STATUS_BAD_VALUE;
    }
    RadioManager.ProgramInfo current = mCallback.getCurrentProgramInformation();
    if (current == null) {
        Log.w(TAG, ""Didn't get program info yet"");
        return RadioManager.STATUS_INVALID_OPERATION;
    }
    info[0] = current;
    return RadioManager.STATUS_OK;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,2,4","1,2","There is a change from throwing an exception to logging an error and returning a specific status value, as well as a change in the exception handling and removal of the dependent API invocation (mTuner.getProgramInformation()). Moreover, there's a new condition checking the current program information for null, which outputs a warning and returns a specific status. Additionally, there are additional return statements, indicating changes of types 1, 2, and 4.","The early version of the API throws an IllegalArgumentException if the 'info' parameter doesn't meet requirements, but the late version logs an error and returns a specific status code, which represents a difference in both the return variable (type/status code) and exception handling between the early and late versions. This difference introduces a CI of types 1 (returning different values) and 2 (exception handling has changed from throwing an exception to returning a status code). The use of another method to get program information (mCallback.getCurrentProgramInformation()) and additional condition checks that lead to different return behaviour can also affect API compatibility."
824,"<android.os.Parcel: void readException(int,String)>",27,28,"<android.os.Parcel: void readException(int,String)>","<android.os.Parcel: void readException(int,String)>",0,"{
    switch(code) {
        case EX_PARCELABLE:
            if (readInt() > 0) {
                SneakyThrow.sneakyThrow((Exception) readParcelable(Parcelable.class.getClassLoader()));
            } else {
                throw new RuntimeException(msg + "" [missing Parcelable]"");
            }
        case EX_SECURITY:
            throw new SecurityException(msg);
        case EX_BAD_PARCELABLE:
            throw new BadParcelableException(msg);
        case EX_ILLEGAL_ARGUMENT:
            throw new IllegalArgumentException(msg);
        case EX_NULL_POINTER:
            throw new NullPointerException(msg);
        case EX_ILLEGAL_STATE:
            throw new IllegalStateException(msg);
        case EX_NETWORK_MAIN_THREAD:
            throw new NetworkOnMainThreadException();
        case EX_UNSUPPORTED_OPERATION:
            throw new UnsupportedOperationException(msg);
        case EX_SERVICE_SPECIFIC:
            throw new ServiceSpecificException(readInt(), msg);
    }
    throw new RuntimeException(""Unknown exception code: "" + code + "" msg "" + msg);
}","{
    String remoteStackTrace = null;
    final int remoteStackPayloadSize = readInt();
    if (remoteStackPayloadSize > 0) {
        remoteStackTrace = readString();
    }
    Exception e = createException(code, msg);
    // Attach remote stack trace if availalble
    if (remoteStackTrace != null) {
        RemoteException cause = new RemoteException(""Remote stack trace:\n"" + remoteStackTrace, null, false, false);
        try {
            Throwable rootCause = ExceptionUtils.getRootCause(e);
            if (rootCause != null) {
                rootCause.initCause(cause);
            }
        } catch (RuntimeException ex) {
            Log.e(TAG, ""Cannot set cause "" + cause + "" for "" + e, ex);
        }
    }
    SneakyThrow.sneakyThrow(e);
}",1,"/**
 * Throw an exception with the given message. Not intended for use
 * outside the Parcel class.
 *
 * @param code Used to determine which exception class to throw.
 * @param msg The exception message.
 */
","/**
 * Throw an exception with the given message. Not intended for use
 * outside the Parcel class.
 *
 * @param code Used to determine which exception class to throw.
 * @param msg The exception message.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,3",2,"The structure of exception handling has changed with a new mechanism for reading the remote stack trace and then throwing the exception using `SneakyThrow.sneakyThrow(e)`. There are also changes to the control dependency due to the new if condition for checking `remoteStackPayloadSize > 0`, so the code change type is 2,3.","Since the new implementation handles the construction of exceptions differently and attaches additional information (remote stack trace) to the exception, the exception thrown may now contain more context. This constitutes a change in how exceptions are handled, which could lead to a different exception being thrown, or at the very least, the same exception with additional information. Therefore, the CI type is 2."
826,"<android.provider.Settings.Secure: long getLong(ContentResolver,String,long)>",27,28,"<android.provider.Settings.Secure: long getLong(ContentResolver,String,long)>","<android.provider.Settings.Secure: long getLong(ContentResolver,String,long)>",0,"{
    return getLongForUser(cr, name, def, UserHandle.myUserId());
}","{
    return getLongForUser(cr, name, def, cr.getUserId());
}",1,"/**
 * Convenience function for retrieving a single secure settings value
 * as a {@code long}.  Note that internally setting values are always
 * stored as strings; this function converts the string to a {@code long}
 * for you.  The default value will be returned if the setting is
 * not defined or not a {@code long}.
 *
 * @param cr The ContentResolver to access.
 * @param name The name of the setting to retrieve.
 * @param def Value to return if the setting is not defined.
 *
 * @return The setting's current value, or 'def' if it is not defined
 * or not a valid {@code long}.
 */
","/**
 * Convenience function for retrieving a single secure settings value
 * as a {@code long}.  Note that internally setting values are always
 * stored as strings; this function converts the string to a {@code long}
 * for you.  The default value will be returned if the setting is
 * not defined or not a {@code long}.
 *
 * @param cr The ContentResolver to access.
 * @param name The name of the setting to retrieve.
 * @param def Value to return if the setting is not defined.
 *
 * @return The setting's current value, or 'def' if it is not defined
 * or not a valid {@code long}.
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The implementation changed from using UserHandle.myUserId() to cr.getUserId() in the getLongForUser method. As this is an internal change in how the user ID is retrieved, the code change type is 5.","There is no Compatibility Issue caused by this change if both methods UserHandle.myUserId() and cr.getUserId() return the same value for the user ID. This change is internal and assuming that both methods are intended to return the correct user ID for the calling context, they should behave identically. The contract of the API is not changed in terms of input parameters or the expected output."
828,"<android.util.proto.ProtoOutputStream: int checkFieldId(long,long)>",27,28,"<android.util.proto.ProtoOutputStream: int checkFieldId(long,long)>","<android.util.proto.ProtoOutputStream: int checkFieldId(long,long)>",0,"{
    final long fieldCount = fieldId & FIELD_COUNT_MASK;
    final long fieldType = fieldId & FIELD_TYPE_MASK;
    final long expectedCount = expectedFlags & FIELD_COUNT_MASK;
    final long expectedType = expectedFlags & FIELD_TYPE_MASK;
    if (((int) fieldId) == 0) {
        throw new IllegalArgumentException(""Invalid proto field "" + (int) fieldId + "" fieldId="" + Long.toHexString(fieldId));
    }
    if (fieldType != expectedType || !((fieldCount == expectedCount) || (fieldCount == FIELD_COUNT_PACKED && expectedCount == FIELD_COUNT_REPEATED))) {
        final String countString = getFieldCountString(fieldCount);
        final String typeString = getFieldTypeString(fieldType);
        if (typeString != null && countString != null) {
            final StringBuilder sb = new StringBuilder();
            if (expectedType == FIELD_TYPE_OBJECT) {
                sb.append(""start"");
            } else {
                sb.append(""write"");
            }
            sb.append(getFieldCountString(expectedCount));
            sb.append(getFieldTypeString(expectedType));
            sb.append("" called for field "");
            sb.append((int) fieldId);
            sb.append("" which should be used with "");
            if (fieldType == FIELD_TYPE_OBJECT) {
                sb.append(""start"");
            } else {
                sb.append(""write"");
            }
            sb.append(countString);
            sb.append(typeString);
            if (fieldCount == FIELD_COUNT_PACKED) {
                sb.append("" or writeRepeated"");
                sb.append(typeString);
            }
            sb.append('.');
            throw new IllegalArgumentException(sb.toString());
        } else {
            final StringBuilder sb = new StringBuilder();
            if (expectedType == FIELD_TYPE_OBJECT) {
                sb.append(""start"");
            } else {
                sb.append(""write"");
            }
            sb.append(getFieldCountString(expectedCount));
            sb.append(getFieldTypeString(expectedType));
            sb.append("" called with an invalid fieldId: 0x"");
            sb.append(Long.toHexString(fieldId));
            sb.append("". The proto field ID might be "");
            sb.append((int) fieldId);
            sb.append('.');
            throw new IllegalArgumentException(sb.toString());
        }
    }
    return (int) fieldId;
}","{
    final long fieldCount = fieldId & FIELD_COUNT_MASK;
    final long fieldType = fieldId & FIELD_TYPE_MASK;
    final long expectedCount = expectedFlags & FIELD_COUNT_MASK;
    final long expectedType = expectedFlags & FIELD_TYPE_MASK;
    if (((int) fieldId) == 0) {
        throw new IllegalArgumentException(""Invalid proto field "" + (int) fieldId + "" fieldId="" + Long.toHexString(fieldId));
    }
    if (fieldType != expectedType || !((fieldCount == expectedCount) || (fieldCount == FIELD_COUNT_PACKED && expectedCount == FIELD_COUNT_REPEATED))) {
        final String countString = getFieldCountString(fieldCount);
        final String typeString = getFieldTypeString(fieldType);
        if (typeString != null && countString != null) {
            final StringBuilder sb = new StringBuilder();
            if (expectedType == FIELD_TYPE_MESSAGE) {
                sb.append(""start"");
            } else {
                sb.append(""write"");
            }
            sb.append(getFieldCountString(expectedCount));
            sb.append(getFieldTypeString(expectedType));
            sb.append("" called for field "");
            sb.append((int) fieldId);
            sb.append("" which should be used with "");
            if (fieldType == FIELD_TYPE_MESSAGE) {
                sb.append(""start"");
            } else {
                sb.append(""write"");
            }
            sb.append(countString);
            sb.append(typeString);
            if (fieldCount == FIELD_COUNT_PACKED) {
                sb.append("" or writeRepeated"");
                sb.append(typeString);
            }
            sb.append('.');
            throw new IllegalArgumentException(sb.toString());
        } else {
            final StringBuilder sb = new StringBuilder();
            if (expectedType == FIELD_TYPE_MESSAGE) {
                sb.append(""start"");
            } else {
                sb.append(""write"");
            }
            sb.append(getFieldCountString(expectedCount));
            sb.append(getFieldTypeString(expectedType));
            sb.append("" called with an invalid fieldId: 0x"");
            sb.append(Long.toHexString(fieldId));
            sb.append("". The proto field ID might be "");
            sb.append((int) fieldId);
            sb.append('.');
            throw new IllegalArgumentException(sb.toString());
        }
    }
    return (int) fieldId;
}",1,"/**
 * Validates that the fieldId providied is of the type and count from expectedType.
 *
 * The type must match exactly to pass this check.
 *
 * The count must match according to this truth table to pass the check:
 *
 * expectedFlags
 * UNKNOWN     SINGLE      REPEATED    PACKED
 * fieldId
 * UNKNOWN       true        false       false       false
 * SINGLE        x           true        false       false
 * REPEATED      x           false       true        false
 * PACKED        x           false       true        true
 *
 * @throws IllegalArgumentException if it is not.
 *
 * @return The raw ID of that field.
 */
","/**
 * Validates that the fieldId providied is of the type and count from expectedType.
 *
 * The type must match exactly to pass this check.
 *
 * The count must match according to this truth table to pass the check:
 *
 * expectedFlags
 * UNKNOWN     SINGLE      REPEATED    PACKED
 * fieldId
 * UNKNOWN       true        false       false       false
 * SINGLE        x           true        false       false
 * REPEATED      x           false       true        false
 * PACKED        x           false       true        true
 *
 * @throws IllegalArgumentException if it is not.
 *
 * @return The raw ID of that field.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The code has changed where FIELD_TYPE_OBJECT is replaced with FIELD_TYPE_MESSAGE. It is not a return statement change, exception handling change, control structure change, or dependent API change. It is an internal string building difference; hence, it falls under other statement changed.","Despite the internal string representation change when building the error message during an exception, the execution path and the conditions for throwing exceptions or returning a value remain the same. Thus, this does not lead to a compatibility issue since it does not affect the method's behavior from a caller's perspective."
830,<android.view.autofill.AutofillManager: void notifyValueChanged(View)>,27,28,<android.view.autofill.AutofillManager: void notifyValueChanged(View)>,<android.view.autofill.AutofillManager: void notifyValueChanged(View)>,0,"{
    if (!hasAutofillFeature()) {
        return;
    }
    AutofillId id = null;
    boolean valueWasRead = false;
    AutofillValue value = null;
    synchronized (mLock) {
        // remove the isAutofilled property even if no sessions are active.
        if (mLastAutofilledData == null) {
            view.setAutofilled(false);
        } else {
            id = getAutofillId(view);
            if (mLastAutofilledData.containsKey(id)) {
                value = view.getAutofillValue();
                valueWasRead = true;
                if (Objects.equals(mLastAutofilledData.get(id), value)) {
                    view.setAutofilled(true);
                } else {
                    view.setAutofilled(false);
                    mLastAutofilledData.remove(id);
                }
            } else {
                view.setAutofilled(false);
            }
        }
        if (!mEnabled || !isActiveLocked()) {
            if (sVerbose && mEnabled) {
                Log.v(TAG, ""notifyValueChanged("" + view + ""): ignoring on state "" + getStateAsStringLocked());
            }
            return;
        }
        if (id == null) {
            id = getAutofillId(view);
        }
        if (!valueWasRead) {
            value = view.getAutofillValue();
        }
        updateSessionLocked(id, null, value, ACTION_VALUE_CHANGED, 0);
    }
}","{
    if (!hasAutofillFeature()) {
        return;
    }
    AutofillId id = null;
    boolean valueWasRead = false;
    AutofillValue value = null;
    synchronized (mLock) {
        // remove the isAutofilled property even if no sessions are active.
        if (mLastAutofilledData == null) {
            view.setAutofilled(false);
        } else {
            id = view.getAutofillId();
            if (mLastAutofilledData.containsKey(id)) {
                value = view.getAutofillValue();
                valueWasRead = true;
                if (Objects.equals(mLastAutofilledData.get(id), value)) {
                    view.setAutofilled(true);
                } else {
                    view.setAutofilled(false);
                    mLastAutofilledData.remove(id);
                }
            } else {
                view.setAutofilled(false);
            }
        }
        if (!mEnabled || !isActiveLocked()) {
            if (sVerbose) {
                Log.v(TAG, ""notifyValueChanged("" + view.getAutofillId() + ""): ignoring on state "" + getStateAsStringLocked());
            }
            return;
        }
        if (id == null) {
            id = view.getAutofillId();
        }
        if (!valueWasRead) {
            value = view.getAutofillValue();
        }
        updateSessionLocked(id, null, value, ACTION_VALUE_CHANGED, 0);
    }
}",1,"/**
 * Called to indicate the value of an autofillable {@link View} changed.
 *
 * @param view view whose value changed.
 */
","/**
 * Called to indicate the value of an autofillable {@link View} changed.
 *
 * @param view view whose value changed.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"The method getAutofillId() is directly called on the view object instead of being assigned to a variable first, and the verbose log message now includes the result of view.getAutofillId(). There have been changes in how the object's methods are accessed and how logging is done, but this does not alter the control flow or the return type/value. The dependent API used for logging and object access has changed, which leads to type 4,5.","There is no compatibility issue because these changes do not affect the API's behavior from a client's perspective. The return values, exceptions thrown, and control flow remain the same. Therefore, the CI type is 0."
831,<android.bluetooth.BluetoothAdapter: boolean cancelDiscovery()>,27,28,<android.bluetooth.BluetoothAdapter: boolean cancelDiscovery()>,<android.bluetooth.BluetoothAdapter: boolean cancelDiscovery()>,0,"{
    if (getState() != STATE_ON)
        return false;
    try {
        mServiceLock.readLock().lock();
        if (mService != null)
            return mService.cancelDiscovery();
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
    } finally {
        mServiceLock.readLock().unlock();
    }
    return false;
}","{
    if (getState() != STATE_ON) {
        return false;
    }
    try {
        mServiceLock.readLock().lock();
        if (mService != null) {
            return mService.cancelDiscovery();
        }
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
    } finally {
        mServiceLock.readLock().unlock();
    }
    return false;
}",1,"/**
 * Cancel the current device discovery process.
 * <p>Because discovery is a heavyweight procedure for the Bluetooth
 * adapter, this method should always be called before attempting to connect
 * to a remote device with {@link
 * android.bluetooth.BluetoothSocket#connect()}. Discovery is not managed by
 * the  Activity, but is run as a system service, so an application should
 * always call cancel discovery even if it did not directly request a
 * discovery, just to be sure.
 * <p>If Bluetooth state is not {@link #STATE_ON}, this API
 * will return false. After turning on Bluetooth,
 * wait for {@link #ACTION_STATE_CHANGED} with {@link #STATE_ON}
 * to get the updated value.
 *
 * @return true on success, false on error
 */
","/**
 * Cancel the current device discovery process.
 * <p>Because discovery is a heavyweight procedure for the Bluetooth
 * adapter, this method should always be called before attempting to connect
 * to a remote device with {@link
 * android.bluetooth.BluetoothSocket#connect()}. Discovery is not managed by
 * the  Activity, but is run as a system service, so an application should
 * always call cancel discovery even if it did not directly request a
 * discovery, just to be sure.
 * <p>If Bluetooth state is not {@link #STATE_ON}, this API
 * will return false. After turning on Bluetooth,
 * wait for {@link #ACTION_STATE_CHANGED} with {@link #STATE_ON}
 * to get the updated value.
 *
 * @return true on success, false on error
 */
",-1,[@RequiresPermission(Manifest.permission.BLUETOOTH_ADMIN)],[@RequiresPermission(Manifest.permission.BLUETOOTH_ADMIN)],-1,-1,-1,-1,-1,-1,0,0,"There is no actual code change between the two versions, only formatting has been updated (adding brackets to condition blocks). The logic, return statements, and structure of the code remains the same.","As there were no changes in the implementation logic, return values, exception handling or method calls, no compatibility issue will arise."
833,<android.service.notification.NotificationListenerService: StatusBarNotification[] getActiveNotifications(String[])>,27,28,<android.service.notification.NotificationListenerService: StatusBarNotification[] getActiveNotifications(String[])>,<android.service.notification.NotificationListenerService: StatusBarNotification[] getActiveNotifications(String[])>,0,"{
    return getActiveNotifications(keys, TRIM_FULL);
}","{
    StatusBarNotification[] activeNotifications = getActiveNotifications(keys, TRIM_FULL);
    return activeNotifications != null ? activeNotifications : new StatusBarNotification[0];
}",1,"/**
 * Request one or more notifications by key. Useful if you have been keeping track of
 * notifications but didn't want to retain the bits, and now need to go back and extract
 * more data out of those notifications.
 *
 * <p>The service should wait for the {@link #onListenerConnected()} event
 * before performing this operation.
 *
 * @param keys the keys of the notifications to request
 * @return An array of notifications corresponding to the requested keys, in the
 * same order as the key list.
 */
","/**
 * Request one or more notifications by key. Useful if you have been keeping track of
 * notifications but didn't want to retain the bits, and now need to go back and extract
 * more data out of those notifications.
 *
 * <p>The service should wait for the {@link #onListenerConnected()} event
 * before performing this operation.
 *
 * @param keys the keys of the notifications to request
 * @return An array of notifications corresponding to the requested keys, in the
 * same order as the key list.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,4",1,"The implementation introduces a local variable to store the result before returning it and includes a ternary conditional to handle the case where 'activeNotifications' may be null, initializing an empty array instead of returning null. This introduces a new assignment statement and modifies the return statement, so the code change types are 1 and 4.","In the late version, if 'activeNotifications' is null, a new empty array is returned instead of null, potentially returning a different value from the early version. Therefore, there is a CI because of a potential different return value, and the CI type is 1."
834,"<android.app.SharedPreferencesImpl.EditorImpl: Editor putInt(String,int)>",27,28,"<android.app.SharedPreferencesImpl.EditorImpl: Editor putInt(String,int)>","<android.app.SharedPreferencesImpl.EditorImpl: Editor putInt(String,int)>",0,"{
    synchronized (mLock) {
        mModified.put(key, value);
        return this;
    }
}","{
    synchronized (mEditorLock) {
        mModified.put(key, value);
        return this;
    }
}",1,,,-1,,[@Override],-1,-1,-1,-1,-1,-1,4,0,"The synchronized block's monitor has changed from mLock to mEditorLock, therefore the code change type is 4 (Other statement changed).","The change in the monitor object for synchronization does not affect the API's return value or the exceptions it may throw. Thus, there is no Compatibility Issue, as it is an internal change that will be transparent to the user of the API."
839,"<android.app.ContextImpl: boolean bindService(Intent,ServiceConnection,int)>",27,28,"<android.app.ContextImpl: boolean bindService(Intent,ServiceConnection,int)>","<android.app.ContextImpl: boolean bindService(Intent,ServiceConnection,int)>",0,"{
    warnIfCallingFromSystemProcess();
    return bindServiceCommon(service, conn, flags, mMainThread.getHandler(), Process.myUserHandle());
}","{
    warnIfCallingFromSystemProcess();
    return bindServiceCommon(service, conn, flags, mMainThread.getHandler(), getUser());
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,5,1,"The change in the code is the last argument of the method bindServiceCommon() changed from Process.myUserHandle() to getUser(). This modification is in the parameter list of a dependent method call, so it is a change of type 5.","The change in the parameter being passed to the bindServiceCommon() method can lead to the API returning a different value, therefore, the CI type is 1."
841,<android.bluetooth.le.AdvertisingSetParameters: boolean isAnonymous()>,27,28,<android.bluetooth.le.AdvertisingSetParameters: boolean isAnonymous()>,<android.bluetooth.le.AdvertisingSetParameters: boolean isAnonymous()>,0,"{
    return isAnonymous;
}","{
    return mIsAnonymous;
}",1,"/**
 * Returns whether the advertisement will be anonymous.
 */
","/**
 * Returns whether the advertisement will be anonymous.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The code has changed from using ""isAnonymous"" to ""mIsAnonymous"", which is likely just a renaming of the variable with no change in the method's logic or return type, so the code change type is 4.","There is no Compatibility Issue, as the renaming of the variable does not affect the return value or behavior of the method, assuming that ""mIsAnonymous"" is just a new name of ""isAnonymous"" and the semantic meaning hasn't changed."
842,<android.app.NotificationManager: StatusBarNotification[] getActiveNotifications()>,27,28,<android.app.NotificationManager: StatusBarNotification[] getActiveNotifications()>,<android.app.NotificationManager: StatusBarNotification[] getActiveNotifications()>,0,"{
    final INotificationManager service = getService();
    final String pkg = mContext.getPackageName();
    try {
        final ParceledListSlice<StatusBarNotification> parceledList = service.getAppActiveNotifications(pkg, UserHandle.myUserId());
        final List<StatusBarNotification> list = parceledList.getList();
        return list.toArray(new StatusBarNotification[list.size()]);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}","{
    final INotificationManager service = getService();
    final String pkg = mContext.getPackageName();
    try {
        final ParceledListSlice<StatusBarNotification> parceledList = service.getAppActiveNotifications(pkg, mContext.getUserId());
        final List<StatusBarNotification> list = parceledList.getList();
        return list.toArray(new StatusBarNotification[list.size()]);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Recover a list of active notifications: ones that have been posted by the calling app that
 * have not yet been dismissed by the user or {@link #cancel(String, int)}ed by the app.
 *
 * Each notification is embedded in a {@link StatusBarNotification} object, including the
 * original <code>tag</code> and <code>id</code> supplied to
 * {@link #notify(String, int, Notification) notify()}
 * (via {@link StatusBarNotification#getTag() getTag()} and
 * {@link StatusBarNotification#getId() getId()}) as well as a copy of the original
 * {@link Notification} object (via {@link StatusBarNotification#getNotification()}).
 *
 * @return An array of {@link StatusBarNotification}.
 */
","/**
 * Recover a list of active notifications: ones that have been posted by the calling app that
 * have not yet been dismissed by the user or {@link #cancel(String, int)}ed by the app.
 *
 * Each notification is embedded in a {@link StatusBarNotification} object, including the
 * original <code>tag</code> and <code>id</code> supplied to
 * {@link #notify(String, int, Notification) notify()}
 * (via {@link StatusBarNotification#getTag() getTag()} and
 * {@link StatusBarNotification#getId() getId()}) as well as a copy of the original
 * {@link Notification} object (via {@link StatusBarNotification#getNotification()}).
 *
 * @return An array of {@link StatusBarNotification}.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The only code change is the call from UserHandle.myUserId() to mContext.getUserId(). This is a change to a dependent API call, but since this change does not impact any control dependency, return statements, or exception handling, it's classified under Other statement changed.","There is no Compatibility Issue here because the method still returns the same type of data (array of StatusBarNotification), and no change in control flow or error handling has been made that would affect the outcome of the method's execution. The change in the dependent API call is internal and should not affect clients calling the getActiveNotifications() method assuming mContext.getUserId() returns a valid user ID as UserHandle.myUserId() did."
843,"<android.bluetooth.BluetoothGatt: boolean setCharacteristicNotification(BluetoothGattCharacteristic,boolean)>",27,28,"<android.bluetooth.BluetoothGatt: boolean setCharacteristicNotification(BluetoothGattCharacteristic,boolean)>","<android.bluetooth.BluetoothGatt: boolean setCharacteristicNotification(BluetoothGattCharacteristic,boolean)>",0,"{
    if (DBG)
        Log.d(TAG, ""setCharacteristicNotification() - uuid: "" + characteristic.getUuid() + "" enable: "" + enable);
    if (mService == null || mClientIf == 0)
        return false;
    BluetoothGattService service = characteristic.getService();
    if (service == null)
        return false;
    BluetoothDevice device = service.getDevice();
    if (device == null)
        return false;
    try {
        mService.registerForNotification(mClientIf, device.getAddress(), characteristic.getInstanceId(), enable);
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
        return false;
    }
    return true;
}","{
    if (DBG) {
        Log.d(TAG, ""setCharacteristicNotification() - uuid: "" + characteristic.getUuid() + "" enable: "" + enable);
    }
    if (mService == null || mClientIf == 0)
        return false;
    BluetoothGattService service = characteristic.getService();
    if (service == null)
        return false;
    BluetoothDevice device = service.getDevice();
    if (device == null)
        return false;
    try {
        mService.registerForNotification(mClientIf, device.getAddress(), characteristic.getInstanceId(), enable);
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
        return false;
    }
    return true;
}",1,"/**
 * Enable or disable notifications/indications for a given characteristic.
 *
 * <p>Once notifications are enabled for a characteristic, a
 * {@link BluetoothGattCallback#onCharacteristicChanged} callback will be
 * triggered if the remote device indicates that the given characteristic
 * has changed.
 *
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH} permission.
 *
 * @param characteristic The characteristic for which to enable notifications
 * @param enable Set to true to enable notifications/indications
 * @return true, if the requested notification status was set successfully
 */
","/**
 * Enable or disable notifications/indications for a given characteristic.
 *
 * <p>Once notifications are enabled for a characteristic, a
 * {@link BluetoothGattCallback#onCharacteristicChanged} callback will be
 * triggered if the remote device indicates that the given characteristic
 * has changed.
 *
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH} permission.
 *
 * @param characteristic The characteristic for which to enable notifications
 * @param enable Set to true to enable notifications/indications
 * @return true, if the requested notification status was set successfully
 */
",-1,,,-1,-1,-1,-1,-1,-1,0,0,"No functional code changes have been made. The only change is the formatting of the debug log line, which does not affect the API behavior.","Since there are no functional changes to the API, there is no Compatibility Issue. The API would behave the same way as before."
844,<android.app.Notification.Builder: int resolveContrastColor()>,27,28,<android.app.Notification.Builder: int resolveContrastColor()>,<android.app.Notification.Builder: int resolveContrastColor()>,0,"{
    if (mCachedContrastColorIsFor == mN.color && mCachedContrastColor != COLOR_INVALID) {
        return mCachedContrastColor;
    }
    int color;
    int background = mBackgroundColorHint;
    if (mBackgroundColorHint == COLOR_INVALID) {
        background = mContext.getColor(com.android.internal.R.color.notification_material_background_color);
    }
    if (mN.color == COLOR_DEFAULT) {
        ensureColors();
        color = mSecondaryTextColor;
    } else {
        color = NotificationColorUtil.resolveContrastColor(mContext, mN.color, background, mInNightMode);
    }
    if (Color.alpha(color) < 255) {
        // alpha doesn't go well for color filters, so let's blend it manually
        color = NotificationColorUtil.compositeColors(color, background);
    }
    mCachedContrastColorIsFor = mN.color;
    return mCachedContrastColor = color;
}","{
    if (mCachedContrastColorIsFor == mN.color && mCachedContrastColor != COLOR_INVALID) {
        return mCachedContrastColor;
    }
    int color;
    int background = mContext.getColor(com.android.internal.R.color.notification_material_background_color);
    if (mN.color == COLOR_DEFAULT) {
        ensureColors();
        color = NotificationColorUtil.resolveDefaultColor(mContext, background);
    } else {
        color = NotificationColorUtil.resolveContrastColor(mContext, mN.color, background, mInNightMode);
    }
    if (Color.alpha(color) < 255) {
        // alpha doesn't go well for color filters, so let's blend it manually
        color = NotificationColorUtil.compositeColors(color, background);
    }
    mCachedContrastColorIsFor = mN.color;
    return mCachedContrastColor = color;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"3,4",1,"The variable 'background' no longer receives a value from 'mBackgroundColorHint', instead, it directly accesses a resource color in both branches of the if-else statement, and the call to resolveDefaultColor is introduced. Thus, the compatible changes are control dependency change and other statement change, coded as 3,4.","Because of the changes in the assignment of 'background' and the method call to resolveDefaultColor, the resolved color could potentially be different, leading to a different return value. Hence, there is a Compatibility Issue due to potential different return values, which is coded as 1."
845,"<android.app.admin.DevicePolicyManager: boolean installKeyPair(ComponentName,PrivateKey,Certificate[],String,boolean)>",27,28,"<android.app.admin.DevicePolicyManager: boolean installKeyPair(ComponentName,PrivateKey,Certificate[],String,boolean)>","<android.app.admin.DevicePolicyManager: boolean installKeyPair(ComponentName,PrivateKey,Certificate[],String,boolean)>",0,"{
    throwIfParentInstance(""installKeyPair"");
    try {
        final byte[] pemCert = Credentials.convertToPem(certs[0]);
        byte[] pemChain = null;
        if (certs.length > 1) {
            pemChain = Credentials.convertToPem(Arrays.copyOfRange(certs, 1, certs.length));
        }
        final byte[] pkcs8Key = KeyFactory.getInstance(privKey.getAlgorithm()).getKeySpec(privKey, PKCS8EncodedKeySpec.class).getEncoded();
        return mService.installKeyPair(admin, mContext.getPackageName(), pkcs8Key, pemCert, pemChain, alias, requestAccess);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    } catch (NoSuchAlgorithmException | InvalidKeySpecException e) {
        Log.w(TAG, ""Failed to obtain private key material"", e);
    } catch (CertificateException | IOException e) {
        Log.w(TAG, ""Could not pem-encode certificate"", e);
    }
    return false;
}","{
    int flags = INSTALLKEY_SET_USER_SELECTABLE;
    if (requestAccess) {
        flags |= INSTALLKEY_REQUEST_CREDENTIALS_ACCESS;
    }
    return installKeyPair(admin, privKey, certs, alias, flags);
}",1,"/**
 * Called by a device or profile owner, or delegated certificate installer, to install a
 * certificate chain and corresponding private key for the leaf certificate. All apps within the
 * profile will be able to access the certificate chain and use the private key, given direct
 * user approval.
 *
 * <p>The caller of this API may grant itself access to the certificate and private key
 * immediately, without user approval. It is a best practice not to request this unless strictly
 * necessary since it opens up additional security vulnerabilities.
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated with, or
 * {@code null} if calling from a delegated certificate installer.
 * @param privKey The private key to install.
 * @param certs The certificate chain to install. The chain should start with the leaf
 * certificate and include the chain of trust in order. This will be returned by
 * {@link android.security.KeyChain#getCertificateChain}.
 * @param alias The private key alias under which to install the certificate. If a certificate
 * with that alias already exists, it will be overwritten.
 * @param requestAccess {@code true} to request that the calling app be granted access to the
 * credentials immediately. Otherwise, access to the credentials will be gated by user
 * approval.
 * @return {@code true} if the keys were installed, {@code false} otherwise.
 * @throws SecurityException if {@code admin} is not {@code null} and not a device or profile
 * owner.
 * @see android.security.KeyChain#getCertificateChain
 * @see #setDelegatedScopes
 * @see #DELEGATION_CERT_INSTALL
 */
","/**
 * Called by a device or profile owner, or delegated certificate installer, to install a
 * certificate chain and corresponding private key for the leaf certificate. All apps within the
 * profile will be able to access the certificate chain and use the private key, given direct
 * user approval.
 *
 * <p>The caller of this API may grant itself access to the certificate and private key
 * immediately, without user approval. It is a best practice not to request this unless strictly
 * necessary since it opens up additional security vulnerabilities.
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated with, or
 * {@code null} if calling from a delegated certificate installer.
 * @param privKey The private key to install.
 * @param certs The certificate chain to install. The chain should start with the leaf
 * certificate and include the chain of trust in order. This will be returned by
 * {@link android.security.KeyChain#getCertificateChain}.
 * @param alias The private key alias under which to install the certificate. If a certificate
 * with that alias already exists, it will be overwritten.
 * @param requestAccess {@code true} to request that the calling app be granted access to the
 * credentials immediately. Otherwise, access to the credentials will be gated by user
 * approval.
 * @return {@code true} if the keys were installed, {@code false} otherwise.
 * @throws SecurityException if {@code admin} is not {@code null} and not a device or profile
 * owner.
 * @see android.security.KeyChain#getCertificateChain
 * @see #setDelegatedScopes
 * @see #DELEGATION_CERT_INSTALL
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3,4,5","1,2",The implementation has changed significantly:,- The internal logic including exception handling and some computations was removed entirely
847,<android.database.DatabaseUtils: int getSqlStatementType(String)>,27,28,<android.database.DatabaseUtils: int getSqlStatementType(String)>,<android.database.DatabaseUtils: int getSqlStatementType(String)>,0,"{
    sql = sql.trim();
    if (sql.length() < 3) {
        return STATEMENT_OTHER;
    }
    String prefixSql = sql.substring(0, 3).toUpperCase(Locale.ROOT);
    if (prefixSql.equals(""SEL"")) {
        return STATEMENT_SELECT;
    } else if (prefixSql.equals(""INS"") || prefixSql.equals(""UPD"") || prefixSql.equals(""REP"") || prefixSql.equals(""DEL"")) {
        return STATEMENT_UPDATE;
    } else if (prefixSql.equals(""ATT"")) {
        return STATEMENT_ATTACH;
    } else if (prefixSql.equals(""COM"")) {
        return STATEMENT_COMMIT;
    } else if (prefixSql.equals(""END"")) {
        return STATEMENT_COMMIT;
    } else if (prefixSql.equals(""ROL"")) {
        return STATEMENT_ABORT;
    } else if (prefixSql.equals(""BEG"")) {
        return STATEMENT_BEGIN;
    } else if (prefixSql.equals(""PRA"")) {
        return STATEMENT_PRAGMA;
    } else if (prefixSql.equals(""CRE"") || prefixSql.equals(""DRO"") || prefixSql.equals(""ALT"")) {
        return STATEMENT_DDL;
    } else if (prefixSql.equals(""ANA"") || prefixSql.equals(""DET"")) {
        return STATEMENT_UNPREPARED;
    }
    return STATEMENT_OTHER;
}","{
    sql = sql.trim();
    if (sql.length() < 3) {
        return STATEMENT_OTHER;
    }
    String prefixSql = sql.substring(0, 3).toUpperCase(Locale.ROOT);
    if (prefixSql.equals(""SEL"")) {
        return STATEMENT_SELECT;
    } else if (prefixSql.equals(""INS"") || prefixSql.equals(""UPD"") || prefixSql.equals(""REP"") || prefixSql.equals(""DEL"")) {
        return STATEMENT_UPDATE;
    } else if (prefixSql.equals(""ATT"")) {
        return STATEMENT_ATTACH;
    } else if (prefixSql.equals(""COM"")) {
        return STATEMENT_COMMIT;
    } else if (prefixSql.equals(""END"")) {
        return STATEMENT_COMMIT;
    } else if (prefixSql.equals(""ROL"")) {
        boolean isRollbackToSavepoint = sql.toUpperCase(Locale.ROOT).contains("" TO "");
        if (isRollbackToSavepoint) {
            Log.w(TAG, ""Statement '"" + sql + ""' may not work on API levels 16-27, use ';"" + sql + ""' instead"");
            return STATEMENT_OTHER;
        }
        return STATEMENT_ABORT;
    } else if (prefixSql.equals(""BEG"")) {
        return STATEMENT_BEGIN;
    } else if (prefixSql.equals(""PRA"")) {
        return STATEMENT_PRAGMA;
    } else if (prefixSql.equals(""CRE"") || prefixSql.equals(""DRO"") || prefixSql.equals(""ALT"")) {
        return STATEMENT_DDL;
    } else if (prefixSql.equals(""ANA"") || prefixSql.equals(""DET"")) {
        return STATEMENT_UNPREPARED;
    }
    return STATEMENT_OTHER;
}",1,"/**
 * Returns one of the following which represent the type of the given SQL statement.
 * <ol>
 * <li>{@link #STATEMENT_SELECT}</li>
 * <li>{@link #STATEMENT_UPDATE}</li>
 * <li>{@link #STATEMENT_ATTACH}</li>
 * <li>{@link #STATEMENT_BEGIN}</li>
 * <li>{@link #STATEMENT_COMMIT}</li>
 * <li>{@link #STATEMENT_ABORT}</li>
 * <li>{@link #STATEMENT_OTHER}</li>
 * </ol>
 * @param sql the SQL statement whose type is returned by this method
 * @return one of the values listed above
 */
","/**
 * Returns one of the following which represent the type of the given SQL statement.
 * <ol>
 * <li>{@link #STATEMENT_SELECT}</li>
 * <li>{@link #STATEMENT_UPDATE}</li>
 * <li>{@link #STATEMENT_ATTACH}</li>
 * <li>{@link #STATEMENT_BEGIN}</li>
 * <li>{@link #STATEMENT_COMMIT}</li>
 * <li>{@link #STATEMENT_ABORT}</li>
 * <li>{@link #STATEMENT_OTHER}</li>
 * </ol>
 * @param sql the SQL statement whose type is returned by this method
 * @return one of the values listed above
 */
",-1,,,-1,-1,-1,-1,-1,-1,3,0,"The code has introduced additional logic in the ""ROL"" branch of the if-else chain, checking for a specific condition in the SQL string and potentially logging a warning. This change is in the control dependency (an if condition within an existing else-if branch), thus, the code change type is 3.","The additional logic only affects logging and does not alter the return value of the method. Regardless of whether the new 'if' condition is true or not, the method will still return STATEMENT_ABORT or STATEMENT_OTHER as it did in the early version for ROLLBACK statements that do not involve 'TO'. Thereby, the behavior of the API in terms of the return value has not been modified for the cases it handles, so there's no Compatibility Issue in this change. The warning might inform users of potential issues on specific API levels, but it doesn't impact the execution flow that determines the method's output."
848,<android.bluetooth.le.AdvertisingSet: void setAdvertisingData(AdvertiseData)>,27,28,<android.bluetooth.le.AdvertisingSet: void setAdvertisingData(AdvertiseData)>,<android.bluetooth.le.AdvertisingSet: void setAdvertisingData(AdvertiseData)>,0,"{
    try {
        gatt.setAdvertisingData(this.advertiserId, advertiseData);
    } catch (RemoteException e) {
        Log.e(TAG, ""remote exception - "", e);
    }
}","{
    try {
        mGatt.setAdvertisingData(mAdvertiserId, advertiseData);
    } catch (RemoteException e) {
        Log.e(TAG, ""remote exception - "", e);
    }
}",1,"/**
 * Set/update data being Advertised. Make sure that data doesn't exceed the size limit for
 * specified AdvertisingSetParameters. This method returns immediately, the operation status is
 * delivered through {@code callback.onAdvertisingDataSet()}.
 * <p>
 * Advertising data must be empty if non-legacy scannable advertising is used.
 *
 * @param advertiseData Advertisement data to be broadcasted. Size must not exceed
 * {@link BluetoothAdapter#getLeMaximumAdvertisingDataLength}. If the
 * advertisement is connectable, three bytes will be added for flags. If the
 * update takes place when the advertising set is enabled, the data can be
 * maximum 251 bytes long.
 */
","/**
 * Set/update data being Advertised. Make sure that data doesn't exceed the size limit for
 * specified AdvertisingSetParameters. This method returns immediately, the operation status is
 * delivered through {@code callback.onAdvertisingDataSet()}.
 * <p>
 * Advertising data must be empty if non-legacy scannable advertising is used.
 *
 * @param advertiseData Advertisement data to be broadcasted. Size must not exceed {@link
 * BluetoothAdapter#getLeMaximumAdvertisingDataLength}. If the advertisement is connectable,
 * three bytes will be added for flags. If the update takes place when the advertising set is
 * enabled, the data can be maximum 251 bytes long.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The change consists of renaming local variable references (`gatt` to `mGatt` and `advertiserId` to `mAdvertiserId`). The method bodies remain functionally equivalent, and there are no changes to the exception handling or return statements. Thus, the code change type is 4.",There is no Compatibility Issue since the method's functionality (including what it returns and the exceptions it may throw) has not been altered. The renaming of local variables does not affect the API's external behavior.
849,<android.content.res.TypedArray: CharSequence getText(int)>,27,28,<android.content.res.TypedArray: CharSequence getText(int)>,<android.content.res.TypedArray: CharSequence getText(int)>,0,"{
    if (mRecycled) {
        throw new RuntimeException(""Cannot make calls to a recycled instance!"");
    }
    index *= AssetManager.STYLE_NUM_ENTRIES;
    final int[] data = mData;
    final int type = data[index + AssetManager.STYLE_TYPE];
    if (type == TypedValue.TYPE_NULL) {
        return null;
    } else if (type == TypedValue.TYPE_STRING) {
        return loadStringValueAt(index);
    }
    final TypedValue v = mValue;
    if (getValueAt(index, v)) {
        return v.coerceToString();
    }
    // We already checked for TYPE_NULL. This should never happen.
    throw new RuntimeException(""getText of bad type: 0x"" + Integer.toHexString(type));
}","{
    if (mRecycled) {
        throw new RuntimeException(""Cannot make calls to a recycled instance!"");
    }
    index *= STYLE_NUM_ENTRIES;
    final int[] data = mData;
    final int type = data[index + STYLE_TYPE];
    if (type == TypedValue.TYPE_NULL) {
        return null;
    } else if (type == TypedValue.TYPE_STRING) {
        return loadStringValueAt(index);
    }
    final TypedValue v = mValue;
    if (getValueAt(index, v)) {
        return v.coerceToString();
    }
    // We already checked for TYPE_NULL. This should never happen.
    throw new RuntimeException(""getText of bad type: 0x"" + Integer.toHexString(type));
}",1,"/**
 * Retrieves the styled string value for the attribute at <var>index</var>.
 * <p>
 * If the attribute is not a string, this method will attempt to coerce
 * it to a string.
 *
 * @param index Index of attribute to retrieve.
 *
 * @return CharSequence holding string data. May be styled. Returns
 * {@code null} if the attribute is not defined or could not be
 * coerced to a string.
 * @throws RuntimeException if the TypedArray has already been recycled.
 */
","/**
 * Retrieves the styled string value for the attribute at <var>index</var>.
 * <p>
 * If the attribute is not a string, this method will attempt to coerce
 * it to a string.
 *
 * @param index Index of attribute to retrieve.
 *
 * @return CharSequence holding string data. May be styled. Returns
 * {@code null} if the attribute is not defined or could not be
 * coerced to a string.
 * @throws RuntimeException if the TypedArray has already been recycled.
 */
",-1,,,-1,-1,-1,-1,-1,-1,0,0,There is no change in the method's implementation between the early and late versions.,"Since there are no changes in the implementation, no Compatibility Issue could arise."
851,<android.nfc.cardemulation.NfcFCardEmulation: String getNfcid2ForService(ComponentName)>,27,28,<android.nfc.cardemulation.NfcFCardEmulation: String getNfcid2ForService(ComponentName)>,<android.nfc.cardemulation.NfcFCardEmulation: String getNfcid2ForService(ComponentName)>,0,"{
    if (service == null) {
        throw new NullPointerException(""service is null"");
    }
    try {
        return sService.getNfcid2ForService(UserHandle.myUserId(), service);
    } catch (RemoteException e) {
        // Try one more time
        recoverService();
        if (sService == null) {
            Log.e(TAG, ""Failed to recover CardEmulationService."");
            return null;
        }
        try {
            return sService.getNfcid2ForService(UserHandle.myUserId(), service);
        } catch (RemoteException ee) {
            Log.e(TAG, ""Failed to reach CardEmulationService."");
            ee.rethrowAsRuntimeException();
            return null;
        }
    }
}","{
    if (service == null) {
        throw new NullPointerException(""service is null"");
    }
    try {
        return sService.getNfcid2ForService(mContext.getUserId(), service);
    } catch (RemoteException e) {
        // Try one more time
        recoverService();
        if (sService == null) {
            Log.e(TAG, ""Failed to recover CardEmulationService."");
            return null;
        }
        try {
            return sService.getNfcid2ForService(mContext.getUserId(), service);
        } catch (RemoteException ee) {
            Log.e(TAG, ""Failed to reach CardEmulationService."");
            ee.rethrowAsRuntimeException();
            return null;
        }
    }
}",1,"/**
 * Retrieves the current NFCID2 for the specified service.
 *
 * <p>Before calling {@link #setNfcid2ForService(ComponentName, String)},
 * the NFCID2 contained in the Manifest file is returned. If ""random"" is specified
 * in the Manifest file, a random number assigned by the system at installation time
 * is returned. After setting an NFCID2
 * with {@link #setNfcid2ForService(ComponentName, String)}, this NFCID2 is returned.
 *
 * @param service The component name of the service
 * @return the current NFCID2
 */
","/**
 * Retrieves the current NFCID2 for the specified service.
 *
 * <p>Before calling {@link #setNfcid2ForService(ComponentName, String)},
 * the NFCID2 contained in the Manifest file is returned. If ""random"" is specified
 * in the Manifest file, a random number assigned by the system at installation time
 * is returned. After setting an NFCID2
 * with {@link #setNfcid2ForService(ComponentName, String)}, this NFCID2 is returned.
 *
 * @param service The component name of the service
 * @return the current NFCID2
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The implementation has changed the method calling `UserHandle.myUserId()` to `mContext.getUserId()`. This corresponds to a change in the way the user ID is obtained, which is a change in a dependent API; therefore, the code change type is 5.","Since `UserHandle.myUserId()` and `mContext.getUserId()` are expected to return the same user ID in the context of the current user, there should not be any compatibility issue with respect to different return values, types, or exceptions being thrown. Thus, the CI type is 0."
853,<android.animation.ValueAnimator: long getCurrentPlayTime()>,27,28,<android.animation.ValueAnimator: long getCurrentPlayTime()>,<android.animation.ValueAnimator: long getCurrentPlayTime()>,0,"{
    if (!mInitialized || (!mStarted && mSeekFraction < 0)) {
        return 0;
    }
    if (mSeekFraction >= 0) {
        return (long) (mDuration * mSeekFraction);
    }
    float durationScale = sDurationScale == 0 ? 1 : sDurationScale;
    return (long) ((AnimationUtils.currentAnimationTimeMillis() - mStartTime) / durationScale);
}","{
    if (!mInitialized || (!mStarted && mSeekFraction < 0)) {
        return 0;
    }
    if (mSeekFraction >= 0) {
        return (long) (mDuration * mSeekFraction);
    }
    float durationScale = resolveDurationScale();
    if (durationScale == 0f) {
        durationScale = 1f;
    }
    return (long) ((AnimationUtils.currentAnimationTimeMillis() - mStartTime) / durationScale);
}",1,"/**
 * Gets the current position of the animation in time, which is equal to the current
 * time minus the time that the animation started. An animation that is not yet started will
 * return a value of zero, unless the animation has has its play time set via
 * {@link #setCurrentPlayTime(long)} or {@link #setCurrentFraction(float)}, in which case
 * it will return the time that was set.
 *
 * @return The current position in time of the animation.
 */
","/**
 * Gets the current position of the animation in time, which is equal to the current
 * time minus the time that the animation started. An animation that is not yet started will
 * return a value of zero, unless the animation has has its play time set via
 * {@link #setCurrentPlayTime(long)} or {@link #setCurrentFraction(float)}, in which case
 * it will return the time that was set.
 *
 * @return The current position in time of the animation.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,5",0,"The method sDurationScale has been replaced by resolveDurationScale(), and additional condition checking for the value of durationScale has been added, so the code change types are 3 for control dependency change and 5 for dependent API change.",There is no compatibility issue detected between the two versions. The newly introduced method resolveDurationScale() and the additional condition checking do not lead to a change in the return behavior compared to the previous behavior when sDurationScale was directly used. The handling of durationScale being zero and the return logic remains the same; the additional condition only refactors the code without changing the semantics.
855,"<android.provider.Settings.System: String getString(ContentResolver,String)>",27,28,"<android.provider.Settings.System: String getString(ContentResolver,String)>","<android.provider.Settings.System: String getString(ContentResolver,String)>",0,"{
    return getStringForUser(resolver, name, UserHandle.myUserId());
}","{
    return getStringForUser(resolver, name, resolver.getUserId());
}",1,"/**
 * Look up a name in the database.
 * @param resolver to access the database with
 * @param name to look up in the table
 * @return the corresponding value, or null if not present
 */
","/**
 * Look up a name in the database.
 * @param resolver to access the database with
 * @param name to look up in the table
 * @return the corresponding value, or null if not present
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"The implementation has changed the source of the user ID from a local method (UserHandle.myUserId()) to a method call on the resolver object (resolver.getUserId()), so the change types are 4 for method body change and 5 for dependent API change.","There is no compatibility issue because the same user ID that pertains to the caller is fetched in the beginning, and the functionality of obtaining a string for a specific user remains unchanged. Although the mechanism for retrieving the user ID has changed between versions, the contract of the method suggests that it will still be returning content for the calling user, and therefore, the behavior from an external perspective remains the same."
856,<android.app.WallpaperManager: WallpaperInfo getWallpaperInfo()>,27,28,<android.app.WallpaperManager: WallpaperInfo getWallpaperInfo()>,<android.app.WallpaperManager: WallpaperInfo getWallpaperInfo()>,0,"{
    try {
        if (sGlobals.mService == null) {
            Log.w(TAG, ""WallpaperService not running"");
            throw new RuntimeException(new DeadSystemException());
        } else {
            return sGlobals.mService.getWallpaperInfo(UserHandle.myUserId());
        }
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}","{
    try {
        if (sGlobals.mService == null) {
            Log.w(TAG, ""WallpaperService not running"");
            throw new RuntimeException(new DeadSystemException());
        } else {
            return sGlobals.mService.getWallpaperInfo(mContext.getUserId());
        }
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * If the current wallpaper is a live wallpaper component, return the
 * information about that wallpaper.  Otherwise, if it is a static image,
 * simply return null.
 */
","/**
 * If the current wallpaper is a live wallpaper component, return the
 * information about that wallpaper.  Otherwise, if it is a static image,
 * simply return null.
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The only change is the method call from `UserHandle.myUserId()` to `mContext.getUserId()`. Since it is an internal detail about how the user ID is retrieved, and assuming that both methods ultimately yield the same user ID, the change is of type 5 (Dependent API changed).","Since the change is purely replacing one method to get the user ID with another and assuming that the change does not alter the user ID that is used, there is no Compatibility Issue caused by potentially different return values, types, or exceptions. Therefore, no CI is detected."
858,<android.content.res.TypedArray: String getNonResourceString(int)>,27,28,<android.content.res.TypedArray: String getNonResourceString(int)>,<android.content.res.TypedArray: String getNonResourceString(int)>,0,"{
    if (mRecycled) {
        throw new RuntimeException(""Cannot make calls to a recycled instance!"");
    }
    index *= AssetManager.STYLE_NUM_ENTRIES;
    final int[] data = mData;
    final int type = data[index + AssetManager.STYLE_TYPE];
    if (type == TypedValue.TYPE_STRING) {
        final int cookie = data[index + AssetManager.STYLE_ASSET_COOKIE];
        if (cookie < 0) {
            return mXml.getPooledString(data[index + AssetManager.STYLE_DATA]).toString();
        }
    }
    return null;
}","{
    if (mRecycled) {
        throw new RuntimeException(""Cannot make calls to a recycled instance!"");
    }
    index *= STYLE_NUM_ENTRIES;
    final int[] data = mData;
    final int type = data[index + STYLE_TYPE];
    if (type == TypedValue.TYPE_STRING) {
        final int cookie = data[index + STYLE_ASSET_COOKIE];
        if (cookie < 0) {
            return mXml.getPooledString(data[index + STYLE_DATA]).toString();
        }
    }
    return null;
}",1,"/**
 * Retrieves the string value for the attribute at <var>index</var>, but
 * only if that string comes from an immediate value in an XML file.  That
 * is, this does not allow references to string resources, string
 * attributes, or conversions from other types.  As such, this method
 * will only return strings for TypedArray objects that come from
 * attributes in an XML file.
 *
 * @param index Index of attribute to retrieve.
 *
 * @return String holding string data. Any styling information is removed.
 * Returns {@code null} if the attribute is not defined or is not
 * an immediate string value.
 * @throws RuntimeException if the TypedArray has already been recycled.
 */
","/**
 * Retrieves the string value for the attribute at <var>index</var>, but
 * only if that string comes from an immediate value in an XML file.  That
 * is, this does not allow references to string resources, string
 * attributes, or conversions from other types.  As such, this method
 * will only return strings for TypedArray objects that come from
 * attributes in an XML file.
 *
 * @param index Index of attribute to retrieve.
 *
 * @return String holding string data. Any styling information is removed.
 * Returns {@code null} if the attribute is not defined or is not
 * an immediate string value.
 * @throws RuntimeException if the TypedArray has already been recycled.
 */
",-1,,,-1,-1,-1,-1,-1,-1,0,0,"There is no actual change in the logic or functionality of the code; the only difference is the removal of the class name ""AssetManager"" from the constants which are being accessed. This is simply a syntactical change, using implicit access to static members of the class rather than explicit.",No Compatibility Issue arises because the functionality and the behavior of the method remain the same between the two versions.
859,<android.content.res.TypedArray: String getString(int)>,27,28,<android.content.res.TypedArray: String getString(int)>,<android.content.res.TypedArray: String getString(int)>,0,"{
    if (mRecycled) {
        throw new RuntimeException(""Cannot make calls to a recycled instance!"");
    }
    index *= AssetManager.STYLE_NUM_ENTRIES;
    final int[] data = mData;
    final int type = data[index + AssetManager.STYLE_TYPE];
    if (type == TypedValue.TYPE_NULL) {
        return null;
    } else if (type == TypedValue.TYPE_STRING) {
        return loadStringValueAt(index).toString();
    }
    final TypedValue v = mValue;
    if (getValueAt(index, v)) {
        final CharSequence cs = v.coerceToString();
        return cs != null ? cs.toString() : null;
    }
    // We already checked for TYPE_NULL. This should never happen.
    throw new RuntimeException(""getString of bad type: 0x"" + Integer.toHexString(type));
}","{
    if (mRecycled) {
        throw new RuntimeException(""Cannot make calls to a recycled instance!"");
    }
    index *= STYLE_NUM_ENTRIES;
    final int[] data = mData;
    final int type = data[index + STYLE_TYPE];
    if (type == TypedValue.TYPE_NULL) {
        return null;
    } else if (type == TypedValue.TYPE_STRING) {
        return loadStringValueAt(index).toString();
    }
    final TypedValue v = mValue;
    if (getValueAt(index, v)) {
        final CharSequence cs = v.coerceToString();
        return cs != null ? cs.toString() : null;
    }
    // We already checked for TYPE_NULL. This should never happen.
    throw new RuntimeException(""getString of bad type: 0x"" + Integer.toHexString(type));
}",1,"/**
 * Retrieves the string value for the attribute at <var>index</var>.
 * <p>
 * If the attribute is not a string, this method will attempt to coerce
 * it to a string.
 *
 * @param index Index of attribute to retrieve.
 *
 * @return String holding string data. Any styling information is removed.
 * Returns {@code null} if the attribute is not defined or could
 * not be coerced to a string.
 * @throws RuntimeException if the TypedArray has already been recycled.
 */
","/**
 * Retrieves the string value for the attribute at <var>index</var>.
 * <p>
 * If the attribute is not a string, this method will attempt to coerce
 * it to a string.
 *
 * @param index Index of attribute to retrieve.
 *
 * @return String holding string data. Any styling information is removed.
 * Returns {@code null} if the attribute is not defined or could
 * not be coerced to a string.
 * @throws RuntimeException if the TypedArray has already been recycled.
 */
",-1,[@Nullable],[@Nullable],-1,-1,-1,-1,-1,-1,0,0,"There are no actual changes in the implementation of the methods; the constants `AssetManager.STYLE_NUM_ENTRIES` and `AssetManager.STYLE_TYPE` were simply accessed in a different way, presumably because of import changes but not affecting behavior. Thus, even though the source lines look different, the executed bytecode would be identical and there's no change in behavior. The annotations have also not changed from [@Nullable] in both versions.",No Compatibility Issue could arise for the API because there is no change in the method's behavior between the two versions.
860,<android.bluetooth.BluetoothSocket: void close()>,27,28,<android.bluetooth.BluetoothSocket: void close()>,<android.bluetooth.BluetoothSocket: void close()>,0,"{
    Log.d(TAG, ""close() this: "" + this + "", channel: "" + mPort + "", mSocketIS: "" + mSocketIS + "", mSocketOS: "" + mSocketOS + ""mSocket: "" + mSocket + "", mSocketState: "" + mSocketState);
    if (mSocketState == SocketState.CLOSED)
        return;
    else {
        synchronized (this) {
            if (mSocketState == SocketState.CLOSED)
                return;
            mSocketState = SocketState.CLOSED;
            if (mSocket != null) {
                if (DBG)
                    Log.d(TAG, ""Closing mSocket: "" + mSocket);
                mSocket.shutdownInput();
                mSocket.shutdownOutput();
                mSocket.close();
                mSocket = null;
            }
            if (mPfd != null) {
                mPfd.close();
                mPfd = null;
            }
        }
    }
}","{
    Log.d(TAG, ""close() this: "" + this + "", channel: "" + mPort + "", mSocketIS: "" + mSocketIS + "", mSocketOS: "" + mSocketOS + ""mSocket: "" + mSocket + "", mSocketState: "" + mSocketState);
    if (mSocketState == SocketState.CLOSED) {
        return;
    } else {
        synchronized (this) {
            if (mSocketState == SocketState.CLOSED) {
                return;
            }
            mSocketState = SocketState.CLOSED;
            if (mSocket != null) {
                if (DBG)
                    Log.d(TAG, ""Closing mSocket: "" + mSocket);
                mSocket.shutdownInput();
                mSocket.shutdownOutput();
                mSocket.close();
                mSocket = null;
            }
            if (mPfd != null) {
                mPfd.close();
                mPfd = null;
            }
        }
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,0,0,"There are no changes in the implementations of the early and late versions of the method. The method signatures, logic, and behavior remain the same.",There are no compatibility issues between the two versions since there were no changes made to the method's implementation.
861,"<android.view.textclassifier.TextClassifier: TextSelection suggestSelection(CharSequence,int,int,LocaleList)>",27,28,"<android.view.textclassifier.TextClassifier: TextSelection suggestSelection(CharSequence,int,int,LocaleList)>","<android.view.textclassifier.TextClassifier: TextSelection suggestSelection(CharSequence,int,int,LocaleList)>",0,,"{
    final TextSelection.Request request = new TextSelection.Request.Builder(text, selectionStartIndex, selectionEndIndex).setDefaultLocales(defaultLocales).build();
    return suggestSelection(request);
}",1,"/**
 * Returns suggested text selection indices, recognized types and their associated confidence
 * scores. The selections are ordered from highest to lowest scoring.
 *
 * @param text text providing context for the selected text (which is specified
 * by the sub sequence starting at selectionStartIndex and ending at selectionEndIndex)
 * @param selectionStartIndex start index of the selected part of text
 * @param selectionEndIndex end index of the selected part of text
 * @param defaultLocales ordered list of locale preferences that can be used to disambiguate
 * the provided text. If no locale preferences exist, set this to null or an empty locale
 * list in which case the classifier will decide whether to use no locale information, use
 * a default locale, or use the system default.
 *
 * @throws IllegalArgumentException if text is null; selectionStartIndex is negative;
 * selectionEndIndex is greater than text.length() or not greater than selectionStartIndex
 */
","/**
 * Returns suggested text selection start and end indices, recognized entity types, and their
 * associated confidence scores. The entity types are ordered from highest to lowest scoring.
 *
 * <p><strong>NOTE: </strong>Call on a worker thread.
 *
 * <p><strong>NOTE: </strong>If a TextClassifier has been destroyed, calls to this method should
 * throw an {@link IllegalStateException}. See {@link #isDestroyed()}.
 *
 * <p><b>NOTE:</b> Do not implement. The default implementation of this method calls
 * {@link #suggestSelection(TextSelection.Request)}. If that method calls this method,
 * a stack overflow error will happen.
 *
 * @param text text providing context for the selected text (which is specified
 * by the sub sequence starting at selectionStartIndex and ending at selectionEndIndex)
 * @param selectionStartIndex start index of the selected part of text
 * @param selectionEndIndex end index of the selected part of text
 * @param defaultLocales ordered list of locale preferences that may be used to
 * disambiguate the provided text. If no locale preferences exist, set this to null
 * or an empty locale list.
 *
 * @throws IllegalArgumentException if text is null; selectionStartIndex is negative;
 * selectionEndIndex is greater than text.length() or not greater than selectionStartIndex
 *
 * @see #suggestSelection(TextSelection.Request)
 */
",-1,"[@WorkerThread, @NonNull]","[@WorkerThread, @NonNull]",-1,-1,-1,-1,-1,-1,"4,5",0,"The early version is not available (nan), thus it seems there was no implementation. In the late version, there is now an implementation that creates a new instance of `TextSelection.Request` and calls `suggestSelection(request)`. This indicates a complete addition of the body of the method, which is a significant change in the implementation, thus the code change type is 4 (Other statement changed) for addition and 5 (Dependent API changed) for introducing a new instance creation and method call.","There was no previous behavior (as the early implementation was not available), so the late version's addition of functionality does not represent a change from previous behavior. This means there is no compatibility issue; accordingly, the CI type is 0."
862,<android.app.WallpaperColors: WallpaperColors fromDrawable(Drawable)>,27,28,<android.app.WallpaperColors: WallpaperColors fromDrawable(Drawable)>,<android.app.WallpaperColors: WallpaperColors fromDrawable(Drawable)>,0,"{
    int width = drawable.getIntrinsicWidth();
    int height = drawable.getIntrinsicHeight();
    // Some drawables do not have intrinsic dimensions
    if (width <= 0 || height <= 0) {
        width = MAX_BITMAP_SIZE;
        height = MAX_BITMAP_SIZE;
    }
    Size optimalSize = calculateOptimalSize(width, height);
    Bitmap bitmap = Bitmap.createBitmap(optimalSize.getWidth(), optimalSize.getHeight(), Bitmap.Config.ARGB_8888);
    final Canvas bmpCanvas = new Canvas(bitmap);
    drawable.setBounds(0, 0, bitmap.getWidth(), bitmap.getHeight());
    drawable.draw(bmpCanvas);
    final WallpaperColors colors = WallpaperColors.fromBitmap(bitmap);
    bitmap.recycle();
    return colors;
}","{
    if (drawable == null) {
        throw new IllegalArgumentException(""Drawable cannot be null"");
    }
    Rect initialBounds = drawable.copyBounds();
    int width = drawable.getIntrinsicWidth();
    int height = drawable.getIntrinsicHeight();
    // Some drawables do not have intrinsic dimensions
    if (width <= 0 || height <= 0) {
        width = MAX_BITMAP_SIZE;
        height = MAX_BITMAP_SIZE;
    }
    Size optimalSize = calculateOptimalSize(width, height);
    Bitmap bitmap = Bitmap.createBitmap(optimalSize.getWidth(), optimalSize.getHeight(), Bitmap.Config.ARGB_8888);
    final Canvas bmpCanvas = new Canvas(bitmap);
    drawable.setBounds(0, 0, bitmap.getWidth(), bitmap.getHeight());
    drawable.draw(bmpCanvas);
    final WallpaperColors colors = WallpaperColors.fromBitmap(bitmap);
    bitmap.recycle();
    drawable.setBounds(initialBounds);
    return colors;
}",1,"/**
 * Constructs {@link WallpaperColors} from a drawable.
 * <p>
 * Main colors will be extracted from the drawable.
 *
 * @param drawable Source where to extract from.
 */
","/**
 * Constructs {@link WallpaperColors} from a drawable.
 * <p>
 * Main colors will be extracted from the drawable.
 *
 * @param drawable Source where to extract from.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,3,4","1,2","The late implementation added a new exception handling statement for a null-check at the beginning (throw new IllegalArgumentException(""Drawable cannot be null"")), and it stores initial bounds, resets them to drawable after drawing process is done (drawable.setBounds(initialBounds)), and the introduction of new variable 'initialBounds'. So, the code change type is 2,3,4.","The additional null-check at the beginning and the additional exception thrown make it a CI of type 2 since clients relying on previous behavior may now encounter an IllegalArgumentException. The reset of bounds may potentially change the state of the input drawable object compared to the early version, which could alter the program behavior if the same drawable is used after calling this function, leading to a CI of type 1."
863,<android.nfc.cardemulation.NfcFCardEmulation: boolean unregisterSystemCodeForService(ComponentName)>,27,28,<android.nfc.cardemulation.NfcFCardEmulation: boolean unregisterSystemCodeForService(ComponentName)>,<android.nfc.cardemulation.NfcFCardEmulation: boolean unregisterSystemCodeForService(ComponentName)>,0,"{
    if (service == null) {
        throw new NullPointerException(""service is null"");
    }
    try {
        return sService.removeSystemCodeForService(UserHandle.myUserId(), service);
    } catch (RemoteException e) {
        // Try one more time
        recoverService();
        if (sService == null) {
            Log.e(TAG, ""Failed to recover CardEmulationService."");
            return false;
        }
        try {
            return sService.removeSystemCodeForService(UserHandle.myUserId(), service);
        } catch (RemoteException ee) {
            Log.e(TAG, ""Failed to reach CardEmulationService."");
            ee.rethrowAsRuntimeException();
            return false;
        }
    }
}","{
    if (service == null) {
        throw new NullPointerException(""service is null"");
    }
    try {
        return sService.removeSystemCodeForService(mContext.getUserId(), service);
    } catch (RemoteException e) {
        // Try one more time
        recoverService();
        if (sService == null) {
            Log.e(TAG, ""Failed to recover CardEmulationService."");
            return false;
        }
        try {
            return sService.removeSystemCodeForService(mContext.getUserId(), service);
        } catch (RemoteException ee) {
            Log.e(TAG, ""Failed to reach CardEmulationService."");
            ee.rethrowAsRuntimeException();
            return false;
        }
    }
}",1,"/**
 * Removes a registered System Code for the specified service.
 *
 * @param service The component name of the service
 * @return whether the System Code was successfully removed.
 */
","/**
 * Removes a registered System Code for the specified service.
 *
 * @param service The component name of the service
 * @return whether the System Code was successfully removed.
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The only change made between the two versions is the way the user ID is retrieved: it changed from `UserHandle.myUserId()` to `mContext.getUserId()`. This change reflects a dependent API modification, so the code change type is 5.","This modification does not constitute a compatibility issue because the behavior of unregistering a service for system code is still semantically the same. The method still returns the same values, and the exception handling logic remains unchanged. It simply alters the mechanism by which the user ID is obtained, which does not affect API consumers in a way that would lead to a compatibility issue. Therefore, the CI type is 0."
864,<android.net.TrafficStats: long getTotalRxBytes()>,27,28,<android.net.TrafficStats: long getTotalRxBytes()>,<android.net.TrafficStats: long getTotalRxBytes()>,0,"{
    return nativeGetTotalStat(TYPE_RX_BYTES);
}","{
    try {
        return getStatsService().getTotalStats(TYPE_RX_BYTES);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Return number of bytes received since device boot. Counts packets across
 * all network interfaces, and always increases monotonically since device
 * boot. Statistics are measured at the network layer, so they include both
 * TCP and UDP usage.
 * <p>
 * Before {@link android.os.Build.VERSION_CODES#JELLY_BEAN_MR2}, this may
 * return {@link #UNSUPPORTED} on devices where statistics aren't available.
 */
","/**
 * Return number of bytes received since device boot. Counts packets across
 * all network interfaces, and always increases monotonically since device
 * boot. Statistics are measured at the network layer, so they include both
 * TCP and UDP usage.
 * <p>
 * Before {@link android.os.Build.VERSION_CODES#JELLY_BEAN_MR2}, this may
 * return {@link #UNSUPPORTED} on devices where statistics aren't available.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,5","1,2","The method body has changed from a direct native call to calling getStatsService().getTotalStats() with a try-catch block to handle RemoteException, so the change types are 2 for the new exception handling and 5 for the change in the dependent API.","By changing from a direct native call to an IPC call that can throw a RemoteException, this could result in a change of the exception handling behavior as well as potentially different return values if the new IPC call behaves differently than the native one. So, the CI type is 1 for potentially returning different values and 2 for the introduction of a new possible exception thrown (rethrowFromSystemServer)."
865,<android.hardware.SensorManager: List<Sensor> getDynamicSensorList(int)>,27,28,<android.hardware.SensorManager: List<Sensor> getDynamicSensorList(int)>,<android.hardware.SensorManager: List<Sensor> getDynamicSensorList(int)>,0,"{
    // cache the returned lists the first time
    final List<Sensor> fullList = getFullDynamicSensorList();
    if (type == Sensor.TYPE_ALL) {
        return Collections.unmodifiableList(fullList);
    } else {
        List<Sensor> list = new ArrayList();
        for (Sensor i : fullList) {
            if (i.getType() == type)
                list.add(i);
        }
        return Collections.unmodifiableList(list);
    }
}","{
    // cache the returned lists the first time
    final List<Sensor> fullList = getFullDynamicSensorList();
    if (type == Sensor.TYPE_ALL) {
        return Collections.unmodifiableList(fullList);
    } else {
        List<Sensor> list = new ArrayList();
        for (Sensor i : fullList) {
            if (i.getType() == type) {
                list.add(i);
            }
        }
        return Collections.unmodifiableList(list);
    }
}",1,"/**
 * Use this method to get a list of available dynamic sensors of a certain type.
 * Make multiple calls to get sensors of different types or use
 * {@link android.hardware.Sensor#TYPE_ALL Sensor.TYPE_ALL} to get all dynamic sensors.
 *
 * <p class=""note"">
 * NOTE: Both wake-up and non wake-up sensors matching the given type are
 * returned. Check {@link Sensor#isWakeUpSensor()} to know the wake-up properties
 * of the returned {@link Sensor}.
 * </p>
 *
 * @param type of sensors requested
 *
 * @return a list of dynamic sensors matching the requested type.
 *
 * @see Sensor
 */
","/**
 * Use this method to get a list of available dynamic sensors of a certain type.
 * Make multiple calls to get sensors of different types or use
 * {@link android.hardware.Sensor#TYPE_ALL Sensor.TYPE_ALL} to get all dynamic sensors.
 *
 * <p class=""note"">
 * NOTE: Both wake-up and non wake-up sensors matching the given type are
 * returned. Check {@link Sensor#isWakeUpSensor()} to know the wake-up properties
 * of the returned {@link Sensor}.
 * </p>
 *
 * @param type of sensors requested
 *
 * @return a list of dynamic sensors matching the requested type.
 *
 * @see Sensor
 */
",-1,,,-1,-1,-1,-1,-1,-1,0,0,"The implementation between the early and late version has no functional changes, only the formatting changed by adding braces to the 'if' block within the loop.","No Compatibility Issue exists here because there are no changes in return values, exception handlings, or control flow. The modification is purely stylistic and does not affect the API's behavior."
866,"<android.provider.MediaStore.InternalThumbnails: Bitmap getThumbnail(ContentResolver,long,long,int,Options,Uri,boolean)>",27,28,"<android.provider.MediaStore.InternalThumbnails: Bitmap getThumbnail(ContentResolver,long,long,int,Options,Uri,boolean)>","<android.provider.MediaStore.InternalThumbnails: Bitmap getThumbnail(ContentResolver,long,long,int,Options,Uri,boolean)>",0,"{
    Bitmap bitmap = null;
    // Log.v(TAG, ""getThumbnail: origId=""+origId+"", kind=""+kind+"", isVideo=""+isVideo);
    // If the magic is non-zero, we simply return thumbnail if it does exist.
    // querying MediaProvider and simply return thumbnail.
    MiniThumbFile thumbFile = new MiniThumbFile(isVideo ? Video.Media.EXTERNAL_CONTENT_URI : Images.Media.EXTERNAL_CONTENT_URI);
    Cursor c = null;
    try {
        long magic = thumbFile.getMagic(origId);
        if (magic != 0) {
            if (kind == MICRO_KIND) {
                synchronized (sThumbBufLock) {
                    if (sThumbBuf == null) {
                        sThumbBuf = new byte[MiniThumbFile.BYTES_PER_MINTHUMB];
                    }
                    if (thumbFile.getMiniThumbFromFile(origId, sThumbBuf) != null) {
                        bitmap = BitmapFactory.decodeByteArray(sThumbBuf, 0, sThumbBuf.length);
                        if (bitmap == null) {
                            Log.w(TAG, ""couldn't decode byte array."");
                        }
                    }
                }
                return bitmap;
            } else if (kind == MINI_KIND) {
                String column = isVideo ? ""video_id="" : ""image_id="";
                c = cr.query(baseUri, PROJECTION, column + origId, null, null);
                if (c != null && c.moveToFirst()) {
                    bitmap = getMiniThumbFromFile(c, baseUri, cr, options);
                    if (bitmap != null) {
                        return bitmap;
                    }
                }
            }
        }
        Uri blockingUri = baseUri.buildUpon().appendQueryParameter(""blocking"", ""1"").appendQueryParameter(""orig_id"", String.valueOf(origId)).appendQueryParameter(""group_id"", String.valueOf(groupId)).build();
        if (c != null)
            c.close();
        c = cr.query(blockingUri, PROJECTION, null, null, null);
        // This happens when original image/video doesn't exist.
        if (c == null)
            return null;
        // Assuming thumbnail has been generated, at least original image exists.
        if (kind == MICRO_KIND) {
            synchronized (sThumbBufLock) {
                if (sThumbBuf == null) {
                    sThumbBuf = new byte[MiniThumbFile.BYTES_PER_MINTHUMB];
                }
                Arrays.fill(sThumbBuf, (byte) 0);
                if (thumbFile.getMiniThumbFromFile(origId, sThumbBuf) != null) {
                    bitmap = BitmapFactory.decodeByteArray(sThumbBuf, 0, sThumbBuf.length);
                    if (bitmap == null) {
                        Log.w(TAG, ""couldn't decode byte array."");
                    }
                }
            }
        } else if (kind == MINI_KIND) {
            if (c.moveToFirst()) {
                bitmap = getMiniThumbFromFile(c, baseUri, cr, options);
            }
        } else {
            throw new IllegalArgumentException(""Unsupported kind: "" + kind);
        }
        // We probably run out of space, so create the thumbnail in memory.
        if (bitmap == null) {
            Log.v(TAG, ""Create the thumbnail in memory: origId="" + origId + "", kind="" + kind + "", isVideo="" + isVideo);
            Uri uri = Uri.parse(baseUri.buildUpon().appendPath(String.valueOf(origId)).toString().replaceFirst(""thumbnails"", ""media""));
            if (c != null)
                c.close();
            c = cr.query(uri, PROJECTION, null, null, null);
            if (c == null || !c.moveToFirst()) {
                return null;
            }
            String filePath = c.getString(1);
            if (filePath != null) {
                if (isVideo) {
                    bitmap = ThumbnailUtils.createVideoThumbnail(filePath, kind);
                } else {
                    bitmap = ThumbnailUtils.createImageThumbnail(filePath, kind);
                }
            }
        }
    } catch (SQLiteException ex) {
        Log.w(TAG, ex);
    } finally {
        if (c != null)
            c.close();
        // To avoid file descriptor leak in application process.
        thumbFile.deactivate();
        thumbFile = null;
    }
    return bitmap;
}","{
    Bitmap bitmap = null;
    // Log.v(TAG, ""getThumbnail: origId=""+origId+"", kind=""+kind+"", isVideo=""+isVideo);
    // If the magic is non-zero, we simply return thumbnail if it does exist.
    // querying MediaProvider and simply return thumbnail.
    MiniThumbFile thumbFile = MiniThumbFile.instance(isVideo ? Video.Media.EXTERNAL_CONTENT_URI : Images.Media.EXTERNAL_CONTENT_URI);
    Cursor c = null;
    try {
        long magic = thumbFile.getMagic(origId);
        if (magic != 0) {
            if (kind == MICRO_KIND) {
                synchronized (sThumbBufLock) {
                    if (sThumbBuf == null) {
                        sThumbBuf = new byte[MiniThumbFile.BYTES_PER_MINTHUMB];
                    }
                    if (thumbFile.getMiniThumbFromFile(origId, sThumbBuf) != null) {
                        bitmap = BitmapFactory.decodeByteArray(sThumbBuf, 0, sThumbBuf.length);
                        if (bitmap == null) {
                            Log.w(TAG, ""couldn't decode byte array."");
                        }
                    }
                }
                return bitmap;
            } else if (kind == MINI_KIND) {
                String column = isVideo ? ""video_id="" : ""image_id="";
                c = cr.query(baseUri, PROJECTION, column + origId, null, null);
                if (c != null && c.moveToFirst()) {
                    bitmap = getMiniThumbFromFile(c, baseUri, cr, options);
                    if (bitmap != null) {
                        return bitmap;
                    }
                }
            }
        }
        Uri blockingUri = baseUri.buildUpon().appendQueryParameter(""blocking"", ""1"").appendQueryParameter(""orig_id"", String.valueOf(origId)).appendQueryParameter(""group_id"", String.valueOf(groupId)).build();
        if (c != null)
            c.close();
        c = cr.query(blockingUri, PROJECTION, null, null, null);
        // This happens when original image/video doesn't exist.
        if (c == null)
            return null;
        // Assuming thumbnail has been generated, at least original image exists.
        if (kind == MICRO_KIND) {
            synchronized (sThumbBufLock) {
                if (sThumbBuf == null) {
                    sThumbBuf = new byte[MiniThumbFile.BYTES_PER_MINTHUMB];
                }
                Arrays.fill(sThumbBuf, (byte) 0);
                if (thumbFile.getMiniThumbFromFile(origId, sThumbBuf) != null) {
                    bitmap = BitmapFactory.decodeByteArray(sThumbBuf, 0, sThumbBuf.length);
                    if (bitmap == null) {
                        Log.w(TAG, ""couldn't decode byte array."");
                    }
                }
            }
        } else if (kind == MINI_KIND) {
            if (c.moveToFirst()) {
                bitmap = getMiniThumbFromFile(c, baseUri, cr, options);
            }
        } else {
            throw new IllegalArgumentException(""Unsupported kind: "" + kind);
        }
        // We probably run out of space, so create the thumbnail in memory.
        if (bitmap == null) {
            Log.v(TAG, ""Create the thumbnail in memory: origId="" + origId + "", kind="" + kind + "", isVideo="" + isVideo);
            Uri uri = Uri.parse(baseUri.buildUpon().appendPath(String.valueOf(origId)).toString().replaceFirst(""thumbnails"", ""media""));
            if (c != null)
                c.close();
            c = cr.query(uri, PROJECTION, null, null, null);
            if (c == null || !c.moveToFirst()) {
                return null;
            }
            String filePath = c.getString(1);
            if (filePath != null) {
                if (isVideo) {
                    bitmap = ThumbnailUtils.createVideoThumbnail(filePath, kind);
                } else {
                    bitmap = ThumbnailUtils.createImageThumbnail(filePath, kind);
                }
            }
        }
    } catch (SQLiteException ex) {
        Log.w(TAG, ex);
    } finally {
        if (c != null)
            c.close();
        // To avoid file descriptor leak in application process.
        thumbFile.deactivate();
        thumbFile = null;
    }
    return bitmap;
}",1,"/**
 * This method ensure thumbnails associated with origId are generated and decode the byte
 * stream from database (MICRO_KIND) or file (MINI_KIND).
 *
 * Special optimization has been done to avoid further IPC communication for MICRO_KIND
 * thumbnails.
 *
 * @param cr ContentResolver
 * @param origId original image or video id
 * @param kind could be MINI_KIND or MICRO_KIND
 * @param options this is only used for MINI_KIND when decoding the Bitmap
 * @param baseUri the base URI of requested thumbnails
 * @param groupId the id of group to which this request belongs
 * @return Bitmap bitmap of specified thumbnail kind
 */
","/**
 * This method ensure thumbnails associated with origId are generated and decode the byte
 * stream from database (MICRO_KIND) or file (MINI_KIND).
 *
 * Special optimization has been done to avoid further IPC communication for MICRO_KIND
 * thumbnails.
 *
 * @param cr ContentResolver
 * @param origId original image or video id
 * @param kind could be MINI_KIND or MICRO_KIND
 * @param options this is only used for MINI_KIND when decoding the Bitmap
 * @param baseUri the base URI of requested thumbnails
 * @param groupId the id of group to which this request belongs
 * @return Bitmap bitmap of specified thumbnail kind
 */
",-1,,,-1,-1,-1,-1,-1,-1,,,,
868,<android.view.textclassifier.TextClassification: String toString()>,27,28,<android.view.textclassifier.TextClassification: String toString()>,<android.view.textclassifier.TextClassification: String toString()>,0,"{
    return String.format(""TextClassification {"" + ""text=%s, entities=%s, label=%s, intent=%s}"", mText, mEntityConfidence, mLabel, mIntent);
}","{
    return String.format(Locale.US, ""TextClassification {text=%s, entities=%s, actions=%s, id=%s}"", mText, mEntityConfidence, mActions, mId);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,4",1,"The return statement uses different format strings and references different class members, evidenced by the presence of mActions and mId in the late version, instead of mLabel and mIntent from the early version, so the code change type is 1,4.","The modified return statement means the method could potentially return a different string representation of the object, which directly affects the output of the API. Thus, the CI type is 1."
869,<android.net.NetworkCapabilities: boolean hasCapability(int)>,27,28,<android.net.NetworkCapabilities: boolean hasCapability(int)>,<android.net.NetworkCapabilities: boolean hasCapability(int)>,0,"{
    if (capability < MIN_NET_CAPABILITY || capability > MAX_NET_CAPABILITY) {
        return false;
    }
    return ((mNetworkCapabilities & (1 << capability)) != 0);
}","{
    return isValidCapability(capability) && ((mNetworkCapabilities & (1 << capability)) != 0);
}",1,"/**
 * Tests for the presence of a capabilitity on this instance.
 *
 * @param capability the {@code NetworkCapabilities.NET_CAPABILITY_*} to be tested for.
 * @return {@code true} if set on this instance.
 */
","/**
 * Tests for the presence of a capability on this instance.
 *
 * @param capability the capabilities to be tested for.
 * @return {@code true} if set on this instance.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3,5",0,"The code change includes replacing a direct comparison with MIN_NET_CAPABILITY and MAX_NET_CAPABILITY to using a new function isValidCapability(capability). This is a change in control dependency (type 3) and is a use of a dependent API (type 5). Also, because the previous implementation's explicit check has been replaced with a method call, the return statement has indirectly changed (type 1).","Since the new implementation seems to use isValidCapability as a straight replacement for the explicit range check present in the earlier version, the return value should remain identical, given isValidCapability(capability) is expected to return false for capabilities outside the accepted range, just as the previous explicit check did. Therefore, assuming isValidCapability is implemented correctly and consistently with the previously inlined range check, there should be no Compatibility Issue due to different return values or types (type 0)."
870,<android.app.ActivityThread.Profiler: void startProfiling()>,27,28,<android.app.ActivityThread.Profiler: void startProfiling()>,<android.app.ActivityThread.Profiler: void startProfiling()>,0,"{
    if (profileFd == null || profiling) {
        return;
    }
    try {
        int bufferSize = SystemProperties.getInt(""debug.traceview-buffer-size-mb"", 8);
        VMDebug.startMethodTracing(profileFile, profileFd.getFileDescriptor(), bufferSize * 1024 * 1024, 0, samplingInterval != 0, samplingInterval, streamingOutput);
        profiling = true;
    } catch (RuntimeException e) {
        Slog.w(TAG, ""Profiling failed on path "" + profileFile);
        try {
            profileFd.close();
            profileFd = null;
        } catch (IOException e2) {
            Slog.w(TAG, ""Failure closing profile fd"", e2);
        }
    }
}","{
    if (profileFd == null || profiling) {
        return;
    }
    try {
        int bufferSize = SystemProperties.getInt(""debug.traceview-buffer-size-mb"", 8);
        VMDebug.startMethodTracing(profileFile, profileFd.getFileDescriptor(), bufferSize * 1024 * 1024, 0, samplingInterval != 0, samplingInterval, streamingOutput);
        profiling = true;
    } catch (RuntimeException e) {
        Slog.w(TAG, ""Profiling failed on path "" + profileFile, e);
        try {
            profileFd.close();
            profileFd = null;
        } catch (IOException e2) {
            Slog.w(TAG, ""Failure closing profile fd"", e2);
        }
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,4,0,"The only change in the code is the addition of the exception instance 'e' in the log warning within the catch block. This change does not alter the control flow or the behavior of the method in terms of its output (returned values) or exceptions thrown to the caller; it merely provides more information in the log message, so the change type is 4.","Since the change only affects the logging and does not affect the method's return value or the exceptions thrown, there is no Compatibility Issue, and the CI type is 0."
871,<android.os.StrictMode.AndroidBlockGuardPolicy: void onNetwork()>,27,28,<android.os.StrictMode.AndroidBlockGuardPolicy: void onNetwork()>,<android.os.StrictMode.AndroidBlockGuardPolicy: void onNetwork()>,0,"{
    if ((mPolicyMask & DETECT_NETWORK) == 0) {
        return;
    }
    if ((mPolicyMask & PENALTY_DEATH_ON_NETWORK) != 0) {
        throw new NetworkOnMainThreadException();
    }
    if (tooManyViolationsThisLoop()) {
        return;
    }
    BlockGuard.BlockGuardPolicyException e = new StrictModeNetworkViolation(mPolicyMask);
    e.fillInStackTrace();
    startHandlingViolationException(e);
}","{
    if ((mPolicyMask & DETECT_NETWORK) == 0) {
        return;
    }
    if ((mPolicyMask & PENALTY_DEATH_ON_NETWORK) != 0) {
        throw new NetworkOnMainThreadException();
    }
    if (tooManyViolationsThisLoop()) {
        return;
    }
    startHandlingViolationException(new NetworkViolation());
}",1,"// Part of BlockGuard.Policy interface:
","// Part of BlockGuard.Policy interface:
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The changed part of the code is the instantiation of a different exception class (`StrictModeNetworkViolation` replaced with `NetworkViolation`). There is no change in the control flow or the method signature, so the code change type is 4.","Despite the change in the instantiated exception object, these adjustments do not alter the external behavior of the method because the method signature remains the same and it is still throwing an exception in the same control flow condition. Therefore, it does not cause any Compatibility Issue."
872,<android.bluetooth.BluetoothAdapter: boolean enable()>,27,28,<android.bluetooth.BluetoothAdapter: boolean enable()>,<android.bluetooth.BluetoothAdapter: boolean enable()>,0,"{
    if (isEnabled()) {
        if (DBG)
            Log.d(TAG, ""enable(): BT already enabled!"");
        return true;
    }
    try {
        return mManagerService.enable(ActivityThread.currentPackageName());
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
    }
    return false;
}","{
    if (isEnabled()) {
        if (DBG) {
            Log.d(TAG, ""enable(): BT already enabled!"");
        }
        return true;
    }
    try {
        return mManagerService.enable(ActivityThread.currentPackageName());
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
    }
    return false;
}",1,"/**
 * Turn on the local Bluetooth adapter&mdash;do not use without explicit
 * user action to turn on Bluetooth.
 * <p>This powers on the underlying Bluetooth hardware, and starts all
 * Bluetooth system services.
 * <p class=""caution""><strong>Bluetooth should never be enabled without
 * direct user consent</strong>. If you want to turn on Bluetooth in order
 * to create a wireless connection, you should use the {@link
 * #ACTION_REQUEST_ENABLE} Intent, which will raise a dialog that requests
 * user permission to turn on Bluetooth. The {@link #enable()} method is
 * provided only for applications that include a user interface for changing
 * system settings, such as a ""power manager"" app.</p>
 * <p>This is an asynchronous call: it will return immediately, and
 * clients should listen for {@link #ACTION_STATE_CHANGED}
 * to be notified of subsequent adapter state changes. If this call returns
 * true, then the adapter state will immediately transition from {@link
 * #STATE_OFF} to {@link #STATE_TURNING_ON}, and some time
 * later transition to either {@link #STATE_OFF} or {@link
 * #STATE_ON}. If this call returns false then there was an
 * immediate problem that will prevent the adapter from being turned on -
 * such as Airplane mode, or the adapter is already turned on.
 *
 * @return true to indicate adapter startup has begun, or false on
 * immediate error
 */
","/**
 * Turn on the local Bluetooth adapter&mdash;do not use without explicit
 * user action to turn on Bluetooth.
 * <p>This powers on the underlying Bluetooth hardware, and starts all
 * Bluetooth system services.
 * <p class=""caution""><strong>Bluetooth should never be enabled without
 * direct user consent</strong>. If you want to turn on Bluetooth in order
 * to create a wireless connection, you should use the {@link
 * #ACTION_REQUEST_ENABLE} Intent, which will raise a dialog that requests
 * user permission to turn on Bluetooth. The {@link #enable()} method is
 * provided only for applications that include a user interface for changing
 * system settings, such as a ""power manager"" app.</p>
 * <p>This is an asynchronous call: it will return immediately, and
 * clients should listen for {@link #ACTION_STATE_CHANGED}
 * to be notified of subsequent adapter state changes. If this call returns
 * true, then the adapter state will immediately transition from {@link
 * #STATE_OFF} to {@link #STATE_TURNING_ON}, and some time
 * later transition to either {@link #STATE_OFF} or {@link
 * #STATE_ON}. If this call returns false then there was an
 * immediate problem that will prevent the adapter from being turned on -
 * such as Airplane mode, or the adapter is already turned on.
 *
 * @return true to indicate adapter startup has begun, or false on immediate error
 */
",-1,[@RequiresPermission(Manifest.permission.BLUETOOTH_ADMIN)],[@RequiresPermission(Manifest.permission.BLUETOOTH_ADMIN)],-1,-1,-1,-1,-1,-1,0,0,There is no actual code change between the Early_Version and Late_Version; the only difference is in code style (the early version lacks braces for the if statement). The functionality and the logic remain the same.,"There is no Compatibility Issue as the logic, exceptions, return values, and dependent API calls remain unchanged."
873,<android.bluetooth.le.BluetoothLeScanner.BleScanCallbackWrapper: void onScanManagerErrorCallback(int)>,27,28,<android.bluetooth.le.BluetoothLeScanner.BleScanCallbackWrapper: void onScanManagerErrorCallback(int)>,<android.bluetooth.le.BluetoothLeScanner.BleScanCallbackWrapper: void onScanManagerErrorCallback(int)>,0,"{
    if (VDBG) {
        Log.d(TAG, ""onScanManagerErrorCallback() - errorCode = "" + errorCode);
    }
    synchronized (this) {
        if (mScannerId <= 0)
            return;
    }
    postCallbackError(mScanCallback, errorCode);
}","{
    if (VDBG) {
        Log.d(TAG, ""onScanManagerErrorCallback() - errorCode = "" + errorCode);
    }
    synchronized (this) {
        if (mScannerId <= 0) {
            return;
        }
    }
    postCallbackError(mScanCallback, errorCode);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,0,0,There is no effective code change since only the code style has been modified without altering the functionality (placement of a return statement's braces has been adjusted).,"Since there is no change in the code logic, behavior, or API usage, no compatibility issue arises."
874,"<android.content.res.AssetManager: boolean getResourceValue(int,int,TypedValue,boolean)>",27,28,"<android.content.res.AssetManager: boolean getResourceValue(int,int,TypedValue,boolean)>","<android.content.res.AssetManager: boolean getResourceValue(int,int,TypedValue,boolean)>",0,"{
    synchronized (this) {
        final int block = loadResourceValue(resId, (short) densityDpi, outValue, resolveRefs);
        if (block < 0) {
            return false;
        }
        // Convert the changing configurations flags populated by native code.
        outValue.changingConfigurations = ActivityInfo.activityInfoConfigNativeToJava(outValue.changingConfigurations);
        if (outValue.type == TypedValue.TYPE_STRING) {
            outValue.string = mStringBlocks[block].get(outValue.data);
        }
        return true;
    }
}","{
    Preconditions.checkNotNull(outValue, ""outValue"");
    synchronized (this) {
        ensureValidLocked();
        final int cookie = nativeGetResourceValue(mObject, resId, (short) densityDpi, outValue, resolveRefs);
        if (cookie <= 0) {
            return false;
        }
        // Convert the changing configurations flags populated by native code.
        outValue.changingConfigurations = ActivityInfo.activityInfoConfigNativeToJava(outValue.changingConfigurations);
        if (outValue.type == TypedValue.TYPE_STRING) {
            outValue.string = mApkAssets[cookie - 1].getStringFromPool(outValue.data);
        }
        return true;
    }
}",1,"/**
 * Populates {@code outValue} with the data associated a particular
 * resource identifier for the current configuration.
 *
 * @param resId the resource identifier to load
 * @param densityDpi the density bucket for which to load the resource
 * @param outValue the typed value in which to put the data
 * @param resolveRefs {@code true} to resolve references, {@code false}
 * to leave them unresolved
 * @return {@code true} if the data was loaded into {@code outValue},
 * {@code false} otherwise
 */
","/**
 * Populates {@code outValue} with the data associated a particular
 * resource identifier for the current configuration.
 *
 * @param resId the resource identifier to load
 * @param densityDpi the density bucket for which to load the resource
 * @param outValue the typed value in which to put the data
 * @param resolveRefs {@code true} to resolve references, {@code false}
 * to leave them unresolved
 * @return {@code true} if the data was loaded into {@code outValue},
 * {@code false} otherwise
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,3,4,5","1,2","The method introduces a new check with Preconditions.checkNotNull(outValue, ""outValue""), changes the if condition check for 'cookie', alters the way of acquiring a string from the resources with mApkAssets[cookie - 1].getStringFromPool(outValue.data) instead of mStringBlocks[block].get(outValue.data), and changes the overall behavior of how resources are accessed with nativeGetResourceValue() instead of loadResourceValue(), which affects the exception thrown and potentially the returned values. Thus, the code change types are 2,3,4,5.","The addition of Preconditions.checkNotNull(outValue, ""outValue"") introduces a new possible exception (NullPointerException) if outValue is null, which is a behavior change from the previous version. The change in condition (from loadResourceValue and block to nativeGetResourceValue and cookie) and string retrieval logic can lead to different resources being returned or different behaviors when resources are not found, which could cause both an exception handling change and different return values (or types) from the method. Therefore, the CI types are 1,2."
876,<android.bluetooth.le.AdvertisingSetParameters: boolean isConnectable()>,27,28,<android.bluetooth.le.AdvertisingSetParameters: boolean isConnectable()>,<android.bluetooth.le.AdvertisingSetParameters: boolean isConnectable()>,0,"{
    return connectable;
}","{
    return mConnectable;
}",1,"/**
 * Returns whether the advertisement will be connectable.
 */
","/**
 * Returns whether the advertisement will be connectable.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The variable name has been changed from 'connectable' to 'mConnectable', indicating a change in the internal field name, but the behavior of the method hasn't been altered, so the code change type is 4.","There is no Compatibility Issue since the return statement effectively returns the same value, despite the change in the variable's name. The change is purely internal and doesn't affect the API's contract. The name of the variable is an implementation detail, not observable by the API consumer."
877,<android.app.Activity: boolean onSearchRequested()>,27,28,<android.app.Activity: boolean onSearchRequested()>,<android.app.Activity: boolean onSearchRequested()>,0,"{
    if ((getResources().getConfiguration().uiMode & Configuration.UI_MODE_TYPE_MASK) != Configuration.UI_MODE_TYPE_TELEVISION) {
        startSearch(null, false, null, false);
        return true;
    } else {
        return false;
    }
}","{
    final int uiMode = getResources().getConfiguration().uiMode & Configuration.UI_MODE_TYPE_MASK;
    if (uiMode != Configuration.UI_MODE_TYPE_TELEVISION && uiMode != Configuration.UI_MODE_TYPE_WATCH) {
        startSearch(null, false, null, false);
        return true;
    } else {
        return false;
    }
}",1,"/**
 * @see #onSearchRequested(SearchEvent)
 */
","/**
 * @see #onSearchRequested(SearchEvent)
 */
",-1,,,-1,-1,-1,-1,-1,-1,3,1,"The control dependency of `if` statement has changed by adding a new condition `(uiMode != Configuration.UI_MODE_TYPE_WATCH)` in the Late_Implementation, so the code change type is 3.","The additional condition in the control statement could lead to the method returning a different boolean value under certain conditions (specifically, when the UI mode is of type watch), therefore a CI exists due to potential different return values. The CI type is 1."
878,<android.widget.ImageView: void setScaleType(ScaleType)>,27,28,<android.widget.ImageView: void setScaleType(ScaleType)>,<android.widget.ImageView: void setScaleType(ScaleType)>,0,"{
    if (scaleType == null) {
        throw new NullPointerException();
    }
    if (mScaleType != scaleType) {
        mScaleType = scaleType;
        setWillNotCacheDrawing(mScaleType == ScaleType.CENTER);
        requestLayout();
        invalidate();
    }
}","{
    if (scaleType == null) {
        throw new NullPointerException();
    }
    if (mScaleType != scaleType) {
        mScaleType = scaleType;
        requestLayout();
        invalidate();
    }
}",1,"/**
 * Controls how the image should be resized or moved to match the size
 * of this ImageView.
 *
 * @param scaleType The desired scaling mode.
 *
 * @attr ref android.R.styleable#ImageView_scaleType
 */
","/**
 * Controls how the image should be resized or moved to match the size
 * of this ImageView.
 *
 * @param scaleType The desired scaling mode.
 *
 * @attr ref android.R.styleable#ImageView_scaleType
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",0,"The method has removed the call to setWillNotCacheDrawing(mScaleType == ScaleType.CENTER), which is an ""other statement"" change type (4). Additionally, because the mScaleType assignment remains amidst a conditional (if) block, this also qualifies as a ""control dependency changed"" (3).","There is no Compatibility Issue as the change does not affect the return type or value, and there are no new exceptions thrown or changed exception handling. Removing the setWillNotCacheDrawing call will impact internal behavior but not the interface contract clients rely upon when calling setScaleType(ScaleType)."
879,<android.view.textclassifier.TextClassification.Builder: Builder setIntent(Intent)>,27,28,<android.view.textclassifier.TextClassification.Builder: Builder setIntent(Intent)>,<android.view.textclassifier.TextClassification.Builder: Builder setIntent(Intent)>,0,"{
    mIntent = intent;
    return this;
}","{
    mLegacyIntent = intent;
    return this;
}",1,"/**
 * Sets an intent that may be fired to act on the classified text.
 */
","/**
 * Sets the intent for the <i>primary</i> action that may be fired to act on the classified
 * text.
 *
 * <p><strong>NOTE: </strong>This field is not parcelled.
 *
 * @deprecated Use {@link #addAction(RemoteAction)} instead.
 */
",-1,,"[@Deprecated, @NonNull]",-1,-1,-1,-1,-1,-1,"4,5",0,"The field that the intent is being assigned to has changed from mIntent to mLegacyIntent. No control statements, return statements, or exception handling statements are changed. Since this is an assignment to a different field, the code change is classified as 4. Additionally, because the field name has changed, if there is a separate API that relies on the field `mIntent`, this would be a dependent API change, hence the code change also gets classified as 5.","There is no Compatibility Issue because the API method signature hasn't changed, it's just assigning the passed intent to a different field. The method still returns the `Builder` object, as before. The behavior from the API user perspective remains unchanged. The `@Deprecated` annotation only indicates that this method is no longer recommended for use, but it still works in a backward-compatible manner. The `@NonNull` annotation is also not a breaking change, as it is a marker for tools and developers to indicate that the parameter shouldn't be null, but it doesn't affect the execution flow or compatibility."
880,<android.content.res.AssetManager.AssetInputStream: int read()>,27,28,<android.content.res.AssetManager.AssetInputStream: int read()>,<android.content.res.AssetManager.AssetInputStream: int read()>,0,"{
    return readAssetChar(mAsset);
}","{
    ensureOpen();
    return nativeAssetReadChar(mAssetNativePtr);
}",1,,,-1,,[@Override],-1,-1,-1,-1,-1,-1,"4,5",1,"The implementation in the late version includes a call to ensureOpen(), and has replaced readAssetChar(mAsset) with nativeAssetReadChar(mAssetNativePtr). The changes include the addition of a new method call and the modification of the method that's being used to read a character. Therefore, the code change type is 4,5.","The new method call to ensureOpen() and change to nativeAssetReadChar could potentially lead to a different return value if ensureOpen() alters the state of the AssetInputStream in a way that affects the outcome of the read operation. Moreover, changing the method used to perform the read operation can lead to a different behavior, especially if there are differences in the implementation between readAssetChar and nativeAssetReadChar. Thus, the CI type is 1."
881,"<android.text.StaticLayout.Builder: Builder obtain(CharSequence,int,int,TextPaint,int)>",27,28,"<android.text.StaticLayout.Builder: Builder obtain(CharSequence,int,int,TextPaint,int)>","<android.text.StaticLayout.Builder: Builder obtain(CharSequence,int,int,TextPaint,int)>",0,"{
    Builder b = sPool.acquire();
    if (b == null) {
        b = new Builder();
    }
    // set default initial values
    b.mText = source;
    b.mStart = start;
    b.mEnd = end;
    b.mPaint = paint;
    b.mWidth = width;
    b.mAlignment = Alignment.ALIGN_NORMAL;
    b.mTextDir = TextDirectionHeuristics.FIRSTSTRONG_LTR;
    b.mSpacingMult = 1.0f;
    b.mSpacingAdd = 0.0f;
    b.mIncludePad = true;
    b.mEllipsizedWidth = width;
    b.mEllipsize = null;
    b.mMaxLines = Integer.MAX_VALUE;
    b.mBreakStrategy = Layout.BREAK_STRATEGY_SIMPLE;
    b.mHyphenationFrequency = Layout.HYPHENATION_FREQUENCY_NONE;
    b.mJustificationMode = Layout.JUSTIFICATION_MODE_NONE;
    b.mMeasuredText = MeasuredText.obtain();
    return b;
}","{
    Builder b = sPool.acquire();
    if (b == null) {
        b = new Builder();
    }
    // set default initial values
    b.mText = source;
    b.mStart = start;
    b.mEnd = end;
    b.mPaint = paint;
    b.mWidth = width;
    b.mAlignment = Alignment.ALIGN_NORMAL;
    b.mTextDir = TextDirectionHeuristics.FIRSTSTRONG_LTR;
    b.mSpacingMult = DEFAULT_LINESPACING_MULTIPLIER;
    b.mSpacingAdd = DEFAULT_LINESPACING_ADDITION;
    b.mIncludePad = true;
    b.mFallbackLineSpacing = false;
    b.mEllipsizedWidth = width;
    b.mEllipsize = null;
    b.mMaxLines = Integer.MAX_VALUE;
    b.mBreakStrategy = Layout.BREAK_STRATEGY_SIMPLE;
    b.mHyphenationFrequency = Layout.HYPHENATION_FREQUENCY_NONE;
    b.mJustificationMode = Layout.JUSTIFICATION_MODE_NONE;
    return b;
}",1,"/**
 * Obtain a builder for constructing StaticLayout objects
 *
 * @param source The text to be laid out, optionally with spans
 * @param start The index of the start of the text
 * @param end The index + 1 of the end of the text
 * @param paint The base paint used for layout
 * @param width The width in pixels
 * @return a builder object used for constructing the StaticLayout
 */
","/**
 * Obtain a builder for constructing StaticLayout objects.
 *
 * @param source The text to be laid out, optionally with spans
 * @param start The index of the start of the text
 * @param end The index + 1 of the end of the text
 * @param paint The base paint used for layout
 * @param width The width in pixels
 * @return a builder object used for constructing the StaticLayout
 */
",-1,,[@NonNull],-1,-1,-1,-1,-1,-1,"3,4",0,"The late version contains changes to the default values for 'b.mSpacingMult' and 'b.mSpacingAdd', replacing them with 'DEFAULT_LINESPACING_MULTIPLIER' and 'DEFAULT_LINESPACING_ADDITION' respectively. Additionally, a new field 'b.mFallbackLineSpacing' has been initialized to 'false', and the statement 'b.mMeasuredText = MeasuredText.obtain();' has been removed. Therefore, the code change types are 3 (since the initialization block is implicitly considered as part of the constructor's control flow) and 4.","There is no Compatibility Issue since the constructor simply modifies internal state without altering return types, values, or introducing new exceptions; it sets up the Builder object with different default values which are expected to not affect users that explicitly set the values they care about. The removed initialization of 'b.mMeasuredText' does not directly affect the method's output, as it's an internal state change that's not part of the returned object's contract. The addition of 'b.mFallbackLineSpacing' is similarly an internal state change that doesn't alter external behavior unless acted upon by new or existing methods that aren't part of this context. The annotations have changed, but they don't cause a compatibility issue for the return type of this method as they're non-functional and pertain to static checking rather than runtime behavior."
882,<android.view.textclassifier.TextSelection: int getEntityCount()>,27,28,<android.view.textclassifier.TextSelection: int getEntityCount()>,<android.view.textclassifier.TextSelection: int getEntityCount()>,0,"{
    return mEntities.size();
}","{
    return mEntityConfidence.getEntities().size();
}",1,"/**
 * Returns the number of entities found in the classified text.
 */
","/**
 * Returns the number of entities found in the classified text.
 */
",-1,[@IntRange(from = 0)],[@IntRange(from = 0)],-1,-1,-1,-1,-1,-1,"4,5",0,"The implementation of the method to obtain the size has changed from direct access through mEntities.size() to indirect access via mEntityConfidence.getEntities().size(), this is a change in the dependent API, therefore the change type is 4,5.","No new return statements are introduced, no exception handling is involved, and despite the implementation details changing, the method's overall contract and behaviour (returning the size of a collection) remain consistent between versions. Thus, there is no compatibility issue in terms of changing return values or exception handling. The CI type is 0."
883,"<android.widget.TextView: boolean onKeyUp(int,KeyEvent)>",27,28,"<android.widget.TextView: boolean onKeyUp(int,KeyEvent)>","<android.widget.TextView: boolean onKeyUp(int,KeyEvent)>",0,"{
    if (!isEnabled()) {
        return super.onKeyUp(keyCode, event);
    }
    if (!KeyEvent.isModifierKey(keyCode)) {
        mPreventDefaultMovement = false;
    }
    switch(keyCode) {
        case KeyEvent.KEYCODE_DPAD_CENTER:
            if (event.hasNoModifiers()) {
                /*
                     * If there is a click listener, just call through to
                     * super, which will invoke it.
                     *
                     * If there isn't a click listener, try to show the soft
                     * input method.  (It will also
                     * call performClick(), but that won't do anything in
                     * this case.)
                     */
                if (!hasOnClickListeners()) {
                    if (mMovement != null && mText instanceof Editable && mLayout != null && onCheckIsTextEditor()) {
                        InputMethodManager imm = InputMethodManager.peekInstance();
                        viewClicked(imm);
                        if (imm != null && getShowSoftInputOnFocus()) {
                            imm.showSoftInput(this, 0);
                        }
                    }
                }
            }
            return super.onKeyUp(keyCode, event);
        case KeyEvent.KEYCODE_ENTER:
            if (event.hasNoModifiers()) {
                if (mEditor != null && mEditor.mInputContentType != null && mEditor.mInputContentType.onEditorActionListener != null && mEditor.mInputContentType.enterDown) {
                    mEditor.mInputContentType.enterDown = false;
                    if (mEditor.mInputContentType.onEditorActionListener.onEditorAction(this, EditorInfo.IME_NULL, event)) {
                        return true;
                    }
                }
                if ((event.getFlags() & KeyEvent.FLAG_EDITOR_ACTION) != 0 || shouldAdvanceFocusOnEnter()) {
                    /*
                         * If there is a click listener, just call through to
                         * super, which will invoke it.
                         *
                         * If there isn't a click listener, try to advance focus,
                         * but still call through to super, which will reset the
                         * pressed state and longpress state.  (It will also
                         * call performClick(), but that won't do anything in
                         * this case.)
                         */
                    if (!hasOnClickListeners()) {
                        View v = focusSearch(FOCUS_DOWN);
                        if (v != null) {
                            if (!v.requestFocus(FOCUS_DOWN)) {
                                throw new IllegalStateException(""focus search returned a view "" + ""that wasn't able to take focus!"");
                            }
                            /*
                                 * Return true because we handled the key; super
                                 * will return false because there was no click
                                 * listener.
                                 */
                            super.onKeyUp(keyCode, event);
                            return true;
                        } else if ((event.getFlags() & KeyEvent.FLAG_EDITOR_ACTION) != 0) {
                            // No target for next focus, but make sure the IME
                            // if this came from it.
                            InputMethodManager imm = InputMethodManager.peekInstance();
                            if (imm != null && imm.isActive(this)) {
                                imm.hideSoftInputFromWindow(getWindowToken(), 0);
                            }
                        }
                    }
                }
                return super.onKeyUp(keyCode, event);
            }
            break;
    }
    if (mEditor != null && mEditor.mKeyListener != null) {
        if (mEditor.mKeyListener.onKeyUp(this, (Editable) mText, keyCode, event)) {
            return true;
        }
    }
    if (mMovement != null && mLayout != null) {
        if (mMovement.onKeyUp(this, (Spannable) mText, keyCode, event)) {
            return true;
        }
    }
    return super.onKeyUp(keyCode, event);
}","{
    if (!isEnabled()) {
        return super.onKeyUp(keyCode, event);
    }
    if (!KeyEvent.isModifierKey(keyCode)) {
        mPreventDefaultMovement = false;
    }
    switch(keyCode) {
        case KeyEvent.KEYCODE_DPAD_CENTER:
            if (event.hasNoModifiers()) {
                /*
                     * If there is a click listener, just call through to
                     * super, which will invoke it.
                     *
                     * If there isn't a click listener, try to show the soft
                     * input method.  (It will also
                     * call performClick(), but that won't do anything in
                     * this case.)
                     */
                if (!hasOnClickListeners()) {
                    if (mMovement != null && mText instanceof Editable && mLayout != null && onCheckIsTextEditor()) {
                        InputMethodManager imm = InputMethodManager.peekInstance();
                        viewClicked(imm);
                        if (imm != null && getShowSoftInputOnFocus()) {
                            imm.showSoftInput(this, 0);
                        }
                    }
                }
            }
            return super.onKeyUp(keyCode, event);
        case KeyEvent.KEYCODE_ENTER:
            if (event.hasNoModifiers()) {
                if (mEditor != null && mEditor.mInputContentType != null && mEditor.mInputContentType.onEditorActionListener != null && mEditor.mInputContentType.enterDown) {
                    mEditor.mInputContentType.enterDown = false;
                    if (mEditor.mInputContentType.onEditorActionListener.onEditorAction(this, EditorInfo.IME_NULL, event)) {
                        return true;
                    }
                }
                if ((event.getFlags() & KeyEvent.FLAG_EDITOR_ACTION) != 0 || shouldAdvanceFocusOnEnter()) {
                    /*
                         * If there is a click listener, just call through to
                         * super, which will invoke it.
                         *
                         * If there isn't a click listener, try to advance focus,
                         * but still call through to super, which will reset the
                         * pressed state and longpress state.  (It will also
                         * call performClick(), but that won't do anything in
                         * this case.)
                         */
                    if (!hasOnClickListeners()) {
                        View v = focusSearch(FOCUS_DOWN);
                        if (v != null) {
                            if (!v.requestFocus(FOCUS_DOWN)) {
                                throw new IllegalStateException(""focus search returned a view "" + ""that wasn't able to take focus!"");
                            }
                            /*
                                 * Return true because we handled the key; super
                                 * will return false because there was no click
                                 * listener.
                                 */
                            super.onKeyUp(keyCode, event);
                            return true;
                        } else if ((event.getFlags() & KeyEvent.FLAG_EDITOR_ACTION) != 0) {
                            // No target for next focus, but make sure the IME
                            // if this came from it.
                            InputMethodManager imm = InputMethodManager.peekInstance();
                            if (imm != null && imm.isActive(this)) {
                                imm.hideSoftInputFromWindow(getWindowToken(), 0);
                            }
                        }
                    }
                }
                return super.onKeyUp(keyCode, event);
            }
            break;
    }
    if (mEditor != null && mEditor.mKeyListener != null) {
        if (mEditor.mKeyListener.onKeyUp(this, (Editable) mText, keyCode, event)) {
            return true;
        }
    }
    if (mMovement != null && mLayout != null) {
        if (mMovement.onKeyUp(this, mSpannable, keyCode, event)) {
            return true;
        }
    }
    return super.onKeyUp(keyCode, event);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,,,,
885,<android.bluetooth.BluetoothDevice: boolean isBluetoothEnabled()>,27,28,<android.bluetooth.BluetoothDevice: boolean isBluetoothEnabled()>,<android.bluetooth.BluetoothDevice: boolean isBluetoothEnabled()>,0,"{
    boolean ret = false;
    BluetoothAdapter adapter = BluetoothAdapter.getDefaultAdapter();
    if (adapter != null && adapter.isEnabled() == true) {
        ret = true;
    }
    return ret;
}","{
    boolean ret = false;
    BluetoothAdapter adapter = BluetoothAdapter.getDefaultAdapter();
    if (adapter != null && adapter.isEnabled()) {
        ret = true;
    }
    return ret;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,0,0,"The implementation has not changed in a way that would affect the behavior of the API. The check for `adapter.isEnabled() == true` has been changed to just `adapter.isEnabled()`, but these two expressions are logically equivalent in Java.",There is no Compatibility Issue since the behavior of the API would be the same. The change does not impact the return value or the way exceptions are thrown.
886,"<android.content.res.TypedArray: int getDimensionPixelOffset(int,int)>",27,28,"<android.content.res.TypedArray: int getDimensionPixelOffset(int,int)>","<android.content.res.TypedArray: int getDimensionPixelOffset(int,int)>",0,"{
    if (mRecycled) {
        throw new RuntimeException(""Cannot make calls to a recycled instance!"");
    }
    final int attrIndex = index;
    index *= AssetManager.STYLE_NUM_ENTRIES;
    final int[] data = mData;
    final int type = data[index + AssetManager.STYLE_TYPE];
    if (type == TypedValue.TYPE_NULL) {
        return defValue;
    } else if (type == TypedValue.TYPE_DIMENSION) {
        return TypedValue.complexToDimensionPixelOffset(data[index + AssetManager.STYLE_DATA], mMetrics);
    } else if (type == TypedValue.TYPE_ATTRIBUTE) {
        final TypedValue value = mValue;
        getValueAt(index, value);
        throw new UnsupportedOperationException(""Failed to resolve attribute at index "" + attrIndex + "": "" + value);
    }
    throw new UnsupportedOperationException(""Can't convert value at index "" + attrIndex + "" to dimension: type=0x"" + Integer.toHexString(type));
}","{
    if (mRecycled) {
        throw new RuntimeException(""Cannot make calls to a recycled instance!"");
    }
    final int attrIndex = index;
    index *= STYLE_NUM_ENTRIES;
    final int[] data = mData;
    final int type = data[index + STYLE_TYPE];
    if (type == TypedValue.TYPE_NULL) {
        return defValue;
    } else if (type == TypedValue.TYPE_DIMENSION) {
        return TypedValue.complexToDimensionPixelOffset(data[index + STYLE_DATA], mMetrics);
    } else if (type == TypedValue.TYPE_ATTRIBUTE) {
        final TypedValue value = mValue;
        getValueAt(index, value);
        throw new UnsupportedOperationException(""Failed to resolve attribute at index "" + attrIndex + "": "" + value);
    }
    throw new UnsupportedOperationException(""Can't convert value at index "" + attrIndex + "" to dimension: type=0x"" + Integer.toHexString(type));
}",1,"/**
 * Retrieve a dimensional unit attribute at <var>index</var> for use
 * as an offset in raw pixels.  This is the same as
 * {@link #getDimension}, except the returned value is converted to
 * integer pixels for you.  An offset conversion involves simply
 * truncating the base value to an integer.
 * <p>
 * This method will throw an exception if the attribute is defined but is
 * not a dimension.
 *
 * @param index Index of attribute to retrieve.
 * @param defValue Value to return if the attribute is not defined or
 * not a resource.
 *
 * @return Attribute dimension value multiplied by the appropriate
 * metric and truncated to integer pixels, or defValue if not defined.
 * @throws RuntimeException if the TypedArray has already been recycled.
 * @throws UnsupportedOperationException if the attribute is defined but is
 * not an integer.
 *
 * @see #getDimension
 * @see #getDimensionPixelSize
 */
","/**
 * Retrieve a dimensional unit attribute at <var>index</var> for use
 * as an offset in raw pixels.  This is the same as
 * {@link #getDimension}, except the returned value is converted to
 * integer pixels for you.  An offset conversion involves simply
 * truncating the base value to an integer.
 * <p>
 * This method will throw an exception if the attribute is defined but is
 * not a dimension.
 *
 * @param index Index of attribute to retrieve.
 * @param defValue Value to return if the attribute is not defined or
 * not a resource.
 *
 * @return Attribute dimension value multiplied by the appropriate
 * metric and truncated to integer pixels, or defValue if not defined.
 * @throws RuntimeException if the TypedArray has already been recycled.
 * @throws UnsupportedOperationException if the attribute is defined but is
 * not an integer.
 *
 * @see #getDimension
 * @see #getDimensionPixelSize
 */
",-1,,,-1,-1,-1,-1,-1,-1,0,0,"The method body hasn't been changed except for the removal of the AssetManager class qualifier from the constants STYLE_NUM_ENTRIES, STYLE_TYPE, and STYLE_DATA. These constants are being accessed without specifying the class name in the later version. This implies that the constants are still available in the scope of this method, and their values are assumed to be unchanged. There are no semantic changes to the code.","There is no Compatibility Issue because there's no difference in how the method behaves: no change in return values, control flow, or exception handling between the two versions."
887,"<android.content.res.AssetManager.AssetInputStream: int read(byte[],int,int)>",27,28,"<android.content.res.AssetManager.AssetInputStream: int read(byte[],int,int)>","<android.content.res.AssetManager.AssetInputStream: int read(byte[],int,int)>",0,"{
    return readAsset(mAsset, b, off, len);
}","{
    ensureOpen();
    Preconditions.checkNotNull(b, ""b"");
    return nativeAssetRead(mAssetNativePtr, b, off, len);
}",1,,,-1,,[@Override],-1,-1,-1,-1,-1,-1,"3,4,5",0,"The late version adds an 'ensureOpen()' statement and replaces 'readAsset(mAsset, b, off, len)' with 'nativeAssetRead(mAssetNativePtr, b, off, len)'. It also adds a check for the byte array 'b' being non-null. This means that there has been a control dependency change due to the addition of a validation step (ensureOpen and checkNotNull), a change in the method call from readAsset to nativeAssetRead, and an argument change from mAsset to mAssetNativePtr. The code change type is 3,4,5.","Despite the changes, the method is designed to read bytes into the array 'b', and the core behavior of reading data from an asset into a byte array has not changed. The method's signature is the same, and while the inner implementation has alterations, they do not inherently cause the method to return a different variable type or value under the same conditions or change the exceptions it throws. The Preconditions.checkNotNull(b, ""b"") adds a check that will throw a NullPointerException if 'b' is null, which matches the behavior expected by Java's standard read method contract that would also throw a NullPointerException if the buffer array is null. No Compatibility Issue is detected since the changes do not alter the logical outcome of the method execution in terms of the data read into the buffer 'b', assuming the byte array passed is non-null and the stream is open."
889,"<android.content.ContentResolver: void removePeriodicSync(Account,String,Bundle)>",27,28,"<android.content.ContentResolver: void removePeriodicSync(Account,String,Bundle)>","<android.content.ContentResolver: void removePeriodicSync(Account,String,Bundle)>",0,"{
    validateSyncExtrasBundle(extras);
    try {
        getContentService().removePeriodicSync(account, authority, extras);
    } catch (RemoteException e) {
        throw new RuntimeException(""the ContentService should always be reachable"", e);
    }
}","{
    validateSyncExtrasBundle(extras);
    try {
        getContentService().removePeriodicSync(account, authority, extras);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Remove a periodic sync. Has no affect if account, authority and extras don't match
 * an existing periodic sync.
 * <p>This method requires the caller to hold the permission
 * {@link android.Manifest.permission#WRITE_SYNC_SETTINGS}.
 *
 * @param account the account of the periodic sync to remove
 * @param authority the provider of the periodic sync to remove
 * @param extras the extras of the periodic sync to remove
 */
","/**
 * Remove a periodic sync. Has no affect if account, authority and extras don't match
 * an existing periodic sync.
 * <p>This method requires the caller to hold the permission
 * {@link android.Manifest.permission#WRITE_SYNC_SETTINGS}.
 *
 * @param account the account of the periodic sync to remove
 * @param authority the provider of the periodic sync to remove
 * @param extras the extras of the periodic sync to remove
 */
",-1,,,-1,-1,-1,-1,-1,-1,2,2,"The exception handling statement has changed. The previous code throws a custom RuntimeException, while the new code uses the rethrowFromSystemServer method to throw the exception, so the change type is 2.","The exception that is being thrown has changed from a custom RuntimeException to the exception generated by rethrowFromSystemServer, which could potentially alter the exception received by the caller. Therefore, this is a compatibility issue of type 2."
891,<android.view.View: boolean setAlphaNoInvalidation(float)>,27,28,<android.view.View: boolean setAlphaNoInvalidation(float)>,<android.view.View: boolean setAlphaNoInvalidation(float)>,0,"{
    ensureTransformationInfo();
    if (mTransformationInfo.mAlpha != alpha) {
        mTransformationInfo.mAlpha = alpha;
        boolean subclassHandlesAlpha = onSetAlpha((int) (alpha * 255));
        if (subclassHandlesAlpha) {
            mPrivateFlags |= PFLAG_ALPHA_SET;
            return true;
        } else {
            mPrivateFlags &= ~PFLAG_ALPHA_SET;
            mRenderNode.setAlpha(getFinalAlpha());
        }
    }
    return false;
}","{
    ensureTransformationInfo();
    if (mTransformationInfo.mAlpha != alpha) {
        setAlphaInternal(alpha);
        boolean subclassHandlesAlpha = onSetAlpha((int) (alpha * 255));
        if (subclassHandlesAlpha) {
            mPrivateFlags |= PFLAG_ALPHA_SET;
            return true;
        } else {
            mPrivateFlags &= ~PFLAG_ALPHA_SET;
            mRenderNode.setAlpha(getFinalAlpha());
        }
    }
    return false;
}",1,"/**
 * Faster version of setAlpha() which performs the same steps except there are
 * no calls to invalidate(). The caller of this function should perform proper invalidation
 * on the parent and this object. The return value indicates whether the subclass handles
 * alpha (the return value for onSetAlpha()).
 *
 * @param alpha The new value for the alpha property
 * @return true if the View subclass handles alpha (the return value for onSetAlpha()) and
 * the new value for the alpha property is different from the old value
 */
","/**
 * Faster version of setAlpha() which performs the same steps except there are
 * no calls to invalidate(). The caller of this function should perform proper invalidation
 * on the parent and this object. The return value indicates whether the subclass handles
 * alpha (the return value for onSetAlpha()).
 *
 * @param alpha The new value for the alpha property
 * @return true if the View subclass handles alpha (the return value for onSetAlpha()) and
 * the new value for the alpha property is different from the old value
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,The statement  `mTransformationInfo.mAlpha = alpha` has been replaced with a method call `setAlphaInternal(alpha)`. This is a change to a different statement (4) and also a dependent API change (5) because `setAlphaInternal()` is a method which may contain different implementation details.,"Although a method call has been introduced to replace a direct assignment, assuming `setAlphaInternal(alpha)` is implemented to have the same effect as the direct assignment it replaces, this should not lead to a Compatibility Issue. The return values and potential exceptions thrown remain the same, as the logic and the checks in the method have not been altered. Therefore, no Compatibility Issue is detected (0)."
892,<android.os.WorkSource: boolean add(WorkSource)>,27,28,<android.os.WorkSource: boolean add(WorkSource)>,<android.os.WorkSource: boolean add(WorkSource)>,0,"{
    synchronized (sTmpWorkSource) {
        return updateLocked(other, false, false);
    }
}","{
    synchronized (sTmpWorkSource) {
        boolean uidAdded = updateLocked(other, false, false);
        boolean chainAdded = false;
        if (other.mChains != null) {
            // is large. We could look into optimizing it if it proves problematic.
            if (mChains == null) {
                mChains = new ArrayList<>(other.mChains.size());
            }
            for (WorkChain wc : other.mChains) {
                if (!mChains.contains(wc)) {
                    mChains.add(new WorkChain(wc));
                }
            }
        }
        return uidAdded || chainAdded;
    }
}",1,"/**
 * Merge the contents of <var>other</var> WorkSource in to this one.
 *
 * @param other The other WorkSource whose contents are to be merged.
 * @return Returns true if any new sources were added.
 */
","/**
 * Merge the contents of <var>other</var> WorkSource in to this one.
 *
 * @param other The other WorkSource whose contents are to be merged.
 * @return Returns true if any new sources were added.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3,4",1,"The method's late implementation adds new variables, additional conditions, a new loop, and an altered return statement combining the results of both uid addition and chain addition. Therefore, the changes include an altered return statement, changed control dependency due to the added loop and if statement, and other statement changes with the addition of variable declarations and the algorithm for adding WorkChains. The code change type is 1,3,4.","The API's behavior may change because the late version considers the addition of both UIDs and WorkChain objects as part of the return value, while the early version only reports on UIDs. This change in the return value calculation logic implies that the API can return different results than before, thus causing a Compatibility Issue. The CI type is 1."
894,"<android.view.textclassifier.logging.SmartSelectionEventTracker.SelectionEvent: SelectionEvent selectionAction(int,int,int,TextClassification)>",27,28,"<android.view.textclassifier.logging.SmartSelectionEventTracker.SelectionEvent: SelectionEvent selectionAction(int,int,int,TextClassification)>","<android.view.textclassifier.logging.SmartSelectionEventTracker.SelectionEvent: SelectionEvent selectionAction(int,int,int,TextClassification)>",0,"{
    final String entityType = classification.getEntityCount() > 0 ? classification.getEntity(0) : TextClassifier.TYPE_UNKNOWN;
    final String versionTag = classification.getVersionInfo();
    return new SelectionEvent(start, end, actionType, entityType, versionTag);
}","{
    final String entityType = classification.getEntityCount() > 0 ? classification.getEntity(0) : TextClassifier.TYPE_UNKNOWN;
    final String versionTag = getVersionInfo(classification.getId());
    return new SelectionEvent(start, end, actionType, entityType, versionTag);
}",1,"/**
 * Creates an event specifying an action taken on a selection.
 * Use when the user clicks on an action to act on the selected text and the selection's
 * entity type is known.
 *
 * @param start  the start word (inclusive) index of the selection
 * @param end  the end word (exclusive) index of the selection
 * @param actionType  the action that was performed on the selection
 * @param classification  the TextClassification object returned by the TextClassifier that
 * classified the selected text
 */
","/**
 * Creates an event specifying an action taken on a selection.
 * Use when the user clicks on an action to act on the selected text and the selection's
 * entity type is known.
 *
 * @param start  the start word (inclusive) index of the selection
 * @param end  the end word (exclusive) index of the selection
 * @param actionType  the action that was performed on the selection
 * @param classification  the TextClassification object returned by the TextClassifier that
 * classified the selected text
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"The method getVersionInfo() is now called instead of directly accessing classification.getVersionInfo(), indicating a change in how the version tag is retrieved, which is type 4. This also involves a change in the dependent API (classification.getVersionInfo() to getVersionInfo()), so it is type 5.","Because the code change only affects how the version tag is obtained, and there's no indication of a semantic difference in what getVersionInfo() would return compared to classification.getVersionInfo(), there's no direct evidence of a change that could return a different value or type; nor is there change in exception handling. Therefore, there is no Compatibility Issue detected, which is type 0."
895,<android.bluetooth.BluetoothAdapter: boolean isOffloadedFilteringSupported()>,27,28,<android.bluetooth.BluetoothAdapter: boolean isOffloadedFilteringSupported()>,<android.bluetooth.BluetoothAdapter: boolean isOffloadedFilteringSupported()>,0,"{
    if (!getLeAccess())
        return false;
    try {
        mServiceLock.readLock().lock();
        if (mService != null)
            return mService.isOffloadedFilteringSupported();
    } catch (RemoteException e) {
        Log.e(TAG, ""failed to get isOffloadedFilteringSupported, error: "", e);
    } finally {
        mServiceLock.readLock().unlock();
    }
    return false;
}","{
    if (!getLeAccess()) {
        return false;
    }
    try {
        mServiceLock.readLock().lock();
        if (mService != null) {
            return mService.isOffloadedFilteringSupported();
        }
    } catch (RemoteException e) {
        Log.e(TAG, ""failed to get isOffloadedFilteringSupported, error: "", e);
    } finally {
        mServiceLock.readLock().unlock();
    }
    return false;
}",1,"/**
 * Return true if offloaded filters are supported
 *
 * @return true if chipset supports on-chip filtering
 */
","/**
 * Return true if offloaded filters are supported
 *
 * @return true if chipset supports on-chip filtering
 */
",-1,,,-1,-1,-1,-1,-1,-1,0,0,"The early and late versions of the implementation are effectively identical, with the only changes being the formatting of the if statements (adding braces). The braces do not alter the functionality of the code.","There is no Compatibility Issue since the actual code execution path remains unchanged; there is only a difference in code style, which does not affect API behavior."
896,<android.service.autofill.FillResponse.Builder: Builder setSaveInfo(SaveInfo)>,27,28,<android.service.autofill.FillResponse.Builder: Builder setSaveInfo(SaveInfo)>,<android.service.autofill.FillResponse.Builder: Builder setSaveInfo(SaveInfo)>,0,"{
    throwIfDestroyed();
    mSaveInfo = saveInfo;
    return this;
}","{
    throwIfDestroyed();
    throwIfDisableAutofillCalled();
    mSaveInfo = saveInfo;
    return this;
}",1,"/**
 * Sets the {@link SaveInfo} associated with this response.
 *
 * @return This builder.
 */
","/**
 * Sets the {@link SaveInfo} associated with this response.
 *
 * @return This builder.
 */
",-1,[@NonNull],[@NonNull],-1,-1,-1,-1,-1,-1,4,2,"The late version of the implementation introduces a new exception check 'throwIfDisableAutofillCalled();', which is an additional operation that doesn't change the return or control flow (assuming the function executes without an exception being thrown), so the change type is 4.","The additional exception check introduces a new circumstance in which an exception may be thrown (if the autofill has been disabled), which was not present in the early version. This means that there's a CI due to potential different exception handlings, hence the CI type is 2."
898,<android.view.accessibility.AccessibilityWindowInfo: String toString()>,27,28,<android.view.accessibility.AccessibilityWindowInfo: String toString()>,<android.view.accessibility.AccessibilityWindowInfo: String toString()>,0,"{
    StringBuilder builder = new StringBuilder();
    builder.append(""AccessibilityWindowInfo["");
    builder.append(""title="").append(mTitle);
    builder.append(""id="").append(mId);
    builder.append("", type="").append(typeToString(mType));
    builder.append("", layer="").append(mLayer);
    builder.append("", bounds="").append(mBoundsInScreen);
    builder.append("", focused="").append(isFocused());
    builder.append("", active="").append(isActive());
    builder.append("", pictureInPicture="").append(inPictureInPicture());
    if (DEBUG) {
        builder.append("", parent="").append(mParentId);
        builder.append("", children=["");
        if (mChildIds != null) {
            final int childCount = mChildIds.size();
            for (int i = 0; i < childCount; i++) {
                builder.append(mChildIds.get(i));
                if (i < childCount - 1) {
                    builder.append(',');
                }
            }
        } else {
            builder.append(""null"");
        }
        builder.append(']');
    } else {
        builder.append("", hasParent="").append(mParentId != UNDEFINED_WINDOW_ID);
        builder.append("", isAnchored="").append(mAnchorId != UNDEFINED_WINDOW_ID);
        builder.append("", hasChildren="").append(mChildIds != null && mChildIds.size() > 0);
    }
    builder.append(']');
    return builder.toString();
}","{
    StringBuilder builder = new StringBuilder();
    builder.append(""AccessibilityWindowInfo["");
    builder.append(""title="").append(mTitle);
    builder.append("", id="").append(mId);
    builder.append("", type="").append(typeToString(mType));
    builder.append("", layer="").append(mLayer);
    builder.append("", bounds="").append(mBoundsInScreen);
    builder.append("", focused="").append(isFocused());
    builder.append("", active="").append(isActive());
    builder.append("", pictureInPicture="").append(isInPictureInPictureMode());
    if (DEBUG) {
        builder.append("", parent="").append(mParentId);
        builder.append("", children=["");
        if (mChildIds != null) {
            final int childCount = mChildIds.size();
            for (int i = 0; i < childCount; i++) {
                builder.append(mChildIds.get(i));
                if (i < childCount - 1) {
                    builder.append(',');
                }
            }
        } else {
            builder.append(""null"");
        }
        builder.append(']');
    } else {
        builder.append("", hasParent="").append(mParentId != UNDEFINED_WINDOW_ID);
        builder.append("", isAnchored="").append(mAnchorId != AccessibilityNodeInfo.UNDEFINED_NODE_ID);
        builder.append("", hasChildren="").append(mChildIds != null && mChildIds.size() > 0);
    }
    builder.append(']');
    return builder.toString();
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"4,5",1,The method implementation has a couple of changes:,- The constant `UNDEFINED_WINDOW_ID` has been replaced with `AccessibilityNodeInfo.UNDEFINED_NODE_ID` when checking `isAnchored`.
899,<android.app.KeyguardManager: boolean isDeviceLocked()>,27,28,<android.app.KeyguardManager: boolean isDeviceLocked()>,<android.app.KeyguardManager: boolean isDeviceLocked()>,0,"{
    return isDeviceLocked(UserHandle.myUserId());
}","{
    return isDeviceLocked(mContext.getUserId());
}",1,"/**
 * Returns whether the device is currently locked and requires a PIN, pattern or
 * password to unlock.
 *
 * @return true if unlocking the device currently requires a PIN, pattern or
 * password.
 */
","/**
 * Returns whether the device is currently locked and requires a PIN, pattern or
 * password to unlock.
 *
 * @return true if unlocking the device currently requires a PIN, pattern or
 * password.
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The code change is located in the argument of the method isDeviceLocked(), where it has changed from calling UserHandle.myUserId() to mContext.getUserId(). Hence, the code change type is 5 (Dependent API changed).","There's no direct evidence that the behavior of mContext.getUserId() diverges from that of UserHandle.myUserId(). Unless the context's getUserId is implemented differently, which we can't determine from the provided code, we cannot conclusively say that there is a CI. Assuming they're meant to return the same user ID under the same conditions, there should be no Compatibility Issue, therefore the CI type is 0."
902,<android.hardware.Camera.EventHandler: void handleMessage(Message)>,27,28,<android.hardware.Camera.EventHandler: void handleMessage(Message)>,<android.hardware.Camera.EventHandler: void handleMessage(Message)>,0,"{
    switch(msg.what) {
        case CAMERA_MSG_SHUTTER:
            if (mShutterCallback != null) {
                mShutterCallback.onShutter();
            }
            return;
        case CAMERA_MSG_RAW_IMAGE:
            if (mRawImageCallback != null) {
                mRawImageCallback.onPictureTaken((byte[]) msg.obj, mCamera);
            }
            return;
        case CAMERA_MSG_COMPRESSED_IMAGE:
            if (mJpegCallback != null) {
                mJpegCallback.onPictureTaken((byte[]) msg.obj, mCamera);
            }
            return;
        case CAMERA_MSG_PREVIEW_FRAME:
            PreviewCallback pCb = mPreviewCallback;
            if (pCb != null) {
                if (mOneShot) {
                    // Clear the callback variable before the callback
                    // in case the app calls setPreviewCallback from
                    // the callback function
                    mPreviewCallback = null;
                } else if (!mWithBuffer) {
                    // We're faking the camera preview mode to prevent
                    // the app from being flooded with preview frames.
                    // Set to oneshot mode again.
                    setHasPreviewCallback(true, false);
                }
                pCb.onPreviewFrame((byte[]) msg.obj, mCamera);
            }
            return;
        case CAMERA_MSG_POSTVIEW_FRAME:
            if (mPostviewCallback != null) {
                mPostviewCallback.onPictureTaken((byte[]) msg.obj, mCamera);
            }
            return;
        case CAMERA_MSG_FOCUS:
            AutoFocusCallback cb = null;
            synchronized (mAutoFocusCallbackLock) {
                cb = mAutoFocusCallback;
            }
            if (cb != null) {
                boolean success = msg.arg1 == 0 ? false : true;
                cb.onAutoFocus(success, mCamera);
            }
            return;
        case CAMERA_MSG_ZOOM:
            if (mZoomListener != null) {
                mZoomListener.onZoomChange(msg.arg1, msg.arg2 != 0, mCamera);
            }
            return;
        case CAMERA_MSG_PREVIEW_METADATA:
            if (mFaceListener != null) {
                mFaceListener.onFaceDetection((Face[]) msg.obj, mCamera);
            }
            return;
        case CAMERA_MSG_ERROR:
            Log.e(TAG, ""Error "" + msg.arg1);
            if (mErrorCallback != null) {
                mErrorCallback.onError(msg.arg1, mCamera);
            }
            return;
        case CAMERA_MSG_FOCUS_MOVE:
            if (mAutoFocusMoveCallback != null) {
                mAutoFocusMoveCallback.onAutoFocusMoving(msg.arg1 == 0 ? false : true, mCamera);
            }
            return;
        default:
            Log.e(TAG, ""Unknown message type "" + msg.what);
            return;
    }
}","{
    switch(msg.what) {
        case CAMERA_MSG_SHUTTER:
            if (mShutterCallback != null) {
                mShutterCallback.onShutter();
            }
            return;
        case CAMERA_MSG_RAW_IMAGE:
            if (mRawImageCallback != null) {
                mRawImageCallback.onPictureTaken((byte[]) msg.obj, mCamera);
            }
            return;
        case CAMERA_MSG_COMPRESSED_IMAGE:
            if (mJpegCallback != null) {
                mJpegCallback.onPictureTaken((byte[]) msg.obj, mCamera);
            }
            return;
        case CAMERA_MSG_PREVIEW_FRAME:
            PreviewCallback pCb = mPreviewCallback;
            if (pCb != null) {
                if (mOneShot) {
                    // Clear the callback variable before the callback
                    // in case the app calls setPreviewCallback from
                    // the callback function
                    mPreviewCallback = null;
                } else if (!mWithBuffer) {
                    // We're faking the camera preview mode to prevent
                    // the app from being flooded with preview frames.
                    // Set to oneshot mode again.
                    setHasPreviewCallback(true, false);
                }
                pCb.onPreviewFrame((byte[]) msg.obj, mCamera);
            }
            return;
        case CAMERA_MSG_POSTVIEW_FRAME:
            if (mPostviewCallback != null) {
                mPostviewCallback.onPictureTaken((byte[]) msg.obj, mCamera);
            }
            return;
        case CAMERA_MSG_FOCUS:
            AutoFocusCallback cb = null;
            synchronized (mAutoFocusCallbackLock) {
                cb = mAutoFocusCallback;
            }
            if (cb != null) {
                boolean success = msg.arg1 == 0 ? false : true;
                cb.onAutoFocus(success, mCamera);
            }
            return;
        case CAMERA_MSG_ZOOM:
            if (mZoomListener != null) {
                mZoomListener.onZoomChange(msg.arg1, msg.arg2 != 0, mCamera);
            }
            return;
        case CAMERA_MSG_PREVIEW_METADATA:
            if (mFaceListener != null) {
                mFaceListener.onFaceDetection((Face[]) msg.obj, mCamera);
            }
            return;
        case CAMERA_MSG_ERROR:
            Log.e(TAG, ""Error "" + msg.arg1);
            if (mDetailedErrorCallback != null) {
                mDetailedErrorCallback.onError(msg.arg1, mCamera);
            } else if (mErrorCallback != null) {
                if (msg.arg1 == CAMERA_ERROR_DISABLED) {
                    mErrorCallback.onError(CAMERA_ERROR_EVICTED, mCamera);
                } else {
                    mErrorCallback.onError(msg.arg1, mCamera);
                }
            }
            return;
        case CAMERA_MSG_FOCUS_MOVE:
            if (mAutoFocusMoveCallback != null) {
                mAutoFocusMoveCallback.onAutoFocusMoving(msg.arg1 == 0 ? false : true, mCamera);
            }
            return;
        default:
            Log.e(TAG, ""Unknown message type "" + msg.what);
            return;
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,,,,
904,"<android.hardware.camera2.impl.CameraDeviceImpl.CameraDeviceCallbacks: void onDeviceError(int,CaptureResultExtras)>",27,28,"<android.hardware.camera2.impl.CameraDeviceImpl.CameraDeviceCallbacks: void onDeviceError(int,CaptureResultExtras)>","<android.hardware.camera2.impl.CameraDeviceImpl.CameraDeviceCallbacks: void onDeviceError(int,CaptureResultExtras)>",0,"{
    if (DEBUG) {
        Log.d(TAG, String.format(""Device error received, code %d, frame number %d, request ID %d, subseq ID %d"", errorCode, resultExtras.getFrameNumber(), resultExtras.getRequestId(), resultExtras.getSubsequenceId()));
    }
    synchronized (mInterfaceLock) {
        if (mRemoteDevice == null) {
            // Camera already closed
            return;
        }
        switch(errorCode) {
            case ERROR_CAMERA_DISCONNECTED:
                CameraDeviceImpl.this.mDeviceHandler.post(mCallOnDisconnected);
                break;
            default:
                Log.e(TAG, ""Unknown error from camera device: "" + errorCode);
            // no break
            case ERROR_CAMERA_DEVICE:
            case ERROR_CAMERA_SERVICE:
                mInError = true;
                final int publicErrorCode = (errorCode == ERROR_CAMERA_DEVICE) ? StateCallback.ERROR_CAMERA_DEVICE : StateCallback.ERROR_CAMERA_SERVICE;
                Runnable r = new Runnable() {

                    @Override
                    public void run() {
                        if (!CameraDeviceImpl.this.isClosed()) {
                            mDeviceCallback.onError(CameraDeviceImpl.this, publicErrorCode);
                        }
                    }
                };
                CameraDeviceImpl.this.mDeviceHandler.post(r);
                break;
            case ERROR_CAMERA_REQUEST:
            case ERROR_CAMERA_RESULT:
            case ERROR_CAMERA_BUFFER:
                onCaptureErrorLocked(errorCode, resultExtras);
                break;
        }
    }
}","{
    if (DEBUG) {
        Log.d(TAG, String.format(""Device error received, code %d, frame number %d, request ID %d, subseq ID %d"", errorCode, resultExtras.getFrameNumber(), resultExtras.getRequestId(), resultExtras.getSubsequenceId()));
    }
    synchronized (mInterfaceLock) {
        if (mRemoteDevice == null) {
            // Camera already closed
            return;
        }
        switch(errorCode) {
            case ERROR_CAMERA_DISCONNECTED:
                final long ident = Binder.clearCallingIdentity();
                try {
                    CameraDeviceImpl.this.mDeviceExecutor.execute(mCallOnDisconnected);
                } finally {
                    Binder.restoreCallingIdentity(ident);
                }
                break;
            case ERROR_CAMERA_REQUEST:
            case ERROR_CAMERA_RESULT:
            case ERROR_CAMERA_BUFFER:
                onCaptureErrorLocked(errorCode, resultExtras);
                break;
            case ERROR_CAMERA_DEVICE:
                scheduleNotifyError(StateCallback.ERROR_CAMERA_DEVICE);
                break;
            case ERROR_CAMERA_DISABLED:
                scheduleNotifyError(StateCallback.ERROR_CAMERA_DISABLED);
                break;
            default:
                Log.e(TAG, ""Unknown error from camera device: "" + errorCode);
                scheduleNotifyError(StateCallback.ERROR_CAMERA_SERVICE);
        }
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,4","1,2","There are changes in the control dependency and other statements, indicated by the change from CameraDeviceImpl.this.mDeviceHandler.post(mCallOnDisconnected) to CameraDeviceImpl.this.mDeviceExecutor.execute(mCallOnDisconnected) and the handling of new error codes like ERROR_CAMERA_DISABLED, as well as changes in the logic for ERROR_CAMERA_DEVICE and ERROR_CAMERA_SERVICE error handling.","The refactoring from using a Handler to post Runnable to using an Executor to execute a Runnable can change the threading behavior and timing. This, along with added cases for error handling, could lead to different return values or exception throwing behavior; hence there is a compatibility issue caused by potential different return values or types and potential different exception handlings."
905,<android.text.format.DateFormat: boolean is24HourFormat(Context)>,27,28,<android.text.format.DateFormat: boolean is24HourFormat(Context)>,<android.text.format.DateFormat: boolean is24HourFormat(Context)>,0,"{
    return is24HourFormat(context, UserHandle.myUserId());
}","{
    return is24HourFormat(context, context.getUserId());
}",1,"/**
 * Returns true if user preference is set to 24-hour format.
 * @param context the context to use for the content resolver
 * @return true if 24 hour time format is selected, false otherwise.
 */
","/**
 * Returns true if times should be formatted as 24 hour times, false if times should be
 * formatted as 12 hour (AM/PM) times. Based on the user's chosen locale and other preferences.
 * @param context the context to use for the content resolver
 * @return true if 24 hour time format is selected, false otherwise.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The implementation code has changed from calling UserHandle.myUserId() to context.getUserId() in the return statement. This change in how the user ID is retrieved can affect the value returned by the method. Thus, the pred_change includes 1 for the return statement change and 5 for the dependent API change.","Because the source of the user ID in the return statement changed, this could potentially lead to different return values when calling is24HourFormat(). For instance, if the user ID returned by context.getUserId() is different from the user ID returned by UserHandle.myUserId(), the method could return a different boolean result. Therefore, there is a potential Compatibility Issue of type 1 caused by possible different return values."
906,<android.bluetooth.BluetoothGattService: BluetoothGattCharacteristic getCharacteristic(UUID)>,27,28,<android.bluetooth.BluetoothGattService: BluetoothGattCharacteristic getCharacteristic(UUID)>,<android.bluetooth.BluetoothGattService: BluetoothGattCharacteristic getCharacteristic(UUID)>,0,"{
    for (BluetoothGattCharacteristic characteristic : mCharacteristics) {
        if (uuid.equals(characteristic.getUuid()))
            return characteristic;
    }
    return null;
}","{
    for (BluetoothGattCharacteristic characteristic : mCharacteristics) {
        if (uuid.equals(characteristic.getUuid())) {
            return characteristic;
        }
    }
    return null;
}",1,"/**
 * Returns a characteristic with a given UUID out of the list of
 * characteristics offered by this service.
 *
 * <p>This is a convenience function to allow access to a given characteristic
 * without enumerating over the list returned by {@link #getCharacteristics}
 * manually.
 *
 * <p>If a remote service offers multiple characteristics with the same
 * UUID, the first instance of a characteristic with the given UUID
 * is returned.
 *
 * @return GATT characteristic object or null if no characteristic with the
 * given UUID was found.
 */
","/**
 * Returns a characteristic with a given UUID out of the list of
 * characteristics offered by this service.
 *
 * <p>This is a convenience function to allow access to a given characteristic
 * without enumerating over the list returned by {@link #getCharacteristics}
 * manually.
 *
 * <p>If a remote service offers multiple characteristics with the same
 * UUID, the first instance of a characteristic with the given UUID
 * is returned.
 *
 * @return GATT characteristic object or null if no characteristic with the given UUID was
 * found.
 */
",-1,,,-1,-1,-1,-1,-1,-1,0,0,"There is no actual code change between the two versions, only the formatting/style was altered.","No change in behavior or return values is expected, and thus there should be no compatibility issues."
907,<android.content.pm.PackageParser.Package: boolean isMatch(int)>,27,28,<android.content.pm.PackageParser.Package: boolean isMatch(int)>,<android.content.pm.PackageParser.Package: boolean isMatch(int)>,0,"{
    if ((flags & PackageManager.MATCH_SYSTEM_ONLY) != 0) {
        return isSystemApp();
    }
    return true;
}","{
    if ((flags & PackageManager.MATCH_SYSTEM_ONLY) != 0) {
        return isSystem();
    }
    return true;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,5,0,"The method called within the return statement has changed from isSystemApp() to isSystem(), indicating the dependent API is changed, which is a type 5 change.","Since both the early and late versions of the method return true for all cases except when the (flags & PackageManager.MATCH_SYSTEM_ONLY) is non-zero, in which they call a method that is presumably to check if the package is a system application or not, the behavior of the method is consistent as long as the new isSystem() method is functionally equivalent to isSystemApp(). It seems that the method name has just been updated, but without knowing if the internal behavior of isSystem() has changed, based on the given code, we cannot confirm a compatibility issue solely from changing the method name. Thus, the CI type is 0."
908,<android.bluetooth.BluetoothAdapter: BluetoothLeAdvertiser getBluetoothLeAdvertiser()>,27,28,<android.bluetooth.BluetoothAdapter: BluetoothLeAdvertiser getBluetoothLeAdvertiser()>,<android.bluetooth.BluetoothAdapter: BluetoothLeAdvertiser getBluetoothLeAdvertiser()>,0,"{
    if (!getLeAccess())
        return null;
    synchronized (mLock) {
        if (sBluetoothLeAdvertiser == null) {
            sBluetoothLeAdvertiser = new BluetoothLeAdvertiser(mManagerService);
        }
    }
    return sBluetoothLeAdvertiser;
}","{
    if (!getLeAccess()) {
        return null;
    }
    synchronized (mLock) {
        if (sBluetoothLeAdvertiser == null) {
            sBluetoothLeAdvertiser = new BluetoothLeAdvertiser(mManagerService);
        }
    }
    return sBluetoothLeAdvertiser;
}",1,"/**
 * Returns a {@link BluetoothLeAdvertiser} object for Bluetooth LE Advertising operations.
 * Will return null if Bluetooth is turned off or if Bluetooth LE Advertising is not
 * supported on this device.
 * <p>
 * Use {@link #isMultipleAdvertisementSupported()} to check whether LE Advertising is supported
 * on this device before calling this method.
 */
","/**
 * Returns a {@link BluetoothLeAdvertiser} object for Bluetooth LE Advertising operations.
 * Will return null if Bluetooth is turned off or if Bluetooth LE Advertising is not
 * supported on this device.
 * <p>
 * Use {@link #isMultipleAdvertisementSupported()} to check whether LE Advertising is supported
 * on this device before calling this method.
 */
",-1,,,-1,-1,-1,-1,-1,-1,0,0,"There is no actual code change between the early and late versions, only a formatting change (the addition of braces around the return statement in the if block). This does not affect the behavior of the API method.","Since there is no change in the actual code, there is no compatibility issue between the two versions."
909,"<android.app.PendingIntent: PendingIntent getActivities(Context,int,Intent[],int,Bundle)>",27,28,"<android.app.PendingIntent: PendingIntent getActivities(Context,int,Intent[],int,Bundle)>","<android.app.PendingIntent: PendingIntent getActivities(Context,int,Intent[],int,Bundle)>",0,"{
    String packageName = context.getPackageName();
    String[] resolvedTypes = new String[intents.length];
    for (int i = 0; i < intents.length; i++) {
        intents[i].migrateExtraStreamToClipData();
        intents[i].prepareToLeaveProcess(context);
        resolvedTypes[i] = intents[i].resolveTypeIfNeeded(context.getContentResolver());
    }
    try {
        IIntentSender target = ActivityManager.getService().getIntentSender(ActivityManager.INTENT_SENDER_ACTIVITY, packageName, null, null, requestCode, intents, resolvedTypes, flags, options, UserHandle.myUserId());
        return target != null ? new PendingIntent(target) : null;
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}","{
    String packageName = context.getPackageName();
    String[] resolvedTypes = new String[intents.length];
    for (int i = 0; i < intents.length; i++) {
        intents[i].migrateExtraStreamToClipData();
        intents[i].prepareToLeaveProcess(context);
        resolvedTypes[i] = intents[i].resolveTypeIfNeeded(context.getContentResolver());
    }
    try {
        IIntentSender target = ActivityManager.getService().getIntentSender(ActivityManager.INTENT_SENDER_ACTIVITY, packageName, null, null, requestCode, intents, resolvedTypes, flags, options, context.getUserId());
        return target != null ? new PendingIntent(target) : null;
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Like {@link #getActivity(Context, int, Intent, int)}, but allows an
 * array of Intents to be supplied.  The last Intent in the array is
 * taken as the primary key for the PendingIntent, like the single Intent
 * given to {@link #getActivity(Context, int, Intent, int)}.  Upon sending
 * the resulting PendingIntent, all of the Intents are started in the same
 * way as they would be by passing them to {@link Context#startActivities(Intent[])}.
 *
 * <p class=""note"">
 * The <em>first</em> intent in the array will be started outside of the context of an
 * existing activity, so you must use the {@link Intent#FLAG_ACTIVITY_NEW_TASK
 * Intent.FLAG_ACTIVITY_NEW_TASK} launch flag in the Intent.  (Activities after
 * the first in the array are started in the context of the previous activity
 * in the array, so FLAG_ACTIVITY_NEW_TASK is not needed nor desired for them.)
 * </p>
 *
 * <p class=""note"">
 * The <em>last</em> intent in the array represents the key for the
 * PendingIntent.  In other words, it is the significant element for matching
 * (as done with the single intent given to {@link #getActivity(Context, int, Intent, int)},
 * its content will be the subject of replacement by
 * {@link #send(Context, int, Intent)} and {@link #FLAG_UPDATE_CURRENT}, etc.
 * This is because it is the most specific of the supplied intents, and the
 * UI the user actually sees when the intents are started.
 * </p>
 *
 * <p class=""note"">For security reasons, the {@link android.content.Intent} objects
 * you supply here should almost always be <em>explicit intents</em>,
 * that is specify an explicit component to be delivered to through
 * {@link Intent#setClass(android.content.Context, Class) Intent.setClass}</p>
 *
 * @param context The Context in which this PendingIntent should start
 * the activity.
 * @param requestCode Private request code for the sender
 * @param intents Array of Intents of the activities to be launched.
 * @param flags May be {@link #FLAG_ONE_SHOT}, {@link #FLAG_NO_CREATE},
 * {@link #FLAG_CANCEL_CURRENT}, {@link #FLAG_UPDATE_CURRENT},
 * {@link #FLAG_IMMUTABLE} or any of the flags as supported by
 * {@link Intent#fillIn Intent.fillIn()} to control which unspecified parts
 * of the intent that can be supplied when the actual send happens.
 *
 * @return Returns an existing or new PendingIntent matching the given
 * parameters.  May return null only if {@link #FLAG_NO_CREATE} has been
 * supplied.
 */
","/**
 * Like {@link #getActivity(Context, int, Intent, int)}, but allows an
 * array of Intents to be supplied.  The last Intent in the array is
 * taken as the primary key for the PendingIntent, like the single Intent
 * given to {@link #getActivity(Context, int, Intent, int)}.  Upon sending
 * the resulting PendingIntent, all of the Intents are started in the same
 * way as they would be by passing them to {@link Context#startActivities(Intent[])}.
 *
 * <p class=""note"">
 * The <em>first</em> intent in the array will be started outside of the context of an
 * existing activity, so you must use the {@link Intent#FLAG_ACTIVITY_NEW_TASK
 * Intent.FLAG_ACTIVITY_NEW_TASK} launch flag in the Intent.  (Activities after
 * the first in the array are started in the context of the previous activity
 * in the array, so FLAG_ACTIVITY_NEW_TASK is not needed nor desired for them.)
 * </p>
 *
 * <p class=""note"">
 * The <em>last</em> intent in the array represents the key for the
 * PendingIntent.  In other words, it is the significant element for matching
 * (as done with the single intent given to {@link #getActivity(Context, int, Intent, int)},
 * its content will be the subject of replacement by
 * {@link #send(Context, int, Intent)} and {@link #FLAG_UPDATE_CURRENT}, etc.
 * This is because it is the most specific of the supplied intents, and the
 * UI the user actually sees when the intents are started.
 * </p>
 *
 * <p class=""note"">For security reasons, the {@link android.content.Intent} objects
 * you supply here should almost always be <em>explicit intents</em>,
 * that is specify an explicit component to be delivered to through
 * {@link Intent#setClass(android.content.Context, Class) Intent.setClass}</p>
 *
 * @param context The Context in which this PendingIntent should start
 * the activity.
 * @param requestCode Private request code for the sender
 * @param intents Array of Intents of the activities to be launched.
 * @param flags May be {@link #FLAG_ONE_SHOT}, {@link #FLAG_NO_CREATE},
 * {@link #FLAG_CANCEL_CURRENT}, {@link #FLAG_UPDATE_CURRENT},
 * {@link #FLAG_IMMUTABLE} or any of the flags as supported by
 * {@link Intent#fillIn Intent.fillIn()} to control which unspecified parts
 * of the intent that can be supplied when the actual send happens.
 *
 * @return Returns an existing or new PendingIntent matching the given
 * parameters.  May return null only if {@link #FLAG_NO_CREATE} has been
 * supplied.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"The code change is in the line where the method getUserId() from the context object is called instead of UserHandle.myUserId(). This change indicates a dependent API change where a method called on the `context` object replaces the static call to `UserHandle.myUserId()`. There is no return statement change, exception handling statement change, or control dependency change since the algorithm flow and exception handling remain the same. Therefore, the change type is a combination of 4 (other statement changed) and 5 (dependent API changed).","There is no Compatibility Issue in terms of return values or exception handling, because the call to `context.getUserId()` should return the user ID associated with the given context, which is expected to be the same user ID that would have been obtained by calling `UserHandle.myUserId()` in the scope of the same context. Since the intent of both calls is to retrieve the user ID of the current process and there's no indication that the result would differ between the two API versions, there are no changes that affect the outcome of the API's functionality in a way that should lead to a Compatibility Issue. However, this presumes consistent behavior across the two versions in terms of user ID resolution. If the user ID resolution mechanism were to have changed between the two versions, this could potentially introduce a Compatibility Issue, but there's no evidence in this information to suggest that this is the case."
910,<android.bluetooth.le.AdvertisingSetParameters.Builder: Builder setSecondaryPhy(int)>,27,28,<android.bluetooth.le.AdvertisingSetParameters.Builder: Builder setSecondaryPhy(int)>,<android.bluetooth.le.AdvertisingSetParameters.Builder: Builder setSecondaryPhy(int)>,0,"{
    if (secondaryPhy != BluetoothDevice.PHY_LE_1M && secondaryPhy != BluetoothDevice.PHY_LE_2M && secondaryPhy != BluetoothDevice.PHY_LE_CODED) {
        throw new IllegalArgumentException(""bad secondaryPhy "" + secondaryPhy);
    }
    this.secondaryPhy = secondaryPhy;
    return this;
}","{
    if (secondaryPhy != BluetoothDevice.PHY_LE_1M && secondaryPhy != BluetoothDevice.PHY_LE_2M && secondaryPhy != BluetoothDevice.PHY_LE_CODED) {
        throw new IllegalArgumentException(""bad secondaryPhy "" + secondaryPhy);
    }
    mSecondaryPhy = secondaryPhy;
    return this;
}",1,"/**
 * Set the secondary physical channel used for this advertising set.
 *
 * This is used only if legacy mode is not used.
 *
 * Use {@link BluetoothAdapter#isLeCodedPhySupported} and
 * {@link BluetoothAdapter#isLe2MPhySupported} to determine if LE Coded PHY or 2M PHY is
 * supported on this device.
 *
 * @param secondaryPhy Secondary advertising physical channel, can only be
 * one of {@link BluetoothDevice#PHY_LE_1M},
 * {@link BluetoothDevice#PHY_LE_2M} or
 * {@link BluetoothDevice#PHY_LE_CODED}.
 * @throws IllegalArgumentException If the secondaryPhy is invalid.
 */
","/**
 * Set the secondary physical channel used for this advertising set.
 *
 * This is used only if legacy mode is not used.
 *
 * Use {@link BluetoothAdapter#isLeCodedPhySupported} and
 * {@link BluetoothAdapter#isLe2MPhySupported} to determine if LE Coded PHY or 2M PHY is
 * supported on this device.
 *
 * @param secondaryPhy Secondary advertising physical channel, can only be one of {@link
 * BluetoothDevice#PHY_LE_1M}, {@link BluetoothDevice#PHY_LE_2M} or {@link
 * BluetoothDevice#PHY_LE_CODED}.
 * @throws IllegalArgumentException If the secondaryPhy is invalid.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The assignment statement has changed from this.secondaryPhy = secondaryPhy to mSecondaryPhy = secondaryPhy. Since it is only a variable name change and does not affect object state externally, the change type is 4.",There is no Compatibility Issue as the change does not affect the API's behavior. It's an internal field renaming that won't change the API contract or its observable behavior.
911,"<android.hardware.camera2.impl.CameraCaptureSessionImpl: int setRepeatingBurst(List<CaptureRequest>,CaptureCallback,Handler)>",27,28,"<android.hardware.camera2.impl.CameraCaptureSessionImpl: int setRepeatingBurst(List<CaptureRequest>,CaptureCallback,Handler)>","<android.hardware.camera2.impl.CameraCaptureSessionImpl: int setRepeatingBurst(List<CaptureRequest>,CaptureCallback,Handler)>",0,"{
    if (requests == null) {
        throw new IllegalArgumentException(""requests must not be null"");
    } else if (requests.isEmpty()) {
        throw new IllegalArgumentException(""requests must have at least one element"");
    }
    for (CaptureRequest r : requests) {
        if (r.isReprocess()) {
            throw new IllegalArgumentException(""repeating reprocess burst requests are not "" + ""supported"");
        }
    }
    synchronized (mDeviceImpl.mInterfaceLock) {
        checkNotClosed();
        handler = checkHandler(handler, callback);
        if (DEBUG) {
            CaptureRequest[] requestArray = requests.toArray(new CaptureRequest[0]);
            Log.v(TAG, mIdString + ""setRepeatingBurst - requests "" + Arrays.toString(requestArray) + "", callback "" + callback + "" handler"" + """" + handler);
        }
        return addPendingSequence(mDeviceImpl.setRepeatingBurst(requests, createCaptureCallbackProxy(handler, callback), mDeviceHandler));
    }
}","{
    checkRepeatingRequests(requests);
    synchronized (mDeviceImpl.mInterfaceLock) {
        checkNotClosed();
        handler = checkHandler(handler, callback);
        if (DEBUG) {
            CaptureRequest[] requestArray = requests.toArray(new CaptureRequest[0]);
            Log.v(TAG, mIdString + ""setRepeatingBurst - requests "" + Arrays.toString(requestArray) + "", callback "" + callback + "" handler"" + """" + handler);
        }
        return addPendingSequence(mDeviceImpl.setRepeatingBurst(requests, createCaptureCallbackProxy(handler, callback), mDeviceExecutor));
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"4,5",0,"Early implementation contains input validation checks and a loop, which are replaced by the `checkRepeatingRequests(requests)` call in the late implementation. Furthermore, `mDeviceHandler` is replaced by `mDeviceExecutor`. Given that `checkRepeatingRequests(requests)` is likely to be performing the same checks as the replaced code, and that the change from `mDeviceHandler` to `mDeviceExecutor` doesn't change the arguments to `setRepeatingBurst()` (since both are `Handler` types and the internal workings of `setRepeatingBurst` are not specified), these changes are classified as 4 (Other statement changed) and 5 (Dependent API changed).","There appears to be no Compatibility Issue with this change since the extracted method `checkRepeatingRequests(requests)` is expected to perform the same checks as the original inline code. The update from `mDeviceHandler` to `mDeviceExecutor` doesn't inherently impact the behavior seen from invoking the `setRepeatingBurst` method from an external viewpointthe changes handle internal implementation details which are not exposed to the API users, assuming `mDeviceExecutor` is compatible with the `Handler` interface as `mDeviceHandler` was. Therefore, the CI situation is 0 (No Compatibility Issue)."
912,"<android.app.ActivityManager: List<RecentTaskInfo> getRecentTasks(int,int)>",27,28,"<android.app.ActivityManager: List<RecentTaskInfo> getRecentTasks(int,int)>","<android.app.ActivityManager: List<RecentTaskInfo> getRecentTasks(int,int)>",0,"{
    try {
        return getService().getRecentTasks(maxNum, flags, UserHandle.myUserId()).getList();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}","{
    try {
        if (maxNum < 0) {
            throw new IllegalArgumentException(""The requested number of tasks should be >= 0"");
        }
        return getService().getRecentTasks(maxNum, flags, mContext.getUserId()).getList();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * <p></p>Return a list of the tasks that the user has recently launched, with
 * the most recent being first and older ones after in order.
 *
 * <p><b>Note: this method is only intended for debugging and presenting
 * task management user interfaces</b>.  This should never be used for
 * core logic in an application, such as deciding between different
 * behaviors based on the information found here.  Such uses are
 * <em>not</em> supported, and will likely break in the future.  For
 * example, if multiple applications can be actively running at the
 * same time, assumptions made about the meaning of the data here for
 * purposes of control flow will be incorrect.</p>
 *
 * @deprecated As of {@link android.os.Build.VERSION_CODES#LOLLIPOP}, this method is
 * no longer available to third party applications: the introduction of
 * document-centric recents means
 * it can leak personal information to the caller.  For backwards compatibility,
 * it will still return a small subset of its data: at least the caller's
 * own tasks (though see {@link #getAppTasks()} for the correct supported
 * way to retrieve that information), and possibly some other tasks
 * such as home that are known to not be sensitive.
 *
 * @param maxNum The maximum number of entries to return in the list.  The
 * actual number returned may be smaller, depending on how many tasks the
 * user has started and the maximum number the system can remember.
 * @param flags Information about what to return.  May be any combination
 * of {@link #RECENT_WITH_EXCLUDED} and {@link #RECENT_IGNORE_UNAVAILABLE}.
 *
 * @return Returns a list of RecentTaskInfo records describing each of
 * the recent tasks.
 */
","/**
 * <p></p>Return a list of the tasks that the user has recently launched, with
 * the most recent being first and older ones after in order.
 *
 * <p><b>Note: this method is only intended for debugging and presenting
 * task management user interfaces</b>.  This should never be used for
 * core logic in an application, such as deciding between different
 * behaviors based on the information found here.  Such uses are
 * <em>not</em> supported, and will likely break in the future.  For
 * example, if multiple applications can be actively running at the
 * same time, assumptions made about the meaning of the data here for
 * purposes of control flow will be incorrect.</p>
 *
 * @deprecated As of {@link android.os.Build.VERSION_CODES#LOLLIPOP}, this method is
 * no longer available to third party applications: the introduction of
 * document-centric recents means
 * it can leak personal information to the caller.  For backwards compatibility,
 * it will still return a small subset of its data: at least the caller's
 * own tasks (though see {@link #getAppTasks()} for the correct supported
 * way to retrieve that information), and possibly some other tasks
 * such as home that are known to not be sensitive.
 *
 * @param maxNum The maximum number of entries to return in the list.  The
 * actual number returned may be smaller, depending on how many tasks the
 * user has started and the maximum number the system can remember.
 * @param flags Information about what to return.  May be any combination
 * of {@link #RECENT_WITH_EXCLUDED} and {@link #RECENT_IGNORE_UNAVAILABLE}.
 *
 * @return Returns a list of RecentTaskInfo records describing each of
 * the recent tasks.
 */
",-1,[@Deprecated],[@Deprecated],-1,-1,-1,-1,-1,-1,3,1,"An if-statement checking the parameter 'maxNum' has been added to throw an IllegalArgumentException if 'maxNum' is less than 0. This is a change in control dependency, represented by the code change type 3.","The new if-statement could potentially result in throwing an IllegalArgumentException where none was thrown before, which would constitute a different behavior. Thus, the API could potentially lead to a Compatibility Issue caused by a different exception being thrown, and this corresponds to CI type 1."
913,<android.content.ContentResolver: void cancelSync(SyncRequest)>,27,28,<android.content.ContentResolver: void cancelSync(SyncRequest)>,<android.content.ContentResolver: void cancelSync(SyncRequest)>,0,"{
    if (request == null) {
        throw new IllegalArgumentException(""request cannot be null"");
    }
    try {
        getContentService().cancelRequest(request);
    } catch (RemoteException e) {
    // exception ignored; if this is thrown then it means the runtime is in the midst of
    // being restarted
    }
}","{
    if (request == null) {
        throw new IllegalArgumentException(""request cannot be null"");
    }
    try {
        getContentService().cancelRequest(request);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Remove the specified sync. This will cancel any pending or active syncs. If the request is
 * for a periodic sync, this call will remove any future occurrences.
 * <p>
 * If a periodic sync is specified, the caller must hold the permission
 * {@link android.Manifest.permission#WRITE_SYNC_SETTINGS}.
 * </p>
 * It is possible to cancel a sync using a SyncRequest object that is not the same object
 * with which you requested the sync. Do so by building a SyncRequest with the same
 * adapter, frequency, <b>and</b> extras bundle.
 *
 * @param request SyncRequest object containing information about sync to cancel.
 */
","/**
 * Remove the specified sync. This will cancel any pending or active syncs. If the request is
 * for a periodic sync, this call will remove any future occurrences.
 * <p>
 * If a periodic sync is specified, the caller must hold the permission
 * {@link android.Manifest.permission#WRITE_SYNC_SETTINGS}.
 * </p>
 * It is possible to cancel a sync using a SyncRequest object that is not the same object
 * with which you requested the sync. Do so by building a SyncRequest with the same
 * adapter, frequency, <b>and</b> extras bundle.
 *
 * @param request SyncRequest object containing information about sync to cancel.
 */
",-1,,,-1,-1,-1,-1,-1,-1,2,2,"The handling of RemoteException has changed, the early version ignores it while the late version throws an exception with `throw e.rethrowFromSystemServer()`, so the change type is 2.","The new exception handling in the late version API may cause it to throw an exception where the previous version would not, leading to a different behavior in the presence of a RemoteException. This is a Compatibility Issue of type 2."
914,<android.app.admin.DnsEvent: String getHostname()>,27,28,<android.app.admin.DnsEvent: String getHostname()>,<android.app.admin.DnsEvent: String getHostname()>,0,"{
    return hostname;
}","{
    return mHostname;
}",1,"/**
 * Returns the hostname that was looked up.
 */
","/**
 * Returns the hostname that was looked up.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The variable returned by the method changed from ""hostname"" to ""mHostname"". This is a simple renaming of a member variable, so the code change type is 4, indicating ""Other statement changed"".","There are no potential Compatibility Issues detected because it's a straightforward renaming of a variable. The functionality and return type remain the same, so CI type is 0."
915,<android.net.Network: long getNetworkHandle()>,27,28,<android.net.Network: long getNetworkHandle()>,<android.net.Network: long getNetworkHandle()>,0,"{
    // value in the native/android/net.c NDK implementation.
    if (netId == 0) {
        // make this zero condition obvious for debugging
        return 0L;
    }
    final long HANDLE_MAGIC = 0xfacade;
    return (((long) netId) << 32) | HANDLE_MAGIC;
}","{
    // IETF mif working group.
    if (netId == 0) {
        // make this zero condition obvious for debugging
        return 0L;
    }
    return (((long) netId) << HANDLE_MAGIC_SIZE) | HANDLE_MAGIC;
}",1,"/**
 * Returns a handle representing this {@code Network}, for use with the NDK API.
 */
","/**
 * Returns a handle representing this {@code Network}, for use with the NDK API.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The change occurs in the way the return value is computed since HANDLE_MAGIC_SIZE is now used instead of the hardcoded '32'. However, this does not directly indicate a change in the actual output unless HANDLE_MAGIC_SIZE is defined differently than '32', which we can't infer from the given code snippets. The numeric constant HANDLE_MAGIC seems not to be modified. Therefore, as there is no direct evidence of HANDLE_MAGIC_SIZE being a different value, the classification is 4.","Without further context indicating that HANDLE_MAGIC_SIZE has a different value, we cannot conclusively determine that there is a compatibility issue based on the given implementation. The calculated values could remain the same if HANDLE_MAGIC_SIZE equals '32'. Therefore, there is no direct evidence of a compatibility issue."
916,"<android.nfc.cardemulation.CardEmulation: boolean isDefaultServiceForAid(ComponentName,String)>",27,28,"<android.nfc.cardemulation.CardEmulation: boolean isDefaultServiceForAid(ComponentName,String)>","<android.nfc.cardemulation.CardEmulation: boolean isDefaultServiceForAid(ComponentName,String)>",0,"{
    try {
        return sService.isDefaultServiceForAid(UserHandle.myUserId(), service, aid);
    } catch (RemoteException e) {
        // Try one more time
        recoverService();
        if (sService == null) {
            Log.e(TAG, ""Failed to recover CardEmulationService."");
            return false;
        }
        try {
            return sService.isDefaultServiceForAid(UserHandle.myUserId(), service, aid);
        } catch (RemoteException ee) {
            Log.e(TAG, ""Failed to reach CardEmulationService."");
            return false;
        }
    }
}","{
    try {
        return sService.isDefaultServiceForAid(mContext.getUserId(), service, aid);
    } catch (RemoteException e) {
        // Try one more time
        recoverService();
        if (sService == null) {
            Log.e(TAG, ""Failed to recover CardEmulationService."");
            return false;
        }
        try {
            return sService.isDefaultServiceForAid(mContext.getUserId(), service, aid);
        } catch (RemoteException ee) {
            Log.e(TAG, ""Failed to reach CardEmulationService."");
            return false;
        }
    }
}",1,"/**
 * Allows an application to query whether a service is currently
 * the default handler for a specified ISO7816-4 Application ID.
 *
 * @param service The ComponentName of the service
 * @param aid The ISO7816-4 Application ID
 * @return whether the service is the default handler for the specified AID
 *
 * <p class=""note"">Requires the {@link android.Manifest.permission#NFC} permission.
 */
","/**
 * Allows an application to query whether a service is currently
 * the default handler for a specified ISO7816-4 Application ID.
 *
 * @param service The ComponentName of the service
 * @param aid The ISO7816-4 Application ID
 * @return whether the service is the default handler for the specified AID
 *
 * <p class=""note"">Requires the {@link android.Manifest.permission#NFC} permission.
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The dependent API call changed from UserHandle.myUserId() to mContext.getUserId(), so the code change type is 5.","There is no Compatibility Issue as the change does not affect the return value or exception handling; it simply changes the way the user ID is obtained, which should not impact the external behavior of the method as long as the context provides the same user ID as the UserHandle."
917,<android.appwidget.AppWidgetHostView: View getDefaultView()>,27,28,<android.appwidget.AppWidgetHostView: View getDefaultView()>,<android.appwidget.AppWidgetHostView: View getDefaultView()>,0,"{
    if (LOGD) {
        Log.d(TAG, ""getDefaultView"");
    }
    View defaultView = null;
    Exception exception = null;
    try {
        if (mInfo != null) {
            Context theirContext = getRemoteContext();
            mRemoteContext = theirContext;
            LayoutInflater inflater = (LayoutInflater) theirContext.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
            inflater = inflater.cloneInContext(theirContext);
            inflater.setFilter(sInflaterFilter);
            AppWidgetManager manager = AppWidgetManager.getInstance(mContext);
            Bundle options = manager.getAppWidgetOptions(mAppWidgetId);
            int layoutId = mInfo.initialLayout;
            if (options.containsKey(AppWidgetManager.OPTION_APPWIDGET_HOST_CATEGORY)) {
                int category = options.getInt(AppWidgetManager.OPTION_APPWIDGET_HOST_CATEGORY);
                if (category == AppWidgetProviderInfo.WIDGET_CATEGORY_KEYGUARD) {
                    int kgLayoutId = mInfo.initialKeyguardLayout;
                    // If a default keyguard layout is not specified, use the standard
                    // default layout.
                    layoutId = kgLayoutId == 0 ? layoutId : kgLayoutId;
                }
            }
            defaultView = inflater.inflate(layoutId, this, false);
        } else {
            Log.w(TAG, ""can't inflate defaultView because mInfo is missing"");
        }
    } catch (RuntimeException e) {
        exception = e;
    }
    if (exception != null) {
        Log.w(TAG, ""Error inflating AppWidget "" + mInfo + "": "" + exception.toString());
    }
    if (defaultView == null) {
        if (LOGD)
            Log.d(TAG, ""getDefaultView couldn't find any view, so inflating error"");
        defaultView = getErrorView();
    }
    return defaultView;
}","{
    if (LOGD) {
        Log.d(TAG, ""getDefaultView"");
    }
    View defaultView = null;
    Exception exception = null;
    try {
        if (mInfo != null) {
            Context theirContext = getRemoteContext();
            mRemoteContext = theirContext;
            LayoutInflater inflater = (LayoutInflater) theirContext.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
            inflater = inflater.cloneInContext(theirContext);
            inflater.setFilter(INFLATER_FILTER);
            AppWidgetManager manager = AppWidgetManager.getInstance(mContext);
            Bundle options = manager.getAppWidgetOptions(mAppWidgetId);
            int layoutId = mInfo.initialLayout;
            if (options.containsKey(AppWidgetManager.OPTION_APPWIDGET_HOST_CATEGORY)) {
                int category = options.getInt(AppWidgetManager.OPTION_APPWIDGET_HOST_CATEGORY);
                if (category == AppWidgetProviderInfo.WIDGET_CATEGORY_KEYGUARD) {
                    int kgLayoutId = mInfo.initialKeyguardLayout;
                    // If a default keyguard layout is not specified, use the standard
                    // default layout.
                    layoutId = kgLayoutId == 0 ? layoutId : kgLayoutId;
                }
            }
            defaultView = inflater.inflate(layoutId, this, false);
        } else {
            Log.w(TAG, ""can't inflate defaultView because mInfo is missing"");
        }
    } catch (RuntimeException e) {
        exception = e;
    }
    if (exception != null) {
        Log.w(TAG, ""Error inflating AppWidget "" + mInfo + "": "" + exception.toString());
    }
    if (defaultView == null) {
        if (LOGD)
            Log.d(TAG, ""getDefaultView couldn't find any view, so inflating error"");
        defaultView = getErrorView();
    }
    return defaultView;
}",1,"/**
 * Inflate and return the default layout requested by AppWidget provider.
 */
","/**
 * Inflate and return the default layout requested by AppWidget provider.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The only change is in the constant name from 'sInflaterFilter' to 'INFLATER_FILTER'. This is a change of a reference to a constant value, so the code change type is 4.","This change does not affect the control flow or method behavior as it simply updates a constant reference. Therefore, there's no Compatibility Issue since it does not influence the return value, thrown exceptions, or control flow. The CI type is 0."
918,"<android.net.Network.NetworkBoundSocketFactory: Socket createSocket(InetAddress,int)>",27,28,"<android.net.Network.NetworkBoundSocketFactory: Socket createSocket(InetAddress,int)>","<android.net.Network.NetworkBoundSocketFactory: Socket createSocket(InetAddress,int)>",0,"{
    Socket socket = createSocket();
    socket.connect(new InetSocketAddress(host, port));
    return socket;
}","{
    Socket socket = createSocket();
    boolean failed = true;
    try {
        socket.connect(new InetSocketAddress(host, port));
        failed = false;
    } finally {
        if (failed)
            IoUtils.closeQuietly(socket);
    }
    return socket;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"2,3",2,"The late version introduces new variable 'failed', a try block, and a 'finally' block to close the socket silently if connection failed, so the change type is 2,3 due to the changes in exception handling and control structure.","The addition of exception handling with a 'finally' block that could close the socket in case of failure introduces a potential Compatibility Issue. In the early version if socket.connect throws an exception, the socket is not closed. In the late version, the socket is explicitly closed in this case, so the CI type is 2, caused by potentially different exception handlings."
919,<android.content.res.TypedArray: boolean hasValueOrEmpty(int)>,27,28,<android.content.res.TypedArray: boolean hasValueOrEmpty(int)>,<android.content.res.TypedArray: boolean hasValueOrEmpty(int)>,0,"{
    if (mRecycled) {
        throw new RuntimeException(""Cannot make calls to a recycled instance!"");
    }
    index *= AssetManager.STYLE_NUM_ENTRIES;
    final int[] data = mData;
    final int type = data[index + AssetManager.STYLE_TYPE];
    return type != TypedValue.TYPE_NULL || data[index + AssetManager.STYLE_DATA] == TypedValue.DATA_NULL_EMPTY;
}","{
    if (mRecycled) {
        throw new RuntimeException(""Cannot make calls to a recycled instance!"");
    }
    index *= STYLE_NUM_ENTRIES;
    final int[] data = mData;
    final int type = data[index + STYLE_TYPE];
    return type != TypedValue.TYPE_NULL || data[index + STYLE_DATA] == TypedValue.DATA_NULL_EMPTY;
}",1,"/**
 * Determines whether there is an attribute at <var>index</var>, returning
 * {@code true} if the attribute was explicitly set to {@code @empty} and
 * {@code false} only if the attribute was undefined.
 *
 * @param index Index of attribute to retrieve.
 *
 * @return True if the attribute has a value or is empty, false otherwise.
 * @throws RuntimeException if the TypedArray has already been recycled.
 */
","/**
 * Determines whether there is an attribute at <var>index</var>, returning
 * {@code true} if the attribute was explicitly set to {@code @empty} and
 * {@code false} only if the attribute was undefined.
 *
 * @param index Index of attribute to retrieve.
 *
 * @return True if the attribute has a value or is empty, false otherwise.
 * @throws RuntimeException if the TypedArray has already been recycled.
 */
",-1,,,-1,-1,-1,-1,-1,-1,0,0,"There is no actual code change between the early and late version implementations because the only difference is removing the explicit class name `AssetManager` before the constants `STYLE_NUM_ENTRIES`, `STYLE_TYPE`, and `STYLE_DATA`. This change does not affect the behavior of the code as the constants refer to the same values.",There is no compatibility issue between the versions because there is no change in the behavior of the method. The method still performs the same checks and returns the same value under the same conditions.
921,<android.hardware.camera2.impl.CameraDeviceImpl: void flush()>,27,28,<android.hardware.camera2.impl.CameraDeviceImpl: void flush()>,<android.hardware.camera2.impl.CameraDeviceImpl: void flush()>,0,"{
    synchronized (mInterfaceLock) {
        checkIfCameraClosedOrInError();
        mDeviceHandler.post(mCallOnBusy);
        // flush.
        if (mIdle) {
            mDeviceHandler.post(mCallOnIdle);
            return;
        }
        long lastFrameNumber = mRemoteDevice.flush();
        if (mRepeatingRequestId != REQUEST_ID_NONE) {
            checkEarlyTriggerSequenceComplete(mRepeatingRequestId, lastFrameNumber);
            mRepeatingRequestId = REQUEST_ID_NONE;
        }
    }
}","{
    synchronized (mInterfaceLock) {
        checkIfCameraClosedOrInError();
        mDeviceExecutor.execute(mCallOnBusy);
        // flush.
        if (mIdle) {
            mDeviceExecutor.execute(mCallOnIdle);
            return;
        }
        long lastFrameNumber = mRemoteDevice.flush();
        if (mRepeatingRequestId != REQUEST_ID_NONE) {
            checkEarlyTriggerSequenceComplete(mRepeatingRequestId, lastFrameNumber);
            mRepeatingRequestId = REQUEST_ID_NONE;
        }
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,4,0,"The method invocation has changed from mDeviceHandler.post() to mDeviceExecutor.execute(), which does not affect the logic but changes the way how the runnable is posted. So the code change type is 4.","Since the change from mDeviceHandler.post() to mDeviceExecutor.execute() does not alter the logic of the methodit merely affects how the Runnable is executed on a threadand since the Runnable logic remains the same, there is no potential Compatibility Issue in this change."
923,<android.view.ViewRootImpl.ViewRootHandler: void handleMessage(Message)>,27,28,<android.view.ViewRootImpl.ViewRootHandler: void handleMessage(Message)>,<android.view.ViewRootImpl.ViewRootHandler: void handleMessage(Message)>,0,"{
    switch(msg.what) {
        case MSG_INVALIDATE:
            ((View) msg.obj).invalidate();
            break;
        case MSG_INVALIDATE_RECT:
            final View.AttachInfo.InvalidateInfo info = (View.AttachInfo.InvalidateInfo) msg.obj;
            info.target.invalidate(info.left, info.top, info.right, info.bottom);
            info.recycle();
            break;
        case MSG_PROCESS_INPUT_EVENTS:
            mProcessInputEventsScheduled = false;
            doProcessInputEvents();
            break;
        case MSG_DISPATCH_APP_VISIBILITY:
            handleAppVisibility(msg.arg1 != 0);
            break;
        case MSG_DISPATCH_GET_NEW_SURFACE:
            handleGetNewSurface();
            break;
        case MSG_RESIZED:
            {
                // Recycled in the fall through...
                SomeArgs args = (SomeArgs) msg.obj;
                if (mWinFrame.equals(args.arg1) && mPendingOverscanInsets.equals(args.arg5) && mPendingContentInsets.equals(args.arg2) && mPendingStableInsets.equals(args.arg6) && mPendingVisibleInsets.equals(args.arg3) && mPendingOutsets.equals(args.arg7) && mPendingBackDropFrame.equals(args.arg8) && args.arg4 == null && args.argi1 == 0 && mDisplay.getDisplayId() == args.argi3) {
                    break;
                }
            }
        // fall through...
        case MSG_RESIZED_REPORT:
            if (mAdded) {
                SomeArgs args = (SomeArgs) msg.obj;
                final int displayId = args.argi3;
                MergedConfiguration mergedConfiguration = (MergedConfiguration) args.arg4;
                final boolean displayChanged = mDisplay.getDisplayId() != displayId;
                if (!mLastReportedMergedConfiguration.equals(mergedConfiguration)) {
                    // If configuration changed - notify about that and, maybe, about move to
                    // display.
                    performConfigurationChange(mergedConfiguration, false, /* force */
                    displayChanged ? displayId : INVALID_DISPLAY);
                } else if (displayChanged) {
                    // Moved to display without config change - report last applied one.
                    onMovedToDisplay(displayId, mLastConfigurationFromResources);
                }
                final boolean framesChanged = !mWinFrame.equals(args.arg1) || !mPendingOverscanInsets.equals(args.arg5) || !mPendingContentInsets.equals(args.arg2) || !mPendingStableInsets.equals(args.arg6) || !mPendingVisibleInsets.equals(args.arg3) || !mPendingOutsets.equals(args.arg7);
                mWinFrame.set((Rect) args.arg1);
                mPendingOverscanInsets.set((Rect) args.arg5);
                mPendingContentInsets.set((Rect) args.arg2);
                mPendingStableInsets.set((Rect) args.arg6);
                mPendingVisibleInsets.set((Rect) args.arg3);
                mPendingOutsets.set((Rect) args.arg7);
                mPendingBackDropFrame.set((Rect) args.arg8);
                mForceNextWindowRelayout = args.argi1 != 0;
                mPendingAlwaysConsumeNavBar = args.argi2 != 0;
                args.recycle();
                if (msg.what == MSG_RESIZED_REPORT) {
                    reportNextDraw();
                }
                if (mView != null && framesChanged) {
                    forceLayout(mView);
                }
                requestLayout();
            }
            break;
        case MSG_WINDOW_MOVED:
            if (mAdded) {
                final int w = mWinFrame.width();
                final int h = mWinFrame.height();
                final int l = msg.arg1;
                final int t = msg.arg2;
                mWinFrame.left = l;
                mWinFrame.right = l + w;
                mWinFrame.top = t;
                mWinFrame.bottom = t + h;
                mPendingBackDropFrame.set(mWinFrame);
                maybeHandleWindowMove(mWinFrame);
            }
            break;
        case MSG_WINDOW_FOCUS_CHANGED:
            {
                if (mAdded) {
                    boolean hasWindowFocus = msg.arg1 != 0;
                    mAttachInfo.mHasWindowFocus = hasWindowFocus;
                    profileRendering(hasWindowFocus);
                    if (hasWindowFocus) {
                        boolean inTouchMode = msg.arg2 != 0;
                        ensureTouchModeLocally(inTouchMode);
                        if (mAttachInfo.mThreadedRenderer != null && mSurface.isValid()) {
                            mFullRedrawNeeded = true;
                            try {
                                final WindowManager.LayoutParams lp = mWindowAttributes;
                                final Rect surfaceInsets = lp != null ? lp.surfaceInsets : null;
                                mAttachInfo.mThreadedRenderer.initializeIfNeeded(mWidth, mHeight, mAttachInfo, mSurface, surfaceInsets);
                            } catch (OutOfResourcesException e) {
                                Log.e(mTag, ""OutOfResourcesException locking surface"", e);
                                try {
                                    if (!mWindowSession.outOfMemory(mWindow)) {
                                        Slog.w(mTag, ""No processes killed for memory; killing self"");
                                        Process.killProcess(Process.myPid());
                                    }
                                } catch (RemoteException ex) {
                                }
                                // Retry in a bit.
                                sendMessageDelayed(obtainMessage(msg.what, msg.arg1, msg.arg2), 500);
                                return;
                            }
                        }
                    }
                    mLastWasImTarget = WindowManager.LayoutParams.mayUseInputMethod(mWindowAttributes.flags);
                    InputMethodManager imm = InputMethodManager.peekInstance();
                    if (imm != null && mLastWasImTarget && !isInLocalFocusMode()) {
                        imm.onPreWindowFocus(mView, hasWindowFocus);
                    }
                    if (mView != null) {
                        mAttachInfo.mKeyDispatchState.reset();
                        mView.dispatchWindowFocusChanged(hasWindowFocus);
                        mAttachInfo.mTreeObserver.dispatchOnWindowFocusChange(hasWindowFocus);
                        if (mAttachInfo.mTooltipHost != null) {
                            mAttachInfo.mTooltipHost.hideTooltip();
                        }
                    }
                    // so all of the view state is set up correctly.
                    if (hasWindowFocus) {
                        if (imm != null && mLastWasImTarget && !isInLocalFocusMode()) {
                            imm.onPostWindowFocus(mView, mView.findFocus(), mWindowAttributes.softInputMode, !mHasHadWindowFocus, mWindowAttributes.flags);
                        }
                        // Clear the forward bit.  We can just do this directly, since
                        // the window manager doesn't care about it.
                        mWindowAttributes.softInputMode &= ~WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION;
                        ((WindowManager.LayoutParams) mView.getLayoutParams()).softInputMode &= ~WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION;
                        mHasHadWindowFocus = true;
                    } else {
                        if (mPointerCapture) {
                            handlePointerCaptureChanged(false);
                        }
                    }
                }
            }
            break;
        case MSG_DIE:
            doDie();
            break;
        case MSG_DISPATCH_INPUT_EVENT:
            {
                SomeArgs args = (SomeArgs) msg.obj;
                InputEvent event = (InputEvent) args.arg1;
                InputEventReceiver receiver = (InputEventReceiver) args.arg2;
                enqueueInputEvent(event, receiver, 0, true);
                args.recycle();
            }
            break;
        case MSG_SYNTHESIZE_INPUT_EVENT:
            {
                InputEvent event = (InputEvent) msg.obj;
                enqueueInputEvent(event, null, QueuedInputEvent.FLAG_UNHANDLED, true);
            }
            break;
        case MSG_DISPATCH_KEY_FROM_IME:
            {
                if (LOCAL_LOGV)
                    Log.v(TAG, ""Dispatching key "" + msg.obj + "" from IME to "" + mView);
                KeyEvent event = (KeyEvent) msg.obj;
                if ((event.getFlags() & KeyEvent.FLAG_FROM_SYSTEM) != 0) {
                    // The IME is trying to say this event is from the
                    // system!  Bad bad bad!
                    // noinspection UnusedAssignment
                    event = KeyEvent.changeFlags(event, event.getFlags() & ~KeyEvent.FLAG_FROM_SYSTEM);
                }
                enqueueInputEvent(event, null, QueuedInputEvent.FLAG_DELIVER_POST_IME, true);
            }
            break;
        case MSG_CHECK_FOCUS:
            {
                InputMethodManager imm = InputMethodManager.peekInstance();
                if (imm != null) {
                    imm.checkFocus();
                }
            }
            break;
        case MSG_CLOSE_SYSTEM_DIALOGS:
            {
                if (mView != null) {
                    mView.onCloseSystemDialogs((String) msg.obj);
                }
            }
            break;
        case MSG_DISPATCH_DRAG_EVENT:
        case MSG_DISPATCH_DRAG_LOCATION_EVENT:
            {
                DragEvent event = (DragEvent) msg.obj;
                // only present when this app called startDrag()
                event.mLocalState = mLocalDragState;
                handleDragEvent(event);
            }
            break;
        case MSG_DISPATCH_SYSTEM_UI_VISIBILITY:
            {
                handleDispatchSystemUiVisibilityChanged((SystemUiVisibilityInfo) msg.obj);
            }
            break;
        case MSG_UPDATE_CONFIGURATION:
            {
                Configuration config = (Configuration) msg.obj;
                if (config.isOtherSeqNewer(mLastReportedMergedConfiguration.getMergedConfiguration())) {
                    // If we already have a newer merged config applied - use its global part.
                    config = mLastReportedMergedConfiguration.getGlobalConfiguration();
                }
                // Use the newer global config and last reported override config.
                mPendingMergedConfiguration.setConfiguration(config, mLastReportedMergedConfiguration.getOverrideConfiguration());
                performConfigurationChange(mPendingMergedConfiguration, false, /* force */
                INVALID_DISPLAY);
            }
            break;
        case MSG_CLEAR_ACCESSIBILITY_FOCUS_HOST:
            {
                setAccessibilityFocus(null, null);
            }
            break;
        case MSG_INVALIDATE_WORLD:
            {
                if (mView != null) {
                    invalidateWorld(mView);
                }
            }
            break;
        case MSG_DISPATCH_WINDOW_SHOWN:
            {
                handleDispatchWindowShown();
            }
            break;
        case MSG_REQUEST_KEYBOARD_SHORTCUTS:
            {
                final IResultReceiver receiver = (IResultReceiver) msg.obj;
                final int deviceId = msg.arg1;
                handleRequestKeyboardShortcuts(receiver, deviceId);
            }
            break;
        case MSG_UPDATE_POINTER_ICON:
            {
                MotionEvent event = (MotionEvent) msg.obj;
                resetPointerIcon(event);
            }
            break;
        case MSG_POINTER_CAPTURE_CHANGED:
            {
                final boolean hasCapture = msg.arg1 != 0;
                handlePointerCaptureChanged(hasCapture);
            }
            break;
        case MSG_DRAW_FINISHED:
            {
                pendingDrawFinished();
            }
            break;
    }
}","{
    switch(msg.what) {
        case MSG_INVALIDATE:
            ((View) msg.obj).invalidate();
            break;
        case MSG_INVALIDATE_RECT:
            final View.AttachInfo.InvalidateInfo info = (View.AttachInfo.InvalidateInfo) msg.obj;
            info.target.invalidate(info.left, info.top, info.right, info.bottom);
            info.recycle();
            break;
        case MSG_PROCESS_INPUT_EVENTS:
            mProcessInputEventsScheduled = false;
            doProcessInputEvents();
            break;
        case MSG_DISPATCH_APP_VISIBILITY:
            handleAppVisibility(msg.arg1 != 0);
            break;
        case MSG_DISPATCH_GET_NEW_SURFACE:
            handleGetNewSurface();
            break;
        case MSG_RESIZED:
            {
                // Recycled in the fall through...
                SomeArgs args = (SomeArgs) msg.obj;
                if (mWinFrame.equals(args.arg1) && mPendingOverscanInsets.equals(args.arg5) && mPendingContentInsets.equals(args.arg2) && mPendingStableInsets.equals(args.arg6) && mPendingDisplayCutout.get().equals(args.arg9) && mPendingVisibleInsets.equals(args.arg3) && mPendingOutsets.equals(args.arg7) && mPendingBackDropFrame.equals(args.arg8) && args.arg4 == null && args.argi1 == 0 && mDisplay.getDisplayId() == args.argi3) {
                    break;
                }
            }
        // fall through...
        case MSG_RESIZED_REPORT:
            if (mAdded) {
                SomeArgs args = (SomeArgs) msg.obj;
                final int displayId = args.argi3;
                MergedConfiguration mergedConfiguration = (MergedConfiguration) args.arg4;
                final boolean displayChanged = mDisplay.getDisplayId() != displayId;
                if (!mLastReportedMergedConfiguration.equals(mergedConfiguration)) {
                    // If configuration changed - notify about that and, maybe,
                    // about move to display.
                    performConfigurationChange(mergedConfiguration, false, /* force */
                    displayChanged ? displayId : INVALID_DISPLAY);
                } else if (displayChanged) {
                    // Moved to display without config change - report last applied one.
                    onMovedToDisplay(displayId, mLastConfigurationFromResources);
                }
                final boolean framesChanged = !mWinFrame.equals(args.arg1) || !mPendingOverscanInsets.equals(args.arg5) || !mPendingContentInsets.equals(args.arg2) || !mPendingStableInsets.equals(args.arg6) || !mPendingDisplayCutout.get().equals(args.arg9) || !mPendingVisibleInsets.equals(args.arg3) || !mPendingOutsets.equals(args.arg7);
                mWinFrame.set((Rect) args.arg1);
                mPendingOverscanInsets.set((Rect) args.arg5);
                mPendingContentInsets.set((Rect) args.arg2);
                mPendingStableInsets.set((Rect) args.arg6);
                mPendingDisplayCutout.set((DisplayCutout) args.arg9);
                mPendingVisibleInsets.set((Rect) args.arg3);
                mPendingOutsets.set((Rect) args.arg7);
                mPendingBackDropFrame.set((Rect) args.arg8);
                mForceNextWindowRelayout = args.argi1 != 0;
                mPendingAlwaysConsumeNavBar = args.argi2 != 0;
                args.recycle();
                if (msg.what == MSG_RESIZED_REPORT) {
                    reportNextDraw();
                }
                if (mView != null && framesChanged) {
                    forceLayout(mView);
                }
                requestLayout();
            }
            break;
        case MSG_WINDOW_MOVED:
            if (mAdded) {
                final int w = mWinFrame.width();
                final int h = mWinFrame.height();
                final int l = msg.arg1;
                final int t = msg.arg2;
                mWinFrame.left = l;
                mWinFrame.right = l + w;
                mWinFrame.top = t;
                mWinFrame.bottom = t + h;
                mPendingBackDropFrame.set(mWinFrame);
                maybeHandleWindowMove(mWinFrame);
            }
            break;
        case MSG_WINDOW_FOCUS_CHANGED:
            {
                handleWindowFocusChanged();
            }
            break;
        case MSG_DIE:
            doDie();
            break;
        case MSG_DISPATCH_INPUT_EVENT:
            {
                SomeArgs args = (SomeArgs) msg.obj;
                InputEvent event = (InputEvent) args.arg1;
                InputEventReceiver receiver = (InputEventReceiver) args.arg2;
                enqueueInputEvent(event, receiver, 0, true);
                args.recycle();
            }
            break;
        case MSG_SYNTHESIZE_INPUT_EVENT:
            {
                InputEvent event = (InputEvent) msg.obj;
                enqueueInputEvent(event, null, QueuedInputEvent.FLAG_UNHANDLED, true);
            }
            break;
        case MSG_DISPATCH_KEY_FROM_IME:
            {
                if (LOCAL_LOGV) {
                    Log.v(TAG, ""Dispatching key "" + msg.obj + "" from IME to "" + mView);
                }
                KeyEvent event = (KeyEvent) msg.obj;
                if ((event.getFlags() & KeyEvent.FLAG_FROM_SYSTEM) != 0) {
                    // The IME is trying to say this event is from the
                    // system!  Bad bad bad!
                    // noinspection UnusedAssignment
                    event = KeyEvent.changeFlags(event, event.getFlags() & ~KeyEvent.FLAG_FROM_SYSTEM);
                }
                enqueueInputEvent(event, null, QueuedInputEvent.FLAG_DELIVER_POST_IME, true);
            }
            break;
        case MSG_DISPATCH_KEY_FROM_AUTOFILL:
            {
                if (LOCAL_LOGV) {
                    Log.v(TAG, ""Dispatching key "" + msg.obj + "" from Autofill to "" + mView);
                }
                KeyEvent event = (KeyEvent) msg.obj;
                enqueueInputEvent(event, null, 0, true);
            }
            break;
        case MSG_CHECK_FOCUS:
            {
                InputMethodManager imm = InputMethodManager.peekInstance();
                if (imm != null) {
                    imm.checkFocus();
                }
            }
            break;
        case MSG_CLOSE_SYSTEM_DIALOGS:
            {
                if (mView != null) {
                    mView.onCloseSystemDialogs((String) msg.obj);
                }
            }
            break;
        case MSG_DISPATCH_DRAG_EVENT:
            {
            }
        // fall through
        case MSG_DISPATCH_DRAG_LOCATION_EVENT:
            {
                DragEvent event = (DragEvent) msg.obj;
                // only present when this app called startDrag()
                event.mLocalState = mLocalDragState;
                handleDragEvent(event);
            }
            break;
        case MSG_DISPATCH_SYSTEM_UI_VISIBILITY:
            {
                handleDispatchSystemUiVisibilityChanged((SystemUiVisibilityInfo) msg.obj);
            }
            break;
        case MSG_UPDATE_CONFIGURATION:
            {
                Configuration config = (Configuration) msg.obj;
                if (config.isOtherSeqNewer(mLastReportedMergedConfiguration.getMergedConfiguration())) {
                    // If we already have a newer merged config applied - use its global part.
                    config = mLastReportedMergedConfiguration.getGlobalConfiguration();
                }
                // Use the newer global config and last reported override config.
                mPendingMergedConfiguration.setConfiguration(config, mLastReportedMergedConfiguration.getOverrideConfiguration());
                performConfigurationChange(mPendingMergedConfiguration, false, /* force */
                INVALID_DISPLAY);
            }
            break;
        case MSG_CLEAR_ACCESSIBILITY_FOCUS_HOST:
            {
                setAccessibilityFocus(null, null);
            }
            break;
        case MSG_INVALIDATE_WORLD:
            {
                if (mView != null) {
                    invalidateWorld(mView);
                }
            }
            break;
        case MSG_DISPATCH_WINDOW_SHOWN:
            {
                handleDispatchWindowShown();
            }
            break;
        case MSG_REQUEST_KEYBOARD_SHORTCUTS:
            {
                final IResultReceiver receiver = (IResultReceiver) msg.obj;
                final int deviceId = msg.arg1;
                handleRequestKeyboardShortcuts(receiver, deviceId);
            }
            break;
        case MSG_UPDATE_POINTER_ICON:
            {
                MotionEvent event = (MotionEvent) msg.obj;
                resetPointerIcon(event);
            }
            break;
        case MSG_POINTER_CAPTURE_CHANGED:
            {
                final boolean hasCapture = msg.arg1 != 0;
                handlePointerCaptureChanged(hasCapture);
            }
            break;
        case MSG_DRAW_FINISHED:
            {
                pendingDrawFinished();
            }
            break;
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,,,,
924,<android.content.res.Configuration: int updateFrom(Configuration)>,27,28,<android.content.res.Configuration: int updateFrom(Configuration)>,<android.content.res.Configuration: int updateFrom(Configuration)>,0,"{
    int changed = 0;
    if (delta.fontScale > 0 && fontScale != delta.fontScale) {
        changed |= ActivityInfo.CONFIG_FONT_SCALE;
        fontScale = delta.fontScale;
    }
    if (delta.mcc != 0 && mcc != delta.mcc) {
        changed |= ActivityInfo.CONFIG_MCC;
        mcc = delta.mcc;
    }
    if (delta.mnc != 0 && mnc != delta.mnc) {
        changed |= ActivityInfo.CONFIG_MNC;
        mnc = delta.mnc;
    }
    fixUpLocaleList();
    delta.fixUpLocaleList();
    if (!delta.mLocaleList.isEmpty() && !mLocaleList.equals(delta.mLocaleList)) {
        changed |= ActivityInfo.CONFIG_LOCALE;
        mLocaleList = delta.mLocaleList;
        // delta.locale can't be null, since delta.mLocaleList is not empty.
        if (!delta.locale.equals(locale)) {
            locale = (Locale) delta.locale.clone();
            // If locale has changed, then layout direction is also changed ...
            changed |= ActivityInfo.CONFIG_LAYOUT_DIRECTION;
            // ... and we need to update the layout direction (represented by the first
            // 2 most significant bits in screenLayout).
            setLayoutDirection(locale);
        }
    }
    final int deltaScreenLayoutDir = delta.screenLayout & SCREENLAYOUT_LAYOUTDIR_MASK;
    if (deltaScreenLayoutDir != SCREENLAYOUT_LAYOUTDIR_UNDEFINED && deltaScreenLayoutDir != (screenLayout & SCREENLAYOUT_LAYOUTDIR_MASK)) {
        screenLayout = (screenLayout & ~SCREENLAYOUT_LAYOUTDIR_MASK) | deltaScreenLayoutDir;
        changed |= ActivityInfo.CONFIG_LAYOUT_DIRECTION;
    }
    if (delta.userSetLocale && (!userSetLocale || ((changed & ActivityInfo.CONFIG_LOCALE) != 0))) {
        changed |= ActivityInfo.CONFIG_LOCALE;
        userSetLocale = true;
    }
    if (delta.touchscreen != TOUCHSCREEN_UNDEFINED && touchscreen != delta.touchscreen) {
        changed |= ActivityInfo.CONFIG_TOUCHSCREEN;
        touchscreen = delta.touchscreen;
    }
    if (delta.keyboard != KEYBOARD_UNDEFINED && keyboard != delta.keyboard) {
        changed |= ActivityInfo.CONFIG_KEYBOARD;
        keyboard = delta.keyboard;
    }
    if (delta.keyboardHidden != KEYBOARDHIDDEN_UNDEFINED && keyboardHidden != delta.keyboardHidden) {
        changed |= ActivityInfo.CONFIG_KEYBOARD_HIDDEN;
        keyboardHidden = delta.keyboardHidden;
    }
    if (delta.hardKeyboardHidden != HARDKEYBOARDHIDDEN_UNDEFINED && hardKeyboardHidden != delta.hardKeyboardHidden) {
        changed |= ActivityInfo.CONFIG_KEYBOARD_HIDDEN;
        hardKeyboardHidden = delta.hardKeyboardHidden;
    }
    if (delta.navigation != NAVIGATION_UNDEFINED && navigation != delta.navigation) {
        changed |= ActivityInfo.CONFIG_NAVIGATION;
        navigation = delta.navigation;
    }
    if (delta.navigationHidden != NAVIGATIONHIDDEN_UNDEFINED && navigationHidden != delta.navigationHidden) {
        changed |= ActivityInfo.CONFIG_KEYBOARD_HIDDEN;
        navigationHidden = delta.navigationHidden;
    }
    if (delta.orientation != ORIENTATION_UNDEFINED && orientation != delta.orientation) {
        changed |= ActivityInfo.CONFIG_ORIENTATION;
        orientation = delta.orientation;
    }
    if (((delta.screenLayout & SCREENLAYOUT_SIZE_MASK) != SCREENLAYOUT_SIZE_UNDEFINED) && (delta.screenLayout & SCREENLAYOUT_SIZE_MASK) != (screenLayout & SCREENLAYOUT_SIZE_MASK)) {
        changed |= ActivityInfo.CONFIG_SCREEN_LAYOUT;
        screenLayout = (screenLayout & ~SCREENLAYOUT_SIZE_MASK) | (delta.screenLayout & SCREENLAYOUT_SIZE_MASK);
    }
    if (((delta.screenLayout & SCREENLAYOUT_LONG_MASK) != SCREENLAYOUT_LONG_UNDEFINED) && (delta.screenLayout & SCREENLAYOUT_LONG_MASK) != (screenLayout & SCREENLAYOUT_LONG_MASK)) {
        changed |= ActivityInfo.CONFIG_SCREEN_LAYOUT;
        screenLayout = (screenLayout & ~SCREENLAYOUT_LONG_MASK) | (delta.screenLayout & SCREENLAYOUT_LONG_MASK);
    }
    if (((delta.screenLayout & SCREENLAYOUT_ROUND_MASK) != SCREENLAYOUT_ROUND_UNDEFINED) && (delta.screenLayout & SCREENLAYOUT_ROUND_MASK) != (screenLayout & SCREENLAYOUT_ROUND_MASK)) {
        changed |= ActivityInfo.CONFIG_SCREEN_LAYOUT;
        screenLayout = (screenLayout & ~SCREENLAYOUT_ROUND_MASK) | (delta.screenLayout & SCREENLAYOUT_ROUND_MASK);
    }
    if ((delta.screenLayout & SCREENLAYOUT_COMPAT_NEEDED) != (screenLayout & SCREENLAYOUT_COMPAT_NEEDED) && delta.screenLayout != 0) {
        changed |= ActivityInfo.CONFIG_SCREEN_LAYOUT;
        screenLayout = (screenLayout & ~SCREENLAYOUT_COMPAT_NEEDED) | (delta.screenLayout & SCREENLAYOUT_COMPAT_NEEDED);
    }
    if (((delta.colorMode & COLOR_MODE_WIDE_COLOR_GAMUT_MASK) != COLOR_MODE_WIDE_COLOR_GAMUT_UNDEFINED) && (delta.colorMode & COLOR_MODE_WIDE_COLOR_GAMUT_MASK) != (colorMode & COLOR_MODE_WIDE_COLOR_GAMUT_MASK)) {
        changed |= ActivityInfo.CONFIG_COLOR_MODE;
        colorMode = (colorMode & ~COLOR_MODE_WIDE_COLOR_GAMUT_MASK) | (delta.colorMode & COLOR_MODE_WIDE_COLOR_GAMUT_MASK);
    }
    if (((delta.colorMode & COLOR_MODE_HDR_MASK) != COLOR_MODE_HDR_UNDEFINED) && (delta.colorMode & COLOR_MODE_HDR_MASK) != (colorMode & COLOR_MODE_HDR_MASK)) {
        changed |= ActivityInfo.CONFIG_COLOR_MODE;
        colorMode = (colorMode & ~COLOR_MODE_HDR_MASK) | (delta.colorMode & COLOR_MODE_HDR_MASK);
    }
    if (delta.uiMode != (UI_MODE_TYPE_UNDEFINED | UI_MODE_NIGHT_UNDEFINED) && uiMode != delta.uiMode) {
        changed |= ActivityInfo.CONFIG_UI_MODE;
        if ((delta.uiMode & UI_MODE_TYPE_MASK) != UI_MODE_TYPE_UNDEFINED) {
            uiMode = (uiMode & ~UI_MODE_TYPE_MASK) | (delta.uiMode & UI_MODE_TYPE_MASK);
        }
        if ((delta.uiMode & UI_MODE_NIGHT_MASK) != UI_MODE_NIGHT_UNDEFINED) {
            uiMode = (uiMode & ~UI_MODE_NIGHT_MASK) | (delta.uiMode & UI_MODE_NIGHT_MASK);
        }
    }
    if (delta.screenWidthDp != SCREEN_WIDTH_DP_UNDEFINED && screenWidthDp != delta.screenWidthDp) {
        changed |= ActivityInfo.CONFIG_SCREEN_SIZE;
        screenWidthDp = delta.screenWidthDp;
    }
    if (delta.screenHeightDp != SCREEN_HEIGHT_DP_UNDEFINED && screenHeightDp != delta.screenHeightDp) {
        changed |= ActivityInfo.CONFIG_SCREEN_SIZE;
        screenHeightDp = delta.screenHeightDp;
    }
    if (delta.smallestScreenWidthDp != SMALLEST_SCREEN_WIDTH_DP_UNDEFINED && smallestScreenWidthDp != delta.smallestScreenWidthDp) {
        changed |= ActivityInfo.CONFIG_SMALLEST_SCREEN_SIZE;
        smallestScreenWidthDp = delta.smallestScreenWidthDp;
    }
    if (delta.densityDpi != DENSITY_DPI_UNDEFINED && densityDpi != delta.densityDpi) {
        changed |= ActivityInfo.CONFIG_DENSITY;
        densityDpi = delta.densityDpi;
    }
    if (delta.compatScreenWidthDp != SCREEN_WIDTH_DP_UNDEFINED) {
        compatScreenWidthDp = delta.compatScreenWidthDp;
    }
    if (delta.compatScreenHeightDp != SCREEN_HEIGHT_DP_UNDEFINED) {
        compatScreenHeightDp = delta.compatScreenHeightDp;
    }
    if (delta.compatSmallestScreenWidthDp != SMALLEST_SCREEN_WIDTH_DP_UNDEFINED) {
        compatSmallestScreenWidthDp = delta.compatSmallestScreenWidthDp;
    }
    if (delta.appBounds != null && !delta.appBounds.equals(appBounds)) {
        changed |= ActivityInfo.CONFIG_SCREEN_SIZE;
        setAppBounds(delta.appBounds);
    }
    if (delta.assetsSeq != ASSETS_SEQ_UNDEFINED && delta.assetsSeq != assetsSeq) {
        changed |= ActivityInfo.CONFIG_ASSETS_PATHS;
        assetsSeq = delta.assetsSeq;
    }
    if (delta.seq != 0) {
        seq = delta.seq;
    }
    return changed;
}","{
    int changed = 0;
    if (delta.fontScale > 0 && fontScale != delta.fontScale) {
        changed |= ActivityInfo.CONFIG_FONT_SCALE;
        fontScale = delta.fontScale;
    }
    if (delta.mcc != 0 && mcc != delta.mcc) {
        changed |= ActivityInfo.CONFIG_MCC;
        mcc = delta.mcc;
    }
    if (delta.mnc != 0 && mnc != delta.mnc) {
        changed |= ActivityInfo.CONFIG_MNC;
        mnc = delta.mnc;
    }
    fixUpLocaleList();
    delta.fixUpLocaleList();
    if (!delta.mLocaleList.isEmpty() && !mLocaleList.equals(delta.mLocaleList)) {
        changed |= ActivityInfo.CONFIG_LOCALE;
        mLocaleList = delta.mLocaleList;
        // delta.locale can't be null, since delta.mLocaleList is not empty.
        if (!delta.locale.equals(locale)) {
            locale = (Locale) delta.locale.clone();
            // If locale has changed, then layout direction is also changed ...
            changed |= ActivityInfo.CONFIG_LAYOUT_DIRECTION;
            // ... and we need to update the layout direction (represented by the first
            // 2 most significant bits in screenLayout).
            setLayoutDirection(locale);
        }
    }
    final int deltaScreenLayoutDir = delta.screenLayout & SCREENLAYOUT_LAYOUTDIR_MASK;
    if (deltaScreenLayoutDir != SCREENLAYOUT_LAYOUTDIR_UNDEFINED && deltaScreenLayoutDir != (screenLayout & SCREENLAYOUT_LAYOUTDIR_MASK)) {
        screenLayout = (screenLayout & ~SCREENLAYOUT_LAYOUTDIR_MASK) | deltaScreenLayoutDir;
        changed |= ActivityInfo.CONFIG_LAYOUT_DIRECTION;
    }
    if (delta.userSetLocale && (!userSetLocale || ((changed & ActivityInfo.CONFIG_LOCALE) != 0))) {
        changed |= ActivityInfo.CONFIG_LOCALE;
        userSetLocale = true;
    }
    if (delta.touchscreen != TOUCHSCREEN_UNDEFINED && touchscreen != delta.touchscreen) {
        changed |= ActivityInfo.CONFIG_TOUCHSCREEN;
        touchscreen = delta.touchscreen;
    }
    if (delta.keyboard != KEYBOARD_UNDEFINED && keyboard != delta.keyboard) {
        changed |= ActivityInfo.CONFIG_KEYBOARD;
        keyboard = delta.keyboard;
    }
    if (delta.keyboardHidden != KEYBOARDHIDDEN_UNDEFINED && keyboardHidden != delta.keyboardHidden) {
        changed |= ActivityInfo.CONFIG_KEYBOARD_HIDDEN;
        keyboardHidden = delta.keyboardHidden;
    }
    if (delta.hardKeyboardHidden != HARDKEYBOARDHIDDEN_UNDEFINED && hardKeyboardHidden != delta.hardKeyboardHidden) {
        changed |= ActivityInfo.CONFIG_KEYBOARD_HIDDEN;
        hardKeyboardHidden = delta.hardKeyboardHidden;
    }
    if (delta.navigation != NAVIGATION_UNDEFINED && navigation != delta.navigation) {
        changed |= ActivityInfo.CONFIG_NAVIGATION;
        navigation = delta.navigation;
    }
    if (delta.navigationHidden != NAVIGATIONHIDDEN_UNDEFINED && navigationHidden != delta.navigationHidden) {
        changed |= ActivityInfo.CONFIG_KEYBOARD_HIDDEN;
        navigationHidden = delta.navigationHidden;
    }
    if (delta.orientation != ORIENTATION_UNDEFINED && orientation != delta.orientation) {
        changed |= ActivityInfo.CONFIG_ORIENTATION;
        orientation = delta.orientation;
    }
    if (((delta.screenLayout & SCREENLAYOUT_SIZE_MASK) != SCREENLAYOUT_SIZE_UNDEFINED) && (delta.screenLayout & SCREENLAYOUT_SIZE_MASK) != (screenLayout & SCREENLAYOUT_SIZE_MASK)) {
        changed |= ActivityInfo.CONFIG_SCREEN_LAYOUT;
        screenLayout = (screenLayout & ~SCREENLAYOUT_SIZE_MASK) | (delta.screenLayout & SCREENLAYOUT_SIZE_MASK);
    }
    if (((delta.screenLayout & SCREENLAYOUT_LONG_MASK) != SCREENLAYOUT_LONG_UNDEFINED) && (delta.screenLayout & SCREENLAYOUT_LONG_MASK) != (screenLayout & SCREENLAYOUT_LONG_MASK)) {
        changed |= ActivityInfo.CONFIG_SCREEN_LAYOUT;
        screenLayout = (screenLayout & ~SCREENLAYOUT_LONG_MASK) | (delta.screenLayout & SCREENLAYOUT_LONG_MASK);
    }
    if (((delta.screenLayout & SCREENLAYOUT_ROUND_MASK) != SCREENLAYOUT_ROUND_UNDEFINED) && (delta.screenLayout & SCREENLAYOUT_ROUND_MASK) != (screenLayout & SCREENLAYOUT_ROUND_MASK)) {
        changed |= ActivityInfo.CONFIG_SCREEN_LAYOUT;
        screenLayout = (screenLayout & ~SCREENLAYOUT_ROUND_MASK) | (delta.screenLayout & SCREENLAYOUT_ROUND_MASK);
    }
    if ((delta.screenLayout & SCREENLAYOUT_COMPAT_NEEDED) != (screenLayout & SCREENLAYOUT_COMPAT_NEEDED) && delta.screenLayout != 0) {
        changed |= ActivityInfo.CONFIG_SCREEN_LAYOUT;
        screenLayout = (screenLayout & ~SCREENLAYOUT_COMPAT_NEEDED) | (delta.screenLayout & SCREENLAYOUT_COMPAT_NEEDED);
    }
    if (((delta.colorMode & COLOR_MODE_WIDE_COLOR_GAMUT_MASK) != COLOR_MODE_WIDE_COLOR_GAMUT_UNDEFINED) && (delta.colorMode & COLOR_MODE_WIDE_COLOR_GAMUT_MASK) != (colorMode & COLOR_MODE_WIDE_COLOR_GAMUT_MASK)) {
        changed |= ActivityInfo.CONFIG_COLOR_MODE;
        colorMode = (colorMode & ~COLOR_MODE_WIDE_COLOR_GAMUT_MASK) | (delta.colorMode & COLOR_MODE_WIDE_COLOR_GAMUT_MASK);
    }
    if (((delta.colorMode & COLOR_MODE_HDR_MASK) != COLOR_MODE_HDR_UNDEFINED) && (delta.colorMode & COLOR_MODE_HDR_MASK) != (colorMode & COLOR_MODE_HDR_MASK)) {
        changed |= ActivityInfo.CONFIG_COLOR_MODE;
        colorMode = (colorMode & ~COLOR_MODE_HDR_MASK) | (delta.colorMode & COLOR_MODE_HDR_MASK);
    }
    if (delta.uiMode != (UI_MODE_TYPE_UNDEFINED | UI_MODE_NIGHT_UNDEFINED) && uiMode != delta.uiMode) {
        changed |= ActivityInfo.CONFIG_UI_MODE;
        if ((delta.uiMode & UI_MODE_TYPE_MASK) != UI_MODE_TYPE_UNDEFINED) {
            uiMode = (uiMode & ~UI_MODE_TYPE_MASK) | (delta.uiMode & UI_MODE_TYPE_MASK);
        }
        if ((delta.uiMode & UI_MODE_NIGHT_MASK) != UI_MODE_NIGHT_UNDEFINED) {
            uiMode = (uiMode & ~UI_MODE_NIGHT_MASK) | (delta.uiMode & UI_MODE_NIGHT_MASK);
        }
    }
    if (delta.screenWidthDp != SCREEN_WIDTH_DP_UNDEFINED && screenWidthDp != delta.screenWidthDp) {
        changed |= ActivityInfo.CONFIG_SCREEN_SIZE;
        screenWidthDp = delta.screenWidthDp;
    }
    if (delta.screenHeightDp != SCREEN_HEIGHT_DP_UNDEFINED && screenHeightDp != delta.screenHeightDp) {
        changed |= ActivityInfo.CONFIG_SCREEN_SIZE;
        screenHeightDp = delta.screenHeightDp;
    }
    if (delta.smallestScreenWidthDp != SMALLEST_SCREEN_WIDTH_DP_UNDEFINED && smallestScreenWidthDp != delta.smallestScreenWidthDp) {
        changed |= ActivityInfo.CONFIG_SMALLEST_SCREEN_SIZE;
        smallestScreenWidthDp = delta.smallestScreenWidthDp;
    }
    if (delta.densityDpi != DENSITY_DPI_UNDEFINED && densityDpi != delta.densityDpi) {
        changed |= ActivityInfo.CONFIG_DENSITY;
        densityDpi = delta.densityDpi;
    }
    if (delta.compatScreenWidthDp != SCREEN_WIDTH_DP_UNDEFINED) {
        compatScreenWidthDp = delta.compatScreenWidthDp;
    }
    if (delta.compatScreenHeightDp != SCREEN_HEIGHT_DP_UNDEFINED) {
        compatScreenHeightDp = delta.compatScreenHeightDp;
    }
    if (delta.compatSmallestScreenWidthDp != SMALLEST_SCREEN_WIDTH_DP_UNDEFINED) {
        compatSmallestScreenWidthDp = delta.compatSmallestScreenWidthDp;
    }
    if (delta.assetsSeq != ASSETS_SEQ_UNDEFINED && delta.assetsSeq != assetsSeq) {
        changed |= ActivityInfo.CONFIG_ASSETS_PATHS;
        assetsSeq = delta.assetsSeq;
    }
    if (delta.seq != 0) {
        seq = delta.seq;
    }
    if (windowConfiguration.updateFrom(delta.windowConfiguration) != 0) {
        changed |= ActivityInfo.CONFIG_WINDOW_CONFIGURATION;
    }
    return changed;
}",1,"/**
 * Copies the fields from delta into this Configuration object, keeping
 * track of which ones have changed. Any undefined fields in {@code delta}
 * are ignored and not copied in to the current Configuration.
 *
 * @return a bit mask of the changed fields, as per {@link #diff}
 */
","/**
 * Copies the fields from delta into this Configuration object, keeping
 * track of which ones have changed. Any undefined fields in {@code delta}
 * are ignored and not copied in to the current Configuration.
 *
 * @return a bit mask of the changed fields, as per {@link #diff}
 */
",-1,[@Config],[@Config],-1,-1,-1,-1,-1,-1,,,,
925,<android.widget.Editor.SelectionHandleView: boolean onTouchEvent(MotionEvent)>,27,28,<android.widget.Editor.SelectionHandleView: boolean onTouchEvent(MotionEvent)>,<android.widget.Editor.SelectionHandleView: boolean onTouchEvent(MotionEvent)>,0,"{
    boolean superResult = super.onTouchEvent(event);
    if (event.getActionMasked() == MotionEvent.ACTION_DOWN) {
        // Reset the touch word offset and x value when the user
        // re-engages the handle.
        mTouchWordDelta = 0.0f;
        mPrevX = UNSET_X_VALUE;
    }
    return superResult;
}","{
    boolean superResult = super.onTouchEvent(event);
    switch(event.getActionMasked()) {
        case MotionEvent.ACTION_DOWN:
            // Reset the touch word offset and x value when the user
            // re-engages the handle.
            mTouchWordDelta = 0.0f;
            mPrevX = UNSET_X_VALUE;
            updateMagnifier(event);
            break;
        case MotionEvent.ACTION_MOVE:
            updateMagnifier(event);
            break;
        case MotionEvent.ACTION_UP:
        case MotionEvent.ACTION_CANCEL:
            dismissMagnifier();
            break;
    }
    return superResult;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,4",0,"The control dependency has been changed from a simple if statement to a switch statement with added cases and associated actions (updateMagnifier(event), dismissMagnifier()), and method calls have been introduced inside the control flow, which are considered Other statement changed. Therefore, the code change type is 3,4.","Despite the changes in the control flow and the addition of method calls, the final return value is still coming only from `super.onTouchEvent(event)`, which has not been changed between versions. Therefore, there is no Compatibility Issue as the return value and the behavior of exception handling remain the same; hence, the CI type is 0."
926,<android.view.textclassifier.TextSelection.Builder: TextSelection build()>,27,28,<android.view.textclassifier.TextSelection.Builder: TextSelection build()>,<android.view.textclassifier.TextSelection.Builder: TextSelection build()>,0,"{
    return new TextSelection(mStartIndex, mEndIndex, mEntityConfidence, mLogSource, mVersionInfo);
}","{
    return new TextSelection(mStartIndex, mEndIndex, mEntityConfidence, mId);
}",1,"/**
 * Builds and returns {@link TextSelection} object.
 */
","/**
 * Builds and returns {@link TextSelection} object.
 */
",-1,,[@NonNull],-1,-1,-1,-1,-1,-1,"4,5",1,"The constructor for `TextSelection` has changed in terms of the parameters it takes; it no longer includes mLogSource and mVersionInfo, but now includes mId. Therefore, the dependent API has changed, which corresponds to code change type 4. Also, because new member variables are used for the construction, this corresponds to a dependent API change, which is code change type 5.","Since the constructor parameters for `TextSelection` have changed, the constructed `TextSelection` object would potentially have different member values, thus the API potentially returns a different value. This corresponds to a compatibility issue of type 1."
927,<android.widget.TextView: boolean onDragEvent(DragEvent)>,27,28,<android.widget.TextView: boolean onDragEvent(DragEvent)>,<android.widget.TextView: boolean onDragEvent(DragEvent)>,0,"{
    switch(event.getAction()) {
        case DragEvent.ACTION_DRAG_STARTED:
            return mEditor != null && mEditor.hasInsertionController();
        case DragEvent.ACTION_DRAG_ENTERED:
            TextView.this.requestFocus();
            return true;
        case DragEvent.ACTION_DRAG_LOCATION:
            if (mText instanceof Spannable) {
                final int offset = getOffsetForPosition(event.getX(), event.getY());
                Selection.setSelection((Spannable) mText, offset);
            }
            return true;
        case DragEvent.ACTION_DROP:
            if (mEditor != null)
                mEditor.onDrop(event);
            return true;
        case DragEvent.ACTION_DRAG_ENDED:
        case DragEvent.ACTION_DRAG_EXITED:
        default:
            return true;
    }
}","{
    switch(event.getAction()) {
        case DragEvent.ACTION_DRAG_STARTED:
            return mEditor != null && mEditor.hasInsertionController();
        case DragEvent.ACTION_DRAG_ENTERED:
            TextView.this.requestFocus();
            return true;
        case DragEvent.ACTION_DRAG_LOCATION:
            if (mText instanceof Spannable) {
                final int offset = getOffsetForPosition(event.getX(), event.getY());
                Selection.setSelection(mSpannable, offset);
            }
            return true;
        case DragEvent.ACTION_DROP:
            if (mEditor != null)
                mEditor.onDrop(event);
            return true;
        case DragEvent.ACTION_DRAG_ENDED:
        case DragEvent.ACTION_DRAG_EXITED:
        default:
            return true;
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,0,0,"There are no changes in the implementations between the early and late versions, as the code inside the method body is identical. ","Since there are no changes in the code, there cannot be any compatibility issues between the two versions."
928,<android.app.Dialog: void show()>,27,28,<android.app.Dialog: void show()>,<android.app.Dialog: void show()>,0,"{
    if (mShowing) {
        if (mDecor != null) {
            if (mWindow.hasFeature(Window.FEATURE_ACTION_BAR)) {
                mWindow.invalidatePanelMenu(Window.FEATURE_ACTION_BAR);
            }
            mDecor.setVisibility(View.VISIBLE);
        }
        return;
    }
    mCanceled = false;
    if (!mCreated) {
        dispatchOnCreate(null);
    } else {
        // Fill the DecorView in on any configuration changes that
        // may have occured while it was removed from the WindowManager.
        final Configuration config = mContext.getResources().getConfiguration();
        mWindow.getDecorView().dispatchConfigurationChanged(config);
    }
    onStart();
    mDecor = mWindow.getDecorView();
    if (mActionBar == null && mWindow.hasFeature(Window.FEATURE_ACTION_BAR)) {
        final ApplicationInfo info = mContext.getApplicationInfo();
        mWindow.setDefaultIcon(info.icon);
        mWindow.setDefaultLogo(info.logo);
        mActionBar = new WindowDecorActionBar(this);
    }
    WindowManager.LayoutParams l = mWindow.getAttributes();
    if ((l.softInputMode & WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION) == 0) {
        WindowManager.LayoutParams nl = new WindowManager.LayoutParams();
        nl.copyFrom(l);
        nl.softInputMode |= WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION;
        l = nl;
    }
    mWindowManager.addView(mDecor, l);
    mShowing = true;
    sendShowMessage();
}","{
    if (mShowing) {
        if (mDecor != null) {
            if (mWindow.hasFeature(Window.FEATURE_ACTION_BAR)) {
                mWindow.invalidatePanelMenu(Window.FEATURE_ACTION_BAR);
            }
            mDecor.setVisibility(View.VISIBLE);
        }
        return;
    }
    mCanceled = false;
    if (!mCreated) {
        dispatchOnCreate(null);
    } else {
        // Fill the DecorView in on any configuration changes that
        // may have occured while it was removed from the WindowManager.
        final Configuration config = mContext.getResources().getConfiguration();
        mWindow.getDecorView().dispatchConfigurationChanged(config);
    }
    onStart();
    mDecor = mWindow.getDecorView();
    if (mActionBar == null && mWindow.hasFeature(Window.FEATURE_ACTION_BAR)) {
        final ApplicationInfo info = mContext.getApplicationInfo();
        mWindow.setDefaultIcon(info.icon);
        mWindow.setDefaultLogo(info.logo);
        mActionBar = new WindowDecorActionBar(this);
    }
    WindowManager.LayoutParams l = mWindow.getAttributes();
    boolean restoreSoftInputMode = false;
    if ((l.softInputMode & WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION) == 0) {
        l.softInputMode |= WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION;
        restoreSoftInputMode = true;
    }
    mWindowManager.addView(mDecor, l);
    if (restoreSoftInputMode) {
        l.softInputMode &= ~WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION;
    }
    mShowing = true;
    sendShowMessage();
}",1,"/**
 * Start the dialog and display it on screen.  The window is placed in the
 * application layer and opaque.  Note that you should not override this
 * method to do initialization when the dialog is shown, instead implement
 * that in {@link #onStart}.
 */
","/**
 * Start the dialog and display it on screen.  The window is placed in the
 * application layer and opaque.  Note that you should not override this
 * method to do initialization when the dialog is shown, instead implement
 * that in {@link #onStart}.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",0,"The control dependency has changed regarding how the softInputMode flag is modified in the WindowManager.LayoutParams `l`. There's also an addition of a boolean flag `restoreSoftInputMode` to keep track of whether the softInputMode was altered, which shows an 'Other statement changed'. ","There is no Compatibility Issue as the end result of the WindowManager.LayoutParams `l` being passed to mWindowManager.addView(mDecor, l); remains unchanged within control flow. The addition of the boolean flag `restoreSoftInputMode` does not affect the external behavior of the `show()` method; it's an internal change to restore `softInputMode` after the view is added, which has no impact on the API contract."
929,"<android.appwidget.AppWidgetHostView: Rect getDefaultPaddingForWidget(Context,ComponentName,Rect)>",27,28,"<android.appwidget.AppWidgetHostView: Rect getDefaultPaddingForWidget(Context,ComponentName,Rect)>","<android.appwidget.AppWidgetHostView: Rect getDefaultPaddingForWidget(Context,ComponentName,Rect)>",0,"{
    PackageManager packageManager = context.getPackageManager();
    ApplicationInfo appInfo;
    if (padding == null) {
        padding = new Rect(0, 0, 0, 0);
    } else {
        padding.set(0, 0, 0, 0);
    }
    try {
        appInfo = packageManager.getApplicationInfo(component.getPackageName(), 0);
    } catch (NameNotFoundException e) {
        // if we can't find the package, return 0 padding
        return padding;
    }
    if (appInfo.targetSdkVersion >= Build.VERSION_CODES.ICE_CREAM_SANDWICH) {
        Resources r = context.getResources();
        padding.left = r.getDimensionPixelSize(com.android.internal.R.dimen.default_app_widget_padding_left);
        padding.right = r.getDimensionPixelSize(com.android.internal.R.dimen.default_app_widget_padding_right);
        padding.top = r.getDimensionPixelSize(com.android.internal.R.dimen.default_app_widget_padding_top);
        padding.bottom = r.getDimensionPixelSize(com.android.internal.R.dimen.default_app_widget_padding_bottom);
    }
    return padding;
}","{
    ApplicationInfo appInfo = null;
    try {
        appInfo = context.getPackageManager().getApplicationInfo(component.getPackageName(), 0);
    } catch (NameNotFoundException e) {
    // if we can't find the package, ignore
    }
    return getDefaultPaddingForWidget(context, appInfo, padding);
}",1,"/**
 * As of ICE_CREAM_SANDWICH we are automatically adding padding to widgets targeting
 * ICE_CREAM_SANDWICH and higher. The new widget design guidelines strongly recommend
 * that widget developers do not add extra padding to their widgets. This will help
 * achieve consistency among widgets.
 *
 * Note: this method is only needed by developers of AppWidgetHosts. The method is provided in
 * order for the AppWidgetHost to account for the automatic padding when computing the number
 * of cells to allocate to a particular widget.
 *
 * @param context the current context
 * @param component the component name of the widget
 * @param padding Rect in which to place the output, if null, a new Rect will be allocated and
 * returned
 * @return default padding for this widget, in pixels
 */
","/**
 * As of ICE_CREAM_SANDWICH we are automatically adding padding to widgets targeting
 * ICE_CREAM_SANDWICH and higher. The new widget design guidelines strongly recommend
 * that widget developers do not add extra padding to their widgets. This will help
 * achieve consistency among widgets.
 *
 * Note: this method is only needed by developers of AppWidgetHosts. The method is provided in
 * order for the AppWidgetHost to account for the automatic padding when computing the number
 * of cells to allocate to a particular widget.
 *
 * @param context the current context
 * @param component the component name of the widget
 * @param padding Rect in which to place the output, if null, a new Rect will be allocated and
 * returned
 * @return default padding for this widget, in pixels
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3,4,5",1,"The method implementation has changed significantly. The entire block of code handling padding initialization based on 'appInfo.targetSdkVersion' has been removed and is replaced with a single call to a new or different method getDefaultPaddingForWidget(context, appInfo, padding). There is a control dependency change because the conditional check on 'appInfo.targetSdkVersion' has been removed and the flow to set the padding values is no longer present. In addition, the handling of the NameNotFoundException has changed, as the early version returns 'padding' with zeroed values if the exception occurs, while the late version simply ignores the exception and proceeds to call 'getDefaultPaddingForWidget' potentially with a null 'appInfo'. The exception handling and the default padding setup now depends on the new getDefaultPaddingForWidget method. If 'getDefaultPaddingForWidget' behaves differently or expects 'appInfo' to be non-null, this could result in different behavior. The change type is 1,3,4,5 because there are changes in the return statement, control dependency, other statements, and a dependent API.","There is a potential compatibility issue as the late version method delegates to another method 'getDefaultPaddingForWidget', which might not handle a null 'appInfo' as the old code did, potentially resulting in different return values or exception handling behavior, specifically if the package is not found. The Compatibility Issue type is 1."
930,<android.bluetooth.le.AdvertisingSetParameters: boolean includeTxPower()>,27,28,<android.bluetooth.le.AdvertisingSetParameters: boolean includeTxPower()>,<android.bluetooth.le.AdvertisingSetParameters: boolean includeTxPower()>,0,"{
    return includeTxPower;
}","{
    return mIncludeTxPower;
}",1,"/**
 * Returns whether the TX Power will be included.
 */
","/**
 * Returns whether the TX Power will be included.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The variable name for the return statement has changed from includeTxPower to mIncludeTxPower, which falls under the ""Other statement changed"" category.","Despite the variable name change, this is simply a change in the internal representation and does not affect the API's behavior provided that the new variable mIncludeTxPower is correctly maintaining the previous state of includeTxPower. Hence, there is no Compatibility Issue."
934,<android.companion.CompanionDeviceManager.CallbackProxy: void onActivityDestroyed(Activity)>,27,28,<android.companion.CompanionDeviceManager.CallbackProxy: void onActivityDestroyed(Activity)>,<android.companion.CompanionDeviceManager.CallbackProxy: void onActivityDestroyed(Activity)>,0,"{
    if (activity != getActivity())
        return;
    try {
        mService.stopScan(mRequest, this, getCallingPackage());
    } catch (RemoteException e) {
        e.rethrowFromSystemServer();
    }
    getActivity().getApplication().unregisterActivityLifecycleCallbacks(this);
    mCallback = null;
    mHandler = null;
    mRequest = null;
}","{
    synchronized (mLock) {
        if (activity != getActivity())
            return;
        try {
            mService.stopScan(mRequest, this, getCallingPackage());
        } catch (RemoteException e) {
            e.rethrowFromSystemServer();
        }
        getActivity().getApplication().unregisterActivityLifecycleCallbacks(this);
        mCallback = null;
        mHandler = null;
        mRequest = null;
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,3,0,"A synchronized block has been added to wrap the entirety of the method's implementation, so the change type is 3 (Control dependency changed).","The addition of the synchronized block does not change the behavior of the API in terms of the values it returns or the exceptions it throws. It merely adds thread safety to the execution of the method body. Since the method's functionality from the perspective of an API consumer remains unchanged, there is no Compatibility Issue, and CI type is 0."
935,<android.bluetooth.le.AdvertisingSet: void setAdvertisingParameters(AdvertisingSetParameters)>,27,28,<android.bluetooth.le.AdvertisingSet: void setAdvertisingParameters(AdvertisingSetParameters)>,<android.bluetooth.le.AdvertisingSet: void setAdvertisingParameters(AdvertisingSetParameters)>,0,"{
    try {
        gatt.setAdvertisingParameters(this.advertiserId, parameters);
    } catch (RemoteException e) {
        Log.e(TAG, ""remote exception - "", e);
    }
}","{
    try {
        mGatt.setAdvertisingParameters(mAdvertiserId, parameters);
    } catch (RemoteException e) {
        Log.e(TAG, ""remote exception - "", e);
    }
}",1,"/**
 * Update advertising parameters associated with this AdvertisingSet. Must be called when
 * advertising is not active. This method returns immediately, the operation status is delivered
 * through {@code callback.onAdvertisingParametersUpdated}.
 *
 * @param parameters advertising set parameters.
 */
","/**
 * Update advertising parameters associated with this AdvertisingSet. Must be called when
 * advertising is not active. This method returns immediately, the operation status is delivered
 * through {@code callback.onAdvertisingParametersUpdated}.
 *
 * @param parameters advertising set parameters.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The changes in the implementation consist of renaming variables: `gatt` to `mGatt` and `advertiserId` to `mAdvertiserId`. There are no changes to the logic or control flow of the method, so the code change type is 4.","Because only the names of the variables are altered without modifying the control flow, return statements, or exception handling, there's no Compatibility Issue. The method behaves identically from the caller's perspective; thus, the CI situation is 0."
936,"<android.text.TextUtils: String join(CharSequence,Object[])>",27,28,"<android.text.TextUtils: String join(CharSequence,Object[])>","<android.text.TextUtils: String join(CharSequence,Object[])>",0,"{
    StringBuilder sb = new StringBuilder();
    boolean firstTime = true;
    for (Object token : tokens) {
        if (firstTime) {
            firstTime = false;
        } else {
            sb.append(delimiter);
        }
        sb.append(token);
    }
    return sb.toString();
}","{
    final int length = tokens.length;
    if (length == 0) {
        return """";
    }
    final StringBuilder sb = new StringBuilder();
    sb.append(tokens[0]);
    for (int i = 1; i < length; i++) {
        sb.append(delimiter);
        sb.append(tokens[i]);
    }
    return sb.toString();
}",1,"/**
 * Returns a string containing the tokens joined by delimiters.
 * @param tokens an array objects to be joined. Strings will be formed from
 * the objects by calling object.toString().
 */
","/**
 * Returns a string containing the tokens joined by delimiters.
 *
 * @param delimiter a CharSequence that will be inserted between the tokens. If null, the string
 * ""null"" will be used as the delimiter.
 * @param tokens an array objects to be joined. Strings will be formed from the objects by
 * calling object.toString(). If tokens is null, a NullPointerException will be thrown. If
 * tokens is an empty array, an empty string will be returned.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3,4",1,"The late implementation introduces a new control flow to handle the case when tokens is empty, and it also changes the way the StringBuilder is filled. A new local variable for the length of the array is introduced and the for loop starts from 1 instead of 0 because the first token is now appended before the loop. So, the code change type is 1,3,4.","The late implementation handles an empty array differently and appends the delimiter in a different way within the loop. This implies potential for a different return value when an empty array or a non-empty array is joined, thus the CI type is 1."
937,"<android.net.Uri.StringUri: String parsePath(String,int)>",27,28,"<android.net.Uri.StringUri: String parsePath(String,int)>","<android.net.Uri.StringUri: String parsePath(String,int)>",0,"{
    int length = uriString.length();
    // Find start of path.
    int pathStart;
    if (length > ssi + 2 && uriString.charAt(ssi + 1) == '/' && uriString.charAt(ssi + 2) == '/') {
        // Skip over authority to path.
        pathStart = ssi + 3;
        LOOP: while (pathStart < length) {
            switch(uriString.charAt(pathStart)) {
                // Start of query
                case '?':
                case // Start of fragment
                '#':
                    // Empty path.
                    return """";
                case // Start of path!
                '/':
                    break LOOP;
            }
            pathStart++;
        }
    } else {
        // Path starts immediately after scheme separator.
        pathStart = ssi + 1;
    }
    // Find end of path.
    int pathEnd = pathStart;
    LOOP: while (pathEnd < length) {
        switch(uriString.charAt(pathEnd)) {
            // Start of query
            case '?':
            case // Start of fragment
            '#':
                break LOOP;
        }
        pathEnd++;
    }
    return uriString.substring(pathStart, pathEnd);
}","{
    int length = uriString.length();
    // Find start of path.
    int pathStart;
    if (length > ssi + 2 && uriString.charAt(ssi + 1) == '/' && uriString.charAt(ssi + 2) == '/') {
        // Skip over authority to path.
        pathStart = ssi + 3;
        LOOP: while (pathStart < length) {
            switch(uriString.charAt(pathStart)) {
                // Start of query
                case '?':
                case // Start of fragment
                '#':
                    // Empty path.
                    return """";
                // Start of path!
                case '/':
                case // Start of path!
                '\\':
                    // host
                    break LOOP;
            }
            pathStart++;
        }
    } else {
        // Path starts immediately after scheme separator.
        pathStart = ssi + 1;
    }
    // Find end of path.
    int pathEnd = pathStart;
    LOOP: while (pathEnd < length) {
        switch(uriString.charAt(pathEnd)) {
            // Start of query
            case '?':
            case // Start of fragment
            '#':
                break LOOP;
        }
        pathEnd++;
    }
    return uriString.substring(pathStart, pathEnd);
}",1,"/**
 * Parses a path out of this given URI string.
 *
 * @param uriString URI string
 * @param ssi scheme separator index, -1 for a relative URI
 *
 * @return the path
 */
","/**
 * Parses a path out of this given URI string.
 *
 * @param uriString URI string
 * @param ssi scheme separator index, -1 for a relative URI
 *
 * @return the path
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",0,"The 'case' statement within the 'switch' block inside the first 'LOOP' structure was changed by adding an extra case ('\\'). This change affects the control flow and is thus classified as a control dependency change, which is code change type 3. Additionally, since the new case does not modify the behavior of any existing case and only adds a new condition for entering the existing 'break LOOP;' statement, there is also a minor change to the control-flow structure itself, which can be attributed to code change type 4.","There is no compatibility issue detected in this situation. The additional 'case' for the backslash ('\\') allows the method to recognize a new condition for finding the start of a path, but it does not affect the return values for any inputs that would have worked in the earlier version. Given that the backslash character was not accounted for in the earlier version, the new implementation does not change the return value or type of the method for inputs that would have been valid in the earlier version; it merely extends the functionality to correctly parse a new set of inputs that include the backslash as a potential path starter. Thus, no compatibility issue arises for existing functionality."
938,"<android.content.ContentResolver: boolean isSyncActive(Account,String)>",27,28,"<android.content.ContentResolver: boolean isSyncActive(Account,String)>","<android.content.ContentResolver: boolean isSyncActive(Account,String)>",0,"{
    if (account == null) {
        throw new IllegalArgumentException(""account must not be null"");
    }
    if (authority == null) {
        throw new IllegalArgumentException(""authority must not be null"");
    }
    try {
        return getContentService().isSyncActive(account, authority, null);
    } catch (RemoteException e) {
        throw new RuntimeException(""the ContentService should always be reachable"", e);
    }
}","{
    if (account == null) {
        throw new IllegalArgumentException(""account must not be null"");
    }
    if (authority == null) {
        throw new IllegalArgumentException(""authority must not be null"");
    }
    try {
        return getContentService().isSyncActive(account, authority, null);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Returns true if there is currently a sync operation for the given account or authority
 * actively being processed.
 * <p>This method requires the caller to hold the permission
 * {@link android.Manifest.permission#READ_SYNC_STATS}.
 * @param account the account whose setting we are querying
 * @param authority the provider whose behavior is being queried
 * @return true if a sync is active for the given account or authority.
 */
","/**
 * Returns true if there is currently a sync operation for the given account or authority
 * actively being processed.
 * <p>This method requires the caller to hold the permission
 * {@link android.Manifest.permission#READ_SYNC_STATS}.
 * @param account the account whose setting we are querying
 * @param authority the provider whose behavior is being queried
 * @return true if a sync is active for the given account or authority.
 */
",-1,,,-1,-1,-1,-1,-1,-1,2,2,Exception handling statement has changed with different exception being thrown in the catch block. So the code change type is 2.,"The late version throws a different exception type in the catch block which can cause a different behavior in exception handling, hence the CI type is 2."
939,"<android.bluetooth.BluetoothAdapter: boolean startLeScan(UUID[],LeScanCallback)>",27,28,"<android.bluetooth.BluetoothAdapter: boolean startLeScan(UUID[],LeScanCallback)>","<android.bluetooth.BluetoothAdapter: boolean startLeScan(UUID[],LeScanCallback)>",0,"{
    if (DBG)
        Log.d(TAG, ""startLeScan(): "" + Arrays.toString(serviceUuids));
    if (callback == null) {
        if (DBG)
            Log.e(TAG, ""startLeScan: null callback"");
        return false;
    }
    BluetoothLeScanner scanner = getBluetoothLeScanner();
    if (scanner == null) {
        if (DBG)
            Log.e(TAG, ""startLeScan: cannot get BluetoothLeScanner"");
        return false;
    }
    synchronized (mLeScanClients) {
        if (mLeScanClients.containsKey(callback)) {
            if (DBG)
                Log.e(TAG, ""LE Scan has already started"");
            return false;
        }
        try {
            IBluetoothGatt iGatt = mManagerService.getBluetoothGatt();
            if (iGatt == null) {
                // BLE is not supported
                return false;
            }
            ScanCallback scanCallback = new ScanCallback() {

                @Override
                public void onScanResult(int callbackType, ScanResult result) {
                    if (callbackType != ScanSettings.CALLBACK_TYPE_ALL_MATCHES) {
                        // Should not happen.
                        Log.e(TAG, ""LE Scan has already started"");
                        return;
                    }
                    ScanRecord scanRecord = result.getScanRecord();
                    if (scanRecord == null) {
                        return;
                    }
                    if (serviceUuids != null) {
                        List<ParcelUuid> uuids = new ArrayList<ParcelUuid>();
                        for (UUID uuid : serviceUuids) {
                            uuids.add(new ParcelUuid(uuid));
                        }
                        List<ParcelUuid> scanServiceUuids = scanRecord.getServiceUuids();
                        if (scanServiceUuids == null || !scanServiceUuids.containsAll(uuids)) {
                            if (DBG)
                                Log.d(TAG, ""uuids does not match"");
                            return;
                        }
                    }
                    callback.onLeScan(result.getDevice(), result.getRssi(), scanRecord.getBytes());
                }
            };
            ScanSettings settings = new ScanSettings.Builder().setCallbackType(ScanSettings.CALLBACK_TYPE_ALL_MATCHES).setScanMode(ScanSettings.SCAN_MODE_LOW_LATENCY).build();
            List<ScanFilter> filters = new ArrayList<ScanFilter>();
            if (serviceUuids != null && serviceUuids.length > 0) {
                // Note scan filter does not support matching an UUID array so we put one
                // UUID to hardware and match the whole array in callback.
                ScanFilter filter = new ScanFilter.Builder().setServiceUuid(new ParcelUuid(serviceUuids[0])).build();
                filters.add(filter);
            }
            scanner.startScan(filters, settings, scanCallback);
            mLeScanClients.put(callback, scanCallback);
            return true;
        } catch (RemoteException e) {
            Log.e(TAG, """", e);
        }
    }
    return false;
}","{
    if (DBG) {
        Log.d(TAG, ""startLeScan(): "" + Arrays.toString(serviceUuids));
    }
    if (callback == null) {
        if (DBG) {
            Log.e(TAG, ""startLeScan: null callback"");
        }
        return false;
    }
    BluetoothLeScanner scanner = getBluetoothLeScanner();
    if (scanner == null) {
        if (DBG) {
            Log.e(TAG, ""startLeScan: cannot get BluetoothLeScanner"");
        }
        return false;
    }
    synchronized (mLeScanClients) {
        if (mLeScanClients.containsKey(callback)) {
            if (DBG) {
                Log.e(TAG, ""LE Scan has already started"");
            }
            return false;
        }
        try {
            IBluetoothGatt iGatt = mManagerService.getBluetoothGatt();
            if (iGatt == null) {
                // BLE is not supported
                return false;
            }
            ScanCallback scanCallback = new ScanCallback() {

                @Override
                public void onScanResult(int callbackType, ScanResult result) {
                    if (callbackType != ScanSettings.CALLBACK_TYPE_ALL_MATCHES) {
                        // Should not happen.
                        Log.e(TAG, ""LE Scan has already started"");
                        return;
                    }
                    ScanRecord scanRecord = result.getScanRecord();
                    if (scanRecord == null) {
                        return;
                    }
                    if (serviceUuids != null) {
                        List<ParcelUuid> uuids = new ArrayList<ParcelUuid>();
                        for (UUID uuid : serviceUuids) {
                            uuids.add(new ParcelUuid(uuid));
                        }
                        List<ParcelUuid> scanServiceUuids = scanRecord.getServiceUuids();
                        if (scanServiceUuids == null || !scanServiceUuids.containsAll(uuids)) {
                            if (DBG) {
                                Log.d(TAG, ""uuids does not match"");
                            }
                            return;
                        }
                    }
                    callback.onLeScan(result.getDevice(), result.getRssi(), scanRecord.getBytes());
                }
            };
            ScanSettings settings = new ScanSettings.Builder().setCallbackType(ScanSettings.CALLBACK_TYPE_ALL_MATCHES).setScanMode(ScanSettings.SCAN_MODE_LOW_LATENCY).build();
            List<ScanFilter> filters = new ArrayList<ScanFilter>();
            if (serviceUuids != null && serviceUuids.length > 0) {
                // Note scan filter does not support matching an UUID array so we put one
                // UUID to hardware and match the whole array in callback.
                ScanFilter filter = new ScanFilter.Builder().setServiceUuid(new ParcelUuid(serviceUuids[0])).build();
                filters.add(filter);
            }
            scanner.startScan(filters, settings, scanCallback);
            mLeScanClients.put(callback, scanCallback);
            return true;
        } catch (RemoteException e) {
            Log.e(TAG, """", e);
        }
    }
    return false;
}",1,"/**
 * Starts a scan for Bluetooth LE devices, looking for devices that
 * advertise given services.
 *
 * <p>Devices which advertise all specified services are reported using the
 * {@link LeScanCallback#onLeScan} callback.
 *
 * @param serviceUuids Array of services to look for
 * @param callback the callback LE scan results are delivered
 * @return true, if the scan was started successfully
 * @deprecated use {@link BluetoothLeScanner#startScan(List, ScanSettings, ScanCallback)}
 * instead.
 */
","/**
 * Starts a scan for Bluetooth LE devices, looking for devices that
 * advertise given services.
 *
 * <p>Devices which advertise all specified services are reported using the
 * {@link LeScanCallback#onLeScan} callback.
 *
 * @param serviceUuids Array of services to look for
 * @param callback the callback LE scan results are delivered
 * @return true, if the scan was started successfully
 * @deprecated use {@link BluetoothLeScanner#startScan(List, ScanSettings, ScanCallback)}
 * instead.
 */
",-1,"[@Deprecated, @RequiresPermission(Manifest.permission.BLUETOOTH_ADMIN)]","[@Deprecated, @RequiresPermission(Manifest.permission.BLUETOOTH_ADMIN)]",-1,-1,-1,-1,-1,-1,,,,
940,<android.os.PowerManager.WakeLock: void release(int)>,27,28,<android.os.PowerManager.WakeLock: void release(int)>,<android.os.PowerManager.WakeLock: void release(int)>,0,"{
    synchronized (mToken) {
        mInternalCount--;
        if ((flags & RELEASE_FLAG_TIMEOUT) == 0) {
            mExternalCount--;
        }
        if (!mRefCounted || mInternalCount == 0) {
            mHandler.removeCallbacks(mReleaser);
            if (mHeld) {
                Trace.asyncTraceEnd(Trace.TRACE_TAG_POWER, mTraceName, 0);
                try {
                    mService.releaseWakeLock(mToken, flags);
                } catch (RemoteException e) {
                    throw e.rethrowFromSystemServer();
                }
                mHeld = false;
            }
        }
        if (mRefCounted && mExternalCount < 0) {
            throw new RuntimeException(""WakeLock under-locked "" + mTag);
        }
    }
}","{
    synchronized (mToken) {
        if (mInternalCount > 0) {
            // internal count must only be decreased if it is > 0 or state of
            // the WakeLock object is broken.
            mInternalCount--;
        }
        if ((flags & RELEASE_FLAG_TIMEOUT) == 0) {
            mExternalCount--;
        }
        if (!mRefCounted || mInternalCount == 0) {
            mHandler.removeCallbacks(mReleaser);
            if (mHeld) {
                Trace.asyncTraceEnd(Trace.TRACE_TAG_POWER, mTraceName, 0);
                try {
                    mService.releaseWakeLock(mToken, flags);
                } catch (RemoteException e) {
                    throw e.rethrowFromSystemServer();
                }
                mHeld = false;
            }
        }
        if (mRefCounted && mExternalCount < 0) {
            throw new RuntimeException(""WakeLock under-locked "" + mTag);
        }
    }
}",1,"/**
 * Releases the wake lock with flags to modify the release behavior.
 * <p>
 * This method releases your claim to the CPU or screen being on.
 * The screen may turn off shortly after you release the wake lock, or it may
 * not if there are other wake locks still held.
 * </p>
 *
 * @param flags Combination of flag values to modify the release behavior.
 * Currently only {@link #RELEASE_FLAG_WAIT_FOR_NO_PROXIMITY} is supported.
 * Passing 0 is equivalent to calling {@link #release()}.
 */
","/**
 * Releases the wake lock with flags to modify the release behavior.
 * <p>
 * This method releases your claim to the CPU or screen being on.
 * The screen may turn off shortly after you release the wake lock, or it may
 * not if there are other wake locks still held.
 * </p>
 *
 * @param flags Combination of flag values to modify the release behavior.
 * Currently only {@link #RELEASE_FLAG_WAIT_FOR_NO_PROXIMITY} is supported.
 * Passing 0 is equivalent to calling {@link #release()}.
 */
",-1,,,-1,-1,-1,-1,-1,-1,3,0,"A new condition ""if (mInternalCount > 0)"" has been added before decrementing the mInternalCount, which means the decrement will only happen if mInternalCount is greater than zero. This is a control dependency change.","Although the control statement has changed, the new conditional check ""if (mInternalCount > 0)"" before decrementing mInternalCount is added as a safety check to ensure the count doesn't go negative. This does not introduce compatibility issues because the logic that leads to the behavior visible to the user (like releasing the wake lock or throwing exceptions) has not changed. The overall behavior of how the method handles the release process remains consistent with the previous version. Therefore, there is no compatibility issue."
942,<android.hardware.usb.UsbManager: UsbDeviceConnection openDevice(UsbDevice)>,27,28,<android.hardware.usb.UsbManager: UsbDeviceConnection openDevice(UsbDevice)>,<android.hardware.usb.UsbManager: UsbDeviceConnection openDevice(UsbDevice)>,0,"{
    try {
        String deviceName = device.getDeviceName();
        ParcelFileDescriptor pfd = mService.openDevice(deviceName);
        if (pfd != null) {
            UsbDeviceConnection connection = new UsbDeviceConnection(device);
            boolean result = connection.open(deviceName, pfd, mContext);
            pfd.close();
            if (result) {
                return connection;
            }
        }
    } catch (Exception e) {
        Log.e(TAG, ""exception in UsbManager.openDevice"", e);
    }
    return null;
}","{
    try {
        String deviceName = device.getDeviceName();
        ParcelFileDescriptor pfd = mService.openDevice(deviceName, mContext.getPackageName());
        if (pfd != null) {
            UsbDeviceConnection connection = new UsbDeviceConnection(device);
            boolean result = connection.open(deviceName, pfd, mContext);
            pfd.close();
            if (result) {
                return connection;
            }
        }
    } catch (Exception e) {
        Log.e(TAG, ""exception in UsbManager.openDevice"", e);
    }
    return null;
}",1,"/**
 * Opens the device so it can be used to send and receive
 * data using {@link android.hardware.usb.UsbRequest}.
 *
 * @param device the device to open
 * @return a {@link UsbDeviceConnection}, or {@code null} if open failed
 */
","/**
 * Opens the device so it can be used to send and receive
 * data using {@link android.hardware.usb.UsbRequest}.
 *
 * @param device the device to open
 * @return a {@link UsbDeviceConnection}, or {@code null} if open failed
 */
",-1,,[@RequiresFeature(PackageManager.FEATURE_USB_HOST)],-1,-1,-1,-1,-1,-1,"4,5",0,"The method `mService.openDevice()` has added a new parameter, making it `mService.openDevice(deviceName, mContext.getPackageName())`, and there is an addition in the late version annotation indicating usage requires a feature; hence, the code changes pertain to type 4 and 5 (other statement changed, dependent API changed).","There is no Compatibility Issue in this case; the method still returns the same types of values and handles exceptions in the same way. Adding context as a parameter in the dependent method and changing the annotation does not lead to different return values/types or exception handlings in this context, so the CI classification is 0."
943,"<android.bluetooth.le.AdvertisingSet: void enableAdvertising(boolean,int,int)>",27,28,"<android.bluetooth.le.AdvertisingSet: void enableAdvertising(boolean,int,int)>","<android.bluetooth.le.AdvertisingSet: void enableAdvertising(boolean,int,int)>",0,"{
    try {
        gatt.enableAdvertisingSet(this.advertiserId, enable, duration, maxExtendedAdvertisingEvents);
    } catch (RemoteException e) {
        Log.e(TAG, ""remote exception - "", e);
    }
}","{
    try {
        mGatt.enableAdvertisingSet(mAdvertiserId, enable, duration, maxExtendedAdvertisingEvents);
    } catch (RemoteException e) {
        Log.e(TAG, ""remote exception - "", e);
    }
}",1,"/**
 * Enables Advertising. This method returns immediately, the operation status is
 * delivered through {@code callback.onAdvertisingEnabled()}.
 * <p>
 * Requires {@link android.Manifest.permission#BLUETOOTH_ADMIN}
 *
 * @param enable whether the advertising should be enabled (true), or disabled (false)
 * @param duration advertising duration, in 10ms unit. Valid range is from 1 (10ms) to
 * 65535 (655,350 ms)
 * @param maxExtendedAdvertisingEvents maximum number of extended advertising events the
 * controller shall attempt to send prior to terminating the extended
 * advertising, even if the duration has not expired. Valid range is
 * from 1 to 255.
 */
","/**
 * Enables Advertising. This method returns immediately, the operation status is
 * delivered through {@code callback.onAdvertisingEnabled()}.
 * <p>
 * Requires {@link android.Manifest.permission#BLUETOOTH_ADMIN}
 *
 * @param enable whether the advertising should be enabled (true), or disabled (false)
 * @param duration advertising duration, in 10ms unit. Valid range is from 1 (10ms) to 65535
 * (655,350 ms)
 * @param maxExtendedAdvertisingEvents maximum number of extended advertising events the
 * controller shall attempt to send prior to terminating the extended advertising, even if the
 * duration has not expired. Valid range is from 1 to 255.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The member variables names are changed from `gatt` to `mGatt` and from `advertiserId` to `mAdvertiserId`. However, these changes refer to internal variable renamings and do not affect the external behavior or contract of the API. Therefore, the observed change is type 4 (other statement changed).","There is no compatibility issue, as the renaming of internal variables does not affect how the method behaves externally, meaning it still accepts the same parameters and does not change the way exceptions are handled or the returned result. Therefore, the CI type is 0 (No Compatibility Issue)."
944,"<android.app.usage.NetworkStatsManager: Bucket querySummaryForUser(int,String,long,long)>",27,28,"<android.app.usage.NetworkStatsManager: Bucket querySummaryForUser(int,String,long,long)>","<android.app.usage.NetworkStatsManager: Bucket querySummaryForUser(int,String,long,long)>",0,"{
    NetworkTemplate template;
    try {
        template = createTemplate(networkType, subscriberId);
    } catch (IllegalArgumentException e) {
        if (DBG)
            Log.e(TAG, ""Cannot create template"", e);
        return null;
    }
    NetworkStats stats;
    stats = new NetworkStats(mContext, template, mFlags, startTime, endTime);
    stats.startSummaryEnumeration();
    stats.close();
    return stats.getSummaryAggregate();
}","{
    NetworkTemplate template;
    try {
        template = createTemplate(networkType, subscriberId);
    } catch (IllegalArgumentException e) {
        if (DBG)
            Log.e(TAG, ""Cannot create template"", e);
        return null;
    }
    NetworkStats stats;
    stats = new NetworkStats(mContext, template, mFlags, startTime, endTime, mService);
    stats.startSummaryEnumeration();
    stats.close();
    return stats.getSummaryAggregate();
}",1,"/**
 * Query network usage statistics summaries. Result is summarised data usage for all uids
 * belonging to calling user. Result is a single Bucket aggregated over time, state and uid.
 * This means the bucket's start and end timestamp are going to be the same as the 'startTime'
 * and 'endTime' parameters. State is going to be {@link NetworkStats.Bucket#STATE_ALL},
 * uid {@link NetworkStats.Bucket#UID_ALL}, tag {@link NetworkStats.Bucket#TAG_NONE},
 * metered {@link NetworkStats.Bucket#METERED_ALL}, and roaming
 * {@link NetworkStats.Bucket#ROAMING_ALL}.
 *
 * @param networkType As defined in {@link ConnectivityManager}, e.g.
 * {@link ConnectivityManager#TYPE_MOBILE}, {@link ConnectivityManager#TYPE_WIFI}
 * etc.
 * @param subscriberId If applicable, the subscriber id of the network interface.
 * @param startTime Start of period. Defined in terms of ""Unix time"", see
 * {@link java.lang.System#currentTimeMillis}.
 * @param endTime End of period. Defined in terms of ""Unix time"", see
 * {@link java.lang.System#currentTimeMillis}.
 * @return Bucket object or null if permissions are insufficient or error happened during
 * statistics collection.
 */
","/**
 * Query network usage statistics summaries. Result is summarised data usage for all uids
 * belonging to calling user. Result is a single Bucket aggregated over time, state and uid.
 * This means the bucket's start and end timestamp are going to be the same as the 'startTime'
 * and 'endTime' parameters. State is going to be {@link NetworkStats.Bucket#STATE_ALL},
 * uid {@link NetworkStats.Bucket#UID_ALL}, tag {@link NetworkStats.Bucket#TAG_NONE},
 * metered {@link NetworkStats.Bucket#METERED_ALL}, and roaming
 * {@link NetworkStats.Bucket#ROAMING_ALL}.
 *
 * @param networkType As defined in {@link ConnectivityManager}, e.g.
 * {@link ConnectivityManager#TYPE_MOBILE}, {@link ConnectivityManager#TYPE_WIFI}
 * etc.
 * @param subscriberId If applicable, the subscriber id of the network interface.
 * @param startTime Start of period. Defined in terms of ""Unix time"", see
 * {@link java.lang.System#currentTimeMillis}.
 * @param endTime End of period. Defined in terms of ""Unix time"", see
 * {@link java.lang.System#currentTimeMillis}.
 * @return Bucket object or null if permissions are insufficient or error happened during
 * statistics collection.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",1,"The constructor call for NetworkStats has changed by adding a new parameter (mService). This indicates that a dependent API (the constructor of NetworkStats) has presumably changed its parameter list, which falls under code change type 4,5.",This change to the dependent API could potentially lead to different return values due to a different behavior of the new constructor when compared to the early version and thus cause a Compatibility Issue of type 1.
945,"<android.app.Instrumentation: Application newApplication(ClassLoader,String,Context)>",27,28,"<android.app.Instrumentation: Application newApplication(ClassLoader,String,Context)>","<android.app.Instrumentation: Application newApplication(ClassLoader,String,Context)>",0,"{
    return newApplication(cl.loadClass(className), context);
}","{
    Application app = getFactory(context.getPackageName()).instantiateApplication(cl, className);
    app.attach(context);
    return app;
}",1,"/**
 * Perform instantiation of the process's {@link Application} object.  The
 * default implementation provides the normal system behavior.
 *
 * @param cl The ClassLoader with which to instantiate the object.
 * @param className The name of the class implementing the Application
 * object.
 * @param context The context to initialize the application with
 *
 * @return The newly instantiated Application object.
 */
","/**
 * Perform instantiation of the process's {@link Application} object.  The
 * default implementation provides the normal system behavior.
 *
 * @param cl The ClassLoader with which to instantiate the object.
 * @param className The name of the class implementing the Application
 * object.
 * @param context The context to initialize the application with
 *
 * @return The newly instantiated Application object.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,4,5",1,"The entire implementation of the method is changed. It no longer directly calls newApplication(Class, Context), but now constructs the Application instance using a different API, getFactory(context.getPackageName()).instantiateApplication(cl, className), followed by attaching the context to the application object. This constitutes a return statement changed (1), another statement changed (4) as the process of creating and preparing the application object is different, and a dependent API changed (5) since it's now relying on getFactory().instantiateApplication() instead of simply calling newApplication().","This change is likely to change the behavior of the method in terms of how the Application is instantiated and could therefore return a different type or setup of the Application object. The instantiation process has been changed and the interoperation with the 'context' has also changed (it now explicitly calls attach(context)), which introduces potential compatibility issues by returning a differently initialized Application object, hence the CI type is 1."
946,"<android.content.ContentResolver: int getIsSyncable(Account,String)>",27,28,"<android.content.ContentResolver: int getIsSyncable(Account,String)>","<android.content.ContentResolver: int getIsSyncable(Account,String)>",0,"{
    try {
        return getContentService().getIsSyncable(account, authority);
    } catch (RemoteException e) {
        throw new RuntimeException(""the ContentService should always be reachable"", e);
    }
}","{
    try {
        return getContentService().getIsSyncable(account, authority);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Check if this account/provider is syncable.
 * <p>This method requires the caller to hold the permission
 * {@link android.Manifest.permission#READ_SYNC_SETTINGS}.
 * @return >0 if it is syncable, 0 if not, and <0 if the state isn't known yet.
 */
","/**
 * Check if this account/provider is syncable.
 * <p>This method requires the caller to hold the permission
 * {@link android.Manifest.permission#READ_SYNC_SETTINGS}.
 * @return >0 if it is syncable, 0 if not, and <0 if the state isn't known yet.
 */
",-1,,,-1,-1,-1,-1,-1,-1,2,2,"The exception handling statement has changed from throwing a new RuntimeException to throwing the result of e.rethrowFromSystemServer(), so the code change type is 2.","As the exception handling now throws a different exception type, the API may behave differently when encountering an exception, thus the CI type is 2."
947,<android.hardware.radio.RadioManager.ProgramInfo: int getSignalStrength()>,27,28,<android.hardware.radio.RadioManager.ProgramInfo: int getSignalStrength()>,<android.hardware.radio.RadioManager.ProgramInfo: int getSignalStrength()>,0,"{
    return mSignalStrength;
}","{
    return mSignalQuality;
}",1,"/**
 * Signal strength indicator from 0 (no signal) to 100 (excellent)
 * @return the signal strength indication.
 */
","/**
 * Signal quality (as opposed to the name) indication from 0 (no signal)
 * to 100 (excellent)
 * @return the signal quality indication.
 */
",-1,,,-1,-1,-1,-1,-1,-1,1,1,"The return statement has changed from returning `mSignalStrength` to returning `mSignalQuality`, which indicates a variable has been changed. Hence, the change type is 1.","The method now returns a different variable. Even though they might represent similar concepts, `mSignalStrength` and `mSignalQuality` are different variables and potentially hold different values. This change will cause the API to return a different value, which is a compatibility issue of type 1."
950,<android.service.autofill.Dataset: String toString()>,27,28,<android.service.autofill.Dataset: String toString()>,<android.service.autofill.Dataset: String toString()>,0,"{
    if (!sDebug)
        return super.toString();
    return new StringBuilder(""Dataset "" + mId + "" ["").append(""fieldIds="").append(mFieldIds).append("", fieldValues="").append(mFieldValues).append("", fieldPresentations="").append(mFieldPresentations == null ? 0 : mFieldPresentations.size()).append("", hasPresentation="").append(mPresentation != null).append("", hasAuthentication="").append(mAuthentication != null).append(']').toString();
}","{
    if (!sDebug)
        return super.toString();
    final StringBuilder builder = new StringBuilder(""Dataset["");
    if (mId == null) {
        builder.append(""noId"");
    } else {
        // Cannot disclose id because it could contain PII.
        builder.append(""id="").append(mId.length()).append(""_chars"");
    }
    if (mFieldIds != null) {
        builder.append("", fieldIds="").append(mFieldIds);
    }
    if (mFieldValues != null) {
        builder.append("", fieldValues="").append(mFieldValues);
    }
    if (mFieldPresentations != null) {
        builder.append("", fieldPresentations="").append(mFieldPresentations.size());
    }
    if (mFieldFilters != null) {
        builder.append("", fieldFilters="").append(mFieldFilters.size());
    }
    if (mPresentation != null) {
        builder.append("", hasPresentation"");
    }
    if (mAuthentication != null) {
        builder.append("", hasAuthentication"");
    }
    return builder.append(']').toString();
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,4",1,"There are updates to the return statement and other statements within the toString() method. The construction of the StringBuilder has been changed, and different fields and their formats are appended to the return value. Particularly, the handling of mId has changed significantly where only length is now appended instead of the actual value due to privacy reasons. These changes constitute change types 1 and 4.","The modifications in the return value construction will lead to the API returning a different string representation for the Dataset object. Therefore, there is a compatibility issue of type 1 due to potential different return values."
951,<android.content.res.Configuration: String toString()>,27,28,<android.content.res.Configuration: String toString()>,<android.content.res.Configuration: String toString()>,0,"{
    StringBuilder sb = new StringBuilder(128);
    sb.append(""{"");
    sb.append(fontScale);
    sb.append("" "");
    if (mcc != 0) {
        sb.append(mcc);
        sb.append(""mcc"");
    } else {
        sb.append(""?mcc"");
    }
    if (mnc != 0) {
        sb.append(mnc);
        sb.append(""mnc"");
    } else {
        sb.append(""?mnc"");
    }
    fixUpLocaleList();
    if (!mLocaleList.isEmpty()) {
        sb.append("" "");
        sb.append(mLocaleList);
    } else {
        sb.append("" ?localeList"");
    }
    int layoutDir = (screenLayout & SCREENLAYOUT_LAYOUTDIR_MASK);
    switch(layoutDir) {
        case SCREENLAYOUT_LAYOUTDIR_UNDEFINED:
            sb.append("" ?layoutDir"");
            break;
        case SCREENLAYOUT_LAYOUTDIR_LTR:
            sb.append("" ldltr"");
            break;
        case SCREENLAYOUT_LAYOUTDIR_RTL:
            sb.append("" ldrtl"");
            break;
        default:
            sb.append("" layoutDir="");
            sb.append(layoutDir >> SCREENLAYOUT_LAYOUTDIR_SHIFT);
            break;
    }
    if (smallestScreenWidthDp != SMALLEST_SCREEN_WIDTH_DP_UNDEFINED) {
        sb.append("" sw"");
        sb.append(smallestScreenWidthDp);
        sb.append(""dp"");
    } else {
        sb.append("" ?swdp"");
    }
    if (screenWidthDp != SCREEN_WIDTH_DP_UNDEFINED) {
        sb.append("" w"");
        sb.append(screenWidthDp);
        sb.append(""dp"");
    } else {
        sb.append("" ?wdp"");
    }
    if (screenHeightDp != SCREEN_HEIGHT_DP_UNDEFINED) {
        sb.append("" h"");
        sb.append(screenHeightDp);
        sb.append(""dp"");
    } else {
        sb.append("" ?hdp"");
    }
    if (densityDpi != DENSITY_DPI_UNDEFINED) {
        sb.append("" "");
        sb.append(densityDpi);
        sb.append(""dpi"");
    } else {
        sb.append("" ?density"");
    }
    switch((screenLayout & SCREENLAYOUT_SIZE_MASK)) {
        case SCREENLAYOUT_SIZE_UNDEFINED:
            sb.append("" ?lsize"");
            break;
        case SCREENLAYOUT_SIZE_SMALL:
            sb.append("" smll"");
            break;
        case SCREENLAYOUT_SIZE_NORMAL:
            sb.append("" nrml"");
            break;
        case SCREENLAYOUT_SIZE_LARGE:
            sb.append("" lrg"");
            break;
        case SCREENLAYOUT_SIZE_XLARGE:
            sb.append("" xlrg"");
            break;
        default:
            sb.append("" layoutSize="");
            sb.append(screenLayout & SCREENLAYOUT_SIZE_MASK);
            break;
    }
    switch((screenLayout & SCREENLAYOUT_LONG_MASK)) {
        case SCREENLAYOUT_LONG_UNDEFINED:
            sb.append("" ?long"");
            break;
        case SCREENLAYOUT_LONG_NO:
            /* not-long is not interesting to print */
            break;
        case SCREENLAYOUT_LONG_YES:
            sb.append("" long"");
            break;
        default:
            sb.append("" layoutLong="");
            sb.append(screenLayout & SCREENLAYOUT_LONG_MASK);
            break;
    }
    switch((colorMode & COLOR_MODE_HDR_MASK)) {
        // most likely not HDR
        case COLOR_MODE_HDR_UNDEFINED:
            sb.append("" ?ldr"");
            break;
        case COLOR_MODE_HDR_NO:
            /* ldr is not interesting to print */
            break;
        case COLOR_MODE_HDR_YES:
            sb.append("" hdr"");
            break;
        default:
            sb.append("" dynamicRange="");
            sb.append(colorMode & COLOR_MODE_HDR_MASK);
            break;
    }
    switch((colorMode & COLOR_MODE_WIDE_COLOR_GAMUT_MASK)) {
        case COLOR_MODE_WIDE_COLOR_GAMUT_UNDEFINED:
            sb.append("" ?wideColorGamut"");
            break;
        case COLOR_MODE_WIDE_COLOR_GAMUT_NO:
            /* not wide is not interesting to print */
            break;
        case COLOR_MODE_WIDE_COLOR_GAMUT_YES:
            sb.append("" widecg"");
            break;
        default:
            sb.append("" wideColorGamut="");
            sb.append(colorMode & COLOR_MODE_WIDE_COLOR_GAMUT_MASK);
            break;
    }
    switch(orientation) {
        case ORIENTATION_UNDEFINED:
            sb.append("" ?orien"");
            break;
        case ORIENTATION_LANDSCAPE:
            sb.append("" land"");
            break;
        case ORIENTATION_PORTRAIT:
            sb.append("" port"");
            break;
        default:
            sb.append("" orien="");
            sb.append(orientation);
            break;
    }
    switch((uiMode & UI_MODE_TYPE_MASK)) {
        case UI_MODE_TYPE_UNDEFINED:
            sb.append("" ?uimode"");
            break;
        case UI_MODE_TYPE_NORMAL:
            /* normal is not interesting to print */
            break;
        case UI_MODE_TYPE_DESK:
            sb.append("" desk"");
            break;
        case UI_MODE_TYPE_CAR:
            sb.append("" car"");
            break;
        case UI_MODE_TYPE_TELEVISION:
            sb.append("" television"");
            break;
        case UI_MODE_TYPE_APPLIANCE:
            sb.append("" appliance"");
            break;
        case UI_MODE_TYPE_WATCH:
            sb.append("" watch"");
            break;
        case UI_MODE_TYPE_VR_HEADSET:
            sb.append("" vrheadset"");
            break;
        default:
            sb.append("" uimode="");
            sb.append(uiMode & UI_MODE_TYPE_MASK);
            break;
    }
    switch((uiMode & UI_MODE_NIGHT_MASK)) {
        case UI_MODE_NIGHT_UNDEFINED:
            sb.append("" ?night"");
            break;
        case UI_MODE_NIGHT_NO:
            /* not-night is not interesting to print */
            break;
        case UI_MODE_NIGHT_YES:
            sb.append("" night"");
            break;
        default:
            sb.append("" night="");
            sb.append(uiMode & UI_MODE_NIGHT_MASK);
            break;
    }
    switch(touchscreen) {
        case TOUCHSCREEN_UNDEFINED:
            sb.append("" ?touch"");
            break;
        case TOUCHSCREEN_NOTOUCH:
            sb.append("" -touch"");
            break;
        case TOUCHSCREEN_STYLUS:
            sb.append("" stylus"");
            break;
        case TOUCHSCREEN_FINGER:
            sb.append("" finger"");
            break;
        default:
            sb.append("" touch="");
            sb.append(touchscreen);
            break;
    }
    switch(keyboard) {
        case KEYBOARD_UNDEFINED:
            sb.append("" ?keyb"");
            break;
        case KEYBOARD_NOKEYS:
            sb.append("" -keyb"");
            break;
        case KEYBOARD_QWERTY:
            sb.append("" qwerty"");
            break;
        case KEYBOARD_12KEY:
            sb.append("" 12key"");
            break;
        default:
            sb.append("" keys="");
            sb.append(keyboard);
            break;
    }
    switch(keyboardHidden) {
        case KEYBOARDHIDDEN_UNDEFINED:
            sb.append(""/?"");
            break;
        case KEYBOARDHIDDEN_NO:
            sb.append(""/v"");
            break;
        case KEYBOARDHIDDEN_YES:
            sb.append(""/h"");
            break;
        case KEYBOARDHIDDEN_SOFT:
            sb.append(""/s"");
            break;
        default:
            sb.append(""/"");
            sb.append(keyboardHidden);
            break;
    }
    switch(hardKeyboardHidden) {
        case HARDKEYBOARDHIDDEN_UNDEFINED:
            sb.append(""/?"");
            break;
        case HARDKEYBOARDHIDDEN_NO:
            sb.append(""/v"");
            break;
        case HARDKEYBOARDHIDDEN_YES:
            sb.append(""/h"");
            break;
        default:
            sb.append(""/"");
            sb.append(hardKeyboardHidden);
            break;
    }
    switch(navigation) {
        case NAVIGATION_UNDEFINED:
            sb.append("" ?nav"");
            break;
        case NAVIGATION_NONAV:
            sb.append("" -nav"");
            break;
        case NAVIGATION_DPAD:
            sb.append("" dpad"");
            break;
        case NAVIGATION_TRACKBALL:
            sb.append("" tball"");
            break;
        case NAVIGATION_WHEEL:
            sb.append("" wheel"");
            break;
        default:
            sb.append("" nav="");
            sb.append(navigation);
            break;
    }
    switch(navigationHidden) {
        case NAVIGATIONHIDDEN_UNDEFINED:
            sb.append(""/?"");
            break;
        case NAVIGATIONHIDDEN_NO:
            sb.append(""/v"");
            break;
        case NAVIGATIONHIDDEN_YES:
            sb.append(""/h"");
            break;
        default:
            sb.append(""/"");
            sb.append(navigationHidden);
            break;
    }
    if (appBounds != null) {
        sb.append("" appBounds="");
        sb.append(appBounds);
    }
    if (assetsSeq != 0) {
        sb.append("" as."").append(assetsSeq);
    }
    if (seq != 0) {
        sb.append("" s."").append(seq);
    }
    sb.append('}');
    return sb.toString();
}","{
    StringBuilder sb = new StringBuilder(128);
    sb.append(""{"");
    sb.append(fontScale);
    sb.append("" "");
    if (mcc != 0) {
        sb.append(mcc);
        sb.append(""mcc"");
    } else {
        sb.append(""?mcc"");
    }
    if (mnc != 0) {
        sb.append(mnc);
        sb.append(""mnc"");
    } else {
        sb.append(""?mnc"");
    }
    fixUpLocaleList();
    if (!mLocaleList.isEmpty()) {
        sb.append("" "");
        sb.append(mLocaleList);
    } else {
        sb.append("" ?localeList"");
    }
    int layoutDir = (screenLayout & SCREENLAYOUT_LAYOUTDIR_MASK);
    switch(layoutDir) {
        case SCREENLAYOUT_LAYOUTDIR_UNDEFINED:
            sb.append("" ?layoutDir"");
            break;
        case SCREENLAYOUT_LAYOUTDIR_LTR:
            sb.append("" ldltr"");
            break;
        case SCREENLAYOUT_LAYOUTDIR_RTL:
            sb.append("" ldrtl"");
            break;
        default:
            sb.append("" layoutDir="");
            sb.append(layoutDir >> SCREENLAYOUT_LAYOUTDIR_SHIFT);
            break;
    }
    if (smallestScreenWidthDp != SMALLEST_SCREEN_WIDTH_DP_UNDEFINED) {
        sb.append("" sw"");
        sb.append(smallestScreenWidthDp);
        sb.append(""dp"");
    } else {
        sb.append("" ?swdp"");
    }
    if (screenWidthDp != SCREEN_WIDTH_DP_UNDEFINED) {
        sb.append("" w"");
        sb.append(screenWidthDp);
        sb.append(""dp"");
    } else {
        sb.append("" ?wdp"");
    }
    if (screenHeightDp != SCREEN_HEIGHT_DP_UNDEFINED) {
        sb.append("" h"");
        sb.append(screenHeightDp);
        sb.append(""dp"");
    } else {
        sb.append("" ?hdp"");
    }
    if (densityDpi != DENSITY_DPI_UNDEFINED) {
        sb.append("" "");
        sb.append(densityDpi);
        sb.append(""dpi"");
    } else {
        sb.append("" ?density"");
    }
    switch((screenLayout & SCREENLAYOUT_SIZE_MASK)) {
        case SCREENLAYOUT_SIZE_UNDEFINED:
            sb.append("" ?lsize"");
            break;
        case SCREENLAYOUT_SIZE_SMALL:
            sb.append("" smll"");
            break;
        case SCREENLAYOUT_SIZE_NORMAL:
            sb.append("" nrml"");
            break;
        case SCREENLAYOUT_SIZE_LARGE:
            sb.append("" lrg"");
            break;
        case SCREENLAYOUT_SIZE_XLARGE:
            sb.append("" xlrg"");
            break;
        default:
            sb.append("" layoutSize="");
            sb.append(screenLayout & SCREENLAYOUT_SIZE_MASK);
            break;
    }
    switch((screenLayout & SCREENLAYOUT_LONG_MASK)) {
        case SCREENLAYOUT_LONG_UNDEFINED:
            sb.append("" ?long"");
            break;
        case SCREENLAYOUT_LONG_NO:
            /* not-long is not interesting to print */
            break;
        case SCREENLAYOUT_LONG_YES:
            sb.append("" long"");
            break;
        default:
            sb.append("" layoutLong="");
            sb.append(screenLayout & SCREENLAYOUT_LONG_MASK);
            break;
    }
    switch((colorMode & COLOR_MODE_HDR_MASK)) {
        // most likely not HDR
        case COLOR_MODE_HDR_UNDEFINED:
            sb.append("" ?ldr"");
            break;
        case COLOR_MODE_HDR_NO:
            /* ldr is not interesting to print */
            break;
        case COLOR_MODE_HDR_YES:
            sb.append("" hdr"");
            break;
        default:
            sb.append("" dynamicRange="");
            sb.append(colorMode & COLOR_MODE_HDR_MASK);
            break;
    }
    switch((colorMode & COLOR_MODE_WIDE_COLOR_GAMUT_MASK)) {
        case COLOR_MODE_WIDE_COLOR_GAMUT_UNDEFINED:
            sb.append("" ?wideColorGamut"");
            break;
        case COLOR_MODE_WIDE_COLOR_GAMUT_NO:
            /* not wide is not interesting to print */
            break;
        case COLOR_MODE_WIDE_COLOR_GAMUT_YES:
            sb.append("" widecg"");
            break;
        default:
            sb.append("" wideColorGamut="");
            sb.append(colorMode & COLOR_MODE_WIDE_COLOR_GAMUT_MASK);
            break;
    }
    switch(orientation) {
        case ORIENTATION_UNDEFINED:
            sb.append("" ?orien"");
            break;
        case ORIENTATION_LANDSCAPE:
            sb.append("" land"");
            break;
        case ORIENTATION_PORTRAIT:
            sb.append("" port"");
            break;
        default:
            sb.append("" orien="");
            sb.append(orientation);
            break;
    }
    switch((uiMode & UI_MODE_TYPE_MASK)) {
        case UI_MODE_TYPE_UNDEFINED:
            sb.append("" ?uimode"");
            break;
        case UI_MODE_TYPE_NORMAL:
            /* normal is not interesting to print */
            break;
        case UI_MODE_TYPE_DESK:
            sb.append("" desk"");
            break;
        case UI_MODE_TYPE_CAR:
            sb.append("" car"");
            break;
        case UI_MODE_TYPE_TELEVISION:
            sb.append("" television"");
            break;
        case UI_MODE_TYPE_APPLIANCE:
            sb.append("" appliance"");
            break;
        case UI_MODE_TYPE_WATCH:
            sb.append("" watch"");
            break;
        case UI_MODE_TYPE_VR_HEADSET:
            sb.append("" vrheadset"");
            break;
        default:
            sb.append("" uimode="");
            sb.append(uiMode & UI_MODE_TYPE_MASK);
            break;
    }
    switch((uiMode & UI_MODE_NIGHT_MASK)) {
        case UI_MODE_NIGHT_UNDEFINED:
            sb.append("" ?night"");
            break;
        case UI_MODE_NIGHT_NO:
            /* not-night is not interesting to print */
            break;
        case UI_MODE_NIGHT_YES:
            sb.append("" night"");
            break;
        default:
            sb.append("" night="");
            sb.append(uiMode & UI_MODE_NIGHT_MASK);
            break;
    }
    switch(touchscreen) {
        case TOUCHSCREEN_UNDEFINED:
            sb.append("" ?touch"");
            break;
        case TOUCHSCREEN_NOTOUCH:
            sb.append("" -touch"");
            break;
        case TOUCHSCREEN_STYLUS:
            sb.append("" stylus"");
            break;
        case TOUCHSCREEN_FINGER:
            sb.append("" finger"");
            break;
        default:
            sb.append("" touch="");
            sb.append(touchscreen);
            break;
    }
    switch(keyboard) {
        case KEYBOARD_UNDEFINED:
            sb.append("" ?keyb"");
            break;
        case KEYBOARD_NOKEYS:
            sb.append("" -keyb"");
            break;
        case KEYBOARD_QWERTY:
            sb.append("" qwerty"");
            break;
        case KEYBOARD_12KEY:
            sb.append("" 12key"");
            break;
        default:
            sb.append("" keys="");
            sb.append(keyboard);
            break;
    }
    switch(keyboardHidden) {
        case KEYBOARDHIDDEN_UNDEFINED:
            sb.append(""/?"");
            break;
        case KEYBOARDHIDDEN_NO:
            sb.append(""/v"");
            break;
        case KEYBOARDHIDDEN_YES:
            sb.append(""/h"");
            break;
        case KEYBOARDHIDDEN_SOFT:
            sb.append(""/s"");
            break;
        default:
            sb.append(""/"");
            sb.append(keyboardHidden);
            break;
    }
    switch(hardKeyboardHidden) {
        case HARDKEYBOARDHIDDEN_UNDEFINED:
            sb.append(""/?"");
            break;
        case HARDKEYBOARDHIDDEN_NO:
            sb.append(""/v"");
            break;
        case HARDKEYBOARDHIDDEN_YES:
            sb.append(""/h"");
            break;
        default:
            sb.append(""/"");
            sb.append(hardKeyboardHidden);
            break;
    }
    switch(navigation) {
        case NAVIGATION_UNDEFINED:
            sb.append("" ?nav"");
            break;
        case NAVIGATION_NONAV:
            sb.append("" -nav"");
            break;
        case NAVIGATION_DPAD:
            sb.append("" dpad"");
            break;
        case NAVIGATION_TRACKBALL:
            sb.append("" tball"");
            break;
        case NAVIGATION_WHEEL:
            sb.append("" wheel"");
            break;
        default:
            sb.append("" nav="");
            sb.append(navigation);
            break;
    }
    switch(navigationHidden) {
        case NAVIGATIONHIDDEN_UNDEFINED:
            sb.append(""/?"");
            break;
        case NAVIGATIONHIDDEN_NO:
            sb.append(""/v"");
            break;
        case NAVIGATIONHIDDEN_YES:
            sb.append(""/h"");
            break;
        default:
            sb.append(""/"");
            sb.append(navigationHidden);
            break;
    }
    sb.append("" winConfig="");
    sb.append(windowConfiguration);
    if (assetsSeq != 0) {
        sb.append("" as."").append(assetsSeq);
    }
    if (seq != 0) {
        sb.append("" s."").append(seq);
    }
    sb.append('}');
    return sb.toString();
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,,,,
952,<android.app.Notification.Action.Builder: Action build()>,27,28,<android.app.Notification.Action.Builder: Action build()>,<android.app.Notification.Action.Builder: Action build()>,0,"{
    ArrayList<RemoteInput> dataOnlyInputs = new ArrayList<>();
    RemoteInput[] previousDataInputs = (RemoteInput[]) mExtras.getParcelableArray(EXTRA_DATA_ONLY_INPUTS);
    if (previousDataInputs != null) {
        for (RemoteInput input : previousDataInputs) {
            dataOnlyInputs.add(input);
        }
    }
    List<RemoteInput> textInputs = new ArrayList<>();
    if (mRemoteInputs != null) {
        for (RemoteInput input : mRemoteInputs) {
            if (input.isDataOnly()) {
                dataOnlyInputs.add(input);
            } else {
                textInputs.add(input);
            }
        }
    }
    if (!dataOnlyInputs.isEmpty()) {
        RemoteInput[] dataInputsArr = dataOnlyInputs.toArray(new RemoteInput[dataOnlyInputs.size()]);
        mExtras.putParcelableArray(EXTRA_DATA_ONLY_INPUTS, dataInputsArr);
    }
    RemoteInput[] textInputsArr = textInputs.isEmpty() ? null : textInputs.toArray(new RemoteInput[textInputs.size()]);
    return new Action(mIcon, mTitle, mIntent, mExtras, textInputsArr, mAllowGeneratedReplies);
}","{
    ArrayList<RemoteInput> dataOnlyInputs = new ArrayList<>();
    RemoteInput[] previousDataInputs = (RemoteInput[]) mExtras.getParcelableArray(EXTRA_DATA_ONLY_INPUTS);
    if (previousDataInputs != null) {
        for (RemoteInput input : previousDataInputs) {
            dataOnlyInputs.add(input);
        }
    }
    List<RemoteInput> textInputs = new ArrayList<>();
    if (mRemoteInputs != null) {
        for (RemoteInput input : mRemoteInputs) {
            if (input.isDataOnly()) {
                dataOnlyInputs.add(input);
            } else {
                textInputs.add(input);
            }
        }
    }
    if (!dataOnlyInputs.isEmpty()) {
        RemoteInput[] dataInputsArr = dataOnlyInputs.toArray(new RemoteInput[dataOnlyInputs.size()]);
        mExtras.putParcelableArray(EXTRA_DATA_ONLY_INPUTS, dataInputsArr);
    }
    RemoteInput[] textInputsArr = textInputs.isEmpty() ? null : textInputs.toArray(new RemoteInput[textInputs.size()]);
    return new Action(mIcon, mTitle, mIntent, mExtras, textInputsArr, mAllowGeneratedReplies, mSemanticAction);
}",1,"/**
 * Combine all of the options that have been set and return a new {@link Action}
 * object.
 * @return the built action
 */
","/**
 * Combine all of the options that have been set and return a new {@link Action}
 * object.
 * @return the built action
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,4",1,"In the late version implementation, an additional parameter ""mSemanticAction"" has been added to the constructor of the new 'Action' object. This is both an ""Other statement changed"" since it adds a parameter to the method invocation, and a ""Return statement changed"" since the 'Action' object that is returned will have a different state due to the extra parameter.","The additional parameter ""mSemanticAction"" in the late version can cause the method to return an 'Action' object with a different state, which could lead to a different behavior when interacting with the 'Action' object. Thus, it is a ""Compatibility Issue caused by potential different return values."""
953,<android.hardware.camera2.impl.CameraCaptureSessionImpl.IdleDrainListener: void onDrained()>,27,28,<android.hardware.camera2.impl.CameraCaptureSessionImpl.IdleDrainListener: void onDrained()>,<android.hardware.camera2.impl.CameraCaptureSessionImpl.IdleDrainListener: void onDrained()>,0,"{
    if (DEBUG)
        Log.v(TAG, mIdString + ""onIdleDrained"");
    // without causing a deadlock
    synchronized (mDeviceImpl.mInterfaceLock) {
        /*
                 * The device is now IDLE, and has settled. It will not transition to
                 * ACTIVE or BUSY again by itself.
                 *
                 * It's now safe to unconfigure the outputs.
                 *
                 * This operation is idempotent; a session will not be closed twice.
                 */
        if (DEBUG)
            Log.v(TAG, mIdString + ""Session drain complete, skip unconfigure: "" + mSkipUnconfigure);
        // as we won't get state updates any more anyway.
        if (mSkipUnconfigure) {
            return;
        }
        // everything is idle.
        try {
            // begin transition to unconfigured
            mDeviceImpl.configureStreamsChecked(/*inputConfig*/
            null, /*outputs*/
            null, /*operatingMode*/
            ICameraDeviceUser.NORMAL_MODE);
        } catch (CameraAccessException e) {
            // OK: do not throw checked exceptions.
            Log.e(TAG, mIdString + ""Exception while unconfiguring outputs: "", e);
        // TODO: call onError instead of onClosed if this happens
        } catch (IllegalStateException e) {
            // Camera is already closed, so nothing left to do
            if (DEBUG)
                Log.v(TAG, mIdString + ""Camera was already closed or busy, skipping unconfigure"");
        }
    }
}","{
    if (DEBUG)
        Log.v(TAG, mIdString + ""onIdleDrained"");
    // without causing a deadlock
    synchronized (mDeviceImpl.mInterfaceLock) {
        /*
                 * The device is now IDLE, and has settled. It will not transition to
                 * ACTIVE or BUSY again by itself.
                 *
                 * It's now safe to unconfigure the outputs.
                 *
                 * This operation is idempotent; a session will not be closed twice.
                 */
        if (DEBUG)
            Log.v(TAG, mIdString + ""Session drain complete, skip unconfigure: "" + mSkipUnconfigure);
        // as we won't get state updates any more anyway.
        if (mSkipUnconfigure) {
            return;
        }
        // everything is idle.
        try {
            // begin transition to unconfigured
            mDeviceImpl.configureStreamsChecked(/*inputConfig*/
            null, /*outputs*/
            null, /*operatingMode*/
            ICameraDeviceUser.NORMAL_MODE, /*sessionParams*/
            null);
        } catch (CameraAccessException e) {
            // OK: do not throw checked exceptions.
            Log.e(TAG, mIdString + ""Exception while unconfiguring outputs: "", e);
        // TODO: call onError instead of onClosed if this happens
        } catch (IllegalStateException e) {
            // Camera is already closed, so nothing left to do
            if (DEBUG)
                Log.v(TAG, mIdString + ""Camera was already closed or busy, skipping unconfigure"");
        }
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"4,5",0,"The change in the implementation is the addition of a new parameter, `null`, to the method `mDeviceImpl.configureStreamsChecked()`. This change falls under the category of 'Other statement changed' and also under 'Dependent API changed' because it modifies how a dependent API (`configureStreamsChecked`) is called with the number of parameters altered; hence code changes 4,5 apply.","There is no Compatibility Issue caused by potential different return values or types, nor by potential different exception handlings. The method definition and the way exceptions are handled remain unchanged. The additional parameter `null` for sessionParams does not affect how the method behaves from the caller's perspective; the extra parameter is for internal use within the `configureStreamsChecked` method. Therefore, the pred_CI is 0."
954,<android.service.autofill.CustomDescription: String toString()>,27,28,<android.service.autofill.CustomDescription: String toString()>,<android.service.autofill.CustomDescription: String toString()>,0,"{
    if (!sDebug)
        return super.toString();
    return new StringBuilder(""CustomDescription: [presentation="").append(mPresentation).append("", transformations="").append(mTransformations).append(""]"").toString();
}","{
    if (!sDebug)
        return super.toString();
    return new StringBuilder(""CustomDescription: [presentation="").append(mPresentation).append("", transformations="").append(mTransformations == null ? ""N/A"" : mTransformations.size()).append("", updates="").append(mUpdates == null ? ""N/A"" : mUpdates.size()).append(""]"").toString();
}",1,"// ///////////////////////////////////
","// ///////////////////////////////////
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,4",1,"The implementation has changed by appending additional details about transformations and updates to the StringBuilder, so the change types are 1 (Return statement changed) and 4 (Other statement changed).","The added conditional statements that check if 'mTransformations' and 'mUpdates' are null affect the return value, thus potentially causing the API to return a different value, which categorizes as type 1 (Compatibility Issue caused by potential different return values)."
955,"<android.content.res.TypedArray: int getLayoutDimension(int,int)>",27,28,"<android.content.res.TypedArray: int getLayoutDimension(int,int)>","<android.content.res.TypedArray: int getLayoutDimension(int,int)>",0,"{
    if (mRecycled) {
        throw new RuntimeException(""Cannot make calls to a recycled instance!"");
    }
    index *= AssetManager.STYLE_NUM_ENTRIES;
    final int[] data = mData;
    final int type = data[index + AssetManager.STYLE_TYPE];
    if (type >= TypedValue.TYPE_FIRST_INT && type <= TypedValue.TYPE_LAST_INT) {
        return data[index + AssetManager.STYLE_DATA];
    } else if (type == TypedValue.TYPE_DIMENSION) {
        return TypedValue.complexToDimensionPixelSize(data[index + AssetManager.STYLE_DATA], mMetrics);
    }
    return defValue;
}","{
    if (mRecycled) {
        throw new RuntimeException(""Cannot make calls to a recycled instance!"");
    }
    index *= STYLE_NUM_ENTRIES;
    final int[] data = mData;
    final int type = data[index + STYLE_TYPE];
    if (type >= TypedValue.TYPE_FIRST_INT && type <= TypedValue.TYPE_LAST_INT) {
        return data[index + STYLE_DATA];
    } else if (type == TypedValue.TYPE_DIMENSION) {
        return TypedValue.complexToDimensionPixelSize(data[index + STYLE_DATA], mMetrics);
    }
    return defValue;
}",1,"/**
 * Special version of {@link #getDimensionPixelSize} for retrieving
 * {@link android.view.ViewGroup}'s layout_width and layout_height
 * attributes.  This is only here for performance reasons; applications
 * should use {@link #getDimensionPixelSize}.
 *
 * @param index Index of the attribute to retrieve.
 * @param defValue The default value to return if this attribute is not
 * default or contains the wrong type of data.
 *
 * @return Attribute dimension value multiplied by the appropriate
 * metric and truncated to integer pixels.
 * @throws RuntimeException if the TypedArray has already been recycled.
 */
","/**
 * Special version of {@link #getDimensionPixelSize} for retrieving
 * {@link android.view.ViewGroup}'s layout_width and layout_height
 * attributes.  This is only here for performance reasons; applications
 * should use {@link #getDimensionPixelSize}.
 *
 * @param index Index of the attribute to retrieve.
 * @param defValue The default value to return if this attribute is not
 * default or contains the wrong type of data.
 *
 * @return Attribute dimension value multiplied by the appropriate
 * metric and truncated to integer pixels.
 * @throws RuntimeException if the TypedArray has already been recycled.
 */
",-1,,,-1,-1,-1,-1,-1,-1,0,0,"There are no changes in the implementation of the API between the early and late versions besides the removal of the AssetManager class qualifier before STYLE_NUM_ENTRIES, STYLE_TYPE and STYLE_DATA constants which appear redundant since they're likely being referenced from within the same class context that already has access to these static members.",There are no Compatibility Issues; the behavior and return value of the API have not changed between the versions.
956,<android.view.autofill.AutofillValue: String toString()>,27,28,<android.view.autofill.AutofillValue: String toString()>,<android.view.autofill.AutofillValue: String toString()>,0,"{
    if (!sDebug)
        return super.toString();
    final StringBuilder string = new StringBuilder().append(""[type="").append(mType).append("", value="");
    if (isText()) {
        string.append(((CharSequence) mValue).length()).append(""_chars"");
    } else {
        string.append(mValue);
    }
    return string.append(']').toString();
}","{
    if (!sDebug)
        return super.toString();
    final StringBuilder string = new StringBuilder().append(""[type="").append(mType).append("", value="");
    if (isText()) {
        Helper.appendRedacted(string, (CharSequence) mValue);
    } else {
        string.append(mValue);
    }
    return string.append(']').toString();
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"4,5",1,"The implementation of how the string is built when the value is of text type has been changed from directly appending the length of the sequence to using a Helper method `Helper.appendRedacted(string, (CharSequence) mValue);`. This indicates a dependency on another method (Helper.appendRedacted), thus the change types are 4,5.","This change will result in a different `toString` representation (value) when `sDebug` is true and the `mValue` is of text type, therefore, there is a potential for different return values. The CI type is 1."
957,"<android.text.BoringLayout: BoringLayout make(CharSequence,TextPaint,int,Alignment,float,float,Metrics,boolean)>",27,28,"<android.text.BoringLayout: BoringLayout make(CharSequence,TextPaint,int,Alignment,float,float,Metrics,boolean)>","<android.text.BoringLayout: BoringLayout make(CharSequence,TextPaint,int,Alignment,float,float,Metrics,boolean)>",0,"{
    return new BoringLayout(source, paint, outerwidth, align, spacingmult, spacingadd, metrics, includepad);
}","{
    return new BoringLayout(source, paint, outerWidth, align, spacingMult, spacingAdd, metrics, includePad);
}",1,,"/**
 * Utility function to construct a BoringLayout instance.
 *
 * @param source the text to render
 * @param paint the default paint for the layout
 * @param outerWidth the wrapping width for the text
 * @param align whether to left, right, or center the text
 * @param spacingMult this value is no longer used by BoringLayout
 * @param spacingAdd this value is no longer used by BoringLayout
 * @param metrics {@code #Metrics} instance that contains information about FontMetrics and
 * line width
 * @param includePad set whether to include extra space beyond font ascent and descent which is
 * needed to avoid clipping in some scripts
 */
",-1,,,-1,-1,-1,-1,-1,-1,0,0,"The implementation of the method did not change; the difference is only in the variable name casing, which doesn't affect the API behavior.",There is no Compatibility Issue as the functionality of the API remains the same between versions. The variable names' capitalization does not change the behavior or outcome of the method.
958,<android.speech.tts.SynthesisPlaybackQueueItem: void stop(int)>,27,28,<android.speech.tts.SynthesisPlaybackQueueItem: void stop(int)>,<android.speech.tts.SynthesisPlaybackQueueItem: void stop(int)>,0,"{
    try {
        mListLock.lock();
        // Update our internal state.
        mStopped = true;
        mStatusCode = statusCode;
        // Wake up the audio playback thread if it was waiting on take().
        // take() will return null since mStopped was true, and will then
        // break out of the data write loop.
        mReadReady.signal();
        // Wake up the synthesis thread if it was waiting on put(). Its
        // buffers will no longer be copied since mStopped is true. The
        // PlaybackSynthesisCallback that this synthesis corresponds to
        // would also have been stopped, and so all calls to
        // Callback.onDataAvailable( ) will return errors too.
        mNotFull.signal();
    } finally {
        mListLock.unlock();
    }
    // Stop the underlying audio track. This will stop sending
    // data to the mixer and discard any pending buffers that the
    // track holds.
    mAudioTrack.stop();
}","{
    try {
        mListLock.lock();
        // Update our internal state.
        mStopped = true;
        mStatusCode = statusCode;
        // Wake up the synthesis thread if it was waiting on put(). Its
        // buffers will no longer be copied since mStopped is true. The
        // PlaybackSynthesisCallback that this synthesis corresponds to
        // would also have been stopped, and so all calls to
        // Callback.onDataAvailable( ) will return errors too.
        mNotFull.signal();
        if (mRunState.getAndSet(STOP_CALLED) == NOT_RUN) {
            // Dispatch the status code and just finish. Signaling audio
            // playback is not necessary because run() hasn't started.
            dispatchEndStatus();
            return;
        }
        // Wake up the audio playback thread if it was waiting on take().
        // take() will return null since mStopped was true, and will then
        // break out of the data write loop.
        mReadReady.signal();
    } finally {
        mListLock.unlock();
    }
    // Stop the underlying audio track. This will stop sending
    // data to the mixer and discard any pending buffers that the
    // track holds.
    mAudioTrack.stop();
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,3",0,"The late version includes an extra if condition with assignment and a method call within the try block, which potentially modifies the execution order of the statements (`mReadReady.signal()` gets executed after the new if block, and a new method `dispatchEndStatus()` is introduced). Therefore, the change includes control dependency change (3) and other statement change due to the added if condition's statements (1).","While there has been a change to the internal control flow of the method, this does not necessarily lead to a compatibility issue for the callers of the method. The contract of the method appears to be that it stops the playback; the precise internal sequence of signaling and status updates does not affect that contract from the perspective of the caller. Assuming the new condition and associated method `dispatchEndStatus()` do not alter the observable behavior (return type, exceptions, observable state) that callers depend on, there would be no compatibility issue. The method still doesn't return any value or throw checked exceptions that are documented or part of the method signature. Therefore, the prediction for Compatibility Issue is 0."
960,<android.hardware.radio.TunerAdapter: boolean isAntennaConnected()>,27,28,<android.hardware.radio.TunerAdapter: boolean isAntennaConnected()>,<android.hardware.radio.TunerAdapter: boolean isAntennaConnected()>,0,"{
    try {
        return mTuner.isAntennaConnected();
    } catch (RemoteException e) {
        throw new RuntimeException(""service died"", e);
    }
}","{
    return mCallback.isAntennaConnected();
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"4,5","1,2","The implementation of the method has changed from using `mTuner.isAntennaConnected()` to `mCallback.isAntennaConnected()`, which is a change in the dependent API being used, so the code change types are 4 and 5.","The change in the dependent API used for checking if the antenna is connected could lead to a different return value if `mTuner` and `mCallback` behave differently. Moreover, the earlier implementation had a try-catch block to handle `RemoteException`, which has been removed in the late version. These may cause potential different return values or types and different exception handlings, so the CI types are 1 and 2."
961,"<android.app.usage.NetworkStatsManager: Bucket querySummaryForDevice(int,String,long,long)>",27,28,"<android.app.usage.NetworkStatsManager: Bucket querySummaryForDevice(int,String,long,long)>","<android.app.usage.NetworkStatsManager: Bucket querySummaryForDevice(int,String,long,long)>",0,"{
    NetworkTemplate template;
    try {
        template = createTemplate(networkType, subscriberId);
    } catch (IllegalArgumentException e) {
        if (DBG)
            Log.e(TAG, ""Cannot create template"", e);
        return null;
    }
    Bucket bucket = null;
    NetworkStats stats = new NetworkStats(mContext, template, mFlags, startTime, endTime);
    bucket = stats.getDeviceSummaryForNetwork();
    stats.close();
    return bucket;
}","{
    NetworkTemplate template;
    try {
        template = createTemplate(networkType, subscriberId);
    } catch (IllegalArgumentException e) {
        if (DBG)
            Log.e(TAG, ""Cannot create template"", e);
        return null;
    }
    return querySummaryForDevice(template, startTime, endTime);
}",1,"/**
 * Query network usage statistics summaries. Result is summarised data usage for the whole
 * device. Result is a single Bucket aggregated over time, state, uid, tag, metered, and
 * roaming. This means the bucket's start and end timestamp are going to be the same as the
 * 'startTime' and 'endTime' parameters. State is going to be
 * {@link NetworkStats.Bucket#STATE_ALL}, uid {@link NetworkStats.Bucket#UID_ALL},
 * tag {@link NetworkStats.Bucket#TAG_NONE}, metered {@link NetworkStats.Bucket#METERED_ALL},
 * and roaming {@link NetworkStats.Bucket#ROAMING_ALL}.
 *
 * @param networkType As defined in {@link ConnectivityManager}, e.g.
 * {@link ConnectivityManager#TYPE_MOBILE}, {@link ConnectivityManager#TYPE_WIFI}
 * etc.
 * @param subscriberId If applicable, the subscriber id of the network interface.
 * @param startTime Start of period. Defined in terms of ""Unix time"", see
 * {@link java.lang.System#currentTimeMillis}.
 * @param endTime End of period. Defined in terms of ""Unix time"", see
 * {@link java.lang.System#currentTimeMillis}.
 * @return Bucket object or null if permissions are insufficient or error happened during
 * statistics collection.
 */
","/**
 * Query network usage statistics summaries. Result is summarised data usage for the whole
 * device. Result is a single Bucket aggregated over time, state, uid, tag, metered, and
 * roaming. This means the bucket's start and end timestamp are going to be the same as the
 * 'startTime' and 'endTime' parameters. State is going to be
 * {@link NetworkStats.Bucket#STATE_ALL}, uid {@link NetworkStats.Bucket#UID_ALL},
 * tag {@link NetworkStats.Bucket#TAG_NONE},
 * default network {@link NetworkStats.Bucket#DEFAULT_NETWORK_ALL},
 * metered {@link NetworkStats.Bucket#METERED_ALL},
 * and roaming {@link NetworkStats.Bucket#ROAMING_ALL}.
 *
 * @param networkType As defined in {@link ConnectivityManager}, e.g.
 * {@link ConnectivityManager#TYPE_MOBILE}, {@link ConnectivityManager#TYPE_WIFI}
 * etc.
 * @param subscriberId If applicable, the subscriber id of the network interface.
 * @param startTime Start of period. Defined in terms of ""Unix time"", see
 * {@link java.lang.System#currentTimeMillis}.
 * @param endTime End of period. Defined in terms of ""Unix time"", see
 * {@link java.lang.System#currentTimeMillis}.
 * @return Bucket object or null if permissions are insufficient or error happened during
 * statistics collection.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The implementation of creating a Bucket instance and handling it has been replaced by a call to another method querySummaryForDevice with a different signature, so the code change types are 1,5.","The changed return statement implies that the API may now return different data because it relies on the return value of a different method, potentially leading to a different return value or type. Hence, the CI type is 1."
962,<android.view.textclassifier.TextSelection: String toString()>,27,28,<android.view.textclassifier.TextSelection: String toString()>,<android.view.textclassifier.TextSelection: String toString()>,0,"{
    return String.format(""TextSelection {%d, %d, %s}"", mStartIndex, mEndIndex, mEntityConfidence);
}","{
    return String.format(Locale.US, ""TextSelection {id=%s, startIndex=%d, endIndex=%d, entities=%s}"", mId, mStartIndex, mEndIndex, mEntityConfidence);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,4",1,"The String returned by toString() has changed which includes additional information, and this includes the change of format as well as additional parameters passed to String.format method. Therefore, the code change type is 1, since it involves changing the return statement, and 4 as it includes a modification in the format and parameters of the method call.","The structure of the String returned by toString() has been altered, which means that calling code expecting a specific format might behave differently or incorrectly. Hence, the CI type is 1."
964,<android.view.textclassifier.TextClassification: OnClickListener getOnClickListener()>,27,28,<android.view.textclassifier.TextClassification: OnClickListener getOnClickListener()>,<android.view.textclassifier.TextClassification: OnClickListener getOnClickListener()>,0,"{
    return mOnClickListener;
}","{
    return mLegacyOnClickListener;
}",1,"/**
 * Returns an OnClickListener that may be triggered to act on the classified text.
 */
","/**
 * Returns the OnClickListener that may be triggered to act on the classified text.
 *
 * <p><strong>NOTE: </strong>This field is not parcelable and only represents the first
 * {@link RemoteAction} (if one exists) when this object is read from a parcel.
 *
 * @deprecated Use {@link #getActions()} instead.
 */
",-1,[@Nullable],[@Nullable],-1,-1,-1,-1,-1,-1,1,1,"The object being returned has changed from mOnClickListener to mLegacyOnClickListener, so the change type is 1 because the return statement now returns a different variable.","Since the method in the late version returns a different variable, it could lead to a change in the behavior of the API if the objects referred by mOnClickListener and mLegacyOnClickListener are not functionally equivalent. Therefore, the CI type is 1."
965,"<android.view.autofill.AutofillManager: void notifyViewExited(View,int)>",27,28,"<android.view.autofill.AutofillManager: void notifyViewExited(View,int)>","<android.view.autofill.AutofillManager: void notifyViewExited(View,int)>",0,"{
    if (!hasAutofillFeature()) {
        return;
    }
    synchronized (mLock) {
        ensureServiceClientAddedIfNeededLocked();
        if (mEnabled && isActiveLocked()) {
            final AutofillId id = getAutofillId(view, virtualId);
            // Update focus on existing session.
            updateSessionLocked(id, null, null, ACTION_VIEW_EXITED, 0);
        }
    }
}","{
    if (sVerbose)
        Log.v(TAG, ""notifyViewExited("" + view.getAutofillId() + "", "" + virtualId);
    if (!hasAutofillFeature()) {
        return;
    }
    synchronized (mLock) {
        notifyViewExitedLocked(view, virtualId);
    }
}",1,"/**
 * Called when a virtual view that supports autofill is exited.
 *
 * @param view the virtual view parent.
 * @param virtualId id identifying the virtual child inside the parent view.
 */
","/**
 * Called when a virtual view that supports autofill is exited.
 *
 * @param view the virtual view parent.
 * @param virtualId id identifying the virtual child inside the parent view.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",0,"There is a control dependency change since an additional logging statement has been added when the verbose flag (`sVerbose`) is true. Additionally, there's an 'Other statement changed' because the implementation within the synchronized block was refactored to call `notifyViewExitedLocked(view, virtualId);` in place of the previous implementation. This could indicate internal restructuring, but without seeing the implementation of `notifyViewExitedLocked`, we can't tell for sure if it's merely a renaming or if the behavior changed as well.","There is no Compatibility Issue because the added log statement is dependent on a verbose flag which doesn't affect the functional behavior of the method. The refactoring within the synchronized block appears to be an internal cleanup that presumably does not change the externally observable behavior of the method. The external behavior of the API should remain the same, assuming `notifyViewExitedLocked(view, virtualId);` is functionally identical to the inlined code it replaces. Without further information on internal method changes, we assume no compatibility issue."
966,"<android.view.View: void setFlags(int,int)>",27,28,"<android.view.View: void setFlags(int,int)>","<android.view.View: void setFlags(int,int)>",0,"{
    final boolean accessibilityEnabled = AccessibilityManager.getInstance(mContext).isEnabled();
    final boolean oldIncludeForAccessibility = accessibilityEnabled && includeForAccessibility();
    int old = mViewFlags;
    mViewFlags = (mViewFlags & ~mask) | (flags & mask);
    int changed = mViewFlags ^ old;
    if (changed == 0) {
        return;
    }
    int privateFlags = mPrivateFlags;
    // If focusable is auto, update the FOCUSABLE bit.
    int focusableChangedByAuto = 0;
    if (((mViewFlags & FOCUSABLE_AUTO) != 0) && (changed & (FOCUSABLE_MASK | CLICKABLE)) != 0) {
        // Heuristic only takes into account whether view is clickable.
        final int newFocus;
        if ((mViewFlags & CLICKABLE) != 0) {
            newFocus = FOCUSABLE;
        } else {
            newFocus = NOT_FOCUSABLE;
        }
        mViewFlags = (mViewFlags & ~FOCUSABLE) | newFocus;
        focusableChangedByAuto = (old & FOCUSABLE) ^ (newFocus & FOCUSABLE);
        changed = (changed & ~FOCUSABLE) | focusableChangedByAuto;
    }
    /* Check if the FOCUSABLE bit has changed */
    if (((changed & FOCUSABLE) != 0) && ((privateFlags & PFLAG_HAS_BOUNDS) != 0)) {
        if (((old & FOCUSABLE) == FOCUSABLE) && ((privateFlags & PFLAG_FOCUSED) != 0)) {
            /* Give up focus if we are no longer focusable */
            clearFocus();
            if (mParent instanceof ViewGroup) {
                ((ViewGroup) mParent).clearFocusedInCluster();
            }
        } else if (((old & FOCUSABLE) == NOT_FOCUSABLE) && ((privateFlags & PFLAG_FOCUSED) == 0)) {
            /*
                 * Tell the view system that we are now available to take focus
                 * if no one else already has it.
                 */
            if (mParent != null) {
                ViewRootImpl viewRootImpl = getViewRootImpl();
                if (!sAutoFocusableOffUIThreadWontNotifyParents || focusableChangedByAuto == 0 || viewRootImpl == null || viewRootImpl.mThread == Thread.currentThread()) {
                    mParent.focusableViewAvailable(this);
                }
            }
        }
    }
    final int newVisibility = flags & VISIBILITY_MASK;
    if (newVisibility == VISIBLE) {
        if ((changed & VISIBILITY_MASK) != 0) {
            /*
                 * If this view is becoming visible, invalidate it in case it changed while
                 * it was not visible. Marking it drawn ensures that the invalidation will
                 * go through.
                 */
            mPrivateFlags |= PFLAG_DRAWN;
            invalidate(true);
            needGlobalAttributesUpdate(true);
            // the root view try to give this focus if nothing else does.
            if ((mParent != null) && (mBottom > mTop) && (mRight > mLeft)) {
                mParent.focusableViewAvailable(this);
            }
        }
    }
    /* Check if the GONE bit has changed */
    if ((changed & GONE) != 0) {
        needGlobalAttributesUpdate(false);
        requestLayout();
        if (((mViewFlags & VISIBILITY_MASK) == GONE)) {
            if (hasFocus()) {
                clearFocus();
                if (mParent instanceof ViewGroup) {
                    ((ViewGroup) mParent).clearFocusedInCluster();
                }
            }
            clearAccessibilityFocus();
            destroyDrawingCache();
            if (mParent instanceof View) {
                // GONE views noop invalidation, so invalidate the parent
                ((View) mParent).invalidate(true);
            }
            // Mark the view drawn to ensure that it gets invalidated properly the next
            // time it is visible and gets invalidated
            mPrivateFlags |= PFLAG_DRAWN;
        }
        if (mAttachInfo != null) {
            mAttachInfo.mViewVisibilityChanged = true;
        }
    }
    /* Check if the VISIBLE bit has changed */
    if ((changed & INVISIBLE) != 0) {
        needGlobalAttributesUpdate(false);
        /*
             * If this view is becoming invisible, set the DRAWN flag so that
             * the next invalidate() will not be skipped.
             */
        mPrivateFlags |= PFLAG_DRAWN;
        if (((mViewFlags & VISIBILITY_MASK) == INVISIBLE)) {
            // root view becoming invisible shouldn't clear focus and accessibility focus
            if (getRootView() != this) {
                if (hasFocus()) {
                    clearFocus();
                    if (mParent instanceof ViewGroup) {
                        ((ViewGroup) mParent).clearFocusedInCluster();
                    }
                }
                clearAccessibilityFocus();
            }
        }
        if (mAttachInfo != null) {
            mAttachInfo.mViewVisibilityChanged = true;
        }
    }
    if ((changed & VISIBILITY_MASK) != 0) {
        // If the view is invisible, cleanup its display list to free up resources
        if (newVisibility != VISIBLE && mAttachInfo != null) {
            cleanupDraw();
        }
        if (mParent instanceof ViewGroup) {
            ((ViewGroup) mParent).onChildVisibilityChanged(this, (changed & VISIBILITY_MASK), newVisibility);
            ((View) mParent).invalidate(true);
        } else if (mParent != null) {
            mParent.invalidateChild(this, null);
        }
        if (mAttachInfo != null) {
            dispatchVisibilityChanged(this, newVisibility);
            // to change animation states.
            if (mParent != null && getWindowVisibility() == VISIBLE && ((!(mParent instanceof ViewGroup)) || ((ViewGroup) mParent).isShown())) {
                dispatchVisibilityAggregated(newVisibility == VISIBLE);
            }
            notifySubtreeAccessibilityStateChangedIfNeeded();
        }
    }
    if ((changed & WILL_NOT_CACHE_DRAWING) != 0) {
        destroyDrawingCache();
    }
    if ((changed & DRAWING_CACHE_ENABLED) != 0) {
        destroyDrawingCache();
        mPrivateFlags &= ~PFLAG_DRAWING_CACHE_VALID;
        invalidateParentCaches();
    }
    if ((changed & DRAWING_CACHE_QUALITY_MASK) != 0) {
        destroyDrawingCache();
        mPrivateFlags &= ~PFLAG_DRAWING_CACHE_VALID;
    }
    if ((changed & DRAW_MASK) != 0) {
        if ((mViewFlags & WILL_NOT_DRAW) != 0) {
            if (mBackground != null || mDefaultFocusHighlight != null || (mForegroundInfo != null && mForegroundInfo.mDrawable != null)) {
                mPrivateFlags &= ~PFLAG_SKIP_DRAW;
            } else {
                mPrivateFlags |= PFLAG_SKIP_DRAW;
            }
        } else {
            mPrivateFlags &= ~PFLAG_SKIP_DRAW;
        }
        requestLayout();
        invalidate(true);
    }
    if ((changed & KEEP_SCREEN_ON) != 0) {
        if (mParent != null && mAttachInfo != null && !mAttachInfo.mRecomputeGlobalAttributes) {
            mParent.recomputeViewAttributes(this);
        }
    }
    if (accessibilityEnabled) {
        if ((changed & FOCUSABLE) != 0 || (changed & VISIBILITY_MASK) != 0 || (changed & CLICKABLE) != 0 || (changed & LONG_CLICKABLE) != 0 || (changed & CONTEXT_CLICKABLE) != 0) {
            if (oldIncludeForAccessibility != includeForAccessibility()) {
                notifySubtreeAccessibilityStateChangedIfNeeded();
            } else {
                notifyViewAccessibilityStateChangedIfNeeded(AccessibilityEvent.CONTENT_CHANGE_TYPE_UNDEFINED);
            }
        } else if ((changed & ENABLED_MASK) != 0) {
            notifyViewAccessibilityStateChangedIfNeeded(AccessibilityEvent.CONTENT_CHANGE_TYPE_UNDEFINED);
        }
    }
}","{
    final boolean accessibilityEnabled = AccessibilityManager.getInstance(mContext).isEnabled();
    final boolean oldIncludeForAccessibility = accessibilityEnabled && includeForAccessibility();
    int old = mViewFlags;
    mViewFlags = (mViewFlags & ~mask) | (flags & mask);
    int changed = mViewFlags ^ old;
    if (changed == 0) {
        return;
    }
    int privateFlags = mPrivateFlags;
    boolean shouldNotifyFocusableAvailable = false;
    // If focusable is auto, update the FOCUSABLE bit.
    int focusableChangedByAuto = 0;
    if (((mViewFlags & FOCUSABLE_AUTO) != 0) && (changed & (FOCUSABLE_MASK | CLICKABLE)) != 0) {
        // Heuristic only takes into account whether view is clickable.
        final int newFocus;
        if ((mViewFlags & CLICKABLE) != 0) {
            newFocus = FOCUSABLE;
        } else {
            newFocus = NOT_FOCUSABLE;
        }
        mViewFlags = (mViewFlags & ~FOCUSABLE) | newFocus;
        focusableChangedByAuto = (old & FOCUSABLE) ^ (newFocus & FOCUSABLE);
        changed = (changed & ~FOCUSABLE) | focusableChangedByAuto;
    }
    /* Check if the FOCUSABLE bit has changed */
    if (((changed & FOCUSABLE) != 0) && ((privateFlags & PFLAG_HAS_BOUNDS) != 0)) {
        if (((old & FOCUSABLE) == FOCUSABLE) && ((privateFlags & PFLAG_FOCUSED) != 0)) {
            /* Give up focus if we are no longer focusable */
            clearFocus();
            if (mParent instanceof ViewGroup) {
                ((ViewGroup) mParent).clearFocusedInCluster();
            }
        } else if (((old & FOCUSABLE) == NOT_FOCUSABLE) && ((privateFlags & PFLAG_FOCUSED) == 0)) {
            /*
                 * Tell the view system that we are now available to take focus
                 * if no one else already has it.
                 */
            if (mParent != null) {
                ViewRootImpl viewRootImpl = getViewRootImpl();
                if (!sAutoFocusableOffUIThreadWontNotifyParents || focusableChangedByAuto == 0 || viewRootImpl == null || viewRootImpl.mThread == Thread.currentThread()) {
                    shouldNotifyFocusableAvailable = canTakeFocus();
                }
            }
        }
    }
    final int newVisibility = flags & VISIBILITY_MASK;
    if (newVisibility == VISIBLE) {
        if ((changed & VISIBILITY_MASK) != 0) {
            /*
                 * If this view is becoming visible, invalidate it in case it changed while
                 * it was not visible. Marking it drawn ensures that the invalidation will
                 * go through.
                 */
            mPrivateFlags |= PFLAG_DRAWN;
            invalidate(true);
            needGlobalAttributesUpdate(true);
            // a view becoming visible is worth notifying the parent about in case nothing has
            // focus. Even if this specific view isn't focusable, it may contain something that
            // is, so let the root view try to give this focus if nothing else does.
            shouldNotifyFocusableAvailable = hasSize();
        }
    }
    if ((changed & ENABLED_MASK) != 0) {
        if ((mViewFlags & ENABLED_MASK) == ENABLED) {
            // a view becoming enabled should notify the parent as long as the view is also
            // visible and the parent wasn't already notified by becoming visible during this
            // setFlags invocation.
            shouldNotifyFocusableAvailable = canTakeFocus();
        } else {
            if (isFocused())
                clearFocus();
        }
    }
    if (shouldNotifyFocusableAvailable && mParent != null) {
        mParent.focusableViewAvailable(this);
    }
    /* Check if the GONE bit has changed */
    if ((changed & GONE) != 0) {
        needGlobalAttributesUpdate(false);
        requestLayout();
        if (((mViewFlags & VISIBILITY_MASK) == GONE)) {
            if (hasFocus()) {
                clearFocus();
                if (mParent instanceof ViewGroup) {
                    ((ViewGroup) mParent).clearFocusedInCluster();
                }
            }
            clearAccessibilityFocus();
            destroyDrawingCache();
            if (mParent instanceof View) {
                // GONE views noop invalidation, so invalidate the parent
                ((View) mParent).invalidate(true);
            }
            // Mark the view drawn to ensure that it gets invalidated properly the next
            // time it is visible and gets invalidated
            mPrivateFlags |= PFLAG_DRAWN;
        }
        if (mAttachInfo != null) {
            mAttachInfo.mViewVisibilityChanged = true;
        }
    }
    /* Check if the VISIBLE bit has changed */
    if ((changed & INVISIBLE) != 0) {
        needGlobalAttributesUpdate(false);
        /*
             * If this view is becoming invisible, set the DRAWN flag so that
             * the next invalidate() will not be skipped.
             */
        mPrivateFlags |= PFLAG_DRAWN;
        if (((mViewFlags & VISIBILITY_MASK) == INVISIBLE)) {
            // root view becoming invisible shouldn't clear focus and accessibility focus
            if (getRootView() != this) {
                if (hasFocus()) {
                    clearFocus();
                    if (mParent instanceof ViewGroup) {
                        ((ViewGroup) mParent).clearFocusedInCluster();
                    }
                }
                clearAccessibilityFocus();
            }
        }
        if (mAttachInfo != null) {
            mAttachInfo.mViewVisibilityChanged = true;
        }
    }
    if ((changed & VISIBILITY_MASK) != 0) {
        // If the view is invisible, cleanup its display list to free up resources
        if (newVisibility != VISIBLE && mAttachInfo != null) {
            cleanupDraw();
        }
        if (mParent instanceof ViewGroup) {
            ((ViewGroup) mParent).onChildVisibilityChanged(this, (changed & VISIBILITY_MASK), newVisibility);
            ((View) mParent).invalidate(true);
        } else if (mParent != null) {
            mParent.invalidateChild(this, null);
        }
        if (mAttachInfo != null) {
            dispatchVisibilityChanged(this, newVisibility);
            // to change animation states.
            if (mParent != null && getWindowVisibility() == VISIBLE && ((!(mParent instanceof ViewGroup)) || ((ViewGroup) mParent).isShown())) {
                dispatchVisibilityAggregated(newVisibility == VISIBLE);
            }
            notifySubtreeAccessibilityStateChangedIfNeeded();
        }
    }
    if ((changed & WILL_NOT_CACHE_DRAWING) != 0) {
        destroyDrawingCache();
    }
    if ((changed & DRAWING_CACHE_ENABLED) != 0) {
        destroyDrawingCache();
        mPrivateFlags &= ~PFLAG_DRAWING_CACHE_VALID;
        invalidateParentCaches();
    }
    if ((changed & DRAWING_CACHE_QUALITY_MASK) != 0) {
        destroyDrawingCache();
        mPrivateFlags &= ~PFLAG_DRAWING_CACHE_VALID;
    }
    if ((changed & DRAW_MASK) != 0) {
        if ((mViewFlags & WILL_NOT_DRAW) != 0) {
            if (mBackground != null || mDefaultFocusHighlight != null || (mForegroundInfo != null && mForegroundInfo.mDrawable != null)) {
                mPrivateFlags &= ~PFLAG_SKIP_DRAW;
            } else {
                mPrivateFlags |= PFLAG_SKIP_DRAW;
            }
        } else {
            mPrivateFlags &= ~PFLAG_SKIP_DRAW;
        }
        requestLayout();
        invalidate(true);
    }
    if ((changed & KEEP_SCREEN_ON) != 0) {
        if (mParent != null && mAttachInfo != null && !mAttachInfo.mRecomputeGlobalAttributes) {
            mParent.recomputeViewAttributes(this);
        }
    }
    if (accessibilityEnabled) {
        // a state change, so we really don't need to report other changes.
        if (isAccessibilityPane()) {
            changed &= ~VISIBILITY_MASK;
        }
        if ((changed & FOCUSABLE) != 0 || (changed & VISIBILITY_MASK) != 0 || (changed & CLICKABLE) != 0 || (changed & LONG_CLICKABLE) != 0 || (changed & CONTEXT_CLICKABLE) != 0) {
            if (oldIncludeForAccessibility != includeForAccessibility()) {
                notifySubtreeAccessibilityStateChangedIfNeeded();
            } else {
                notifyViewAccessibilityStateChangedIfNeeded(AccessibilityEvent.CONTENT_CHANGE_TYPE_UNDEFINED);
            }
        } else if ((changed & ENABLED_MASK) != 0) {
            notifyViewAccessibilityStateChangedIfNeeded(AccessibilityEvent.CONTENT_CHANGE_TYPE_UNDEFINED);
        }
    }
}",1,"/**
 * Set flags controlling behavior of this view.
 *
 * @param flags Constant indicating the value which should be set
 * @param mask Constant indicating the bit range that should be changed
 */
","/**
 * Set flags controlling behavior of this view.
 *
 * @param flags Constant indicating the value which should be set
 * @param mask Constant indicating the bit range that should be changed
 */
",-1,,,-1,-1,-1,-1,-1,-1,,,,
967,<android.widget.TextView: void onRestoreInstanceState(Parcelable)>,27,28,<android.widget.TextView: void onRestoreInstanceState(Parcelable)>,<android.widget.TextView: void onRestoreInstanceState(Parcelable)>,0,"{
    if (!(state instanceof SavedState)) {
        super.onRestoreInstanceState(state);
        return;
    }
    SavedState ss = (SavedState) state;
    super.onRestoreInstanceState(ss.getSuperState());
    // XXX restore buffer type too, as well as lots of other stuff
    if (ss.text != null) {
        setText(ss.text);
    }
    if (ss.selStart >= 0 && ss.selEnd >= 0) {
        if (mText instanceof Spannable) {
            int len = mText.length();
            if (ss.selStart > len || ss.selEnd > len) {
                String restored = """";
                if (ss.text != null) {
                    restored = ""(restored) "";
                }
                Log.e(LOG_TAG, ""Saved cursor position "" + ss.selStart + ""/"" + ss.selEnd + "" out of range for "" + restored + ""text "" + mText);
            } else {
                Selection.setSelection((Spannable) mText, ss.selStart, ss.selEnd);
                if (ss.frozenWithFocus) {
                    createEditorIfNeeded();
                    mEditor.mFrozenWithFocus = true;
                }
            }
        }
    }
    if (ss.error != null) {
        final CharSequence error = ss.error;
        // Display the error later, after the first layout pass
        post(new Runnable() {

            public void run() {
                if (mEditor == null || !mEditor.mErrorWasChanged) {
                    setError(error);
                }
            }
        });
    }
    if (ss.editorState != null) {
        createEditorIfNeeded();
        mEditor.restoreInstanceState(ss.editorState);
    }
}","{
    if (!(state instanceof SavedState)) {
        super.onRestoreInstanceState(state);
        return;
    }
    SavedState ss = (SavedState) state;
    super.onRestoreInstanceState(ss.getSuperState());
    // XXX restore buffer type too, as well as lots of other stuff
    if (ss.text != null) {
        setText(ss.text);
    }
    if (ss.selStart >= 0 && ss.selEnd >= 0) {
        if (mSpannable != null) {
            int len = mText.length();
            if (ss.selStart > len || ss.selEnd > len) {
                String restored = """";
                if (ss.text != null) {
                    restored = ""(restored) "";
                }
                Log.e(LOG_TAG, ""Saved cursor position "" + ss.selStart + ""/"" + ss.selEnd + "" out of range for "" + restored + ""text "" + mText);
            } else {
                Selection.setSelection(mSpannable, ss.selStart, ss.selEnd);
                if (ss.frozenWithFocus) {
                    createEditorIfNeeded();
                    mEditor.mFrozenWithFocus = true;
                }
            }
        }
    }
    if (ss.error != null) {
        final CharSequence error = ss.error;
        // Display the error later, after the first layout pass
        post(new Runnable() {

            public void run() {
                if (mEditor == null || !mEditor.mErrorWasChanged) {
                    setError(error);
                }
            }
        });
    }
    if (ss.editorState != null) {
        createEditorIfNeeded();
        mEditor.restoreInstanceState(ss.editorState);
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,3,0,"The check condition for `if (mText instanceof Spannable)` changed to `if (mSpannable != null)` and the related variable from `(Spannable) mText` to `mSpannable` within the if block. Since `mSpannable` is assigned from `mText` if `mText` is an instance of `Spannable`, this is a refactor that does not affect the external behavior of the method, so the code change type is 3.","There is no Compatibility Issue here, as the refactor does not change the behavior of the method with respect to how it handles the input or what output it produces. The internal change doesn't affect the overall API contract or its interaction with external code."
968,"<android.provider.Settings.Global: boolean putString(ContentResolver,String,String)>",27,28,"<android.provider.Settings.Global: boolean putString(ContentResolver,String,String)>","<android.provider.Settings.Global: boolean putString(ContentResolver,String,String)>",0,"{
    return putStringForUser(resolver, name, value, null, false, UserHandle.myUserId());
}","{
    return putStringForUser(resolver, name, value, null, false, resolver.getUserId());
}",1,"/**
 * Store a name/value pair into the database.
 * @param resolver to access the database with
 * @param name to store
 * @param value to associate with the name
 * @return true if the value was set, false on database errors
 */
","/**
 * Store a name/value pair into the database.
 * @param resolver to access the database with
 * @param name to store
 * @param value to associate with the name
 * @return true if the value was set, false on database errors
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,1,"The code change consists of altering the last parameter passed to the method putStringForUser from UserHandle.myUserId() to resolver.getUserId(), which indicates that a dependent API has changed. Thus, the code change type is 5.","The change in which user ID is obtained and passed to putStringForUser may alter which user's settings the string is being put for. This leads to different behaviors depending on the user context. Therefore, there is a Compatibility Issue caused by potential different return values or types, and the CI type is 1."
969,<android.content.res.TypedArray: CharSequence[] getTextArray(int)>,27,28,<android.content.res.TypedArray: CharSequence[] getTextArray(int)>,<android.content.res.TypedArray: CharSequence[] getTextArray(int)>,0,"{
    if (mRecycled) {
        throw new RuntimeException(""Cannot make calls to a recycled instance!"");
    }
    final TypedValue value = mValue;
    if (getValueAt(index * AssetManager.STYLE_NUM_ENTRIES, value)) {
        return mResources.getTextArray(value.resourceId);
    }
    return null;
}","{
    if (mRecycled) {
        throw new RuntimeException(""Cannot make calls to a recycled instance!"");
    }
    final TypedValue value = mValue;
    if (getValueAt(index * STYLE_NUM_ENTRIES, value)) {
        return mResources.getTextArray(value.resourceId);
    }
    return null;
}",1,"/**
 * Retrieve the CharSequence[] for the attribute at <var>index</var>.
 * This gets the resource ID of the selected attribute, and uses
 * {@link Resources#getTextArray Resources.getTextArray} of the owning
 * Resources object to retrieve its String[].
 * <p>
 * This method will throw an exception if the attribute is defined but is
 * not a text array resource.
 *
 * @param index Index of attribute to retrieve.
 *
 * @return CharSequence[] for the attribute, or {@code null} if not
 * defined.
 * @throws RuntimeException if the TypedArray has already been recycled.
 */
","/**
 * Retrieve the CharSequence[] for the attribute at <var>index</var>.
 * This gets the resource ID of the selected attribute, and uses
 * {@link Resources#getTextArray Resources.getTextArray} of the owning
 * Resources object to retrieve its String[].
 * <p>
 * This method will throw an exception if the attribute is defined but is
 * not a text array resource.
 *
 * @param index Index of attribute to retrieve.
 *
 * @return CharSequence[] for the attribute, or {@code null} if not
 * defined.
 * @throws RuntimeException if the TypedArray has already been recycled.
 */
",-1,,,-1,-1,-1,-1,-1,-1,0,0,"The implementation code hasn't changed between the two versions, except for the removal of the 'AssetManager' class qualification for 'STYLE_NUM_ENTRIES', which doesn't affect the behavior of the method. It is likely that 'STYLE_NUM_ENTRIES' was made a static import in the later version.","There is no compatibility issue because there is no change in the API's behavior, return values, exception handling, or any control flow that would affect how it operates."
970,<android.content.res.AssetManager.AssetInputStream: long skip(long)>,27,28,<android.content.res.AssetManager.AssetInputStream: long skip(long)>,<android.content.res.AssetManager.AssetInputStream: long skip(long)>,0,"{
    long pos = seekAsset(mAsset, 0, 0);
    if ((pos + n) > mLength) {
        n = mLength - pos;
    }
    if (n > 0) {
        seekAsset(mAsset, n, 0);
    }
    return n;
}","{
    ensureOpen();
    long pos = nativeAssetSeek(mAssetNativePtr, 0, 0);
    if ((pos + n) > mLength) {
        n = mLength - pos;
    }
    if (n > 0) {
        nativeAssetSeek(mAssetNativePtr, n, 0);
    }
    return n;
}",1,,,-1,,[@Override],-1,-1,-1,-1,-1,-1,"4,5",0,"The method seekAsset(mAsset, 0, 0) is replaced with nativeAssetSeek(mAssetNativePtr, 0, 0) and the parameter name has changed. Also, a new method call ensureOpen() is added at the start of the method. The code change type is 4,5.","There is no change in the behaviour of the API in terms of the return statement or the exception handling; the modifications are internal with an additional check for the stream being open, and the renaming of a variable which should not affect the API's output or exception throwing behaviour. Therefore, the CI type is 0."
971,<android.net.NetworkStats.Entry: String toString()>,27,28,<android.net.NetworkStats.Entry: String toString()>,<android.net.NetworkStats.Entry: String toString()>,0,"{
    final StringBuilder builder = new StringBuilder();
    builder.append(""iface="").append(iface);
    builder.append("" uid="").append(uid);
    builder.append("" set="").append(setToString(set));
    builder.append("" tag="").append(tagToString(tag));
    builder.append("" metered="").append(meteredToString(metered));
    builder.append("" roaming="").append(roamingToString(roaming));
    builder.append("" rxBytes="").append(rxBytes);
    builder.append("" rxPackets="").append(rxPackets);
    builder.append("" txBytes="").append(txBytes);
    builder.append("" txPackets="").append(txPackets);
    builder.append("" operations="").append(operations);
    return builder.toString();
}","{
    final StringBuilder builder = new StringBuilder();
    builder.append(""iface="").append(iface);
    builder.append("" uid="").append(uid);
    builder.append("" set="").append(setToString(set));
    builder.append("" tag="").append(tagToString(tag));
    builder.append("" metered="").append(meteredToString(metered));
    builder.append("" roaming="").append(roamingToString(roaming));
    builder.append("" defaultNetwork="").append(defaultNetworkToString(defaultNetwork));
    builder.append("" rxBytes="").append(rxBytes);
    builder.append("" rxPackets="").append(rxPackets);
    builder.append("" txBytes="").append(txBytes);
    builder.append("" txPackets="").append(txPackets);
    builder.append("" operations="").append(operations);
    return builder.toString();
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,1,"There's an additional append operation in the late version to include the 'defaultNetwork' information in the output string, which is an ""Other statement changed"". ","Since the 'toString' method will now include additional information ('defaultNetwork') in the returned string, consumers of this API could observe a different output resulting from the same inputs, which represents a Compatibility Issue caused by potential different return values. Therefore, the CI type is 1."
973,<android.os.StrictMode: ThreadPolicy allowThreadDiskReads()>,27,28,<android.os.StrictMode: ThreadPolicy allowThreadDiskReads()>,<android.os.StrictMode: ThreadPolicy allowThreadDiskReads()>,0,"{
    int oldPolicyMask = getThreadPolicyMask();
    int newPolicyMask = oldPolicyMask & ~(DETECT_DISK_READ);
    if (newPolicyMask != oldPolicyMask) {
        setThreadPolicyMask(newPolicyMask);
    }
    return new ThreadPolicy(oldPolicyMask);
}","{
    return new ThreadPolicy(allowThreadDiskReadsMask(), sThreadViolationListener.get(), sThreadViolationExecutor.get());
}",1,"/**
 * A convenience wrapper that takes the current
 * {@link ThreadPolicy} from {@link #getThreadPolicy}, modifies it
 * to permit disk reads, and sets the new policy
 * with {@link #setThreadPolicy}, returning the old policy so you
 * can restore it at the end of a block.
 *
 * @return the old policy, to be passed to setThreadPolicy to
 * restore the policy.
 */
","/**
 * A convenience wrapper that takes the current {@link ThreadPolicy} from {@link
 * #getThreadPolicy}, modifies it to permit disk reads, and sets the new policy with {@link
 * #setThreadPolicy}, returning the old policy so you can restore it at the end of a block.
 *
 * @return the old policy, to be passed to setThreadPolicy to restore the policy.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,4",1,"The method implementation has completely changed, with the earlier version altering the policy mask using a local operation, followed by creating a new ThreadPolicy. The late version creates a new ThreadPolicy using different parameters, including allowThreadDiskReadsMask(), and two getters for listener and executor. This change involves different method calls and constructs the return object differently, which qualifies as other statement changed (type 4), as well as a changed return statement (type 1).","The change in the implementation can lead to a different return value since the construction of the new ThreadPolicy object is now based on potentially different values, especially due to the introduction of allowThreadDiskReadsMask() and the use of sThreadViolationListener.get() and sThreadViolationExecutor.get(). Thus, a Compatibility Issue due to different return values or types could potentially arise, which is type 1."
974,"<android.service.autofill.Dataset.Builder: Builder setValue(AutofillId,AutofillValue,RemoteViews)>",27,28,"<android.service.autofill.Dataset.Builder: Builder setValue(AutofillId,AutofillValue,RemoteViews)>","<android.service.autofill.Dataset.Builder: Builder setValue(AutofillId,AutofillValue,RemoteViews)>",0,"{
    throwIfDestroyed();
    Preconditions.checkNotNull(presentation, ""presentation cannot be null"");
    setValueAndPresentation(id, value, presentation);
    return this;
}","{
    throwIfDestroyed();
    Preconditions.checkNotNull(presentation, ""presentation cannot be null"");
    setLifeTheUniverseAndEverything(id, value, presentation, null);
    return this;
}",1,"/**
 * Sets the value of a field, using a custom {@link RemoteViews presentation} to
 * visualize it.
 *
 * @param id id returned by {@link
 * android.app.assist.AssistStructure.ViewNode#getAutofillId()}.
 * @param value value to be auto filled. Pass {@code null} if you do not have the value
 * but the target view is a logical part of the dataset. For example, if
 * the dataset needs an authentication and you have no access to the value.
 * Filtering matches any user typed string to {@code null} values.
 * @param presentation The presentation used to visualize this field.
 * @return This builder.
 */
","/**
 * Sets the value of a field, using a custom {@link RemoteViews presentation} to
 * visualize it.
 *
 * <p><b>Note:</b> On Android {@link android.os.Build.VERSION_CODES#P} and
 * higher, datasets that require authentication can be also be filtered by passing a
 * {@link AutofillValue#forText(CharSequence) text value} as the  {@code value} parameter.
 *
 * <p>Theme does not work with RemoteViews layout. Avoid hardcoded text color
 * or background color: Autofill on different platforms may have different themes.
 *
 * @param id id returned by {@link
 * android.app.assist.AssistStructure.ViewNode#getAutofillId()}.
 * @param value the value to be autofilled. Pass {@code null} if you do not have the value
 * but the target view is a logical part of the dataset. For example, if
 * the dataset needs authentication and you have no access to the value.
 * @param presentation the presentation used to visualize this field.
 * @return this builder.
 */
",-1,[@NonNull],[@NonNull],-1,-1,-1,-1,-1,-1,5,0,"The method 'setValueAndPresentation()' in the early version is replaced with 'setLifeTheUniverseAndEverything()' in the late version, but with the last parameter as 'null', which indicates that the core functionality intended by this method call remains the same even though the method name and potentially its internal implementation might have changed. So the code change type is 5, as this is a change in a dependent API.","There does not appear to be a Compatibility Issue since the Builder is expected to return 'this' in both versions, and there's no indication that the type or value returned by the methods 'setValueAndPresentation' or 'setLifeTheUniverseAndEverything' affects the returned 'this' object of the Builder. Thus, the behaviour of the API remains the same in terms of its return value and exception handling, resulting in no Compatibility Issue."
975,<android.view.accessibility.AccessibilityEvent: AccessibilityEvent obtain()>,27,28,<android.view.accessibility.AccessibilityEvent: AccessibilityEvent obtain()>,<android.view.accessibility.AccessibilityEvent: AccessibilityEvent obtain()>,0,"{
    AccessibilityEvent event = sPool.acquire();
    return (event != null) ? event : new AccessibilityEvent();
}","{
    AccessibilityEvent event = sPool.acquire();
    if (event == null)
        event = new AccessibilityEvent();
    if (DEBUG_ORIGIN)
        event.originStackTrace = Thread.currentThread().getStackTrace();
    return event;
}",1,"/**
 * Returns a cached instance if such is available or a new one is
 * instantiated.
 *
 * @return An instance.
 */
","/**
 * Returns a cached instance if such is available or a new one is
 * instantiated.
 *
 * @return An instance.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,4",1,"There is a new if statement added that sets the originStackTrace of the event if DEBUG_ORIGIN is true, and the return construction has been changed from ternary to standard if-else statement. Thus, the code change types are 1 (since the return value is now potentially including additional information - the stack trace), and 4 for the change in statement structure.","The added if statement can potentially alter the returned AccessibilityEvent object by setting originStackTrace if DEBUG_ORIGIN is true. This additional mutation of the event object could result in different behavior of the API, making the CI type 1."
976,<android.content.res.AssetManager.AssetInputStream: int read(byte[])>,27,28,<android.content.res.AssetManager.AssetInputStream: int read(byte[])>,<android.content.res.AssetManager.AssetInputStream: int read(byte[])>,0,"{
    return readAsset(mAsset, b, 0, b.length);
}","{
    ensureOpen();
    Preconditions.checkNotNull(b, ""b"");
    return nativeAssetRead(mAssetNativePtr, b, 0, b.length);
}",1,,,-1,,[@Override],-1,-1,-1,-1,-1,-1,"1,4,5",1,"The method now includes additional calls to ensureOpen() and Preconditions.checkNotNull, and the method used to read asset has changed from readAsset() to nativeAssetRead(), with the parameter also changing from mAsset to mAssetNativePtr. Hence, this is classified as a change in the return statement (because of a different method being called), other statement (due to the addition of validation checks), and dependent API (because the native reading function has been altered).","There's a potential for a different return value due to the change in the method invoked (from readAsset to nativeAssetRead) and the additional validation checks introduced. Additionally, if ensureOpen() or Preconditions.checkNotNull(b, ""b"") throws an exception, the behavior of this API would also be different. Therefore, we can classify these as a potential for both different return values or types (1) and different exception handling (2). However, since Preconditions.checkNotNull(b, ""b"") doesn't influence the return value or type, only ensureOpen() and the change from readAsset to nativeAssetRead could cause different return values or types. The exception thrown from Preconditions.checkNotNull(b, ""b"") can be ignored since it does not constitute a change in the API's exception throwing behavior as per the information provided. Thus, the final classification for CI is only 1."
977,"<android.content.res.TypedArray: boolean getBoolean(int,boolean)>",27,28,"<android.content.res.TypedArray: boolean getBoolean(int,boolean)>","<android.content.res.TypedArray: boolean getBoolean(int,boolean)>",0,"{
    if (mRecycled) {
        throw new RuntimeException(""Cannot make calls to a recycled instance!"");
    }
    index *= AssetManager.STYLE_NUM_ENTRIES;
    final int[] data = mData;
    final int type = data[index + AssetManager.STYLE_TYPE];
    if (type == TypedValue.TYPE_NULL) {
        return defValue;
    } else if (type >= TypedValue.TYPE_FIRST_INT && type <= TypedValue.TYPE_LAST_INT) {
        return data[index + AssetManager.STYLE_DATA] != 0;
    }
    final TypedValue v = mValue;
    if (getValueAt(index, v)) {
        StrictMode.noteResourceMismatch(v);
        return XmlUtils.convertValueToBoolean(v.coerceToString(), defValue);
    }
    // We already checked for TYPE_NULL. This should never happen.
    throw new RuntimeException(""getBoolean of bad type: 0x"" + Integer.toHexString(type));
}","{
    if (mRecycled) {
        throw new RuntimeException(""Cannot make calls to a recycled instance!"");
    }
    index *= STYLE_NUM_ENTRIES;
    final int[] data = mData;
    final int type = data[index + STYLE_TYPE];
    if (type == TypedValue.TYPE_NULL) {
        return defValue;
    } else if (type >= TypedValue.TYPE_FIRST_INT && type <= TypedValue.TYPE_LAST_INT) {
        return data[index + STYLE_DATA] != 0;
    }
    final TypedValue v = mValue;
    if (getValueAt(index, v)) {
        StrictMode.noteResourceMismatch(v);
        return XmlUtils.convertValueToBoolean(v.coerceToString(), defValue);
    }
    // We already checked for TYPE_NULL. This should never happen.
    throw new RuntimeException(""getBoolean of bad type: 0x"" + Integer.toHexString(type));
}",1,"/**
 * Retrieve the boolean value for the attribute at <var>index</var>.
 * <p>
 * If the attribute is an integer value, this method will return whether
 * it is equal to zero. If the attribute is not a boolean or integer value,
 * this method will attempt to coerce it to an integer using
 * {@link Integer#decode(String)} and return whether it is equal to zero.
 *
 * @param index Index of attribute to retrieve.
 * @param defValue Value to return if the attribute is not defined or
 * cannot be coerced to an integer.
 *
 * @return Boolean value of the attribute, or defValue if the attribute was
 * not defined or could not be coerced to an integer.
 * @throws RuntimeException if the TypedArray has already been recycled.
 */
","/**
 * Retrieve the boolean value for the attribute at <var>index</var>.
 * <p>
 * If the attribute is an integer value, this method will return whether
 * it is equal to zero. If the attribute is not a boolean or integer value,
 * this method will attempt to coerce it to an integer using
 * {@link Integer#decode(String)} and return whether it is equal to zero.
 *
 * @param index Index of attribute to retrieve.
 * @param defValue Value to return if the attribute is not defined or
 * cannot be coerced to an integer.
 *
 * @return Boolean value of the attribute, or defValue if the attribute was
 * not defined or could not be coerced to an integer.
 * @throws RuntimeException if the TypedArray has already been recycled.
 */
",-1,,,-1,-1,-1,-1,-1,-1,0,0,"The implementations between the early version and late version are effectively identical, with the only difference being the removal of the AssetManager qualifier from STYLE_NUM_ENTRIES and STYLE_TYPE.",There is no Compatibility Issue because this change in reference does not alter the behavior or output of the method. The method's functionality is preserved as before.
978,<android.view.accessibility.AccessibilityEvent: String toString()>,27,28,<android.view.accessibility.AccessibilityEvent: String toString()>,<android.view.accessibility.AccessibilityEvent: String toString()>,0,"{
    StringBuilder builder = new StringBuilder();
    builder.append(""EventType: "").append(eventTypeToString(mEventType));
    builder.append(""; EventTime: "").append(mEventTime);
    builder.append(""; PackageName: "").append(mPackageName);
    builder.append(""; MovementGranularity: "").append(mMovementGranularity);
    builder.append(""; Action: "").append(mAction);
    builder.append(super.toString());
    if (DEBUG) {
        builder.append(""\n"");
        builder.append(""; ContentChangeTypes: "").append(contentChangeTypesToString(mContentChangeTypes));
        builder.append(""; sourceWindowId: "").append(mSourceWindowId);
        builder.append(""; mSourceNodeId: "").append(mSourceNodeId);
        for (int i = 0; i < getRecordCount(); i++) {
            final AccessibilityRecord record = getRecord(i);
            builder.append(""  Record "");
            builder.append(i);
            builder.append("":"");
            builder.append("" [ ClassName: "" + record.mClassName);
            builder.append(""; Text: "" + record.mText);
            builder.append(""; ContentDescription: "" + record.mContentDescription);
            builder.append(""; ItemCount: "" + record.mItemCount);
            builder.append(""; CurrentItemIndex: "" + record.mCurrentItemIndex);
            builder.append(""; IsEnabled: "" + record.isEnabled());
            builder.append(""; IsPassword: "" + record.isPassword());
            builder.append(""; IsChecked: "" + record.isChecked());
            builder.append(""; IsFullScreen: "" + record.isFullScreen());
            builder.append(""; Scrollable: "" + record.isScrollable());
            builder.append(""; BeforeText: "" + record.mBeforeText);
            builder.append(""; FromIndex: "" + record.mFromIndex);
            builder.append(""; ToIndex: "" + record.mToIndex);
            builder.append(""; ScrollX: "" + record.mScrollX);
            builder.append(""; ScrollY: "" + record.mScrollY);
            builder.append(""; AddedCount: "" + record.mAddedCount);
            builder.append(""; RemovedCount: "" + record.mRemovedCount);
            builder.append(""; ParcelableData: "" + record.mParcelableData);
            builder.append("" ]"");
            builder.append(""\n"");
        }
    } else {
        builder.append(""; recordCount: "").append(getRecordCount());
    }
    return builder.toString();
}","{
    StringBuilder builder = new StringBuilder();
    builder.append(""EventType: "").append(eventTypeToString(mEventType));
    builder.append(""; EventTime: "").append(mEventTime);
    builder.append(""; PackageName: "").append(mPackageName);
    if (!DEBUG_CONCISE_TOSTRING || mMovementGranularity != 0) {
        builder.append(""; MovementGranularity: "").append(mMovementGranularity);
    }
    if (!DEBUG_CONCISE_TOSTRING || mAction != 0) {
        builder.append(""; Action: "").append(mAction);
    }
    if (!DEBUG_CONCISE_TOSTRING || mContentChangeTypes != 0) {
        builder.append(""; ContentChangeTypes: "").append(contentChangeTypesToString(mContentChangeTypes));
    }
    if (!DEBUG_CONCISE_TOSTRING || mWindowChangeTypes != 0) {
        builder.append(""; WindowChangeTypes: "").append(windowChangeTypesToString(mWindowChangeTypes));
    }
    super.appendTo(builder);
    if (DEBUG || DEBUG_CONCISE_TOSTRING) {
        if (!DEBUG_CONCISE_TOSTRING) {
            builder.append(""\n"");
        }
        if (DEBUG) {
            builder.append(""; SourceWindowId: "").append(mSourceWindowId);
            builder.append(""; SourceNodeId: "").append(mSourceNodeId);
        }
        for (int i = 0; i < getRecordCount(); i++) {
            builder.append(""  Record "").append(i).append("":"");
            getRecord(i).appendTo(builder).append(""\n"");
        }
    } else {
        builder.append(""; recordCount: "").append(getRecordCount());
    }
    return builder.toString();
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,4",0,"There are changes in control statement conditions (with the addition of `!DEBUG_CONCISE_TOSTRING` checks before appending some strings) and other statements as well (such as the change from `super.toString()` to `super.appendTo(builder)` and the addition of window change types information), so the code change type is 3,4.","There is no Compatibility Issue as the behavior of the method remains to return a String representing the state of the object, just with potentially additional or less information based on new conditions, without affecting the compatibility of existing clients' expectations from the method's contract."
979,"<android.accounts.AccountManager: AccountManagerFuture<Bundle> confirmCredentials(Account,Bundle,Activity,AccountManagerCallback<Bundle>,Handler)>",27,28,"<android.accounts.AccountManager: AccountManagerFuture<Bundle> confirmCredentials(Account,Bundle,Activity,AccountManagerCallback<Bundle>,Handler)>","<android.accounts.AccountManager: AccountManagerFuture<Bundle> confirmCredentials(Account,Bundle,Activity,AccountManagerCallback<Bundle>,Handler)>",0,"{
    return confirmCredentialsAsUser(account, options, activity, callback, handler, Process.myUserHandle());
}","{
    return confirmCredentialsAsUser(account, options, activity, callback, handler, mContext.getUser());
}",1,"/**
 * Confirms that the user knows the password for an account to make extra
 * sure they are the owner of the account.  The user-entered password can
 * be supplied directly, otherwise the authenticator for this account type
 * prompts the user with the appropriate interface.  This method is
 * intended for applications which want extra assurance; for example, the
 * phone lock screen uses this to let the user unlock the phone with an
 * account password if they forget the lock pattern.
 *
 * <p>If the user-entered password matches a saved password for this
 * account, the request is considered valid; otherwise the authenticator
 * verifies the password (usually by contacting the server).
 *
 * <p>This method may be called from any thread, but the returned
 * {@link AccountManagerFuture} must not be used on the main thread.
 *
 * <p><b>NOTE:</b> If targeting your app to work on API level 22 and before,
 * MANAGE_ACCOUNTS permission is needed for those platforms. See docs
 * for this function in API level 22.
 *
 * @param account The account to confirm password knowledge for
 * @param options Authenticator-specific options for the request;
 * if the {@link #KEY_PASSWORD} string field is present, the
 * authenticator may use it directly rather than prompting the user;
 * may be null or empty
 * @param activity The {@link Activity} context to use for launching a new
 * authenticator-defined sub-Activity to prompt the user to enter a
 * password; used only to call startActivity(); if null, the prompt
 * will not be launched directly, but the necessary {@link Intent}
 * will be returned to the caller instead
 * @param callback Callback to invoke when the request completes,
 * null for no callback
 * @param handler {@link Handler} identifying the callback thread,
 * null for the main thread
 * @return An {@link AccountManagerFuture} which resolves to a Bundle
 * with these fields if activity or password was supplied and
 * the account was successfully verified:
 * <ul>
 * <li> {@link #KEY_ACCOUNT_NAME} - the name of the account verified
 * <li> {@link #KEY_ACCOUNT_TYPE} - the type of the account
 * <li> {@link #KEY_BOOLEAN_RESULT} - true to indicate success
 * </ul>
 *
 * If no activity or password was specified, the returned Bundle contains
 * {@link #KEY_INTENT} with the {@link Intent} needed to launch the
 * password prompt.
 *
 * <p>Also the returning Bundle may contain {@link
 * #KEY_LAST_AUTHENTICATED_TIME} indicating the last time the
 * credential was validated/created.
 *
 * If an error occurred,{@link AccountManagerFuture#getResult()} throws:
 * <ul>
 * <li> {@link AuthenticatorException} if the authenticator failed to respond
 * <li> {@link OperationCanceledException} if the operation was canceled for
 * any reason, including the user canceling the password prompt
 * <li> {@link IOException} if the authenticator experienced an I/O problem
 * verifying the password, usually because of network trouble
 * </ul>
 */
","/**
 * Confirms that the user knows the password for an account to make extra
 * sure they are the owner of the account.  The user-entered password can
 * be supplied directly, otherwise the authenticator for this account type
 * prompts the user with the appropriate interface.  This method is
 * intended for applications which want extra assurance; for example, the
 * phone lock screen uses this to let the user unlock the phone with an
 * account password if they forget the lock pattern.
 *
 * <p>If the user-entered password matches a saved password for this
 * account, the request is considered valid; otherwise the authenticator
 * verifies the password (usually by contacting the server).
 *
 * <p>This method may be called from any thread, but the returned
 * {@link AccountManagerFuture} must not be used on the main thread.
 *
 * <p><b>NOTE:</b> If targeting your app to work on API level 22 and before,
 * MANAGE_ACCOUNTS permission is needed for those platforms. See docs
 * for this function in API level 22.
 *
 * @param account The account to confirm password knowledge for
 * @param options Authenticator-specific options for the request;
 * if the {@link #KEY_PASSWORD} string field is present, the
 * authenticator may use it directly rather than prompting the user;
 * may be null or empty
 * @param activity The {@link Activity} context to use for launching a new
 * authenticator-defined sub-Activity to prompt the user to enter a
 * password; used only to call startActivity(); if null, the prompt
 * will not be launched directly, but the necessary {@link Intent}
 * will be returned to the caller instead
 * @param callback Callback to invoke when the request completes,
 * null for no callback
 * @param handler {@link Handler} identifying the callback thread,
 * null for the main thread
 * @return An {@link AccountManagerFuture} which resolves to a Bundle
 * with these fields if activity or password was supplied and
 * the account was successfully verified:
 * <ul>
 * <li> {@link #KEY_ACCOUNT_NAME} - the name of the account verified
 * <li> {@link #KEY_ACCOUNT_TYPE} - the type of the account
 * <li> {@link #KEY_BOOLEAN_RESULT} - true to indicate success
 * </ul>
 *
 * If no activity or password was specified, the returned Bundle contains
 * {@link #KEY_INTENT} with the {@link Intent} needed to launch the
 * password prompt.
 *
 * <p>Also the returning Bundle may contain {@link
 * #KEY_LAST_AUTHENTICATED_TIME} indicating the last time the
 * credential was validated/created.
 *
 * If an error occurred,{@link AccountManagerFuture#getResult()} throws:
 * <ul>
 * <li> {@link AuthenticatorException} if the authenticator failed to respond
 * <li> {@link OperationCanceledException} if the operation was canceled for
 * any reason, including the user canceling the password prompt
 * <li> {@link IOException} if the authenticator experienced an I/O problem
 * verifying the password, usually because of network trouble
 * </ul>
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The only change is the parameter passed to the confirmCredentialsAsUser method, switching from Process.myUserHandle() to mContext.getUser(). Since this is a call to a different method to obtain a user handle, it is classified as a change in a dependent API, which is type 5.","This change does not lead to any compatibility issues as it only alters the way in which the user handle is retrieved. The behavior of the confirmCredentials method itself and its return type have not changed, implying that the change would not lead to a different behavior in terms of how callers interact with the method or handle its results, thus the CI type is 0."
980,<android.widget.RemoteViewsAdapter.FixedSizeRemoteViewsCache: boolean queuePositionsToBePreloadedFromRequestedPosition(int)>,27,28,<android.widget.RemoteViewsAdapter.FixedSizeRemoteViewsCache: boolean queuePositionsToBePreloadedFromRequestedPosition(int)>,<android.widget.RemoteViewsAdapter.FixedSizeRemoteViewsCache: boolean queuePositionsToBePreloadedFromRequestedPosition(int)>,0,"{
    // Check if we need to preload any items
    if (mPreloadLowerBound <= position && position <= mPreloadUpperBound) {
        int center = (mPreloadUpperBound + mPreloadLowerBound) / 2;
        if (Math.abs(position - center) < mMaxCountSlack) {
            return false;
        }
    }
    int count = 0;
    synchronized (mMetaData) {
        count = mMetaData.count;
    }
    synchronized (mIndicesToLoad) {
        // Remove all indices which have not been previously requested.
        for (int i = mIndicesToLoad.size() - 1; i >= 0; i--) {
            if (!mIndicesToLoad.valueAt(i)) {
                mIndicesToLoad.removeAt(i);
            }
        }
        // Add all the preload indices
        int halfMaxCount = mMaxCount / 2;
        mPreloadLowerBound = position - halfMaxCount;
        mPreloadUpperBound = position + halfMaxCount;
        int effectiveLowerBound = Math.max(0, mPreloadLowerBound);
        int effectiveUpperBound = Math.min(mPreloadUpperBound, count - 1);
        for (int i = effectiveLowerBound; i <= effectiveUpperBound; ++i) {
            if (mIndexRemoteViews.indexOfKey(i) < 0 && !mIndicesToLoad.get(i)) {
                // If the index has not been requested, and has not been loaded.
                mIndicesToLoad.put(i, false);
            }
        }
    }
    return true;
}","{
    // Check if we need to preload any items
    if (mPreloadLowerBound <= position && position <= mPreloadUpperBound) {
        int center = (mPreloadUpperBound + mPreloadLowerBound) / 2;
        if (Math.abs(position - center) < mMaxCountSlack) {
            return false;
        }
    }
    int count;
    synchronized (mMetaData) {
        count = mMetaData.count;
    }
    synchronized (mIndicesToLoad) {
        // Remove all indices which have not been previously requested.
        for (int i = mIndicesToLoad.size() - 1; i >= 0; i--) {
            if (!mIndicesToLoad.valueAt(i)) {
                mIndicesToLoad.removeAt(i);
            }
        }
        // Add all the preload indices
        int halfMaxCount = mMaxCount / 2;
        mPreloadLowerBound = position - halfMaxCount;
        mPreloadUpperBound = position + halfMaxCount;
        int effectiveLowerBound = Math.max(0, mPreloadLowerBound);
        int effectiveUpperBound = Math.min(mPreloadUpperBound, count - 1);
        for (int i = effectiveLowerBound; i <= effectiveUpperBound; ++i) {
            if (mIndexRemoteViews.indexOfKey(i) < 0 && !mIndicesToLoad.get(i)) {
                // If the index has not been requested, and has not been loaded.
                mIndicesToLoad.put(i, false);
            }
        }
    }
    return true;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,0,0,"The only change between the two versions is the way variable `count` is declared. In the early version, it is initialized to 0 at declaration, while in the late version, it is declared without an initial value and set inside a synchronized block. However, this change doesn't affect the behavior of the method because the assignment of `count` occurs before it is used, in both versions, within the same synchronized block.","There is no Compatibility Issue here, as the behavior of the method does not change; it still performs the same checks and operations, and returns the same result."
981,<android.app.ActivityOptions: void update(ActivityOptions)>,27,28,<android.app.ActivityOptions: void update(ActivityOptions)>,<android.app.ActivityOptions: void update(ActivityOptions)>,0,"{
    if (otherOptions.mPackageName != null) {
        mPackageName = otherOptions.mPackageName;
    }
    mUsageTimeReport = otherOptions.mUsageTimeReport;
    mTransitionReceiver = null;
    mSharedElementNames = null;
    mIsReturning = false;
    mResultData = null;
    mResultCode = 0;
    mExitCoordinatorIndex = 0;
    mAnimationType = otherOptions.mAnimationType;
    switch(otherOptions.mAnimationType) {
        case ANIM_CUSTOM:
            mCustomEnterResId = otherOptions.mCustomEnterResId;
            mCustomExitResId = otherOptions.mCustomExitResId;
            mThumbnail = null;
            if (mAnimationStartedListener != null) {
                try {
                    mAnimationStartedListener.sendResult(null);
                } catch (RemoteException e) {
                }
            }
            mAnimationStartedListener = otherOptions.mAnimationStartedListener;
            break;
        case ANIM_CUSTOM_IN_PLACE:
            mCustomInPlaceResId = otherOptions.mCustomInPlaceResId;
            break;
        case ANIM_SCALE_UP:
            mStartX = otherOptions.mStartX;
            mStartY = otherOptions.mStartY;
            mWidth = otherOptions.mWidth;
            mHeight = otherOptions.mHeight;
            if (mAnimationStartedListener != null) {
                try {
                    mAnimationStartedListener.sendResult(null);
                } catch (RemoteException e) {
                }
            }
            mAnimationStartedListener = null;
            break;
        case ANIM_THUMBNAIL_SCALE_UP:
        case ANIM_THUMBNAIL_SCALE_DOWN:
        case ANIM_THUMBNAIL_ASPECT_SCALE_UP:
        case ANIM_THUMBNAIL_ASPECT_SCALE_DOWN:
            mThumbnail = otherOptions.mThumbnail;
            mStartX = otherOptions.mStartX;
            mStartY = otherOptions.mStartY;
            mWidth = otherOptions.mWidth;
            mHeight = otherOptions.mHeight;
            if (mAnimationStartedListener != null) {
                try {
                    mAnimationStartedListener.sendResult(null);
                } catch (RemoteException e) {
                }
            }
            mAnimationStartedListener = otherOptions.mAnimationStartedListener;
            break;
        case ANIM_SCENE_TRANSITION:
            mTransitionReceiver = otherOptions.mTransitionReceiver;
            mSharedElementNames = otherOptions.mSharedElementNames;
            mIsReturning = otherOptions.mIsReturning;
            mThumbnail = null;
            mAnimationStartedListener = null;
            mResultData = otherOptions.mResultData;
            mResultCode = otherOptions.mResultCode;
            mExitCoordinatorIndex = otherOptions.mExitCoordinatorIndex;
            break;
    }
    mAnimSpecs = otherOptions.mAnimSpecs;
    mAnimationFinishedListener = otherOptions.mAnimationFinishedListener;
    mSpecsFuture = otherOptions.mSpecsFuture;
}","{
    if (otherOptions.mPackageName != null) {
        mPackageName = otherOptions.mPackageName;
    }
    mUsageTimeReport = otherOptions.mUsageTimeReport;
    mTransitionReceiver = null;
    mSharedElementNames = null;
    mIsReturning = false;
    mResultData = null;
    mResultCode = 0;
    mExitCoordinatorIndex = 0;
    mAnimationType = otherOptions.mAnimationType;
    switch(otherOptions.mAnimationType) {
        case ANIM_CUSTOM:
            mCustomEnterResId = otherOptions.mCustomEnterResId;
            mCustomExitResId = otherOptions.mCustomExitResId;
            mThumbnail = null;
            if (mAnimationStartedListener != null) {
                try {
                    mAnimationStartedListener.sendResult(null);
                } catch (RemoteException e) {
                }
            }
            mAnimationStartedListener = otherOptions.mAnimationStartedListener;
            break;
        case ANIM_CUSTOM_IN_PLACE:
            mCustomInPlaceResId = otherOptions.mCustomInPlaceResId;
            break;
        case ANIM_SCALE_UP:
            mStartX = otherOptions.mStartX;
            mStartY = otherOptions.mStartY;
            mWidth = otherOptions.mWidth;
            mHeight = otherOptions.mHeight;
            if (mAnimationStartedListener != null) {
                try {
                    mAnimationStartedListener.sendResult(null);
                } catch (RemoteException e) {
                }
            }
            mAnimationStartedListener = null;
            break;
        case ANIM_THUMBNAIL_SCALE_UP:
        case ANIM_THUMBNAIL_SCALE_DOWN:
        case ANIM_THUMBNAIL_ASPECT_SCALE_UP:
        case ANIM_THUMBNAIL_ASPECT_SCALE_DOWN:
            mThumbnail = otherOptions.mThumbnail;
            mStartX = otherOptions.mStartX;
            mStartY = otherOptions.mStartY;
            mWidth = otherOptions.mWidth;
            mHeight = otherOptions.mHeight;
            if (mAnimationStartedListener != null) {
                try {
                    mAnimationStartedListener.sendResult(null);
                } catch (RemoteException e) {
                }
            }
            mAnimationStartedListener = otherOptions.mAnimationStartedListener;
            break;
        case ANIM_SCENE_TRANSITION:
            mTransitionReceiver = otherOptions.mTransitionReceiver;
            mSharedElementNames = otherOptions.mSharedElementNames;
            mIsReturning = otherOptions.mIsReturning;
            mThumbnail = null;
            mAnimationStartedListener = null;
            mResultData = otherOptions.mResultData;
            mResultCode = otherOptions.mResultCode;
            mExitCoordinatorIndex = otherOptions.mExitCoordinatorIndex;
            break;
    }
    mLockTaskMode = otherOptions.mLockTaskMode;
    mAnimSpecs = otherOptions.mAnimSpecs;
    mAnimationFinishedListener = otherOptions.mAnimationFinishedListener;
    mSpecsFuture = otherOptions.mSpecsFuture;
    mRemoteAnimationAdapter = otherOptions.mRemoteAnimationAdapter;
}",1,"/**
 * Update the current values in this ActivityOptions from those supplied
 * in <var>otherOptions</var>.  Any values
 * defined in <var>otherOptions</var> replace those in the base options.
 */
","/**
 * Update the current values in this ActivityOptions from those supplied
 * in <var>otherOptions</var>.  Any values
 * defined in <var>otherOptions</var> replace those in the base options.
 */
",-1,,,-1,-1,-1,-1,-1,-1,,,,
982,"<android.provider.Settings.Secure: int getInt(ContentResolver,String,int)>",27,28,"<android.provider.Settings.Secure: int getInt(ContentResolver,String,int)>","<android.provider.Settings.Secure: int getInt(ContentResolver,String,int)>",0,"{
    return getIntForUser(cr, name, def, UserHandle.myUserId());
}","{
    return getIntForUser(cr, name, def, cr.getUserId());
}",1,"/**
 * Convenience function for retrieving a single secure settings value
 * as an integer.  Note that internally setting values are always
 * stored as strings; this function converts the string to an integer
 * for you.  The default value will be returned if the setting is
 * not defined or not an integer.
 *
 * @param cr The ContentResolver to access.
 * @param name The name of the setting to retrieve.
 * @param def Value to return if the setting is not defined.
 *
 * @return The setting's current value, or 'def' if it is not defined
 * or not a valid integer.
 */
","/**
 * Convenience function for retrieving a single secure settings value
 * as an integer.  Note that internally setting values are always
 * stored as strings; this function converts the string to an integer
 * for you.  The default value will be returned if the setting is
 * not defined or not an integer.
 *
 * @param cr The ContentResolver to access.
 * @param name The name of the setting to retrieve.
 * @param def Value to return if the setting is not defined.
 *
 * @return The setting's current value, or 'def' if it is not defined
 * or not a valid integer.
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The change stems from the difference in how the user ID is retrieved: from UserHandle.myUserId() in the early version to cr.getUserId() in the late version. As such, the change type is 5.","There's no direct compatibility issue as long as cr.getUserId() and UserHandle.myUserId() return the same value for the current context. The change is internal and should not affect the returned value of the API from the caller's perspective, as long as the context in which the API is used remains the same between the two versions. Thus, CI type is 0."
983,<android.net.Network: InetAddress getByName(String)>,27,28,<android.net.Network: InetAddress getByName(String)>,<android.net.Network: InetAddress getByName(String)>,0,"{
    return InetAddress.getByNameOnNet(host, netId);
}","{
    return InetAddress.getByNameOnNet(host, getNetIdForResolv());
}",1,"/**
 * Operates the same as {@code InetAddress.getByName} except that host
 * resolution is done on this network.
 *
 * @param host
 * the hostName to be resolved to an address or {@code null}.
 * @return the {@code InetAddress} instance representing the host.
 * @throws UnknownHostException
 * if the address lookup fails.
 */
","/**
 * Operates the same as {@code InetAddress.getByName} except that host
 * resolution is done on this network.
 *
 * @param host
 * the hostName to be resolved to an address or {@code null}.
 * @return the {@code InetAddress} instance representing the host.
 * @throws UnknownHostException
 * if the address lookup fails.
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,1,"The implementation of the method has changed from calling InetAddress.getByNameOnNet(host, netId) to calling InetAddress.getByNameOnNet(host, getNetIdForResolv()), which means a dependent API getNetIdForResolv() is now being used instead of the variable netId. Therefore, the code change type is 5.","Since the dependent API used to retrieve the network ID for resolution has changed, there could be a different value returned by the new method getNetIdForResolv(), and as a result, the final result of the InetAddress.getByNameOnNet method could be different. This potential change in return value constitutes a CI, with the type being 1."
984,<android.widget.TextView: TextClassifier getTextClassifier()>,27,28,<android.widget.TextView: TextClassifier getTextClassifier()>,<android.widget.TextView: TextClassifier getTextClassifier()>,0,"{
    if (mTextClassifier == null) {
        TextClassificationManager tcm = mContext.getSystemService(TextClassificationManager.class);
        if (tcm != null) {
            mTextClassifier = tcm.getTextClassifier();
        } else {
            mTextClassifier = TextClassifier.NO_OP;
        }
    }
    return mTextClassifier;
}","{
    if (mTextClassifier == null) {
        final TextClassificationManager tcm = mContext.getSystemService(TextClassificationManager.class);
        if (tcm != null) {
            return tcm.getTextClassifier();
        }
        return TextClassifier.NO_OP;
    }
    return mTextClassifier;
}",1,"/**
 * Returns the {@link TextClassifier} used by this TextView.
 * If no TextClassifier has been set, this TextView uses the default set by the
 * {@link TextClassificationManager}.
 */
","/**
 * Returns the {@link TextClassifier} used by this TextView.
 * If no TextClassifier has been set, this TextView uses the default set by the
 * {@link TextClassificationManager}.
 */
",-1,[@NonNull],[@NonNull],-1,-1,-1,-1,-1,-1,"1,3",0,"There is a control dependency change; in the early version, `mTextClassifier` is assigned a value within the if-else block, whereas, in the late version, it directly returns within the if block. There's also a change in return typethe early version updates `mTextClassifier` before returning it, while the late version potentially returns different values without updating `mTextClassifier`. However, the overall method contract and return type remain unchanged as both versions ultimately return a `TextClassifier` object, so the code change type is 1,3.","Despite the change in the control flow and the immediate return of the value within the if block in the late version, there is no Compatibility Issue. This is because the method's contract, which guarantees to return a non-null `TextClassifier` object, is maintained. In either version, the method will return either the existing `mTextClassifier` or a new one from the `TextClassificationManager`, or `TextClassifier.NO_OP` if `tcm` is null. The behavior from the caller's perspective remains consistent, fulfilling the non-null contract as annotated, so the CI type is 0."
986,"<android.accounts.AbstractAccountAuthenticator.Transport: void addAccount(IAccountAuthenticatorResponse,String,String,String[],Bundle)>",27,28,"<android.accounts.AbstractAccountAuthenticator.Transport: void addAccount(IAccountAuthenticatorResponse,String,String,String[],Bundle)>","<android.accounts.AbstractAccountAuthenticator.Transport: void addAccount(IAccountAuthenticatorResponse,String,String,String[],Bundle)>",0,"{
    if (Log.isLoggable(TAG, Log.VERBOSE)) {
        Log.v(TAG, ""addAccount: accountType "" + accountType + "", authTokenType "" + authTokenType + "", features "" + (features == null ? ""[]"" : Arrays.toString(features)));
    }
    checkBinderPermission();
    try {
        final Bundle result = AbstractAccountAuthenticator.this.addAccount(new AccountAuthenticatorResponse(response), accountType, authTokenType, features, options);
        if (Log.isLoggable(TAG, Log.VERBOSE)) {
            if (result != null) {
                // force it to be unparcelled
                result.keySet();
            }
            Log.v(TAG, ""addAccount: result "" + AccountManager.sanitizeResult(result));
        }
        if (result != null) {
            response.onResult(result);
        }
    } catch (Exception e) {
        handleException(response, ""addAccount"", accountType, e);
    }
}","{
    if (Log.isLoggable(TAG, Log.VERBOSE)) {
        Log.v(TAG, ""addAccount: accountType "" + accountType + "", authTokenType "" + authTokenType + "", features "" + (features == null ? ""[]"" : Arrays.toString(features)));
    }
    checkBinderPermission();
    try {
        final Bundle result = AbstractAccountAuthenticator.this.addAccount(new AccountAuthenticatorResponse(response), accountType, authTokenType, features, options);
        if (Log.isLoggable(TAG, Log.VERBOSE)) {
            if (result != null) {
                // force it to be unparcelled
                result.keySet();
            }
            Log.v(TAG, ""addAccount: result "" + AccountManager.sanitizeResult(result));
        }
        if (result != null) {
            response.onResult(result);
        } else {
            response.onError(AccountManager.ERROR_CODE_INVALID_RESPONSE, ""null bundle returned"");
        }
    } catch (Exception e) {
        handleException(response, ""addAccount"", accountType, e);
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,3",1,"An 'else' block has been added in the control dependency which includes a new call to response.onError(...) if 'result' is null, so the code change type is 1,3.","This addition of the 'else' block can cause a different behavior as it introduces a new error response that was not present in the early version. Therefore, the API can potentially return a different result when 'result' is null, and the CI type is 1."
989,<android.os.WorkSource: boolean remove(WorkSource)>,27,28,<android.os.WorkSource: boolean remove(WorkSource)>,<android.os.WorkSource: boolean remove(WorkSource)>,0,"{
    if (mNum <= 0 || other.mNum <= 0) {
        return false;
    }
    if (mNames == null && other.mNames == null) {
        return removeUids(other);
    } else {
        if (mNames == null) {
            throw new IllegalArgumentException(""Other "" + other + "" has names, but target "" + this + "" does not"");
        }
        if (other.mNames == null) {
            throw new IllegalArgumentException(""Target "" + this + "" has names, but other "" + other + "" does not"");
        }
        return removeUidsAndNames(other);
    }
}","{
    if (isEmpty() || other.isEmpty()) {
        return false;
    }
    boolean uidRemoved;
    if (mNames == null && other.mNames == null) {
        uidRemoved = removeUids(other);
    } else {
        if (mNames == null) {
            throw new IllegalArgumentException(""Other "" + other + "" has names, but target "" + this + "" does not"");
        }
        if (other.mNames == null) {
            throw new IllegalArgumentException(""Target "" + this + "" has names, but other "" + other + "" does not"");
        }
        uidRemoved = removeUidsAndNames(other);
    }
    boolean chainRemoved = false;
    if (other.mChains != null && mChains != null) {
        chainRemoved = mChains.removeAll(other.mChains);
    }
    return uidRemoved || chainRemoved;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"3,4",1,"The check for non-empty WorkSource has been changed to call the isEmpty() method instead of directly checking the mNum property. A new local variable uidRemoved is introduced to store the result of removeUids() or removeUidsAndNames(), and a new variable chainRemoved along with additional logic to handle removing chains that exist in the WorkSource. Lastly, there's a change in the return statement to return the logical OR of uidRemoved and chainRemoved. This change can be classified as a control dependency change (due to the introduction of the new if clause for chains) and other statement changed (due to introduction of new local variables and changes in the logic).","The modifications in the logic could lead the API to return different values due to the additional checks on the chains and the use of logical OR in the return statement. The implementation now considers the removal of chains along with the UIDs and names, which wasn't considered previously. This is a potential compatibility issue caused by different return values or types because clients relying on the previous implementation would not expect the state of chains in a WorkSource object to affect the output of the remove() method."
990,<android.database.sqlite.SQLiteDatabase.OpenParams.Builder: OpenParams build()>,27,28,<android.database.sqlite.SQLiteDatabase.OpenParams.Builder: OpenParams build()>,<android.database.sqlite.SQLiteDatabase.OpenParams.Builder: OpenParams build()>,0,"{
    return new OpenParams(mOpenFlags, mCursorFactory, mErrorHandler, mLookasideSlotSize, mLookasideSlotCount, mIdleConnectionTimeout);
}","{
    return new OpenParams(mOpenFlags, mCursorFactory, mErrorHandler, mLookasideSlotSize, mLookasideSlotCount, mIdleConnectionTimeout, mJournalMode, mSyncMode);
}",1,"/**
 * Creates an instance of {@link OpenParams} with the options that were previously set
 * on this builder
 */
","/**
 * Creates an instance of {@link OpenParams} with the options that were previously set
 * on this builder
 */
",-1,[@NonNull],[@NonNull],-1,-1,-1,-1,-1,-1,"1,5",1,"The return statement has been modified by including two additional parameters, mJournalMode and mSyncMode, in the constructor of OpenParams, so the code change type is 1,5.","The change in the return statement could lead to the API returning an object with potentially different behavior, because the instance is now constructed with additional configuration parameters. Therefore, the CI type is 1."
