Number,Signature,Early_Version,Late_Version,Early_Signature,Late_Signature,Diff_Signature,Early_Implementation,Late_Implementation,Diff_Implementation,Early_Comment,Late_Comment,Diff_Comment,Early_Annotation,Late_Annotation,Diff_Annotation,Early_Callback,Late_Callback,Diff_Callback,GT_CI_ControlFlow,GT_CI_Type,pred_change,pred_CI,change_description,CI_description
0,"<android.gesture.GestureStroke: Path toPath(float,float,int)>",7,8,"<android.gesture.GestureStroke: Path toPath(float,float,int)>","<android.gesture.GestureStroke: Path toPath(float,float,int)>",0,"{
    final float[] pts = GestureUtilities.temporalSampling(this, numSample);
    final RectF rect = boundingBox;
    GestureUtilities.translate(pts, -rect.left, -rect.top);
    float sx = width / rect.width();
    float sy = height / rect.height();
    float scale = sx > sy ? sy : sx;
    GestureUtilities.scale(pts, scale, scale);
    float mX = 0;
    float mY = 0;
    Path path = null;
    final int count = pts.length;
    for (int i = 0; i < count; i += 2) {
        float x = pts[i];
        float y = pts[i + 1];
        if (path == null) {
            path = new Path();
            path.moveTo(x, y);
            mX = x;
            mY = y;
        } else {
            float dx = Math.abs(x - mX);
            float dy = Math.abs(y - mY);
            if (dx >= TOUCH_TOLERANCE || dy >= TOUCH_TOLERANCE) {
                path.quadTo(mX, mY, (x + mX) / 2, (y + mY) / 2);
                mX = x;
                mY = y;
            }
        }
    }
    return path;
}","{
    final float[] pts = GestureUtils.temporalSampling(this, numSample);
    final RectF rect = boundingBox;
    GestureUtils.translate(pts, -rect.left, -rect.top);
    float sx = width / rect.width();
    float sy = height / rect.height();
    float scale = sx > sy ? sy : sx;
    GestureUtils.scale(pts, scale, scale);
    float mX = 0;
    float mY = 0;
    Path path = null;
    final int count = pts.length;
    for (int i = 0; i < count; i += 2) {
        float x = pts[i];
        float y = pts[i + 1];
        if (path == null) {
            path = new Path();
            path.moveTo(x, y);
            mX = x;
            mY = y;
        } else {
            float dx = Math.abs(x - mX);
            float dy = Math.abs(y - mY);
            if (dx >= TOUCH_TOLERANCE || dy >= TOUCH_TOLERANCE) {
                path.quadTo(mX, mY, (x + mX) / 2, (y + mY) / 2);
                mX = x;
                mY = y;
            }
        }
    }
    return path;
}",1,"/**
 * Convert the stroke to a Path based on the number of points
 *
 * @param width the width of the bounding box of the target path
 * @param height the height of the bounding box of the target path
 * @param numSample the number of points needed
 *
 * @return the path
 */
","/**
 * Converts the stroke to a Path of a given number of points.
 *
 * @param width the width of the bounding box of the target path
 * @param height the height of the bounding box of the target path
 * @param numSample the number of points needed
 *
 * @return the path
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The code has changed from calling the method GestureUtilities.temporalSampling() and GestureUtilities.scale() to GestureUtils.temporalSampling() and GestureUtils.scale() correspondingly, the type of dependent APIs has changed, so the code change type is 5.","Although some APIs that the method depends on have changed, the overall behavior and return values of the method itself do not seem to change. As such, there is no compatibility issue detected, so the CI type is 0."
1,<android.webkit.WebViewDatabase: ArrayList<Cookie> getCookiesForDomain(String)>,7,8,<android.webkit.WebViewDatabase: ArrayList<Cookie> getCookiesForDomain(String)>,<android.webkit.WebViewDatabase: ArrayList<Cookie> getCookiesForDomain(String)>,0,"{
    ArrayList<Cookie> list = new ArrayList<Cookie>();
    if (domain == null || mDatabase == null) {
        return list;
    }
    synchronized (mCookieLock) {
        final String[] columns = new String[] { ID_COL, COOKIES_DOMAIN_COL, COOKIES_PATH_COL, COOKIES_NAME_COL, COOKIES_VALUE_COL, COOKIES_EXPIRES_COL, COOKIES_SECURE_COL };
        final String selection = ""("" + COOKIES_DOMAIN_COL + "" GLOB '*' || ?)"";
        Cursor cursor = mDatabase.query(mTableNames[TABLE_COOKIES_ID], columns, selection, new String[] { domain }, null, null, null);
        if (cursor.moveToFirst()) {
            int domainCol = cursor.getColumnIndex(COOKIES_DOMAIN_COL);
            int pathCol = cursor.getColumnIndex(COOKIES_PATH_COL);
            int nameCol = cursor.getColumnIndex(COOKIES_NAME_COL);
            int valueCol = cursor.getColumnIndex(COOKIES_VALUE_COL);
            int expiresCol = cursor.getColumnIndex(COOKIES_EXPIRES_COL);
            int secureCol = cursor.getColumnIndex(COOKIES_SECURE_COL);
            do {
                Cookie cookie = new Cookie();
                cookie.domain = cursor.getString(domainCol);
                cookie.path = cursor.getString(pathCol);
                cookie.name = cursor.getString(nameCol);
                cookie.value = cursor.getString(valueCol);
                if (cursor.isNull(expiresCol)) {
                    cookie.expires = -1;
                } else {
                    cookie.expires = cursor.getLong(expiresCol);
                }
                cookie.secure = cursor.getShort(secureCol) != 0;
                cookie.mode = Cookie.MODE_NORMAL;
                list.add(cookie);
            } while (cursor.moveToNext());
        }
        cursor.close();
        return list;
    }
}","{
    ArrayList<Cookie> list = new ArrayList<Cookie>();
    if (domain == null || mDatabase == null) {
        return list;
    }
    synchronized (mCookieLock) {
        final String[] columns = new String[] { ID_COL, COOKIES_DOMAIN_COL, COOKIES_PATH_COL, COOKIES_NAME_COL, COOKIES_VALUE_COL, COOKIES_EXPIRES_COL, COOKIES_SECURE_COL };
        final String selection = ""("" + COOKIES_DOMAIN_COL + "" GLOB '*' || ?)"";
        Cursor cursor = null;
        try {
            cursor = mDatabase.query(mTableNames[TABLE_COOKIES_ID], columns, selection, new String[] { domain }, null, null, null);
            if (cursor.moveToFirst()) {
                int domainCol = cursor.getColumnIndex(COOKIES_DOMAIN_COL);
                int pathCol = cursor.getColumnIndex(COOKIES_PATH_COL);
                int nameCol = cursor.getColumnIndex(COOKIES_NAME_COL);
                int valueCol = cursor.getColumnIndex(COOKIES_VALUE_COL);
                int expiresCol = cursor.getColumnIndex(COOKIES_EXPIRES_COL);
                int secureCol = cursor.getColumnIndex(COOKIES_SECURE_COL);
                do {
                    Cookie cookie = new Cookie();
                    cookie.domain = cursor.getString(domainCol);
                    cookie.path = cursor.getString(pathCol);
                    cookie.name = cursor.getString(nameCol);
                    cookie.value = cursor.getString(valueCol);
                    if (cursor.isNull(expiresCol)) {
                        cookie.expires = -1;
                    } else {
                        cookie.expires = cursor.getLong(expiresCol);
                    }
                    cookie.secure = cursor.getShort(secureCol) != 0;
                    cookie.mode = Cookie.MODE_NORMAL;
                    list.add(cookie);
                } while (cursor.moveToNext());
            }
        } catch (IllegalStateException e) {
            Log.e(LOGTAG, ""getCookiesForDomain"", e);
        } finally {
            if (cursor != null)
                cursor.close();
        }
        return list;
    }
}",1,"/**
 * Get cookies in the format of CookieManager.Cookie inside an ArrayList for
 * a given domain
 *
 * @return ArrayList<Cookie> If nothing is found, return an empty list.
 */
","/**
 * Get cookies in the format of CookieManager.Cookie inside an ArrayList for
 * a given domain
 *
 * @return ArrayList<Cookie> If nothing is found, return an empty list.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,3",2,"In the early version of the API, a Cursor object named ""cursor"" is directly assigned a value through a database query operation. In contrast, in the late version of the API, the declaration of ""cursor"" is detached from the assignment process (it's first declared as null), and this assignment process is enclosed in a try-catch block. Moreover, a new RuntimeException ""IllegalStateException"" with a specified error message is caught in the late version. Therefore, the change type is 2,3.","As a result of the new exception handling statement in the late version of this API, it may throw a different exception compared to the early version, so the API behaviors are potentially changed accordingly. Therefore, the compatibility issue type is 2."
2,"<android.widget.ExpandableListView: void drawDivider(Canvas,Rect,int)>",7,8,"<android.widget.ExpandableListView: void drawDivider(Canvas,Rect,int)>","<android.widget.ExpandableListView: void drawDivider(Canvas,Rect,int)>",0,"{
    int flatListPosition = childIndex + mFirstPosition;
    // all items, then the item below it has to be a group)
    if (flatListPosition >= 0) {
        PositionMetadata pos = mConnector.getUnflattenedPos(flatListPosition);
        // If this item is a child, or it is a non-empty group that is expanded
        if ((pos.position.type == ExpandableListPosition.CHILD) || (pos.isExpanded() && pos.groupMetadata.lastChildFlPos != pos.groupMetadata.flPos)) {
            // These are the cases where we draw the child divider
            final Drawable divider = mChildDivider;
            final boolean clip = mClipChildDivider;
            if (!clip) {
                divider.setBounds(bounds);
            } else {
                canvas.save();
                canvas.clipRect(bounds);
            }
            divider.draw(canvas);
            if (clip) {
                canvas.restore();
            }
            pos.recycle();
            return;
        }
        pos.recycle();
    }
    // Otherwise draw the default divider
    super.drawDivider(canvas, bounds, flatListPosition);
}","{
    int flatListPosition = childIndex + mFirstPosition;
    // all items, then the item below it has to be a group)
    if (flatListPosition >= 0) {
        final int adjustedPosition = getFlatPositionForConnector(flatListPosition);
        PositionMetadata pos = mConnector.getUnflattenedPos(adjustedPosition);
        // If this item is a child, or it is a non-empty group that is expanded
        if ((pos.position.type == ExpandableListPosition.CHILD) || (pos.isExpanded() && pos.groupMetadata.lastChildFlPos != pos.groupMetadata.flPos)) {
            // These are the cases where we draw the child divider
            final Drawable divider = mChildDivider;
            final boolean clip = mClipChildDivider;
            if (!clip) {
                divider.setBounds(bounds);
            } else {
                canvas.save();
                canvas.clipRect(bounds);
            }
            divider.draw(canvas);
            if (clip) {
                canvas.restore();
            }
            pos.recycle();
            return;
        }
        pos.recycle();
    }
    // Otherwise draw the default divider
    super.drawDivider(canvas, bounds, flatListPosition);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"4,5",1,"There's an additional method call to 'getFlatPositionForConnector(flatListPosition)', which is a dependent API change, hence code change type is 4,5.","As the introduction of the new dependent API 'getFlatPositionForConnector', the return value might be different between two versions when the condition checks satisfies in the 'if' statements. Hence, the CI type is 1."
3,"<android.webkit.WebView: void initiateTextFieldDrag(float,float,long)>",7,8,"<android.webkit.WebView: void initiateTextFieldDrag(float,float,long)>","<android.webkit.WebView: void initiateTextFieldDrag(float,float,long)>",0,"{
    if (!inEditingMode()) {
        return;
    }
    mLastTouchX = x + (float) (mWebTextView.getLeft() - mScrollX);
    mLastTouchY = y + (float) (mWebTextView.getTop() - mScrollY);
    mLastTouchTime = eventTime;
    if (!mScroller.isFinished()) {
        abortAnimation();
        mPrivateHandler.removeMessages(RESUME_WEBCORE_UPDATE);
    }
    mSnapScrollMode = SNAP_NONE;
    mVelocityTracker = VelocityTracker.obtain();
    mTouchMode = TOUCH_DRAG_START_MODE;
}","{
    if (!inEditingMode()) {
        return;
    }
    mLastTouchX = x + (float) (mWebTextView.getLeft() - mScrollX);
    mLastTouchY = y + (float) (mWebTextView.getTop() - mScrollY);
    mLastTouchTime = eventTime;
    if (!mScroller.isFinished()) {
        abortAnimation();
        mPrivateHandler.removeMessages(RESUME_WEBCORE_PRIORITY);
    }
    mSnapScrollMode = SNAP_NONE;
    mVelocityTracker = VelocityTracker.obtain();
    mTouchMode = TOUCH_DRAG_START_MODE;
}",1,"/*package*/
","/*package*/
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The parameter of method removeMessages() has changed from RESUME_WEBCORE_UPDATE to RESUME_WEBCORE_PRIORITY, so the code change type is 4.","The change does not potentially caused by different return values/types or exception handlings, thus no Compatibility Issue exists, and the CI type is 0."
5,<android.webkit.WebBackForwardList: WebBackForwardList clone()>,7,8,<android.webkit.WebBackForwardList: WebBackForwardList clone()>,<android.webkit.WebBackForwardList: WebBackForwardList clone()>,0,"{
    WebBackForwardList l = new WebBackForwardList();
    if (mClearPending) {
        // If a clear is pending, return a copy with only the current item.
        l.addHistoryItem(getCurrentItem());
        return l;
    }
    l.mCurrentIndex = mCurrentIndex;
    int size = getSize();
    l.mArray = new ArrayList<WebHistoryItem>(size);
    for (int i = 0; i < size; i++) {
        // Add a copy of each WebHistoryItem
        l.mArray.add(mArray.get(i).clone());
    }
    return l;
}","{
    WebBackForwardList l = new WebBackForwardList(null);
    if (mClearPending) {
        // If a clear is pending, return a copy with only the current item.
        l.addHistoryItem(getCurrentItem());
        return l;
    }
    l.mCurrentIndex = mCurrentIndex;
    int size = getSize();
    l.mArray = new ArrayList<WebHistoryItem>(size);
    for (int i = 0; i < size; i++) {
        // Add a copy of each WebHistoryItem
        l.mArray.add(mArray.get(i).clone());
    }
    return l;
}",1,"/**
 * Clone the entire object to be used in the UI thread by clients of
 * WebView. This creates a copy that should never be modified by any of the
 * webkit package classes.
 */
","/**
 * Clone the entire object to be used in the UI thread by clients of
 * WebView. This creates a copy that should never be modified by any of the
 * webkit package classes.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,The instantiation of WebBackForwardList changed by passing null in the late version while not passing anything in the early version. This corresponds to change type 1 and 5.,"The returned object of WebBackForwardList may differ as it is constructed differently in the early and late versions (passing null in the late version). So, the CI type is 1."
6,"<android.accounts.AccountManager: AccountManagerFuture<Bundle> editProperties(String,Activity,AccountManagerCallback<Bundle>,Handler)>",7,8,"<android.accounts.AccountManager: AccountManagerFuture<Bundle> editProperties(String,Activity,AccountManagerCallback<Bundle>,Handler)>","<android.accounts.AccountManager: AccountManagerFuture<Bundle> editProperties(String,Activity,AccountManagerCallback<Bundle>,Handler)>",0,"{
    return new AmsTask(activity, handler, callback) {

        public void doWork() throws RemoteException {
            mService.editProperties(mResponse, accountType, activity != null);
        }
    }.start();
}","{
    if (accountType == null)
        throw new IllegalArgumentException(""accountType is null"");
    return new AmsTask(activity, handler, callback) {

        public void doWork() throws RemoteException {
            mService.editProperties(mResponse, accountType, activity != null);
        }
    }.start();
}",1,"/**
 * Request that the properties for an authenticator be updated. This is typically done by
 * returning an intent to an activity that will allow the user to make changes. This request
 * is processed by the authenticator for the account. If no matching authenticator is
 * registered in the system then {@link AuthenticatorException} is thrown.
 * <p>
 * This call returns immediately but runs asynchronously and the result is accessed via the
 * {@link AccountManagerFuture} that is returned. This future is also passed as the sole
 * parameter to the {@link AccountManagerCallback}. If the caller wished to use this
 * method asynchronously then they will generally pass in a callback object that will get
 * invoked with the {@link AccountManagerFuture}. If they wish to use it synchronously then
 * they will generally pass null for the callback and instead call
 * {@link android.accounts.AccountManagerFuture#getResult()} on this method's return value,
 * which will then block until the request completes.
 * <p>
 * Requires that the caller has permission {@link android.Manifest.permission#MANAGE_ACCOUNTS}.
 *
 * @param accountType The account type of the authenticator whose properties are to be edited.
 * @param activity If the authenticator returns a {@link #KEY_INTENT} in the result then
 * the intent will be started with this activity. If activity is null then the result will
 * be returned as-is.
 * @param callback A callback to invoke when the request completes. If null then
 * no callback is invoked.
 * @param handler The {@link Handler} to use to invoke the callback. If null then the
 * main thread's {@link Handler} is used.
 * @return an {@link AccountManagerFuture} that represents the future result of the call.
 * The future result is a {@link Bundle} that contains either:
 * <ul>
 * <li> {@link #KEY_INTENT}, which is to be used to prompt the user for the credentials
 * <li> nothing, returned if the edit completes successfully
 * </ul>
 * If the user presses ""back"" then the request will be canceled.
 */
","/**
 * Offers the user an opportunity to change an authenticator's settings.
 * These properties are for the authenticator in general, not a particular
 * account.  Not all authenticators support this method.
 *
 * <p>This method may be called from any thread, but the returned
 * {@link AccountManagerFuture} must not be used on the main thread.
 *
 * <p>This method requires the caller to hold the permission
 * {@link android.Manifest.permission#MANAGE_ACCOUNTS}.
 *
 * @param accountType The account type associated with the authenticator
 * to adjust
 * @param activity The {@link Activity} context to use for launching a new
 * authenticator-defined sub-Activity to adjust authenticator settings;
 * used only to call startActivity(); if null, the settings dialog will
 * not be launched directly, but the necessary {@link Intent} will be
 * returned to the caller instead
 * @param callback Callback to invoke when the request completes,
 * null for no callback
 * @param handler {@link Handler} identifying the callback thread,
 * null for the main thread
 * @return An {@link AccountManagerFuture} which resolves to a Bundle
 * which is empty if properties were edited successfully, or
 * if no activity was specified, contains only {@link #KEY_INTENT}
 * needed to launch the authenticator's settings dialog.
 *
 * <p>If an error occurred, {@link AccountManagerFuture#getResult()} throws:
 * <ul>
 * <li> {@link AuthenticatorException} if no authenticator was registered for
 * this account type or the authenticator failed to respond
 * <li> {@link OperationCanceledException} if the operation was canceled for
 * any reason, including the user canceling the settings dialog
 * <li> {@link IOException} if the authenticator experienced an I/O problem
 * updating settings, usually because of network trouble
 * </ul>
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,3","1,2","In the late version, an if statement together with a new throw statement has been introduced, hence the change types are 2,3.","As a new exception throw is introduced, the CI type includes 2. Additionally, due to the change in control statement, the execution path of the method can now be different, leading to a potential change in return, making the CI type also 1."
7,"<android.util.Log: int v(String,String,Throwable)>",7,8,"<android.util.Log: int v(String,String,Throwable)>","<android.util.Log: int v(String,String,Throwable)>",0,"{
    return println(VERBOSE, tag, msg + '\n' + getStackTraceString(tr));
}","{
    return println_native(LOG_ID_MAIN, VERBOSE, tag, msg + '\n' + getStackTraceString(tr));
}",1,"/**
 * Send a {@link #VERBOSE} log message and log the exception.
 * @param tag Used to identify the source of a log message.  It usually identifies
 * the class or activity where the log call occurs.
 * @param msg The message you would like logged.
 * @param tr An exception to log
 */
","/**
 * Send a {@link #VERBOSE} log message and log the exception.
 * @param tag Used to identify the source of a log message.  It usually identifies
 * the class or activity where the log call occurs.
 * @param msg The message you would like logged.
 * @param tr An exception to log
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The return statement has changed from println() to println_native() and the parameter type of println_native() also changed, so the code change type is 1,5.","The change of return statement will make the API potentially return a different value, so the CI type is 1."
9,"<android.webkit.WebView: boolean savePicture(Bundle,File)>",7,8,"<android.webkit.WebView: boolean savePicture(Bundle,File)>","<android.webkit.WebView: boolean savePicture(Bundle,File)>",0,"{
    if (dest == null || b == null) {
        return false;
    }
    final Picture p = capturePicture();
    try {
        final FileOutputStream out = new FileOutputStream(dest);
        p.writeToStream(out);
        out.close();
    } catch (FileNotFoundException e) {
        e.printStackTrace();
    } catch (IOException e) {
        e.printStackTrace();
    } catch (RuntimeException e) {
        e.printStackTrace();
    }
    if (dest.length() > 0) {
        b.putInt(""scrollX"", mScrollX);
        b.putInt(""scrollY"", mScrollY);
        b.putFloat(""scale"", mActualScale);
        b.putFloat(""textwrapScale"", mTextWrapScale);
        b.putBoolean(""overview"", mInZoomOverview);
        return true;
    }
    return false;
}","{
    if (dest == null || b == null) {
        return false;
    }
    final Picture p = capturePicture();
    // Use a temporary file while writing to ensure the destination file
    // contains valid data.
    final File temp = new File(dest.getPath() + "".writing"");
    new Thread(new Runnable() {

        public void run() {
            try {
                FileOutputStream out = new FileOutputStream(temp);
                p.writeToStream(out);
                out.close();
                // Writing the picture succeeded, rename the temporary file
                // to the destination.
                temp.renameTo(dest);
            } catch (Exception e) {
            // too late to do anything about it.
            } finally {
                temp.delete();
            }
        }
    }).start();
    // now update the bundle
    b.putInt(""scrollX"", mScrollX);
    b.putInt(""scrollY"", mScrollY);
    b.putFloat(""scale"", mActualScale);
    b.putFloat(""textwrapScale"", mTextWrapScale);
    b.putBoolean(""overview"", mInZoomOverview);
    return true;
}",1,"/**
 * Save the current display data to the Bundle given. Used in conjunction
 * with {@link #saveState}.
 * @param b A Bundle to store the display data.
 * @param dest The file to store the serialized picture data. Will be
 * overwritten with this WebView's picture data.
 * @return True if the picture was successfully saved.
 */
","/**
 * Save the current display data to the Bundle given. Used in conjunction
 * with {@link #saveState}.
 * @param b A Bundle to store the display data.
 * @param dest The file to store the serialized picture data. Will be
 * overwritten with this WebView's picture data.
 * @return True if the picture was successfully saved.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,3,4","1,2","The method has been restructured to start a new Thread which contains part of the original code and added new operations. Also, the exception handling has been changed to do nothing instead of ""printStackTrace"". Therefore, the change type is 2,3,4.","The edited code could potentially return different values as the new implementation does not have the condition ""if (dest.length() > 0)"" which was present in the early version. Furthermore, the exception handling has been changed, potentially causing different exceptions to be thrown. So, the CI type is 1,2."
11,<android.widget.AbsListView.PerformClick: void run()>,7,8,<android.widget.AbsListView.PerformClick: void run()>,<android.widget.AbsListView.PerformClick: void run()>,0,"{
    // bail out before bad things happen
    if (mDataChanged)
        return;
    if (mAdapter != null && mItemCount > 0 && mClickMotionPosition < mAdapter.getCount() && sameWindow()) {
        performItemClick(mChild, mClickMotionPosition, getAdapter().getItemId(mClickMotionPosition));
    }
}","{
    // bail out before bad things happen
    if (mDataChanged)
        return;
    final ListAdapter adapter = mAdapter;
    final int motionPosition = mClickMotionPosition;
    if (adapter != null && mItemCount > 0 && motionPosition != INVALID_POSITION && motionPosition < adapter.getCount() && sameWindow()) {
        performItemClick(mChild, motionPosition, adapter.getItemId(motionPosition));
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"3, 4",1,"The control dependency 'if' statement condition has changed and two new local variables have been introduced (adapter and motionPosition), so the code change type is 3, 4.","Due to the change in the 'if' condition, the function may execute the performItemClick method under different conditions in the late version and can cause potential different return (as the method returns nothing, the return here means whether invoking performItemClick or not). Therefore the CI type is 1."
12,<android.pim.vcard.VCardComposer: boolean createOneEntry()>,7,8,<android.pim.vcard.VCardComposer: boolean createOneEntry()>,<android.pim.vcard.VCardComposer: boolean createOneEntry()>,0,"{
    if (mCursor == null || mCursor.isAfterLast()) {
        mErrorReason = FAILURE_REASON_NOT_INITIALIZED;
        return false;
    }
    String name = null;
    String vcard;
    try {
        if (mIsCallLogComposer) {
            vcard = createOneCallLogEntryInternal();
        } else {
            if (mIdColumn >= 0) {
                vcard = createOneEntryInternal(mCursor.getString(mIdColumn));
            } else {
                Log.e(LOG_TAG, ""Incorrect mIdColumn: "" + mIdColumn);
                return true;
            }
        }
    } catch (OutOfMemoryError error) {
        // Maybe some data (e.g. photo) is too big to have in memory. But it
        // should be rare.
        Log.e(LOG_TAG, ""OutOfMemoryError occured. Ignore the entry: "" + name);
        System.gc();
        // TODO: should tell users what happened?
        return true;
    } finally {
        mCursor.moveToNext();
    }
    // :-P
    if (mCareHandlerErrors) {
        List<OneEntryHandler> finishedList = new ArrayList<OneEntryHandler>(mHandlerList.size());
        for (OneEntryHandler handler : mHandlerList) {
            if (!handler.onEntryCreated(vcard)) {
                return false;
            }
        }
    } else {
        for (OneEntryHandler handler : mHandlerList) {
            handler.onEntryCreated(vcard);
        }
    }
    return true;
}","{
    return createOneEntry(null);
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"1,4",1,"This method changes its implementation significantly. It replaces all the logic with one line return statement, creating one entry with null parameter. Notably, the original method has a complicated logic with multiple return statements, but the updated version only returns the result of calling createOneEntry(null), so the code change type is 1,4.","Due to the drastic change of code structure, it is potential to return the different results compared to the early version. So, a Compatibility Issue caused by potential different return values exists here, and CI type is 1."
13,<android.net.http.Request: void readResponse(AndroidHttpClientConnection)>,7,8,<android.net.http.Request: void readResponse(AndroidHttpClientConnection)>,<android.net.http.Request: void readResponse(AndroidHttpClientConnection)>,0,"{
    // don't send cancelled requests
    if (mCancelled)
        return;
    StatusLine statusLine = null;
    boolean hasBody = false;
    boolean reuse = false;
    httpClientConnection.flush();
    int statusCode = 0;
    Headers header = new Headers();
    do {
        statusLine = httpClientConnection.parseResponseHeader(header);
        statusCode = statusLine.getStatusCode();
    } while (statusCode < HttpStatus.SC_OK);
    if (HttpLog.LOGV)
        HttpLog.v(""Request.readResponseStatus() "" + statusLine.toString().length() + "" "" + statusLine);
    ProtocolVersion v = statusLine.getProtocolVersion();
    mEventHandler.status(v.getMajor(), v.getMinor(), statusCode, statusLine.getReasonPhrase());
    mEventHandler.headers(header);
    HttpEntity entity = null;
    hasBody = canResponseHaveBody(mHttpRequest, statusCode);
    if (hasBody)
        entity = httpClientConnection.receiveResponseEntity(header);
    if (entity != null) {
        InputStream is = entity.getContent();
        // process gzip content encoding
        Header contentEncoding = entity.getContentEncoding();
        InputStream nis = null;
        byte[] buf = null;
        int count = 0;
        try {
            if (contentEncoding != null && contentEncoding.getValue().equals(""gzip"")) {
                nis = new GZIPInputStream(is);
            } else {
                nis = is;
            }
            /* accumulate enough data to make it worth pushing it
                 * up the stack */
            buf = mConnection.getBuf();
            int len = 0;
            int lowWater = buf.length / 2;
            while (len != -1) {
                len = nis.read(buf, count, buf.length - count);
                if (len != -1) {
                    count += len;
                }
                if (len == -1 || count >= lowWater) {
                    if (HttpLog.LOGV)
                        HttpLog.v(""Request.readResponse() "" + count);
                    mEventHandler.data(buf, count);
                    count = 0;
                }
            }
        } catch (EOFException e) {
            /* InflaterInputStream throws an EOFException when the
                   server truncates gzipped content.  Handle this case
                   as we do truncated non-gzipped content: no error */
            if (count > 0) {
                // if there is uncommited content, we should commit them
                mEventHandler.data(buf, count);
            }
            if (HttpLog.LOGV)
                HttpLog.v(""readResponse() handling "" + e);
        } catch (IOException e) {
            // don't throw if we have a non-OK status code
            if (statusCode == HttpStatus.SC_OK) {
                throw e;
            }
        } finally {
            if (nis != null) {
                nis.close();
            }
        }
    }
    mConnection.setCanPersist(entity, statusLine.getProtocolVersion(), header.getConnectionType());
    mEventHandler.endData();
    complete();
    if (HttpLog.LOGV)
        HttpLog.v(""Request.readResponse(): done "" + mHost.getSchemeName() + ""://"" + getHostPort() + mPath);
}","{
    // don't send cancelled requests
    if (mCancelled)
        return;
    StatusLine statusLine = null;
    boolean hasBody = false;
    httpClientConnection.flush();
    int statusCode = 0;
    Headers header = new Headers();
    do {
        statusLine = httpClientConnection.parseResponseHeader(header);
        statusCode = statusLine.getStatusCode();
    } while (statusCode < HttpStatus.SC_OK);
    if (HttpLog.LOGV)
        HttpLog.v(""Request.readResponseStatus() "" + statusLine.toString().length() + "" "" + statusLine);
    ProtocolVersion v = statusLine.getProtocolVersion();
    mEventHandler.status(v.getMajor(), v.getMinor(), statusCode, statusLine.getReasonPhrase());
    mEventHandler.headers(header);
    HttpEntity entity = null;
    hasBody = canResponseHaveBody(mHttpRequest, statusCode);
    if (hasBody)
        entity = httpClientConnection.receiveResponseEntity(header);
    // restrict the range request to the servers claiming that they are
    // accepting ranges in bytes
    boolean supportPartialContent = ""bytes"".equalsIgnoreCase(header.getAcceptRanges());
    if (entity != null) {
        InputStream is = entity.getContent();
        // process gzip content encoding
        Header contentEncoding = entity.getContentEncoding();
        InputStream nis = null;
        byte[] buf = null;
        int count = 0;
        try {
            if (contentEncoding != null && contentEncoding.getValue().equals(""gzip"")) {
                nis = new GZIPInputStream(is);
            } else {
                nis = is;
            }
            /* accumulate enough data to make it worth pushing it
                 * up the stack */
            buf = mConnection.getBuf();
            int len = 0;
            int lowWater = buf.length / 2;
            while (len != -1) {
                synchronized (this) {
                    while (mLoadingPaused) {
                        // filled its internal buffers.
                        try {
                            wait();
                        } catch (InterruptedException e) {
                            HttpLog.e(""Interrupted exception whilst "" + ""network thread paused at WebCore's request."" + "" "" + e.getMessage());
                        }
                    }
                }
                len = nis.read(buf, count, buf.length - count);
                if (len != -1) {
                    count += len;
                    if (supportPartialContent)
                        mReceivedBytes += len;
                }
                if (len == -1 || count >= lowWater) {
                    if (HttpLog.LOGV)
                        HttpLog.v(""Request.readResponse() "" + count);
                    mEventHandler.data(buf, count);
                    count = 0;
                }
            }
        } catch (EOFException e) {
            /* InflaterInputStream throws an EOFException when the
                   server truncates gzipped content.  Handle this case
                   as we do truncated non-gzipped content: no error */
            if (count > 0) {
                // if there is uncommited content, we should commit them
                mEventHandler.data(buf, count);
            }
            if (HttpLog.LOGV)
                HttpLog.v(""readResponse() handling "" + e);
        } catch (IOException e) {
            // don't throw if we have a non-OK status code
            if (statusCode == HttpStatus.SC_OK || statusCode == HttpStatus.SC_PARTIAL_CONTENT) {
                if (supportPartialContent && count > 0) {
                    // if there is uncommited content, we should commit them
                    // as we will continue the request
                    mEventHandler.data(buf, count);
                }
                throw e;
            }
        } finally {
            if (nis != null) {
                nis.close();
            }
        }
    }
    mConnection.setCanPersist(entity, statusLine.getProtocolVersion(), header.getConnectionType());
    mEventHandler.endData();
    complete();
    if (HttpLog.LOGV)
        HttpLog.v(""Request.readResponse(): done "" + mHost.getSchemeName() + ""://"" + getHostPort() + mPath);
}",1,"/**
 * Receive a single http response.
 *
 * @param httpClientConnection the request to receive the response for.
 */
","/**
 * Receive a single http response.
 *
 * @param httpClientConnection the request to receive the response for.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3,4","1,2",Several changes has been made in this update:,"- In the IOException handling block, the conditions checked have changed ('statusCode == HttpStatus.SC_OK' to 'statusCode == HttpStatus.SC_OK || statusCode == HttpStatus.SC_PARTIAL_CONTENT') along with the introduction of a new if statement;"
14,"<android.accounts.AccountManager: String peekAuthToken(Account,String)>",7,8,"<android.accounts.AccountManager: String peekAuthToken(Account,String)>","<android.accounts.AccountManager: String peekAuthToken(Account,String)>",0,"{
    if (account == null) {
        Log.e(TAG, ""peekAuthToken: the account must not be null"");
        return null;
    }
    if (authTokenType == null) {
        return null;
    }
    try {
        return mService.peekAuthToken(account, authTokenType);
    } catch (RemoteException e) {
        // won't ever happen
        throw new RuntimeException(e);
    }
}","{
    if (account == null)
        throw new IllegalArgumentException(""account is null"");
    if (authTokenType == null)
        throw new IllegalArgumentException(""authTokenType is null"");
    try {
        return mService.peekAuthToken(account, authTokenType);
    } catch (RemoteException e) {
        // won't ever happen
        throw new RuntimeException(e);
    }
}",1,"/**
 * Gets the authtoken named by ""authTokenType"" for the specified account if it is cached
 * by the AccountManager. If no authtoken is cached then null is returned rather than
 * asking the authenticaticor to generate one. If the account or the
 * authtoken do not exist then null is returned.
 * <p>
 * Requires that the caller has permission
 * {@link android.Manifest.permission#AUTHENTICATE_ACCOUNTS} and is running
 * with the same UID as the Authenticator for the account.
 * @param account the account whose authtoken is to be retrieved, must not be null
 * @param authTokenType the type of authtoken to retrieve
 * @return an authtoken for the given account and authTokenType, if one is cached by the
 * AccountManager, null otherwise.
 */
","/**
 * Gets an auth token from the AccountManager's cache.  If no auth
 * token is cached for this account, null will be returned -- a new
 * auth token will not be generated, and the server will not be contacted.
 * Intended for use by the authenticator, not directly by applications.
 *
 * <p>It is safe to call this method from the main thread.
 *
 * <p>This method requires the caller to hold the permission
 * {@link android.Manifest.permission#AUTHENTICATE_ACCOUNTS}
 * and to have the same UID as the account's authenticator.
 *
 * @param account The account to fetch an auth token for
 * @param authTokenType The type of auth token to fetch, see {#getAuthToken}
 * @return The cached auth token for this account and type, or null if
 * no auth token is cached or the account does not exist.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,2","1,2","The exception handling and return statement in 'if' statements are changed from logging and returning null values to throwing IllegalArgumentExceptions, which results in a classification of 1,2.","The change in return statement may lead to returning different values. Additionally, the new exception thrown could potentially change the behavior of API by dealing differently with invalid input. Thus, this should be considered as an instance of compatibility issue class 1 and 2."
16,"<android.webkit.CacheManager: void saveCacheFile(String,CacheResult)>",7,8,"<android.webkit.CacheManager: void saveCacheFile(String,CacheResult)>","<android.webkit.CacheManager: void saveCacheFile(String,CacheResult)>",0,"{
    try {
        cacheRet.outStream.close();
    } catch (IOException e) {
        return;
    }
    if (!cacheRet.outFile.exists()) {
        // the file in the cache directory can be removed by the system
        return;
    }
    cacheRet.contentLength = cacheRet.outFile.length();
    boolean redirect = checkCacheRedirect(cacheRet.httpStatusCode);
    if (redirect) {
        // location is in database, no need to keep the file
        cacheRet.contentLength = 0;
        cacheRet.localPath = """";
    }
    if ((redirect || cacheRet.contentLength == 0) && !cacheRet.outFile.delete()) {
        Log.e(LOGTAG, cacheRet.outFile.getPath() + "" delete failed."");
    }
    if (cacheRet.contentLength == 0) {
        return;
    }
    mDataBase.addCache(url, cacheRet);
    if (DebugFlags.CACHE_MANAGER) {
        Log.v(LOGTAG, ""saveCacheFile for url "" + url);
    }
}","{
    saveCacheFile(url, 0, cacheRet);
}",1,"// only called from WebCore thread
","/**
 * Save the info of a cache file for a given url to the CacheMap so that it
 * can be reused later
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The implementation has completely changed in the late version. All execution branches of the method are removed and replaced with a call to an overloaded version of the same method. Therefore, the code change type is 1,5.","The replacement of all the execution branches with a call to an overload of the same method implies that the API potentially returns different values in the two versions. Thus, the CI type is 1."
18,"<android.service.wallpaper.WallpaperService.Engine: void updateSurface(boolean,boolean)>",7,8,"<android.service.wallpaper.WallpaperService.Engine: void updateSurface(boolean,boolean)>","<android.service.wallpaper.WallpaperService.Engine: void updateSurface(boolean,boolean)>",0,"{
    if (mDestroyed) {
        Log.w(TAG, ""Ignoring updateSurface: destroyed"");
    }
    int myWidth = mSurfaceHolder.getRequestedWidth();
    if (myWidth <= 0)
        myWidth = ViewGroup.LayoutParams.FILL_PARENT;
    int myHeight = mSurfaceHolder.getRequestedHeight();
    if (myHeight <= 0)
        myHeight = ViewGroup.LayoutParams.FILL_PARENT;
    final boolean creating = !mCreated;
    final boolean formatChanged = mFormat != mSurfaceHolder.getRequestedFormat();
    boolean sizeChanged = mWidth != myWidth || mHeight != myHeight;
    final boolean typeChanged = mType != mSurfaceHolder.getRequestedType();
    final boolean flagsChanged = mCurWindowFlags != mWindowFlags;
    if (forceRelayout || creating || formatChanged || sizeChanged || typeChanged || flagsChanged) {
        if (DEBUG)
            Log.v(TAG, ""Changes: creating="" + creating + "" format="" + formatChanged + "" size="" + sizeChanged);
        try {
            mWidth = myWidth;
            mHeight = myHeight;
            mFormat = mSurfaceHolder.getRequestedFormat();
            mType = mSurfaceHolder.getRequestedType();
            mLayout.x = 0;
            mLayout.y = 0;
            mLayout.width = myWidth;
            mLayout.height = myHeight;
            mLayout.format = mFormat;
            mCurWindowFlags = mWindowFlags;
            mLayout.flags = mWindowFlags | WindowManager.LayoutParams.FLAG_LAYOUT_NO_LIMITS | WindowManager.LayoutParams.FLAG_LAYOUT_IN_SCREEN | WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE;
            mLayout.memoryType = mType;
            mLayout.token = mWindowToken;
            if (!mCreated) {
                mLayout.type = mIWallpaperEngine.mWindowType;
                mLayout.gravity = Gravity.LEFT | Gravity.TOP;
                mLayout.setTitle(WallpaperService.this.getClass().getName());
                mLayout.windowAnimations = com.android.internal.R.style.Animation_Wallpaper;
                mSession.add(mWindow, mLayout, View.VISIBLE, mContentInsets);
            }
            mSurfaceHolder.mSurfaceLock.lock();
            mDrawingAllowed = true;
            final int relayoutResult = mSession.relayout(mWindow, mLayout, mWidth, mHeight, View.VISIBLE, false, mWinFrame, mContentInsets, mVisibleInsets, mSurfaceHolder.mSurface);
            if (DEBUG)
                Log.v(TAG, ""New surface: "" + mSurfaceHolder.mSurface + "", frame="" + mWinFrame);
            int w = mWinFrame.width();
            if (mCurWidth != w) {
                sizeChanged = true;
                mCurWidth = w;
            }
            int h = mWinFrame.height();
            if (mCurHeight != h) {
                sizeChanged = true;
                mCurHeight = h;
            }
            mSurfaceHolder.mSurfaceLock.unlock();
            try {
                mDestroyReportNeeded = true;
                SurfaceHolder.Callback[] callbacks = null;
                synchronized (mSurfaceHolder.mCallbacks) {
                    final int N = mSurfaceHolder.mCallbacks.size();
                    if (N > 0) {
                        callbacks = new SurfaceHolder.Callback[N];
                        mSurfaceHolder.mCallbacks.toArray(callbacks);
                    }
                }
                if (!mCreated) {
                    mIsCreating = true;
                    if (DEBUG)
                        Log.v(TAG, ""onSurfaceCreated("" + mSurfaceHolder + ""): "" + this);
                    onSurfaceCreated(mSurfaceHolder);
                    if (callbacks != null) {
                        for (SurfaceHolder.Callback c : callbacks) {
                            c.surfaceCreated(mSurfaceHolder);
                        }
                    }
                }
                if (forceReport || creating || formatChanged || sizeChanged) {
                    if (DEBUG) {
                        RuntimeException e = new RuntimeException();
                        e.fillInStackTrace();
                        Log.w(TAG, ""forceReport="" + forceReport + "" creating="" + creating + "" formatChanged="" + formatChanged + "" sizeChanged="" + sizeChanged, e);
                    }
                    if (DEBUG)
                        Log.v(TAG, ""onSurfaceChanged("" + mSurfaceHolder + "", "" + mFormat + "", "" + mCurWidth + "", "" + mCurHeight + ""): "" + this);
                    onSurfaceChanged(mSurfaceHolder, mFormat, mCurWidth, mCurHeight);
                    if (callbacks != null) {
                        for (SurfaceHolder.Callback c : callbacks) {
                            c.surfaceChanged(mSurfaceHolder, mFormat, mCurWidth, mCurHeight);
                        }
                    }
                }
            } finally {
                mIsCreating = false;
                mCreated = true;
                if (creating || (relayoutResult & WindowManagerImpl.RELAYOUT_FIRST_TIME) != 0) {
                    mSession.finishDrawing(mWindow);
                }
            }
        } catch (RemoteException ex) {
        }
        if (DEBUG)
            Log.v(TAG, ""Layout: x="" + mLayout.x + "" y="" + mLayout.y + "" w="" + mLayout.width + "" h="" + mLayout.height);
    }
}","{
    if (mDestroyed) {
        Log.w(TAG, ""Ignoring updateSurface: destroyed"");
    }
    int myWidth = mSurfaceHolder.getRequestedWidth();
    if (myWidth <= 0)
        myWidth = ViewGroup.LayoutParams.MATCH_PARENT;
    int myHeight = mSurfaceHolder.getRequestedHeight();
    if (myHeight <= 0)
        myHeight = ViewGroup.LayoutParams.MATCH_PARENT;
    final boolean creating = !mCreated;
    final boolean surfaceCreating = !mSurfaceCreated;
    final boolean formatChanged = mFormat != mSurfaceHolder.getRequestedFormat();
    boolean sizeChanged = mWidth != myWidth || mHeight != myHeight;
    final boolean typeChanged = mType != mSurfaceHolder.getRequestedType();
    final boolean flagsChanged = mCurWindowFlags != mWindowFlags;
    if (forceRelayout || creating || surfaceCreating || formatChanged || sizeChanged || typeChanged || flagsChanged) {
        if (DEBUG)
            Log.v(TAG, ""Changes: creating="" + creating + "" format="" + formatChanged + "" size="" + sizeChanged);
        try {
            mWidth = myWidth;
            mHeight = myHeight;
            mFormat = mSurfaceHolder.getRequestedFormat();
            mType = mSurfaceHolder.getRequestedType();
            mLayout.x = 0;
            mLayout.y = 0;
            mLayout.width = myWidth;
            mLayout.height = myHeight;
            mLayout.format = mFormat;
            mCurWindowFlags = mWindowFlags;
            mLayout.flags = mWindowFlags | WindowManager.LayoutParams.FLAG_LAYOUT_NO_LIMITS | WindowManager.LayoutParams.FLAG_LAYOUT_IN_SCREEN | WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE;
            mLayout.memoryType = mType;
            mLayout.token = mWindowToken;
            if (!mCreated) {
                mLayout.type = mIWallpaperEngine.mWindowType;
                mLayout.gravity = Gravity.LEFT | Gravity.TOP;
                mLayout.setTitle(WallpaperService.this.getClass().getName());
                mLayout.windowAnimations = com.android.internal.R.style.Animation_Wallpaper;
                mSession.add(mWindow, mLayout, View.VISIBLE, mContentInsets);
                mCreated = true;
            }
            mSurfaceHolder.mSurfaceLock.lock();
            mDrawingAllowed = true;
            final int relayoutResult = mSession.relayout(mWindow, mLayout, mWidth, mHeight, View.VISIBLE, false, mWinFrame, mContentInsets, mVisibleInsets, mConfiguration, mSurfaceHolder.mSurface);
            if (DEBUG)
                Log.v(TAG, ""New surface: "" + mSurfaceHolder.mSurface + "", frame="" + mWinFrame);
            int w = mWinFrame.width();
            if (mCurWidth != w) {
                sizeChanged = true;
                mCurWidth = w;
            }
            int h = mWinFrame.height();
            if (mCurHeight != h) {
                sizeChanged = true;
                mCurHeight = h;
            }
            mSurfaceHolder.mSurfaceLock.unlock();
            if (!mSurfaceHolder.mSurface.isValid()) {
                reportSurfaceDestroyed();
                if (DEBUG)
                    Log.v(TAG, ""Layout: Surface destroyed"");
                return;
            }
            try {
                SurfaceHolder.Callback[] callbacks = null;
                synchronized (mSurfaceHolder.mCallbacks) {
                    final int N = mSurfaceHolder.mCallbacks.size();
                    if (N > 0) {
                        callbacks = new SurfaceHolder.Callback[N];
                        mSurfaceHolder.mCallbacks.toArray(callbacks);
                    }
                }
                if (surfaceCreating) {
                    mIsCreating = true;
                    if (DEBUG)
                        Log.v(TAG, ""onSurfaceCreated("" + mSurfaceHolder + ""): "" + this);
                    onSurfaceCreated(mSurfaceHolder);
                    if (callbacks != null) {
                        for (SurfaceHolder.Callback c : callbacks) {
                            c.surfaceCreated(mSurfaceHolder);
                        }
                    }
                }
                if (forceReport || creating || surfaceCreating || formatChanged || sizeChanged) {
                    if (DEBUG) {
                        RuntimeException e = new RuntimeException();
                        e.fillInStackTrace();
                        Log.w(TAG, ""forceReport="" + forceReport + "" creating="" + creating + "" formatChanged="" + formatChanged + "" sizeChanged="" + sizeChanged, e);
                    }
                    if (DEBUG)
                        Log.v(TAG, ""onSurfaceChanged("" + mSurfaceHolder + "", "" + mFormat + "", "" + mCurWidth + "", "" + mCurHeight + ""): "" + this);
                    onSurfaceChanged(mSurfaceHolder, mFormat, mCurWidth, mCurHeight);
                    if (callbacks != null) {
                        for (SurfaceHolder.Callback c : callbacks) {
                            c.surfaceChanged(mSurfaceHolder, mFormat, mCurWidth, mCurHeight);
                        }
                    }
                }
            } finally {
                mIsCreating = false;
                mSurfaceCreated = true;
                if (creating || (relayoutResult & WindowManagerImpl.RELAYOUT_FIRST_TIME) != 0) {
                    mSession.finishDrawing(mWindow);
                }
            }
        } catch (RemoteException ex) {
        }
        if (DEBUG)
            Log.v(TAG, ""Layout: x="" + mLayout.x + "" y="" + mLayout.y + "" w="" + mLayout.width + "" h="" + mLayout.height);
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"4,3",1,"The value assigned to 'myWidth' and 'myHeight' in early implementation is based on 'FILL_PARENT' while in the late version it is 'MATCH_PARENT'. A new boolean variable 'surfaceCreating' is introduced. Also, a control condition 'surfaceCreating' is added to the if condition. Therefore, the code change type is 4,3.","The change of the return statement to an if condition that checks if 'mSurfaceHolder.mSurface.isValid()' and the changes in the values 'myWidth', 'myHeight', and the introduction of 'surfaceCreating' can change the behavior of the API when invoked. This potentially leads to different return values for the two versions, so the CI type is 1."
19,<android.pim.vcard.VCardParser_V21: void parseItems()>,7,8,<android.pim.vcard.VCardParser_V21: void parseItems()>,<android.pim.vcard.VCardParser_V21: void parseItems()>,0,"{
    /* items *CRLF item / item */
    boolean ended = false;
    if (mBuilder != null) {
        long start = System.currentTimeMillis();
        mBuilder.startProperty();
        mTimeStartProperty += System.currentTimeMillis() - start;
    }
    ended = parseItem();
    if (mBuilder != null && !ended) {
        long start = System.currentTimeMillis();
        mBuilder.endProperty();
        mTimeEndProperty += System.currentTimeMillis() - start;
    }
    while (!ended) {
        // follow VCARD ,it wont reach endProperty
        if (mBuilder != null) {
            long start = System.currentTimeMillis();
            mBuilder.startProperty();
            mTimeStartProperty += System.currentTimeMillis() - start;
        }
        try {
            ended = parseItem();
        } catch (VCardInvalidCommentLineException e) {
            Log.e(LOG_TAG, ""Invalid line which looks like some comment was found. Ignored."");
            ended = false;
        }
        if (mBuilder != null && !ended) {
            long start = System.currentTimeMillis();
            mBuilder.endProperty();
            mTimeEndProperty += System.currentTimeMillis() - start;
        }
    }
}","{
    boolean ended = false;
    if (mBuilder != null) {
        long start = System.currentTimeMillis();
        mBuilder.startProperty();
        mTimeStartProperty += System.currentTimeMillis() - start;
    }
    ended = parseItem();
    if (mBuilder != null && !ended) {
        long start = System.currentTimeMillis();
        mBuilder.endProperty();
        mTimeEndProperty += System.currentTimeMillis() - start;
    }
    while (!ended) {
        // follow VCARD ,it wont reach endProperty
        if (mBuilder != null) {
            long start = System.currentTimeMillis();
            mBuilder.startProperty();
            mTimeStartProperty += System.currentTimeMillis() - start;
        }
        try {
            ended = parseItem();
        } catch (VCardInvalidCommentLineException e) {
            Log.e(LOG_TAG, ""Invalid line which looks like some comment was found. Ignored."");
            ended = false;
        }
        if (mBuilder != null && !ended) {
            long start = System.currentTimeMillis();
            mBuilder.endProperty();
            mTimeEndProperty += System.currentTimeMillis() - start;
        }
    }
}",1,"/**
 * items = *CRLF item
 * / item
 */
","/**
 * items = *CRLF item
 * / item
 */
",-1,,,-1,-1,-1,-1,-1,-1,0,0,"There are no differences between the early version and the late version code, hence no code change was made.","Since there are no changes in the code implementation, no compatibility issue exists."
20,<android.widget.FrameLayout: LayoutParams generateDefaultLayoutParams()>,7,8,<android.widget.FrameLayout: LayoutParams generateDefaultLayoutParams()>,<android.widget.FrameLayout: LayoutParams generateDefaultLayoutParams()>,0,"{
    return new LayoutParams(LayoutParams.FILL_PARENT, LayoutParams.FILL_PARENT);
}","{
    return new LayoutParams(LayoutParams.MATCH_PARENT, LayoutParams.MATCH_PARENT);
}",1,"/**
 * Returns a set of layout parameters with a width of
 * {@link android.view.ViewGroup.LayoutParams#FILL_PARENT},
 * and a height of {@link android.view.ViewGroup.LayoutParams#FILL_PARENT}.
 */
","/**
 * Returns a set of layout parameters with a width of
 * {@link android.view.ViewGroup.LayoutParams#MATCH_PARENT},
 * and a height of {@link android.view.ViewGroup.LayoutParams#MATCH_PARENT}.
 */
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,1,1,"The return statement changed from new LayoutParams(LayoutParams.FILL_PARENT, LayoutParams.FILL_PARENT) in the early version to new LayoutParams(LayoutParams.MATCH_PARENT, LayoutParams.MATCH_PARENT) in the late version. Therefore, the type of the code change is 1.","Given the return statement change, this can lead to potential different return types between versions. Thus, this change can cause a compatibility issue categorized as type 1."
21,<android.server.BluetoothA2dpService: boolean connectSink(BluetoothDevice)>,7,8,<android.server.BluetoothA2dpService: boolean connectSink(BluetoothDevice)>,<android.server.BluetoothA2dpService: boolean connectSink(BluetoothDevice)>,0,"{
    mContext.enforceCallingOrSelfPermission(BLUETOOTH_ADMIN_PERM, ""Need BLUETOOTH_ADMIN permission"");
    if (DBG)
        log(""connectSink("" + device + "")"");
    // ignore if there are any active sinks
    if (lookupSinksMatchingStates(new int[] { BluetoothA2dp.STATE_CONNECTING, BluetoothA2dp.STATE_CONNECTED, BluetoothA2dp.STATE_PLAYING, BluetoothA2dp.STATE_DISCONNECTING }).size() != 0) {
        return false;
    }
    if (mAudioDevices.get(device) == null && !addAudioSink(device))
        return false;
    int state = mAudioDevices.get(device);
    switch(state) {
        case BluetoothA2dp.STATE_CONNECTED:
        case BluetoothA2dp.STATE_PLAYING:
        case BluetoothA2dp.STATE_DISCONNECTING:
            return false;
        case BluetoothA2dp.STATE_CONNECTING:
            return true;
    }
    String path = mBluetoothService.getObjectPathFromAddress(device.getAddress());
    if (path == null)
        return false;
    // State is DISCONNECTED
    if (!connectSinkNative(path)) {
        return false;
    }
    return true;
}","{
    mContext.enforceCallingOrSelfPermission(BLUETOOTH_ADMIN_PERM, ""Need BLUETOOTH_ADMIN permission"");
    if (DBG)
        log(""connectSink("" + device + "")"");
    if (!mBluetoothService.isEnabled())
        return false;
    // ignore if there are any active sinks
    if (lookupSinksMatchingStates(new int[] { BluetoothA2dp.STATE_CONNECTING, BluetoothA2dp.STATE_CONNECTED, BluetoothA2dp.STATE_PLAYING, BluetoothA2dp.STATE_DISCONNECTING }).size() != 0) {
        return false;
    }
    if (mAudioDevices.get(device) == null && !addAudioSink(device))
        return false;
    int state = mAudioDevices.get(device);
    switch(state) {
        case BluetoothA2dp.STATE_CONNECTED:
        case BluetoothA2dp.STATE_PLAYING:
        case BluetoothA2dp.STATE_DISCONNECTING:
            return false;
        case BluetoothA2dp.STATE_CONNECTING:
            return true;
    }
    String path = mBluetoothService.getObjectPathFromAddress(device.getAddress());
    if (path == null)
        return false;
    // State is DISCONNECTED
    handleSinkStateChange(device, state, BluetoothA2dp.STATE_CONNECTING);
    if (!connectSinkNative(path)) {
        // Restore previous state
        handleSinkStateChange(device, mAudioDevices.get(device), state);
        return false;
    }
    return true;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"1,3,4",1,"A new 'if' statement is added (""if (!mBluetoothService.isEnabled()) return false;""), the 'connectSinkNative(path)' method is now embedded with extra error handling (handleSinkStateChange), and a new  method call ""handleSinkStateChange(device, state, BluetoothA2dp.STATE_CONNECTING);"" is introduced before connecting to sink, hence the change types are 1 (return statement has changed), 3 (control dependency has changed), and 4 (other statement has changed).","The newly added 'if' statement ""(if (!mBluetoothService.isEnabled()) return false;)"", could potentially introduce a different return value. Similarly, the enhanced error handling introduces a new return value for when connectSinkNative(path) fails. Therefore, CI type is 1+2 caused by changes in return value and exception handling."
24,<android.webkit.WebView: void clearMatches()>,7,8,<android.webkit.WebView: void clearMatches()>,<android.webkit.WebView: void clearMatches()>,0,"{
    if (mFindIsUp) {
        recordNewContentSize(mContentWidth, mContentHeight - mFindHeight, false);
        mFindIsUp = false;
    }
    nativeSetFindIsDown();
    // Now that the dialog has been removed, ensure that we scroll to a
    // location that is not beyond the end of the page.
    pinScrollTo(mScrollX, mScrollY, false, 0);
    invalidate();
}","{
    mLastFind = """";
    if (mNativeClass == 0)
        return;
    nativeSetFindIsEmpty();
    invalidate();
}",1,"/*
     * Clear the highlighting surrounding text matches created by findAll.
     */
","/*
     * Clear the highlighting surrounding text matches created by findAll.
     */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3,4",0,"The entire implementation method changes, including return statements, condition statements and other statements. Therefore, the change types include 1, 3, and 4.","Though the method has been completely rewritten, since this method does not return any values and does not throw any exceptions in both versions, no compatibility issue exists and the CI type is 0."
26,<android.view.Surface: String toString()>,7,8,<android.view.Surface: String toString()>,<android.view.Surface: String toString()>,0,"{
    return ""Surface(native-token="" + mSurfaceControl + "")"";
}","{
    return ""Surface(name="" + mName + "", identity="" + getIdentity() + "")"";
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,1,1,"The return statement has been changed from ""Surface(native-token="" + mSurfaceControl + "")"" to ""Surface(name="" + mName + "", identity="" + getIdentity() + "")"", which belongs to code change type 1.","Due to the change in the return statement, the API potentially returns a different value so the Compatibility Issue type is 1."
27,<android.webkit.LoadListener: void downloadFile()>,7,8,<android.webkit.LoadListener: void downloadFile()>,<android.webkit.LoadListener: void downloadFile()>,0,"{
    // Setting the Cache Result to null ensures that this
    // content is not added to the cache
    mCacheResult = null;
    // Inform the client that they should download a file
    mBrowserFrame.getCallbackProxy().onDownloadStart(url(), mBrowserFrame.getUserAgentString(), mHeaders.getContentDisposition(), mMimeType, mContentLength);
    // Cancel the download. We need to stop the http load.
    // The native loader object will get cleared by the call to
    // cancel() but will also be cleared on the WebCore side
    // when this function returns.
    cancel();
}","{
    // remove the cache
    WebViewWorker.getHandler().obtainMessage(WebViewWorker.MSG_REMOVE_CACHE, this).sendToTarget();
    // Inform the client that they should download a file
    mBrowserFrame.getCallbackProxy().onDownloadStart(url(), mBrowserFrame.getUserAgentString(), mHeaders.getContentDisposition(), mMimeType, mContentLength);
    // Cancel the download. We need to stop the http load.
    // The native loader object will get cleared by the call to
    // cancel() but will also be cleared on the WebCore side
    // when this function returns.
    cancel();
}",1,"/*
     * This function is called from native WebCore code to
     * notify this LoadListener that the content it is currently
     * downloading should be saved to a file and not sent to
     * WebCore.
     */
","/*
     * This function is called from native WebCore code to
     * notify this LoadListener that the content it is currently
     * downloading should be saved to a file and not sent to
     * WebCore.
     */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The way to remove the cache has been changed from 'mCacheResult = null;' to 'WebViewWorker.getHandler().obtainMessage(WebViewWorker.MSG_REMOVE_CACHE, this).sendToTarget();'. This change, while potentially altering the internal state of the object, does not effect the return value or exceptions thrown. The code change type is 4.","This change in implementation does not introduce any Compatibility Issues because it doesn't lead to any difference in returned values or handled exceptions. Hence, the CI type is 0."
28,<android.widget.GridView: int computeVerticalScrollOffset()>,7,8,<android.widget.GridView: int computeVerticalScrollOffset()>,<android.widget.GridView: int computeVerticalScrollOffset()>,0,"{
    if (mFirstPosition >= 0 && getChildCount() > 0) {
        final View view = getChildAt(0);
        final int top = view.getTop();
        int height = view.getHeight();
        if (height > 0) {
            final int whichRow = mFirstPosition / mNumColumns;
            return Math.max(whichRow * 100 - (top * 100) / height, 0);
        }
    }
    return 0;
}","{
    if (mFirstPosition >= 0 && getChildCount() > 0) {
        final View view = getChildAt(0);
        final int top = view.getTop();
        int height = view.getHeight();
        if (height > 0) {
            final int numColumns = mNumColumns;
            final int whichRow = mFirstPosition / numColumns;
            final int rowCount = (mItemCount + numColumns - 1) / numColumns;
            return Math.max(whichRow * 100 - (top * 100) / height + (int) ((float) mScrollY / getHeight() * rowCount * 100), 0);
        }
    }
    return 0;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,3",1,"The return statement has changed with an extra computation of return value introduced (mScrollY, getHeight(), rowCount). Also, the control dependency 'final int rowCount = (mItemCount + numColumns - 1) / numColumns;' has been introduced in the late version, so the code change type is 1,3.","Adding a new computation into a return statement will make the API potentially return a different value in different versions, so the CI type is 1."
29,"<android.webkit.WebViewDatabase: ArrayList<String> getFormData(String,String)>",7,8,"<android.webkit.WebViewDatabase: ArrayList<String> getFormData(String,String)>","<android.webkit.WebViewDatabase: ArrayList<String> getFormData(String,String)>",0,"{
    ArrayList<String> values = new ArrayList<String>();
    if (url == null || name == null || mDatabase == null) {
        return values;
    }
    final String urlSelection = ""("" + FORMURL_URL_COL + "" == ?)"";
    final String dataSelection = ""("" + FORMDATA_URLID_COL + "" == ?) AND ("" + FORMDATA_NAME_COL + "" == ?)"";
    synchronized (mFormLock) {
        Cursor cursor = mDatabase.query(mTableNames[TABLE_FORMURL_ID], ID_PROJECTION, urlSelection, new String[] { url }, null, null, null);
        if (cursor.moveToFirst()) {
            long urlid = cursor.getLong(cursor.getColumnIndex(ID_COL));
            Cursor dataCursor = mDatabase.query(mTableNames[TABLE_FORMDATA_ID], new String[] { ID_COL, FORMDATA_VALUE_COL }, dataSelection, new String[] { Long.toString(urlid), name }, null, null, null);
            if (dataCursor.moveToFirst()) {
                int valueCol = dataCursor.getColumnIndex(FORMDATA_VALUE_COL);
                do {
                    values.add(dataCursor.getString(valueCol));
                } while (dataCursor.moveToNext());
            }
            dataCursor.close();
        }
        cursor.close();
        return values;
    }
}","{
    ArrayList<String> values = new ArrayList<String>();
    if (url == null || name == null || mDatabase == null) {
        return values;
    }
    final String urlSelection = ""("" + FORMURL_URL_COL + "" == ?)"";
    final String dataSelection = ""("" + FORMDATA_URLID_COL + "" == ?) AND ("" + FORMDATA_NAME_COL + "" == ?)"";
    synchronized (mFormLock) {
        Cursor cursor = null;
        try {
            cursor = mDatabase.query(mTableNames[TABLE_FORMURL_ID], ID_PROJECTION, urlSelection, new String[] { url }, null, null, null);
            if (cursor.moveToFirst()) {
                long urlid = cursor.getLong(cursor.getColumnIndex(ID_COL));
                Cursor dataCursor = null;
                try {
                    dataCursor = mDatabase.query(mTableNames[TABLE_FORMDATA_ID], new String[] { ID_COL, FORMDATA_VALUE_COL }, dataSelection, new String[] { Long.toString(urlid), name }, null, null, null);
                    if (dataCursor.moveToFirst()) {
                        int valueCol = dataCursor.getColumnIndex(FORMDATA_VALUE_COL);
                        do {
                            values.add(dataCursor.getString(valueCol));
                        } while (dataCursor.moveToNext());
                    }
                } catch (IllegalStateException e) {
                    Log.e(LOGTAG, ""getFormData dataCursor"", e);
                } finally {
                    if (dataCursor != null)
                        dataCursor.close();
                }
            }
        } catch (IllegalStateException e) {
            Log.e(LOGTAG, ""getFormData cursor"", e);
        } finally {
            if (cursor != null)
                cursor.close();
        }
        return values;
    }
}",1,"/**
 * Get all the values for a form entry with ""name"" in a given site
 *
 * @param url The url of the site
 * @param name The name of the form entry
 * @return A list of values. Return empty list if nothing is found.
 */
","/**
 * Get all the values for a form entry with ""name"" in a given site
 *
 * @param url The url of the site
 * @param name The name of the form entry
 * @return A list of values. Return empty list if nothing is found.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,3",0,"The exception handling statements, specifically the catch blocks for IllegalStateException, have been introduced in the late version. Besides, the control flow has also changed slightly with the introduction of try-catch blocks and additional null check conditionals for 'cursor' and 'dataCursor' closing. Therefore, the code change type is 2,3.","Although the exception handling and control flow has changed, it wouldn't cause the API to return different values or throw different exceptions, as the new exception handling is for logging purpose and doesn't change the API behavior, and the control flow change doesn't impact the returned ArrayList 'values'. Hence, there's no Compatibility Issue existing."
30,<android.app.Activity: boolean dispatchPopulateAccessibilityEvent(AccessibilityEvent)>,7,8,<android.app.Activity: boolean dispatchPopulateAccessibilityEvent(AccessibilityEvent)>,<android.app.Activity: boolean dispatchPopulateAccessibilityEvent(AccessibilityEvent)>,0,"{
    event.setClassName(getClass().getName());
    event.setPackageName(getPackageName());
    LayoutParams params = getWindow().getAttributes();
    boolean isFullScreen = (params.width == LayoutParams.FILL_PARENT) && (params.height == LayoutParams.FILL_PARENT);
    event.setFullScreen(isFullScreen);
    CharSequence title = getTitle();
    if (!TextUtils.isEmpty(title)) {
        event.getText().add(title);
    }
    return true;
}","{
    event.setClassName(getClass().getName());
    event.setPackageName(getPackageName());
    LayoutParams params = getWindow().getAttributes();
    boolean isFullScreen = (params.width == LayoutParams.MATCH_PARENT) && (params.height == LayoutParams.MATCH_PARENT);
    event.setFullScreen(isFullScreen);
    CharSequence title = getTitle();
    if (!TextUtils.isEmpty(title)) {
        event.getText().add(title);
    }
    return true;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,4,0,"The constant `FILL_PARENT` was renamed to `MATCH_PARENT`. However, their values are the same (i.e., -1) that means the behaviour of the code doesn't change, so the code change type is 4.","The change in code will not cause different behaviors in terms of returned variable or thrown exceptions, so there is no compatibility issue. Hence, the CI type is 0."
32,<android.content.pm.ResolveInfo: Drawable loadIcon(PackageManager)>,7,8,<android.content.pm.ResolveInfo: Drawable loadIcon(PackageManager)>,<android.content.pm.ResolveInfo: Drawable loadIcon(PackageManager)>,0,"{
    ComponentInfo ci = activityInfo != null ? activityInfo : serviceInfo;
    ApplicationInfo ai = ci.applicationInfo;
    Drawable dr;
    if (resolvePackageName != null && icon != 0) {
        dr = pm.getDrawable(resolvePackageName, icon, null);
        if (dr != null) {
            return dr;
        }
    }
    if (icon != 0) {
        dr = pm.getDrawable(ci.packageName, icon, ai);
        if (dr != null) {
            return dr;
        }
    }
    return ci.loadIcon(pm);
}","{
    Drawable dr;
    if (resolvePackageName != null && icon != 0) {
        dr = pm.getDrawable(resolvePackageName, icon, null);
        if (dr != null) {
            return dr;
        }
    }
    ComponentInfo ci = activityInfo != null ? activityInfo : serviceInfo;
    ApplicationInfo ai = ci.applicationInfo;
    if (icon != 0) {
        dr = pm.getDrawable(ci.packageName, icon, ai);
        if (dr != null) {
            return dr;
        }
    }
    return ci.loadIcon(pm);
}",1,"/**
 * Retrieve the current graphical icon associated with this resolution.  This
 * will call back on the given PackageManager to load the icon from
 * the application.
 *
 * @param pm A PackageManager from which the icon can be loaded; usually
 * the PackageManager from which you originally retrieved this item.
 *
 * @return Returns a Drawable containing the resolution's icon.  If the
 * item does not have an icon, the default activity icon is returned.
 */
","/**
 * Retrieve the current graphical icon associated with this resolution.  This
 * will call back on the given PackageManager to load the icon from
 * the application.
 *
 * @param pm A PackageManager from which the icon can be loaded; usually
 * the PackageManager from which you originally retrieved this item.
 *
 * @return Returns a Drawable containing the resolution's icon.  If the
 * item does not have an icon, the default activity icon is returned.
 */
",-1,,,-1,-1,-1,-1,-1,-1,3,0,"The change between the given codes is the swapping order between a pair of statements. The assignment of ci and ai variables were done earlier in the early implementation, whereas it was done comparatively later in the late implementation, therefore the change type is 3.","There is no compatibility issue detected from the given code, as despite the sequence of operations changing, it does not alter the return values or exceptions thrown by the API. Therefore, the CI type is 0."
33,<android.webkit.CacheManager: boolean disableTransaction()>,7,8,<android.webkit.CacheManager: boolean disableTransaction()>,<android.webkit.CacheManager: boolean disableTransaction()>,0,"{
    if (mRefCount == 0) {
        Log.e(LOGTAG, ""disableTransaction is out of sync"");
    }
    if (--mRefCount == 0) {
        mDataBase.endCacheTransaction();
        return true;
    }
    return false;
}","{
    if (--mRefCount == 0) {
        mDataBase.endCacheTransaction();
        return true;
    }
    return false;
}",1,"// make sure to call enableTransaction/disableTransaction in pair
","// make sure to call enableTransaction/disableTransaction in pair
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",1,"The first if statement including its BODY disappeared (It logged an error message), so the change type is 3,4.","The deleted statement is a condition control and log output statement which will not change the returned value or exception handling. But the second IF statement that decides the returned value depends on the change of 'mRefCount' which is modified before it. Because this mechanism is changed by removing the first IF statement, the return value could be different. So, the CI type is 1."
34,<android.content.SyncManager.SyncHandler: void handleMessage(Message)>,7,8,<android.content.SyncManager.SyncHandler: void handleMessage(Message)>,<android.content.SyncManager.SyncHandler: void handleMessage(Message)>,0,"{
    try {
        waitUntilReadyToRun();
        switch(msg.what) {
            case SyncHandler.MESSAGE_SYNC_FINISHED:
                if (Log.isLoggable(TAG, Log.VERBOSE)) {
                    Log.v(TAG, ""handleSyncHandlerMessage: MESSAGE_SYNC_FINISHED"");
                }
                SyncHandlerMessagePayload payload = (SyncHandlerMessagePayload) msg.obj;
                if (mActiveSyncContext != payload.activeSyncContext) {
                    if (Config.LOGD) {
                        Log.d(TAG, ""handleSyncHandlerMessage: sync context doesn't match, "" + ""dropping: mActiveSyncContext "" + mActiveSyncContext + "" != "" + payload.activeSyncContext);
                    }
                    return;
                }
                runSyncFinishedOrCanceled(payload.syncResult);
                // since we are no longer syncing, check if it is time to start a new sync
                runStateIdle();
                break;
            case SyncHandler.MESSAGE_SERVICE_CONNECTED:
                {
                    ServiceConnectionData msgData = (ServiceConnectionData) msg.obj;
                    if (Log.isLoggable(TAG, Log.VERBOSE)) {
                        Log.d(TAG, ""handleSyncHandlerMessage: MESSAGE_SERVICE_CONNECTED: "" + msgData.activeSyncContext + "" active is "" + mActiveSyncContext);
                    }
                    // check that this isn't an old message
                    if (mActiveSyncContext == msgData.activeSyncContext) {
                        runBoundToSyncAdapter(msgData.syncAdapter);
                    }
                    break;
                }
            case SyncHandler.MESSAGE_SERVICE_DISCONNECTED:
                {
                    ServiceConnectionData msgData = (ServiceConnectionData) msg.obj;
                    if (Log.isLoggable(TAG, Log.VERBOSE)) {
                        Log.d(TAG, ""handleSyncHandlerMessage: MESSAGE_SERVICE_DISCONNECTED: "" + msgData.activeSyncContext + "" active is "" + mActiveSyncContext);
                    }
                    // check that this isn't an old message
                    if (mActiveSyncContext == msgData.activeSyncContext) {
                        // outstanding
                        if (mActiveSyncContext.mSyncAdapter != null) {
                            try {
                                mActiveSyncContext.mSyncAdapter.cancelSync(mActiveSyncContext);
                            } catch (RemoteException e) {
                            // we don't need to retry this in this case
                            }
                        }
                        // pretend that the sync failed with an IOException,
                        // which is a soft error
                        SyncResult syncResult = new SyncResult();
                        syncResult.stats.numIoExceptions++;
                        runSyncFinishedOrCanceled(syncResult);
                        // since we are no longer syncing, check if it is time to start a new
                        // sync
                        runStateIdle();
                    }
                    break;
                }
            case SyncHandler.MESSAGE_SYNC_ALARM:
                {
                    boolean isLoggable = Log.isLoggable(TAG, Log.VERBOSE);
                    if (isLoggable) {
                        Log.v(TAG, ""handleSyncHandlerMessage: MESSAGE_SYNC_ALARM"");
                    }
                    mAlarmScheduleTime = null;
                    try {
                        if (mActiveSyncContext != null) {
                            if (isLoggable) {
                                Log.v(TAG, ""handleSyncHandlerMessage: sync context is active"");
                            }
                            runStateSyncing();
                        }
                        // check if it is time to start a new sync
                        if (mActiveSyncContext == null) {
                            if (isLoggable) {
                                Log.v(TAG, ""handleSyncHandlerMessage: "" + ""sync context is not active"");
                            }
                            runStateIdle();
                        }
                    } finally {
                        mHandleAlarmWakeLock.release();
                    }
                    break;
                }
            case SyncHandler.MESSAGE_CHECK_ALARMS:
                if (Log.isLoggable(TAG, Log.VERBOSE)) {
                    Log.v(TAG, ""handleSyncHandlerMessage: MESSAGE_CHECK_ALARMS"");
                }
                // we do all the work for this case in the finally block
                break;
        }
    } finally {
        final boolean isSyncInProgress = mActiveSyncContext != null;
        if (!isSyncInProgress) {
            mSyncWakeLock.release();
        }
        manageSyncNotification();
        manageErrorNotification();
        manageSyncAlarm();
        mSyncTimeTracker.update();
    }
}","{
    Long earliestFuturePollTime = null;
    try {
        waitUntilReadyToRun();
        // Always do this first so that we be sure that any periodic syncs that
        // are ready to run have been converted into pending syncs. This allows the
        // logic that considers the next steps to take based on the set of pending syncs
        // to also take into account the periodic syncs.
        earliestFuturePollTime = scheduleReadyPeriodicSyncs();
        switch(msg.what) {
            case SyncHandler.MESSAGE_SYNC_FINISHED:
                if (Log.isLoggable(TAG, Log.VERBOSE)) {
                    Log.v(TAG, ""handleSyncHandlerMessage: MESSAGE_SYNC_FINISHED"");
                }
                SyncHandlerMessagePayload payload = (SyncHandlerMessagePayload) msg.obj;
                if (mActiveSyncContext != payload.activeSyncContext) {
                    Log.d(TAG, ""handleSyncHandlerMessage: sync context doesn't match, "" + ""dropping: mActiveSyncContext "" + mActiveSyncContext + "" != "" + payload.activeSyncContext);
                    return;
                }
                runSyncFinishedOrCanceled(payload.syncResult);
                // since we are no longer syncing, check if it is time to start a new sync
                runStateIdle();
                break;
            case SyncHandler.MESSAGE_SERVICE_CONNECTED:
                {
                    ServiceConnectionData msgData = (ServiceConnectionData) msg.obj;
                    if (Log.isLoggable(TAG, Log.VERBOSE)) {
                        Log.d(TAG, ""handleSyncHandlerMessage: MESSAGE_SERVICE_CONNECTED: "" + msgData.activeSyncContext + "" active is "" + mActiveSyncContext);
                    }
                    // check that this isn't an old message
                    if (mActiveSyncContext == msgData.activeSyncContext) {
                        runBoundToSyncAdapter(msgData.syncAdapter);
                    }
                    break;
                }
            case SyncHandler.MESSAGE_SERVICE_DISCONNECTED:
                {
                    ServiceConnectionData msgData = (ServiceConnectionData) msg.obj;
                    if (Log.isLoggable(TAG, Log.VERBOSE)) {
                        Log.d(TAG, ""handleSyncHandlerMessage: MESSAGE_SERVICE_DISCONNECTED: "" + msgData.activeSyncContext + "" active is "" + mActiveSyncContext);
                    }
                    // check that this isn't an old message
                    if (mActiveSyncContext == msgData.activeSyncContext) {
                        // outstanding
                        if (mActiveSyncContext.mSyncAdapter != null) {
                            try {
                                mActiveSyncContext.mSyncAdapter.cancelSync(mActiveSyncContext);
                            } catch (RemoteException e) {
                            // we don't need to retry this in this case
                            }
                        }
                        // pretend that the sync failed with an IOException,
                        // which is a soft error
                        SyncResult syncResult = new SyncResult();
                        syncResult.stats.numIoExceptions++;
                        runSyncFinishedOrCanceled(syncResult);
                        // since we are no longer syncing, check if it is time to start a new
                        // sync
                        runStateIdle();
                    }
                    break;
                }
            case SyncHandler.MESSAGE_SYNC_ALARM:
                {
                    boolean isLoggable = Log.isLoggable(TAG, Log.VERBOSE);
                    if (isLoggable) {
                        Log.v(TAG, ""handleSyncHandlerMessage: MESSAGE_SYNC_ALARM"");
                    }
                    mAlarmScheduleTime = null;
                    try {
                        if (mActiveSyncContext != null) {
                            if (isLoggable) {
                                Log.v(TAG, ""handleSyncHandlerMessage: sync context is active"");
                            }
                            runStateSyncing();
                        }
                        // check if it is time to start a new sync
                        if (mActiveSyncContext == null) {
                            if (isLoggable) {
                                Log.v(TAG, ""handleSyncHandlerMessage: "" + ""sync context is not active"");
                            }
                            runStateIdle();
                        }
                    } finally {
                        mHandleAlarmWakeLock.release();
                    }
                    break;
                }
            case SyncHandler.MESSAGE_CHECK_ALARMS:
                if (Log.isLoggable(TAG, Log.VERBOSE)) {
                    Log.v(TAG, ""handleSyncHandlerMessage: MESSAGE_CHECK_ALARMS"");
                }
                // we do all the work for this case in the finally block
                break;
        }
    } finally {
        final boolean isSyncInProgress = mActiveSyncContext != null;
        if (!isSyncInProgress) {
            mSyncWakeLock.release();
        }
        manageSyncNotification();
        manageErrorNotification();
        manageSyncAlarm(earliestFuturePollTime);
        mSyncTimeTracker.update();
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,4,0,"In the late implementation, a new method call 'scheduleReadyPeriodicSyncs()' is inserted which was not present in the early implementation. Also, a new value 'earliestFuturePollTime' is passed to 'manageSyncAlarm()', which is a little change from the earlier version where nothing was passed.",The new method 'scheduleReadyPeriodicSyncs()' doesn't change the return value of the API or any exceptional behaviour. No evident compatibility issue is found in this comparison.
35,<android.provider.Telephony.Mms: boolean isEmailAddress(String)>,7,8,<android.provider.Telephony.Mms: boolean isEmailAddress(String)>,<android.provider.Telephony.Mms: boolean isEmailAddress(String)>,0,"{
    if (TextUtils.isEmpty(address)) {
        return false;
    }
    String s = extractAddrSpec(address);
    Matcher match = Regex.EMAIL_ADDRESS_PATTERN.matcher(s);
    return match.matches();
}","{
    if (TextUtils.isEmpty(address)) {
        return false;
    }
    String s = extractAddrSpec(address);
    Matcher match = Patterns.EMAIL_ADDRESS.matcher(s);
    return match.matches();
}",1,"/**
 * Returns true if the address is an email address
 *
 * @param address the input address to be tested
 * @return true if address is an email address
 */
","/**
 * Returns true if the address is an email address
 *
 * @param address the input address to be tested
 * @return true if address is an email address
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,1,"The dependent method has changed from Regex.EMAIL_ADDRESS_PATTERN.matcher(s) to Patterns.EMAIL_ADDRESS.matcher(s), so the code change type is 5.","The API may potentially return a different value because the method used to match the email address has changed, so the CI type is 1."
36,<android.content.res.AssetManager: void finalize()>,7,8,<android.content.res.AssetManager: void finalize()>,<android.content.res.AssetManager: void finalize()>,0,"{
    destroy();
}","{
    try {
        if (DEBUG_REFS && mNumRefs != 0) {
            Log.w(TAG, ""AssetManager "" + this + "" finalized with non-zero refs: "" + mNumRefs);
            if (mRefStacks != null) {
                for (RuntimeException e : mRefStacks.values()) {
                    Log.w(TAG, ""Reference from here"", e);
                }
            }
        }
        destroy();
    } finally {
        super.finalize();
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"2,3,4",2,"The new implementation has added a try-finally block to explicitly call `super.finalize()` and new debug logging conditions inside the try block. This leads to changes in exception handling, control dependency and other statements. Therefore, the code change types are 2,3,4.","The new exception handling introduces a call to `super.finalize()`. Therefore, the method might throw different exceptions and leads to CI. The CI type is 2."
37,<android.database.sqlite.SQLiteQuery: String toString()>,7,8,<android.database.sqlite.SQLiteQuery: String toString()>,<android.database.sqlite.SQLiteQuery: String toString()>,0,"{
    return ""SQLiteQuery: "" + mQuery;
}","{
    return ""SQLiteQuery: "" + mSql;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,5",1,"The return statement change from ""SQLiteQuery: "" + mQuery to ""SQLiteQuery: "" + mSql and the field variable that concatenated to the string has changed from mQuery to mSql. Therefore, the change types are 1 and 5.","The return value potentially changes in the late version due to the change in the field variable from mQuery to mSql. Therefore, the CI type is 1."
38,"<android.provider.Settings.Secure: String getString(ContentResolver,String)>",7,8,"<android.provider.Settings.Secure: String getString(ContentResolver,String)>","<android.provider.Settings.Secure: String getString(ContentResolver,String)>",0,"{
    if (mNameValueCache == null) {
        mNameValueCache = new NameValueCache(SYS_PROP_SETTING_VERSION, CONTENT_URI);
    }
    return mNameValueCache.getString(resolver, name);
}","{
    if (sNameValueCache == null) {
        sNameValueCache = new NameValueCache(SYS_PROP_SETTING_VERSION, CONTENT_URI, CALL_METHOD_GET_SECURE);
    }
    return sNameValueCache.getString(resolver, name);
}",1,"/**
 * Look up a name in the database.
 * @param resolver to access the database with
 * @param name to look up in the table
 * @return the corresponding value, or null if not present
 */
","/**
 * Look up a name in the database.
 * @param resolver to access the database with
 * @param name to look up in the table
 * @return the corresponding value, or null if not present
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The name of the variable mNameValueCache has changed to sNameValueCache and the constructor of NameValueCache has added a third parameter CALL_METHOD_GET_SECURE. So the change type is 1,5.","The method sNameValueCache.getString(resolver, name) was executed depends on the object sNameValueCache which is initialized differently. This could potentially lead the method to return different values. So the CI type is 1."
39,"<android.provider.Browser: void updateVisitedHistory(ContentResolver,String,boolean)>",7,8,"<android.provider.Browser: void updateVisitedHistory(ContentResolver,String,boolean)>","<android.provider.Browser: void updateVisitedHistory(ContentResolver,String,boolean)>",0,"{
    long now = new Date().getTime();
    try {
        StringBuilder sb = new StringBuilder(BookmarkColumns.URL + "" = "");
        DatabaseUtils.appendEscapedSQLString(sb, url);
        Cursor c = cr.query(BOOKMARKS_URI, HISTORY_PROJECTION, sb.toString(), null, null);
        /* We should only get one answer that is exactly the same. */
        if (c.moveToFirst()) {
            ContentValues map = new ContentValues();
            if (real) {
                map.put(BookmarkColumns.VISITS, c.getInt(HISTORY_PROJECTION_VISITS_INDEX) + 1);
            }
            map.put(BookmarkColumns.DATE, now);
            cr.update(BOOKMARKS_URI, map, ""_id = "" + c.getInt(0), null);
        } else {
            truncateHistory(cr);
            ContentValues map = new ContentValues();
            map.put(BookmarkColumns.URL, url);
            map.put(BookmarkColumns.VISITS, real ? 1 : 0);
            map.put(BookmarkColumns.DATE, now);
            map.put(BookmarkColumns.BOOKMARK, 0);
            map.put(BookmarkColumns.TITLE, url);
            map.put(BookmarkColumns.CREATED, 0);
            cr.insert(BOOKMARKS_URI, map);
        }
        c.deactivate();
    } catch (IllegalStateException e) {
        return;
    }
}","{
    long now = new Date().getTime();
    Cursor c = null;
    try {
        c = getVisitedLike(cr, url);
        /* We should only get one answer that is exactly the same. */
        if (c.moveToFirst()) {
            ContentValues map = new ContentValues();
            if (real) {
                map.put(BookmarkColumns.VISITS, c.getInt(HISTORY_PROJECTION_VISITS_INDEX) + 1);
            } else {
                map.put(BookmarkColumns.USER_ENTERED, 1);
            }
            map.put(BookmarkColumns.DATE, now);
            String[] projection = new String[] { Integer.valueOf(c.getInt(0)).toString() };
            cr.update(BOOKMARKS_URI, map, ""_id = ?"", projection);
        } else {
            truncateHistory(cr);
            ContentValues map = new ContentValues();
            int visits;
            int user_entered;
            if (real) {
                visits = 1;
                user_entered = 0;
            } else {
                visits = 0;
                user_entered = 1;
            }
            map.put(BookmarkColumns.URL, url);
            map.put(BookmarkColumns.VISITS, visits);
            map.put(BookmarkColumns.DATE, now);
            map.put(BookmarkColumns.BOOKMARK, 0);
            map.put(BookmarkColumns.TITLE, url);
            map.put(BookmarkColumns.CREATED, 0);
            map.put(BookmarkColumns.USER_ENTERED, user_entered);
            cr.insert(BOOKMARKS_URI, map);
        }
    } catch (IllegalStateException e) {
        Log.e(LOGTAG, ""updateVisitedHistory"", e);
    } finally {
        if (c != null)
            c.close();
    }
}",1,"/**
 * Update the visited history to acknowledge that a site has been
 * visited.
 * Requires {@link android.Manifest.permission#READ_HISTORY_BOOKMARKS}
 * Requires {@link android.Manifest.permission#WRITE_HISTORY_BOOKMARKS}
 * @param cr   The ContentResolver used to access the database.
 * @param url  The site being visited.
 * @param real Whether this is an actual visit, and should be added to the
 * number of visits.
 */
","/**
 * Update the visited history to acknowledge that a site has been
 * visited.
 * Requires {@link android.Manifest.permission#READ_HISTORY_BOOKMARKS}
 * Requires {@link android.Manifest.permission#WRITE_HISTORY_BOOKMARKS}
 * @param cr   The ContentResolver used to access the database.
 * @param url  The site being visited.
 * @param real If true, this is an actual visit, and should add to the
 * number of visits.  If false, the user entered it manually.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,2,3,4,5","1,2","Changes include updated method used for querying history(getVisitedLike()), handling exceptions(Now logging instead of returning), control statements updated (more checks in else block of if statement) and other statements updated(Use of ContentValues and update methods). Therefore, the change types are 1,2,3,4,5.","These changes affect the behavior and hence, the return variables of the API. Also, the different mechanism for handling exceptions in the new version can affect the exception flow of the API. Hence, the Compatibility Issue type is 1,2."
40,<android.webkit.WebView.ScaleDetectorListener: boolean onScaleBegin(ScaleGestureDetector)>,7,8,<android.webkit.WebView.ScaleDetectorListener: boolean onScaleBegin(ScaleGestureDetector)>,<android.webkit.WebView.ScaleDetectorListener: boolean onScaleBegin(ScaleGestureDetector)>,0,"{
    // cancel the single touch handling
    cancelTouch();
    if (mZoomButtonsController.isVisible()) {
        mZoomButtonsController.setVisible(false);
    }
    // reset the zoom overview mode so that the page won't auto grow
    mInZoomOverview = false;
    // misplaced.
    if (inEditingMode() && nativeFocusCandidateIsPassword()) {
        mWebTextView.setInPassword(false);
    }
    return true;
}","{
    // cancel the single touch handling
    cancelTouch();
    dismissZoomControl();
    // reset the zoom overview mode so that the page won't auto grow
    mInZoomOverview = false;
    // misplaced.
    if (inEditingMode() && nativeFocusCandidateIsPassword()) {
        mWebTextView.setInPassword(false);
    }
    mViewManager.startZoom();
    return true;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"Some statements have been changed in the late version. The ""mZoomButtonsController.isVisible()"" and ""mZoomButtonsController.setVisible(false)"" calls have been replaced with ""dismissZoomControl()"", and ""mViewManager.startZoom()"" call is added. Therefore, it is type 4 and type 5 changes.","Though there are some changes in the implementation of the method, it does not lead to a different return value or throws an exception. Therefore, there is no compatibility issue."
41,"<android.app.SearchManager: void triggerSearch(String,ComponentName,Bundle)>",7,8,"<android.app.SearchManager: void triggerSearch(String,ComponentName,Bundle)>","<android.app.SearchManager: void triggerSearch(String,ComponentName,Bundle)>",0,"{
    if (mIdent == 0)
        throw new IllegalArgumentException(""Called from outside of an Activity context"");
    if (!mAssociatedPackage.equals(launchActivity.getPackageName())) {
        throw new IllegalArgumentException(""invoking app search on a different package "" + ""not associated with this search manager"");
    }
    if (query == null || TextUtils.getTrimmedLength(query) == 0) {
        Log.w(TAG, ""triggerSearch called with empty query, ignoring."");
        return;
    }
    try {
        mService.triggerSearch(query, launchActivity, appSearchData, mSearchManagerCallback, mIdent);
    } catch (RemoteException ex) {
        Log.e(TAG, ""triggerSearch() failed."", ex);
    }
}","{
    if (!mAssociatedPackage.equals(launchActivity.getPackageName())) {
        throw new IllegalArgumentException(""invoking app search on a different package "" + ""not associated with this search manager"");
    }
    if (query == null || TextUtils.getTrimmedLength(query) == 0) {
        Log.w(TAG, ""triggerSearch called with empty query, ignoring."");
        return;
    }
    startSearch(query, false, launchActivity, appSearchData, false);
    mSearchDialog.launchQuerySearch();
}",1,"/**
 * Similar to {@link #startSearch} but actually fires off the search query after invoking
 * the search dialog.  Made available for testing purposes.
 *
 * @param query The query to trigger.  If empty, request will be ignored.
 * @param launchActivity The ComponentName of the activity that has launched this search.
 * @param appSearchData An application can insert application-specific
 * context here, in order to improve quality or specificity of its own
 * searches.  This data will be returned with SEARCH intent(s).  Null if
 * no extra data is required.
 *
 * @see #startSearch
 */
","/**
 * Similar to {@link #startSearch} but actually fires off the search query after invoking
 * the search dialog.  Made available for testing purposes.
 *
 * @param query The query to trigger.  If empty, request will be ignored.
 * @param launchActivity The ComponentName of the activity that has launched this search.
 * @param appSearchData An application can insert application-specific
 * context here, in order to improve quality or specificity of its own
 * searches.  This data will be returned with SEARCH intent(s).  Null if
 * no extra data is required.
 *
 * @see #startSearch
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,4",1,There are two changes occured:,
42,<android.widget.PopupWindow: void dismiss()>,7,8,<android.widget.PopupWindow: void dismiss()>,<android.widget.PopupWindow: void dismiss()>,0,"{
    if (isShowing() && mPopupView != null) {
        unregisterForScrollChanged();
        mWindowManager.removeView(mPopupView);
        if (mPopupView != mContentView && mPopupView instanceof ViewGroup) {
            ((ViewGroup) mPopupView).removeView(mContentView);
        }
        mPopupView = null;
        mIsShowing = false;
        if (mOnDismissListener != null) {
            mOnDismissListener.onDismiss();
        }
    }
}","{
    if (isShowing() && mPopupView != null) {
        unregisterForScrollChanged();
        try {
            mWindowManager.removeView(mPopupView);
        } finally {
            if (mPopupView != mContentView && mPopupView instanceof ViewGroup) {
                ((ViewGroup) mPopupView).removeView(mContentView);
            }
            mPopupView = null;
            mIsShowing = false;
            if (mOnDismissListener != null) {
                mOnDismissListener.onDismiss();
            }
        }
    }
}",1,"/**
 * <p>Dispose of the popup window. This method can be invoked only after
 * {@link #showAsDropDown(android.view.View)} has been executed. Failing that, calling
 * this method will have no effect.</p>
 *
 * @see #showAsDropDown(android.view.View)
 */
","/**
 * <p>Dispose of the popup window. This method can be invoked only after
 * {@link #showAsDropDown(android.view.View)} has been executed. Failing that, calling
 * this method will have no effect.</p>
 *
 * @see #showAsDropDown(android.view.View)
 */
",-1,,,-1,-1,-1,-1,-1,-1,3,0,"The difference between early and late implementations lies within the 'try' and 'finally' statements that have been added in the late version. This means the control dependency has changed, so the change type is 3.","Despite the introduction of the 'try' and 'finally' block, the logic of the method stays the same, with the final expected result unaffected by the change. Thus, no compatibility issues are identified. The CI type is 0."
43,"<android.text.method.PasswordTransformationMethod: CharSequence getTransformation(CharSequence,View)>",7,8,"<android.text.method.PasswordTransformationMethod: CharSequence getTransformation(CharSequence,View)>","<android.text.method.PasswordTransformationMethod: CharSequence getTransformation(CharSequence,View)>",0,"{
    if (source instanceof Spannable) {
        Spannable sp = (Spannable) source;
        /*
             * Remove any references to other views that may still be
             * attached.  This will happen when you flip the screen
             * while a password field is showing; there will still
             * be references to the old EditText in the text.
             */
        ViewReference[] vr = sp.getSpans(0, sp.length(), ViewReference.class);
        for (int i = 0; i < vr.length; i++) {
            sp.removeSpan(vr[i]);
        }
        sp.setSpan(new ViewReference(view), 0, 0, Spannable.SPAN_POINT_POINT);
    }
    return new PasswordCharSequence(source);
}","{
    if (source instanceof Spannable) {
        Spannable sp = (Spannable) source;
        /*
             * Remove any references to other views that may still be
             * attached.  This will happen when you flip the screen
             * while a password field is showing; there will still
             * be references to the old EditText in the text.
             */
        ViewReference[] vr = sp.getSpans(0, sp.length(), ViewReference.class);
        for (int i = 0; i < vr.length; i++) {
            sp.removeSpan(vr[i]);
        }
        removeVisibleSpans(sp);
        sp.setSpan(new ViewReference(view), 0, 0, Spannable.SPAN_POINT_POINT);
    }
    return new PasswordCharSequence(source);
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,4,1,"The change is within a control statement, but it is not a control dependency change. A new statement removeVisibleSpans(sp) is introduced, so the code change type is 4.","Even though the returned type and value are the same, the change in the source associated with the password characters sequence could lead to potentially different behaviors in the late version. Thus, the CI type is 1."
45,<android.widget.GridView: int findMotionRow(int)>,7,8,<android.widget.GridView: int findMotionRow(int)>,<android.widget.GridView: int findMotionRow(int)>,0,"{
    final int childCount = getChildCount();
    if (childCount > 0) {
        final int numColumns = mNumColumns;
        if (!mStackFromBottom) {
            for (int i = 0; i < childCount; i += numColumns) {
                if (y <= getChildAt(i).getBottom()) {
                    return mFirstPosition + i;
                }
            }
        } else {
            for (int i = childCount - 1; i >= 0; i -= numColumns) {
                if (y >= getChildAt(i).getTop()) {
                    return mFirstPosition + i;
                }
            }
        }
        return mFirstPosition + childCount - 1;
    }
    return INVALID_POSITION;
}","{
    final int childCount = getChildCount();
    if (childCount > 0) {
        final int numColumns = mNumColumns;
        if (!mStackFromBottom) {
            for (int i = 0; i < childCount; i += numColumns) {
                if (y <= getChildAt(i).getBottom()) {
                    return mFirstPosition + i;
                }
            }
        } else {
            for (int i = childCount - 1; i >= 0; i -= numColumns) {
                if (y >= getChildAt(i).getTop()) {
                    return mFirstPosition + i;
                }
            }
        }
    }
    return INVALID_POSITION;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,0,0,There is no code change between the early version and the late version.,"As there is no change in the code, no compatibility issue exists in the two versions."
46,<android.database.sqlite.SQLiteDatabase: void setTransactionSuccessful()>,7,8,<android.database.sqlite.SQLiteDatabase: void setTransactionSuccessful()>,<android.database.sqlite.SQLiteDatabase: void setTransactionSuccessful()>,0,"{
    if (!mLock.isHeldByCurrentThread()) {
        throw new IllegalStateException(""no transaction pending"");
    }
    if (mInnerTransactionIsSuccessful) {
        throw new IllegalStateException(""setTransactionSuccessful may only be called once per call to beginTransaction"");
    }
    mInnerTransactionIsSuccessful = true;
}","{
    if (!isOpen()) {
        throw new IllegalStateException(""database not open"");
    }
    if (!mLock.isHeldByCurrentThread()) {
        throw new IllegalStateException(""no transaction pending"");
    }
    if (mInnerTransactionIsSuccessful) {
        throw new IllegalStateException(""setTransactionSuccessful may only be called once per call to beginTransaction"");
    }
    mInnerTransactionIsSuccessful = true;
}",1,"/**
 * Marks the current transaction as successful. Do not do any more database work between
 * calling this and calling endTransaction. Do as little non-database work as possible in that
 * situation too. If any errors are encountered between this and endTransaction the transaction
 * will still be committed.
 *
 * @throws IllegalStateException if the current thread is not in a transaction or the
 * transaction is already marked as successful.
 */
","/**
 * Marks the current transaction as successful. Do not do any more database work between
 * calling this and calling endTransaction. Do as little non-database work as possible in that
 * situation too. If any errors are encountered between this and endTransaction the transaction
 * will still be committed.
 *
 * @throws IllegalStateException if the current thread is not in a transaction or the
 * transaction is already marked as successful.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,3",2,"The early version of the method did not check if the database is open first. The late version adds a new `if` statement that throws an IllegalStateException if the database is not open. Because of the order of the checks, the behaviour could be different depending on whether the database is open or not.","The addition of the initial `if` statement might make the late version of the method throw a IllegalStateException under a condition (database not open) that would not lead to an exception in the early version. Thus, the change can potentially cause the API to throw a different exception."
47,<android.widget.ExpandableListView: long getExpandableListPosition(int)>,7,8,<android.widget.ExpandableListView: long getExpandableListPosition(int)>,<android.widget.ExpandableListView: long getExpandableListPosition(int)>,0,"{
    PositionMetadata pm = mConnector.getUnflattenedPos(flatListPosition);
    long packedPos = pm.position.getPackedPosition();
    pm.recycle();
    return packedPos;
}","{
    if (isHeaderOrFooterPosition(flatListPosition)) {
        return PACKED_POSITION_VALUE_NULL;
    }
    final int adjustedPosition = getFlatPositionForConnector(flatListPosition);
    PositionMetadata pm = mConnector.getUnflattenedPos(adjustedPosition);
    long packedPos = pm.position.getPackedPosition();
    pm.recycle();
    return packedPos;
}",1,"/**
 * Converts a flat list position (the raw position of an item (child or
 * group) in the list) to an group and/or child position (represented in a
 * packed position). This is useful in situations where the caller needs to
 * use the underlying {@link ListView}'s methods. Use
 * {@link ExpandableListView#getPackedPositionType} ,
 * {@link ExpandableListView#getPackedPositionChild},
 * {@link ExpandableListView#getPackedPositionGroup} to unpack.
 *
 * @param flatListPosition The flat list position to be converted.
 * @return The group and/or child position for the given flat list position
 * in packed position representation.
 */
","/**
 * Converts a flat list position (the raw position of an item (child or group)
 * in the list) to an group and/or child position (represented in a
 * packed position). This is useful in situations where the caller needs to
 * use the underlying {@link ListView}'s methods. Use
 * {@link ExpandableListView#getPackedPositionType} ,
 * {@link ExpandableListView#getPackedPositionChild},
 * {@link ExpandableListView#getPackedPositionGroup} to unpack.
 *
 * @param flatListPosition The flat list position to be converted.
 * @return The group and/or child position for the given flat list position
 * in packed position representation. #PACKED_POSITION_VALUE_NULL if
 * the position corresponds to a header or a footer item.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3",1,"In the earlier version method operation 'PACKED_POSITION_VALUE_NULL' is not existing. Nevertheless, the later version has introduced the 'if' control statement and the 'PACKED_POSITION_VALUE_NULL' return statement, signalling that there is a potentially different return of the modified API. Furthermore, there is a change in control dependency due to the introduction of the 'if' control statement. Thus, the change type is 1,3.","The new 'if' control statement can potentially affect the return results of the API, which could differ from the earlier version, especially when 'isHeaderOrFooterPosition(flatListPosition)' returns true. Hence, the CI type is 1."
49,<android.accounts.AccountManager: AccountManager get(Context)>,7,8,<android.accounts.AccountManager: AccountManager get(Context)>,<android.accounts.AccountManager: AccountManager get(Context)>,0,"{
    return (AccountManager) context.getSystemService(Context.ACCOUNT_SERVICE);
}","{
    if (context == null)
        throw new IllegalArgumentException(""context is null"");
    return (AccountManager) context.getSystemService(Context.ACCOUNT_SERVICE);
}",1,"/**
 * Retrieve an AccountManager instance that is associated with the context that is passed in.
 * Certain calls such as {@link #addOnAccountsUpdatedListener} use this context internally,
 * so the caller must take care to use a {@link Context} whose lifetime is associated with
 * the listener registration.
 * @param context The {@link Context} to use when necessary
 * @return an {@link AccountManager} instance that is associated with context
 */
","/**
 * Gets an AccountManager instance associated with a Context.
 * The {@link Context} will be used as long as the AccountManager is
 * active, so make sure to use a {@link Context} whose lifetime is
 * commensurate with any listeners registered to
 * {@link #addOnAccountsUpdatedListener} or similar methods.
 *
 * <p>It is safe to call this method from the main thread.
 *
 * <p>No permission is required to call this method.
 *
 * @param context The {@link Context} to use when necessary
 * @return An {@link AccountManager} instance
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,2",2,"An 'if' statement has been added and a new exception handling statement has been introduced (throw new IllegalArgumentException(""context is null"")), so the change type is 3,2.","In the previous version, when 'context' is null, it will not throw an exception, but in the late version, it will throw an IllegalArgumentException. The beahviour of throwing exceptions can be different in the late version and thereby it can cause a compatibility issue, so the CI type is 2."
51,<android.pim.vcard.VCardParser_V30: String maybeUnescapeCharacter(char)>,7,8,<android.pim.vcard.VCardParser_V30: String maybeUnescapeCharacter(char)>,<android.pim.vcard.VCardParser_V30: String maybeUnescapeCharacter(char)>,0,"{
    if (ch == 'n' || ch == 'N') {
        return ""\n"";
    } else {
        return String.valueOf(ch);
    }
}","{
    return unescapeCharacter(ch);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,5",1,"In the early version, the API acts based on 'if' statements and returns either ""\n"" or the char itself, while in the newer version it is calling the new method unescapeCharacter(ch). Change types are 1,5.","Since the method used to handle the character has been changed, the return value may potentially change when called. Therefore, the CI type is 1."
53,<android.widget.QuickContactBadge: void onClick(View)>,7,8,<android.widget.QuickContactBadge: void onClick(View)>,<android.widget.QuickContactBadge: void onClick(View)>,0,"{
    if (mContactUri != null) {
        final ContentResolver resolver = getContext().getContentResolver();
        final Uri lookupUri = Contacts.getLookupUri(resolver, mContactUri);
        trigger(lookupUri);
    } else if (mContactEmail != null) {
        mQueryHandler.startQuery(TOKEN_EMAIL_LOOKUP_AND_TRIGGER, mContactEmail, Uri.withAppendedPath(Email.CONTENT_LOOKUP_URI, Uri.encode(mContactEmail)), EMAIL_LOOKUP_PROJECTION, null, null, null);
    } else if (mContactPhone != null) {
        mQueryHandler.startQuery(TOKEN_PHONE_LOOKUP_AND_TRIGGER, mContactPhone, Uri.withAppendedPath(PhoneLookup.CONTENT_FILTER_URI, mContactPhone), PHONE_LOOKUP_PROJECTION, null, null, null);
    } else {
        // If a contact hasn't been assigned, don't react to click.
        return;
    }
}","{
    if (mContactUri != null) {
        mQueryHandler.startQuery(TOKEN_CONTACT_LOOKUP_AND_TRIGGER, null, mContactUri, CONTACT_LOOKUP_PROJECTION, null, null, null);
    } else if (mContactEmail != null) {
        mQueryHandler.startQuery(TOKEN_EMAIL_LOOKUP_AND_TRIGGER, mContactEmail, Uri.withAppendedPath(Email.CONTENT_LOOKUP_URI, Uri.encode(mContactEmail)), EMAIL_LOOKUP_PROJECTION, null, null, null);
    } else if (mContactPhone != null) {
        mQueryHandler.startQuery(TOKEN_PHONE_LOOKUP_AND_TRIGGER, mContactPhone, Uri.withAppendedPath(PhoneLookup.CONTENT_FILTER_URI, mContactPhone), PHONE_LOOKUP_PROJECTION, null, null, null);
    } else {
        // If a contact hasn't been assigned, don't react to click.
        return;
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"3,4",0,The operations within the 'if (mContactUri != null) {}' block have changed from interacting with a `lookupUri` variable to calling `mQueryHandler.startQuery()`. This reflects a change in the control dependency logic (change type 3) and an alteration of statements within the block (change type 4).,"Though changes were made in the method logic, they do not lead to any compatibility issue as the return type or exception throwing behavior of the function does not change between versions. Thus, the CI type is 0."
54,"<android.app.ActivityThread.PackageInfo.ReceiverDispatcher: void performReceive(Intent,int,String,Bundle,boolean,boolean)>",7,8,"<android.app.ActivityThread.PackageInfo.ReceiverDispatcher: void performReceive(Intent,int,String,Bundle,boolean,boolean)>","<android.app.ActivityThread.PackageInfo.ReceiverDispatcher: void performReceive(Intent,int,String,Bundle,boolean,boolean)>",0,"{
    if (DEBUG_BROADCAST) {
        int seq = intent.getIntExtra(""seq"", -1);
        Log.i(TAG, ""Enqueueing broadcast "" + intent.getAction() + "" seq="" + seq + "" to "" + mReceiver);
    }
    Args args = new Args();
    args.mCurIntent = intent;
    args.mCurCode = resultCode;
    args.mCurData = data;
    args.mCurMap = extras;
    args.mCurOrdered = ordered;
    args.mCurSticky = sticky;
    if (!mActivityThread.post(args)) {
        if (mRegistered) {
            IActivityManager mgr = ActivityManagerNative.getDefault();
            try {
                mgr.finishReceiver(mIIntentReceiver, args.mCurCode, args.mCurData, args.mCurMap, false);
            } catch (RemoteException ex) {
            }
        }
    }
}","{
    if (DEBUG_BROADCAST) {
        int seq = intent.getIntExtra(""seq"", -1);
        Slog.i(TAG, ""Enqueueing broadcast "" + intent.getAction() + "" seq="" + seq + "" to "" + mReceiver);
    }
    Args args = new Args();
    args.mCurIntent = intent;
    args.mCurCode = resultCode;
    args.mCurData = data;
    args.mCurMap = extras;
    args.mCurOrdered = ordered;
    args.mCurSticky = sticky;
    if (!mActivityThread.post(args)) {
        if (mRegistered && ordered) {
            IActivityManager mgr = ActivityManagerNative.getDefault();
            try {
                if (DEBUG_BROADCAST)
                    Slog.i(TAG, ""Finishing sync broadcast to "" + mReceiver);
                mgr.finishReceiver(mIIntentReceiver, args.mCurCode, args.mCurData, args.mCurMap, false);
            } catch (RemoteException ex) {
            }
        }
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"3, 4",0,"In the 'if' condition statement, an additional condition 'ordered' is added, which qualifies the code change as control dependency change (type 3). Also, an extra logging statement was introduced under another 'if' condition (DEBUG_BROADCAST) which is an other statement change (type 4). ","The additional 'if' condition and logging statement do not affect the return value or the exceptions that the method might throw. Therefore, there's no compatibility issue (type 0)."
55,<android.webkit.WebView: int computeHorizontalScrollRange()>,7,8,<android.webkit.WebView: int computeHorizontalScrollRange()>,<android.webkit.WebView: int computeHorizontalScrollRange()>,0,"{
    if (mDrawHistory) {
        return mHistoryWidth;
    } else {
        // to avoid rounding error caused unnecessary scrollbar, use floor
        return (int) Math.floor(mContentWidth * mActualScale);
    }
}","{
    if (mDrawHistory) {
        return mHistoryWidth;
    } else if (mHorizontalScrollBarMode == SCROLLBAR_ALWAYSOFF && (mActualScale - mMinZoomScale <= MINIMUM_SCALE_INCREMENT)) {
        // only honor the scrollbar mode when it is at minimum zoom level
        return computeHorizontalScrollExtent();
    } else {
        // to avoid rounding error caused unnecessary scrollbar, use floor
        return (int) Math.floor(mContentWidth * mActualScale);
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,3,1,"The control condition in 'else if' statement is newly added in the late version, so the code change type is 3.","The newly added conditional statement could lead to a different return value under certain scenarios in the late version API. Therefore, the CI type is 1."
56,"<android.accounts.AccountManagerService.SimWatcher: void onReceive(Context,Intent)>",7,8,"<android.accounts.AccountManagerService.SimWatcher: void onReceive(Context,Intent)>","<android.accounts.AccountManagerService.SimWatcher: void onReceive(Context,Intent)>",0,"{
    // Check IMSI on every update; nothing happens if the IMSI is missing or unchanged.
    String imsi = ((TelephonyManager) context.getSystemService(Context.TELEPHONY_SERVICE)).getSubscriberId();
    if (TextUtils.isEmpty(imsi))
        return;
    String storedImsi = getMetaValue(""imsi"");
    if (Log.isLoggable(TAG, Log.VERBOSE)) {
        Log.v(TAG, ""current IMSI="" + imsi + ""; stored IMSI="" + storedImsi);
    }
    if (!imsi.equals(storedImsi) && !TextUtils.isEmpty(storedImsi)) {
        Log.w(TAG, ""wiping all passwords and authtokens because IMSI changed ("" + ""stored="" + storedImsi + "", current="" + imsi + "")"");
        SQLiteDatabase db = mOpenHelper.getWritableDatabase();
        db.beginTransaction();
        try {
            db.execSQL(""DELETE from "" + TABLE_AUTHTOKENS);
            db.execSQL(""UPDATE "" + TABLE_ACCOUNTS + "" SET "" + ACCOUNTS_PASSWORD + "" = ''"");
            sendAccountsChangedBroadcast();
            db.setTransactionSuccessful();
        } finally {
            db.endTransaction();
        }
    }
    setMetaValue(""imsi"", imsi);
}","{
    // Check IMSI on every update; nothing happens if the IMSI
    // is missing or unchanged.
    TelephonyManager telephonyManager = (TelephonyManager) context.getSystemService(Context.TELEPHONY_SERVICE);
    if (telephonyManager == null) {
        Log.w(TAG, ""failed to get TelephonyManager"");
        return;
    }
    String imsi = telephonyManager.getSubscriberId();
    // If the subscriber ID is an empty string, don't do anything.
    if (TextUtils.isEmpty(imsi))
        return;
    // If the current IMSI matches what's stored, don't do anything.
    String storedImsi = getMetaValue(""imsi"");
    if (Log.isLoggable(TAG, Log.VERBOSE)) {
        Log.v(TAG, ""current IMSI="" + imsi + ""; stored IMSI="" + storedImsi);
    }
    if (imsi.equals(storedImsi))
        return;
    // subscriber ID once it's provisioned.
    if (telephonyManager.getPhoneType() == TelephonyManager.PHONE_TYPE_CDMA) {
        IBinder service = ServiceManager.checkService(Context.TELEPHONY_SERVICE);
        if (service == null) {
            Log.w(TAG, ""call to checkService(TELEPHONY_SERVICE) failed"");
            return;
        }
        ITelephony telephony = ITelephony.Stub.asInterface(service);
        if (telephony == null) {
            Log.w(TAG, ""failed to get ITelephony interface"");
            return;
        }
        boolean needsProvisioning;
        try {
            needsProvisioning = telephony.getCdmaNeedsProvisioning();
        } catch (RemoteException e) {
            Log.w(TAG, ""exception while checking provisioning"", e);
            // default to NOT wiping out the passwords
            needsProvisioning = true;
        }
        if (needsProvisioning) {
            // if the phone needs re-provisioning, don't do anything.
            if (Log.isLoggable(TAG, Log.VERBOSE)) {
                Log.v(TAG, ""current IMSI="" + imsi + "" (needs provisioning); stored IMSI="" + storedImsi);
            }
            return;
        }
    }
    if (!imsi.equals(storedImsi) && !TextUtils.isEmpty(storedImsi)) {
        Log.w(TAG, ""wiping all passwords and authtokens because IMSI changed ("" + ""stored="" + storedImsi + "", current="" + imsi + "")"");
        SQLiteDatabase db = mOpenHelper.getWritableDatabase();
        db.beginTransaction();
        try {
            db.execSQL(""DELETE from "" + TABLE_AUTHTOKENS);
            db.execSQL(""UPDATE "" + TABLE_ACCOUNTS + "" SET "" + ACCOUNTS_PASSWORD + "" = ''"");
            sendAccountsChangedBroadcast();
            db.setTransactionSuccessful();
        } finally {
            db.endTransaction();
        }
    }
    setMetaValue(""imsi"", imsi);
}",1,"/**
 * Compare the IMSI to the one stored in the login service's
 * database.  If they differ, erase all passwords and
 * authtokens (and store the new IMSI).
 */
","/**
 * Compare the IMSI to the one stored in the login service's
 * database.  If they differ, erase all passwords and
 * authtokens (and store the new IMSI).
 */
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,3,4","1,2","The late implementation introduces several return statements, changes the way to get `imsi` and introduces new dependency on `ITelephony`. It also modifies the logic check for `imsi`. Therefore, the code change type is 1,3,4.","The changes in the code may lead the method to return different values, as the amount and position of return statements have been changed. Also, the changes modify the exception handling by introducing new exceptions through newly depended API `ITelephony`. Therefore, the CI types are 1,2."
57,<android.widget.AbsListView: boolean onTouchEvent(MotionEvent)>,7,8,<android.widget.AbsListView: boolean onTouchEvent(MotionEvent)>,<android.widget.AbsListView: boolean onTouchEvent(MotionEvent)>,0,"{
    if (!isEnabled()) {
        // events, it just doesn't respond to them.
        return isClickable() || isLongClickable();
    }
    if (mFastScroller != null) {
        boolean intercepted = mFastScroller.onTouchEvent(ev);
        if (intercepted) {
            return true;
        }
    }
    final int action = ev.getAction();
    final int x = (int) ev.getX();
    final int y = (int) ev.getY();
    View v;
    int deltaY;
    if (mVelocityTracker == null) {
        mVelocityTracker = VelocityTracker.obtain();
    }
    mVelocityTracker.addMovement(ev);
    switch(action) {
        case MotionEvent.ACTION_DOWN:
            {
                int motionPosition = pointToPosition(x, y);
                if (!mDataChanged) {
                    if ((mTouchMode != TOUCH_MODE_FLING) && (motionPosition >= 0) && (getAdapter().isEnabled(motionPosition))) {
                        // User clicked on an actual view (and was not stopping a fling). It might be a
                        // click or a scroll. Assume it is a click until proven otherwise
                        mTouchMode = TOUCH_MODE_DOWN;
                        // FIXME Debounce
                        if (mPendingCheckForTap == null) {
                            mPendingCheckForTap = new CheckForTap();
                        }
                        postDelayed(mPendingCheckForTap, ViewConfiguration.getTapTimeout());
                    } else {
                        if (ev.getEdgeFlags() != 0 && motionPosition < 0) {
                            // code in ViewRoot to try to find a nearby view to select
                            return false;
                        }
                        // User clicked on whitespace, or stopped a fling. It is a scroll.
                        createScrollingCache();
                        mTouchMode = TOUCH_MODE_SCROLL;
                        mMotionCorrection = 0;
                        motionPosition = findMotionRow(y);
                        reportScrollStateChange(OnScrollListener.SCROLL_STATE_TOUCH_SCROLL);
                    }
                }
                if (motionPosition >= 0) {
                    // Remember where the motion event started
                    v = getChildAt(motionPosition - mFirstPosition);
                    mMotionViewOriginalTop = v.getTop();
                    mMotionX = x;
                    mMotionY = y;
                    mMotionPosition = motionPosition;
                }
                mLastY = Integer.MIN_VALUE;
                break;
            }
        case MotionEvent.ACTION_MOVE:
            {
                deltaY = y - mMotionY;
                switch(mTouchMode) {
                    case TOUCH_MODE_DOWN:
                    case TOUCH_MODE_TAP:
                    case TOUCH_MODE_DONE_WAITING:
                        // Check if we have moved far enough that it looks more like a
                        // scroll than a tap
                        startScrollIfNeeded(deltaY);
                        break;
                    case TOUCH_MODE_SCROLL:
                        if (PROFILE_SCROLLING) {
                            if (!mScrollProfilingStarted) {
                                Debug.startMethodTracing(""AbsListViewScroll"");
                                mScrollProfilingStarted = true;
                            }
                        }
                        if (y != mLastY) {
                            deltaY -= mMotionCorrection;
                            int incrementalDeltaY = mLastY != Integer.MIN_VALUE ? y - mLastY : deltaY;
                            // No need to do all this work if we're not going to move anyway
                            if (incrementalDeltaY != 0) {
                                trackMotionScroll(deltaY, incrementalDeltaY);
                            }
                            // Check to see if we have bumped into the scroll limit
                            View motionView = this.getChildAt(mMotionPosition - mFirstPosition);
                            if (motionView != null) {
                                // supposed to be
                                if (motionView.getTop() != mMotionViewNewTop) {
                                    // We did not scroll the full amount. Treat this essentially like the
                                    // start of a new touch scroll
                                    final int motionPosition = findMotionRow(y);
                                    mMotionCorrection = 0;
                                    motionView = getChildAt(motionPosition - mFirstPosition);
                                    mMotionViewOriginalTop = motionView.getTop();
                                    mMotionY = y;
                                    mMotionPosition = motionPosition;
                                }
                            }
                            mLastY = y;
                        }
                        break;
                }
                break;
            }
        case MotionEvent.ACTION_UP:
            {
                switch(mTouchMode) {
                    case TOUCH_MODE_DOWN:
                    case TOUCH_MODE_TAP:
                    case TOUCH_MODE_DONE_WAITING:
                        final int motionPosition = mMotionPosition;
                        final View child = getChildAt(motionPosition - mFirstPosition);
                        if (child != null && !child.hasFocusable()) {
                            if (mTouchMode != TOUCH_MODE_DOWN) {
                                child.setPressed(false);
                            }
                            if (mPerformClick == null) {
                                mPerformClick = new PerformClick();
                            }
                            final AbsListView.PerformClick performClick = mPerformClick;
                            performClick.mChild = child;
                            performClick.mClickMotionPosition = motionPosition;
                            performClick.rememberWindowAttachCount();
                            mResurrectToPosition = motionPosition;
                            if (mTouchMode == TOUCH_MODE_DOWN || mTouchMode == TOUCH_MODE_TAP) {
                                final Handler handler = getHandler();
                                if (handler != null) {
                                    handler.removeCallbacks(mTouchMode == TOUCH_MODE_DOWN ? mPendingCheckForTap : mPendingCheckForLongPress);
                                }
                                mLayoutMode = LAYOUT_NORMAL;
                                mTouchMode = TOUCH_MODE_TAP;
                                if (!mDataChanged) {
                                    setSelectedPositionInt(mMotionPosition);
                                    layoutChildren();
                                    child.setPressed(true);
                                    positionSelector(child);
                                    setPressed(true);
                                    if (mSelector != null) {
                                        Drawable d = mSelector.getCurrent();
                                        if (d != null && d instanceof TransitionDrawable) {
                                            ((TransitionDrawable) d).resetTransition();
                                        }
                                    }
                                    postDelayed(new Runnable() {

                                        public void run() {
                                            child.setPressed(false);
                                            setPressed(false);
                                            if (!mDataChanged) {
                                                post(performClick);
                                            }
                                            mTouchMode = TOUCH_MODE_REST;
                                        }
                                    }, ViewConfiguration.getPressedStateDuration());
                                }
                                return true;
                            } else {
                                if (!mDataChanged) {
                                    post(performClick);
                                }
                            }
                        }
                        mTouchMode = TOUCH_MODE_REST;
                        break;
                    case TOUCH_MODE_SCROLL:
                        final int childCount = getChildCount();
                        if (childCount > 0) {
                            if (mFirstPosition == 0 && getChildAt(0).getTop() >= mListPadding.top && mFirstPosition + childCount < mItemCount && getChildAt(childCount - 1).getBottom() <= getHeight() - mListPadding.bottom) {
                                mTouchMode = TOUCH_MODE_REST;
                                reportScrollStateChange(OnScrollListener.SCROLL_STATE_IDLE);
                            } else {
                                final VelocityTracker velocityTracker = mVelocityTracker;
                                velocityTracker.computeCurrentVelocity(1000, mMaximumVelocity);
                                final int initialVelocity = (int) velocityTracker.getYVelocity();
                                if (Math.abs(initialVelocity) > mMinimumVelocity) {
                                    if (mFlingRunnable == null) {
                                        mFlingRunnable = new FlingRunnable();
                                    }
                                    reportScrollStateChange(OnScrollListener.SCROLL_STATE_FLING);
                                    mFlingRunnable.start(-initialVelocity);
                                }
                            }
                        } else {
                            mTouchMode = TOUCH_MODE_REST;
                            reportScrollStateChange(OnScrollListener.SCROLL_STATE_IDLE);
                        }
                }
                setPressed(false);
                // Need to redraw since we probably aren't drawing the selector anymore
                invalidate();
                final Handler handler = getHandler();
                if (handler != null) {
                    handler.removeCallbacks(mPendingCheckForLongPress);
                }
                if (mVelocityTracker != null) {
                    mVelocityTracker.recycle();
                    mVelocityTracker = null;
                }
                if (PROFILE_SCROLLING) {
                    if (mScrollProfilingStarted) {
                        Debug.stopMethodTracing();
                        mScrollProfilingStarted = false;
                    }
                }
                break;
            }
        case MotionEvent.ACTION_CANCEL:
            {
                mTouchMode = TOUCH_MODE_REST;
                setPressed(false);
                View motionView = this.getChildAt(mMotionPosition - mFirstPosition);
                if (motionView != null) {
                    motionView.setPressed(false);
                }
                clearScrollingCache();
                final Handler handler = getHandler();
                if (handler != null) {
                    handler.removeCallbacks(mPendingCheckForLongPress);
                }
                if (mVelocityTracker != null) {
                    mVelocityTracker.recycle();
                    mVelocityTracker = null;
                }
            }
    }
    return true;
}","{
    if (!isEnabled()) {
        // events, it just doesn't respond to them.
        return isClickable() || isLongClickable();
    }
    if (mFastScroller != null) {
        boolean intercepted = mFastScroller.onTouchEvent(ev);
        if (intercepted) {
            return true;
        }
    }
    final int action = ev.getAction();
    View v;
    int deltaY;
    if (mVelocityTracker == null) {
        mVelocityTracker = VelocityTracker.obtain();
    }
    mVelocityTracker.addMovement(ev);
    switch(action & MotionEvent.ACTION_MASK) {
        case MotionEvent.ACTION_DOWN:
            {
                mActivePointerId = ev.getPointerId(0);
                final int x = (int) ev.getX();
                final int y = (int) ev.getY();
                int motionPosition = pointToPosition(x, y);
                if (!mDataChanged) {
                    if ((mTouchMode != TOUCH_MODE_FLING) && (motionPosition >= 0) && (getAdapter().isEnabled(motionPosition))) {
                        // User clicked on an actual view (and was not stopping a fling). It might be a
                        // click or a scroll. Assume it is a click until proven otherwise
                        mTouchMode = TOUCH_MODE_DOWN;
                        // FIXME Debounce
                        if (mPendingCheckForTap == null) {
                            mPendingCheckForTap = new CheckForTap();
                        }
                        postDelayed(mPendingCheckForTap, ViewConfiguration.getTapTimeout());
                    } else {
                        if (ev.getEdgeFlags() != 0 && motionPosition < 0) {
                            // code in ViewRoot to try to find a nearby view to select
                            return false;
                        }
                        if (mTouchMode == TOUCH_MODE_FLING) {
                            // Stopped a fling. It is a scroll.
                            createScrollingCache();
                            mTouchMode = TOUCH_MODE_SCROLL;
                            mMotionCorrection = 0;
                            motionPosition = findMotionRow(y);
                            reportScrollStateChange(OnScrollListener.SCROLL_STATE_TOUCH_SCROLL);
                        }
                    }
                }
                if (motionPosition >= 0) {
                    // Remember where the motion event started
                    v = getChildAt(motionPosition - mFirstPosition);
                    mMotionViewOriginalTop = v.getTop();
                }
                mMotionX = x;
                mMotionY = y;
                mMotionPosition = motionPosition;
                mLastY = Integer.MIN_VALUE;
                break;
            }
        case MotionEvent.ACTION_MOVE:
            {
                final int pointerIndex = ev.findPointerIndex(mActivePointerId);
                final int y = (int) ev.getY(pointerIndex);
                deltaY = y - mMotionY;
                switch(mTouchMode) {
                    case TOUCH_MODE_DOWN:
                    case TOUCH_MODE_TAP:
                    case TOUCH_MODE_DONE_WAITING:
                        // Check if we have moved far enough that it looks more like a
                        // scroll than a tap
                        startScrollIfNeeded(deltaY);
                        break;
                    case TOUCH_MODE_SCROLL:
                        if (PROFILE_SCROLLING) {
                            if (!mScrollProfilingStarted) {
                                Debug.startMethodTracing(""AbsListViewScroll"");
                                mScrollProfilingStarted = true;
                            }
                        }
                        if (y != mLastY) {
                            deltaY -= mMotionCorrection;
                            int incrementalDeltaY = mLastY != Integer.MIN_VALUE ? y - mLastY : deltaY;
                            // No need to do all this work if we're not going to move anyway
                            boolean atEdge = false;
                            if (incrementalDeltaY != 0) {
                                atEdge = trackMotionScroll(deltaY, incrementalDeltaY);
                            }
                            // Check to see if we have bumped into the scroll limit
                            if (atEdge && getChildCount() > 0) {
                                // Treat this like we're starting a new scroll from the current
                                // position. This will let the user start scrolling back into
                                // content immediately rather than needing to scroll back to the
                                // point where they hit the limit first.
                                int motionPosition = findMotionRow(y);
                                if (motionPosition >= 0) {
                                    final View motionView = getChildAt(motionPosition - mFirstPosition);
                                    mMotionViewOriginalTop = motionView.getTop();
                                }
                                mMotionY = y;
                                mMotionPosition = motionPosition;
                                invalidate();
                            }
                            mLastY = y;
                        }
                        break;
                }
                break;
            }
        case MotionEvent.ACTION_UP:
            {
                switch(mTouchMode) {
                    case TOUCH_MODE_DOWN:
                    case TOUCH_MODE_TAP:
                    case TOUCH_MODE_DONE_WAITING:
                        final int motionPosition = mMotionPosition;
                        final View child = getChildAt(motionPosition - mFirstPosition);
                        if (child != null && !child.hasFocusable()) {
                            if (mTouchMode != TOUCH_MODE_DOWN) {
                                child.setPressed(false);
                            }
                            if (mPerformClick == null) {
                                mPerformClick = new PerformClick();
                            }
                            final AbsListView.PerformClick performClick = mPerformClick;
                            performClick.mChild = child;
                            performClick.mClickMotionPosition = motionPosition;
                            performClick.rememberWindowAttachCount();
                            mResurrectToPosition = motionPosition;
                            if (mTouchMode == TOUCH_MODE_DOWN || mTouchMode == TOUCH_MODE_TAP) {
                                final Handler handler = getHandler();
                                if (handler != null) {
                                    handler.removeCallbacks(mTouchMode == TOUCH_MODE_DOWN ? mPendingCheckForTap : mPendingCheckForLongPress);
                                }
                                mLayoutMode = LAYOUT_NORMAL;
                                if (!mDataChanged && mAdapter.isEnabled(motionPosition)) {
                                    mTouchMode = TOUCH_MODE_TAP;
                                    setSelectedPositionInt(mMotionPosition);
                                    layoutChildren();
                                    child.setPressed(true);
                                    positionSelector(child);
                                    setPressed(true);
                                    if (mSelector != null) {
                                        Drawable d = mSelector.getCurrent();
                                        if (d != null && d instanceof TransitionDrawable) {
                                            ((TransitionDrawable) d).resetTransition();
                                        }
                                    }
                                    postDelayed(new Runnable() {

                                        public void run() {
                                            child.setPressed(false);
                                            setPressed(false);
                                            if (!mDataChanged) {
                                                post(performClick);
                                            }
                                            mTouchMode = TOUCH_MODE_REST;
                                        }
                                    }, ViewConfiguration.getPressedStateDuration());
                                } else {
                                    mTouchMode = TOUCH_MODE_REST;
                                }
                                return true;
                            } else if (!mDataChanged && mAdapter.isEnabled(motionPosition)) {
                                post(performClick);
                            }
                        }
                        mTouchMode = TOUCH_MODE_REST;
                        break;
                    case TOUCH_MODE_SCROLL:
                        final int childCount = getChildCount();
                        if (childCount > 0) {
                            if (mFirstPosition == 0 && getChildAt(0).getTop() >= mListPadding.top && mFirstPosition + childCount < mItemCount && getChildAt(childCount - 1).getBottom() <= getHeight() - mListPadding.bottom) {
                                mTouchMode = TOUCH_MODE_REST;
                                reportScrollStateChange(OnScrollListener.SCROLL_STATE_IDLE);
                            } else {
                                final VelocityTracker velocityTracker = mVelocityTracker;
                                velocityTracker.computeCurrentVelocity(1000, mMaximumVelocity);
                                final int initialVelocity = (int) velocityTracker.getYVelocity(mActivePointerId);
                                if (Math.abs(initialVelocity) > mMinimumVelocity) {
                                    if (mFlingRunnable == null) {
                                        mFlingRunnable = new FlingRunnable();
                                    }
                                    reportScrollStateChange(OnScrollListener.SCROLL_STATE_FLING);
                                    mFlingRunnable.start(-initialVelocity);
                                } else {
                                    mTouchMode = TOUCH_MODE_REST;
                                    reportScrollStateChange(OnScrollListener.SCROLL_STATE_IDLE);
                                }
                            }
                        } else {
                            mTouchMode = TOUCH_MODE_REST;
                            reportScrollStateChange(OnScrollListener.SCROLL_STATE_IDLE);
                        }
                        break;
                }
                setPressed(false);
                // Need to redraw since we probably aren't drawing the selector anymore
                invalidate();
                final Handler handler = getHandler();
                if (handler != null) {
                    handler.removeCallbacks(mPendingCheckForLongPress);
                }
                if (mVelocityTracker != null) {
                    mVelocityTracker.recycle();
                    mVelocityTracker = null;
                }
                mActivePointerId = INVALID_POINTER;
                if (PROFILE_SCROLLING) {
                    if (mScrollProfilingStarted) {
                        Debug.stopMethodTracing();
                        mScrollProfilingStarted = false;
                    }
                }
                break;
            }
        case MotionEvent.ACTION_CANCEL:
            {
                mTouchMode = TOUCH_MODE_REST;
                setPressed(false);
                View motionView = this.getChildAt(mMotionPosition - mFirstPosition);
                if (motionView != null) {
                    motionView.setPressed(false);
                }
                clearScrollingCache();
                final Handler handler = getHandler();
                if (handler != null) {
                    handler.removeCallbacks(mPendingCheckForLongPress);
                }
                if (mVelocityTracker != null) {
                    mVelocityTracker.recycle();
                    mVelocityTracker = null;
                }
                mActivePointerId = INVALID_POINTER;
                break;
            }
        case MotionEvent.ACTION_POINTER_UP:
            {
                onSecondaryPointerUp(ev);
                final int x = mMotionX;
                final int y = mMotionY;
                final int motionPosition = pointToPosition(x, y);
                if (motionPosition >= 0) {
                    // Remember where the motion event started
                    v = getChildAt(motionPosition - mFirstPosition);
                    mMotionViewOriginalTop = v.getTop();
                    mMotionPosition = motionPosition;
                }
                mLastY = y;
                break;
            }
    }
    return true;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,,,,
58,<android.pim.vcard.VCardConfig: boolean usesUtf8(int)>,7,8,<android.pim.vcard.VCardConfig: boolean usesUtf8(int)>,<android.pim.vcard.VCardConfig: boolean usesUtf8(int)>,0,"{
    return ((vcardType & FLAG_CHARSET_UTF8) != 0);
}","{
    return ((vcardType & FLAG_CHARSET_MASK) == FLAG_CHARSET_UTF8);
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"1,3",1,"The return statement has been changed ((vcardType & FLAG_CHARSET_UTF8) != 0 to (vcardType & FLAG_CHARSET_MASK) == FLAG_CHARSET_UTF8) and involves change in arithmetic operation. Hence, the code change type is 1,3.","Since return statement has changed there is a potential for the API to return a different boolean variable, thus the CI type is 1."
61,<android.app.SearchManager: void onCancel(DialogInterface)>,7,8,<android.app.SearchManager: void onCancel(DialogInterface)>,<android.app.SearchManager: void onCancel(DialogInterface)>,0,"{
    throw new UnsupportedOperationException();
}","{
    if (mCancelListener != null) {
        mCancelListener.onCancel();
    }
}",1,"/**
 * @deprecated This method is an obsolete internal implementation detail. Do not use.
 */
","/**
 * @deprecated This method is an obsolete internal implementation detail. Do not use.
 */
",-1,[@Deprecated],[@Deprecated],-1,-1,-1,-1,-1,-1,"2,3",2,"The UnsupportedOperationException thrown in the early version has been removed and a new control statement (if checking null for mCancelListener). So the change type is 2,3.","The UnsupportedOperationException will not be thrown in the later version while a new behavior (mCancelListener.onCancel()) is introduced which execution depends on the condition if mCancelListener is not null, so CI type is 2."
65,<android.webkit.HttpAuthHandler: void handleAuthRequest(LoadListener)>,7,8,<android.webkit.HttpAuthHandler: void handleAuthRequest(LoadListener)>,<android.webkit.HttpAuthHandler: void handleAuthRequest(LoadListener)>,0,"{
    boolean processNext = false;
    synchronized (mLoaderQueue) {
        mLoaderQueue.offer(loader);
        processNext = (mLoaderQueue.size() == 1);
    }
    if (processNext) {
        processNextLoader();
    }
}","{
    // response.
    if (loader.isSynchronous()) {
        // If there's a request in flight, wait for it to complete. The
        // response will queue a message on this thread.
        waitForRequestToComplete();
        // useHttpAuthUsernamePassword().
        synchronized (mLoaderQueue) {
            mLoaderQueue.addFirst(loader);
        }
        processNextLoader();
        // Wait for this request to complete.
        waitForRequestToComplete();
        // Pop the loader from the queue.
        synchronized (mLoaderQueue) {
            assert (mLoaderQueue.peek() == loader);
            mLoaderQueue.poll();
        }
        // Call back.
        loader.handleAuthResponse(mUsername, mPassword);
        // request, if present, will start the next request.
        return;
    }
    boolean processNext = false;
    synchronized (mLoaderQueue) {
        mLoaderQueue.offer(loader);
        processNext = (mLoaderQueue.size() == 1);
    }
    if (processNext) {
        processNextLoader();
    }
}",1,"/* package */
","/* package */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",0,"The control dependency and other statements have been added into the latest version to handle synchronous loader. Thus, the code change types are 3,4.","Despite the code changes, these modifications do not produce a different return value or exception handling between two versions, thus no compatibility issue, and the CI type is 0."
66,<android.app.Activity: void dismissDialog(int)>,7,8,<android.app.Activity: void dismissDialog(int)>,<android.app.Activity: void dismissDialog(int)>,0,"{
    if (mManagedDialogs == null) {
        throw missingDialog(id);
    }
    final Dialog dialog = mManagedDialogs.get(id);
    if (dialog == null) {
        throw missingDialog(id);
    }
    dialog.dismiss();
}","{
    if (mManagedDialogs == null) {
        throw missingDialog(id);
    }
    final ManagedDialog md = mManagedDialogs.get(id);
    if (md == null) {
        throw missingDialog(id);
    }
    md.mDialog.dismiss();
}",1,"/**
 * Dismiss a dialog that was previously shown via {@link #showDialog(int)}.
 *
 * @param id The id of the managed dialog.
 *
 * @throws IllegalArgumentException if the id was not previously shown via
 * {@link #showDialog(int)}.
 *
 * @see #onCreateDialog(int)
 * @see #onPrepareDialog(int, Dialog)
 * @see #showDialog(int)
 * @see #removeDialog(int)
 */
","/**
 * Dismiss a dialog that was previously shown via {@link #showDialog(int)}.
 *
 * @param id The id of the managed dialog.
 *
 * @throws IllegalArgumentException if the id was not previously shown via
 * {@link #showDialog(int)}.
 *
 * @see #onCreateDialog(int, Bundle)
 * @see #onPrepareDialog(int, Dialog, Bundle)
 * @see #showDialog(int)
 * @see #removeDialog(int)
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,4,5",0,"The object type that 'get()' method returns has changed from Dialog to ManagedDialog, and an attribute of 'md' is visited in mDialog.dismiss(), which are changes in return statements and other statements. The type change of the object returned by the 'get()' method is a dependent API change, so the code change types are 1,4,5.","Although some statements have been changed, the goal of this method - ""dismiss a dialog""- remains the same in both versions. These changes will not affect the current API to return a different value or throw a different exception. Therefore, no compatibility issue exists."
68,"<android.speech.tts.TextToSpeech: int synthesizeToFile(String,HashMap<String, String>,String)>",7,8,"<android.speech.tts.TextToSpeech: int synthesizeToFile(String,HashMap<String, String>,String)>","<android.speech.tts.TextToSpeech: int synthesizeToFile(String,HashMap<String, String>,String)>",0,"{
    synchronized (mStartLock) {
        int result = ERROR;
        if (!mStarted) {
            return result;
        }
        try {
            if ((params != null) && (!params.isEmpty())) {
                // no need to read the stream type here
                String extra = params.get(Engine.KEY_PARAM_UTTERANCE_ID);
                if (extra != null) {
                    mCachedParams[Engine.PARAM_POSITION_UTTERANCE_ID + 1] = extra;
                }
            }
            if (mITts.synthesizeToFile(mPackageName, text, mCachedParams, filename)) {
                result = SUCCESS;
            }
        } catch (RemoteException e) {
            // TTS died; restart it.
            Log.e(""TextToSpeech.java - synthesizeToFile"", ""RemoteException"");
            e.printStackTrace();
            mStarted = false;
            initTts();
        } catch (NullPointerException e) {
            // TTS died; restart it.
            Log.e(""TextToSpeech.java - synthesizeToFile"", ""NullPointerException"");
            e.printStackTrace();
            mStarted = false;
            initTts();
        } catch (IllegalStateException e) {
            // TTS died; restart it.
            Log.e(""TextToSpeech.java - synthesizeToFile"", ""IllegalStateException"");
            e.printStackTrace();
            mStarted = false;
            initTts();
        } finally {
            resetCachedParams();
            return result;
        }
    }
}","{
    synchronized (mStartLock) {
        int result = ERROR;
        if (!mStarted) {
            return result;
        }
        try {
            if ((params != null) && (!params.isEmpty())) {
                // no need to read the stream type here
                String extra = params.get(Engine.KEY_PARAM_UTTERANCE_ID);
                if (extra != null) {
                    mCachedParams[Engine.PARAM_POSITION_UTTERANCE_ID + 1] = extra;
                }
                extra = params.get(Engine.KEY_PARAM_ENGINE);
                if (extra != null) {
                    mCachedParams[Engine.PARAM_POSITION_ENGINE + 1] = extra;
                }
            }
            result = mITts.synthesizeToFile(mPackageName, text, mCachedParams, filename) ? SUCCESS : ERROR;
        } catch (RemoteException e) {
            // TTS died; restart it.
            Log.e(""TextToSpeech.java - synthesizeToFile"", ""RemoteException"");
            e.printStackTrace();
            mStarted = false;
            initTts();
        } catch (NullPointerException e) {
            // TTS died; restart it.
            Log.e(""TextToSpeech.java - synthesizeToFile"", ""NullPointerException"");
            e.printStackTrace();
            mStarted = false;
            initTts();
        } catch (IllegalStateException e) {
            // TTS died; restart it.
            Log.e(""TextToSpeech.java - synthesizeToFile"", ""IllegalStateException"");
            e.printStackTrace();
            mStarted = false;
            initTts();
        } finally {
            resetCachedParams();
            return result;
        }
    }
}",1,"/**
 * Synthesizes the given text to a file using the specified parameters.
 *
 * @param text
 * The String of text that should be synthesized
 * @param params
 * The list of parameters to be used. Can be null if no parameters are given.
 * They are specified using a (key, value) pair, where the key can be
 * {@link Engine#KEY_PARAM_UTTERANCE_ID}.
 * @param filename
 * The string that gives the full output filename; it should be
 * something like ""/sdcard/myappsounds/mysound.wav"".
 *
 * @return Code indicating success or failure. See {@link #ERROR} and {@link #SUCCESS}.
 */
","/**
 * Synthesizes the given text to a file using the specified parameters.
 *
 * @param text
 * The String of text that should be synthesized
 * @param params
 * The list of parameters to be used. Can be null if no parameters are given.
 * They are specified using a (key, value) pair, where the key can be
 * {@link Engine#KEY_PARAM_UTTERANCE_ID}.
 * @param filename
 * The string that gives the full output filename; it should be
 * something like ""/sdcard/myappsounds/mysound.wav"".
 *
 * @return Code indicating success or failure. See {@link #ERROR} and {@link #SUCCESS}.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3",1,"In the late version of the code, a new check and assignment have been inserted for Engine.KEY_PARAM_ENGINE in the if condition (params != null) && (!params.isEmpty()). Furthermore, the return statement if (mITts.synthesizeToFile(mPackageName, text, mCachedParams, filename)) {result = SUCCESS;} has been condensed into a ternary operation in the late version.","The insertion of the new check and assignment for Engine.KEY_PARAM_ENGINE could potentially alter the parameters mCachedParams passed to mITts.synthesizeToFile(). Consequently, it might cause the API to return different values, leading to a potential compatibility issue related to different return values (CI type 1)."
69,<android.webkit.WebView: boolean onTrackballEvent(MotionEvent)>,7,8,<android.webkit.WebView: boolean onTrackballEvent(MotionEvent)>,<android.webkit.WebView: boolean onTrackballEvent(MotionEvent)>,0,"{
    long time = ev.getEventTime();
    if ((ev.getMetaState() & KeyEvent.META_ALT_ON) != 0) {
        if (ev.getY() > 0)
            pageDown(true);
        if (ev.getY() < 0)
            pageUp(true);
        return true;
    }
    if (ev.getAction() == MotionEvent.ACTION_DOWN) {
        if (mShiftIsPressed) {
            // discard press if copy in progress
            return true;
        }
        mTrackballDown = true;
        if (mNativeClass == 0) {
            return false;
        }
        nativeRecordButtons(hasFocus() && hasWindowFocus(), true, true);
        if (time - mLastCursorTime <= TRACKBALL_TIMEOUT && !mLastCursorBounds.equals(nativeGetCursorRingBounds())) {
            nativeSelectBestAt(mLastCursorBounds);
        }
        if (DebugFlags.WEB_VIEW) {
            Log.v(LOGTAG, ""onTrackballEvent down ev="" + ev + "" time="" + time + "" mLastCursorTime="" + mLastCursorTime);
        }
        if (isInTouchMode())
            requestFocusFromTouch();
        // let common code in onKeyDown at it
        return false;
    }
    if (ev.getAction() == MotionEvent.ACTION_UP) {
        // LONG_PRESS_CENTER is set in common onKeyDown
        mPrivateHandler.removeMessages(LONG_PRESS_CENTER);
        mTrackballDown = false;
        mTrackballUpTime = time;
        if (mShiftIsPressed) {
            if (mExtendSelection) {
                commitCopy();
            } else {
                mExtendSelection = true;
            }
            // discard press if copy in progress
            return true;
        }
        if (DebugFlags.WEB_VIEW) {
            Log.v(LOGTAG, ""onTrackballEvent up ev="" + ev + "" time="" + time);
        }
        // let common code in onKeyUp at it
        return false;
    }
    if (mMapTrackballToArrowKeys && mShiftIsPressed == false) {
        if (DebugFlags.WEB_VIEW)
            Log.v(LOGTAG, ""onTrackballEvent gmail quit"");
        return false;
    }
    if (mTrackballDown) {
        if (DebugFlags.WEB_VIEW)
            Log.v(LOGTAG, ""onTrackballEvent down quit"");
        // discard move if trackball is down
        return true;
    }
    if (time - mTrackballUpTime < TRACKBALL_TIMEOUT) {
        if (DebugFlags.WEB_VIEW)
            Log.v(LOGTAG, ""onTrackballEvent up timeout quit"");
        return true;
    }
    // TODO: alternatively we can do panning as touch does
    switchOutDrawHistory();
    if (time - mTrackballLastTime > TRACKBALL_TIMEOUT) {
        if (DebugFlags.WEB_VIEW) {
            Log.v(LOGTAG, ""onTrackballEvent time="" + time + "" last="" + mTrackballLastTime);
        }
        mTrackballFirstTime = time;
        mTrackballXMove = mTrackballYMove = 0;
    }
    mTrackballLastTime = time;
    if (DebugFlags.WEB_VIEW) {
        Log.v(LOGTAG, ""onTrackballEvent ev="" + ev + "" time="" + time);
    }
    mTrackballRemainsX += ev.getX();
    mTrackballRemainsY += ev.getY();
    doTrackball(time);
    return true;
}","{
    long time = ev.getEventTime();
    if ((ev.getMetaState() & KeyEvent.META_ALT_ON) != 0) {
        if (ev.getY() > 0)
            pageDown(true);
        if (ev.getY() < 0)
            pageUp(true);
        return true;
    }
    boolean shiftPressed = mShiftIsPressed && (mNativeClass == 0 || !nativeFocusIsPlugin());
    if (ev.getAction() == MotionEvent.ACTION_DOWN) {
        if (shiftPressed) {
            // discard press if copy in progress
            return true;
        }
        mTrackballDown = true;
        if (mNativeClass == 0) {
            return false;
        }
        nativeRecordButtons(hasFocus() && hasWindowFocus(), true, true);
        if (time - mLastCursorTime <= TRACKBALL_TIMEOUT && !mLastCursorBounds.equals(nativeGetCursorRingBounds())) {
            nativeSelectBestAt(mLastCursorBounds);
        }
        if (DebugFlags.WEB_VIEW) {
            Log.v(LOGTAG, ""onTrackballEvent down ev="" + ev + "" time="" + time + "" mLastCursorTime="" + mLastCursorTime);
        }
        if (isInTouchMode())
            requestFocusFromTouch();
        // let common code in onKeyDown at it
        return false;
    }
    if (ev.getAction() == MotionEvent.ACTION_UP) {
        // LONG_PRESS_CENTER is set in common onKeyDown
        mPrivateHandler.removeMessages(LONG_PRESS_CENTER);
        mTrackballDown = false;
        mTrackballUpTime = time;
        if (shiftPressed) {
            if (mExtendSelection) {
                commitCopy();
            } else {
                mExtendSelection = true;
                // draw the i-beam instead of the arrow
                invalidate();
            }
            // discard press if copy in progress
            return true;
        }
        if (DebugFlags.WEB_VIEW) {
            Log.v(LOGTAG, ""onTrackballEvent up ev="" + ev + "" time="" + time);
        }
        // let common code in onKeyUp at it
        return false;
    }
    if (mMapTrackballToArrowKeys && mShiftIsPressed == false) {
        if (DebugFlags.WEB_VIEW)
            Log.v(LOGTAG, ""onTrackballEvent gmail quit"");
        return false;
    }
    if (mTrackballDown) {
        if (DebugFlags.WEB_VIEW)
            Log.v(LOGTAG, ""onTrackballEvent down quit"");
        // discard move if trackball is down
        return true;
    }
    if (time - mTrackballUpTime < TRACKBALL_TIMEOUT) {
        if (DebugFlags.WEB_VIEW)
            Log.v(LOGTAG, ""onTrackballEvent up timeout quit"");
        return true;
    }
    // TODO: alternatively we can do panning as touch does
    switchOutDrawHistory();
    if (time - mTrackballLastTime > TRACKBALL_TIMEOUT) {
        if (DebugFlags.WEB_VIEW) {
            Log.v(LOGTAG, ""onTrackballEvent time="" + time + "" last="" + mTrackballLastTime);
        }
        mTrackballFirstTime = time;
        mTrackballXMove = mTrackballYMove = 0;
    }
    mTrackballLastTime = time;
    if (DebugFlags.WEB_VIEW) {
        Log.v(LOGTAG, ""onTrackballEvent ev="" + ev + "" time="" + time);
    }
    mTrackballRemainsX += ev.getX();
    mTrackballRemainsY += ev.getY();
    doTrackball(time);
    return true;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,4",1,The change type is 3 and 4 because the condition for setting the variable 'shiftPressed' and some other non-control statements have changed.,"Though the exact returned boolean value might not change due to these modifications, it potentialy can because the conditions for setting values of 'shiftPressed' has changed and it affects return statements in different conditions. Therefore, the CI type is 1."
70,<android.widget.Spinner.DropDownAdapter: boolean areAllItemsEnabled()>,7,8,<android.widget.Spinner.DropDownAdapter: boolean areAllItemsEnabled()>,<android.widget.Spinner.DropDownAdapter: boolean areAllItemsEnabled()>,0,"{
    return true;
}","{
    final ListAdapter adapter = mListAdapter;
    if (adapter != null) {
        return adapter.areAllItemsEnabled();
    } else {
        return true;
    }
}",1,"/**
 * <p>Always returns false.</p>
 *
 * @return false
 */
","/**
 * If the wrapped SpinnerAdapter is also a ListAdapter, delegate this call.
 * Otherwise, return true.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3",1,"The control flow of the method has changed and an if statement has been added. Additionally, the return statement has changed as well, so the change type is 1,3.","As the return statement changes, this introduces a possibility for the method to return a different value depending on a specific condition in the late version as contrasted to the early version which always returned 'true'. Therefore, the API potentially returns different variables (true or false here), so the CI type is 1."
73,<android.widget.RemoteViews.SetOnClickPendingIntent: void apply(View)>,7,8,<android.widget.RemoteViews.SetOnClickPendingIntent: void apply(View)>,<android.widget.RemoteViews.SetOnClickPendingIntent: void apply(View)>,0,"{
    final View target = root.findViewById(viewId);
    if (target != null && pendingIntent != null) {
        OnClickListener listener = new OnClickListener() {

            public void onClick(View v) {
                int[] pos = new int[2];
                v.getLocationOnScreen(pos);
                Intent intent = new Intent();
                intent.setSourceBounds(new Rect(pos[0], pos[1], pos[0] + v.getWidth(), pos[1] + v.getHeight()));
                try {
                    // TODO: Unregister this handler if PendingIntent.FLAG_ONE_SHOT?
                    v.getContext().startIntentSender(pendingIntent.getIntentSender(), intent, Intent.FLAG_ACTIVITY_NEW_TASK, Intent.FLAG_ACTIVITY_NEW_TASK, 0);
                } catch (IntentSender.SendIntentException e) {
                    android.util.Log.e(LOG_TAG, ""Cannot send pending intent: "", e);
                }
            }
        };
        target.setOnClickListener(listener);
    }
}","{
    final View target = root.findViewById(viewId);
    if (target != null && pendingIntent != null) {
        OnClickListener listener = new OnClickListener() {

            public void onClick(View v) {
                // Find target view location in screen coordinates and
                // fill into PendingIntent before sending.
                final float appScale = v.getContext().getResources().getCompatibilityInfo().applicationScale;
                final int[] pos = new int[2];
                v.getLocationOnScreen(pos);
                final Rect rect = new Rect();
                rect.left = (int) (pos[0] * appScale + 0.5f);
                rect.top = (int) (pos[1] * appScale + 0.5f);
                rect.right = (int) ((pos[0] + v.getWidth()) * appScale + 0.5f);
                rect.bottom = (int) ((pos[1] + v.getHeight()) * appScale + 0.5f);
                final Intent intent = new Intent();
                intent.setSourceBounds(rect);
                try {
                    // TODO: Unregister this handler if PendingIntent.FLAG_ONE_SHOT?
                    v.getContext().startIntentSender(pendingIntent.getIntentSender(), intent, Intent.FLAG_ACTIVITY_NEW_TASK, Intent.FLAG_ACTIVITY_NEW_TASK, 0);
                } catch (IntentSender.SendIntentException e) {
                    android.util.Log.e(LOG_TAG, ""Cannot send pending intent: "", e);
                }
            }
        };
        target.setOnClickListener(listener);
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,1,"The main change in the late version is the modification of how the rect variable is set. A new variable 'appScale' is introduced and the calculation of the rect left, top, right and bottom is different. This changes fall under the category of ""Other statement changed"" which is type 4.","The change in the calculation of the rect variable may lead to a different result in 'intent.setSourceBounds(rect)', which can cause a different 'intent' to be started. Therefore, the API may return a different result, indicating a Compatibility Issue of type 1."
75,<android.server.BluetoothA2dpService: boolean disconnectSink(BluetoothDevice)>,7,8,<android.server.BluetoothA2dpService: boolean disconnectSink(BluetoothDevice)>,<android.server.BluetoothA2dpService: boolean disconnectSink(BluetoothDevice)>,0,"{
    mContext.enforceCallingOrSelfPermission(BLUETOOTH_ADMIN_PERM, ""Need BLUETOOTH_ADMIN permission"");
    if (DBG)
        log(""disconnectSink("" + device + "")"");
    String path = mBluetoothService.getObjectPathFromAddress(device.getAddress());
    if (path == null) {
        return false;
    }
    switch(getSinkState(device)) {
        case BluetoothA2dp.STATE_DISCONNECTED:
            return false;
        case BluetoothA2dp.STATE_DISCONNECTING:
            return true;
    }
    // State is CONNECTING or CONNECTED or PLAYING
    if (!disconnectSinkNative(path)) {
        return false;
    } else {
        return true;
    }
}","{
    mContext.enforceCallingOrSelfPermission(BLUETOOTH_ADMIN_PERM, ""Need BLUETOOTH_ADMIN permission"");
    if (DBG)
        log(""disconnectSink("" + device + "")"");
    String path = mBluetoothService.getObjectPathFromAddress(device.getAddress());
    if (path == null) {
        return false;
    }
    int state = getSinkState(device);
    switch(state) {
        case BluetoothA2dp.STATE_DISCONNECTED:
            return false;
        case BluetoothA2dp.STATE_DISCONNECTING:
            return true;
    }
    // State is CONNECTING or CONNECTED or PLAYING
    handleSinkStateChange(device, state, BluetoothA2dp.STATE_DISCONNECTING);
    if (!disconnectSinkNative(path)) {
        // Restore previous state
        handleSinkStateChange(device, mAudioDevices.get(device), state);
        return false;
    }
    return true;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"3,4",1,"This code change affects the control dependency (i.e., a new condition change alters the control flow) and introduction of new commands (i.e., two calls to handleSinkStateChange()). Therefore, we classify it as changes 3 and 4.","The additional commands within the late version could potentially change the state of the device and thereby affect the behavior of the API (resulting in different returns), leading us to classify this as Compatibility Issue of type 1."
76,<android.content.res.Configuration: int hashCode()>,7,8,<android.content.res.Configuration: int hashCode()>,<android.content.res.Configuration: int hashCode()>,0,"{
    return ((int) this.fontScale) + this.mcc + this.mnc + this.locale.hashCode() + this.touchscreen + this.keyboard + this.keyboardHidden + this.hardKeyboardHidden + this.navigation + this.navigationHidden + this.orientation + this.screenLayout;
}","{
    return ((int) this.fontScale) + this.mcc + this.mnc + (this.locale != null ? this.locale.hashCode() : 0) + this.touchscreen + this.keyboard + this.keyboardHidden + this.hardKeyboardHidden + this.navigation + this.navigationHidden + this.orientation + this.screenLayout + this.uiMode;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"1,3",1,"The return statement changed, it now includes the addition of 'this.uiMode' and a condition check for 'this.locale', therefore the code change is classified as 1,3.","The change in the return statement means that the output of the hashCode() method can potentially be different in the late version of the API compared to the early version. Depending on the state of 'this.locale' and 'this.uiMode', different values can be added to the overall hash calculation. This could result in potential Compatibility Issue causing different return values which corresponds to CI type 1."
78,<android.widget.ScrollView: int computeVerticalScrollRange()>,7,8,<android.widget.ScrollView: int computeVerticalScrollRange()>,<android.widget.ScrollView: int computeVerticalScrollRange()>,0,"{
    int count = getChildCount();
    return count == 0 ? getHeight() : (getChildAt(0)).getBottom();
}","{
    final int count = getChildCount();
    final int contentHeight = getHeight() - mPaddingBottom - mPaddingTop;
    if (count == 0) {
        return contentHeight;
    }
    return getChildAt(0).getBottom();
}",1,"/**
 * <p>The scroll range of a scroll view is the overall height of all of its
 * children.</p>
 */
","/**
 * <p>The scroll range of a scroll view is the overall height of all of its
 * children.</p>
 */
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,4",1,"The return statement and the logic to compute the returned variable changed. The calculation introduces new variables (mPaddingBottom and mPaddingTop) in the later implementation, so the change type is 1,4.","The logic to compute the return value 'contentHeight' has changed. This could potentially cause this API to return a different value on the later version as compared to the earlier version. Thus, the CI type is 1."
79,"<android.preference.PreferenceGroupAdapter: View getView(int,View,ViewGroup)>",7,8,"<android.preference.PreferenceGroupAdapter: View getView(int,View,ViewGroup)>","<android.preference.PreferenceGroupAdapter: View getView(int,View,ViewGroup)>",0,"{
    final Preference preference = this.getItem(position);
    if (preference.hasSpecifiedLayout()) {
        // If the preference had specified a layout (as opposed to the
        // default), don't use convert views.
        convertView = null;
    } else {
        // TODO: better way of doing this
        final String name = preference.getClass().getName();
        if (Collections.binarySearch(mPreferenceClassNames, name) < 0) {
            convertView = null;
        }
    }
    return preference.getView(convertView, parent);
}","{
    final Preference preference = this.getItem(position);
    // Build a PreferenceLayout to compare with known ones that are cacheable.
    mTempPreferenceLayout = createPreferenceLayout(preference, mTempPreferenceLayout);
    // the layout gets re-created by the Preference.
    if (Collections.binarySearch(mPreferenceLayouts, mTempPreferenceLayout) < 0) {
        convertView = null;
    }
    return preference.getView(convertView, parent);
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,4,1,"The routine of determining whether to set ""convertView"" as null has been completely restructured in this change, with the condition of setting ""convertView"" as null significantly simplified. Therefore, this change belongs to type 4, ""other statement changed"".","Given that the condition for ""convertView"" to be set as null has changed, the value passed to preference.getView(convertView, parent) could potentially differ, potentially leading to different return values between the two versions. Therefore, this falls under CI type 1 - ""Compatibility Issue caused by potential different return values or types""."
80,"<android.os.PowerManager: WakeLock newWakeLock(int,String)>",7,8,"<android.os.PowerManager: WakeLock newWakeLock(int,String)>","<android.os.PowerManager: WakeLock newWakeLock(int,String)>",0,"{
    return new WakeLock(flags, tag);
}","{
    if (tag == null) {
        throw new NullPointerException(""tag is null in PowerManager.newWakeLock"");
    }
    return new WakeLock(flags, tag);
}",1,"/**
 * Get a wake lock at the level of the flags parameter.  Call
 * {@link WakeLock#acquire() acquire()} on the object to acquire the
 * wake lock, and {@link WakeLock#release release()} when you are done.
 *
 * {@samplecode
 * PowerManager pm = (PowerManager)mContext.getSystemService(
 * Context.POWER_SERVICE);
 * PowerManager.WakeLock wl = pm.newWakeLock(
 * PowerManager.SCREEN_DIM_WAKE_LOCK
 * | PowerManager.ON_AFTER_RELEASE,
 * TAG);
 * wl.acquire();
 * // ...
 * wl.release();
 * }
 *
 * @param flags Combination of flag values defining the requested behavior of the WakeLock.
 * @param tag Your class name (or other tag) for debugging purposes.
 *
 * @see WakeLock#acquire()
 * @see WakeLock#release()
 */
","/**
 * Get a wake lock at the level of the flags parameter.  Call
 * {@link WakeLock#acquire() acquire()} on the object to acquire the
 * wake lock, and {@link WakeLock#release release()} when you are done.
 *
 * {@samplecode
 * PowerManager pm = (PowerManager)mContext.getSystemService(
 * Context.POWER_SERVICE);
 * PowerManager.WakeLock wl = pm.newWakeLock(
 * PowerManager.SCREEN_DIM_WAKE_LOCK
 * | PowerManager.ON_AFTER_RELEASE,
 * TAG);
 * wl.acquire();
 * // ...
 * wl.release();
 * }
 *
 * @param flags Combination of flag values defining the requested behavior of the WakeLock.
 * @param tag Your class name (or other tag) for debugging purposes.
 *
 * @see WakeLock#acquire()
 * @see WakeLock#release()
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2, 3",2,"In the new version of the method, an `if` condition has been added to verify if 'tag' is null. If it is, a new exception is thrown. Therefore, the changes involve both Exception handling (2) and Control Dependency (3).","The new version of the API could throw a different exception (`NullPointerException`) when 'tag' is null, which didn't occur in the early version. Therefore, a Compatibility Issue arises due to potential different exception handlings (2)."
81,<android.content.ContentValues: Double getAsDouble(String)>,7,8,<android.content.ContentValues: Double getAsDouble(String)>,<android.content.ContentValues: Double getAsDouble(String)>,0,"{
    Object value = mValues.get(key);
    try {
        return value != null ? ((Number) value).doubleValue() : null;
    } catch (ClassCastException e) {
        if (value instanceof CharSequence) {
            try {
                return Double.valueOf(value.toString());
            } catch (NumberFormatException e2) {
                Log.e(TAG, ""Cannot parse Double value for "" + value + "" at key "" + key);
                return null;
            }
        } else {
            Log.e(TAG, ""Cannot cast value for "" + key + "" to a Double"");
            return null;
        }
    }
}","{
    Object value = mValues.get(key);
    try {
        return value != null ? ((Number) value).doubleValue() : null;
    } catch (ClassCastException e) {
        if (value instanceof CharSequence) {
            try {
                return Double.valueOf(value.toString());
            } catch (NumberFormatException e2) {
                Log.e(TAG, ""Cannot parse Double value for "" + value + "" at key "" + key);
                return null;
            }
        } else {
            Log.e(TAG, ""Cannot cast value for "" + key + "" to a Double: "" + value, e);
            return null;
        }
    }
}",1,"/**
 * Gets a value and converts it to a Double.
 *
 * @param key the value to get
 * @return the Double value, or null if the value is missing or cannot be converted
 */
","/**
 * Gets a value and converts it to a Double.
 *
 * @param key the value to get
 * @return the Double value, or null if the value is missing or cannot be converted
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The log message when catching the ClassCastException has changed. Hence, the classified change is 4 - Other Statement Changed.","Despite the change in the log message which is an other statement change, it doesn't modify the API behavior, and thus doesn't affect the return value or thrown exceptions. Therefore, there is no Compatibility Issue."
82,"<android.content.ContentResolver: Uri insert(Uri,ContentValues)>",7,8,"<android.content.ContentResolver: Uri insert(Uri,ContentValues)>","<android.content.ContentResolver: Uri insert(Uri,ContentValues)>",0,"{
    IContentProvider provider = acquireProvider(url);
    if (provider == null) {
        throw new IllegalArgumentException(""Unknown URL "" + url);
    }
    try {
        return provider.insert(url, values);
    } catch (RemoteException e) {
        return null;
    } finally {
        releaseProvider(provider);
    }
}","{
    IContentProvider provider = acquireProvider(url);
    if (provider == null) {
        throw new IllegalArgumentException(""Unknown URL "" + url);
    }
    try {
        long startTime = SystemClock.uptimeMillis();
        Uri createdRow = provider.insert(url, values);
        long durationMillis = SystemClock.uptimeMillis() - startTime;
        maybeLogUpdateToEventLog(durationMillis, url, ""insert"", null);
        return createdRow;
    } catch (RemoteException e) {
        return null;
    } finally {
        releaseProvider(provider);
    }
}",1,"/**
 * Inserts a row into a table at the given URL.
 *
 * If the content provider supports transactions the insertion will be atomic.
 *
 * @param url The URL of the table to insert into.
 * @param values The initial values for the newly inserted row. The key is the column name for
 * the field. Passing an empty ContentValues will create an empty row.
 * @return the URL of the newly created row.
 */
","/**
 * Inserts a row into a table at the given URL.
 *
 * If the content provider supports transactions the insertion will be atomic.
 *
 * @param url The URL of the table to insert into.
 * @param values The initial values for the newly inserted row. The key is the column name for
 * the field. Passing an empty ContentValues will create an empty row.
 * @return the URL of the newly created row.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The change is in adding lines to calculate and log the time taken for the provider to insert data, which is not a return, exception, or control dependency change, so the change type is 4.","These additional lines are for logging purposes and do not change what the API returns nor the exceptions it may throw, so no Compatibility Issue exists here."
83,<android.webkit.CookieManager.Cookie: boolean exactMatch(Cookie)>,7,8,<android.webkit.CookieManager.Cookie: boolean exactMatch(Cookie)>,<android.webkit.CookieManager.Cookie: boolean exactMatch(Cookie)>,0,"{
    return domain.equals(in.domain) && path.equals(in.path) && name.equals(in.name);
}","{
    // An exact match means that domain, path, and name are equal. If
    // both values are null, the cookies match. If both values are
    // non-null, the cookies match. If one value is null and the other
    // is non-null, the cookies do not match (i.e. ""foo=;"" and ""foo;"")
    boolean valuesMatch = !((value == null) ^ (in.value == null));
    return domain.equals(in.domain) && path.equals(in.path) && name.equals(in.name) && valuesMatch;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"1,3",1,"A new return condition (valuesMatch) has been added, and its value depends on a new variable assignment statement. Therefore, the code change type is 1,3.","The additional return condition 'valuesMatch' has the potential to change the return value of the method. As a result, the CI type is 1."
85,"<android.webkit.CookieManager.CookieComparator: int compare(Cookie,Cookie)>",7,8,"<android.webkit.CookieManager.CookieComparator: int compare(Cookie,Cookie)>","<android.webkit.CookieManager.CookieComparator: int compare(Cookie,Cookie)>",0,"{
    // According to RFC 2109, multiple cookies are ordered in a way such
    // that those with more specific Path attributes precede those with
    // less specific. Ordering with respect to other attributes (e.g.,
    // Domain) is unspecified.
    // As Set is not modified if the two objects are same, we do want to
    // assign different value for each cookie.
    int diff = cookie2.path.length() - cookie1.path.length();
    if (diff == 0) {
        diff = cookie2.domain.length() - cookie1.domain.length();
        if (diff == 0) {
            diff = cookie2.name.hashCode() - cookie1.name.hashCode();
            if (diff == 0) {
                Log.w(LOGTAG, ""Found two cookies with the same value."" + ""cookie1="" + cookie1 + "" , cookie2="" + cookie2);
            }
        }
    }
    return diff;
}","{
    // According to RFC 2109, multiple cookies are ordered in a way such
    // that those with more specific Path attributes precede those with
    // less specific. Ordering with respect to other attributes (e.g.,
    // Domain) is unspecified.
    // As Set is not modified if the two objects are same, we do want to
    // assign different value for each cookie.
    int diff = cookie2.path.length() - cookie1.path.length();
    if (diff != 0)
        return diff;
    diff = cookie2.domain.length() - cookie1.domain.length();
    if (diff != 0)
        return diff;
    // the list.
    if (cookie2.value == null) {
        // difference.
        if (cookie1.value != null) {
            return -1;
        }
    } else if (cookie1.value == null) {
        // cookie1 has a null value, place it later in the list.
        return 1;
    }
    // Fallback to comparing the name to ensure consistent order.
    return cookie1.name.compareTo(cookie2.name);
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"1,3",1,"The control flow has changed due to the addition of extra if conditions to check the value of the cookie. Also, the return statement has been modified as it now compares the name of the cookies in case of having the same path length and domain length. Therefore, the code change types are 1,3.","The change in return statements and the control flow might lead to different output. For example, if cookies have the same path length and domain length, in the early version, the returned diff would be based on the hashCode difference whereas in the late version it returns the comparison result of the cookie's name. Therefore, the CI type is 1."
86,"<android.accounts.AccountManager: AccountManagerFuture<Account[]> getAccountsByTypeAndFeatures(String,String[],AccountManagerCallback<Account[]>,Handler)>",7,8,"<android.accounts.AccountManager: AccountManagerFuture<Account[]> getAccountsByTypeAndFeatures(String,String[],AccountManagerCallback<Account[]>,Handler)>","<android.accounts.AccountManager: AccountManagerFuture<Account[]> getAccountsByTypeAndFeatures(String,String[],AccountManagerCallback<Account[]>,Handler)>",0,"{
    return new Future2Task<Account[]>(handler, callback) {

        public void doWork() throws RemoteException {
            if (type == null) {
                Log.e(TAG, ""Type is null"");
                set(new Account[0]);
                return;
            }
            mService.getAccountsByFeatures(mResponse, type, features);
        }

        public Account[] bundleToResult(Bundle bundle) throws AuthenticatorException {
            if (!bundle.containsKey(KEY_ACCOUNTS)) {
                throw new AuthenticatorException(""no result in response"");
            }
            final Parcelable[] parcelables = bundle.getParcelableArray(KEY_ACCOUNTS);
            Account[] descs = new Account[parcelables.length];
            for (int i = 0; i < parcelables.length; i++) {
                descs[i] = (Account) parcelables[i];
            }
            return descs;
        }
    }.start();
}","{
    if (type == null)
        throw new IllegalArgumentException(""type is null"");
    return new Future2Task<Account[]>(handler, callback) {

        public void doWork() throws RemoteException {
            mService.getAccountsByFeatures(mResponse, type, features);
        }

        public Account[] bundleToResult(Bundle bundle) throws AuthenticatorException {
            if (!bundle.containsKey(KEY_ACCOUNTS)) {
                throw new AuthenticatorException(""no result in response"");
            }
            final Parcelable[] parcelables = bundle.getParcelableArray(KEY_ACCOUNTS);
            Account[] descs = new Account[parcelables.length];
            for (int i = 0; i < parcelables.length; i++) {
                descs[i] = (Account) parcelables[i];
            }
            return descs;
        }
    }.start();
}",1,,"/**
 * Lists all accounts of a type which have certain features.  The account
 * type identifies the authenticator (see {@link #getAccountsByType}).
 * Account features are authenticator-specific string tokens identifying
 * boolean account properties (see {@link #hasFeatures}).
 *
 * <p>Unlike {@link #getAccountsByType}, this method calls the authenticator,
 * which may contact the server or do other work to check account features,
 * so the method returns an {@link AccountManagerFuture}.
 *
 * <p>This method may be called from any thread, but the returned
 * {@link AccountManagerFuture} must not be used on the main thread.
 *
 * <p>This method requires the caller to hold the permission
 * {@link android.Manifest.permission#GET_ACCOUNTS}.
 *
 * @param type The type of accounts to return, must not be null
 * @param features An array of the account features to require,
 * may be null or empty
 * @param callback Callback to invoke when the request completes,
 * null for no callback
 * @param handler {@link Handler} identifying the callback thread,
 * null for the main thread
 * @return An {@link AccountManagerFuture} which resolves to an array of
 * {@link Account}, one per account of the specified type which
 * matches the requested features.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,2","1,2","The condition statement 'if (type == null)' in the early version has changed to throw an exception in the late version, and the corresponding code block ('Log.e(TAG, ""Type is null"");', 'set(new Account[0]);', 'return;') has been removed . So the code change type is 3,2.","Due to the removal of the 'Log' and 'set' methods and the addition of the 'IllegalArgumentException', the API's return behaviour ('set(new Account[0]);') and exception handling ('IllegalArgumentException') have changed. So the CI type is 1,2."
88,"<android.text.Layout: float measureText(TextPaint,TextPaint,CharSequence,int,int,FontMetricsInt,boolean,Object[])>",7,8,"<android.text.Layout: float measureText(TextPaint,TextPaint,CharSequence,int,int,FontMetricsInt,boolean,Object[])>","<android.text.Layout: float measureText(TextPaint,TextPaint,CharSequence,int,int,FontMetricsInt,boolean,Object[])>",0,"{
    char[] buf = null;
    if (hasTabs) {
        buf = TextUtils.obtain(end - start);
        TextUtils.getChars(text, start, end, buf, 0);
    }
    int len = end - start;
    int here = 0;
    float h = 0;
    int ab = 0, be = 0;
    int top = 0, bot = 0;
    if (fm != null) {
        fm.ascent = 0;
        fm.descent = 0;
    }
    for (int i = hasTabs ? 0 : len; i <= len; i++) {
        int codept = 0;
        Bitmap bm = null;
        if (hasTabs && i < len) {
            codept = buf[i];
        }
        if (codept >= 0xD800 && codept <= 0xDFFF && i < len) {
            codept = Character.codePointAt(buf, i);
            if (codept >= MIN_EMOJI && codept <= MAX_EMOJI) {
                bm = EMOJI_FACTORY.getBitmapFromAndroidPua(codept);
            }
        }
        if (i == len || codept == '\t' || bm != null) {
            workPaint.baselineShift = 0;
            h += Styled.measureText(paint, workPaint, text, start + here, start + i, fm);
            if (fm != null) {
                if (workPaint.baselineShift < 0) {
                    fm.ascent += workPaint.baselineShift;
                    fm.top += workPaint.baselineShift;
                } else {
                    fm.descent += workPaint.baselineShift;
                    fm.bottom += workPaint.baselineShift;
                }
            }
            if (i != len) {
                if (bm == null) {
                    h = nextTab(text, start, end, h, tabs);
                } else {
                    workPaint.set(paint);
                    Styled.measureText(paint, workPaint, text, start + i, start + i + 1, null);
                    float wid = (float) bm.getWidth() * -workPaint.ascent() / bm.getHeight();
                    h += wid;
                    i++;
                }
            }
            if (fm != null) {
                if (fm.ascent < ab) {
                    ab = fm.ascent;
                }
                if (fm.descent > be) {
                    be = fm.descent;
                }
                if (fm.top < top) {
                    top = fm.top;
                }
                if (fm.bottom > bot) {
                    bot = fm.bottom;
                }
            /*
                     * No need to take bitmap height into account here,
                     * since it is scaled to match the text height.
                     */
            }
            here = i + 1;
        }
    }
    if (fm != null) {
        fm.ascent = ab;
        fm.descent = be;
        fm.top = top;
        fm.bottom = bot;
    }
    if (hasTabs)
        TextUtils.recycle(buf);
    return h;
}","{
    char[] buf = null;
    if (hasTabs) {
        buf = TextUtils.obtain(end - start);
        TextUtils.getChars(text, start, end, buf, 0);
    }
    int len = end - start;
    int lastPos = 0;
    float width = 0;
    int ascent = 0, descent = 0, top = 0, bottom = 0;
    if (fm != null) {
        fm.ascent = 0;
        fm.descent = 0;
    }
    for (int pos = hasTabs ? 0 : len; pos <= len; pos++) {
        int codept = 0;
        Bitmap bm = null;
        if (hasTabs && pos < len) {
            codept = buf[pos];
        }
        if (codept >= 0xD800 && codept <= 0xDFFF && pos < len) {
            codept = Character.codePointAt(buf, pos);
            if (codept >= MIN_EMOJI && codept <= MAX_EMOJI) {
                bm = EMOJI_FACTORY.getBitmapFromAndroidPua(codept);
            }
        }
        if (pos == len || codept == '\t' || bm != null) {
            workPaint.baselineShift = 0;
            width += Styled.measureText(paint, workPaint, text, start + lastPos, start + pos, fm);
            if (fm != null) {
                if (workPaint.baselineShift < 0) {
                    fm.ascent += workPaint.baselineShift;
                    fm.top += workPaint.baselineShift;
                } else {
                    fm.descent += workPaint.baselineShift;
                    fm.bottom += workPaint.baselineShift;
                }
            }
            if (pos != len) {
                if (bm == null) {
                    // no emoji, must have hit a tab
                    width = nextTab(text, start, end, width, tabs);
                } else {
                    // This sets up workPaint with the font on the emoji
                    // text, so that we can extract the ascent and scale.
                    // We can't use the result of the previous call to
                    // measureText because the emoji might have its own style.
                    // We have to initialize workPaint here because if the
                    // text is unstyled measureText might not use workPaint
                    // at all.
                    workPaint.set(paint);
                    Styled.measureText(paint, workPaint, text, start + pos, start + pos + 1, null);
                    width += (float) bm.getWidth() * -workPaint.ascent() / bm.getHeight();
                    // Since we had an emoji, we bump past the second half
                    // of the surrogate pair.
                    pos++;
                }
            }
            if (fm != null) {
                if (fm.ascent < ascent) {
                    ascent = fm.ascent;
                }
                if (fm.descent > descent) {
                    descent = fm.descent;
                }
                if (fm.top < top) {
                    top = fm.top;
                }
                if (fm.bottom > bottom) {
                    bottom = fm.bottom;
                }
            // No need to take bitmap height into account here,
            // since it is scaled to match the text height.
            }
            lastPos = pos + 1;
        }
    }
    if (fm != null) {
        fm.ascent = ascent;
        fm.descent = descent;
        fm.top = top;
        fm.bottom = bottom;
    }
    if (hasTabs)
        TextUtils.recycle(buf);
    return width;
}",1,"/* package */
","/* package */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The change between the two versions is about the variable naming, which includes h to width, here to lastPos, ab to ascent, be to descent, etc., so the code change type is 4.","There is no compatibility issue in this scenario as only the variables have been renamed while logic, return statements, and exception handlings remain the same and as such do not affect the behavior of the method. Thus, the CI type is 0."
89,<android.net.Uri: String getQueryParameter(String)>,7,8,<android.net.Uri: String getQueryParameter(String)>,<android.net.Uri: String getQueryParameter(String)>,0,"{
    if (isOpaque()) {
        throw new UnsupportedOperationException(NOT_HIERARCHICAL);
    }
    String query = getEncodedQuery();
    if (query == null) {
        return null;
    }
    String encodedKey;
    try {
        encodedKey = URLEncoder.encode(key, DEFAULT_ENCODING);
    } catch (UnsupportedEncodingException e) {
        throw new AssertionError(e);
    }
    String prefix = encodedKey + ""="";
    if (query.length() < prefix.length()) {
        return null;
    }
    int start;
    if (query.startsWith(prefix)) {
        // It's the first parameter.
        start = prefix.length();
    } else {
        // It must be later in the query string.
        prefix = ""&"" + prefix;
        start = query.indexOf(prefix);
        if (start == -1) {
            // Not found.
            return null;
        }
        start += prefix.length();
    }
    // Find end of value.
    int end = query.indexOf('&', start);
    if (end == -1) {
        end = query.length();
    }
    String value = query.substring(start, end);
    return decode(value);
}","{
    if (isOpaque()) {
        throw new UnsupportedOperationException(NOT_HIERARCHICAL);
    }
    if (key == null) {
        throw new NullPointerException(""key"");
    }
    final String query = getEncodedQuery();
    if (query == null) {
        return null;
    }
    final String encodedKey = encode(key, null);
    final int encodedKeyLength = encodedKey.length();
    int encodedKeySearchIndex = 0;
    final int encodedKeySearchEnd = query.length() - (encodedKeyLength + 1);
    while (encodedKeySearchIndex <= encodedKeySearchEnd) {
        int keyIndex = query.indexOf(encodedKey, encodedKeySearchIndex);
        if (keyIndex == -1) {
            break;
        }
        final int equalsIndex = keyIndex + encodedKeyLength;
        if (equalsIndex >= query.length()) {
            break;
        }
        if (query.charAt(equalsIndex) != '=') {
            encodedKeySearchIndex = equalsIndex + 1;
            continue;
        }
        if (keyIndex == 0 || query.charAt(keyIndex - 1) == '&') {
            int end = query.indexOf('&', equalsIndex);
            if (end == -1) {
                end = query.length();
            }
            return decode(query.substring(equalsIndex + 1, end));
        } else {
            encodedKeySearchIndex = equalsIndex + 1;
        }
    }
    return null;
}",1,"/**
 * Searches the query string for the first value with the given key.
 *
 * @param key which will be encoded
 * @throws UnsupportedOperationException if this isn't a hierarchical URI
 * @throws NullPointerException if key is null
 *
 * @return the decoded value or null if no parameter is found
 */
","/**
 * Searches the query string for the first value with the given key.
 *
 * @param key which will be encoded
 * @throws UnsupportedOperationException if this isn't a hierarchical URI
 * @throws NullPointerException if key is null
 *
 * @return the decoded value or null if no parameter is found
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3,4",1,"The 'if' condition block of checking 'key == null' and the block for key searching and extracting the parameter value have been changed. Also, some individual lines such as the encoding method for 'key' have been changed. So the code change type is 1,3,4.","The newly added 'if' condition block and the changed strategy of searching key could potentially make the function return different values, so the CI type is 1."
91,"<android.content.ContentResolver: int update(Uri,ContentValues,String,String[])>",7,8,"<android.content.ContentResolver: int update(Uri,ContentValues,String,String[])>","<android.content.ContentResolver: int update(Uri,ContentValues,String,String[])>",0,"{
    IContentProvider provider = acquireProvider(uri);
    if (provider == null) {
        throw new IllegalArgumentException(""Unknown URI "" + uri);
    }
    try {
        return provider.update(uri, values, where, selectionArgs);
    } catch (RemoteException e) {
        return -1;
    } finally {
        releaseProvider(provider);
    }
}","{
    IContentProvider provider = acquireProvider(uri);
    if (provider == null) {
        throw new IllegalArgumentException(""Unknown URI "" + uri);
    }
    try {
        long startTime = SystemClock.uptimeMillis();
        int rowsUpdated = provider.update(uri, values, where, selectionArgs);
        long durationMillis = SystemClock.uptimeMillis() - startTime;
        maybeLogUpdateToEventLog(durationMillis, uri, ""update"", where);
        return rowsUpdated;
    } catch (RemoteException e) {
        return -1;
    } finally {
        releaseProvider(provider);
    }
}",1,"/**
 * Update row(s) in a content URI.
 *
 * If the content provider supports transactions the update will be atomic.
 *
 * @param uri The URI to modify.
 * @param values The new field values. The key is the column name for the field.
 * A null value will remove an existing field value.
 * @param where A filter to apply to rows before deleting, formatted as an SQL WHERE clause
 * (excluding the WHERE itself).
 * @return The number of rows updated.
 * @throws NullPointerException if uri or values are null
 */
","/**
 * Update row(s) in a content URI.
 *
 * If the content provider supports transactions the update will be atomic.
 *
 * @param uri The URI to modify.
 * @param values The new field values. The key is the column name for the field.
 * A null value will remove an existing field value.
 * @param where A filter to apply to rows before updating, formatted as an SQL WHERE clause
 * (excluding the WHERE itself).
 * @return The number of rows updated.
 * @throws NullPointerException if uri or values are null
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"Additional statements are added in the late version to possibly log the update operations, therefore, the code change type is 4.","The returned value and the thrown exception have not changed between the two versions. Thus, there is no Compatibility Issue, hence the CI type is 0."
93,<android.webkit.HTML5VideoViewProxy: void onCompletion(MediaPlayer)>,7,8,<android.webkit.HTML5VideoViewProxy: void onCompletion(MediaPlayer)>,<android.webkit.HTML5VideoViewProxy: void onCompletion(MediaPlayer)>,0,"{
    playbackEnded();
}","{
    // The video ended by itself, so we need to
    // send a message to the UI thread to dismiss
    // the video view and to return to the WebView.
    sendMessage(obtainMessage(ENDED));
}",1,"// MediaPlayer.OnCompletionListener;
","// MediaPlayer.OnCompletionListener;
",-1,,,-1,-1,-1,-1,-1,-1,4,1,"The method content changed (from 'playbackEnded()' to 'sendMessage(obtainMessage(ENDED))'), which falls under other statement changes. So, the code type change is 4.","The change in these methods could potentially lead to different behaviors, as the methods being called may return different values. Therefore, the CI type is 1."
94,<android.hardware.Camera.Parameters: List<Integer> getSupportedPreviewFormats()>,7,8,<android.hardware.Camera.Parameters: List<Integer> getSupportedPreviewFormats()>,<android.hardware.Camera.Parameters: List<Integer> getSupportedPreviewFormats()>,0,"{
    String str = get(KEY_PREVIEW_FORMAT + SUPPORTED_VALUES_SUFFIX);
    ArrayList<Integer> formats = new ArrayList<Integer>();
    for (String s : split(str)) {
        int f = pixelFormatForCameraFormat(s);
        if (f == PixelFormat.UNKNOWN)
            continue;
        formats.add(f);
    }
    return formats;
}","{
    String str = get(KEY_PREVIEW_FORMAT + SUPPORTED_VALUES_SUFFIX);
    ArrayList<Integer> formats = new ArrayList<Integer>();
    for (String s : split(str)) {
        int f = pixelFormatForCameraFormat(s);
        if (f == ImageFormat.UNKNOWN)
            continue;
        formats.add(f);
    }
    return formats;
}",1,"/**
 * Gets the supported preview formats.
 *
 * @return a List of Integer objects. This method will always return a
 * list with at least one element.
 */
","/**
 * Gets the supported preview formats.
 *
 * @return a list of supported preview formats. This method will always
 * return a list with at least one element.
 * @see android.graphics.ImageFormat
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"There are changes in the if statement where the checking constant has been changed from PixelFormat.UNKNOWN to ImageFormat.UNKNOWN and also a dependent API change (Dependent API PixelFormat.UNKNOWN to ImageFormat.UNKNOWN), so the code change type is 1,5.","As the condition in the if statement has changed, it could potentially return different values and thus the CI type is 1."
95,<android.view.SurfaceView: void onDetachedFromWindow()>,7,8,<android.view.SurfaceView: void onDetachedFromWindow()>,<android.view.SurfaceView: void onDetachedFromWindow()>,0,"{
    mRequestedVisible = false;
    updateWindow(false);
    mHaveFrame = false;
    if (mWindow != null) {
        try {
            mSession.remove(mWindow);
        } catch (RemoteException ex) {
        }
        mWindow = null;
    }
    mSession = null;
    mLayout.token = null;
    super.onDetachedFromWindow();
}","{
    getViewTreeObserver().removeOnScrollChangedListener(mScrollChangedListener);
    mRequestedVisible = false;
    updateWindow(false);
    mHaveFrame = false;
    if (mWindow != null) {
        try {
            mSession.remove(mWindow);
        } catch (RemoteException ex) {
        }
        mWindow = null;
    }
    mSession = null;
    mLayout.token = null;
    super.onDetachedFromWindow();
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"There is only one additional statement: `getViewTreeObserver().removeOnScrollChangedListener(mScrollChangedListener);` which seems to remove some listeners from the view tree observer. Therefore, I would argue that the change type is 4.","The additional statement should not change the behaviour of the original code, and thus it theoretically won't cause a compatibility issue on its own. So, the CI type is 0."
96,<android.view.WindowOrientationListener.SensorEventListenerImpl: void onSensorChanged(SensorEvent)>,7,8,<android.view.WindowOrientationListener.SensorEventListenerImpl: void onSensorChanged(SensorEvent)>,<android.view.WindowOrientationListener.SensorEventListenerImpl: void onSensorChanged(SensorEvent)>,0,"{
    float[] values = event.values;
    float X = values[_DATA_X];
    float Y = values[_DATA_Y];
    float Z = values[_DATA_Z];
    float OneEightyOverPi = 57.29577957855f;
    float gravity = (float) Math.sqrt(X * X + Y * Y + Z * Z);
    float zyangle = (float) Math.asin(Z / gravity) * OneEightyOverPi;
    int rotation = -1;
    if ((zyangle <= PIVOT_UPPER) && (zyangle >= PIVOT_LOWER)) {
        // Check orientation only if the phone is flat enough
        // Don't trust the angle if the magnitude is small compared to the y value
        float angle = (float) Math.atan2(Y, -X) * OneEightyOverPi;
        int orientation = 90 - (int) Math.round(angle);
        // normalize to 0 - 359 range
        while (orientation >= 360) {
            orientation -= 360;
        }
        while (orientation < 0) {
            orientation += 360;
        }
        // the threshold gets set linearly around PIVOT.
        if ((orientation >= PL_LOWER) && (orientation <= LP_UPPER)) {
            float threshold;
            float delta = zyangle - PIVOT;
            if (mSensorRotation == Surface.ROTATION_90) {
                if (delta < 0) {
                    // Delta is negative
                    threshold = LP_LOWER - (LP_LF_LOWER * delta);
                } else {
                    threshold = LP_LOWER + (LP_LF_UPPER * delta);
                }
                rotation = (orientation >= threshold) ? Surface.ROTATION_0 : Surface.ROTATION_90;
            } else {
                if (delta < 0) {
                    // Delta is negative
                    threshold = PL_UPPER + (PL_LF_LOWER * delta);
                } else {
                    threshold = PL_UPPER - (PL_LF_UPPER * delta);
                }
                rotation = (orientation <= threshold) ? Surface.ROTATION_90 : Surface.ROTATION_0;
            }
        } else if ((orientation >= LANDSCAPE_LOWER) && (orientation < LP_LOWER)) {
            rotation = Surface.ROTATION_90;
        } else if ((orientation >= PL_UPPER) || (orientation <= PORTRAIT_LOWER)) {
            rotation = Surface.ROTATION_0;
        }
        if ((rotation != -1) && (rotation != mSensorRotation)) {
            mSensorRotation = rotation;
            onOrientationChanged(mSensorRotation);
        }
    }
}","{
    // the vector given in the SensorEvent points straight up (towards the sky) under ideal
    // conditions (the phone is not accelerating).  i'll call this upVector elsewhere.
    float x = event.values[_DATA_X];
    float y = event.values[_DATA_Y];
    float z = event.values[_DATA_Z];
    float magnitude = vectorMagnitude(x, y, z);
    float deviation = Math.abs(magnitude - SensorManager.STANDARD_GRAVITY);
    float tiltAngle = tiltAngle(z, magnitude);
    float alpha = DEFAULT_LOWPASS_ALPHA;
    if (tiltAngle > MAX_TILT) {
        return;
    } else if (deviation > MAX_DEVIATION_FROM_GRAVITY) {
        alpha = ACCELERATING_LOWPASS_ALPHA;
    } else if (tiltAngle > PARTIAL_TILT) {
        alpha = TILTED_LOWPASS_ALPHA;
    }
    x = mFilteredVector[0] = lowpassFilter(x, mFilteredVector[0], alpha);
    y = mFilteredVector[1] = lowpassFilter(y, mFilteredVector[1], alpha);
    z = mFilteredVector[2] = lowpassFilter(z, mFilteredVector[2], alpha);
    magnitude = vectorMagnitude(x, y, z);
    tiltAngle = tiltAngle(z, magnitude);
    // Angle between the x-y projection of upVector and the +y-axis, increasing
    // counter-clockwise.
    // 0 degrees = speaker end towards the sky
    // 90 degrees = left edge of device towards the sky
    float orientationAngle = (float) Math.atan2(-x, y) * RADIANS_TO_DEGREES;
    int orientation = Math.round(orientationAngle);
    // atan2 returns (-180, 180]; normalize to [0, 360)
    if (orientation < 0) {
        orientation += 360;
    }
    calculateNewRotation(orientation, Math.round(tiltAngle));
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"1,3,4",0,"The control flow and the logic of how the method works have fundamentally changed. Several lines of code have been removed and new lines have been inserted. The specific implementation details and methods called within the implementation have been changed, that includes a new return statement being introduced and significant changes in the control flow with a new 'else if' condition. So, the code change type is 1,3,4.","Although the code underwent a significant change, there isn't any CI. The method originally has no explicit return type and thus, doesn't provide any output or throw exceptions. After the changes, it still maintains this behavior, it doesn't return any values or throw exceptions that could cause compatibility issues. The changes are internal and should not affect how the method is used in applications, hence, no compatibility issue exists."
97,"<android.widget.ListView: int measureHeightOfChildren(int,int,int,int,int)>",7,8,"<android.widget.ListView: int measureHeightOfChildren(int,int,int,int,int)>","<android.widget.ListView: int measureHeightOfChildren(int,int,int,int,int)>",0,"{
    final ListAdapter adapter = mAdapter;
    if (adapter == null) {
        return mListPadding.top + mListPadding.bottom;
    }
    // Include the padding of the list
    int returnedHeight = mListPadding.top + mListPadding.bottom;
    final int dividerHeight = ((mDividerHeight > 0) && mDivider != null) ? mDividerHeight : 0;
    // The previous height value that was less than maxHeight and contained
    // no partial children
    int prevHeightWithoutPartialChild = 0;
    int i;
    View child;
    // mItemCount - 1 since endPosition parameter is inclusive
    endPosition = (endPosition == NO_POSITION) ? adapter.getCount() - 1 : endPosition;
    final AbsListView.RecycleBin recycleBin = mRecycler;
    final boolean recyle = recycleOnMeasure();
    for (i = startPosition; i <= endPosition; ++i) {
        child = obtainView(i);
        measureScrapChild(child, i, widthMeasureSpec);
        if (i > 0) {
            // Count the divider for all but one child
            returnedHeight += dividerHeight;
        }
        // Recycle the view before we possibly return from the method
        if (recyle) {
            recycleBin.addScrapView(child);
        }
        returnedHeight += child.getMeasuredHeight();
        if (returnedHeight >= maxHeight) {
            // then the i'th position did not fit completely.
            return // Disallowing is enabled (> -1)
            (disallowPartialChildPosition >= 0) && // We've past the min pos
            (i > disallowPartialChildPosition) && // We have a prev height
            (prevHeightWithoutPartialChild > 0) && // i'th child did not fit completely
            (returnedHeight != maxHeight) ? prevHeightWithoutPartialChild : maxHeight;
        }
        if ((disallowPartialChildPosition >= 0) && (i >= disallowPartialChildPosition)) {
            prevHeightWithoutPartialChild = returnedHeight;
        }
    }
    // completely fit, so return the returnedHeight
    return returnedHeight;
}","{
    final ListAdapter adapter = mAdapter;
    if (adapter == null) {
        return mListPadding.top + mListPadding.bottom;
    }
    // Include the padding of the list
    int returnedHeight = mListPadding.top + mListPadding.bottom;
    final int dividerHeight = ((mDividerHeight > 0) && mDivider != null) ? mDividerHeight : 0;
    // The previous height value that was less than maxHeight and contained
    // no partial children
    int prevHeightWithoutPartialChild = 0;
    int i;
    View child;
    // mItemCount - 1 since endPosition parameter is inclusive
    endPosition = (endPosition == NO_POSITION) ? adapter.getCount() - 1 : endPosition;
    final AbsListView.RecycleBin recycleBin = mRecycler;
    final boolean recyle = recycleOnMeasure();
    final boolean[] isScrap = mIsScrap;
    for (i = startPosition; i <= endPosition; ++i) {
        child = obtainView(i, isScrap);
        measureScrapChild(child, i, widthMeasureSpec);
        if (i > 0) {
            // Count the divider for all but one child
            returnedHeight += dividerHeight;
        }
        // Recycle the view before we possibly return from the method
        if (recyle && recycleBin.shouldRecycleViewType(((LayoutParams) child.getLayoutParams()).viewType)) {
            recycleBin.addScrapView(child);
        }
        returnedHeight += child.getMeasuredHeight();
        if (returnedHeight >= maxHeight) {
            // then the i'th position did not fit completely.
            return // Disallowing is enabled (> -1)
            (disallowPartialChildPosition >= 0) && // We've past the min pos
            (i > disallowPartialChildPosition) && // We have a prev height
            (prevHeightWithoutPartialChild > 0) && // i'th child did not fit completely
            (returnedHeight != maxHeight) ? prevHeightWithoutPartialChild : maxHeight;
        }
        if ((disallowPartialChildPosition >= 0) && (i >= disallowPartialChildPosition)) {
            prevHeightWithoutPartialChild = returnedHeight;
        }
    }
    // completely fit, so return the returnedHeight
    return returnedHeight;
}",1,"/**
 * Measures the height of the given range of children (inclusive) and
 * returns the height with this ListView's padding and divider heights
 * included. If maxHeight is provided, the measuring will stop when the
 * current height reaches maxHeight.
 *
 * @param widthMeasureSpec The width measure spec to be given to a child's
 * {@link View#measure(int, int)}.
 * @param startPosition The position of the first child to be shown.
 * @param endPosition The (inclusive) position of the last child to be
 * shown. Specify {@link #NO_POSITION} if the last child should be
 * the last available child from the adapter.
 * @param maxHeight The maximum height that will be returned (if all the
 * children don't fit in this value, this value will be
 * returned).
 * @param disallowPartialChildPosition In general, whether the returned
 * height should only contain entire children. This is more
 * powerful--it is the first inclusive position at which partial
 * children will not be allowed. Example: it looks nice to have
 * at least 3 completely visible children, and in portrait this
 * will most likely fit; but in landscape there could be times
 * when even 2 children can not be completely shown, so a value
 * of 2 (remember, inclusive) would be good (assuming
 * startPosition is 0).
 * @return The height of this ListView with the given children.
 */
","/**
 * Measures the height of the given range of children (inclusive) and
 * returns the height with this ListView's padding and divider heights
 * included. If maxHeight is provided, the measuring will stop when the
 * current height reaches maxHeight.
 *
 * @param widthMeasureSpec The width measure spec to be given to a child's
 * {@link View#measure(int, int)}.
 * @param startPosition The position of the first child to be shown.
 * @param endPosition The (inclusive) position of the last child to be
 * shown. Specify {@link #NO_POSITION} if the last child should be
 * the last available child from the adapter.
 * @param maxHeight The maximum height that will be returned (if all the
 * children don't fit in this value, this value will be
 * returned).
 * @param disallowPartialChildPosition In general, whether the returned
 * height should only contain entire children. This is more
 * powerful--it is the first inclusive position at which partial
 * children will not be allowed. Example: it looks nice to have
 * at least 3 completely visible children, and in portrait this
 * will most likely fit; but in landscape there could be times
 * when even 2 children can not be completely shown, so a value
 * of 2 (remember, inclusive) would be good (assuming
 * startPosition is 0).
 * @return The height of this ListView with the given children.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",1,"The API parameters of obtainView(i, isScrap) and recycleBin.addScrapView(child) have changed, and the boolean array 'isScrap' is introduced, so the code change type is 4,5.","The change in the dependent APIs (obtainView and addScrapView) and other code change can potentially result in the method returning a different value, so the CI type is 1."
98,<android.database.sqlite.SQLiteStatement: long executeInsert()>,7,8,<android.database.sqlite.SQLiteStatement: long executeInsert()>,<android.database.sqlite.SQLiteStatement: long executeInsert()>,0,"{
    mDatabase.lock();
    boolean logStats = mDatabase.mLogStats;
    long startTime = logStats ? SystemClock.elapsedRealtime() : 0;
    acquireReference();
    try {
        if (SQLiteDebug.DEBUG_SQL_STATEMENTS) {
            Log.v(TAG, ""executeInsert() for ["" + mSql + ""]"");
        }
        native_execute();
        if (logStats) {
            mDatabase.logTimeStat(false, /* write */
            startTime, SystemClock.elapsedRealtime());
        }
        return mDatabase.lastInsertRow();
    } finally {
        releaseReference();
        mDatabase.unlock();
    }
}","{
    if (!mDatabase.isOpen()) {
        throw new IllegalStateException(""database "" + mDatabase.getPath() + "" already closed"");
    }
    long timeStart = SystemClock.uptimeMillis();
    mDatabase.lock();
    acquireReference();
    try {
        native_execute();
        mDatabase.logTimeStat(mSql, timeStart);
        return (mDatabase.lastChangeCount() > 0) ? mDatabase.lastInsertRow() : -1;
    } finally {
        releaseReference();
        mDatabase.unlock();
    }
}",1,"/**
 * Execute this SQL statement and return the ID of the most
 * recently inserted row.  The SQL statement should probably be an
 * INSERT for this to be a useful call.
 *
 * @return the row ID of the last row inserted.
 *
 * @throws android.database.SQLException If the SQL string is invalid for
 * some reason
 */
","/**
 * Execute this SQL statement and return the ID of the row inserted due to this call.
 * The SQL statement should be an INSERT for this to be a useful call.
 *
 * @return the row ID of the last row inserted, if this insert is successful. -1 otherwise.
 *
 * @throws android.database.SQLException If the SQL string is invalid for
 * some reason
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3,4","1,2",There are multiple changes made in the late version implementation of the method.,3) A conditional statement is added with return where the value for return has changed.
99,<android.webkit.WebView: void onDetachedFromWindow()>,7,8,<android.webkit.WebView: void onDetachedFromWindow()>,<android.webkit.WebView: void onDetachedFromWindow()>,0,"{
    super.onDetachedFromWindow();
    ViewParent parent = getParent();
    if (parent instanceof ViewGroup) {
        ViewGroup p = (ViewGroup) parent;
        p.setOnHierarchyChangeListener(null);
    }
    // Clean up the zoom controller
    mZoomButtonsController.setVisible(false);
}","{
    clearTextEntry(false);
    dismissZoomControl();
    if (hasWindowFocus())
        setActive(false);
    super.onDetachedFromWindow();
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,4",1,"The previous version had calls to setOnHierarchyChangeListener and setVisible methods, which have been replaced in the new version with calls to clearTextEntry, dismissZoomControl and setActive methods. Also, the order of calling super method has changed too, which can be regarded as the change of return statement. Thus, the code change type is 1,4.","Since the method calls have been radically changed and the order of calling the super method has been adjusted, the return or the effect of the method when being called may notably differ between versions. Hence, the CI type is 1."
101,<android.widget.ListView: long[] getCheckItemIds()>,7,8,<android.widget.ListView: long[] getCheckItemIds()>,<android.widget.ListView: long[] getCheckItemIds()>,0,"{
    if (mChoiceMode != CHOICE_MODE_NONE && mCheckStates != null && mAdapter != null) {
        final SparseBooleanArray states = mCheckStates;
        final int count = states.size();
        final long[] ids = new long[count];
        final ListAdapter adapter = mAdapter;
        for (int i = 0; i < count; i++) {
            ids[i] = adapter.getItemId(states.keyAt(i));
        }
        return ids;
    }
    return new long[0];
}","{
    // Use new behavior that correctly handles stable ID mapping.
    if (mAdapter != null && mAdapter.hasStableIds()) {
        return getCheckedItemIds();
    }
    // Fall back to it to support legacy apps.
    if (mChoiceMode != CHOICE_MODE_NONE && mCheckStates != null && mAdapter != null) {
        final SparseBooleanArray states = mCheckStates;
        final int count = states.size();
        final long[] ids = new long[count];
        final ListAdapter adapter = mAdapter;
        int checkedCount = 0;
        for (int i = 0; i < count; i++) {
            if (states.valueAt(i)) {
                ids[checkedCount++] = adapter.getItemId(states.keyAt(i));
            }
        }
        // resulting in checkedCount being smaller than count.
        if (checkedCount == count) {
            return ids;
        } else {
            final long[] result = new long[checkedCount];
            System.arraycopy(ids, 0, result, 0, checkedCount);
            return result;
        }
    }
    return new long[0];
}",1,"/**
 * Returns the set of checked items ids. The result is only valid if
 * the choice mode has not been set to {@link #CHOICE_MODE_SINGLE}.
 *
 * @return A new array which contains the id of each checked item in the list.
 */
","/**
 * Returns the set of checked items ids. The result is only valid if the
 * choice mode has not been set to {@link #CHOICE_MODE_NONE}.
 *
 * @return A new array which contains the id of each checked item in the
 * list.
 *
 * @deprecated Use {@link #getCheckedItemIds()} instead.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3,4",1,"In the late implementation, it introduces a condition check (if (mAdapter != null && mAdapter.hasStableIds())) and changed the existing 'for' loop control, and has modified the values to be returned (return getCheckedItemIds(); and return result;). Therefore, the change falls under categories 1,3,4.","Due to the introduced condition check and the modification of the 'for' loop and the return values, the API will potentially return different values in the late version, thus it is a compatibility issue of type 1."
103,"<android.accounts.AccountManager: boolean addAccountExplicitly(Account,String,Bundle)>",7,8,"<android.accounts.AccountManager: boolean addAccountExplicitly(Account,String,Bundle)>","<android.accounts.AccountManager: boolean addAccountExplicitly(Account,String,Bundle)>",0,"{
    try {
        return mService.addAccount(account, password, userdata);
    } catch (RemoteException e) {
        // won't ever happen
        throw new RuntimeException(e);
    }
}","{
    if (account == null)
        throw new IllegalArgumentException(""account is null"");
    try {
        return mService.addAccount(account, password, userdata);
    } catch (RemoteException e) {
        // won't ever happen
        throw new RuntimeException(e);
    }
}",1,"/**
 * Add an account to the AccountManager's set of known accounts.
 * <p>
 * Requires that the caller has permission
 * {@link android.Manifest.permission#AUTHENTICATE_ACCOUNTS} and is running
 * with the same UID as the Authenticator for the account.
 * @param account The account to add
 * @param password The password to associate with the account. May be null.
 * @param userdata A bundle of key/value pairs to set as the account's userdata. May be null.
 * @return true if the account was sucessfully added, false otherwise, for example,
 * if the account already exists or if the account is null
 */
","/**
 * Adds an account directly to the AccountManager.  Normally used by sign-up
 * wizards associated with authenticators, not directly by applications.
 *
 * <p>It is safe to call this method from the main thread.
 *
 * <p>This method requires the caller to hold the permission
 * {@link android.Manifest.permission#AUTHENTICATE_ACCOUNTS}
 * and to have the same UID as the added account's authenticator.
 *
 * @param account The {@link Account} to add
 * @param password The password to associate with the account, null for none
 * @param userdata String values to use for the account's userdata, null for none
 * @return Whether the account was successfully added.  False if the account
 * already exists, the account is null, or another error occurs.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,3","1,2","The late implementation has added an 'if' control statement which checks if the 'account' parameter is null or not, and a new exception throw statement (IllegalArgumentException) is introduced as well. Thus, the code change types are 2,3.","With the addition of the 'if' statement in the late version, the API now potentially throws an IllegalArgumentException and may return earlier without executing the try-catch block. Therefore, this could cause potentially different return values or types and potential different exception handlings, which leads to CI types 1,2."
105,<android.widget.HorizontalScrollView: boolean dispatchKeyEvent(KeyEvent)>,7,8,<android.widget.HorizontalScrollView: boolean dispatchKeyEvent(KeyEvent)>,<android.widget.HorizontalScrollView: boolean dispatchKeyEvent(KeyEvent)>,0,"{
    // Let the focused view and/or our descendants get the key first
    boolean handled = super.dispatchKeyEvent(event);
    if (handled) {
        return true;
    }
    return executeKeyEvent(event);
}","{
    // Let the focused view and/or our descendants get the key first
    return super.dispatchKeyEvent(event) || executeKeyEvent(event);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"The control flow of code has been modified. Instead of checking if super.dispatchKeyEvent(event) returns true and then returning true, the later implementation directly returns the logical OR result of super.dispatchKeyEvent(event) and executeKeyEvent(event). However, the actual function of the API remains the same. So, the code change type is 4.","Despite the simplification in control flow, the logic remains the same. The return values are unaffected, and this change doesn't introduce new exceptions. Therefore, there are no Compatibility Issues."
106,<android.webkit.WebView: void touchUpOnTextField(MotionEvent)>,7,8,<android.webkit.WebView: void touchUpOnTextField(MotionEvent)>,<android.webkit.WebView: void touchUpOnTextField(MotionEvent)>,0,"{
    if (!inEditingMode()) {
        return;
    }
    int x = viewToContentX((int) event.getX() + mWebTextView.getLeft());
    int y = viewToContentY((int) event.getY() + mWebTextView.getTop());
    // In case the soft keyboard has been dismissed, bring it back up.
    InputMethodManager.getInstance(getContext()).showSoftInput(mWebTextView, 0);
    if (nativeFocusNodePointer() != nativeCursorNodePointer()) {
        nativeMotionUp(x, y, mNavSlop);
    }
    nativeTextInputMotionUp(x, y);
}","{
    if (!inEditingMode()) {
        return;
    }
    int x = viewToContentX((int) event.getX() + mWebTextView.getLeft());
    int y = viewToContentY((int) event.getY() + mWebTextView.getTop());
    nativeMotionUp(x, y, mNavSlop);
}",1,"/*package*/
","/*package*/
",-1,,,-1,-1,-1,-1,-1,-1,"1,4",1,"There is a removal of two function calls: ""InputMethodManager.getInstance(getContext()).showSoftInput(mWebTextView, 0);"" and ""nativeTextInputMotionUp(x, y);"" and a removal of condition statement ""if (nativeFocusNodePointer() != nativeCursorNodePointer())"". Therefore, the change types are 1,4.","Due to the removal of function calls and conditional statement, the behavior of the late version could be different from the early version. The function could potentially return at a different point in the code or behave differently due to the absence of the called APIs and condition check. So, the compatibility issue type is 1."
107,<android.database.sqlite.SQLiteProgram: void close()>,7,8,<android.database.sqlite.SQLiteProgram: void close()>,<android.database.sqlite.SQLiteProgram: void close()>,0,"{
    mDatabase.lock();
    try {
        releaseReference();
    } finally {
        mDatabase.unlock();
    }
}","{
    if (!mDatabase.isOpen()) {
        return;
    }
    mDatabase.lock();
    try {
        releaseReference();
    } finally {
        mDatabase.unlock();
    }
}",1,"/**
 * Release this program's resources, making it invalid.
 */
","/**
 * Release this program's resources, making it invalid.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,1",1,"There is an introduced 'if' conditional statement before the existing logic in late implementation. And a new return statement is introduced inside that 'if' logic. Therefore, the code change type is 3,1.","The API in the later version could potentially return nothing while the early version API does not have such behavior. This change might cause inconsistent behaviours between the two versions; thus, the compatibility issue detected is 1."
108,"<android.server.BluetoothService: boolean fetchRemoteUuids(String,ParcelUuid,IBluetoothCallback)>",7,8,"<android.server.BluetoothService: boolean fetchRemoteUuids(String,ParcelUuid,IBluetoothCallback)>","<android.server.BluetoothService: boolean fetchRemoteUuids(String,ParcelUuid,IBluetoothCallback)>",0,"{
    mContext.enforceCallingOrSelfPermission(BLUETOOTH_PERM, ""Need BLUETOOTH permission"");
    if (!isEnabledInternal())
        return false;
    if (!BluetoothAdapter.checkBluetoothAddress(address)) {
        return false;
    }
    RemoteService service = new RemoteService(address, uuid);
    if (uuid != null && mUuidCallbackTracker.get(service) != null) {
        // Do not add this callback for the uuid
        return false;
    }
    if (mUuidIntentTracker.contains(address)) {
        // Add this uuid onto the in-progress SDP query
        if (uuid != null) {
            mUuidCallbackTracker.put(new RemoteService(address, uuid), callback);
        }
        return true;
    }
    boolean ret;
    if (getBondState(address) == BluetoothDevice.BOND_BONDED) {
        String path = getObjectPathFromAddress(address);
        if (path == null)
            return false;
        // Use an empty string for the UUID pattern
        ret = discoverServicesNative(path, """");
    } else {
        ret = createDeviceNative(address);
    }
    mUuidIntentTracker.add(address);
    if (uuid != null) {
        mUuidCallbackTracker.put(new RemoteService(address, uuid), callback);
    }
    Message message = mHandler.obtainMessage(MESSAGE_UUID_INTENT);
    message.obj = address;
    mHandler.sendMessageDelayed(message, UUID_INTENT_DELAY);
    return ret;
}","{
    mContext.enforceCallingOrSelfPermission(BLUETOOTH_PERM, ""Need BLUETOOTH permission"");
    if (!isEnabledInternal())
        return false;
    if (!BluetoothAdapter.checkBluetoothAddress(address)) {
        return false;
    }
    RemoteService service = new RemoteService(address, uuid);
    if (uuid != null && mUuidCallbackTracker.get(service) != null) {
        // Do not add this callback for the uuid
        return false;
    }
    if (mUuidIntentTracker.contains(address)) {
        // Add this uuid onto the in-progress SDP query
        if (uuid != null) {
            mUuidCallbackTracker.put(new RemoteService(address, uuid), callback);
        }
        return true;
    }
    boolean ret;
    // NULL, else create the device and then do SDP.
    if (isRemoteDeviceInCache(address) && getRemoteUuids(address) != null) {
        String path = getObjectPathFromAddress(address);
        if (path == null)
            return false;
        // Use an empty string for the UUID pattern
        ret = discoverServicesNative(path, """");
    } else {
        ret = createDeviceNative(address);
    }
    mUuidIntentTracker.add(address);
    if (uuid != null) {
        mUuidCallbackTracker.put(new RemoteService(address, uuid), callback);
    }
    Message message = mHandler.obtainMessage(MESSAGE_UUID_INTENT);
    message.obj = address;
    mHandler.sendMessageDelayed(message, UUID_INTENT_DELAY);
    return ret;
}",1,"/**
 * Connect and fetch new UUID's using SDP.
 * The UUID's found are broadcast as intents.
 * Optionally takes a uuid and callback to fetch the RFCOMM channel for the
 * a given uuid.
 * TODO: Don't wait UUID_INTENT_DELAY to broadcast UUID intents on success
 * TODO: Don't wait UUID_INTENT_DELAY to handle the failure case for
 * callback and broadcast intents.
 */
","/**
 * Connect and fetch new UUID's using SDP.
 * The UUID's found are broadcast as intents.
 * Optionally takes a uuid and callback to fetch the RFCOMM channel for the
 * a given uuid.
 * TODO: Don't wait UUID_INTENT_DELAY to broadcast UUID intents on success
 * TODO: Don't wait UUID_INTENT_DELAY to handle the failure case for
 * callback and broadcast intents.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",1,"The condition for the 'if' control statement, 'getBondState(address) == BluetoothDevice.BOND_BONDED' in the early version has changed to 'isRemoteDeviceInCache(address) && getRemoteUuids(address) != null' in the late version. Hence, the code change type is 3. Additionally, there is a change in another API getBondState which the current implementation relies on, changing to isRemoteDeviceInCache and getRemoteUuids, so also code change type 4.","With the change in the condition for the if control statement, there might be a difference in returned values, giving us a CI of type 1."
110,"<android.view.View: boolean onKeyUp(int,KeyEvent)>",7,8,"<android.view.View: boolean onKeyUp(int,KeyEvent)>","<android.view.View: boolean onKeyUp(int,KeyEvent)>",0,"{
    boolean result = false;
    switch(keyCode) {
        case KeyEvent.KEYCODE_DPAD_CENTER:
        case KeyEvent.KEYCODE_ENTER:
            {
                if ((mViewFlags & ENABLED_MASK) == DISABLED) {
                    return true;
                }
                if ((mViewFlags & CLICKABLE) == CLICKABLE && isPressed()) {
                    setPressed(false);
                    if (!mHasPerformedLongPress) {
                        // This is a tap, so remove the longpress check
                        if (mPendingCheckForLongPress != null) {
                            removeCallbacks(mPendingCheckForLongPress);
                        }
                        result = performClick();
                    }
                }
                break;
            }
    }
    return result;
}","{
    boolean result = false;
    switch(keyCode) {
        case KeyEvent.KEYCODE_DPAD_CENTER:
        case KeyEvent.KEYCODE_ENTER:
            {
                if ((mViewFlags & ENABLED_MASK) == DISABLED) {
                    return true;
                }
                if ((mViewFlags & CLICKABLE) == CLICKABLE && isPressed()) {
                    setPressed(false);
                    if (!mHasPerformedLongPress) {
                        // This is a tap, so remove the longpress check
                        removeLongPressCallback();
                        result = performClick();
                    }
                }
                break;
            }
    }
    return result;
}",1,"/**
 * Default implementation of {@link KeyEvent.Callback#onKeyMultiple(int, int, KeyEvent)
 * KeyEvent.Callback.onKeyMultiple()}: perform clicking of the view
 * when {@link KeyEvent#KEYCODE_DPAD_CENTER} or
 * {@link KeyEvent#KEYCODE_ENTER} is released.
 *
 * @param keyCode A key code that represents the button pressed, from
 * {@link android.view.KeyEvent}.
 * @param event   The KeyEvent object that defines the button action.
 */
","/**
 * Default implementation of {@link KeyEvent.Callback#onKeyMultiple(int, int, KeyEvent)
 * KeyEvent.Callback.onKeyMultiple()}: perform clicking of the view
 * when {@link KeyEvent#KEYCODE_DPAD_CENTER} or
 * {@link KeyEvent#KEYCODE_ENTER} is released.
 *
 * @param keyCode A key code that represents the button pressed, from
 * {@link android.view.KeyEvent}.
 * @param event   The KeyEvent object that defines the button action.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",1,"The method invoked inside the if statement has changed from removeCallbacks(mPendingCheckForLongPress) to removeLongPressCallback() so the code change type is 4,5.","Since the method removeLongPressCallback() may behaves differently compared to removeCallbacks(mPendingCheckForLongPress), this change on implementation can potentially make returned variable 'result' different from the previous version. This leads to a potential incompatibility issue in the term of returning different values or types. So the CI type is 1."
111,<android.app.ActivityThread.Idler: boolean queueIdle()>,7,8,<android.app.ActivityThread.Idler: boolean queueIdle()>,<android.app.ActivityThread.Idler: boolean queueIdle()>,0,"{
    ActivityRecord a = mNewActivities;
    if (a != null) {
        mNewActivities = null;
        IActivityManager am = ActivityManagerNative.getDefault();
        ActivityRecord prev;
        do {
            if (localLOGV)
                Log.v(TAG, ""Reporting idle of "" + a + "" finished="" + (a.activity != null ? a.activity.mFinished : false));
            if (a.activity != null && !a.activity.mFinished) {
                try {
                    am.activityIdle(a.token, a.createdConfig);
                    a.createdConfig = null;
                } catch (RemoteException ex) {
                }
            }
            prev = a;
            a = a.nextIdle;
            prev.nextIdle = null;
        } while (a != null);
    }
    return false;
}","{
    ActivityRecord a = mNewActivities;
    if (a != null) {
        mNewActivities = null;
        IActivityManager am = ActivityManagerNative.getDefault();
        ActivityRecord prev;
        do {
            if (localLOGV)
                Slog.v(TAG, ""Reporting idle of "" + a + "" finished="" + (a.activity != null ? a.activity.mFinished : false));
            if (a.activity != null && !a.activity.mFinished) {
                try {
                    am.activityIdle(a.token, a.createdConfig);
                    a.createdConfig = null;
                } catch (RemoteException ex) {
                }
            }
            prev = a;
            a = a.nextIdle;
            prev.nextIdle = null;
        } while (a != null);
    }
    ensureJitEnabled();
    return false;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"1,4",0,"A new method called 'ensureJitEnabled()' is added and also the statement 'Log.v()' has been changed to 'Slog.v()', so the change type is 1,4.","These changes modify only logging and inner workings of the API but not its behaviour or output. The return value and exception handling remain constant, so there is no Compatibility Issue (0)."
112,"<android.widget.PopupWindow: void showAsDropDown(View,int,int)>",7,8,"<android.widget.PopupWindow: void showAsDropDown(View,int,int)>","<android.widget.PopupWindow: void showAsDropDown(View,int,int)>",0,"{
    if (isShowing() || mContentView == null) {
        return;
    }
    registerForScrollChanged(anchor, xoff, yoff);
    mIsShowing = true;
    mIsDropdown = true;
    WindowManager.LayoutParams p = createPopupLayout(anchor.getWindowToken());
    preparePopup(p);
    mAboveAnchor = findDropDownPosition(anchor, p, xoff, yoff);
    if (mBackground != null) {
        // do the job.
        if (mAboveAnchorBackgroundDrawable != null) {
            if (mAboveAnchor) {
                mPopupView.setBackgroundDrawable(mAboveAnchorBackgroundDrawable);
            } else {
                mPopupView.setBackgroundDrawable(mBelowAnchorBackgroundDrawable);
            }
        } else {
            mPopupView.refreshDrawableState();
        }
    }
    if (mHeightMode < 0)
        p.height = mLastHeight = mHeightMode;
    if (mWidthMode < 0)
        p.width = mLastWidth = mWidthMode;
    p.windowAnimations = computeAnimationResource();
    invokePopup(p);
}","{
    if (isShowing() || mContentView == null) {
        return;
    }
    registerForScrollChanged(anchor, xoff, yoff);
    mIsShowing = true;
    mIsDropdown = true;
    WindowManager.LayoutParams p = createPopupLayout(anchor.getWindowToken());
    preparePopup(p);
    updateAboveAnchor(findDropDownPosition(anchor, p, xoff, yoff));
    if (mHeightMode < 0)
        p.height = mLastHeight = mHeightMode;
    if (mWidthMode < 0)
        p.width = mLastWidth = mWidthMode;
    p.windowAnimations = computeAnimationResource();
    invokePopup(p);
}",1,"/**
 * <p>Display the content view in a popup window anchored to the bottom-left
 * corner of the anchor view offset by the specified x and y coordinates.
 * If there is not enough room on screen to show
 * the popup in its entirety, this method tries to find a parent scroll
 * view to scroll. If no parent scroll view can be scrolled, the bottom-left
 * corner of the popup is pinned at the top left corner of the anchor view.</p>
 * <p>If the view later scrolls to move <code>anchor</code> to a different
 * location, the popup will be moved correspondingly.</p>
 *
 * @param anchor the view on which to pin the popup window
 *
 * @see #dismiss()
 */
","/**
 * <p>Display the content view in a popup window anchored to the bottom-left
 * corner of the anchor view offset by the specified x and y coordinates.
 * If there is not enough room on screen to show
 * the popup in its entirety, this method tries to find a parent scroll
 * view to scroll. If no parent scroll view can be scrolled, the bottom-left
 * corner of the popup is pinned at the top left corner of the anchor view.</p>
 * <p>If the view later scrolls to move <code>anchor</code> to a different
 * location, the popup will be moved correspondingly.</p>
 *
 * @param anchor the view on which to pin the popup window
 *
 * @see #dismiss()
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",1,"The functions findDropDownPosition() and updateAboveAnchor() have replaced multiple lines relating to both control dependency statements ('if', 'else') and statements about 'mPopupView' variable. Also, the function updateAboveAnchor() is new in the late version and findDropDownPosition() in the early version is called with additional assignment 'mAboveAnchor ='. So, change type is both 3 and 4.","The change of those statements could potentially leads to different assignments to the 'mAboveAnchor' and 'mPopupView' variables, which can potentially cause the API to return a different behavior. So, the CI type is 1."
114,<android.webkit.WebView: void switchOutDrawHistory()>,7,8,<android.webkit.WebView: void switchOutDrawHistory()>,<android.webkit.WebView: void switchOutDrawHistory()>,0,"{
    // CallbackProxy may trigger this
    if (null == mWebViewCore)
        return;
    if (mDrawHistory && mWebViewCore.pictureReady()) {
        mDrawHistory = false;
        invalidate();
        int oldScrollX = mScrollX;
        int oldScrollY = mScrollY;
        mScrollX = pinLocX(mScrollX);
        mScrollY = pinLocY(mScrollY);
        if (oldScrollX != mScrollX || oldScrollY != mScrollY) {
            mUserScroll = false;
            mWebViewCore.sendMessage(EventHub.SYNC_SCROLL, oldScrollX, oldScrollY);
        }
        sendOurVisibleRect();
    }
}","{
    // CallbackProxy may trigger this
    if (null == mWebViewCore)
        return;
    if (mDrawHistory && mWebViewCore.pictureReady()) {
        mDrawHistory = false;
        mHistoryPicture = null;
        invalidate();
        int oldScrollX = mScrollX;
        int oldScrollY = mScrollY;
        mScrollX = pinLocX(mScrollX);
        mScrollY = pinLocY(mScrollY);
        if (oldScrollX != mScrollX || oldScrollY != mScrollY) {
            mUserScroll = false;
            mWebViewCore.sendMessage(EventHub.SYNC_SCROLL, oldScrollX, oldScrollY);
            onScrollChanged(mScrollX, mScrollY, oldScrollX, oldScrollY);
        } else {
            sendOurVisibleRect();
        }
    }
}",1,"// Should only be called in UI thread
","// Should only be called in UI thread
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",0,"There are new statements added under the if control block in the late version - the assignment of mHistoryPicture to null and call of onScrollChanged(mScrollX, mScrollY, oldScrollX, oldScrollY). This falls into the category of control dependency change (3). Also, new statements (mHistoryPicture = null; onScrollChanged(mScrollX, mScrollY, oldScrollX, oldScrollY);) have been added, which is the 'Other statement changed' change type (4).","Though there are some changes in the code, but these changes do not affect the behavior of the API in terms of return value or type and exception handling. Their change locates in the control block, but it doesn't change the program flow. So there is no Compatibility Issue exists (0) in this case."
115,"<android.view.View: boolean onKeyDown(int,KeyEvent)>",7,8,"<android.view.View: boolean onKeyDown(int,KeyEvent)>","<android.view.View: boolean onKeyDown(int,KeyEvent)>",0,"{
    boolean result = false;
    switch(keyCode) {
        case KeyEvent.KEYCODE_DPAD_CENTER:
        case KeyEvent.KEYCODE_ENTER:
            {
                if ((mViewFlags & ENABLED_MASK) == DISABLED) {
                    return true;
                }
                // Long clickable items don't necessarily have to be clickable
                if (((mViewFlags & CLICKABLE) == CLICKABLE || (mViewFlags & LONG_CLICKABLE) == LONG_CLICKABLE) && (event.getRepeatCount() == 0)) {
                    setPressed(true);
                    if ((mViewFlags & LONG_CLICKABLE) == LONG_CLICKABLE) {
                        postCheckForLongClick();
                    }
                    return true;
                }
                break;
            }
    }
    return result;
}","{
    boolean result = false;
    switch(keyCode) {
        case KeyEvent.KEYCODE_DPAD_CENTER:
        case KeyEvent.KEYCODE_ENTER:
            {
                if ((mViewFlags & ENABLED_MASK) == DISABLED) {
                    return true;
                }
                // Long clickable items don't necessarily have to be clickable
                if (((mViewFlags & CLICKABLE) == CLICKABLE || (mViewFlags & LONG_CLICKABLE) == LONG_CLICKABLE) && (event.getRepeatCount() == 0)) {
                    setPressed(true);
                    if ((mViewFlags & LONG_CLICKABLE) == LONG_CLICKABLE) {
                        postCheckForLongClick(0);
                    }
                    return true;
                }
                break;
            }
    }
    return result;
}",1,"/**
 * Default implementation of {@link KeyEvent.Callback#onKeyMultiple(int, int, KeyEvent)
 * KeyEvent.Callback.onKeyMultiple()}: perform press of the view
 * when {@link KeyEvent#KEYCODE_DPAD_CENTER} or {@link KeyEvent#KEYCODE_ENTER}
 * is released, if the view is enabled and clickable.
 *
 * @param keyCode A key code that represents the button pressed, from
 * {@link android.view.KeyEvent}.
 * @param event   The KeyEvent object that defines the button action.
 */
","/**
 * Default implementation of {@link KeyEvent.Callback#onKeyMultiple(int, int, KeyEvent)
 * KeyEvent.Callback.onKeyMultiple()}: perform press of the view
 * when {@link KeyEvent#KEYCODE_DPAD_CENTER} or {@link KeyEvent#KEYCODE_ENTER}
 * is released, if the view is enabled and clickable.
 *
 * @param keyCode A key code that represents the button pressed, from
 * {@link android.view.KeyEvent}.
 * @param event   The KeyEvent object that defines the button action.
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The parameter of postCheckForLongClick() method has changed, so the code change type is 5.",No Compatibility Issue exist because even though the dependent method postCheckForLongClick() has been changed; it doesn't affect the behaviour of the onKeyDown method itself. It will still return the same values under the same conditions.
116,"<android.database.sqlite.SQLiteQuery: int fillWindow(CursorWindow,int,int)>",7,8,"<android.database.sqlite.SQLiteQuery: int fillWindow(CursorWindow,int,int)>","<android.database.sqlite.SQLiteQuery: int fillWindow(CursorWindow,int,int)>",0,"{
    mDatabase.lock();
    boolean logStats = mDatabase.mLogStats;
    long startTime = logStats ? SystemClock.elapsedRealtime() : 0;
    try {
        acquireReference();
        try {
            window.acquireReference();
            // if the start pos is not equal to 0, then most likely window is
            // too small for the data set, loading by another thread
            // is not safe in this situation. the native code will ignore maxRead
            int numRows = native_fill_window(window, window.getStartPosition(), mOffsetIndex, maxRead, lastPos);
            // Logging
            if (SQLiteDebug.DEBUG_SQL_STATEMENTS) {
                Log.d(TAG, ""fillWindow(): "" + mQuery);
            }
            if (logStats) {
                mDatabase.logTimeStat(true, /* read */
                startTime, SystemClock.elapsedRealtime());
            }
            return numRows;
        } catch (IllegalStateException e) {
            // simply ignore it
            return 0;
        } catch (SQLiteDatabaseCorruptException e) {
            mDatabase.onCorruption();
            throw e;
        } finally {
            window.releaseReference();
        }
    } finally {
        releaseReference();
        mDatabase.unlock();
    }
}","{
    long timeStart = SystemClock.uptimeMillis();
    mDatabase.lock();
    mDatabase.logTimeStat(mSql, timeStart, SQLiteDatabase.GET_LOCK_LOG_PREFIX);
    try {
        acquireReference();
        try {
            window.acquireReference();
            // if the start pos is not equal to 0, then most likely window is
            // too small for the data set, loading by another thread
            // is not safe in this situation. the native code will ignore maxRead
            int numRows = native_fill_window(window, window.getStartPosition(), mOffsetIndex, maxRead, lastPos);
            // Logging
            if (SQLiteDebug.DEBUG_SQL_STATEMENTS) {
                Log.d(TAG, ""fillWindow(): "" + mSql);
            }
            mDatabase.logTimeStat(mSql, timeStart);
            return numRows;
        } catch (IllegalStateException e) {
            // simply ignore it
            return 0;
        } catch (SQLiteDatabaseCorruptException e) {
            mDatabase.onCorruption();
            throw e;
        } finally {
            window.releaseReference();
        }
    } finally {
        releaseReference();
        mDatabase.unlock();
    }
}",1,"/* package */
","/* package */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The changes are related to logging and timing, with variable name and some code logic changed (e.g., mDatabase.logTimeStat method's parameters and placement; the position of the declaration and usage of timeStart variable). These changes fall under Other statement changed category. ","These changes will not affect the return values or the exceptions thrown by the method, hence there are no Compatibility Issues in this case."
120,"<android.text.method.Touch: boolean onTouchEvent(TextView,Spannable,MotionEvent)>",7,8,"<android.text.method.Touch: boolean onTouchEvent(TextView,Spannable,MotionEvent)>","<android.text.method.Touch: boolean onTouchEvent(TextView,Spannable,MotionEvent)>",0,"{
    DragState[] ds;
    switch(event.getAction()) {
        case MotionEvent.ACTION_DOWN:
            ds = buffer.getSpans(0, buffer.length(), DragState.class);
            for (int i = 0; i < ds.length; i++) {
                buffer.removeSpan(ds[i]);
            }
            buffer.setSpan(new DragState(event.getX(), event.getY(), widget.getScrollX(), widget.getScrollY()), 0, 0, Spannable.SPAN_MARK_MARK);
            return true;
        case MotionEvent.ACTION_UP:
            ds = buffer.getSpans(0, buffer.length(), DragState.class);
            for (int i = 0; i < ds.length; i++) {
                buffer.removeSpan(ds[i]);
            }
            if (ds.length > 0 && ds[0].mUsed) {
                return true;
            } else {
                return false;
            }
        case MotionEvent.ACTION_MOVE:
            ds = buffer.getSpans(0, buffer.length(), DragState.class);
            if (ds.length > 0) {
                if (ds[0].mFarEnough == false) {
                    int slop = ViewConfiguration.get(widget.getContext()).getScaledTouchSlop();
                    if (Math.abs(event.getX() - ds[0].mX) >= slop || Math.abs(event.getY() - ds[0].mY) >= slop) {
                        ds[0].mFarEnough = true;
                    }
                }
                if (ds[0].mFarEnough) {
                    ds[0].mUsed = true;
                    float dx = ds[0].mX - event.getX();
                    float dy = ds[0].mY - event.getY();
                    ds[0].mX = event.getX();
                    ds[0].mY = event.getY();
                    int nx = widget.getScrollX() + (int) dx;
                    int ny = widget.getScrollY() + (int) dy;
                    int padding = widget.getTotalPaddingTop() + widget.getTotalPaddingBottom();
                    Layout layout = widget.getLayout();
                    ny = Math.min(ny, layout.getHeight() - (widget.getHeight() - padding));
                    ny = Math.max(ny, 0);
                    int oldX = widget.getScrollX();
                    int oldY = widget.getScrollY();
                    scrollTo(widget, layout, nx, ny);
                    // If we actually scrolled, then cancel the up action.
                    if (oldX != widget.getScrollX() || oldY != widget.getScrollY()) {
                        widget.cancelLongPress();
                    }
                    return true;
                }
            }
    }
    return false;
}","{
    DragState[] ds;
    switch(event.getAction()) {
        case MotionEvent.ACTION_DOWN:
            ds = buffer.getSpans(0, buffer.length(), DragState.class);
            for (int i = 0; i < ds.length; i++) {
                buffer.removeSpan(ds[i]);
            }
            buffer.setSpan(new DragState(event.getX(), event.getY(), widget.getScrollX(), widget.getScrollY()), 0, 0, Spannable.SPAN_MARK_MARK);
            return true;
        case MotionEvent.ACTION_UP:
            ds = buffer.getSpans(0, buffer.length(), DragState.class);
            for (int i = 0; i < ds.length; i++) {
                buffer.removeSpan(ds[i]);
            }
            if (ds.length > 0 && ds[0].mUsed) {
                return true;
            } else {
                return false;
            }
        case MotionEvent.ACTION_MOVE:
            ds = buffer.getSpans(0, buffer.length(), DragState.class);
            if (ds.length > 0) {
                if (ds[0].mFarEnough == false) {
                    int slop = ViewConfiguration.get(widget.getContext()).getScaledTouchSlop();
                    if (Math.abs(event.getX() - ds[0].mX) >= slop || Math.abs(event.getY() - ds[0].mY) >= slop) {
                        ds[0].mFarEnough = true;
                    }
                }
                if (ds[0].mFarEnough) {
                    ds[0].mUsed = true;
                    boolean cap = (MetaKeyKeyListener.getMetaState(buffer, KeyEvent.META_SHIFT_ON) == 1) || (MetaKeyKeyListener.getMetaState(buffer, MetaKeyKeyListener.META_SELECTING) != 0);
                    float dx;
                    float dy;
                    if (cap) {
                        // if we're selecting, we want the scroll to go in
                        // the direction of the drag
                        dx = event.getX() - ds[0].mX;
                        dy = event.getY() - ds[0].mY;
                    } else {
                        dx = ds[0].mX - event.getX();
                        dy = ds[0].mY - event.getY();
                    }
                    ds[0].mX = event.getX();
                    ds[0].mY = event.getY();
                    int nx = widget.getScrollX() + (int) dx;
                    int ny = widget.getScrollY() + (int) dy;
                    int padding = widget.getTotalPaddingTop() + widget.getTotalPaddingBottom();
                    Layout layout = widget.getLayout();
                    ny = Math.min(ny, layout.getHeight() - (widget.getHeight() - padding));
                    ny = Math.max(ny, 0);
                    int oldX = widget.getScrollX();
                    int oldY = widget.getScrollY();
                    scrollTo(widget, layout, nx, ny);
                    // If we actually scrolled, then cancel the up action.
                    if (oldX != widget.getScrollX() || oldY != widget.getScrollY()) {
                        widget.cancelLongPress();
                    }
                    return true;
                }
            }
    }
    return false;
}",1,"/**
 * Handles touch events for dragging.  You may want to do other actions
 * like moving the cursor on touch as well.
 */
","/**
 * Handles touch events for dragging.  You may want to do other actions
 * like moving the cursor on touch as well.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",1,"The control dependency has changed as we see the addition of a new condition inside the ""MotionEvent.ACTION_MOVE"" case. Additionally, other statements has changed with the addition of boolean variable 'cap' and change in calculation method of 'dx' and 'dy'.","The change in control dependency and addition of a new condition switch can potentially lead to returning a different value when the MotionEvent is a ""ACTION_MOVE"" event, leading to a potential compatibility issue of type 1."
122,<android.app.WallpaperInfo: CharSequence loadDescription(PackageManager)>,7,8,<android.app.WallpaperInfo: CharSequence loadDescription(PackageManager)>,<android.app.WallpaperInfo: CharSequence loadDescription(PackageManager)>,0,"{
    if (mDescriptionResource <= 0)
        throw new NotFoundException();
    return pm.getText((mService.resolvePackageName != null) ? mService.resolvePackageName : getPackageName(), mDescriptionResource, null);
}","{
    String packageName = mService.resolvePackageName;
    ApplicationInfo applicationInfo = null;
    if (packageName == null) {
        packageName = mService.serviceInfo.packageName;
        applicationInfo = mService.serviceInfo.applicationInfo;
    }
    if (mService.serviceInfo.descriptionRes != 0) {
        return pm.getText(packageName, mService.serviceInfo.descriptionRes, applicationInfo);
    }
    if (mDescriptionResource <= 0)
        throw new NotFoundException();
    return pm.getText(packageName, mDescriptionResource, mService.serviceInfo.applicationInfo);
}",1,"/**
 * Return a brief summary of this wallpaper's behavior.
 */
","/**
 * Return a brief summary of this wallpaper's behavior.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3","1,2","Return statements in these two version are different and if-condition structure has changed, so the pred_change is 1,3.","Exception handling statement is relocated. And also, the return statement changes can potentially cause the program to return a different type or value. Thus, the pred_CI is 1,2."
123,<android.webkit.WebView: int findAll(String)>,7,8,<android.webkit.WebView: int findAll(String)>,<android.webkit.WebView: int findAll(String)>,0,"{
    // client isn't initialized
    if (0 == mNativeClass)
        return 0;
    if (mFindIsUp == false) {
        recordNewContentSize(mContentWidth, mContentHeight + mFindHeight, false);
        mFindIsUp = true;
    }
    int result = nativeFindAll(find.toLowerCase(), find.toUpperCase());
    invalidate();
    return result;
}","{
    // client isn't initialized
    if (0 == mNativeClass)
        return 0;
    int result = find != null ? nativeFindAll(find.toLowerCase(), find.toUpperCase()) : 0;
    invalidate();
    mLastFind = find;
    return result;
}",1,"/*
     * Find all instances of find on the page and highlight them.
     * @param find  String to find.
     * @return int  The number of occurances of the String ""find""
     *              that were found.
     */
","/*
     * Find all instances of find on the page and highlight them.
     * @param find  String to find.
     * @return int  The number of occurances of the String ""find""
     *              that were found.
     */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3,4",1,"The code that checks `mFindIsUp` and updates `mContentWidth` and `mContentHeight` is removed in the late version, and a new ternary operator is introduced to check if `find` is null. Also, a new code line, `mLastFind = find;` ,is added. Therefore, the code change types are 1,3,4.","Due to the change in the condition to check the 'find' and processing the 'result' variable, and the removal of part of the preceding control (the removed 'if' statement), the output of the method could potentially be different depending on the input parameters. Thus, the Compatibility Issue type is 1."
124,"<android.widget.ExpandableListView: boolean handleItemClick(View,int,long)>",7,8,"<android.widget.ExpandableListView: boolean handleItemClick(View,int,long)>","<android.widget.ExpandableListView: boolean handleItemClick(View,int,long)>",0,"{
    final PositionMetadata posMetadata = mConnector.getUnflattenedPos(position);
    id = getChildOrGroupId(posMetadata.position);
    boolean returnValue;
    if (posMetadata.position.type == ExpandableListPosition.GROUP) {
        if (posMetadata.isExpanded()) {
            /* Collapse it */
            mConnector.collapseGroup(posMetadata);
            playSoundEffect(SoundEffectConstants.CLICK);
            if (mOnGroupCollapseListener != null) {
                mOnGroupCollapseListener.onGroupCollapse(posMetadata.position.groupPos);
            }
        } else {
            /* It's a group click, so pass on event */
            if (mOnGroupClickListener != null) {
                if (mOnGroupClickListener.onGroupClick(this, v, posMetadata.position.groupPos, id)) {
                    posMetadata.recycle();
                    return true;
                }
            }
            /* Expand it */
            mConnector.expandGroup(posMetadata);
            playSoundEffect(SoundEffectConstants.CLICK);
            if (mOnGroupExpandListener != null) {
                mOnGroupExpandListener.onGroupExpand(posMetadata.position.groupPos);
            }
        }
        returnValue = true;
    } else {
        /* It's a child, so pass on event */
        if (mOnChildClickListener != null) {
            playSoundEffect(SoundEffectConstants.CLICK);
            return mOnChildClickListener.onChildClick(this, v, posMetadata.position.groupPos, posMetadata.position.childPos, id);
        }
        returnValue = false;
    }
    posMetadata.recycle();
    return returnValue;
}","{
    final PositionMetadata posMetadata = mConnector.getUnflattenedPos(position);
    id = getChildOrGroupId(posMetadata.position);
    boolean returnValue;
    if (posMetadata.position.type == ExpandableListPosition.GROUP) {
        /* It's a group click, so pass on event */
        if (mOnGroupClickListener != null) {
            if (mOnGroupClickListener.onGroupClick(this, v, posMetadata.position.groupPos, id)) {
                posMetadata.recycle();
                return true;
            }
        }
        if (posMetadata.isExpanded()) {
            /* Collapse it */
            mConnector.collapseGroup(posMetadata);
            playSoundEffect(SoundEffectConstants.CLICK);
            if (mOnGroupCollapseListener != null) {
                mOnGroupCollapseListener.onGroupCollapse(posMetadata.position.groupPos);
            }
        } else {
            /* Expand it */
            mConnector.expandGroup(posMetadata);
            playSoundEffect(SoundEffectConstants.CLICK);
            if (mOnGroupExpandListener != null) {
                mOnGroupExpandListener.onGroupExpand(posMetadata.position.groupPos);
            }
            final int groupPos = posMetadata.position.groupPos;
            final int groupFlatPos = posMetadata.position.flatListPos;
            final int shiftedGroupPosition = groupFlatPos + getHeaderViewsCount();
            smoothScrollToPosition(shiftedGroupPosition + mAdapter.getChildrenCount(groupPos), shiftedGroupPosition);
        }
        returnValue = true;
    } else {
        /* It's a child, so pass on event */
        if (mOnChildClickListener != null) {
            playSoundEffect(SoundEffectConstants.CLICK);
            return mOnChildClickListener.onChildClick(this, v, posMetadata.position.groupPos, posMetadata.position.childPos, id);
        }
        returnValue = false;
    }
    posMetadata.recycle();
    return returnValue;
}",1,"/**
 * This will either expand/collapse groups (if a group was clicked) or pass
 * on the click to the proper child (if a child was clicked)
 *
 * @param position The flat list position. This has already been factored to
 * remove the header/footer.
 * @param id The ListAdapter ID, not the group or child ID.
 */
","/**
 * This will either expand/collapse groups (if a group was clicked) or pass
 * on the click to the proper child (if a child was clicked)
 *
 * @param position The flat list position. This has already been factored to
 * remove the header/footer.
 * @param id The ListAdapter ID, not the group or child ID.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",1,"The sequence of the 'if' statements and the existence of 'else' clause in the method have been altered, which is a change in the control dependencies. Additionally, new set of statements are included inside a nested if condition where existing statements 'mConnector.expandGroup(posMetadata);', 'playSoundEffect(SoundEffectConstants.CLICK);', and 'mOnGroupExpandListener.onGroupExpand(posMetadata.position.groupPos);' have been rearranged. These changes are classified as type 3 and 4.",The rearrangement and addition of the control block will affect the execution of method 'handleItemClick' and thereby alter the return value. This signifies a potential compatibility issue of type 1.
126,"<android.accounts.AccountAuthenticatorResponse: void onError(int,String)>",7,8,"<android.accounts.AccountAuthenticatorResponse: void onError(int,String)>","<android.accounts.AccountAuthenticatorResponse: void onError(int,String)>",0,"{
    try {
        mAccountAuthenticatorResponse.onError(errorCode, errorMessage);
    } catch (RemoteException e) {
    // this should never happen
    }
}","{
    if (Log.isLoggable(TAG, Log.VERBOSE)) {
        Log.v(TAG, ""AccountAuthenticatorResponse.onError: "" + errorCode + "", "" + errorMessage);
    }
    try {
        mAccountAuthenticatorResponse.onError(errorCode, errorMessage);
    } catch (RemoteException e) {
    // this should never happen
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,4,0,"Logging code is added in the late version, which doesn't impact the real operation or the result of the method. Therefore, the code change type is 4 (Other statement changed).","Despite the logging statement being added, this change does not affect the returned results or exception handling of this method, which suggests that there is no Compatibility Issue (0)."
127,"<android.hardware.SensorManager: boolean registerListener(SensorEventListener,Sensor,int,Handler)>",7,8,"<android.hardware.SensorManager: boolean registerListener(SensorEventListener,Sensor,int,Handler)>","<android.hardware.SensorManager: boolean registerListener(SensorEventListener,Sensor,int,Handler)>",0,"{
    if (listener == null || sensor == null) {
        return false;
    }
    boolean result;
    int delay = -1;
    switch(rate) {
        case SENSOR_DELAY_FASTEST:
            delay = 0;
            break;
        case SENSOR_DELAY_GAME:
            delay = 20;
            break;
        case SENSOR_DELAY_UI:
            delay = 60;
            break;
        case SENSOR_DELAY_NORMAL:
            delay = 200;
            break;
        default:
            return false;
    }
    try {
        synchronized (sListeners) {
            ListenerDelegate l = null;
            for (ListenerDelegate i : sListeners) {
                if (i.getListener() == listener) {
                    l = i;
                    break;
                }
            }
            String name = sensor.getName();
            int handle = sensor.getHandle();
            if (l == null) {
                l = new ListenerDelegate(listener, sensor, handler);
                result = mSensorService.enableSensor(l, name, handle, delay);
                if (result) {
                    sListeners.add(l);
                    sListeners.notify();
                }
                if (!sListeners.isEmpty()) {
                    sSensorThread.startLocked(mSensorService);
                }
            } else {
                result = mSensorService.enableSensor(l, name, handle, delay);
                if (result) {
                    l.addSensor(sensor);
                }
            }
        }
    } catch (RemoteException e) {
        Log.e(TAG, ""RemoteException in registerListener: "", e);
        result = false;
    }
    return result;
}","{
    if (listener == null || sensor == null) {
        return false;
    }
    boolean result;
    int delay = -1;
    switch(rate) {
        case SENSOR_DELAY_FASTEST:
            delay = 0;
            break;
        case SENSOR_DELAY_GAME:
            delay = 20;
            break;
        case SENSOR_DELAY_UI:
            delay = 60;
            break;
        case SENSOR_DELAY_NORMAL:
            delay = 200;
            break;
        default:
            return false;
    }
    try {
        synchronized (sListeners) {
            ListenerDelegate l = null;
            for (ListenerDelegate i : sListeners) {
                if (i.getListener() == listener) {
                    l = i;
                    break;
                }
            }
            String name = sensor.getName();
            int handle = sensor.getHandle();
            if (l == null) {
                result = false;
                l = new ListenerDelegate(listener, sensor, handler);
                sListeners.add(l);
                if (!sListeners.isEmpty()) {
                    result = sSensorThread.startLocked(mSensorService);
                    if (result) {
                        result = mSensorService.enableSensor(l, name, handle, delay);
                        if (!result) {
                            // there was an error, remove the listeners
                            sListeners.remove(l);
                        }
                    }
                }
            } else {
                result = mSensorService.enableSensor(l, name, handle, delay);
                if (result) {
                    l.addSensor(sensor);
                }
            }
        }
    } catch (RemoteException e) {
        Log.e(TAG, ""RemoteException in registerListener: "", e);
        result = false;
    }
    return result;
}",1,"/**
 * Registers a {@link android.hardware.SensorEventListener SensorEventListener}
 * for the given sensor.
 *
 * @param listener A {@link android.hardware.SensorEventListener SensorEventListener} object.
 * @param sensor The {@link android.hardware.Sensor Sensor} to register to.
 * @param rate The rate {@link android.hardware.SensorEvent sensor events} are delivered at.
 * This is only a hint to the system. Events may be received faster or
 * slower than the specified rate. Usually events are received faster. The value must be one
 * of {@link #SENSOR_DELAY_NORMAL}, {@link #SENSOR_DELAY_UI}, {@link #SENSOR_DELAY_GAME}, or
 * {@link #SENSOR_DELAY_FASTEST}.
 * @param handler The {@link android.os.Handler Handler} the
 * {@link android.hardware.SensorEvent sensor events} will be delivered to.
 *
 * @return true if the sensor is supported and successfully enabled.
 */
","/**
 * Registers a {@link android.hardware.SensorEventListener SensorEventListener}
 * for the given sensor.
 *
 * @param listener A {@link android.hardware.SensorEventListener SensorEventListener} object.
 * @param sensor The {@link android.hardware.Sensor Sensor} to register to.
 * @param rate The rate {@link android.hardware.SensorEvent sensor events} are delivered at.
 * This is only a hint to the system. Events may be received faster or
 * slower than the specified rate. Usually events are received faster. The value must be one
 * of {@link #SENSOR_DELAY_NORMAL}, {@link #SENSOR_DELAY_UI}, {@link #SENSOR_DELAY_GAME}, or
 * {@link #SENSOR_DELAY_FASTEST}.
 * @param handler The {@link android.os.Handler Handler} the
 * {@link android.hardware.SensorEvent sensor events} will be delivered to.
 *
 * @return true if the sensor is supported and successfully enabled.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,4",1,"In the if (l == null) section, new return statement 'result = false;' has been added, and the execution order of some statements has changed. Therefore, the code change type is 1 and 4.","The modification of the control statements and the introduction of new 'result = false' statement can potentially make the API return different values, thus CI type is 1."
129,"<android.util.Log: int v(String,String)>",7,8,"<android.util.Log: int v(String,String)>","<android.util.Log: int v(String,String)>",0,"{
    return println(VERBOSE, tag, msg);
}","{
    return println_native(LOG_ID_MAIN, VERBOSE, tag, msg);
}",1,"/**
 * Send a {@link #VERBOSE} log message.
 * @param tag Used to identify the source of a log message.  It usually identifies
 * the class or activity where the log call occurs.
 * @param msg The message you would like logged.
 */
","/**
 * Send a {@link #VERBOSE} log message.
 * @param tag Used to identify the source of a log message.  It usually identifies
 * the class or activity where the log call occurs.
 * @param msg The message you would like logged.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,4,5",1,"The method println from early implementation is replaced with println_native in the late implementation, which is another type of statement change, so the code change type is 1,4. Moreover, the number and type of parameters within this method changed (LOG_ID_MAIN was added), fitting into category 5.","Because the return statement has changed (switching from println to println_native), it's possible that the outcome of the function, i.e., what it returns, may differ between different versions. Hence, the compatibility issue type classification is 1."
130,<android.app.ActivityThread.H: String codeToString(int)>,7,8,<android.app.ActivityThread.H: String codeToString(int)>,<android.app.ActivityThread.H: String codeToString(int)>,0,"{
    if (localLOGV) {
        switch(code) {
            case LAUNCH_ACTIVITY:
                return ""LAUNCH_ACTIVITY"";
            case PAUSE_ACTIVITY:
                return ""PAUSE_ACTIVITY"";
            case PAUSE_ACTIVITY_FINISHING:
                return ""PAUSE_ACTIVITY_FINISHING"";
            case STOP_ACTIVITY_SHOW:
                return ""STOP_ACTIVITY_SHOW"";
            case STOP_ACTIVITY_HIDE:
                return ""STOP_ACTIVITY_HIDE"";
            case SHOW_WINDOW:
                return ""SHOW_WINDOW"";
            case HIDE_WINDOW:
                return ""HIDE_WINDOW"";
            case RESUME_ACTIVITY:
                return ""RESUME_ACTIVITY"";
            case SEND_RESULT:
                return ""SEND_RESULT"";
            case DESTROY_ACTIVITY:
                return ""DESTROY_ACTIVITY"";
            case BIND_APPLICATION:
                return ""BIND_APPLICATION"";
            case EXIT_APPLICATION:
                return ""EXIT_APPLICATION"";
            case NEW_INTENT:
                return ""NEW_INTENT"";
            case RECEIVER:
                return ""RECEIVER"";
            case CREATE_SERVICE:
                return ""CREATE_SERVICE"";
            case SERVICE_ARGS:
                return ""SERVICE_ARGS"";
            case STOP_SERVICE:
                return ""STOP_SERVICE"";
            case REQUEST_THUMBNAIL:
                return ""REQUEST_THUMBNAIL"";
            case CONFIGURATION_CHANGED:
                return ""CONFIGURATION_CHANGED"";
            case CLEAN_UP_CONTEXT:
                return ""CLEAN_UP_CONTEXT"";
            case GC_WHEN_IDLE:
                return ""GC_WHEN_IDLE"";
            case BIND_SERVICE:
                return ""BIND_SERVICE"";
            case UNBIND_SERVICE:
                return ""UNBIND_SERVICE"";
            case DUMP_SERVICE:
                return ""DUMP_SERVICE"";
            case LOW_MEMORY:
                return ""LOW_MEMORY"";
            case ACTIVITY_CONFIGURATION_CHANGED:
                return ""ACTIVITY_CONFIGURATION_CHANGED"";
            case RELAUNCH_ACTIVITY:
                return ""RELAUNCH_ACTIVITY"";
            case PROFILER_CONTROL:
                return ""PROFILER_CONTROL"";
            case CREATE_BACKUP_AGENT:
                return ""CREATE_BACKUP_AGENT"";
            case DESTROY_BACKUP_AGENT:
                return ""DESTROY_BACKUP_AGENT"";
            case SUICIDE:
                return ""SUICIDE"";
            case REMOVE_PROVIDER:
                return ""REMOVE_PROVIDER"";
        }
    }
    return ""(unknown)"";
}","{
    if (localLOGV) {
        switch(code) {
            case LAUNCH_ACTIVITY:
                return ""LAUNCH_ACTIVITY"";
            case PAUSE_ACTIVITY:
                return ""PAUSE_ACTIVITY"";
            case PAUSE_ACTIVITY_FINISHING:
                return ""PAUSE_ACTIVITY_FINISHING"";
            case STOP_ACTIVITY_SHOW:
                return ""STOP_ACTIVITY_SHOW"";
            case STOP_ACTIVITY_HIDE:
                return ""STOP_ACTIVITY_HIDE"";
            case SHOW_WINDOW:
                return ""SHOW_WINDOW"";
            case HIDE_WINDOW:
                return ""HIDE_WINDOW"";
            case RESUME_ACTIVITY:
                return ""RESUME_ACTIVITY"";
            case SEND_RESULT:
                return ""SEND_RESULT"";
            case DESTROY_ACTIVITY:
                return ""DESTROY_ACTIVITY"";
            case BIND_APPLICATION:
                return ""BIND_APPLICATION"";
            case EXIT_APPLICATION:
                return ""EXIT_APPLICATION"";
            case NEW_INTENT:
                return ""NEW_INTENT"";
            case RECEIVER:
                return ""RECEIVER"";
            case CREATE_SERVICE:
                return ""CREATE_SERVICE"";
            case SERVICE_ARGS:
                return ""SERVICE_ARGS"";
            case STOP_SERVICE:
                return ""STOP_SERVICE"";
            case REQUEST_THUMBNAIL:
                return ""REQUEST_THUMBNAIL"";
            case CONFIGURATION_CHANGED:
                return ""CONFIGURATION_CHANGED"";
            case CLEAN_UP_CONTEXT:
                return ""CLEAN_UP_CONTEXT"";
            case GC_WHEN_IDLE:
                return ""GC_WHEN_IDLE"";
            case BIND_SERVICE:
                return ""BIND_SERVICE"";
            case UNBIND_SERVICE:
                return ""UNBIND_SERVICE"";
            case DUMP_SERVICE:
                return ""DUMP_SERVICE"";
            case LOW_MEMORY:
                return ""LOW_MEMORY"";
            case ACTIVITY_CONFIGURATION_CHANGED:
                return ""ACTIVITY_CONFIGURATION_CHANGED"";
            case RELAUNCH_ACTIVITY:
                return ""RELAUNCH_ACTIVITY"";
            case PROFILER_CONTROL:
                return ""PROFILER_CONTROL"";
            case CREATE_BACKUP_AGENT:
                return ""CREATE_BACKUP_AGENT"";
            case DESTROY_BACKUP_AGENT:
                return ""DESTROY_BACKUP_AGENT"";
            case SUICIDE:
                return ""SUICIDE"";
            case REMOVE_PROVIDER:
                return ""REMOVE_PROVIDER"";
            case ENABLE_JIT:
                return ""ENABLE_JIT"";
            case DISPATCH_PACKAGE_BROADCAST:
                return ""DISPATCH_PACKAGE_BROADCAST"";
        }
    }
    return ""(unknown)"";
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,3,1,"In the 'switch' statement, two new cases have been added in the latest version ('case ENABLE_JIT' and 'case DISPATCH_PACKAGE_BROADCAST'), so the code change type is 3.","Due to the introduction of the new cases in the 'switch' statement, the API can potentially return different values in the new version. Specifically, when called with an argument that matches either of the new cases, the function will return a different result than it would in the previous version. Therefore, CI type is 1."
132,<android.service.wallpaper.WallpaperService.Engine: void doOffsetsChanged()>,7,8,<android.service.wallpaper.WallpaperService.Engine: void doOffsetsChanged()>,<android.service.wallpaper.WallpaperService.Engine: void doOffsetsChanged()>,0,"{
    if (mDestroyed) {
        return;
    }
    float xOffset;
    float yOffset;
    float xOffsetStep;
    float yOffsetStep;
    boolean sync;
    synchronized (mLock) {
        xOffset = mPendingXOffset;
        yOffset = mPendingYOffset;
        xOffsetStep = mPendingXOffsetStep;
        yOffsetStep = mPendingYOffsetStep;
        sync = mPendingSync;
        mPendingSync = false;
        mOffsetMessageEnqueued = false;
    }
    if (DEBUG)
        Log.v(TAG, ""Offsets change in "" + this + "": "" + xOffset + "","" + yOffset);
    final int availw = mIWallpaperEngine.mReqWidth - mCurWidth;
    final int xPixels = availw > 0 ? -(int) (availw * xOffset + .5f) : 0;
    final int availh = mIWallpaperEngine.mReqHeight - mCurHeight;
    final int yPixels = availh > 0 ? -(int) (availh * yOffset + .5f) : 0;
    onOffsetsChanged(xOffset, yOffset, xOffsetStep, yOffsetStep, xPixels, yPixels);
    if (sync) {
        try {
            if (DEBUG)
                Log.v(TAG, ""Reporting offsets change complete"");
            mSession.wallpaperOffsetsComplete(mWindow.asBinder());
        } catch (RemoteException e) {
        }
    }
}","{
    if (mDestroyed) {
        return;
    }
    float xOffset;
    float yOffset;
    float xOffsetStep;
    float yOffsetStep;
    boolean sync;
    synchronized (mLock) {
        xOffset = mPendingXOffset;
        yOffset = mPendingYOffset;
        xOffsetStep = mPendingXOffsetStep;
        yOffsetStep = mPendingYOffsetStep;
        sync = mPendingSync;
        mPendingSync = false;
        mOffsetMessageEnqueued = false;
    }
    if (mSurfaceCreated) {
        if (DEBUG)
            Log.v(TAG, ""Offsets change in "" + this + "": "" + xOffset + "","" + yOffset);
        final int availw = mIWallpaperEngine.mReqWidth - mCurWidth;
        final int xPixels = availw > 0 ? -(int) (availw * xOffset + .5f) : 0;
        final int availh = mIWallpaperEngine.mReqHeight - mCurHeight;
        final int yPixels = availh > 0 ? -(int) (availh * yOffset + .5f) : 0;
        onOffsetsChanged(xOffset, yOffset, xOffsetStep, yOffsetStep, xPixels, yPixels);
    }
    if (sync) {
        try {
            if (DEBUG)
                Log.v(TAG, ""Reporting offsets change complete"");
            mSession.wallpaperOffsetsComplete(mWindow.asBinder());
        } catch (RemoteException e) {
        }
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,3,1,"A new control statement 'if(mSurfaceCreated)' is introduced in the late implementation. This signifies a change in the control dependency, hence marked as type 3 change.","Due to the added control statement 'if(mSurfaceCreated)', the API has a potential to return different values since the execution of 'onOffsetsChanged(xOffset, yOffset, xOffsetStep, yOffsetStep, xPixels, yPixels);' now depends on the condition 'mSurfaceCreated'. Thus, this can potentially cause a change in behavior leading to a compatibility issue of type 1."
133,"<android.widget.AutoCompleteTextView.PopupTouchInterceptor: boolean onTouch(View,MotionEvent)>",7,8,"<android.widget.AutoCompleteTextView.PopupTouchInterceptor: boolean onTouch(View,MotionEvent)>","<android.widget.AutoCompleteTextView.PopupTouchInterceptor: boolean onTouch(View,MotionEvent)>",0,"{
    if (event.getAction() == MotionEvent.ACTION_DOWN && mPopup != null && mPopup.isShowing()) {
        mPopup.setInputMethodMode(PopupWindow.INPUT_METHOD_NOT_NEEDED);
        showDropDown();
    }
    return false;
}","{
    final int action = event.getAction();
    if (action == MotionEvent.ACTION_DOWN && mPopup != null && mPopup.isShowing()) {
        postDelayed(mResizePopupRunnable, EXPAND_LIST_TIMEOUT);
    } else if (action == MotionEvent.ACTION_UP) {
        removeCallbacks(mResizePopupRunnable);
    }
    return false;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,4,0,"The method removes two method invocations: 'mPopup.setInputMethodMode(PopupWindow.INPUT_METHOD_NOT_NEEDED)' and 'showDropDown()'. And it introduces three new statements: 'final int action = event.getAction()', 'postDelayed(mResizePopupRunnable, EXPAND_LIST_TIMEOUT)', and 'removeCallbacks(mResizePopupRunnable)'. So the code change type is 4.","Despite changes in the implementation, both versions return the same, static value: false. So the return value will always be the same, no matter the state. Therefore, the CI type is 0. No Compatibility Issue exist."
135,<android.app.WallpaperInfo: CharSequence loadAuthor(PackageManager)>,7,8,<android.app.WallpaperInfo: CharSequence loadAuthor(PackageManager)>,<android.app.WallpaperInfo: CharSequence loadAuthor(PackageManager)>,0,"{
    if (mAuthorResource <= 0)
        throw new NotFoundException();
    return pm.getText((mService.resolvePackageName != null) ? mService.resolvePackageName : getPackageName(), mAuthorResource, null);
}","{
    if (mAuthorResource <= 0)
        throw new NotFoundException();
    String packageName = mService.resolvePackageName;
    ApplicationInfo applicationInfo = null;
    if (packageName == null) {
        packageName = mService.serviceInfo.packageName;
        applicationInfo = mService.serviceInfo.applicationInfo;
    }
    return pm.getText(packageName, mAuthorResource, applicationInfo);
}",1,"/**
 * Return a string indicating the author(s) of this wallpaper.
 */
","/**
 * Return a string indicating the author(s) of this wallpaper.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3,4","1,2","The return statement has changed with different parameters passed to the getText() method and additional control statements are introduced related to packageName and applicationInfo, so the code change type is 1,3,4.","The change in return statement may cause the API to return a different value, and the additional control statements would potentially lead to throwing an exception which did not exist in the early version, so CI type is 1,2."
136,"<android.net.http.RequestQueue.ActivePool: Connection getConnection(Context,HttpHost)>",7,8,"<android.net.http.RequestQueue.ActivePool: Connection getConnection(Context,HttpHost)>","<android.net.http.RequestQueue.ActivePool: Connection getConnection(Context,HttpHost)>",0,"{
    Connection con = mIdleCache.getConnection(host);
    if (con == null) {
        mTotalConnection++;
        con = Connection.getConnection(mContext, host, this, RequestQueue.this);
    }
    return con;
}","{
    host = RequestQueue.this.determineHost(host);
    Connection con = mIdleCache.getConnection(host);
    if (con == null) {
        mTotalConnection++;
        con = Connection.getConnection(mContext, host, mProxyHost, RequestQueue.this);
    }
    return con;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"1,3,4,5",1,"In the late version, a new line of code is introduced (host = RequestQueue.this.determineHost(host);), changes in the control flow, the value of the variable 'host' has changed, and the dependent method getConnection() now accepts an additional parameter (mProxyHost). Hence the code changes include types 1, 3, 4, and 5.","The return value of the function depends on the value of 'host' and the host has changed. The dependent method getConnection() also accepts a new parameter which can alter its result too. Therefore, the modification can potentially return a different value which leads to the CI type 1."
137,<android.speech.tts.TextToSpeech: Locale getLanguage()>,7,8,<android.speech.tts.TextToSpeech: Locale getLanguage()>,<android.speech.tts.TextToSpeech: Locale getLanguage()>,0,"{
    synchronized (mStartLock) {
        if (!mStarted) {
            return null;
        }
        try {
            String[] locStrings = mITts.getLanguage();
            if ((locStrings != null) && (locStrings.length == 3)) {
                return new Locale(locStrings[0], locStrings[1], locStrings[2]);
            } else {
                return null;
            }
        } catch (RemoteException e) {
            // TTS died; restart it.
            Log.e(""TextToSpeech.java - getLanguage"", ""RemoteException"");
            e.printStackTrace();
            mStarted = false;
            initTts();
        } catch (NullPointerException e) {
            // TTS died; restart it.
            Log.e(""TextToSpeech.java - getLanguage"", ""NullPointerException"");
            e.printStackTrace();
            mStarted = false;
            initTts();
        } catch (IllegalStateException e) {
            // TTS died; restart it.
            Log.e(""TextToSpeech.java - getLanguage"", ""IllegalStateException"");
            e.printStackTrace();
            mStarted = false;
            initTts();
        }
        return null;
    }
}","{
    synchronized (mStartLock) {
        if (!mStarted) {
            return null;
        }
        try {
            // Only do a call to the native synth if there is nothing in the cached params
            if (mCachedParams[Engine.PARAM_POSITION_LANGUAGE + 1].length() < 1) {
                String[] locStrings = mITts.getLanguage();
                if ((locStrings != null) && (locStrings.length == 3)) {
                    return new Locale(locStrings[0], locStrings[1], locStrings[2]);
                } else {
                    return null;
                }
            } else {
                return new Locale(mCachedParams[Engine.PARAM_POSITION_LANGUAGE + 1], mCachedParams[Engine.PARAM_POSITION_COUNTRY + 1], mCachedParams[Engine.PARAM_POSITION_VARIANT + 1]);
            }
        } catch (RemoteException e) {
            // TTS died; restart it.
            Log.e(""TextToSpeech.java - getLanguage"", ""RemoteException"");
            e.printStackTrace();
            mStarted = false;
            initTts();
        } catch (NullPointerException e) {
            // TTS died; restart it.
            Log.e(""TextToSpeech.java - getLanguage"", ""NullPointerException"");
            e.printStackTrace();
            mStarted = false;
            initTts();
        } catch (IllegalStateException e) {
            // TTS died; restart it.
            Log.e(""TextToSpeech.java - getLanguage"", ""IllegalStateException"");
            e.printStackTrace();
            mStarted = false;
            initTts();
        }
        return null;
    }
}",1,"/**
 * Returns a Locale instance describing the language currently being used by the TextToSpeech
 * engine.
 * @return language, country (if any) and variant (if any) used by the engine stored in a Locale
 * instance, or null is the TextToSpeech engine has failed.
 */
","/**
 * Returns a Locale instance describing the language currently being used by the TextToSpeech
 * engine.
 * @return language, country (if any) and variant (if any) used by the engine stored in a Locale
 * instance, or null is the TextToSpeech engine has failed.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3",1,"The early version of the method directly calls the getLanguage() method on the mITts object. However, in the late version, before calling the getLanguage() method, there's a new 'if' condition that checks the length of mCachedParams[Engine.PARAM_POSITION_LANGUAGE + 1] is introduced, and if the length is less than 1, getLanguage() is called. Otherwise, a new Locale object is returned directly using the cached parameters. Therefore, the code change types includes the change of a return statement and control dependency changes, which results in a classification of 1 and 3.","The introduction of a new condition checking on the cached parameters and the new return statement (return new Locale(mCachedParams[Engine.PARAM_POSITION_LANGUAGE + 1], mCachedParams[Engine.PARAM_POSITION_COUNTRY + 1], mCachedParams[Engine.PARAM_POSITION_VARIANT + 1])) could cause this API to return a different type or value, creating a potential Compatibility Issue of type 1."
138,<android.widget.GridView: void layoutChildren()>,7,8,<android.widget.GridView: void layoutChildren()>,<android.widget.GridView: void layoutChildren()>,0,"{
    final boolean blockLayoutRequests = mBlockLayoutRequests;
    if (!blockLayoutRequests) {
        mBlockLayoutRequests = true;
    }
    try {
        super.layoutChildren();
        invalidate();
        if (mAdapter == null) {
            resetList();
            invokeOnItemScrollListener();
            return;
        }
        final int childrenTop = mListPadding.top;
        final int childrenBottom = mBottom - mTop - mListPadding.bottom;
        int childCount = getChildCount();
        int index;
        int delta = 0;
        View sel;
        View oldSel = null;
        View oldFirst = null;
        View newSel = null;
        // Remember stuff we will need down below
        switch(mLayoutMode) {
            case LAYOUT_SET_SELECTION:
                index = mNextSelectedPosition - mFirstPosition;
                if (index >= 0 && index < childCount) {
                    newSel = getChildAt(index);
                }
                break;
            case LAYOUT_FORCE_TOP:
            case LAYOUT_FORCE_BOTTOM:
            case LAYOUT_SPECIFIC:
            case LAYOUT_SYNC:
                break;
            case LAYOUT_MOVE_SELECTION:
                if (mNextSelectedPosition >= 0) {
                    delta = mNextSelectedPosition - mSelectedPosition;
                }
                break;
            default:
                // Remember the previously selected view
                index = mSelectedPosition - mFirstPosition;
                if (index >= 0 && index < childCount) {
                    oldSel = getChildAt(index);
                }
                // Remember the previous first child
                oldFirst = getChildAt(0);
        }
        boolean dataChanged = mDataChanged;
        if (dataChanged) {
            handleDataChanged();
        }
        // and calling it a day
        if (mItemCount == 0) {
            resetList();
            invokeOnItemScrollListener();
            return;
        }
        setSelectedPositionInt(mNextSelectedPosition);
        // Pull all children into the RecycleBin.
        // These views will be reused if possible
        final int firstPosition = mFirstPosition;
        final RecycleBin recycleBin = mRecycler;
        if (dataChanged) {
            for (int i = 0; i < childCount; i++) {
                recycleBin.addScrapView(getChildAt(i));
            }
        } else {
            recycleBin.fillActiveViews(childCount, firstPosition);
        }
        // Clear out old views
        // removeAllViewsInLayout();
        detachAllViewsFromParent();
        switch(mLayoutMode) {
            case LAYOUT_SET_SELECTION:
                if (newSel != null) {
                    sel = fillFromSelection(newSel.getTop(), childrenTop, childrenBottom);
                } else {
                    sel = fillSelection(childrenTop, childrenBottom);
                }
                break;
            case LAYOUT_FORCE_TOP:
                mFirstPosition = 0;
                sel = fillFromTop(childrenTop);
                adjustViewsUpOrDown();
                break;
            case LAYOUT_FORCE_BOTTOM:
                sel = fillUp(mItemCount - 1, childrenBottom);
                adjustViewsUpOrDown();
                break;
            case LAYOUT_SPECIFIC:
                sel = fillSpecific(mSelectedPosition, mSpecificTop);
                break;
            case LAYOUT_SYNC:
                sel = fillSpecific(mSyncPosition, mSpecificTop);
                break;
            case LAYOUT_MOVE_SELECTION:
                // Move the selection relative to its old position
                sel = moveSelection(delta, childrenTop, childrenBottom);
                break;
            default:
                if (childCount == 0) {
                    if (!mStackFromBottom) {
                        setSelectedPositionInt(0);
                        sel = fillFromTop(childrenTop);
                    } else {
                        final int last = mItemCount - 1;
                        setSelectedPositionInt(last);
                        sel = fillFromBottom(last, childrenBottom);
                    }
                } else {
                    if (mSelectedPosition >= 0 && mSelectedPosition < mItemCount) {
                        sel = fillSpecific(mSelectedPosition, oldSel == null ? childrenTop : oldSel.getTop());
                    } else if (mFirstPosition < mItemCount) {
                        sel = fillSpecific(mFirstPosition, oldFirst == null ? childrenTop : oldFirst.getTop());
                    } else {
                        sel = fillSpecific(0, childrenTop);
                    }
                }
                break;
        }
        // Flush any cached views that did not get reused above
        recycleBin.scrapActiveViews();
        if (sel != null) {
            positionSelector(sel);
            mSelectedTop = sel.getTop();
        } else if (mTouchMode > TOUCH_MODE_DOWN && mTouchMode < TOUCH_MODE_SCROLL) {
            View child = getChildAt(mMotionPosition - mFirstPosition);
            if (child != null)
                positionSelector(child);
        } else {
            mSelectedTop = 0;
            mSelectorRect.setEmpty();
        }
        mLayoutMode = LAYOUT_NORMAL;
        mDataChanged = false;
        mNeedSync = false;
        setNextSelectedPositionInt(mSelectedPosition);
        updateScrollIndicators();
        if (mItemCount > 0) {
            checkSelectionChanged();
        }
        invokeOnItemScrollListener();
    } finally {
        if (!blockLayoutRequests) {
            mBlockLayoutRequests = false;
        }
    }
}","{
    final boolean blockLayoutRequests = mBlockLayoutRequests;
    if (!blockLayoutRequests) {
        mBlockLayoutRequests = true;
    }
    try {
        super.layoutChildren();
        invalidate();
        if (mAdapter == null) {
            resetList();
            invokeOnItemScrollListener();
            return;
        }
        final int childrenTop = mListPadding.top;
        final int childrenBottom = mBottom - mTop - mListPadding.bottom;
        int childCount = getChildCount();
        int index;
        int delta = 0;
        View sel;
        View oldSel = null;
        View oldFirst = null;
        View newSel = null;
        // Remember stuff we will need down below
        switch(mLayoutMode) {
            case LAYOUT_SET_SELECTION:
                index = mNextSelectedPosition - mFirstPosition;
                if (index >= 0 && index < childCount) {
                    newSel = getChildAt(index);
                }
                break;
            case LAYOUT_FORCE_TOP:
            case LAYOUT_FORCE_BOTTOM:
            case LAYOUT_SPECIFIC:
            case LAYOUT_SYNC:
                break;
            case LAYOUT_MOVE_SELECTION:
                if (mNextSelectedPosition >= 0) {
                    delta = mNextSelectedPosition - mSelectedPosition;
                }
                break;
            default:
                // Remember the previously selected view
                index = mSelectedPosition - mFirstPosition;
                if (index >= 0 && index < childCount) {
                    oldSel = getChildAt(index);
                }
                // Remember the previous first child
                oldFirst = getChildAt(0);
        }
        boolean dataChanged = mDataChanged;
        if (dataChanged) {
            handleDataChanged();
        }
        // and calling it a day
        if (mItemCount == 0) {
            resetList();
            invokeOnItemScrollListener();
            return;
        }
        setSelectedPositionInt(mNextSelectedPosition);
        // Pull all children into the RecycleBin.
        // These views will be reused if possible
        final int firstPosition = mFirstPosition;
        final RecycleBin recycleBin = mRecycler;
        if (dataChanged) {
            for (int i = 0; i < childCount; i++) {
                recycleBin.addScrapView(getChildAt(i));
            }
        } else {
            recycleBin.fillActiveViews(childCount, firstPosition);
        }
        // Clear out old views
        // removeAllViewsInLayout();
        detachAllViewsFromParent();
        switch(mLayoutMode) {
            case LAYOUT_SET_SELECTION:
                if (newSel != null) {
                    sel = fillFromSelection(newSel.getTop(), childrenTop, childrenBottom);
                } else {
                    sel = fillSelection(childrenTop, childrenBottom);
                }
                break;
            case LAYOUT_FORCE_TOP:
                mFirstPosition = 0;
                sel = fillFromTop(childrenTop);
                adjustViewsUpOrDown();
                break;
            case LAYOUT_FORCE_BOTTOM:
                sel = fillUp(mItemCount - 1, childrenBottom);
                adjustViewsUpOrDown();
                break;
            case LAYOUT_SPECIFIC:
                sel = fillSpecific(mSelectedPosition, mSpecificTop);
                break;
            case LAYOUT_SYNC:
                sel = fillSpecific(mSyncPosition, mSpecificTop);
                break;
            case LAYOUT_MOVE_SELECTION:
                // Move the selection relative to its old position
                sel = moveSelection(delta, childrenTop, childrenBottom);
                break;
            default:
                if (childCount == 0) {
                    if (!mStackFromBottom) {
                        setSelectedPositionInt(mAdapter == null || isInTouchMode() ? INVALID_POSITION : 0);
                        sel = fillFromTop(childrenTop);
                    } else {
                        final int last = mItemCount - 1;
                        setSelectedPositionInt(mAdapter == null || isInTouchMode() ? INVALID_POSITION : last);
                        sel = fillFromBottom(last, childrenBottom);
                    }
                } else {
                    if (mSelectedPosition >= 0 && mSelectedPosition < mItemCount) {
                        sel = fillSpecific(mSelectedPosition, oldSel == null ? childrenTop : oldSel.getTop());
                    } else if (mFirstPosition < mItemCount) {
                        sel = fillSpecific(mFirstPosition, oldFirst == null ? childrenTop : oldFirst.getTop());
                    } else {
                        sel = fillSpecific(0, childrenTop);
                    }
                }
                break;
        }
        // Flush any cached views that did not get reused above
        recycleBin.scrapActiveViews();
        if (sel != null) {
            positionSelector(sel);
            mSelectedTop = sel.getTop();
        } else if (mTouchMode > TOUCH_MODE_DOWN && mTouchMode < TOUCH_MODE_SCROLL) {
            View child = getChildAt(mMotionPosition - mFirstPosition);
            if (child != null)
                positionSelector(child);
        } else {
            mSelectedTop = 0;
            mSelectorRect.setEmpty();
        }
        mLayoutMode = LAYOUT_NORMAL;
        mDataChanged = false;
        mNeedSync = false;
        setNextSelectedPositionInt(mSelectedPosition);
        updateScrollIndicators();
        if (mItemCount > 0) {
            checkSelectionChanged();
        }
        invokeOnItemScrollListener();
    } finally {
        if (!blockLayoutRequests) {
            mBlockLayoutRequests = false;
        }
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,3,1,"The control dependency, specifically the condition statement in the default switch case has changed. Before the change, setSelectedPositionInt() always receive 0 or last position regardless of other conditions. After the change, setSelectedPositionInt() might receive INVALID_POSITION if either mAdapter is null or the mode is in touch mode. This is a Control dependency changed issue.","The change in condition statement could lead to different return values. For instance, if setSelectedPositionInt() receives INVALID_POSITION instead of 0 or the last position, the getter method might return a different value. Thus, a compatibility issue caused by potential different return value exists."
139,"<android.webkit.WebViewDatabase: void setFormData(String,HashMap<String, String>)>",7,8,"<android.webkit.WebViewDatabase: void setFormData(String,HashMap<String, String>)>","<android.webkit.WebViewDatabase: void setFormData(String,HashMap<String, String>)>",0,"{
    if (url == null || formdata == null || mDatabase == null) {
        return;
    }
    final String selection = ""("" + FORMURL_URL_COL + "" == ?)"";
    synchronized (mFormLock) {
        long urlid = -1;
        Cursor cursor = mDatabase.query(mTableNames[TABLE_FORMURL_ID], ID_PROJECTION, selection, new String[] { url }, null, null, null);
        if (cursor.moveToFirst()) {
            urlid = cursor.getLong(cursor.getColumnIndex(ID_COL));
        } else {
            ContentValues c = new ContentValues();
            c.put(FORMURL_URL_COL, url);
            urlid = mDatabase.insert(mTableNames[TABLE_FORMURL_ID], null, c);
        }
        cursor.close();
        if (urlid >= 0) {
            Set<Entry<String, String>> set = formdata.entrySet();
            Iterator<Entry<String, String>> iter = set.iterator();
            ContentValues map = new ContentValues();
            map.put(FORMDATA_URLID_COL, urlid);
            while (iter.hasNext()) {
                Entry<String, String> entry = iter.next();
                map.put(FORMDATA_NAME_COL, entry.getKey());
                map.put(FORMDATA_VALUE_COL, entry.getValue());
                mDatabase.insert(mTableNames[TABLE_FORMDATA_ID], null, map);
            }
        }
    }
}","{
    if (url == null || formdata == null || mDatabase == null) {
        return;
    }
    final String selection = ""("" + FORMURL_URL_COL + "" == ?)"";
    synchronized (mFormLock) {
        long urlid = -1;
        Cursor cursor = null;
        try {
            cursor = mDatabase.query(mTableNames[TABLE_FORMURL_ID], ID_PROJECTION, selection, new String[] { url }, null, null, null);
            if (cursor.moveToFirst()) {
                urlid = cursor.getLong(cursor.getColumnIndex(ID_COL));
            } else {
                ContentValues c = new ContentValues();
                c.put(FORMURL_URL_COL, url);
                urlid = mDatabase.insert(mTableNames[TABLE_FORMURL_ID], null, c);
            }
        } catch (IllegalStateException e) {
            Log.e(LOGTAG, ""setFormData"", e);
        } finally {
            if (cursor != null)
                cursor.close();
        }
        if (urlid >= 0) {
            Set<Entry<String, String>> set = formdata.entrySet();
            Iterator<Entry<String, String>> iter = set.iterator();
            ContentValues map = new ContentValues();
            map.put(FORMDATA_URLID_COL, urlid);
            while (iter.hasNext()) {
                Entry<String, String> entry = iter.next();
                map.put(FORMDATA_NAME_COL, entry.getKey());
                map.put(FORMDATA_VALUE_COL, entry.getValue());
                mDatabase.insert(mTableNames[TABLE_FORMDATA_ID], null, map);
            }
        }
    }
}",1,"/**
 * Set form data for a site. Tuple (FORMDATA_URLID_COL, FORMDATA_NAME_COL,
 * FORMDATA_VALUE_COL) is unique
 *
 * @param url The url of the site
 * @param formdata The form data in HashMap
 */
","/**
 * Set form data for a site. Tuple (FORMDATA_URLID_COL, FORMDATA_NAME_COL,
 * FORMDATA_VALUE_COL) is unique
 *
 * @param url The url of the site
 * @param formdata The form data in HashMap
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,3",2,"A new exception handling statement has been introduced (catch (IllegalStateException e)), and the control flow for cursor closing is changed (from a direct statement to an if condition within a finally block), so the change type is 2,3.","The introduced exception handling will cause a different exception-handling behaviour, so the CI type is 2."
140,"<android.provider.Browser: void requestAllIcons(ContentResolver,String,IconListener)>",7,8,"<android.provider.Browser: void requestAllIcons(ContentResolver,String,IconListener)>","<android.provider.Browser: void requestAllIcons(ContentResolver,String,IconListener)>",0,"{
    try {
        final Cursor c = cr.query(BOOKMARKS_URI, HISTORY_PROJECTION, where, null, null);
        if (c.moveToFirst()) {
            final WebIconDatabase db = WebIconDatabase.getInstance();
            do {
                db.requestIconForPageUrl(c.getString(HISTORY_PROJECTION_URL_INDEX), listener);
            } while (c.moveToNext());
        }
        c.deactivate();
    } catch (IllegalStateException e) {
        Log.e(LOGTAG, ""requestAllIcons"", e);
    }
}","{
    WebIconDatabase.getInstance().bulkRequestIconForPageUrl(cr, where, listener);
}",1,"/**
 * Request all icons from the database.
 * Requires {@link android.Manifest.permission#READ_HISTORY_BOOKMARKS}
 * @param  cr The ContentResolver used to access the database.
 * @param  where Clause to be used to limit the query from the database.
 * Must be an allowable string to be passed into a database query.
 * @param  listener IconListener that gets the icons once they are
 * retrieved.
 */
","/**
 * Request all icons from the database.  This call must either be called
 * in the main thread or have had Looper.prepare() invoked in the calling
 * thread.
 * Requires {@link android.Manifest.permission#READ_HISTORY_BOOKMARKS}
 * @param  cr The ContentResolver used to access the database.
 * @param  where Clause to be used to limit the query from the database.
 * Must be an allowable string to be passed into a database query.
 * @param  listener IconListener that gets the icons once they are
 * retrieved.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1, 3, 4, 5",1,"The whole API is changed. The new method bulkRequestIconForPageUrl() is introduced to replace the old statements. The changes have multiple levels including: changes on return, overall control logic, the behavior of the program and dependence, so the change types are 1, 3, 4, 5.","The introduced method bulkRequestIconForPageUrl() completely changes the way the method works and it might return different values than the previous version, thus leading to compatibility issues of type 1."
141,<android.webkit.FrameLoader: boolean executeLoad()>,7,8,<android.webkit.FrameLoader: boolean executeLoad()>,<android.webkit.FrameLoader: boolean executeLoad()>,0,"{
    String url = mListener.url();
    if (URLUtil.isNetworkUrl(url)) {
        if (mSettings.getBlockNetworkLoads()) {
            mListener.error(EventHandler.ERROR_BAD_URL, mListener.getContext().getString(com.android.internal.R.string.httpErrorBadUrl));
            return false;
        }
        // Make sure it is correctly URL encoded before sending the request
        if (!URLUtil.verifyURLEncoding(url)) {
            mListener.error(EventHandler.ERROR_BAD_URL, mListener.getContext().getString(com.android.internal.R.string.httpErrorBadUrl));
            return false;
        }
        mNetwork = Network.getInstance(mListener.getContext());
        return handleHTTPLoad();
    } else if (handleLocalFile(url, mListener, mSettings)) {
        return true;
    }
    if (DebugFlags.FRAME_LOADER) {
        Log.v(LOGTAG, ""FrameLoader.executeLoad: url protocol not supported:"" + mListener.url());
    }
    mListener.error(EventHandler.ERROR_UNSUPPORTED_SCHEME, mListener.getContext().getText(com.android.internal.R.string.httpErrorUnsupportedScheme).toString());
    return false;
}","{
    String url = mListener.url();
    if (URLUtil.isNetworkUrl(url)) {
        if (mSettings.getBlockNetworkLoads()) {
            mListener.error(EventHandler.ERROR_BAD_URL, mListener.getContext().getString(com.android.internal.R.string.httpErrorBadUrl));
            return false;
        }
        // encoded before sending the request
        if (!URLUtil.verifyURLEncoding(mListener.host())) {
            mListener.error(EventHandler.ERROR_BAD_URL, mListener.getContext().getString(com.android.internal.R.string.httpErrorBadUrl));
            return false;
        }
        mNetwork = Network.getInstance(mListener.getContext());
        if (mListener.isSynchronous()) {
            return handleHTTPLoad();
        }
        WebViewWorker.getHandler().obtainMessage(WebViewWorker.MSG_ADD_HTTPLOADER, this).sendToTarget();
        return true;
    } else if (handleLocalFile(url, mListener, mSettings)) {
        return true;
    }
    if (DebugFlags.FRAME_LOADER) {
        Log.v(LOGTAG, ""FrameLoader.executeLoad: url protocol not supported:"" + mListener.url());
    }
    mListener.error(EventHandler.ERROR_UNSUPPORTED_SCHEME, mListener.getContext().getText(com.android.internal.R.string.httpErrorUnsupportedScheme).toString());
    return false;
}",1,"/**
 * Issues the load request.
 *
 * Return value does not indicate if the load was successful or not. It
 * simply indicates that the load request is reasonable.
 *
 * @return true if the load is reasonable.
 */
","/**
 * Issues the load request.
 *
 * Return value does not indicate if the load was successful or not. It
 * simply indicates that the load request is reasonable.
 *
 * @return true if the load is reasonable.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3,4",1,"In the second 'if' statement, 'URLUtil.verifyURLEncoding(url)' changes to 'URLUtil.verifyURLEncoding(mListener.host())' and a new 'if' statement 'mListener.isSynchronous()' has been introduced with a new 'return true' statement. Another return statement 'WebViewWorker.getHandler().obtainMessage(WebViewWorker.MSG_ADD_HTTPLOADER, this).sendToTarget();' is also introduced. Hence, the code change type is 1,3,4.","The change in return statements could potentially lead the API to return a different boolean value in those introduced scenarios, thus results in a different behavior. Hence, the CI type is 1."
142,<android.net.http.SslCertificate: String getValidNotAfter()>,7,8,<android.net.http.SslCertificate: String getValidNotAfter()>,<android.net.http.SslCertificate: String getValidNotAfter()>,0,"{
    return mValidNotAfter != null ? mValidNotAfter : """";
}","{
    return formatDate(mValidNotAfter);
}",1,"/**
 * @return Not-after date from the certificate validity period or
 * """" if none has been set
 */
","/**
 * @return Not-after date from the certificate validity period in
 * ISO 8601 format or """" if none has been set
 *
 * @deprecated Use {@link #getValidNotAfterDate()}
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The return statement has changed from the version that directly returns the string of the 'mValidNotAfter' (or an empty string if 'mValidNotAfter' is null) to the version format the date of 'mValidNotAfter'. Also, the API 'formatDate' is a dependent API, therefore the change type is 1,5.","Due to the implementation logic change, which involves changes in return type, Compatibility Issue arises which causes the API getValidNotAfter() to potentially return a different value or type, therefore the CI type is 1."
143,"<android.provider.MediaStore.Video.Thumbnails: Bitmap getThumbnail(ContentResolver,long,int,Options)>",7,8,"<android.provider.MediaStore.Video.Thumbnails: Bitmap getThumbnail(ContentResolver,long,int,Options)>","<android.provider.MediaStore.Video.Thumbnails: Bitmap getThumbnail(ContentResolver,long,int,Options)>",0,"{
    return InternalThumbnails.getThumbnail(cr, origId, kind, options, EXTERNAL_CONTENT_URI, true);
}","{
    return InternalThumbnails.getThumbnail(cr, origId, InternalThumbnails.DEFAULT_GROUP_ID, kind, options, EXTERNAL_CONTENT_URI, true);
}",1,"/**
 * This method checks if the thumbnails of the specified image (origId) has been created.
 * It will be blocked until the thumbnails are generated.
 *
 * @param cr ContentResolver used to dispatch queries to MediaProvider.
 * @param origId Original image id associated with thumbnail of interest.
 * @param kind The type of thumbnail to fetch. Should be either MINI_KIND or MICRO_KIND
 * @param options this is only used for MINI_KIND when decoding the Bitmap
 * @return A Bitmap instance. It could be null if the original image associated with
 * origId doesn't exist or memory is not enough.
 */
","/**
 * This method checks if the thumbnails of the specified image (origId) has been created.
 * It will be blocked until the thumbnails are generated.
 *
 * @param cr ContentResolver used to dispatch queries to MediaProvider.
 * @param origId Original image id associated with thumbnail of interest.
 * @param kind The type of thumbnail to fetch. Should be either MINI_KIND or MICRO_KIND.
 * @param options this is only used for MINI_KIND when decoding the Bitmap
 * @return A Bitmap instance. It could be null if the original image
 * associated with origId doesn't exist or memory is not enough.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,The method getThumbnail() in the class InternalThumbnails takes in more parameters in the late version than the early version. This is classified as type 1 (Return statement changed) and type 5 (Dependent API changed).,"With the changes in the parameters, the call to InternalThumbnails.getThumbnail() might potentially return a different value, causing a compatibility issue of type 1 (Compatibility Issue caused by potential different return values or types)."
146,<android.view.ViewStub: View inflate()>,7,8,<android.view.ViewStub: View inflate()>,<android.view.ViewStub: View inflate()>,0,"{
    final ViewParent viewParent = getParent();
    if (viewParent != null && viewParent instanceof ViewGroup) {
        if (mLayoutResource != 0) {
            final ViewGroup parent = (ViewGroup) viewParent;
            final LayoutInflater factory = LayoutInflater.from(mContext);
            final View view = factory.inflate(mLayoutResource, parent, false);
            if (mInflatedId != NO_ID) {
                view.setId(mInflatedId);
            }
            final int index = parent.indexOfChild(this);
            parent.removeViewInLayout(this);
            final ViewGroup.LayoutParams layoutParams = getLayoutParams();
            if (layoutParams != null) {
                parent.addView(view, index, layoutParams);
            } else {
                parent.addView(view, index);
            }
            mInflatedViewRef = new WeakReference(view);
            if (mInflateListener != null) {
                mInflateListener.onInflate(this, view);
            }
            return view;
        } else {
            throw new IllegalArgumentException(""ViewStub must have a valid layoutResource"");
        }
    } else {
        throw new IllegalStateException(""ViewStub must have a non-null ViewGroup viewParent"");
    }
}","{
    final ViewParent viewParent = getParent();
    if (viewParent != null && viewParent instanceof ViewGroup) {
        if (mLayoutResource != 0) {
            final ViewGroup parent = (ViewGroup) viewParent;
            final LayoutInflater factory = LayoutInflater.from(mContext);
            final View view = factory.inflate(mLayoutResource, parent, false);
            if (mInflatedId != NO_ID) {
                view.setId(mInflatedId);
            }
            final int index = parent.indexOfChild(this);
            parent.removeViewInLayout(this);
            final ViewGroup.LayoutParams layoutParams = getLayoutParams();
            if (layoutParams != null) {
                parent.addView(view, index, layoutParams);
            } else {
                parent.addView(view, index);
            }
            mInflatedViewRef = new WeakReference<View>(view);
            if (mInflateListener != null) {
                mInflateListener.onInflate(this, view);
            }
            return view;
        } else {
            throw new IllegalArgumentException(""ViewStub must have a valid layoutResource"");
        }
    } else {
        throw new IllegalStateException(""ViewStub must have a non-null ViewGroup viewParent"");
    }
}",1,"/**
 * Inflates the layout resource identified by {@link #getLayoutResource()}
 * and replaces this StubbedView in its parent by the inflated layout resource.
 *
 * @return The inflated layout resource.
 */
","/**
 * Inflates the layout resource identified by {@link #getLayoutResource()}
 * and replaces this StubbedView in its parent by the inflated layout resource.
 *
 * @return The inflated layout resource.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,The instantiation of the 'WeakReference' object has changed to include an explicit generic type 'View' in the late version 'mInflatedViewRef = new WeakReference<View>(view);'. This change type is categorized as an other statement change.,"This change doesn't affect the behavior of the API, as it does not alter the return values or the exception handling. Consequently, there is no Compatibility Issue."
148,<android.accounts.AccountManager.GetAuthTokenByTypeAndFeaturesTask: void doWork()>,7,8,<android.accounts.AccountManager.GetAuthTokenByTypeAndFeaturesTask: void doWork()>,<android.accounts.AccountManager.GetAuthTokenByTypeAndFeaturesTask: void doWork()>,0,"{
    getAccountsByTypeAndFeatures(mAccountType, mFeatures, new AccountManagerCallback<Account[]>() {

        public void run(AccountManagerFuture<Account[]> future) {
            Account[] accounts;
            try {
                accounts = future.getResult();
            } catch (OperationCanceledException e) {
                setException(e);
                return;
            } catch (IOException e) {
                setException(e);
                return;
            } catch (AuthenticatorException e) {
                setException(e);
                return;
            }
            if (accounts.length == 0) {
                if (mActivity != null) {
                    // no accounts, add one now. pretend that the user directly
                    // made this request
                    mFuture = addAccount(mAccountType, mAuthTokenType, mFeatures, mAddAccountOptions, mActivity, mMyCallback, mHandler);
                } else {
                    // send result since we can't prompt to add an account
                    Bundle result = new Bundle();
                    result.putString(KEY_ACCOUNT_NAME, null);
                    result.putString(KEY_ACCOUNT_TYPE, null);
                    result.putString(KEY_AUTHTOKEN, null);
                    try {
                        mResponse.onResult(result);
                    } catch (RemoteException e) {
                    // this will never happen
                    }
                // we are done
                }
            } else if (accounts.length == 1) {
                // have a single account, return an authtoken for it
                if (mActivity == null) {
                    mFuture = getAuthToken(accounts[0], mAuthTokenType, false, /* notifyAuthFailure */
                    mMyCallback, mHandler);
                } else {
                    mFuture = getAuthToken(accounts[0], mAuthTokenType, mLoginOptions, mActivity, mMyCallback, mHandler);
                }
            } else {
                if (mActivity != null) {
                    IAccountManagerResponse chooseResponse = new IAccountManagerResponse.Stub() {

                        public void onResult(Bundle value) throws RemoteException {
                            Account account = new Account(value.getString(KEY_ACCOUNT_NAME), value.getString(KEY_ACCOUNT_TYPE));
                            mFuture = getAuthToken(account, mAuthTokenType, mLoginOptions, mActivity, mMyCallback, mHandler);
                        }

                        public void onError(int errorCode, String errorMessage) throws RemoteException {
                            mResponse.onError(errorCode, errorMessage);
                        }
                    };
                    // have many accounts, launch the chooser
                    Intent intent = new Intent();
                    intent.setClassName(""android"", ""android.accounts.ChooseAccountActivity"");
                    intent.putExtra(KEY_ACCOUNTS, accounts);
                    intent.putExtra(KEY_ACCOUNT_MANAGER_RESPONSE, new AccountManagerResponse(chooseResponse));
                    mActivity.startActivity(intent);
                // the result will arrive via the IAccountManagerResponse
                } else {
                    // send result since we can't prompt to select an account
                    Bundle result = new Bundle();
                    result.putString(KEY_ACCOUNTS, null);
                    try {
                        mResponse.onResult(result);
                    } catch (RemoteException e) {
                    // this will never happen
                    }
                // we are done
                }
            }
        }
    }, mHandler);
}","{
    getAccountsByTypeAndFeatures(mAccountType, mFeatures, new AccountManagerCallback<Account[]>() {

        public void run(AccountManagerFuture<Account[]> future) {
            Account[] accounts;
            try {
                accounts = future.getResult();
            } catch (OperationCanceledException e) {
                setException(e);
                return;
            } catch (IOException e) {
                setException(e);
                return;
            } catch (AuthenticatorException e) {
                setException(e);
                return;
            }
            mNumAccounts = accounts.length;
            if (accounts.length == 0) {
                if (mActivity != null) {
                    // no accounts, add one now. pretend that the user directly
                    // made this request
                    mFuture = addAccount(mAccountType, mAuthTokenType, mFeatures, mAddAccountOptions, mActivity, mMyCallback, mHandler);
                } else {
                    // send result since we can't prompt to add an account
                    Bundle result = new Bundle();
                    result.putString(KEY_ACCOUNT_NAME, null);
                    result.putString(KEY_ACCOUNT_TYPE, null);
                    result.putString(KEY_AUTHTOKEN, null);
                    try {
                        mResponse.onResult(result);
                    } catch (RemoteException e) {
                    // this will never happen
                    }
                // we are done
                }
            } else if (accounts.length == 1) {
                // have a single account, return an authtoken for it
                if (mActivity == null) {
                    mFuture = getAuthToken(accounts[0], mAuthTokenType, false, /* notifyAuthFailure */
                    mMyCallback, mHandler);
                } else {
                    mFuture = getAuthToken(accounts[0], mAuthTokenType, mLoginOptions, mActivity, mMyCallback, mHandler);
                }
            } else {
                if (mActivity != null) {
                    IAccountManagerResponse chooseResponse = new IAccountManagerResponse.Stub() {

                        public void onResult(Bundle value) throws RemoteException {
                            Account account = new Account(value.getString(KEY_ACCOUNT_NAME), value.getString(KEY_ACCOUNT_TYPE));
                            mFuture = getAuthToken(account, mAuthTokenType, mLoginOptions, mActivity, mMyCallback, mHandler);
                        }

                        public void onError(int errorCode, String errorMessage) throws RemoteException {
                            mResponse.onError(errorCode, errorMessage);
                        }
                    };
                    // have many accounts, launch the chooser
                    Intent intent = new Intent();
                    intent.setClassName(""android"", ""android.accounts.ChooseAccountActivity"");
                    intent.putExtra(KEY_ACCOUNTS, accounts);
                    intent.putExtra(KEY_ACCOUNT_MANAGER_RESPONSE, new AccountManagerResponse(chooseResponse));
                    mActivity.startActivity(intent);
                // the result will arrive via the IAccountManagerResponse
                } else {
                    // send result since we can't prompt to select an account
                    Bundle result = new Bundle();
                    result.putString(KEY_ACCOUNTS, null);
                    try {
                        mResponse.onResult(result);
                    } catch (RemoteException e) {
                    // this will never happen
                    }
                // we are done
                }
            }
        }
    }, mHandler);
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,4,0,"There is only one more statement (mNumAccounts = accounts.length;) in the late version than the early version. Therefore, the code change type is 4.","Because this added statement only changes a status variable but it doesn't lead to any changes in the function return context or thrown exceptions, the CI type is 0."
149,<android.database.sqlite.SQLiteStatement: String simpleQueryForString()>,7,8,<android.database.sqlite.SQLiteStatement: String simpleQueryForString()>,<android.database.sqlite.SQLiteStatement: String simpleQueryForString()>,0,"{
    mDatabase.lock();
    boolean logStats = mDatabase.mLogStats;
    long startTime = logStats ? SystemClock.elapsedRealtime() : 0;
    acquireReference();
    try {
        if (SQLiteDebug.DEBUG_SQL_STATEMENTS) {
            Log.v(TAG, ""simpleQueryForString() for ["" + mSql + ""]"");
        }
        String retValue = native_1x1_string();
        if (logStats) {
            mDatabase.logTimeStat(false, /* write */
            startTime, SystemClock.elapsedRealtime());
        }
        return retValue;
    } finally {
        releaseReference();
        mDatabase.unlock();
    }
}","{
    if (!mDatabase.isOpen()) {
        throw new IllegalStateException(""database "" + mDatabase.getPath() + "" already closed"");
    }
    long timeStart = SystemClock.uptimeMillis();
    mDatabase.lock();
    acquireReference();
    try {
        String retValue = native_1x1_string();
        mDatabase.logTimeStat(mSql, timeStart);
        return retValue;
    } finally {
        releaseReference();
        mDatabase.unlock();
    }
}",1,"/**
 * Execute a statement that returns a 1 by 1 table with a text value.
 * For example, SELECT COUNT(*) FROM table;
 *
 * @return The result of the query.
 *
 * @throws android.database.sqlite.SQLiteDoneException if the query returns zero rows
 */
","/**
 * Execute a statement that returns a 1 by 1 table with a text value.
 * For example, SELECT COUNT(*) FROM table;
 *
 * @return The result of the query.
 *
 * @throws android.database.sqlite.SQLiteDoneException if the query returns zero rows
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,2,3,4","1,2","In the late version of the implementation, a new statement (throw new IllegalStateException(""database "" + mDatabase.getPath() + "" already closed"")) is introduced, which changes the exception handling statements. Additionally, the method code itself is changed, as the logging mechanism and time measurement are updated, which also causes changes in the return statement and control dependency. Hence the code change type is 1,2,3,4.","The introduction of a new exception (IllegalStateException) could lead to a different behaviour when an error occurs. Furthermore, the modification in code could potentially return a different value. Therefore, the CI type is 1,2."
151,"<android.gesture.GestureStore: void save(OutputStream,boolean)>",7,8,"<android.gesture.GestureStore: void save(OutputStream,boolean)>","<android.gesture.GestureStore: void save(OutputStream,boolean)>",0,"{
    DataOutputStream out = null;
    try {
        long start;
        if (PROFILE_LOADING_SAVING) {
            start = SystemClock.elapsedRealtime();
        }
        final HashMap<String, ArrayList<Gesture>> maps = mNamedGestures;
        out = new DataOutputStream((stream instanceof BufferedOutputStream) ? stream : new BufferedOutputStream(stream, GestureConstants.IO_BUFFER_SIZE));
        // Write version number
        out.writeShort(FILE_FORMAT_VERSION);
        // Write number of entries
        out.writeInt(maps.size());
        for (Map.Entry<String, ArrayList<Gesture>> entry : maps.entrySet()) {
            final String key = entry.getKey();
            final ArrayList<Gesture> examples = entry.getValue();
            final int count = examples.size();
            // Write entry name
            out.writeUTF(key);
            // Write number of examples for this entry
            out.writeInt(count);
            for (int i = 0; i < count; i++) {
                examples.get(i).serialize(out);
            }
        }
        out.flush();
        if (PROFILE_LOADING_SAVING) {
            long end = SystemClock.elapsedRealtime();
            Log.d(LOG_TAG, ""Saving gestures library = "" + (end - start) + "" ms"");
        }
        mChanged = false;
    } finally {
        if (closeStream)
            GestureUtilities.closeStream(out);
    }
}","{
    DataOutputStream out = null;
    try {
        long start;
        if (PROFILE_LOADING_SAVING) {
            start = SystemClock.elapsedRealtime();
        }
        final HashMap<String, ArrayList<Gesture>> maps = mNamedGestures;
        out = new DataOutputStream((stream instanceof BufferedOutputStream) ? stream : new BufferedOutputStream(stream, GestureConstants.IO_BUFFER_SIZE));
        // Write version number
        out.writeShort(FILE_FORMAT_VERSION);
        // Write number of entries
        out.writeInt(maps.size());
        for (Map.Entry<String, ArrayList<Gesture>> entry : maps.entrySet()) {
            final String key = entry.getKey();
            final ArrayList<Gesture> examples = entry.getValue();
            final int count = examples.size();
            // Write entry name
            out.writeUTF(key);
            // Write number of examples for this entry
            out.writeInt(count);
            for (int i = 0; i < count; i++) {
                examples.get(i).serialize(out);
            }
        }
        out.flush();
        if (PROFILE_LOADING_SAVING) {
            long end = SystemClock.elapsedRealtime();
            Log.d(LOG_TAG, ""Saving gestures library = "" + (end - start) + "" ms"");
        }
        mChanged = false;
    } finally {
        if (closeStream)
            GestureUtils.closeStream(out);
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"The name of the method used to close the stream in the finally block has changed from GestureUtilities.closeStream(out) to GestureUtils.closeStream(out). The code change type is 4,5: other statements changed and dependent API changed.","Despite the change in the method name, it does not cause a change in functionality or behaviour of the API. The changes here are not expected to cause different return values or types, or different exception handlings, therefore, no compatibility issue exists. The CI type is 0."
154,<android.database.sqlite.SQLiteDatabase: void close()>,7,8,<android.database.sqlite.SQLiteDatabase: void close()>,<android.database.sqlite.SQLiteDatabase: void close()>,0,"{
    lock();
    try {
        closeClosable();
        releaseReference();
    } finally {
        unlock();
    }
}","{
    if (!isOpen()) {
        // already closed
        return;
    }
    lock();
    try {
        closeClosable();
        // close this database instance - regardless of its reference count value
        onAllReferencesReleased();
    } finally {
        unlock();
    }
}",1,"/**
 * Close the database.
 */
","/**
 * Close the database.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3",1,"In the late version, a new 'if' condition is introduced which checks if the database is open or not. Also, an early return is described inside the 'if' condition, and the method releaseReference() has been replaced by onAllReferencesReleased(). Thus, the code change types are 1 and 3.","The early return introduced in the late version changes the flow of the program. Now, the program can potentially return from the function before doing any locking, closing, or releasing operations. Therefore, the CI type is 1."
156,"<android.webkit.WebTextView: void onTextChanged(CharSequence,int,int,int)>",7,8,"<android.webkit.WebTextView: void onTextChanged(CharSequence,int,int,int)>","<android.webkit.WebTextView: void onTextChanged(CharSequence,int,int,int)>",0,"{
    super.onTextChanged(s, start, before, count);
    String postChange = s.toString();
    // limit on text length from registering the onTextChanged event.
    if (mPreChange == null || mPreChange.equals(postChange) || (mMaxLength > -1 && mPreChange.length() > mMaxLength && mPreChange.substring(0, mMaxLength).equals(postChange))) {
        return;
    }
    mPreChange = postChange;
    // This was simply a delete or a cut, so just delete the selection.
    if (before > 0 && 0 == count) {
        mWebView.deleteSelection(start, start + before);
        // For this and all changes to the text, update our cache
        updateCachedTextfield();
        return;
    }
    // Find the last character being replaced.  If it can be represented by
    // events, we will pass them to native (after replacing the beginning
    // of the changed text), so we can see javascript events.
    // Otherwise, replace the text being changed (including the last
    // character) in the textfield.
    TextUtils.getChars(s, start + count - 1, start + count, mCharacter, 0);
    KeyCharacterMap kmap = KeyCharacterMap.load(KeyCharacterMap.BUILT_IN_KEYBOARD);
    KeyEvent[] events = kmap.getEvents(mCharacter);
    boolean cannotUseKeyEvents = null == events;
    int charactersFromKeyEvents = cannotUseKeyEvents ? 0 : 1;
    if (count > 1 || cannotUseKeyEvents) {
        String replace = s.subSequence(start, start + count - charactersFromKeyEvents).toString();
        mWebView.replaceTextfieldText(start, start + before, replace, start + count - charactersFromKeyEvents, start + count - charactersFromKeyEvents);
    } else {
        // trackball or auto-correct.
        if (DebugFlags.WEB_TEXT_VIEW) {
            Log.v(LOGTAG, ""onTextChanged start="" + start + "" start + before="" + (start + before));
        }
        if (!mInSetTextAndKeepSelection) {
            mWebView.setSelection(start, start + before);
        }
    }
    if (!cannotUseKeyEvents) {
        int length = events.length;
        for (int i = 0; i < length; i++) {
            // here either.
            if (!KeyEvent.isModifierKey(events[i].getKeyCode())) {
                sendDomEvent(events[i]);
            }
        }
    }
    updateCachedTextfield();
}","{
    super.onTextChanged(s, start, before, count);
    String postChange = s.toString();
    // limit on text length from registering the onTextChanged event.
    if (mPreChange == null || mPreChange.equals(postChange) || (mMaxLength > -1 && mPreChange.length() > mMaxLength && mPreChange.substring(0, mMaxLength).equals(postChange))) {
        return;
    }
    mPreChange = postChange;
    if (0 == count) {
        if (before > 0) {
            // This was simply a delete or a cut, so just delete the
            // selection.
            mWebView.deleteSelection(start, start + before);
            // For this and all changes to the text, update our cache
            updateCachedTextfield();
        }
        // changed, we should return.
        return;
    }
    // Find the last character being replaced.  If it can be represented by
    // events, we will pass them to native (after replacing the beginning
    // of the changed text), so we can see javascript events.
    // Otherwise, replace the text being changed (including the last
    // character) in the textfield.
    TextUtils.getChars(s, start + count - 1, start + count, mCharacter, 0);
    KeyCharacterMap kmap = KeyCharacterMap.load(KeyCharacterMap.BUILT_IN_KEYBOARD);
    KeyEvent[] events = kmap.getEvents(mCharacter);
    boolean cannotUseKeyEvents = null == events;
    int charactersFromKeyEvents = cannotUseKeyEvents ? 0 : 1;
    if (count > 1 || cannotUseKeyEvents) {
        String replace = s.subSequence(start, start + count - charactersFromKeyEvents).toString();
        mWebView.replaceTextfieldText(start, start + before, replace, start + count - charactersFromKeyEvents, start + count - charactersFromKeyEvents);
    } else {
        // trackball or auto-correct.
        if (DebugFlags.WEB_TEXT_VIEW) {
            Log.v(LOGTAG, ""onTextChanged start="" + start + "" start + before="" + (start + before));
        }
        if (!mInSetTextAndKeepSelection) {
            mWebView.setSelection(start, start + before);
        }
    }
    if (!cannotUseKeyEvents) {
        int length = events.length;
        for (int i = 0; i < length; i++) {
            // here either.
            if (!KeyEvent.isModifierKey(events[i].getKeyCode())) {
                sendDomEvent(events[i]);
            }
        }
    }
    updateCachedTextfield();
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,3,0,"The only change in this code is the modification in the control dependency of 'if' statements. In the early version, condition 'before > 0' and '0 == count' are combined, while they are decoupled in the late version. Thus, this changes under type 3 (Control dependency change)","The change in the control dependency does not potentially cause the API to return a different variable (value or type), or throws the exception differently. Therefore, no Compatibility Issue exists (type 0)."
157,<android.content.ContentValues: Float getAsFloat(String)>,7,8,<android.content.ContentValues: Float getAsFloat(String)>,<android.content.ContentValues: Float getAsFloat(String)>,0,"{
    Object value = mValues.get(key);
    try {
        return value != null ? ((Number) value).floatValue() : null;
    } catch (ClassCastException e) {
        if (value instanceof CharSequence) {
            try {
                return Float.valueOf(value.toString());
            } catch (NumberFormatException e2) {
                Log.e(TAG, ""Cannot parse Float value for "" + value + "" at key "" + key);
                return null;
            }
        } else {
            Log.e(TAG, ""Cannot cast value for "" + key + "" to a Float"");
            return null;
        }
    }
}","{
    Object value = mValues.get(key);
    try {
        return value != null ? ((Number) value).floatValue() : null;
    } catch (ClassCastException e) {
        if (value instanceof CharSequence) {
            try {
                return Float.valueOf(value.toString());
            } catch (NumberFormatException e2) {
                Log.e(TAG, ""Cannot parse Float value for "" + value + "" at key "" + key);
                return null;
            }
        } else {
            Log.e(TAG, ""Cannot cast value for "" + key + "" to a Float: "" + value, e);
            return null;
        }
    }
}",1,"/**
 * Gets a value and converts it to a Float.
 *
 * @param key the value to get
 * @return the Float value, or null if the value is missing or cannot be converted
 */
","/**
 * Gets a value and converts it to a Float.
 *
 * @param key the value to get
 * @return the Float value, or null if the value is missing or cannot be converted
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The change is in the log statement, specifically, an additional string concatenation and error throwing 'e' is added to the log within the else clause of the ClassCastException catch block. This change does not affect or modify the return statements, the exception handling strategy or any control dependencies and hence falls under type 4.","The change merely affects the log output and does not modify the behaviour of the method. The values returned, exceptions thrown and the control flow remain the same. Therefore, no Compatibility Issue should be introduced due to this change."
158,<android.webkit.WebView: void onDraw(Canvas)>,7,8,<android.webkit.WebView: void onDraw(Canvas)>,<android.webkit.WebView: void onDraw(Canvas)>,0,"{
    // if mNativeClass is 0, the WebView has been destroyed. Do nothing.
    if (mNativeClass == 0) {
        return;
    }
    int saveCount = canvas.save();
    if (mTitleBar != null) {
        canvas.translate(0, (int) mTitleBar.getHeight());
    }
    if (mDragTrackerHandler == null || !mDragTrackerHandler.draw(canvas)) {
        drawContent(canvas);
    }
    canvas.restoreToCount(saveCount);
    // Now draw the shadow.
    if (mTitleBar != null) {
        int y = mScrollY + getVisibleTitleHeight();
        int height = (int) (5f * getContext().getResources().getDisplayMetrics().density);
        mTitleShadow.setBounds(mScrollX, y, mScrollX + getWidth(), y + height);
        mTitleShadow.draw(canvas);
    }
    if (AUTO_REDRAW_HACK && mAutoRedraw) {
        invalidate();
    }
}","{
    // if mNativeClass is 0, the WebView has been destroyed. Do nothing.
    if (mNativeClass == 0) {
        return;
    }
    // just starts. Draw the background and return.
    if ((mContentWidth | mContentHeight) == 0 && mHistoryPicture == null) {
        canvas.drawColor(mBackgroundColor);
        return;
    }
    int saveCount = canvas.save();
    if (mTitleBar != null) {
        canvas.translate(0, (int) mTitleBar.getHeight());
    }
    if (mDragTrackerHandler == null) {
        drawContent(canvas);
    } else {
        if (!mDragTrackerHandler.draw(canvas)) {
            // sometimes the tracker doesn't draw, even though its active
            drawContent(canvas);
        }
        if (mDragTrackerHandler.isFinished()) {
            mDragTrackerHandler = null;
        }
    }
    canvas.restoreToCount(saveCount);
    // Now draw the shadow.
    int titleH = getVisibleTitleHeight();
    if (mTitleBar != null && titleH == 0) {
        int height = (int) (5f * getContext().getResources().getDisplayMetrics().density);
        mTitleShadow.setBounds(mScrollX, mScrollY, mScrollX + getWidth(), mScrollY + height);
        mTitleShadow.draw(canvas);
    }
    if (AUTO_REDRAW_HACK && mAutoRedraw) {
        invalidate();
    }
    mWebViewCore.signalRepaintDone();
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,3,4",1,"Several changes are made in the late version API which can be classified into 3 types. Firstly, there are new return and condition statements introduced ((mContentWidth | mContentHeight) == 0 && mHistoryPicture == null), constituting both 'Return statement changed' (1) and 'Control dependency changed' (3). Secondly, the function calls in the 'if' conditions have changed, and a new branch (mDragTrackerHandler.isFinished()) is introduced under 'if (mDragTrackerHandler != null)', leading to 'Control dependency changed' (3). Lastly, a new method call (mWebViewCore.signalRepaintDone()) is added at the end of the method, which falls under 'Other statement changed' (4).","Since several statements that involve returning values and control dependencies have changed, there is potential for different behaviors and returned variable in the late version of the API. Therefore, there is 'Compatibility Issue caused by potential different return values or types' (1)."
159,"<android.database.sqlite.SQLiteQueryBuilder: String buildQuery(String[],String,String[],String,String,String,String)>",7,8,"<android.database.sqlite.SQLiteQueryBuilder: String buildQuery(String[],String,String[],String,String,String,String)>","<android.database.sqlite.SQLiteQueryBuilder: String buildQuery(String[],String,String[],String,String,String,String)>",0,"{
    String[] projection = computeProjection(projectionIn);
    StringBuilder where = new StringBuilder();
    if (mWhereClause.length() > 0) {
        where.append(mWhereClause.toString());
        where.append(')');
    }
    // Tack on the user's selection, if present.
    if (selection != null && selection.length() > 0) {
        if (mWhereClause.length() > 0) {
            where.append("" AND "");
        }
        where.append('(');
        where.append(selection);
        where.append(')');
    }
    return buildQueryString(mDistinct, mTables, projection, where.toString(), groupBy, having, sortOrder, limit);
}","{
    String[] projection = computeProjection(projectionIn);
    StringBuilder where = new StringBuilder();
    boolean hasBaseWhereClause = mWhereClause != null && mWhereClause.length() > 0;
    if (hasBaseWhereClause) {
        where.append(mWhereClause.toString());
        where.append(')');
    }
    // Tack on the user's selection, if present.
    if (selection != null && selection.length() > 0) {
        if (hasBaseWhereClause) {
            where.append("" AND "");
        }
        where.append('(');
        where.append(selection);
        where.append(')');
    }
    return buildQueryString(mDistinct, mTables, projection, where.toString(), groupBy, having, sortOrder, limit);
}",1,"/**
 * Construct a SELECT statement suitable for use in a group of
 * SELECT statements that will be joined through UNION operators
 * in buildUnionQuery.
 *
 * @param projectionIn A list of which columns to return. Passing
 * null will return all columns, which is discouraged to
 * prevent reading data from storage that isn't going to be
 * used.
 * @param selection A filter declaring which rows to return,
 * formatted as an SQL WHERE clause (excluding the WHERE
 * itself).  Passing null will return all rows for the given
 * URL.
 * @param selectionArgs You may include ?s in selection, which
 * will be replaced by the values from selectionArgs, in order
 * that they appear in the selection.  The values will be bound
 * as Strings.
 * @param groupBy A filter declaring how to group rows, formatted
 * as an SQL GROUP BY clause (excluding the GROUP BY itself).
 * Passing null will cause the rows to not be grouped.
 * @param having A filter declare which row groups to include in
 * the cursor, if row grouping is being used, formatted as an
 * SQL HAVING clause (excluding the HAVING itself).  Passing
 * null will cause all row groups to be included, and is
 * required when row grouping is not being used.
 * @param sortOrder How to order the rows, formatted as an SQL
 * ORDER BY clause (excluding the ORDER BY itself). Passing null
 * will use the default sort order, which may be unordered.
 * @param limit Limits the number of rows returned by the query,
 * formatted as LIMIT clause. Passing null denotes no LIMIT clause.
 * @return the resulting SQL SELECT statement
 */
","/**
 * Construct a SELECT statement suitable for use in a group of
 * SELECT statements that will be joined through UNION operators
 * in buildUnionQuery.
 *
 * @param projectionIn A list of which columns to return. Passing
 * null will return all columns, which is discouraged to
 * prevent reading data from storage that isn't going to be
 * used.
 * @param selection A filter declaring which rows to return,
 * formatted as an SQL WHERE clause (excluding the WHERE
 * itself).  Passing null will return all rows for the given
 * URL.
 * @param selectionArgs You may include ?s in selection, which
 * will be replaced by the values from selectionArgs, in order
 * that they appear in the selection.  The values will be bound
 * as Strings.
 * @param groupBy A filter declaring how to group rows, formatted
 * as an SQL GROUP BY clause (excluding the GROUP BY itself).
 * Passing null will cause the rows to not be grouped.
 * @param having A filter declare which row groups to include in
 * the cursor, if row grouping is being used, formatted as an
 * SQL HAVING clause (excluding the HAVING itself).  Passing
 * null will cause all row groups to be included, and is
 * required when row grouping is not being used.
 * @param sortOrder How to order the rows, formatted as an SQL
 * ORDER BY clause (excluding the ORDER BY itself). Passing null
 * will use the default sort order, which may be unordered.
 * @param limit Limits the number of rows returned by the query,
 * formatted as LIMIT clause. Passing null denotes no LIMIT clause.
 * @return the resulting SQL SELECT statement
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",0,"There's a modification in the condition check of `mWhereClause.length() > 0` where an additional null check is added in the late version. This lies in the category of Control dependency change. Also, a new boolean variable `hasBaseWhereClause` is introduced in the late version which falls under the category of Other statement changed. Therefore, the change type is 3,4.","The change does not create a Compatibility Issue because the outcomes are the same. Regardless of the versions, it checks 'mWhereClause.length() > 0', and if it is true, the same procedure continues. The extra null check in the late version just strengthens the code without affecting the returned value from the function, so the CI type is 0."
160,"<android.database.sqlite.SQLiteDatabase: int update(String,ContentValues,String,String[])>",7,8,"<android.database.sqlite.SQLiteDatabase: int update(String,ContentValues,String,String[])>","<android.database.sqlite.SQLiteDatabase: int update(String,ContentValues,String,String[])>",0,"{
    return updateWithOnConflict(table, values, whereClause, whereArgs, null);
}","{
    return updateWithOnConflict(table, values, whereClause, whereArgs, CONFLICT_NONE);
}",1,"/**
 * Convenience method for updating rows in the database.
 *
 * @param table the table to update in
 * @param values a map from column names to new column values. null is a
 * valid value that will be translated to NULL.
 * @param whereClause the optional WHERE clause to apply when updating.
 * Passing null will update all rows.
 * @return the number of rows affected
 */
","/**
 * Convenience method for updating rows in the database.
 *
 * @param table the table to update in
 * @param values a map from column names to new column values. null is a
 * valid value that will be translated to NULL.
 * @param whereClause the optional WHERE clause to apply when updating.
 * Passing null will update all rows.
 * @return the number of rows affected
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The return statement has changed the function call parameter from ""null"" to ""CONFLICT_NONE"", so the code change types are 1,5.","Since the function call in the return statement has been modified, this could potentially result in the function returning a different result - different value or type (Type: 1)."
161,"<android.app.ActivityThread.PackageInfo: void removeContextRegistrations(Context,String,String)>",7,8,"<android.app.ActivityThread.PackageInfo: void removeContextRegistrations(Context,String,String)>","<android.app.ActivityThread.PackageInfo: void removeContextRegistrations(Context,String,String)>",0,"{
    HashMap<BroadcastReceiver, ReceiverDispatcher> rmap = mReceivers.remove(context);
    if (rmap != null) {
        Iterator<ReceiverDispatcher> it = rmap.values().iterator();
        while (it.hasNext()) {
            ReceiverDispatcher rd = it.next();
            IntentReceiverLeaked leak = new IntentReceiverLeaked(what + "" "" + who + "" has leaked IntentReceiver "" + rd.getIntentReceiver() + "" that was "" + ""originally registered here. Are you missing a "" + ""call to unregisterReceiver()?"");
            leak.setStackTrace(rd.getLocation().getStackTrace());
            Log.e(TAG, leak.getMessage(), leak);
            try {
                ActivityManagerNative.getDefault().unregisterReceiver(rd.getIIntentReceiver());
            } catch (RemoteException e) {
            // system crashed, nothing we can do
            }
        }
    }
    mUnregisteredReceivers.remove(context);
    // Log.i(TAG, ""Receiver registrations: "" + mReceivers);
    HashMap<ServiceConnection, ServiceDispatcher> smap = mServices.remove(context);
    if (smap != null) {
        Iterator<ServiceDispatcher> it = smap.values().iterator();
        while (it.hasNext()) {
            ServiceDispatcher sd = it.next();
            ServiceConnectionLeaked leak = new ServiceConnectionLeaked(what + "" "" + who + "" has leaked ServiceConnection "" + sd.getServiceConnection() + "" that was originally bound here"");
            leak.setStackTrace(sd.getLocation().getStackTrace());
            Log.e(TAG, leak.getMessage(), leak);
            try {
                ActivityManagerNative.getDefault().unbindService(sd.getIServiceConnection());
            } catch (RemoteException e) {
            // system crashed, nothing we can do
            }
            sd.doForget();
        }
    }
    mUnboundServices.remove(context);
// Log.i(TAG, ""Service registrations: "" + mServices);
}","{
    HashMap<BroadcastReceiver, ReceiverDispatcher> rmap = mReceivers.remove(context);
    if (rmap != null) {
        Iterator<ReceiverDispatcher> it = rmap.values().iterator();
        while (it.hasNext()) {
            ReceiverDispatcher rd = it.next();
            IntentReceiverLeaked leak = new IntentReceiverLeaked(what + "" "" + who + "" has leaked IntentReceiver "" + rd.getIntentReceiver() + "" that was "" + ""originally registered here. Are you missing a "" + ""call to unregisterReceiver()?"");
            leak.setStackTrace(rd.getLocation().getStackTrace());
            Slog.e(TAG, leak.getMessage(), leak);
            try {
                ActivityManagerNative.getDefault().unregisterReceiver(rd.getIIntentReceiver());
            } catch (RemoteException e) {
            // system crashed, nothing we can do
            }
        }
    }
    mUnregisteredReceivers.remove(context);
    // Slog.i(TAG, ""Receiver registrations: "" + mReceivers);
    HashMap<ServiceConnection, ServiceDispatcher> smap = mServices.remove(context);
    if (smap != null) {
        Iterator<ServiceDispatcher> it = smap.values().iterator();
        while (it.hasNext()) {
            ServiceDispatcher sd = it.next();
            ServiceConnectionLeaked leak = new ServiceConnectionLeaked(what + "" "" + who + "" has leaked ServiceConnection "" + sd.getServiceConnection() + "" that was originally bound here"");
            leak.setStackTrace(sd.getLocation().getStackTrace());
            Slog.e(TAG, leak.getMessage(), leak);
            try {
                ActivityManagerNative.getDefault().unbindService(sd.getIServiceConnection());
            } catch (RemoteException e) {
            // system crashed, nothing we can do
            }
            sd.doForget();
        }
    }
    mUnboundServices.remove(context);
// Slog.i(TAG, ""Service registrations: "" + mServices);
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,4,0,The Log.e() calls were replaced with Slog.e() calls in the new API version. This is a logging change so the change category is 4 (Other statement changed).,"This change doesn't modify the behaviour of the API, it only affects how the output log is recorded. Therefore, this falls under the category 0 (No compatibility issues exist)."
163,<android.webkit.CallbackProxy: void onPageFinished(String)>,7,8,<android.webkit.CallbackProxy: void onPageFinished(String)>,<android.webkit.CallbackProxy: void onPageFinished(String)>,0,"{
    // been set.
    if (mWebViewClient == null) {
        return;
    }
    // Performance probe
    if (PERF_PROBE) {
        // un-comment this if PERF_PROBE is true
        // Looper.myQueue().setWaitCallback(null);
        Log.d(""WebCore"", ""WebCore thread used "" + (SystemClock.currentThreadTimeMillis() - mWebCoreThreadTime) + "" ms and idled "" + mWebCoreIdleTime + "" ms"");
        Network.getInstance(mContext).stopTiming();
    }
    Message msg = obtainMessage(PAGE_FINISHED, url);
    sendMessage(msg);
}","{
    // Performance probe
    if (PERF_PROBE) {
        // un-comment this if PERF_PROBE is true
        // Looper.myQueue().setWaitCallback(null);
        Log.d(""WebCore"", ""WebCore thread used "" + (SystemClock.currentThreadTimeMillis() - mWebCoreThreadTime) + "" ms and idled "" + mWebCoreIdleTime + "" ms"");
        Network.getInstance(mContext).stopTiming();
    }
    Message msg = obtainMessage(PAGE_FINISHED, url);
    sendMessage(msg);
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,3,0,"The changes that have occurred in the code revolve around the removal of a conditional statement 'if()...' that used to check whether 'mWebViewClient' is null. Hence, the code change type is 3, which corresponds to Control dependency change.","Even though there has been a change in the code, this change doesn't give rise to any Compatibility Issues. That's because the removed code segment wasn't significant in affecting the behavior of the API. The main operations in the function remain unaffected. Therefore, no Compatibility Issue exists. The CI type is 0."
164,<android.app.SearchManager: void onDismiss(DialogInterface)>,7,8,<android.app.SearchManager: void onDismiss(DialogInterface)>,<android.app.SearchManager: void onDismiss(DialogInterface)>,0,"{
    throw new UnsupportedOperationException();
}","{
    if (mDismissListener != null) {
        mDismissListener.onDismiss();
    }
}",1,"/**
 * @deprecated This method is an obsolete internal implementation detail. Do not use.
 */
","/**
 * @deprecated This method is an obsolete internal implementation detail. Do not use.
 */
",-1,[@Deprecated],[@Deprecated],-1,-1,-1,-1,-1,-1,"2,3","1,2","The early version has an exception throwing statement. However, the late version has replaced it with an if condition and a method call. Therefore, the change types are: 2) Exception handling statement changed, and 3) Control dependency changed.","It's predictable that the behaviour of the method will be changed significantly because of the removal of exception throwing and the introduction of conditional method call. So the CI types are: 1) Compatibility Issue caused by potential different return values or types, and 2) Compatibility Issue caused by potential different exception handlings."
165,<android.widget.AutoCompleteTextView: void onFilterComplete(int)>,7,8,<android.widget.AutoCompleteTextView: void onFilterComplete(int)>,<android.widget.AutoCompleteTextView: void onFilterComplete(int)>,0,"{
    // Not attached to window, don't update drop-down
    if (getWindowVisibility() == View.GONE)
        return;
    if ((count > 0 || mDropDownAlwaysVisible) && enoughToFilter()) {
        if (hasFocus() && hasWindowFocus()) {
            showDropDown();
        }
    } else if (!mDropDownAlwaysVisible) {
        dismissDropDown();
    }
}","{
    updateDropDownForFilter(count);
}",1,"/**
 * {@inheritDoc}
 */
","/**
 * {@inheritDoc}
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,4",1,"The entire implementation was changed from a series of conditional checks and operations to a single method call to updateDropDownForFilter(count), thus, the change type is 1 and 4.","The original implementation had several conditions which resulted in either the showing or dismissal of a drop down. However, in the late implementation, it now only calls the method updateDropDownForFilter(count). This can result in a different behavior (potentially different return results) if the new method doesn't encapsulate the same logic, making the CI type 1."
167,"<android.provider.Calendar.Instances: Cursor query(ContentResolver,String[],long,long)>",7,8,"<android.provider.Calendar.Instances: Cursor query(ContentResolver,String[],long,long)>","<android.provider.Calendar.Instances: Cursor query(ContentResolver,String[],long,long)>",0,"{
    Uri.Builder builder = CONTENT_URI.buildUpon();
    ContentUris.appendId(builder, begin);
    ContentUris.appendId(builder, end);
    return cr.query(builder.build(), projection, Calendars.SELECTED + ""=1"", null, DEFAULT_SORT_ORDER);
}","{
    Uri.Builder builder = CONTENT_URI.buildUpon();
    ContentUris.appendId(builder, begin);
    ContentUris.appendId(builder, end);
    return cr.query(builder.build(), projection, WHERE_CALENDARS_SELECTED, null, DEFAULT_SORT_ORDER);
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,4,1,"The value of the third parameter in the return statement has changed from `Calendars.SELECTED + ""=1""` to `WHERE_CALENDARS_SELECTED`, so the code change type is 4.","The change in the value of the third parameter in the return statement could potentially cause the API to return a different variable (different cursor). Thus, the Compatibility Issue type is 1."
168,<android.server.search.Searchables: SearchableInfo getSearchableInfo(ComponentName)>,7,8,<android.server.search.Searchables: SearchableInfo getSearchableInfo(ComponentName)>,<android.server.search.Searchables: SearchableInfo getSearchableInfo(ComponentName)>,0,"{
    // Step 1.  Is the result already hashed?  (case 1)
    SearchableInfo result;
    synchronized (this) {
        result = mSearchablesMap.get(activity);
        if (result != null)
            return result;
    }
    // Step 2.  See if the current activity references a searchable.
    // Note:  Conceptually, this could be a while(true) loop, but there's
    // no point in implementing reference chaining here and risking a loop.
    // References must point directly to searchable activities.
    ActivityInfo ai = null;
    try {
        ai = mContext.getPackageManager().getActivityInfo(activity, PackageManager.GET_META_DATA);
        String refActivityName = null;
        // First look for activity-specific reference
        Bundle md = ai.metaData;
        if (md != null) {
            refActivityName = md.getString(MD_LABEL_DEFAULT_SEARCHABLE);
        }
        // If not found, try for app-wide reference
        if (refActivityName == null) {
            md = ai.applicationInfo.metaData;
            if (md != null) {
                refActivityName = md.getString(MD_LABEL_DEFAULT_SEARCHABLE);
            }
        }
        // Irrespective of source, if a reference was found, follow it.
        if (refActivityName != null) {
            // ""system default search"" if search is invoked.
            if (refActivityName.equals(MD_SEARCHABLE_SYSTEM_SEARCH)) {
                return getDefaultSearchable();
            }
            String pkg = activity.getPackageName();
            ComponentName referredActivity;
            if (refActivityName.charAt(0) == '.') {
                referredActivity = new ComponentName(pkg, pkg + refActivityName);
            } else {
                referredActivity = new ComponentName(pkg, refActivityName);
            }
            // it against the original name so we can skip the check
            synchronized (this) {
                result = mSearchablesMap.get(referredActivity);
                if (result != null) {
                    mSearchablesMap.put(activity, result);
                    return result;
                }
            }
        }
    } catch (PackageManager.NameNotFoundException e) {
    // case 3: no metadata
    }
    // Step 3.  None found. Return null.
    return null;
}","{
    // Step 1.  Is the result already hashed?  (case 1)
    SearchableInfo result;
    synchronized (this) {
        result = mSearchablesMap.get(activity);
        if (result != null)
            return result;
    }
    // Step 2.  See if the current activity references a searchable.
    // Note:  Conceptually, this could be a while(true) loop, but there's
    // no point in implementing reference chaining here and risking a loop.
    // References must point directly to searchable activities.
    ActivityInfo ai = null;
    try {
        ai = mContext.getPackageManager().getActivityInfo(activity, PackageManager.GET_META_DATA);
        String refActivityName = null;
        // First look for activity-specific reference
        Bundle md = ai.metaData;
        if (md != null) {
            refActivityName = md.getString(MD_LABEL_DEFAULT_SEARCHABLE);
        }
        // If not found, try for app-wide reference
        if (refActivityName == null) {
            md = ai.applicationInfo.metaData;
            if (md != null) {
                refActivityName = md.getString(MD_LABEL_DEFAULT_SEARCHABLE);
            }
        }
        // Irrespective of source, if a reference was found, follow it.
        if (refActivityName != null) {
            // This value is deprecated, return null
            if (refActivityName.equals(MD_SEARCHABLE_SYSTEM_SEARCH)) {
                return null;
            }
            String pkg = activity.getPackageName();
            ComponentName referredActivity;
            if (refActivityName.charAt(0) == '.') {
                referredActivity = new ComponentName(pkg, pkg + refActivityName);
            } else {
                referredActivity = new ComponentName(pkg, refActivityName);
            }
            // it against the original name so we can skip the check
            synchronized (this) {
                result = mSearchablesMap.get(referredActivity);
                if (result != null) {
                    mSearchablesMap.put(activity, result);
                    return result;
                }
            }
        }
    } catch (PackageManager.NameNotFoundException e) {
    // case 3: no metadata
    }
    // Step 3.  None found. Return null.
    return null;
}",1,"/**
 * Look up, or construct, based on the activity.
 *
 * The activities fall into three cases, based on meta-data found in
 * the manifest entry:
 * <ol>
 * <li>The activity itself implements search.  This is indicated by the
 * presence of a ""android.app.searchable"" meta-data attribute.
 * The value is a reference to an XML file containing search information.</li>
 * <li>A related activity implements search.  This is indicated by the
 * presence of a ""android.app.default_searchable"" meta-data attribute.
 * The value is a string naming the activity implementing search.  In this
 * case the factory will ""redirect"" and return the searchable data.</li>
 * <li>No searchability data is provided.  We return null here and other
 * code will insert the ""default"" (e.g. contacts) search.
 *
 * TODO: cache the result in the map, and check the map first.
 * TODO: it might make sense to implement the searchable reference as
 * an application meta-data entry.  This way we don't have to pepper each
 * and every activity.
 * TODO: can we skip the constructor step if it's a non-searchable?
 * TODO: does it make sense to plug the default into a slot here for
 * automatic return?  Probably not, but it's one way to do it.
 *
 * @param activity The name of the current activity, or null if the
 * activity does not define any explicit searchable metadata.
 */
","/**
 * Look up, or construct, based on the activity.
 *
 * The activities fall into three cases, based on meta-data found in
 * the manifest entry:
 * <ol>
 * <li>The activity itself implements search.  This is indicated by the
 * presence of a ""android.app.searchable"" meta-data attribute.
 * The value is a reference to an XML file containing search information.</li>
 * <li>A related activity implements search.  This is indicated by the
 * presence of a ""android.app.default_searchable"" meta-data attribute.
 * The value is a string naming the activity implementing search.  In this
 * case the factory will ""redirect"" and return the searchable data.</li>
 * <li>No searchability data is provided.  We return null here and other
 * code will insert the ""default"" (e.g. contacts) search.
 *
 * TODO: cache the result in the map, and check the map first.
 * TODO: it might make sense to implement the searchable reference as
 * an application meta-data entry.  This way we don't have to pepper each
 * and every activity.
 * TODO: can we skip the constructor step if it's a non-searchable?
 * TODO: does it make sense to plug the default into a slot here for
 * automatic return?  Probably not, but it's one way to do it.
 *
 * @param activity The name of the current activity, or null if the
 * activity does not define any explicit searchable metadata.
 */
",-1,,,-1,-1,-1,-1,-1,-1,1,1,"The return statement has changed from getDefaultSearchable() to null, so the code change type is 1.","As the return statement has changed from getDefaultSearchable() to null, it may cause the API to return a different value in some situations, so the CI type is 1."
171,"<android.webkit.HttpAuthHandler: void proceed(String,String)>",7,8,"<android.webkit.HttpAuthHandler: void proceed(String,String)>","<android.webkit.HttpAuthHandler: void proceed(String,String)>",0,"{
    Message msg = obtainMessage(AUTH_PROCEED);
    msg.getData().putString(""username"", username);
    msg.getData().putString(""password"", password);
    sendMessage(msg);
}","{
    if (handleResponseForSynchronousRequest(username, password)) {
        signalRequestComplete();
        return;
    }
    Message msg = obtainMessage(AUTH_PROCEED);
    msg.getData().putString(""username"", username);
    msg.getData().putString(""password"", password);
    sendMessage(msg);
    signalRequestComplete();
}",1,"/**
 * Proceed with the authorization with the given credentials
 *
 * @param username The username to use for authentication
 * @param password The password to use for authentication
 */
","/**
 * Proceed with the authorization with the given credentials
 *
 * May be called on the UI thread, rather than the WebCore thread.
 *
 * @param username The username to use for authentication
 * @param password The password to use for authentication
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3,4",1,"In the late version, a new 'return' statement and the invocation of new methods 'handleResponseForSynchronousRequest()' and 'signalRequestComplete()' have been introduced. Hence, the code change types are 1 (return statement has been introduced), 3 (control dependency change due to new 'if' condition), and 4 (other statements have been introduced).","The introduction of a new conditional block and return statement could lead to a compatibility issue. The 'proceed' method may now terminate earlier without executing the remaining statements if the condition 'handleResponseForSynchronousRequest(username, password)' is met, hence potentially leading to a different behaviour and return value, i.e., type 1 CI."
172,"<android.accounts.AccountManager: void setUserData(Account,String,String)>",7,8,"<android.accounts.AccountManager: void setUserData(Account,String,String)>","<android.accounts.AccountManager: void setUserData(Account,String,String)>",0,"{
    if (account == null) {
        Log.e(TAG, ""the account must not be null"");
        return;
    }
    if (key == null) {
        Log.e(TAG, ""the key must not be null"");
        return;
    }
    try {
        mService.setUserData(account, key, value);
    } catch (RemoteException e) {
        // won't ever happen
        throw new RuntimeException(e);
    }
}","{
    if (account == null)
        throw new IllegalArgumentException(""account is null"");
    if (key == null)
        throw new IllegalArgumentException(""key is null"");
    try {
        mService.setUserData(account, key, value);
    } catch (RemoteException e) {
        // won't ever happen
        throw new RuntimeException(e);
    }
}",1,"/**
 * Sets account's userdata named ""key"" to the specified value. If the account does not
 * exist then this call has no effect.
 * <p>
 * Requires that the caller has permission
 * {@link android.Manifest.permission#AUTHENTICATE_ACCOUNTS} and is running
 * with the same UID as the Authenticator for the account.
 * @param account the account whose userdata is to be set. Must not be null.
 * @param key the key of the userdata to set. Must not be null.
 * @param value the value to set. May be null.
 */
","/**
 * Sets one userdata key for an account.  Intended by use for the
 * authenticator to stash state for itself, not directly by applications.
 * The meaning of the keys and values is up to the authenticator.
 *
 * <p>It is safe to call this method from the main thread.
 *
 * <p>This method requires the caller to hold the permission
 * {@link android.Manifest.permission#AUTHENTICATE_ACCOUNTS}
 * and to have the same UID as the account's authenticator.
 *
 * @param account The account to set the userdata for
 * @param key The userdata key to set.  Must not be null
 * @param value The value to set, null to clear this userdata key
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,3",2,"The handling of 'account == null' and 'key == null' conditions has changed from 'return' to throwing an IllegalArgumentException, and an additional exception handling statement has been introduced so the code change type is 2,3. ","In the early version, when the account or key is null, the function will just return. But in the late version, the function will throw an IllegalArgumentException, this could lead to different behaviours. So the CI type is 2."
174,"<android.widget.QuickContactBadge.QueryHandler: void onQueryComplete(int,Object,Cursor)>",7,8,"<android.widget.QuickContactBadge.QueryHandler: void onQueryComplete(int,Object,Cursor)>","<android.widget.QuickContactBadge.QueryHandler: void onQueryComplete(int,Object,Cursor)>",0,"{
    Uri lookupUri = null;
    Uri createUri = null;
    boolean trigger = false;
    try {
        switch(token) {
            case TOKEN_PHONE_LOOKUP_AND_TRIGGER:
                trigger = true;
                createUri = Uri.fromParts(""tel"", (String) cookie, null);
            case TOKEN_PHONE_LOOKUP:
                {
                    if (cursor != null && cursor.moveToFirst()) {
                        long contactId = cursor.getLong(PHONE_ID_COLUMN_INDEX);
                        String lookupKey = cursor.getString(PHONE_LOOKUP_STRING_COLUMN_INDEX);
                        lookupUri = Contacts.getLookupUri(contactId, lookupKey);
                    }
                    break;
                }
            case TOKEN_EMAIL_LOOKUP_AND_TRIGGER:
                trigger = true;
                createUri = Uri.fromParts(""mailto"", (String) cookie, null);
            case TOKEN_EMAIL_LOOKUP:
                {
                    if (cursor != null && cursor.moveToFirst()) {
                        long contactId = cursor.getLong(EMAIL_ID_COLUMN_INDEX);
                        String lookupKey = cursor.getString(EMAIL_LOOKUP_STRING_COLUMN_INDEX);
                        lookupUri = Contacts.getLookupUri(contactId, lookupKey);
                    }
                }
        }
    } finally {
        if (cursor != null) {
            cursor.close();
        }
    }
    mContactUri = lookupUri;
    onContactUriChanged();
    if (trigger && lookupUri != null) {
        // Found contact, so trigger track
        trigger(lookupUri);
    } else if (createUri != null) {
        // Prompt user to add this person to contacts
        final Intent intent = new Intent(Intents.SHOW_OR_CREATE_CONTACT, createUri);
        getContext().startActivity(intent);
    }
}","{
    Uri lookupUri = null;
    Uri createUri = null;
    boolean trigger = false;
    try {
        switch(token) {
            case TOKEN_PHONE_LOOKUP_AND_TRIGGER:
                trigger = true;
                createUri = Uri.fromParts(""tel"", (String) cookie, null);
            case TOKEN_PHONE_LOOKUP:
                {
                    if (cursor != null && cursor.moveToFirst()) {
                        long contactId = cursor.getLong(PHONE_ID_COLUMN_INDEX);
                        String lookupKey = cursor.getString(PHONE_LOOKUP_STRING_COLUMN_INDEX);
                        lookupUri = Contacts.getLookupUri(contactId, lookupKey);
                    }
                    break;
                }
            case TOKEN_EMAIL_LOOKUP_AND_TRIGGER:
                trigger = true;
                createUri = Uri.fromParts(""mailto"", (String) cookie, null);
            case TOKEN_EMAIL_LOOKUP:
                {
                    if (cursor != null && cursor.moveToFirst()) {
                        long contactId = cursor.getLong(EMAIL_ID_COLUMN_INDEX);
                        String lookupKey = cursor.getString(EMAIL_LOOKUP_STRING_COLUMN_INDEX);
                        lookupUri = Contacts.getLookupUri(contactId, lookupKey);
                    }
                }
            case TOKEN_CONTACT_LOOKUP_AND_TRIGGER:
                {
                    if (cursor != null && cursor.moveToFirst()) {
                        long contactId = cursor.getLong(CONTACT_ID_COLUMN_INDEX);
                        String lookupKey = cursor.getString(CONTACT_LOOKUPKEY_COLUMN_INDEX);
                        lookupUri = Contacts.getLookupUri(contactId, lookupKey);
                        trigger = true;
                    }
                    break;
                }
        }
    } finally {
        if (cursor != null) {
            cursor.close();
        }
    }
    mContactUri = lookupUri;
    onContactUriChanged();
    if (trigger && lookupUri != null) {
        // Found contact, so trigger track
        trigger(lookupUri);
    } else if (createUri != null) {
        // Prompt user to add this person to contacts
        final Intent intent = new Intent(Intents.SHOW_OR_CREATE_CONTACT, createUri);
        getContext().startActivity(intent);
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,4",1,"A new case block (case TOKEN_CONTACT_LOOKUP_AND_TRIGGER) has been added to the switch statement, and a new assignment statement for the variable 'trigger' has also been added in the new case block, so the change type is 3,4.","As the new case block triggers a change to 'lookupUri' and the boolean 'trigger', it may alter the outputs of the API, specifically in the line 'trigger(lookupUri);', making it potentially return different values, so the CI type is 1."
175,"<android.webkit.WebViewDatabase: String[] getHttpAuthUsernamePassword(String,String)>",7,8,"<android.webkit.WebViewDatabase: String[] getHttpAuthUsernamePassword(String,String)>","<android.webkit.WebViewDatabase: String[] getHttpAuthUsernamePassword(String,String)>",0,"{
    if (host == null || realm == null || mDatabase == null) {
        return null;
    }
    final String[] columns = new String[] { HTTPAUTH_USERNAME_COL, HTTPAUTH_PASSWORD_COL };
    final String selection = ""("" + HTTPAUTH_HOST_COL + "" == ?) AND ("" + HTTPAUTH_REALM_COL + "" == ?)"";
    synchronized (mHttpAuthLock) {
        String[] ret = null;
        Cursor cursor = mDatabase.query(mTableNames[TABLE_HTTPAUTH_ID], columns, selection, new String[] { host, realm }, null, null, null);
        if (cursor.moveToFirst()) {
            ret = new String[2];
            ret[0] = cursor.getString(cursor.getColumnIndex(HTTPAUTH_USERNAME_COL));
            ret[1] = cursor.getString(cursor.getColumnIndex(HTTPAUTH_PASSWORD_COL));
        }
        cursor.close();
        return ret;
    }
}","{
    if (host == null || realm == null || mDatabase == null) {
        return null;
    }
    final String[] columns = new String[] { HTTPAUTH_USERNAME_COL, HTTPAUTH_PASSWORD_COL };
    final String selection = ""("" + HTTPAUTH_HOST_COL + "" == ?) AND ("" + HTTPAUTH_REALM_COL + "" == ?)"";
    synchronized (mHttpAuthLock) {
        String[] ret = null;
        Cursor cursor = null;
        try {
            cursor = mDatabase.query(mTableNames[TABLE_HTTPAUTH_ID], columns, selection, new String[] { host, realm }, null, null, null);
            if (cursor.moveToFirst()) {
                ret = new String[2];
                ret[0] = cursor.getString(cursor.getColumnIndex(HTTPAUTH_USERNAME_COL));
                ret[1] = cursor.getString(cursor.getColumnIndex(HTTPAUTH_PASSWORD_COL));
            }
        } catch (IllegalStateException e) {
            Log.e(LOGTAG, ""getHttpAuthUsernamePassword"", e);
        } finally {
            if (cursor != null)
                cursor.close();
        }
        return ret;
    }
}",1,"/**
 * Retrieve the HTTP authentication username and password for a given
 * host+realm pair
 *
 * @param host The host the password applies to
 * @param realm The realm the password applies to
 * @return String[] if found, String[0] is username, which can be null and
 * String[1] is password. Return null if it can't find anything.
 */
","/**
 * Retrieve the HTTP authentication username and password for a given
 * host+realm pair
 *
 * @param host The host the password applies to
 * @param realm The realm the password applies to
 * @return String[] if found, String[0] is username, which can be null and
 * String[1] is password. Return null if it can't find anything.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,3,4",0,"The code change includes introduction of a new exception handling (2), addition of a 'try' and a 'finally' block in the control structure (3), and the addition of a null check condition for 'cursor' before closing it (4).","The changed code does not affect the returned value or the exception handling of the API due to the additional exception being caught and logged, and the return variables not being manipulated inside the try-catch block. This means that no Compatibility Issue is introduced."
176,<android.widget.ExpandableListView: long getSelectedPosition()>,7,8,<android.widget.ExpandableListView: long getSelectedPosition()>,<android.widget.ExpandableListView: long getSelectedPosition()>,0,"{
    final int selectedPos = getSelectedItemPosition();
    if (selectedPos == -1)
        return PACKED_POSITION_VALUE_NULL;
    return getExpandableListPosition(selectedPos);
}","{
    final int selectedPos = getSelectedItemPosition();
    // The case where there is no selection (selectedPos == -1) is also handled here.
    return getExpandableListPosition(selectedPos);
}",1,"/**
 * Gets the position of the currently selected group or child (along with
 * its type). Can return {@link #PACKED_POSITION_VALUE_NULL} if no selection.
 *
 * @return A packed position containing the currently selected group or
 * child's position and type. #PACKED_POSITION_VALUE_NULL if no selection.
 */
","/**
 * Gets the position of the currently selected group or child (along with
 * its type). Can return {@link #PACKED_POSITION_VALUE_NULL} if no selection.
 *
 * @return A packed position containing the currently selected group or
 * child's position and type. #PACKED_POSITION_VALUE_NULL if no selection
 * or if selection is on a header or a footer item.
 */
",-1,,,-1,-1,-1,-1,-1,-1,3,1,"The handling of the case where 'selectedPos == -1' has been moved from an 'if' statement to be covered under the call to 'getExpandableListPosition(selectedPos)', so the change type is 3.","The alteration in the control flow of the program can change the return value when 'selectedPos == -1'. In the earlier version, it returned PACKED_POSITION_VALUE_NULL but in the later version, it returns the result of 'getExpandableListPosition(selectedPos)'. Hence, the CI type is 1."
178,<android.preference.PreferenceActivity: void onRestoreInstanceState(Bundle)>,7,8,<android.preference.PreferenceActivity: void onRestoreInstanceState(Bundle)>,<android.preference.PreferenceActivity: void onRestoreInstanceState(Bundle)>,0,"{
    super.onRestoreInstanceState(state);
    Bundle container = state.getBundle(PREFERENCES_TAG);
    if (container != null) {
        final PreferenceScreen preferenceScreen = getPreferenceScreen();
        if (preferenceScreen != null) {
            preferenceScreen.restoreHierarchyState(container);
        }
    }
}","{
    Bundle container = state.getBundle(PREFERENCES_TAG);
    if (container != null) {
        final PreferenceScreen preferenceScreen = getPreferenceScreen();
        if (preferenceScreen != null) {
            preferenceScreen.restoreHierarchyState(container);
            mSavedInstanceState = state;
            return;
        }
    }
    // Only call this if we didn't save the instance state for later.
    // If we did save it, it will be restored when we bind the adapter.
    super.onRestoreInstanceState(state);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,3",1,"The code change includes adding a return statement (return;) and changing the order of the calling of the super method from the beginning of the function to the end in the Late Implementation, so the change type is 1,3.","Considering the new return statement added and the changing order of method invocations, the behavior of this method could potentially change, which means the API could potentially return differently. Hence, the CI type is 1."
179,<android.widget.HeaderViewListAdapter: boolean isEnabled(int)>,7,8,<android.widget.HeaderViewListAdapter: boolean isEnabled(int)>,<android.widget.HeaderViewListAdapter: boolean isEnabled(int)>,0,"{
    int numHeaders = getHeadersCount();
    if (mAdapter != null && position >= numHeaders) {
        int adjPosition = position - numHeaders;
        int adapterCount = mAdapter.getCount();
        if (adjPosition >= adapterCount && mFooterViewInfos != null) {
            return mFooterViewInfos.get(adjPosition - adapterCount).isSelectable;
        } else {
            return mAdapter.isEnabled(adjPosition);
        }
    } else if (position < numHeaders && mHeaderViewInfos != null) {
        return mHeaderViewInfos.get(position).isSelectable;
    }
    return true;
}","{
    // Header (negative positions will throw an ArrayIndexOutOfBoundsException)
    int numHeaders = getHeadersCount();
    if (position < numHeaders) {
        return mHeaderViewInfos.get(position).isSelectable;
    }
    // Adapter
    final int adjPosition = position - numHeaders;
    int adapterCount = 0;
    if (mAdapter != null) {
        adapterCount = mAdapter.getCount();
        if (adjPosition < adapterCount) {
            return mAdapter.isEnabled(adjPosition);
        }
    }
    // Footer (off-limits positions will throw an ArrayIndexOutOfBoundsException)
    return mFooterViewInfos.get(adjPosition - adapterCount).isSelectable;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"1,3",1,"Both the control dependency and return statements have been restructured and changed in the late version. Therefore, the code change type is 1,3.","Since the control dependency and return statements have changed, it might cause this method to return a different value, thus causing a compatibility issue. Therefore, the CI type is 1."
180,<android.pim.vcard.VCardConfig: boolean usesShiftJis(int)>,7,8,<android.pim.vcard.VCardConfig: boolean usesShiftJis(int)>,<android.pim.vcard.VCardConfig: boolean usesShiftJis(int)>,0,"{
    return ((vcardType & FLAG_CHARSET_SHIFT_JIS) != 0);
}","{
    return ((vcardType & FLAG_CHARSET_MASK) == FLAG_CHARSET_SHIFT_JIS);
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,1,1,"The return statement has changed from checking whether the supplied vcardType includes the FLAG_CHARSET_SHIFT_JIS to specifically checking whether the character set portion of the vcardType equals the FLAG_CHARSET_SHIFT_JIS. Thus, the change type is 1.","The change in the return statement can potentially lead to the API returning a different boolean value and hence, the CI type is 1."
182,"<android.widget.AbsListView: boolean onKeyUp(int,KeyEvent)>",7,8,"<android.widget.AbsListView: boolean onKeyUp(int,KeyEvent)>","<android.widget.AbsListView: boolean onKeyUp(int,KeyEvent)>",0,"{
    switch(keyCode) {
        case KeyEvent.KEYCODE_DPAD_CENTER:
        case KeyEvent.KEYCODE_ENTER:
            if (!isEnabled()) {
                return true;
            }
            if (isClickable() && isPressed() && mSelectedPosition >= 0 && mAdapter != null && mSelectedPosition < mAdapter.getCount()) {
                final View view = getChildAt(mSelectedPosition - mFirstPosition);
                performItemClick(view, mSelectedPosition, mSelectedRowId);
                setPressed(false);
                if (view != null)
                    view.setPressed(false);
                return true;
            }
            break;
    }
    return super.onKeyUp(keyCode, event);
}","{
    switch(keyCode) {
        case KeyEvent.KEYCODE_DPAD_CENTER:
        case KeyEvent.KEYCODE_ENTER:
            if (!isEnabled()) {
                return true;
            }
            if (isClickable() && isPressed() && mSelectedPosition >= 0 && mAdapter != null && mSelectedPosition < mAdapter.getCount()) {
                final View view = getChildAt(mSelectedPosition - mFirstPosition);
                if (view != null) {
                    performItemClick(view, mSelectedPosition, mSelectedRowId);
                    view.setPressed(false);
                }
                setPressed(false);
                return true;
            }
            break;
    }
    return super.onKeyUp(keyCode, event);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"The adjustment made in the code is refactoring the position of the 'if' condition statement, it's merely a code optimization without changing the logic flow, hence the change type is 4.","Although the order of certain statements is altered, the semantics of the code remains the same. Therefore, no Compatibility Issue exists, the CI type is 0."
185,<android.widget.AbsListView: boolean onInterceptTouchEvent(MotionEvent)>,7,8,<android.widget.AbsListView: boolean onInterceptTouchEvent(MotionEvent)>,<android.widget.AbsListView: boolean onInterceptTouchEvent(MotionEvent)>,0,"{
    int action = ev.getAction();
    int x = (int) ev.getX();
    int y = (int) ev.getY();
    View v;
    if (mFastScroller != null) {
        boolean intercepted = mFastScroller.onInterceptTouchEvent(ev);
        if (intercepted) {
            return true;
        }
    }
    switch(action) {
        case MotionEvent.ACTION_DOWN:
            {
                int motionPosition = findMotionRow(y);
                if (mTouchMode != TOUCH_MODE_FLING && motionPosition >= 0) {
                    // User clicked on an actual view (and was not stopping a fling).
                    // Remember where the motion event started
                    v = getChildAt(motionPosition - mFirstPosition);
                    mMotionViewOriginalTop = v.getTop();
                    mMotionX = x;
                    mMotionY = y;
                    mMotionPosition = motionPosition;
                    mTouchMode = TOUCH_MODE_DOWN;
                    clearScrollingCache();
                }
                mLastY = Integer.MIN_VALUE;
                if (mTouchMode == TOUCH_MODE_FLING) {
                    return true;
                }
                break;
            }
        case MotionEvent.ACTION_MOVE:
            {
                switch(mTouchMode) {
                    case TOUCH_MODE_DOWN:
                        if (startScrollIfNeeded(y - mMotionY)) {
                            return true;
                        }
                        break;
                }
                break;
            }
        case MotionEvent.ACTION_UP:
            {
                mTouchMode = TOUCH_MODE_REST;
                reportScrollStateChange(OnScrollListener.SCROLL_STATE_IDLE);
                break;
            }
    }
    return false;
}","{
    int action = ev.getAction();
    View v;
    if (mFastScroller != null) {
        boolean intercepted = mFastScroller.onInterceptTouchEvent(ev);
        if (intercepted) {
            return true;
        }
    }
    switch(action & MotionEvent.ACTION_MASK) {
        case MotionEvent.ACTION_DOWN:
            {
                int touchMode = mTouchMode;
                final int x = (int) ev.getX();
                final int y = (int) ev.getY();
                mActivePointerId = ev.getPointerId(0);
                int motionPosition = findMotionRow(y);
                if (touchMode != TOUCH_MODE_FLING && motionPosition >= 0) {
                    // User clicked on an actual view (and was not stopping a fling).
                    // Remember where the motion event started
                    v = getChildAt(motionPosition - mFirstPosition);
                    mMotionViewOriginalTop = v.getTop();
                    mMotionX = x;
                    mMotionY = y;
                    mMotionPosition = motionPosition;
                    mTouchMode = TOUCH_MODE_DOWN;
                    clearScrollingCache();
                }
                mLastY = Integer.MIN_VALUE;
                if (touchMode == TOUCH_MODE_FLING) {
                    return true;
                }
                break;
            }
        case MotionEvent.ACTION_MOVE:
            {
                switch(mTouchMode) {
                    case TOUCH_MODE_DOWN:
                        final int pointerIndex = ev.findPointerIndex(mActivePointerId);
                        final int y = (int) ev.getY(pointerIndex);
                        if (startScrollIfNeeded(y - mMotionY)) {
                            return true;
                        }
                        break;
                }
                break;
            }
        case MotionEvent.ACTION_UP:
            {
                mTouchMode = TOUCH_MODE_REST;
                mActivePointerId = INVALID_POINTER;
                reportScrollStateChange(OnScrollListener.SCROLL_STATE_IDLE);
                break;
            }
        case MotionEvent.ACTION_POINTER_UP:
            {
                onSecondaryPointerUp(ev);
                break;
            }
    }
    return false;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3, 4",0,"There are multiple changes between the Early Implementation and the Late Implementation, including changes in condition sentences and the introduction of new method call. ",
186,"<android.os.ParcelFileDescriptor: ParcelFileDescriptor open(File,int)>",7,8,"<android.os.ParcelFileDescriptor: ParcelFileDescriptor open(File,int)>","<android.os.ParcelFileDescriptor: ParcelFileDescriptor open(File,int)>",0,"{
    String path = file.getPath();
    SecurityManager security = System.getSecurityManager();
    if (security != null) {
        security.checkRead(path);
        if ((mode & MODE_WRITE_ONLY) != 0) {
            security.checkWrite(path);
        }
    }
    if ((mode & MODE_READ_WRITE) == 0) {
        throw new IllegalArgumentException(""Must specify MODE_READ_ONLY, MODE_WRITE_ONLY, or MODE_READ_WRITE"");
    }
    FileDescriptor fd = Parcel.openFileDescriptor(path, mode);
    return new ParcelFileDescriptor(fd);
}","{
    String path = file.getPath();
    SecurityManager security = System.getSecurityManager();
    if (security != null) {
        security.checkRead(path);
        if ((mode & MODE_WRITE_ONLY) != 0) {
            security.checkWrite(path);
        }
    }
    if ((mode & MODE_READ_WRITE) == 0) {
        throw new IllegalArgumentException(""Must specify MODE_READ_ONLY, MODE_WRITE_ONLY, or MODE_READ_WRITE"");
    }
    FileDescriptor fd = Parcel.openFileDescriptor(path, mode);
    return fd != null ? new ParcelFileDescriptor(fd) : null;
}",1,"/**
 * Create a new ParcelFileDescriptor accessing a given file.
 *
 * @param file The file to be opened.
 * @param mode The desired access mode, must be one of
 * {@link #MODE_READ_ONLY}, {@link #MODE_WRITE_ONLY}, or
 * {@link #MODE_READ_WRITE}; may also be any combination of
 * {@link #MODE_CREATE}, {@link #MODE_TRUNCATE},
 * {@link #MODE_WORLD_READABLE}, and {@link #MODE_WORLD_WRITEABLE}.
 *
 * @return Returns a new ParcelFileDescriptor pointing to the given
 * file.
 *
 * @throws FileNotFoundException Throws FileNotFoundException if the given
 * file does not exist or can not be opened with the requested mode.
 */
","/**
 * Create a new ParcelFileDescriptor accessing a given file.
 *
 * @param file The file to be opened.
 * @param mode The desired access mode, must be one of
 * {@link #MODE_READ_ONLY}, {@link #MODE_WRITE_ONLY}, or
 * {@link #MODE_READ_WRITE}; may also be any combination of
 * {@link #MODE_CREATE}, {@link #MODE_TRUNCATE},
 * {@link #MODE_WORLD_READABLE}, and {@link #MODE_WORLD_WRITEABLE}.
 *
 * @return Returns a new ParcelFileDescriptor pointing to the given
 * file.
 *
 * @throws FileNotFoundException Throws FileNotFoundException if the given
 * file does not exist or can not be opened with the requested mode.
 */
",-1,,,-1,-1,-1,-1,-1,-1,1,1,"The return statement has changed to now potentially return null, so the code change type is 1.","The change in the return statement indicates that the API could potentially return different values (either an instance of ParcelFileDescriptor or null) in the two versions. Therefore, the CI type is 1."
188,"<android.widget.TabWidget: void onFocusChange(View,boolean)>",7,8,"<android.widget.TabWidget: void onFocusChange(View,boolean)>","<android.widget.TabWidget: void onFocusChange(View,boolean)>",0,"{
    if (v == this && hasFocus) {
        getChildTabViewAt(mSelectedTab).requestFocus();
        return;
    }
    if (hasFocus) {
        int i = 0;
        int numTabs = getTabCount();
        while (i < numTabs) {
            if (getChildTabViewAt(i) == v) {
                setCurrentTab(i);
                mSelectionChangedListener.onTabSelectionChanged(i, false);
                break;
            }
            i++;
        }
    }
}","{
    if (v == this && hasFocus && getTabCount() > 0) {
        getChildTabViewAt(mSelectedTab).requestFocus();
        return;
    }
    if (hasFocus) {
        int i = 0;
        int numTabs = getTabCount();
        while (i < numTabs) {
            if (getChildTabViewAt(i) == v) {
                setCurrentTab(i);
                mSelectionChangedListener.onTabSelectionChanged(i, false);
                break;
            }
            i++;
        }
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,3,0,"There is an additional condition check 'getTabCount() > 0' added in the if statement in the late version, so the code change type is 3 (Control dependency changed).","Although there is a change in the control dependency, this change doesn't affect the behavior of the API hence no compatibility issue exists. The added condition simply adds an additional safeguard to prevent accessing child tab view when the count is zero, and therefore does not change the outcome of the API calls."
189,<android.accounts.AccountManagerService.GetAccountsByTypeAndFeatureSession: void checkAccount()>,7,8,<android.accounts.AccountManagerService.GetAccountsByTypeAndFeatureSession: void checkAccount()>,<android.accounts.AccountManagerService.GetAccountsByTypeAndFeatureSession: void checkAccount()>,0,"{
    if (mCurrentAccount >= mAccountsOfType.length) {
        sendResult();
        return;
    }
    try {
        mAuthenticator.hasFeatures(this, mAccountsOfType[mCurrentAccount], mFeatures);
    } catch (RemoteException e) {
        onError(AccountManager.ERROR_CODE_REMOTE_EXCEPTION, ""remote exception"");
    }
}","{
    if (mCurrentAccount >= mAccountsOfType.length) {
        sendResult();
        return;
    }
    final IAccountAuthenticator accountAuthenticator = mAuthenticator;
    if (accountAuthenticator == null) {
        // that already happened when mAuthenticator was cleared.
        if (Log.isLoggable(TAG, Log.VERBOSE)) {
            Log.v(TAG, ""checkAccount: aborting session since we are no longer"" + "" connected to the authenticator, "" + toDebugString());
        }
        return;
    }
    try {
        accountAuthenticator.hasFeatures(this, mAccountsOfType[mCurrentAccount], mFeatures);
    } catch (RemoteException e) {
        onError(AccountManager.ERROR_CODE_REMOTE_EXCEPTION, ""remote exception"");
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"1,3",1,"A new if-else control dependency has been introduced in the late implementation that was not present in the early implementation. Also, a new return statement has been introduced inside the new if-else statement. So the change type is 1,3.","The new if-else control dependency and the return statement inside change the flow of code which could lead to potentially different outcomes when invoking the API. The change can cause the API to return at a different point, thus the CI type is 1."
190,<android.webkit.WebView: boolean performLongClick()>,7,8,<android.webkit.WebView: boolean performLongClick()>,<android.webkit.WebView: boolean performLongClick()>,0,"{
    if (mNativeClass != 0 && nativeCursorIsTextInput()) {
        // Send the click so that the textfield is in focus
        // FIXME: When we start respecting changes to the native textfield's
        // selection, need to make sure that this does not change it.
        mWebViewCore.sendMessage(EventHub.CLICK, nativeCursorFramePointer(), nativeCursorNodePointer());
        rebuildWebTextView();
    }
    if (inEditingMode()) {
        return mWebTextView.performLongClick();
    } else {
        return super.performLongClick();
    }
}","{
    // view system. In that case, do nothing.
    if (getParent() == null)
        return false;
    if (mNativeClass != 0 && nativeCursorIsTextInput()) {
        // Send the click so that the textfield is in focus
        centerKeyPressOnTextField();
        rebuildWebTextView();
    }
    if (inEditingMode()) {
        return mWebTextView.performLongClick();
    } else {
        return super.performLongClick();
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,4",1,"The 'if' control condition (getParent() == null) has been introduced and there's a new return statement 'return false' inside this control statement. Also, the method 'centerKeyPressOnTextField()' is called instead of 'mWebViewCore.sendMessage()'. So, the code changes class is 3 and 4.","The introduction of new control condition (getParent() == null) and its return statement 'return false' makes the API potentially return a different value, thus the CI type is 1."
191,<android.provider.MediaStore.Audio: String keyFor(String)>,7,8,<android.provider.MediaStore.Audio: String keyFor(String)>,<android.provider.MediaStore.Audio: String keyFor(String)>,0,"{
    if (name != null) {
        boolean sortfirst = false;
        if (name.equals(android.media.MediaFile.UNKNOWN_STRING)) {
            return ""\001"";
        }
        // force sorting of certain special files, like the silent ringtone.
        if (name.startsWith(""\001"")) {
            sortfirst = true;
        }
        name = name.trim().toLowerCase();
        if (name.startsWith(""the "")) {
            name = name.substring(4);
        }
        if (name.startsWith(""an "")) {
            name = name.substring(3);
        }
        if (name.startsWith(""a "")) {
            name = name.substring(2);
        }
        if (name.endsWith("", the"") || name.endsWith("",the"") || name.endsWith("", an"") || name.endsWith("",an"") || name.endsWith("", a"") || name.endsWith("",a"")) {
            name = name.substring(0, name.lastIndexOf(','));
        }
        name = name.replaceAll(""[\\[\\]\\(\\)\""'.,?!]"", """").trim();
        if (name.length() > 0) {
            // Insert a separator between the characters to avoid
            // matches on a partial character. If we ever change
            // to start-of-word-only matches, this can be removed.
            StringBuilder b = new StringBuilder();
            b.append('.');
            int nl = name.length();
            for (int i = 0; i < nl; i++) {
                b.append(name.charAt(i));
                b.append('.');
            }
            name = b.toString();
            String key = DatabaseUtils.getCollationKey(name);
            if (sortfirst) {
                key = ""\001"" + key;
            }
            return key;
        } else {
            return """";
        }
    }
    return null;
}","{
    if (name != null) {
        boolean sortfirst = false;
        if (name.equals(UNKNOWN_STRING)) {
            return ""\001"";
        }
        // force sorting of certain special files, like the silent ringtone.
        if (name.startsWith(""\001"")) {
            sortfirst = true;
        }
        name = name.trim().toLowerCase();
        if (name.startsWith(""the "")) {
            name = name.substring(4);
        }
        if (name.startsWith(""an "")) {
            name = name.substring(3);
        }
        if (name.startsWith(""a "")) {
            name = name.substring(2);
        }
        if (name.endsWith("", the"") || name.endsWith("",the"") || name.endsWith("", an"") || name.endsWith("",an"") || name.endsWith("", a"") || name.endsWith("",a"")) {
            name = name.substring(0, name.lastIndexOf(','));
        }
        name = name.replaceAll(""[\\[\\]\\(\\)\""'.,?!]"", """").trim();
        if (name.length() > 0) {
            // Insert a separator between the characters to avoid
            // matches on a partial character. If we ever change
            // to start-of-word-only matches, this can be removed.
            StringBuilder b = new StringBuilder();
            b.append('.');
            int nl = name.length();
            for (int i = 0; i < nl; i++) {
                b.append(name.charAt(i));
                b.append('.');
            }
            name = b.toString();
            String key = DatabaseUtils.getCollationKey(name);
            if (sortfirst) {
                key = ""\001"" + key;
            }
            return key;
        } else {
            return """";
        }
    }
    return null;
}",1,"/**
 * Converts a name to a ""key"" that can be used for grouping, sorting
 * and searching.
 * The rules that govern this conversion are:
 * - remove 'special' characters like ()[]'!?.,
 * - remove leading/trailing spaces
 * - convert everything to lowercase
 * - remove leading ""the "", ""an "" and ""a ""
 * - remove trailing "", the|an|a""
 * - remove accents. This step leaves us with CollationKey data,
 * which is not human readable
 *
 * @param name The artist or album name to convert
 * @return The ""key"" for the given name.
 */
","/**
 * Converts a name to a ""key"" that can be used for grouping, sorting
 * and searching.
 * The rules that govern this conversion are:
 * - remove 'special' characters like ()[]'!?.,
 * - remove leading/trailing spaces
 * - convert everything to lowercase
 * - remove leading ""the "", ""an "" and ""a ""
 * - remove trailing "", the|an|a""
 * - remove accents. This step leaves us with CollationKey data,
 * which is not human readable
 *
 * @param name The artist or album name to convert
 * @return The ""key"" for the given name.
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The literal constant in comparison 'name.equals()' has been replaced by a static constant 'UNKNOWN_STRING'. This change doesn't affect the functionality of the code, so the final code change type is 5, which represents the dependent API changed.","The functionally equivalent replacement for a comparison literal with a constant wouldn't lead to a compatibility issue as the actual comparison is still the same and no change on return value or exception throwing occurs. Therefore, there's no compatibility issue, so the CI type is 0."
192,"<android.database.sqlite.SQLiteDatabase: Cursor queryWithFactory(CursorFactory,boolean,String,String[],String,String[],String,String,String,String)>",7,8,"<android.database.sqlite.SQLiteDatabase: Cursor queryWithFactory(CursorFactory,boolean,String,String[],String,String[],String,String,String,String)>","<android.database.sqlite.SQLiteDatabase: Cursor queryWithFactory(CursorFactory,boolean,String,String[],String,String[],String,String,String,String)>",0,"{
    String sql = SQLiteQueryBuilder.buildQueryString(distinct, table, columns, selection, groupBy, having, orderBy, limit);
    return rawQueryWithFactory(cursorFactory, sql, selectionArgs, findEditTable(table));
}","{
    if (!isOpen()) {
        throw new IllegalStateException(""database not open"");
    }
    String sql = SQLiteQueryBuilder.buildQueryString(distinct, table, columns, selection, groupBy, having, orderBy, limit);
    return rawQueryWithFactory(cursorFactory, sql, selectionArgs, findEditTable(table));
}",1,"/**
 * Query the given URL, returning a {@link Cursor} over the result set.
 *
 * @param cursorFactory the cursor factory to use, or null for the default factory
 * @param distinct true if you want each row to be unique, false otherwise.
 * @param table The table name to compile the query against.
 * @param columns A list of which columns to return. Passing null will
 * return all columns, which is discouraged to prevent reading
 * data from storage that isn't going to be used.
 * @param selection A filter declaring which rows to return, formatted as an
 * SQL WHERE clause (excluding the WHERE itself). Passing null
 * will return all rows for the given table.
 * @param selectionArgs You may include ?s in selection, which will be
 * replaced by the values from selectionArgs, in order that they
 * appear in the selection. The values will be bound as Strings.
 * @param groupBy A filter declaring how to group rows, formatted as an SQL
 * GROUP BY clause (excluding the GROUP BY itself). Passing null
 * will cause the rows to not be grouped.
 * @param having A filter declare which row groups to include in the cursor,
 * if row grouping is being used, formatted as an SQL HAVING
 * clause (excluding the HAVING itself). Passing null will cause
 * all row groups to be included, and is required when row
 * grouping is not being used.
 * @param orderBy How to order the rows, formatted as an SQL ORDER BY clause
 * (excluding the ORDER BY itself). Passing null will use the
 * default sort order, which may be unordered.
 * @param limit Limits the number of rows returned by the query,
 * formatted as LIMIT clause. Passing null denotes no LIMIT clause.
 * @return A Cursor object, which is positioned before the first entry
 * @see Cursor
 */
","/**
 * Query the given URL, returning a {@link Cursor} over the result set.
 *
 * @param cursorFactory the cursor factory to use, or null for the default factory
 * @param distinct true if you want each row to be unique, false otherwise.
 * @param table The table name to compile the query against.
 * @param columns A list of which columns to return. Passing null will
 * return all columns, which is discouraged to prevent reading
 * data from storage that isn't going to be used.
 * @param selection A filter declaring which rows to return, formatted as an
 * SQL WHERE clause (excluding the WHERE itself). Passing null
 * will return all rows for the given table.
 * @param selectionArgs You may include ?s in selection, which will be
 * replaced by the values from selectionArgs, in order that they
 * appear in the selection. The values will be bound as Strings.
 * @param groupBy A filter declaring how to group rows, formatted as an SQL
 * GROUP BY clause (excluding the GROUP BY itself). Passing null
 * will cause the rows to not be grouped.
 * @param having A filter declare which row groups to include in the cursor,
 * if row grouping is being used, formatted as an SQL HAVING
 * clause (excluding the HAVING itself). Passing null will cause
 * all row groups to be included, and is required when row
 * grouping is not being used.
 * @param orderBy How to order the rows, formatted as an SQL ORDER BY clause
 * (excluding the ORDER BY itself). Passing null will use the
 * default sort order, which may be unordered.
 * @param limit Limits the number of rows returned by the query,
 * formatted as LIMIT clause. Passing null denotes no LIMIT clause.
 * @return A Cursor object, which is positioned before the first entry
 * @see Cursor
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,3",2,"The control dependency('if' statement) has changed, and a new exception handling statement has been introduced, so the code change type is 2,3.","The introduction of a new exception handling could lead to a different behaviour when the late version of the API is invoked, so the CI type is 2."
193,<android.widget.HorizontalScrollView: boolean onTouchEvent(MotionEvent)>,7,8,<android.widget.HorizontalScrollView: boolean onTouchEvent(MotionEvent)>,<android.widget.HorizontalScrollView: boolean onTouchEvent(MotionEvent)>,0,"{
    if (ev.getAction() == MotionEvent.ACTION_DOWN && ev.getEdgeFlags() != 0) {
        // descendants.
        return false;
    }
    if (!canScroll()) {
        return false;
    }
    if (mVelocityTracker == null) {
        mVelocityTracker = VelocityTracker.obtain();
    }
    mVelocityTracker.addMovement(ev);
    final int action = ev.getAction();
    final float x = ev.getX();
    switch(action) {
        case MotionEvent.ACTION_DOWN:
            /*
                * If being flinged and user touches, stop the fling. isFinished
                * will be false if being flinged.
                */
            if (!mScroller.isFinished()) {
                mScroller.abortAnimation();
            }
            // Remember where the motion event started
            mLastMotionX = x;
            break;
        case MotionEvent.ACTION_MOVE:
            // Scroll to follow the motion event
            final int deltaX = (int) (mLastMotionX - x);
            mLastMotionX = x;
            if (deltaX < 0) {
                if (mScrollX > 0) {
                    scrollBy(deltaX, 0);
                }
            } else if (deltaX > 0) {
                final int rightEdge = getWidth() - mPaddingRight;
                final int availableToScroll = getChildAt(0).getRight() - mScrollX - rightEdge;
                if (availableToScroll > 0) {
                    scrollBy(Math.min(availableToScroll, deltaX), 0);
                }
            }
            break;
        case MotionEvent.ACTION_UP:
            final VelocityTracker velocityTracker = mVelocityTracker;
            velocityTracker.computeCurrentVelocity(1000, mMaximumVelocity);
            int initialVelocity = (int) velocityTracker.getXVelocity();
            if ((Math.abs(initialVelocity) > mMinimumVelocity) && getChildCount() > 0) {
                fling(-initialVelocity);
            }
            if (mVelocityTracker != null) {
                mVelocityTracker.recycle();
                mVelocityTracker = null;
            }
    }
    return true;
}","{
    if (ev.getAction() == MotionEvent.ACTION_DOWN && ev.getEdgeFlags() != 0) {
        // descendants.
        return false;
    }
    if (mVelocityTracker == null) {
        mVelocityTracker = VelocityTracker.obtain();
    }
    mVelocityTracker.addMovement(ev);
    final int action = ev.getAction();
    switch(action & MotionEvent.ACTION_MASK) {
        case MotionEvent.ACTION_DOWN:
            {
                final float x = ev.getX();
                if (!(mIsBeingDragged = inChild((int) x, (int) ev.getY()))) {
                    return false;
                }
                /*
                 * If being flinged and user touches, stop the fling. isFinished
                 * will be false if being flinged.
                 */
                if (!mScroller.isFinished()) {
                    mScroller.abortAnimation();
                }
                // Remember where the motion event started
                mLastMotionX = x;
                mActivePointerId = ev.getPointerId(0);
                break;
            }
        case MotionEvent.ACTION_MOVE:
            if (mIsBeingDragged) {
                // Scroll to follow the motion event
                final int activePointerIndex = ev.findPointerIndex(mActivePointerId);
                final float x = ev.getX(activePointerIndex);
                final int deltaX = (int) (mLastMotionX - x);
                mLastMotionX = x;
                scrollBy(deltaX, 0);
            }
            break;
        case MotionEvent.ACTION_UP:
            if (mIsBeingDragged) {
                final VelocityTracker velocityTracker = mVelocityTracker;
                velocityTracker.computeCurrentVelocity(1000, mMaximumVelocity);
                int initialVelocity = (int) velocityTracker.getXVelocity(mActivePointerId);
                if (getChildCount() > 0 && Math.abs(initialVelocity) > mMinimumVelocity) {
                    fling(-initialVelocity);
                }
                mActivePointerId = INVALID_POINTER;
                mIsBeingDragged = false;
                if (mVelocityTracker != null) {
                    mVelocityTracker.recycle();
                    mVelocityTracker = null;
                }
            }
            break;
        case MotionEvent.ACTION_CANCEL:
            if (mIsBeingDragged && getChildCount() > 0) {
                mActivePointerId = INVALID_POINTER;
                mIsBeingDragged = false;
                if (mVelocityTracker != null) {
                    mVelocityTracker.recycle();
                    mVelocityTracker = null;
                }
            }
            break;
        case MotionEvent.ACTION_POINTER_UP:
            onSecondaryPointerUp(ev);
            break;
    }
    return true;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,4","1,2","The logic in the onTouchEvent has changed, such as the conditions in case statements and added 'case MotionEvent.ACTION_CANCEL' and 'case MotionEvent.ACTION_POINTER_UP'. Thus the code change type is 3 and 4.","Due to the logic changes, different actions will be performed based on the MotionEvent, which could potentially lead to different return values and exceptions. Hence, the CI types are 1 and 2."
194,<android.widget.TextView: boolean dispatchPopulateAccessibilityEvent(AccessibilityEvent)>,7,8,<android.widget.TextView: boolean dispatchPopulateAccessibilityEvent(AccessibilityEvent)>,<android.widget.TextView: boolean dispatchPopulateAccessibilityEvent(AccessibilityEvent)>,0,"{
    final boolean isPassword = isPasswordInputType(mInputType);
    if (!isPassword) {
        CharSequence text = getText();
        if (TextUtils.isEmpty(text)) {
            text = getHint();
        }
        if (!TextUtils.isEmpty(text)) {
            if (text.length() > AccessibilityEvent.MAX_TEXT_LENGTH) {
                text = text.subSequence(0, AccessibilityEvent.MAX_TEXT_LENGTH + 1);
            }
            event.getText().add(text);
        }
    } else {
        event.setPassword(isPassword);
    }
    return false;
}","{
    if (!isShown()) {
        return false;
    }
    final boolean isPassword = isPasswordInputType(mInputType);
    if (!isPassword) {
        CharSequence text = getText();
        if (TextUtils.isEmpty(text)) {
            text = getHint();
        }
        if (!TextUtils.isEmpty(text)) {
            if (text.length() > AccessibilityEvent.MAX_TEXT_LENGTH) {
                text = text.subSequence(0, AccessibilityEvent.MAX_TEXT_LENGTH + 1);
            }
            event.getText().add(text);
        }
    } else {
        event.setPassword(isPassword);
    }
    return false;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,3,0,"The implementation adds a new 'if' control structure to check if the view is shown. If not, it returns false. Therefore, the type of change code is 3.","Both the early version and late version return false at the end, and the changes in the control flow won't impact the return value or the exception handling. Hence, there's no compatibility issue."
195,"<android.webkit.WebView: boolean requestChildRectangleOnScreen(View,Rect,boolean)>",7,8,"<android.webkit.WebView: boolean requestChildRectangleOnScreen(View,Rect,boolean)>","<android.webkit.WebView: boolean requestChildRectangleOnScreen(View,Rect,boolean)>",0,"{
    rect.offset(child.getLeft() - child.getScrollX(), child.getTop() - child.getScrollY());
    int height = getViewHeightWithTitle();
    int screenTop = mScrollY;
    int screenBottom = screenTop + height;
    int scrollYDelta = 0;
    if (rect.bottom > screenBottom) {
        int oneThirdOfScreenHeight = height / 3;
        if (rect.height() > 2 * oneThirdOfScreenHeight) {
            // If the rectangle is too tall to fit in the bottom two thirds
            // of the screen, place it at the top.
            scrollYDelta = rect.top - screenTop;
        } else {
            // If the rectangle will still fit on screen, we want its
            // top to be in the top third of the screen.
            scrollYDelta = rect.top - (screenTop + oneThirdOfScreenHeight);
        }
    } else if (rect.top < screenTop) {
        scrollYDelta = rect.top - screenTop;
    }
    int width = getWidth() - getVerticalScrollbarWidth();
    int screenLeft = mScrollX;
    int screenRight = screenLeft + width;
    int scrollXDelta = 0;
    if (rect.right > screenRight && rect.left > screenLeft) {
        if (rect.width() > width) {
            scrollXDelta += (rect.left - screenLeft);
        } else {
            scrollXDelta += (rect.right - screenRight);
        }
    } else if (rect.left < screenLeft) {
        scrollXDelta -= (screenLeft - rect.left);
    }
    if ((scrollYDelta | scrollXDelta) != 0) {
        return pinScrollBy(scrollXDelta, scrollYDelta, !immediate, 0);
    }
    return false;
}","{
    rect.offset(child.getLeft() - child.getScrollX(), child.getTop() - child.getScrollY());
    Rect content = new Rect(viewToContentX(mScrollX), viewToContentY(mScrollY), viewToContentX(mScrollX + getWidth() - getVerticalScrollbarWidth()), viewToContentY(mScrollY + getViewHeightWithTitle()));
    content = nativeSubtractLayers(content);
    int screenTop = contentToViewY(content.top);
    int screenBottom = contentToViewY(content.bottom);
    int height = screenBottom - screenTop;
    int scrollYDelta = 0;
    if (rect.bottom > screenBottom) {
        int oneThirdOfScreenHeight = height / 3;
        if (rect.height() > 2 * oneThirdOfScreenHeight) {
            // If the rectangle is too tall to fit in the bottom two thirds
            // of the screen, place it at the top.
            scrollYDelta = rect.top - screenTop;
        } else {
            // If the rectangle will still fit on screen, we want its
            // top to be in the top third of the screen.
            scrollYDelta = rect.top - (screenTop + oneThirdOfScreenHeight);
        }
    } else if (rect.top < screenTop) {
        scrollYDelta = rect.top - screenTop;
    }
    int screenLeft = contentToViewX(content.left);
    int screenRight = contentToViewX(content.right);
    int width = screenRight - screenLeft;
    int scrollXDelta = 0;
    if (rect.right > screenRight && rect.left > screenLeft) {
        if (rect.width() > width) {
            scrollXDelta += (rect.left - screenLeft);
        } else {
            scrollXDelta += (rect.right - screenRight);
        }
    } else if (rect.left < screenLeft) {
        scrollXDelta -= (screenLeft - rect.left);
    }
    if ((scrollYDelta | scrollXDelta) != 0) {
        return pinScrollBy(scrollXDelta, scrollYDelta, !immediate, 0);
    }
    return false;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,1,"The calculation method for variables `content`, `screenTop`, `screenBottom`, `height`, `screenLeft`, `screenRight`, `width` has been changed, so classified as Other statement changed. Therefore, the change type is 4. ","The return value is dependent on new calculation methods of variables 'screenTop', 'screenBottom', 'height', 'screenLeft', 'screenRight', 'width'. If these values change, the return value may also change, causing a potential behavior difference. Therefore, the CI type is 1."
198,<android.webkit.WebTextView: boolean dispatchKeyEvent(KeyEvent)>,7,8,<android.webkit.WebTextView: boolean dispatchKeyEvent(KeyEvent)>,<android.webkit.WebTextView: boolean dispatchKeyEvent(KeyEvent)>,0,"{
    if (event.isSystem()) {
        return super.dispatchKeyEvent(event);
    }
    // Treat ACTION_DOWN and ACTION MULTIPLE the same
    boolean down = event.getAction() != KeyEvent.ACTION_UP;
    int keyCode = event.getKeyCode();
    boolean isArrowKey = false;
    switch(keyCode) {
        case KeyEvent.KEYCODE_DPAD_LEFT:
        case KeyEvent.KEYCODE_DPAD_RIGHT:
        case KeyEvent.KEYCODE_DPAD_UP:
        case KeyEvent.KEYCODE_DPAD_DOWN:
            if (!mWebView.nativeCursorMatchesFocus()) {
                return down ? mWebView.onKeyDown(keyCode, event) : mWebView.onKeyUp(keyCode, event);
            }
            isArrowKey = true;
            break;
    }
    if (!isArrowKey && !mOkayForFocusNotToMatch && mWebView.nativeFocusNodePointer() != mNodePointer) {
        mWebView.nativeClearCursor();
        // Do not call remove() here, which hides the soft keyboard.  If
        // the soft keyboard is being displayed, the user will still want
        // it there.
        mWebView.removeView(this);
        mWebView.requestFocus();
        return mWebView.dispatchKeyEvent(event);
    }
    // After a jump to next textfield and the first key press, the cursor
    // and focus will once again match, so reset this value.
    mOkayForFocusNotToMatch = false;
    Spannable text = (Spannable) getText();
    int oldLength = text.length();
    // go ahead and pass the key down immediately.
    if (KeyEvent.KEYCODE_DEL == keyCode && 0 == oldLength) {
        sendDomEvent(event);
        return true;
    }
    if ((mSingle && KeyEvent.KEYCODE_ENTER == keyCode)) {
        if (isPopupShowing()) {
            return super.dispatchKeyEvent(event);
        }
        if (!down) {
            // Hide the keyboard, since the user has just submitted this
            // form.  The submission happens thanks to the two calls
            // to sendDomEvent.
            InputMethodManager.getInstance(mContext).hideSoftInputFromWindow(getWindowToken(), 0);
            sendDomEvent(new KeyEvent(KeyEvent.ACTION_DOWN, keyCode));
            sendDomEvent(event);
        }
        return super.dispatchKeyEvent(event);
    } else if (KeyEvent.KEYCODE_DPAD_CENTER == keyCode) {
        // Note that this handles center key and trackball.
        if (isPopupShowing()) {
            return super.dispatchKeyEvent(event);
        }
        if (!mWebView.nativeCursorMatchesFocus()) {
            return down ? mWebView.onKeyDown(keyCode, event) : mWebView.onKeyUp(keyCode, event);
        }
        // Center key should be passed to a potential onClick
        if (!down) {
            mWebView.shortPressOnTextField();
        }
        // Pass to super to handle longpress.
        return super.dispatchKeyEvent(event);
    }
    // Ensure there is a layout so arrow keys are handled properly.
    if (getLayout() == null) {
        measure(mWidthSpec, mHeightSpec);
    }
    int oldStart = Selection.getSelectionStart(text);
    int oldEnd = Selection.getSelectionEnd(text);
    boolean maxedOut = mMaxLength != -1 && oldLength == mMaxLength;
    // If we are at max length, and there is a selection rather than a
    // cursor, we need to store the text to compare later, since the key
    // may have changed the string.
    String oldText;
    if (maxedOut && oldEnd != oldStart) {
        oldText = text.toString();
    } else {
        oldText = """";
    }
    if (super.dispatchKeyEvent(event)) {
        // ahead and pass it down.
        if (KeyEvent.KEYCODE_ENTER == keyCode) {
            // For multi-line text boxes, newlines will
            // trigger onTextChanged for key down (which will send both
            // key up and key down) but not key up.
            mGotEnterDown = true;
        }
        if (maxedOut && !isArrowKey && keyCode != KeyEvent.KEYCODE_DEL) {
            if (oldEnd == oldStart) {
                // Return true so the key gets dropped.
                return true;
            } else if (!oldText.equals(getText().toString())) {
                // FIXME: This makes the text work properly, but it
                // does not pass down the key event, so it may not
                // work for a textfield that has the type of
                // behavior of GoogleSuggest.  That said, it is
                // unlikely that a site would combine the two in
                // one textfield.
                Spannable span = (Spannable) getText();
                int newStart = Selection.getSelectionStart(span);
                int newEnd = Selection.getSelectionEnd(span);
                mWebView.replaceTextfieldText(0, oldLength, span.toString(), newStart, newEnd);
                return true;
            }
        }
        /* FIXME:
             * In theory, we would like to send the events for the arrow keys.
             * However, the TextView can arbitrarily change the selection (i.e.
             * long press followed by using the trackball).  Therefore, we keep
             * in sync with the TextView via onSelectionChanged.  If we also
             * send the DOM event, we lose the correct selection.
            if (isArrowKey) {
                // Arrow key does not change the text, but we still want to send
                // the DOM events.
                sendDomEvent(event);
            }
             */
        return true;
    }
    // multiple newlines in the native textarea.
    if (mGotEnterDown && !down) {
        return true;
    }
    // if it is a navigation key, pass it to WebView
    if (isArrowKey) {
        // WebView check the trackballtime in onKeyDown to avoid calling
        // native from both trackball and key handling. As this is called
        // from WebTextView, we always want WebView to check with native.
        // Reset trackballtime to ensure it.
        mWebView.resetTrackballTime();
        return down ? mWebView.onKeyDown(keyCode, event) : mWebView.onKeyUp(keyCode, event);
    }
    return false;
}","{
    if (event.isSystem()) {
        return super.dispatchKeyEvent(event);
    }
    // Treat ACTION_DOWN and ACTION MULTIPLE the same
    boolean down = event.getAction() != KeyEvent.ACTION_UP;
    int keyCode = event.getKeyCode();
    boolean isArrowKey = false;
    switch(keyCode) {
        case KeyEvent.KEYCODE_DPAD_LEFT:
        case KeyEvent.KEYCODE_DPAD_RIGHT:
        case KeyEvent.KEYCODE_DPAD_UP:
        case KeyEvent.KEYCODE_DPAD_DOWN:
            if (!mWebView.nativeCursorMatchesFocus()) {
                return down ? mWebView.onKeyDown(keyCode, event) : mWebView.onKeyUp(keyCode, event);
            }
            isArrowKey = true;
            break;
    }
    if (KeyEvent.KEYCODE_TAB == keyCode) {
        if (down) {
            onEditorAction(EditorInfo.IME_ACTION_NEXT);
        }
        return true;
    }
    Spannable text = (Spannable) getText();
    int oldLength = text.length();
    // go ahead and pass the key down immediately.
    if (KeyEvent.KEYCODE_DEL == keyCode && 0 == oldLength) {
        sendDomEvent(event);
        return true;
    }
    if ((mSingle && KeyEvent.KEYCODE_ENTER == keyCode)) {
        if (isPopupShowing()) {
            return super.dispatchKeyEvent(event);
        }
        if (!down) {
            // Hide the keyboard, since the user has just submitted this
            // form.  The submission happens thanks to the two calls
            // to sendDomEvent.
            InputMethodManager.getInstance(mContext).hideSoftInputFromWindow(getWindowToken(), 0);
            sendDomEvent(new KeyEvent(KeyEvent.ACTION_DOWN, keyCode));
            sendDomEvent(event);
        }
        return super.dispatchKeyEvent(event);
    } else if (KeyEvent.KEYCODE_DPAD_CENTER == keyCode) {
        // Note that this handles center key and trackball.
        if (isPopupShowing()) {
            return super.dispatchKeyEvent(event);
        }
        if (!mWebView.nativeCursorMatchesFocus()) {
            return down ? mWebView.onKeyDown(keyCode, event) : mWebView.onKeyUp(keyCode, event);
        }
        // Center key should be passed to a potential onClick
        if (!down) {
            mWebView.centerKeyPressOnTextField();
        }
        // Pass to super to handle longpress.
        return super.dispatchKeyEvent(event);
    }
    // Ensure there is a layout so arrow keys are handled properly.
    if (getLayout() == null) {
        measure(mWidthSpec, mHeightSpec);
    }
    int oldStart = Selection.getSelectionStart(text);
    int oldEnd = Selection.getSelectionEnd(text);
    boolean maxedOut = mMaxLength != -1 && oldLength == mMaxLength;
    // If we are at max length, and there is a selection rather than a
    // cursor, we need to store the text to compare later, since the key
    // may have changed the string.
    String oldText;
    if (maxedOut && oldEnd != oldStart) {
        oldText = text.toString();
    } else {
        oldText = """";
    }
    if (super.dispatchKeyEvent(event)) {
        // ahead and pass it down.
        if (KeyEvent.KEYCODE_ENTER == keyCode) {
            // For multi-line text boxes, newlines will
            // trigger onTextChanged for key down (which will send both
            // key up and key down) but not key up.
            mGotEnterDown = true;
        }
        if (maxedOut && !isArrowKey && keyCode != KeyEvent.KEYCODE_DEL) {
            if (oldEnd == oldStart) {
                // Return true so the key gets dropped.
                return true;
            } else if (!oldText.equals(getText().toString())) {
                // FIXME: This makes the text work properly, but it
                // does not pass down the key event, so it may not
                // work for a textfield that has the type of
                // behavior of GoogleSuggest.  That said, it is
                // unlikely that a site would combine the two in
                // one textfield.
                Spannable span = (Spannable) getText();
                int newStart = Selection.getSelectionStart(span);
                int newEnd = Selection.getSelectionEnd(span);
                mWebView.replaceTextfieldText(0, oldLength, span.toString(), newStart, newEnd);
                return true;
            }
        }
        /* FIXME:
             * In theory, we would like to send the events for the arrow keys.
             * However, the TextView can arbitrarily change the selection (i.e.
             * long press followed by using the trackball).  Therefore, we keep
             * in sync with the TextView via onSelectionChanged.  If we also
             * send the DOM event, we lose the correct selection.
            if (isArrowKey) {
                // Arrow key does not change the text, but we still want to send
                // the DOM events.
                sendDomEvent(event);
            }
             */
        return true;
    }
    // multiple newlines in the native textarea.
    if (mGotEnterDown && !down) {
        return true;
    }
    // if it is a navigation key, pass it to WebView
    if (isArrowKey) {
        // WebView check the trackballtime in onKeyDown to avoid calling
        // native from both trackball and key handling. As this is called
        // from WebTextView, we always want WebView to check with native.
        // Reset trackballtime to ensure it.
        mWebView.resetTrackballTime();
        return down ? mWebView.onKeyDown(keyCode, event) : mWebView.onKeyUp(keyCode, event);
    }
    return false;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,3,4",1,"The code statements inside the 'if (KeyEvent.KEYCODE_TAB == keyCode)' statement block has been introduced in the late version. Also the method called inside 'if (!down)' block has changed from mWebView.shortPressOnTextField() to mWebView.centerKeyPressOnTextField(). So the code change types are return statement (1), control dependency (3), and other statement (4).","The added 'if (KeyEvent.KEYCODE_TAB == keyCode)' block and the change of mWebView.centerKeyPressOnTextField() method call might cause the API to return a different value, hence the CI type is 1."
200,<android.webkit.WebView.ScaleDetectorListener: boolean onScale(ScaleGestureDetector)>,7,8,<android.webkit.WebView.ScaleDetectorListener: boolean onScale(ScaleGestureDetector)>,<android.webkit.WebView.ScaleDetectorListener: boolean onScale(ScaleGestureDetector)>,0,"{
    float scale = (float) (Math.round(detector.getScaleFactor() * mActualScale * 100) / 100.0);
    if (Math.abs(scale - mActualScale) >= PREVIEW_SCALE_INCREMENT) {
        mPreviewZoomOnly = true;
        // limit the scale change per step
        if (scale > mActualScale) {
            scale = Math.min(scale, mActualScale * 1.25f);
        } else {
            scale = Math.max(scale, mActualScale * 0.8f);
        }
        mZoomCenterX = detector.getFocusX();
        mZoomCenterY = detector.getFocusY();
        setNewZoomScale(scale, false, false);
        invalidate();
        return true;
    }
    return false;
}","{
    float scale = (float) (Math.round(detector.getScaleFactor() * mActualScale * 100) / 100.0);
    if (Math.abs(scale - mActualScale) >= MINIMUM_SCALE_INCREMENT) {
        mPreviewZoomOnly = true;
        // limit the scale change per step
        if (scale > mActualScale) {
            scale = Math.min(scale, mActualScale * 1.25f);
        } else {
            scale = Math.max(scale, mActualScale * 0.8f);
        }
        mZoomCenterX = detector.getFocusX();
        mZoomCenterY = detector.getFocusY();
        setNewZoomScale(scale, false, false);
        invalidate();
        return true;
    }
    return false;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,3,1,"The condition part of the 'if' statement has been changed from checking against `PREVIEW_SCALE_INCREMENT` to `MINIMUM_SCALE_INCREMENT`, which falls into change type 3.","The change in condition part of the 'if' statement affects the logic by which the function 'onScale()' returns a boolean value. Depending on the new `MINIMUM_SCALE_INCREMENT` value in late version, the 'onScale()' may exhibit different behavior compare to the early version where `PREVIEW_SCALE_INCREMENT` value was used. Hence the compatibility issue is of type 1."
201,"<android.accounts.AccountManager: void setAuthToken(Account,String,String)>",7,8,"<android.accounts.AccountManager: void setAuthToken(Account,String,String)>","<android.accounts.AccountManager: void setAuthToken(Account,String,String)>",0,"{
    try {
        mService.setAuthToken(account, authTokenType, authToken);
    } catch (RemoteException e) {
        // won't ever happen
        throw new RuntimeException(e);
    }
}","{
    if (account == null)
        throw new IllegalArgumentException(""account is null"");
    if (authTokenType == null)
        throw new IllegalArgumentException(""authTokenType is null"");
    try {
        mService.setAuthToken(account, authTokenType, authToken);
    } catch (RemoteException e) {
        // won't ever happen
        throw new RuntimeException(e);
    }
}",1,"/**
 * Sets the authtoken named by ""authTokenType"" to the value specified by authToken.
 * If the account does not exist then this call has no effect.
 * <p>
 * Requires that the caller has permission
 * {@link android.Manifest.permission#AUTHENTICATE_ACCOUNTS} and is running
 * with the same UID as the Authenticator for the account.
 * @param account the account whose authtoken is to be set. Must not be null.
 * @param authTokenType the type of the authtoken to set. Must not be null.
 * @param authToken the authToken to set. May be null.
 */
","/**
 * Adds an auth token to the AccountManager cache for an account.
 * If the account does not exist then this call has no effect.
 * Replaces any previous auth token for this account and auth token type.
 * Intended for use by the authenticator, not directly by applications.
 *
 * <p>It is safe to call this method from the main thread.
 *
 * <p>This method requires the caller to hold the permission
 * {@link android.Manifest.permission#AUTHENTICATE_ACCOUNTS}
 * and to have the same UID as the account's authenticator.
 *
 * @param account The account to set an auth token for
 * @param authTokenType The type of the auth token, see {#getAuthToken}
 * @param authToken The auth token to add to the cache
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,2",2,"In the late implementation, two new conditional checks have been added to check if 'account' and 'authTokenType' are null and then throws IllegalArgumentException if any of those are null. So, the code change type is 2 (Due to introduction of new exceptions) and 3 (Control dependency has changed due to introduction of conditional checks).","The late implementation potentially throws a new IllegalArgumentException, which isn't present in the early implementation. Therefore, it causes a Compatibility Issue under category 2 (Compatibility Issues caused by potential different exception handlings)."
203,<android.webkit.CallbackProxy: void onProgressChanged(int)>,7,8,<android.webkit.CallbackProxy: void onProgressChanged(int)>,<android.webkit.CallbackProxy: void onProgressChanged(int)>,0,"{
    // Synchronize so that mLatestProgress is up-to-date.
    synchronized (this) {
        mLatestProgress = newProgress;
        if (mWebChromeClient == null) {
            return;
        }
        if (!mProgressUpdatePending) {
            sendEmptyMessage(PROGRESS);
            mProgressUpdatePending = true;
        }
    }
}","{
    // Synchronize so that mLatestProgress is up-to-date.
    synchronized (this) {
        if (mWebChromeClient == null || mLatestProgress == newProgress) {
            return;
        }
        mLatestProgress = newProgress;
        if (!mProgressUpdatePending) {
            sendEmptyMessage(PROGRESS);
            mProgressUpdatePending = true;
        }
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"3,1",1,"The 'if' condition in the late version has been modified as 'mWebChromeClient == null || mLatestProgress == newProgress', which is a control dependency change. Also, the 'return' statement under this condition has been moved which is a return statement changed.","Due to the modification of the 'if' condition, the early version could execute 'mLatestProgress = newProgress;' even when 'mLatestProgress == newProgress', while the late version might not. This can potentially cause the method to return different variable values and leads CI, thus it's categorized as CI type 1."
205,<android.widget.Spinner.DropDownAdapter: boolean isEnabled(int)>,7,8,<android.widget.Spinner.DropDownAdapter: boolean isEnabled(int)>,<android.widget.Spinner.DropDownAdapter: boolean isEnabled(int)>,0,"{
    return true;
}","{
    final ListAdapter adapter = mListAdapter;
    if (adapter != null) {
        return adapter.isEnabled(position);
    } else {
        return true;
    }
}",1,"/**
 * <p>Always returns false.</p>
 *
 * @return false
 */
","/**
 * If the wrapped SpinnerAdapter is also a ListAdapter, delegate this call.
 * Otherwise, return true.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3",1,"The code change occurs at the return statement, and it is now tied to a condition check. Hence, the code change types are 1,3.","The early version always returned ""true"" regardless of the input, while the late version's return value depends on adapter.isEnabled(position). Thus, the return statement change could potentially cause the API to return different values under some specific conditions, making it a CI of type 1."
206,"<android.content.ContentResolver: Cursor query(Uri,String[],String,String[],String)>",7,8,"<android.content.ContentResolver: Cursor query(Uri,String[],String,String[],String)>","<android.content.ContentResolver: Cursor query(Uri,String[],String,String[],String)>",0,"{
    IContentProvider provider = acquireProvider(uri);
    if (provider == null) {
        return null;
    }
    try {
        Cursor qCursor = provider.query(uri, projection, selection, selectionArgs, sortOrder);
        if (qCursor == null) {
            releaseProvider(provider);
            return null;
        }
        // Wrap the cursor object into CursorWrapperInner object
        return new CursorWrapperInner(qCursor, provider);
    } catch (RemoteException e) {
        releaseProvider(provider);
        return null;
    } catch (RuntimeException e) {
        releaseProvider(provider);
        throw e;
    }
}","{
    IContentProvider provider = acquireProvider(uri);
    if (provider == null) {
        return null;
    }
    try {
        long startTime = SystemClock.uptimeMillis();
        Cursor qCursor = provider.query(uri, projection, selection, selectionArgs, sortOrder);
        if (qCursor == null) {
            releaseProvider(provider);
            return null;
        }
        // force query execution
        qCursor.getCount();
        long durationMillis = SystemClock.uptimeMillis() - startTime;
        maybeLogQueryToEventLog(durationMillis, uri, projection, selection, sortOrder);
        // Wrap the cursor object into CursorWrapperInner object
        return new CursorWrapperInner(qCursor, provider);
    } catch (RemoteException e) {
        releaseProvider(provider);
        return null;
    } catch (RuntimeException e) {
        releaseProvider(provider);
        throw e;
    }
}",1,"/**
 * Query the given URI, returning a {@link Cursor} over the result set.
 *
 * @param uri The URI, using the content:// scheme, for the content to
 * retrieve.
 * @param projection A list of which columns to return. Passing null will
 * return all columns, which is discouraged to prevent reading data
 * from storage that isn't going to be used.
 * @param selection A filter declaring which rows to return, formatted as an
 * SQL WHERE clause (excluding the WHERE itself). Passing null will
 * return all rows for the given URI.
 * @param selectionArgs You may include ?s in selection, which will be
 * replaced by the values from selectionArgs, in the order that they
 * appear in the selection. The values will be bound as Strings.
 * @param sortOrder How to order the rows, formatted as an SQL ORDER BY
 * clause (excluding the ORDER BY itself). Passing null will use the
 * default sort order, which may be unordered.
 * @return A Cursor object, which is positioned before the first entry, or null
 * @see Cursor
 */
","/**
 * <p>
 * Query the given URI, returning a {@link Cursor} over the result set.
 * </p>
 * <p>
 * For best performance, the caller should follow these guidelines:
 * <ul>
 * <li>Provide an explicit projection, to prevent
 * reading data from storage that aren't going to be used.</li>
 * <li>Use question mark parameter markers such as 'phone=?' instead of
 * explicit values in the {@code selection} parameter, so that queries
 * that differ only by those values will be recognized as the same
 * for caching purposes.</li>
 * </ul>
 * </p>
 *
 * @param uri The URI, using the content:// scheme, for the content to
 * retrieve.
 * @param projection A list of which columns to return. Passing null will
 * return all columns, which is inefficient.
 * @param selection A filter declaring which rows to return, formatted as an
 * SQL WHERE clause (excluding the WHERE itself). Passing null will
 * return all rows for the given URI.
 * @param selectionArgs You may include ?s in selection, which will be
 * replaced by the values from selectionArgs, in the order that they
 * appear in the selection. The values will be bound as Strings.
 * @param sortOrder How to order the rows, formatted as an SQL ORDER BY
 * clause (excluding the ORDER BY itself). Passing null will use the
 * default sort order, which may be unordered.
 * @return A Cursor object, which is positioned before the first entry, or null
 * @see Cursor
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The changes made in the code are addition of new lines related to query logging, which includes timing the query execution and logging query details. No existing statements or functional aspects of the method have been altered, hence code change type is 4.","Though new statements have been added, these changes do not alter the method's return values or exception handling. Thus, no Compatibility Issue exists and the type is 0."
207,<android.content.ContentResolver: void removeStatusChangeListener(Object)>,7,8,<android.content.ContentResolver: void removeStatusChangeListener(Object)>,<android.content.ContentResolver: void removeStatusChangeListener(Object)>,0,"{
    try {
        getContentService().removeStatusChangeListener((ISyncStatusObserver.Stub) handle);
    } catch (RemoteException e) {
    // exception ignored; if this is thrown then it means the runtime is in the midst of
    // being restarted
    }
}","{
    if (handle == null) {
        throw new IllegalArgumentException(""you passed in a null handle"");
    }
    try {
        getContentService().removeStatusChangeListener((ISyncStatusObserver.Stub) handle);
    } catch (RemoteException e) {
    // exception ignored; if this is thrown then it means the runtime is in the midst of
    // being restarted
    }
}",1,,"/**
 * Remove a previously registered status change listener.
 * @param handle the handle that was returned by {@link #addStatusChangeListener}
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,2",2,"In the late version, a new control statement('if') has been introduced along with a new exception throwing statement which is not present in the early version. So the change type is 3,2.","A new exception (IllegalArgumentException) could be thrown if a null handle is passed in the late version but not in the early version. Therefore, the CI type is 2."
208,<android.widget.ImageView: boolean onSetAlpha(int)>,7,8,<android.widget.ImageView: boolean onSetAlpha(int)>,<android.widget.ImageView: boolean onSetAlpha(int)>,0,"{
    if (getBackground() == null) {
        int scale = alpha + (alpha >> 7);
        if (mViewAlphaScale != scale) {
            mViewAlphaScale = scale;
            applyColorMod();
        }
        return true;
    }
    return false;
}","{
    if (getBackground() == null) {
        int scale = alpha + (alpha >> 7);
        if (mViewAlphaScale != scale) {
            mViewAlphaScale = scale;
            mColorMod = true;
            applyColorMod();
        }
        return true;
    }
    return false;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"The state of variable mColorMod has been changed in the late version. Therefore, the change type is 4 (Other statement changed).","There is no compatibility issue. The variable mColorMod has been set to true in the late version, but it doesn't affect the return value or exceptions of this method. Therefore, the CI type is 0 (No Compatibility Issue exist)."
209,<android.content.pm.ResolveInfo: CharSequence loadLabel(PackageManager)>,7,8,<android.content.pm.ResolveInfo: CharSequence loadLabel(PackageManager)>,<android.content.pm.ResolveInfo: CharSequence loadLabel(PackageManager)>,0,"{
    if (nonLocalizedLabel != null) {
        return nonLocalizedLabel;
    }
    CharSequence label;
    if (resolvePackageName != null && labelRes != 0) {
        label = pm.getText(resolvePackageName, labelRes, null);
        if (label != null) {
            return label;
        }
    }
    ComponentInfo ci = activityInfo != null ? activityInfo : serviceInfo;
    ApplicationInfo ai = ci.applicationInfo;
    if (labelRes != 0) {
        label = pm.getText(ci.packageName, labelRes, ai);
        if (label != null) {
            return label;
        }
    }
    return ci.loadLabel(pm);
}","{
    if (nonLocalizedLabel != null) {
        return nonLocalizedLabel;
    }
    CharSequence label;
    if (resolvePackageName != null && labelRes != 0) {
        label = pm.getText(resolvePackageName, labelRes, null);
        if (label != null) {
            return label.toString().trim();
        }
    }
    ComponentInfo ci = activityInfo != null ? activityInfo : serviceInfo;
    ApplicationInfo ai = ci.applicationInfo;
    if (labelRes != 0) {
        label = pm.getText(ci.packageName, labelRes, ai);
        if (label != null) {
            return label.toString().trim();
        }
    }
    CharSequence data = ci.loadLabel(pm);
    // Make the data safe
    if (data != null)
        data = data.toString().trim();
    return data;
}",1,"/**
 * Retrieve the current textual label associated with this resolution.  This
 * will call back on the given PackageManager to load the label from
 * the application.
 *
 * @param pm A PackageManager from which the label can be loaded; usually
 * the PackageManager from which you originally retrieved this item.
 *
 * @return Returns a CharSequence containing the resolutions's label.  If the
 * item does not have a label, its name is returned.
 */
","/**
 * Retrieve the current textual label associated with this resolution.  This
 * will call back on the given PackageManager to load the label from
 * the application.
 *
 * @param pm A PackageManager from which the label can be loaded; usually
 * the PackageManager from which you originally retrieved this item.
 *
 * @return Returns a CharSequence containing the resolutions's label.  If the
 * item does not have a label, its name is returned.
 */
",-1,,,-1,-1,-1,-1,-1,-1,1,1,"The return statements have been changed from 'return label;' and 'return data;' to 'return label.toString().trim();' and 'return data.toString().trim();', so the code change type is 1.","As in the late version, the 'return' statement called toString() and trim() method, which will potentially return different value (trimmed string) than the early version, so the CI type is 1."
210,"<android.content.pm.PackageItemInfo: XmlResourceParser loadXmlMetaData(PackageManager,String)>",7,8,"<android.content.pm.PackageItemInfo: XmlResourceParser loadXmlMetaData(PackageManager,String)>","<android.content.pm.PackageItemInfo: XmlResourceParser loadXmlMetaData(PackageManager,String)>",0,"{
    if (metaData != null) {
        int resid = metaData.getInt(name);
        if (resid != 0) {
            return pm.getXml(packageName, resid, null);
        }
    }
    return null;
}","{
    if (metaData != null) {
        int resid = metaData.getInt(name);
        if (resid != 0) {
            return pm.getXml(packageName, resid, getApplicationInfo());
        }
    }
    return null;
}",1,"/**
 * Load an XML resource attached to the meta-data of this item.  This will
 * retrieved the name meta-data entry, and if defined call back on the
 * given PackageManager to load its XML file from the application.
 *
 * @param pm A PackageManager from which the XML can be loaded; usually
 * the PackageManager from which you originally retrieved this item.
 * @param name Name of the meta-date you would like to load.
 *
 * @return Returns an XmlPullParser you can use to parse the XML file
 * assigned as the given meta-data.  If the meta-data name is not defined
 * or the XML resource could not be found, null is returned.
 */
","/**
 * Load an XML resource attached to the meta-data of this item.  This will
 * retrieved the name meta-data entry, and if defined call back on the
 * given PackageManager to load its XML file from the application.
 *
 * @param pm A PackageManager from which the XML can be loaded; usually
 * the PackageManager from which you originally retrieved this item.
 * @param name Name of the meta-date you would like to load.
 *
 * @return Returns an XmlPullParser you can use to parse the XML file
 * assigned as the given meta-data.  If the meta-data name is not defined
 * or the XML resource could not be found, null is returned.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1, 5",1,"The third parameter in the method pm.getXml() has changed from null to getApplicationInfo(), so the code change type is 1,5.","As the third parameter in the method pm.getXml() has been replaced with getApplicationInfo(), it could potentially cause the API to return a different value, so the CI type is 1."
214,"<android.provider.Calendar.Calendars: int deleteCalendarsForAccount(ContentResolver,Account)>",7,8,"<android.provider.Calendar.Calendars: int deleteCalendarsForAccount(ContentResolver,Account)>","<android.provider.Calendar.Calendars: int deleteCalendarsForAccount(ContentResolver,Account)>",0,"{
    // delete all calendars that match this account
    return Calendar.Calendars.delete(cr, Calendar.Calendars._SYNC_ACCOUNT + ""=? AND "" + Calendar.Calendars._SYNC_ACCOUNT_TYPE + ""=?"", new String[] { account.name, account.type });
}","{
    // delete all calendars that match this account
    return Calendar.Calendars.delete(cr, WHERE_DELETE_FOR_ACCOUNT, new String[] { account.name, account.type });
}",1,"/**
 * Convenience method to delete all calendars that match the account.
 *
 * @param cr the ContentResolver
 * @param account the account whose rows should be deleted
 * @return the count of rows that were deleted
 */
","/**
 * Convenience method to delete all calendars that match the account.
 *
 * @param cr the ContentResolver
 * @param account the account whose rows should be deleted
 * @return the count of rows that were deleted
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The function has been updated so that the hard-coded query string in Calendar.Calendars.delete has been replaced by the variable WHERE_DELETE_FOR_ACCOUNT. But the logic doesn't seem to be changed, hence the change belongs to the type 4.","As the change in the function is just a replacement of a hardcoded query with a variable, the modification doesn't affect neither the returned values nor exceptions that potentially be thrown, therefore the CI type is 0."
216,"<android.pim.vcard.VCardParser_V21: void handlePropertyValue(String,String)>",7,8,"<android.pim.vcard.VCardParser_V21: void handlePropertyValue(String,String)>","<android.pim.vcard.VCardParser_V21: void handlePropertyValue(String,String)>",0,"{
    if (mEncoding.equalsIgnoreCase(""QUOTED-PRINTABLE"")) {
        long start = System.currentTimeMillis();
        String result = getQuotedPrintable(propertyValue);
        if (mBuilder != null) {
            ArrayList<String> v = new ArrayList<String>();
            v.add(result);
            mBuilder.propertyValues(v);
        }
        mTimeHandleQuotedPrintable += System.currentTimeMillis() - start;
    } else if (mEncoding.equalsIgnoreCase(""BASE64"") || mEncoding.equalsIgnoreCase(""B"")) {
        long start = System.currentTimeMillis();
        // OutOfMemoryError occurs. To ignore such cases, use try-catch.
        try {
            String result = getBase64(propertyValue);
            if (mBuilder != null) {
                ArrayList<String> v = new ArrayList<String>();
                v.add(result);
                mBuilder.propertyValues(v);
            }
        } catch (OutOfMemoryError error) {
            Log.e(LOG_TAG, ""OutOfMemoryError happened during parsing BASE64 data!"");
            if (mBuilder != null) {
                mBuilder.propertyValues(null);
            }
        }
        mTimeHandleBase64 += System.currentTimeMillis() - start;
    } else {
        if (!(mEncoding == null || mEncoding.equalsIgnoreCase(""7BIT"") || mEncoding.equalsIgnoreCase(""8BIT"") || mEncoding.toUpperCase().startsWith(""X-""))) {
            Log.w(LOG_TAG, ""The encoding unsupported by vCard spec: \"""" + mEncoding + ""\""."");
        }
        long start = System.currentTimeMillis();
        if (mBuilder != null) {
            ArrayList<String> v = new ArrayList<String>();
            v.add(maybeUnescapeText(propertyValue));
            mBuilder.propertyValues(v);
        }
        mTimeHandleMiscPropertyValue += System.currentTimeMillis() - start;
    }
}","{
    if (mEncoding.equalsIgnoreCase(""QUOTED-PRINTABLE"")) {
        final long start = System.currentTimeMillis();
        final String result = getQuotedPrintable(propertyValue);
        if (mBuilder != null) {
            ArrayList<String> v = new ArrayList<String>();
            v.add(result);
            mBuilder.propertyValues(v);
        }
        mTimeHandleQuotedPrintable += System.currentTimeMillis() - start;
    } else if (mEncoding.equalsIgnoreCase(""BASE64"") || mEncoding.equalsIgnoreCase(""B"")) {
        final long start = System.currentTimeMillis();
        // OutOfMemoryError occurs. To ignore such cases, use try-catch.
        try {
            final String result = getBase64(propertyValue);
            if (mBuilder != null) {
                ArrayList<String> v = new ArrayList<String>();
                v.add(result);
                mBuilder.propertyValues(v);
            }
        } catch (OutOfMemoryError error) {
            Log.e(LOG_TAG, ""OutOfMemoryError happened during parsing BASE64 data!"");
            if (mBuilder != null) {
                mBuilder.propertyValues(null);
            }
        }
        mTimeHandleBase64 += System.currentTimeMillis() - start;
    } else {
        if (!(mEncoding == null || mEncoding.equalsIgnoreCase(""7BIT"") || mEncoding.equalsIgnoreCase(""8BIT"") || mEncoding.toUpperCase().startsWith(""X-""))) {
            Log.w(LOG_TAG, ""The encoding unsupported by vCard spec: \"""" + mEncoding + ""\""."");
        }
        final long start = System.currentTimeMillis();
        if (mBuilder != null) {
            ArrayList<String> v = new ArrayList<String>();
            v.add(maybeUnescapeText(propertyValue));
            mBuilder.propertyValues(v);
        }
        mTimeHandleMiscPropertyValue += System.currentTimeMillis() - start;
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,4,0,"The implementation code in both the versions are same and the only difference is in the declaration of local variables in the late version where 'final' keyword is added before few variables, Classifying this minor change in the local variable declaration as Other Statement Changed (4).","However, such a change doesn't bring in any incompatibility issues as the final keyword only restricts the reassignment of these variables to a new value, which doesn't seem to be happening in this case, so No Compatibility Issue exists (0)."
217,<android.net.http.Request: void reset()>,7,8,<android.net.http.Request: void reset()>,<android.net.http.Request: void reset()>,0,"{
    /* clear content-length header */
    mHttpRequest.removeHeaders(CONTENT_LENGTH_HEADER);
    if (mBodyProvider != null) {
        try {
            mBodyProvider.reset();
        } catch (IOException ex) {
            if (HttpLog.LOGV)
                HttpLog.v(""failed to reset body provider "" + getUri());
        }
        setBodyProvider(mBodyProvider, mBodyLength);
    }
}","{
    /* clear content-length header */
    mHttpRequest.removeHeaders(CONTENT_LENGTH_HEADER);
    if (mBodyProvider != null) {
        try {
            mBodyProvider.reset();
        } catch (IOException ex) {
            if (HttpLog.LOGV)
                HttpLog.v(""failed to reset body provider "" + getUri());
        }
        setBodyProvider(mBodyProvider, mBodyLength);
    }
    if (mReceivedBytes > 0) {
        // reset the fail count as we continue the request
        mFailCount = 0;
        // set the ""Range"" header to indicate that the retry will continue
        // instead of restarting the request
        HttpLog.v(""*** Request.reset() to range:"" + mReceivedBytes);
        mHttpRequest.setHeader(""Range"", ""bytes="" + mReceivedBytes + ""-"");
    }
}",1,"/**
 * If this request has been sent once and failed, it must be reset
 * before it can be sent again.
 */
","/**
 * If this request has been sent once and failed, it must be reset
 * before it can be sent again.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"In the later version, a new condition statement with 'if (mReceivedBytes > 0) {...}' is introduced and some other statements (log output and setting HttpHeader) are done inside it, which can be classified as an other statement change.","There is no Compatibility Issue (CI) introduced as the newly added statements do not modify the method's behavior in terms of its return values or thrown exceptions. The modifications are only related to internal manipulations and logging mechanisms. Therefore, the type of CI is 0."
218,<android.database.sqlite.SQLiteDatabase: SQLiteStatement compileStatement(String)>,7,8,<android.database.sqlite.SQLiteDatabase: SQLiteStatement compileStatement(String)>,<android.database.sqlite.SQLiteDatabase: SQLiteStatement compileStatement(String)>,0,"{
    lock();
    try {
        return new SQLiteStatement(this, sql);
    } finally {
        unlock();
    }
}","{
    lock();
    if (!isOpen()) {
        throw new IllegalStateException(""database not open"");
    }
    try {
        return new SQLiteStatement(this, sql);
    } finally {
        unlock();
    }
}",1,"/**
 * Compiles an SQL statement into a reusable pre-compiled statement object.
 * The parameters are identical to {@link #execSQL(String)}. You may put ?s in the
 * statement and fill in those values with {@link SQLiteProgram#bindString}
 * and {@link SQLiteProgram#bindLong} each time you want to run the
 * statement. Statements may not return result sets larger than 1x1.
 *
 * @param sql The raw SQL statement, may contain ? for unknown values to be
 * bound later.
 * @return a pre-compiled statement object.
 */
","/**
 * Compiles an SQL statement into a reusable pre-compiled statement object.
 * The parameters are identical to {@link #execSQL(String)}. You may put ?s in the
 * statement and fill in those values with {@link SQLiteProgram#bindString}
 * and {@link SQLiteProgram#bindLong} each time you want to run the
 * statement. Statements may not return result sets larger than 1x1.
 *
 * @param sql The raw SQL statement, may contain ? for unknown values to be
 * bound later.
 * @return a pre-compiled statement object.
 */
",-1,,,-1,-1,-1,-1,-1,-1,2,2,"A new exception handling statement ""if (!isOpen()) {throw new IllegalStateException(""database not open"");}"" is introduced in the late version, so the code change type is 2.","Since a new exception can be thrown due to the introduction of the new exception handling statement in the late version, the API can potentially throw a different exception, so the CI type is 2."
219,<android.app.Activity: void removeDialog(int)>,7,8,<android.app.Activity: void removeDialog(int)>,<android.app.Activity: void removeDialog(int)>,0,"{
    if (mManagedDialogs == null) {
        return;
    }
    final Dialog dialog = mManagedDialogs.get(id);
    if (dialog == null) {
        return;
    }
    dialog.dismiss();
    mManagedDialogs.remove(id);
}","{
    if (mManagedDialogs == null) {
        return;
    }
    final ManagedDialog md = mManagedDialogs.get(id);
    if (md == null) {
        return;
    }
    md.mDialog.dismiss();
    mManagedDialogs.remove(id);
}",1,"/**
 * Removes any internal references to a dialog managed by this Activity.
 * If the dialog is showing, it will dismiss it as part of the clean up.
 *
 * This can be useful if you know that you will never show a dialog again and
 * want to avoid the overhead of saving and restoring it in the future.
 *
 * @param id The id of the managed dialog.
 *
 * @see #onCreateDialog(int)
 * @see #onPrepareDialog(int, Dialog)
 * @see #showDialog(int)
 * @see #dismissDialog(int)
 */
","/**
 * Removes any internal references to a dialog managed by this Activity.
 * If the dialog is showing, it will dismiss it as part of the clean up.
 *
 * <p>This can be useful if you know that you will never show a dialog again and
 * want to avoid the overhead of saving and restoring it in the future.
 *
 * @param id The id of the managed dialog.
 *
 * @see #onCreateDialog(int, Bundle)
 * @see #onPrepareDialog(int, Dialog, Bundle)
 * @see #showDialog(int)
 * @see #dismissDialog(int)
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",0,"The type of local variable 'dialog' has changed from 'Dialog' to 'ManagedDialog' and the variable 'dialog' has been changed to 'md.mDialog' in the 'dismiss' method call, so the code change type is 1,5.","Even though the type of local variable and the method call have changed, the behaviour of function 'removeDialog' remains the same, as it still dismisses a dialog and removes it from 'mManagedDialogs'. Thus, no Compatibility Issue exists. Therefore, the CI type is 0."
220,<android.widget.ExpandableListConnector: int getItemViewType(int)>,7,8,<android.widget.ExpandableListConnector: int getItemViewType(int)>,<android.widget.ExpandableListConnector: int getItemViewType(int)>,0,"{
    final ExpandableListPosition pos = getUnflattenedPos(flatListPos).position;
    int retValue;
    if (pos.type == ExpandableListPosition.GROUP) {
        retValue = 0;
    } else {
        retValue = 1;
    }
    pos.recycle();
    return retValue;
}","{
    final ExpandableListPosition pos = getUnflattenedPos(flatListPos).position;
    int retValue;
    if (mExpandableListAdapter instanceof HeterogeneousExpandableList) {
        HeterogeneousExpandableList adapter = (HeterogeneousExpandableList) mExpandableListAdapter;
        if (pos.type == ExpandableListPosition.GROUP) {
            retValue = adapter.getGroupType(pos.groupPos);
        } else {
            final int childType = adapter.getChildType(pos.groupPos, pos.childPos);
            retValue = adapter.getGroupTypeCount() + childType;
        }
    } else {
        if (pos.type == ExpandableListPosition.GROUP) {
            retValue = 0;
        } else {
            retValue = 1;
        }
    }
    pos.recycle();
    return retValue;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,3,5",1,"In the late version, a change in the control dependency (if else condition), change in the return statement, and the use of a dependent API (HeterogeneousExpandableList and its methods) have been introduced. Therefore, the code change types are 1 for return statement change, 3 for control dependency change, and 5 for dependent API change.","As the return value of the function may change due to the changes made in control flow and return statement, it can potentially cause the API to behave differently, thus a potential Compatibility Issue of type 1 exists."
221,"<android.net.SSLCertificateSocketFactory: Socket createSocket(InetAddress,int,InetAddress,int)>",7,8,"<android.net.SSLCertificateSocketFactory: Socket createSocket(InetAddress,int,InetAddress,int)>","<android.net.SSLCertificateSocketFactory: Socket createSocket(InetAddress,int,InetAddress,int)>",0,"{
    throw new IOException(""Cannot validate certification without a hostname"");
}","{
    OpenSSLSocketImpl s = (OpenSSLSocketImpl) getDelegate().createSocket(addr, port, localAddr, localPort);
    s.setHandshakeTimeout(mHandshakeTimeoutMillis);
    return s;
}",1,,,-1,,[@Override],-1,-1,-1,-1,-1,-1,"1,4",1,"In the early version, the API throws an IOException while in the late version, the API returns a Socket instance. The change includes new statements (like OpenSSLSocketImpl instance creation and method invocation), so the change types are 1 and 4.","The early version always throws an exception, whereas the late version performs a series of operations and returns a different type of object (a Socket instance). This can lead to entirely different behaviours between versions. Therefore, the Compatibility Issue type is 1 (different return values or types)."
224,<android.widget.ListView: int findMotionRow(int)>,7,8,<android.widget.ListView: int findMotionRow(int)>,<android.widget.ListView: int findMotionRow(int)>,0,"{
    int childCount = getChildCount();
    if (childCount > 0) {
        for (int i = 0; i < childCount; i++) {
            View v = getChildAt(i);
            if (y <= v.getBottom()) {
                return mFirstPosition + i;
            }
        }
        return mFirstPosition + childCount - 1;
    }
    return INVALID_POSITION;
}","{
    int childCount = getChildCount();
    if (childCount > 0) {
        if (!mStackFromBottom) {
            for (int i = 0; i < childCount; i++) {
                View v = getChildAt(i);
                if (y <= v.getBottom()) {
                    return mFirstPosition + i;
                }
            }
        } else {
            for (int i = childCount - 1; i >= 0; i--) {
                View v = getChildAt(i);
                if (y >= v.getTop()) {
                    return mFirstPosition + i;
                }
            }
        }
    }
    return INVALID_POSITION;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,3,1,"The control flow is changed in the late version. New 'if' condition is introduced, and the execution of loop varies, including the initial value, iteration way, and conditional check within the loop. Thus the code change type is 3.","The method's behavior in terms of returning a value can potentially change due to the introduction of new conditional check (if !mStackFromBottom) and the change in loop variable's iteration. As the control flow has changed, the returned variable values would possibly change. Thus, a compatibility issue arises due to potential different return values or types, the CI type is 1."
225,<android.webkit.CacheManager: boolean removeAllCacheFiles()>,7,8,<android.webkit.CacheManager: boolean removeAllCacheFiles()>,<android.webkit.CacheManager: boolean removeAllCacheFiles()>,0,"{
    // created or upgraded.
    if (mBaseDir == null) {
        // Init() has not been called yet, so just flag that
        // we need to clear the cache when init() is called.
        mClearCacheOnInit = true;
        return true;
    }
    // delete cache in a separate thread to not block UI.
    final Runnable clearCache = new Runnable() {

        public void run() {
            // delete all cache files
            try {
                String[] files = mBaseDir.list();
                // if mBaseDir doesn't exist, files can be null.
                if (files != null) {
                    for (int i = 0; i < files.length; i++) {
                        File f = new File(mBaseDir, files[i]);
                        if (!f.delete()) {
                            Log.e(LOGTAG, f.getPath() + "" delete failed."");
                        }
                    }
                }
            } catch (SecurityException e) {
            // Ignore SecurityExceptions.
            }
            // delete database
            mDataBase.clearCache();
        }
    };
    new Thread(clearCache).start();
    return true;
}","{
    // created or upgraded.
    if (mBaseDir == null) {
        // Init() has not been called yet, so just flag that
        // we need to clear the cache when init() is called.
        mClearCacheOnInit = true;
        return true;
    }
    // delete rows in the cache database
    WebViewWorker.getHandler().sendEmptyMessage(WebViewWorker.MSG_CLEAR_CACHE);
    // delete cache files in a separate thread to not block UI.
    final Runnable clearCache = new Runnable() {

        public void run() {
            // delete all cache files
            try {
                String[] files = mBaseDir.list();
                // if mBaseDir doesn't exist, files can be null.
                if (files != null) {
                    for (int i = 0; i < files.length; i++) {
                        File f = new File(mBaseDir, files[i]);
                        if (!f.delete()) {
                            Log.e(LOGTAG, f.getPath() + "" delete failed."");
                        }
                    }
                }
            } catch (SecurityException e) {
            // Ignore SecurityExceptions.
            }
        }
    };
    new Thread(clearCache).start();
    return true;
}",1,"// only called from WebCore thread
","/**
 * remove all cache files
 *
 * @return true if it succeeds
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"In the updated implementation, the statement ""WebViewWorker.getHandler().sendEmptyMessage(WebViewWorker.MSG_CLEAR_CACHE);"" has been added to delete rows in the cache database, so the code change type is 4.","Despite the added statement, the method will still return 'true' after all is executed. There's no change in how exceptions are handled either. Therefore no compatibility issue is found, so the CI type is 0."
226,<android.accounts.AccountAuthenticatorResponse: void onResult(Bundle)>,7,8,<android.accounts.AccountAuthenticatorResponse: void onResult(Bundle)>,<android.accounts.AccountAuthenticatorResponse: void onResult(Bundle)>,0,"{
    try {
        mAccountAuthenticatorResponse.onResult(result);
    } catch (RemoteException e) {
    // this should never happen
    }
}","{
    if (Log.isLoggable(TAG, Log.VERBOSE)) {
        // force it to be unparcelled
        result.keySet();
        Log.v(TAG, ""AccountAuthenticatorResponse.onResult: "" + AccountManager.sanitizeResult(result));
    }
    try {
        mAccountAuthenticatorResponse.onResult(result);
    } catch (RemoteException e) {
    // this should never happen
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,4,0,"There is an introduction of logging functionality in the late version which doesn't affect the return values and exception behaviour, thus the change type is just 4.","The added logging component won't affect the behavior of method. Therefore there is no change which could lead to a compatibility issue, thus the CI type is 0."
229,<android.view.View: boolean onTouchEvent(MotionEvent)>,7,8,<android.view.View: boolean onTouchEvent(MotionEvent)>,<android.view.View: boolean onTouchEvent(MotionEvent)>,0,"{
    final int viewFlags = mViewFlags;
    if ((viewFlags & ENABLED_MASK) == DISABLED) {
        // events, it just doesn't respond to them.
        return (((viewFlags & CLICKABLE) == CLICKABLE || (viewFlags & LONG_CLICKABLE) == LONG_CLICKABLE));
    }
    if (mTouchDelegate != null) {
        if (mTouchDelegate.onTouchEvent(event)) {
            return true;
        }
    }
    if (((viewFlags & CLICKABLE) == CLICKABLE || (viewFlags & LONG_CLICKABLE) == LONG_CLICKABLE)) {
        switch(event.getAction()) {
            case MotionEvent.ACTION_UP:
                if ((mPrivateFlags & PRESSED) != 0) {
                    // take focus if we don't have it already and we should in
                    // touch mode.
                    boolean focusTaken = false;
                    if (isFocusable() && isFocusableInTouchMode() && !isFocused()) {
                        focusTaken = requestFocus();
                    }
                    if (!mHasPerformedLongPress) {
                        // This is a tap, so remove the longpress check
                        if (mPendingCheckForLongPress != null) {
                            removeCallbacks(mPendingCheckForLongPress);
                        }
                        // Only perform take click actions if we were in the pressed state
                        if (!focusTaken) {
                            performClick();
                        }
                    }
                    if (mUnsetPressedState == null) {
                        mUnsetPressedState = new UnsetPressedState();
                    }
                    if (!post(mUnsetPressedState)) {
                        // If the post failed, unpress right now
                        mUnsetPressedState.run();
                    }
                }
                break;
            case MotionEvent.ACTION_DOWN:
                mPrivateFlags |= PRESSED;
                refreshDrawableState();
                if ((mViewFlags & LONG_CLICKABLE) == LONG_CLICKABLE) {
                    postCheckForLongClick();
                }
                break;
            case MotionEvent.ACTION_CANCEL:
                mPrivateFlags &= ~PRESSED;
                refreshDrawableState();
                break;
            case MotionEvent.ACTION_MOVE:
                final int x = (int) event.getX();
                final int y = (int) event.getY();
                // Be lenient about moving outside of buttons
                int slop = ViewConfiguration.get(mContext).getScaledTouchSlop();
                if ((x < 0 - slop) || (x >= getWidth() + slop) || (y < 0 - slop) || (y >= getHeight() + slop)) {
                    // Outside button
                    if ((mPrivateFlags & PRESSED) != 0) {
                        // Remove any future long press checks
                        if (mPendingCheckForLongPress != null) {
                            removeCallbacks(mPendingCheckForLongPress);
                        }
                        // Need to switch from pressed to not pressed
                        mPrivateFlags &= ~PRESSED;
                        refreshDrawableState();
                    }
                } else {
                    // Inside button
                    if ((mPrivateFlags & PRESSED) == 0) {
                        // Need to switch from not pressed to pressed
                        mPrivateFlags |= PRESSED;
                        refreshDrawableState();
                    }
                }
                break;
        }
        return true;
    }
    return false;
}","{
    final int viewFlags = mViewFlags;
    if ((viewFlags & ENABLED_MASK) == DISABLED) {
        // events, it just doesn't respond to them.
        return (((viewFlags & CLICKABLE) == CLICKABLE || (viewFlags & LONG_CLICKABLE) == LONG_CLICKABLE));
    }
    if (mTouchDelegate != null) {
        if (mTouchDelegate.onTouchEvent(event)) {
            return true;
        }
    }
    if (((viewFlags & CLICKABLE) == CLICKABLE || (viewFlags & LONG_CLICKABLE) == LONG_CLICKABLE)) {
        switch(event.getAction()) {
            case MotionEvent.ACTION_UP:
                boolean prepressed = (mPrivateFlags & PREPRESSED) != 0;
                if ((mPrivateFlags & PRESSED) != 0 || prepressed) {
                    // take focus if we don't have it already and we should in
                    // touch mode.
                    boolean focusTaken = false;
                    if (isFocusable() && isFocusableInTouchMode() && !isFocused()) {
                        focusTaken = requestFocus();
                    }
                    if (!mHasPerformedLongPress) {
                        // This is a tap, so remove the longpress check
                        removeLongPressCallback();
                        // Only perform take click actions if we were in the pressed state
                        if (!focusTaken) {
                            // of the view update before click actions start.
                            if (mPerformClick == null) {
                                mPerformClick = new PerformClick();
                            }
                            if (!post(mPerformClick)) {
                                performClick();
                            }
                        }
                    }
                    if (mUnsetPressedState == null) {
                        mUnsetPressedState = new UnsetPressedState();
                    }
                    if (prepressed) {
                        mPrivateFlags |= PRESSED;
                        refreshDrawableState();
                        postDelayed(mUnsetPressedState, ViewConfiguration.getPressedStateDuration());
                    } else if (!post(mUnsetPressedState)) {
                        // If the post failed, unpress right now
                        mUnsetPressedState.run();
                    }
                    removeTapCallback();
                }
                break;
            case MotionEvent.ACTION_DOWN:
                if (mPendingCheckForTap == null) {
                    mPendingCheckForTap = new CheckForTap();
                }
                mPrivateFlags |= PREPRESSED;
                mHasPerformedLongPress = false;
                postDelayed(mPendingCheckForTap, ViewConfiguration.getTapTimeout());
                break;
            case MotionEvent.ACTION_CANCEL:
                mPrivateFlags &= ~PRESSED;
                refreshDrawableState();
                removeTapCallback();
                break;
            case MotionEvent.ACTION_MOVE:
                final int x = (int) event.getX();
                final int y = (int) event.getY();
                // Be lenient about moving outside of buttons
                int slop = mTouchSlop;
                if ((x < 0 - slop) || (x >= getWidth() + slop) || (y < 0 - slop) || (y >= getHeight() + slop)) {
                    // Outside button
                    removeTapCallback();
                    if ((mPrivateFlags & PRESSED) != 0) {
                        // Remove any future long press/tap checks
                        removeLongPressCallback();
                        // Need to switch from pressed to not pressed
                        mPrivateFlags &= ~PRESSED;
                        refreshDrawableState();
                    }
                }
                break;
        }
        return true;
    }
    return false;
}",1,"/**
 * Implement this method to handle touch screen motion events.
 *
 * @param event The motion event.
 * @return True if the event was handled, false otherwise.
 */
","/**
 * Implement this method to handle touch screen motion events.
 *
 * @param event The motion event.
 * @return True if the event was handled, false otherwise.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3, 4","1,2","The changes are made in each case under the switch statement, which implies a control dependency change (Type 3). Other minor changes also fall under 'other statement changed' category (Type 4).","The changes inside each case under the switch statement can potentially change the functionality of the onTouchEvent method. This could lead to a change in the return value or a different exception thrown, causing compatibility issues of types 1 and 2."
230,<android.webkit.URLUtil: String parseContentDisposition(String)>,7,8,<android.webkit.URLUtil: String parseContentDisposition(String)>,<android.webkit.URLUtil: String parseContentDisposition(String)>,0,"{
    try {
        Matcher m = CONTENT_DISPOSITION_PATTERN.matcher(contentDisposition);
        if (m.find()) {
            return m.group(1);
        }
    } catch (IllegalStateException ex) {
    // This function is defined as returning null when it can't parse the header
    }
    return null;
}","{
    try {
        Matcher m = CONTENT_DISPOSITION_PATTERN.matcher(contentDisposition);
        if (m.find()) {
            return m.group(2);
        }
    } catch (IllegalStateException ex) {
    // This function is defined as returning null when it can't parse the header
    }
    return null;
}",1,"/*
     * Parse the Content-Disposition HTTP Header. The format of the header
     * is defined here: http://www.w3.org/Protocols/rfc2616/rfc2616-sec19.html
     * This header provides a filename for content that is going to be
     * downloaded to the file system. We only support the attachment type.
     */
","/*
     * Parse the Content-Disposition HTTP Header. The format of the header
     * is defined here: http://www.w3.org/Protocols/rfc2616/rfc2616-sec19.html
     * This header provides a filename for content that is going to be
     * downloaded to the file system. We only support the attachment type.
     * Note that RFC 2616 specifies the filename value must be double-quoted.
     * Unfortunately some servers do not quote the value so to maintain
     * consistent behaviour with other browsers, we allow unquoted values too.
     */
",-1,,,-1,-1,-1,-1,-1,-1,1,1,"The return statement of the 'if' condition has changed from return m.group(1) to return m.group(2), so the code change type is 1.","Because of the change in the return statement, the method may now return different values in comparison to the previous version (from m.group(1) to m.group(2)), thereby causing a potential compatibility issue. Therefore, the CI type is 1."
231,"<android.webkit.FrameLoader: boolean handleLocalFile(String,LoadListener,WebSettings)>",7,8,"<android.webkit.FrameLoader: boolean handleLocalFile(String,LoadListener,WebSettings)>","<android.webkit.FrameLoader: boolean handleLocalFile(String,LoadListener,WebSettings)>",0,"{
    // local loaders.
    try {
        url = new String(URLUtil.decode(url.getBytes()));
    } catch (IllegalArgumentException e) {
        loadListener.error(EventHandler.ERROR_BAD_URL, loadListener.getContext().getString(com.android.internal.R.string.httpErrorBadUrl));
        // error.
        return true;
    }
    if (URLUtil.isAssetUrl(url)) {
        FileLoader.requestUrl(url, loadListener, loadListener.getContext(), true, settings.getAllowFileAccess());
        return true;
    } else if (URLUtil.isFileUrl(url)) {
        FileLoader.requestUrl(url, loadListener, loadListener.getContext(), false, settings.getAllowFileAccess());
        return true;
    } else if (URLUtil.isContentUrl(url)) {
        // Send the raw url to the ContentLoader because it will do a
        // permission check and the url has to match..
        ContentLoader.requestUrl(loadListener.url(), loadListener, loadListener.getContext());
        return true;
    } else if (URLUtil.isDataUrl(url)) {
        DataLoader.requestUrl(url, loadListener);
        return true;
    } else if (URLUtil.isAboutUrl(url)) {
        loadListener.data(mAboutBlank.getBytes(), mAboutBlank.length());
        loadListener.endData();
        return true;
    }
    return false;
}","{
    // local loaders.
    try {
        url = new String(URLUtil.decode(url.getBytes()));
    } catch (IllegalArgumentException e) {
        loadListener.error(EventHandler.ERROR_BAD_URL, loadListener.getContext().getString(com.android.internal.R.string.httpErrorBadUrl));
        // error.
        return true;
    }
    if (URLUtil.isAssetUrl(url)) {
        if (loadListener.isSynchronous()) {
            new FileLoader(url, loadListener, FileLoader.TYPE_ASSET, true).load();
        } else {
            // load asset in a separate thread as it involves IO
            WebViewWorker.getHandler().obtainMessage(WebViewWorker.MSG_ADD_STREAMLOADER, new FileLoader(url, loadListener, FileLoader.TYPE_ASSET, true)).sendToTarget();
        }
        return true;
    } else if (URLUtil.isResourceUrl(url)) {
        if (loadListener.isSynchronous()) {
            new FileLoader(url, loadListener, FileLoader.TYPE_RES, true).load();
        } else {
            // load resource in a separate thread as it involves IO
            WebViewWorker.getHandler().obtainMessage(WebViewWorker.MSG_ADD_STREAMLOADER, new FileLoader(url, loadListener, FileLoader.TYPE_RES, true)).sendToTarget();
        }
        return true;
    } else if (URLUtil.isFileUrl(url)) {
        if (loadListener.isSynchronous()) {
            new FileLoader(url, loadListener, FileLoader.TYPE_FILE, settings.getAllowFileAccess()).load();
        } else {
            // load file in a separate thread as it involves IO
            WebViewWorker.getHandler().obtainMessage(WebViewWorker.MSG_ADD_STREAMLOADER, new FileLoader(url, loadListener, FileLoader.TYPE_FILE, settings.getAllowFileAccess())).sendToTarget();
        }
        return true;
    } else if (URLUtil.isContentUrl(url)) {
        // permission check and the url has to match.
        if (loadListener.isSynchronous()) {
            new ContentLoader(loadListener.url(), loadListener).load();
        } else {
            // load content in a separate thread as it involves IO
            WebViewWorker.getHandler().obtainMessage(WebViewWorker.MSG_ADD_STREAMLOADER, new ContentLoader(loadListener.url(), loadListener)).sendToTarget();
        }
        return true;
    } else if (URLUtil.isDataUrl(url)) {
        // load data in the current thread to reduce the latency
        new DataLoader(url, loadListener).load();
        return true;
    } else if (URLUtil.isAboutUrl(url)) {
        loadListener.data(mAboutBlank.getBytes(), mAboutBlank.length());
        loadListener.endData();
        return true;
    }
    return false;
}",1,"/* package */
","/* package */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3,4",1,"The changes include modifications to return statements, conditional statements and other statements that are not related to control dependency or exception handling. ""FileLoader.requestUrl"" method is replaced with ""new FileLoader().load()"" and the similar replacement also exists for other URL check conditions. Also the methods being called and the arguments they take are different. Thus, this is categorized as changes 1,3 and 4.","The changes in return statements, which involve different methods being called and the arguments they take, will likely cause the API to behave differently. Specifically, the return values of these methods could be different given their different implementations, so this fulfills the criteria for compatibility issue of type 1."
232,<android.webkit.WebView.InvokeListBox.MyArrayListAdapter: boolean isEnabled(int)>,7,8,<android.webkit.WebView.InvokeListBox.MyArrayListAdapter: boolean isEnabled(int)>,<android.webkit.WebView.InvokeListBox.MyArrayListAdapter: boolean isEnabled(int)>,0,"{
    Container item = item(position);
    if (item == null) {
        return false;
    }
    return item.mEnabled;
}","{
    Container item = item(position);
    if (item == null) {
        return false;
    }
    return Container.OPTION_ENABLED == item.mEnabled;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,1,1,"The return statement has changed from ""return item.mEnabled"" to ""return Container.OPTION_ENABLED == item.mEnabled"", so the code change type is 1.","Since the return statement has changed, the API could potentially return a different value, so the CI type is 1."
235,<android.pim.vcard.VCardParser_V21: void handleAgent(String)>,7,8,<android.pim.vcard.VCardParser_V21: void handleAgent(String)>,<android.pim.vcard.VCardParser_V21: void handleAgent(String)>,0,"{
    throw new VCardNotSupportedException(""AGENT Property is not supported now."");
/* This is insufficient support. Also, AGENT Property is very rare.
           Ignore it for now.

        String[] strArray = propertyValue.split("":"", 2);
        if (!(strArray.length == 2 ||
                strArray[0].trim().equalsIgnoreCase(""BEGIN"") && 
                strArray[1].trim().equalsIgnoreCase(""VCARD""))) {
            throw new VCardException(""BEGIN:VCARD != \"""" + propertyValue + ""\"""");
        }
        parseItems();
        readEndVCard();
        */
}","{
    if (!propertyValue.toUpperCase().contains(""BEGIN:VCARD"")) {
        // Apparently invalid line seen in Windows Mobile 6.5. Ignore them.
        return;
    } else {
        throw new VCardAgentNotSupportedException(""AGENT Property is not supported now."");
    }
// TODO: Support AGENT property.
}",1,"/**
 * vCard 2.1 specifies AGENT allows one vcard entry. It is not encoded at all.
 *
 * item     = ...
 * / [groups "".""] ""AGENT""
 * [params] "":"" vcard CRLF
 * vcard    = ""BEGIN"" [ws] "":"" [ws] ""VCARD"" [ws] 1*CRLF
 * items *CRLF ""END"" [ws] "":"" [ws] ""VCARD""
 */
","/**
 * vCard 2.1 specifies AGENT allows one vcard entry. It is not encoded at all.
 *
 * item  = ...
 * / [groups "".""] ""AGENT""
 * [params] "":"" vcard CRLF
 * vcard = ""BEGIN"" [ws] "":"" [ws] ""VCARD"" [ws] 1*CRLF
 * items *CRLF ""END"" [ws] "":"" [ws] ""VCARD""
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,2,3","1,2","The early version of the API only contains an exception handling statement, while the late version introduces some condition checking and return statement. Thus, the API change type includes 1 (return statement changed), 2 (exception handling statement changed), and 3 (control dependency changed).","The return statement and the exception handling statement were changed in this API. The early API version throws an exception (""AGENT Property is not supported now""), while the late API version might return nothing if the condition is not met. Therefore, the CI type includes both 1 (Compatibility Issue caused by potential different return values or types) and 2 (Compatibility Issue caused by potential different exception handlings)."
236,"<android.accounts.AbstractAccountAuthenticator.Transport: void confirmCredentials(IAccountAuthenticatorResponse,Account,Bundle)>",7,8,"<android.accounts.AbstractAccountAuthenticator.Transport: void confirmCredentials(IAccountAuthenticatorResponse,Account,Bundle)>","<android.accounts.AbstractAccountAuthenticator.Transport: void confirmCredentials(IAccountAuthenticatorResponse,Account,Bundle)>",0,"{
    checkBinderPermission();
    try {
        final Bundle result = AbstractAccountAuthenticator.this.confirmCredentials(new AccountAuthenticatorResponse(response), account, options);
        if (result != null) {
            response.onResult(result);
        }
    } catch (NetworkErrorException e) {
        response.onError(AccountManager.ERROR_CODE_NETWORK_ERROR, e.getMessage());
    } catch (UnsupportedOperationException e) {
        response.onError(AccountManager.ERROR_CODE_UNSUPPORTED_OPERATION, ""confirmCredentials not supported"");
    }
}","{
    if (Log.isLoggable(TAG, Log.VERBOSE)) {
        Log.v(TAG, ""confirmCredentials: "" + account);
    }
    checkBinderPermission();
    try {
        final Bundle result = AbstractAccountAuthenticator.this.confirmCredentials(new AccountAuthenticatorResponse(response), account, options);
        if (Log.isLoggable(TAG, Log.VERBOSE)) {
            // force it to be unparcelled
            result.keySet();
            Log.v(TAG, ""confirmCredentials: result "" + AccountManager.sanitizeResult(result));
        }
        if (result != null) {
            response.onResult(result);
        }
    } catch (NetworkErrorException e) {
        if (Log.isLoggable(TAG, Log.VERBOSE)) {
            Log.v(TAG, ""confirmCredentials"", e);
        }
        response.onError(AccountManager.ERROR_CODE_NETWORK_ERROR, e.getMessage());
    } catch (UnsupportedOperationException e) {
        if (Log.isLoggable(TAG, Log.VERBOSE)) {
            Log.v(TAG, ""confirmCredentials"", e);
        }
        response.onError(AccountManager.ERROR_CODE_UNSUPPORTED_OPERATION, ""confirmCredentials not supported"");
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"3,4",0,"Logging statements were inserted at the beginning of the late implementation and under the conditions to catch 'NetworkErrorException' and 'UnsupportedOperationException' exceptions. This change falls under the 'control dependency changed' category because the new statements are enclosed in a conditional check for the verbose logging level. Also, it could be considered as 'other statement changed' category as those loggings are not about return, exception handling, control dependency and dependent API changing.","Despite the code change, the observable behaviour of the API remains consistent between the two versions. The new logging statements do not influence the return values or the exceptions thrown, hence no compatibility issues."
237,"<android.accounts.AccountManager: AccountManagerFuture<Boolean> removeAccount(Account,AccountManagerCallback<Boolean>,Handler)>",7,8,"<android.accounts.AccountManager: AccountManagerFuture<Boolean> removeAccount(Account,AccountManagerCallback<Boolean>,Handler)>","<android.accounts.AccountManager: AccountManagerFuture<Boolean> removeAccount(Account,AccountManagerCallback<Boolean>,Handler)>",0,"{
    return new Future2Task<Boolean>(handler, callback) {

        public void doWork() throws RemoteException {
            mService.removeAccount(mResponse, account);
        }

        public Boolean bundleToResult(Bundle bundle) throws AuthenticatorException {
            if (!bundle.containsKey(KEY_BOOLEAN_RESULT)) {
                throw new AuthenticatorException(""no result in response"");
            }
            return bundle.getBoolean(KEY_BOOLEAN_RESULT);
        }
    }.start();
}","{
    if (account == null)
        throw new IllegalArgumentException(""account is null"");
    return new Future2Task<Boolean>(handler, callback) {

        public void doWork() throws RemoteException {
            mService.removeAccount(mResponse, account);
        }

        public Boolean bundleToResult(Bundle bundle) throws AuthenticatorException {
            if (!bundle.containsKey(KEY_BOOLEAN_RESULT)) {
                throw new AuthenticatorException(""no result in response"");
            }
            return bundle.getBoolean(KEY_BOOLEAN_RESULT);
        }
    }.start();
}",1,"/**
 * Removes the given account. If this account does not exist then this call has no effect.
 * <p>
 * This call returns immediately but runs asynchronously and the result is accessed via the
 * {@link AccountManagerFuture} that is returned. This future is also passed as the sole
 * parameter to the {@link AccountManagerCallback}. If the caller wished to use this
 * method asynchronously then they will generally pass in a callback object that will get
 * invoked with the {@link AccountManagerFuture}. If they wish to use it synchronously then
 * they will generally pass null for the callback and instead call
 * {@link android.accounts.AccountManagerFuture#getResult()} on this method's return value,
 * which will then block until the request completes.
 * <p>
 * Requires that the caller has permission {@link android.Manifest.permission#MANAGE_ACCOUNTS}.
 *
 * @param account The {@link Account} to remove
 * @param callback A callback to invoke when the request completes. If null then
 * no callback is invoked.
 * @param handler The {@link Handler} to use to invoke the callback. If null then the
 * main thread's {@link Handler} is used.
 * @return an {@link AccountManagerFuture} that represents the future result of the call.
 * The future result is a {@link Boolean} that is true if the account is successfully removed
 * or false if the authenticator refuses to remove the account.
 */
","/**
 * Removes an account from the AccountManager.  Does nothing if the account
 * does not exist.  Does not delete the account from the server.
 * The authenticator may have its own policies preventing account
 * deletion, in which case the account will not be deleted.
 *
 * <p>This method may be called from any thread, but the returned
 * {@link AccountManagerFuture} must not be used on the main thread.
 *
 * <p>This method requires the caller to hold the permission
 * {@link android.Manifest.permission#MANAGE_ACCOUNTS}.
 *
 * @param account The {@link Account} to remove
 * @param callback Callback to invoke when the request completes,
 * null for no callback
 * @param handler {@link Handler} identifying the callback thread,
 * null for the main thread
 * @return An {@link AccountManagerFuture} which resolves to a Boolean,
 * true if the account has been successfully removed,
 * false if the authenticator forbids deleting this account.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,3",2,"An exception throw statement has been added if the account parameter is null. In addition, the control flow of the program has also changed due to the newly added 'if' condition. Therefore, the code change type is 2,3.","The new statement possibly throws a IllegalArgumentException depending on the input parameter, which essentially means that the new version of the API potentially throws a new exception compared to the older version. Therefore, there's a Compatibility Issue of type 2."
239,<android.preference.PreferenceGroupAdapter: int getItemViewType(int)>,7,8,<android.preference.PreferenceGroupAdapter: int getItemViewType(int)>,<android.preference.PreferenceGroupAdapter: int getItemViewType(int)>,0,"{
    if (!mHasReturnedViewTypeCount) {
        mHasReturnedViewTypeCount = true;
    }
    final Preference preference = this.getItem(position);
    if (preference.hasSpecifiedLayout()) {
        return IGNORE_ITEM_VIEW_TYPE;
    }
    final String name = preference.getClass().getName();
    int viewType = Collections.binarySearch(mPreferenceClassNames, name);
    if (viewType < 0) {
        // don't recycle it.
        return IGNORE_ITEM_VIEW_TYPE;
    } else {
        return viewType;
    }
}","{
    if (!mHasReturnedViewTypeCount) {
        mHasReturnedViewTypeCount = true;
    }
    final Preference preference = this.getItem(position);
    if (preference.hasSpecifiedLayout()) {
        return IGNORE_ITEM_VIEW_TYPE;
    }
    mTempPreferenceLayout = createPreferenceLayout(preference, mTempPreferenceLayout);
    int viewType = Collections.binarySearch(mPreferenceLayouts, mTempPreferenceLayout);
    if (viewType < 0) {
        // don't recycle it.
        return IGNORE_ITEM_VIEW_TYPE;
    } else {
        return viewType;
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,4",1,"Return statements have changed in the code, and a new statement (mTempPreferenceLayout = createPreferenceLayout(preference, mTempPreferenceLayout)) is introduced in the late version. Therefore, the code change can be categorised as 1,4.","The changes in the return statements, and the introduction of a new statement which affects the 'viewType' variable, make the API potentially return a different value. Hence, the CI is of type 1 caused by the potential differences in return values."
240,<android.widget.FastScroller: boolean onTouchEvent(MotionEvent)>,7,8,<android.widget.FastScroller: boolean onTouchEvent(MotionEvent)>,<android.widget.FastScroller: boolean onTouchEvent(MotionEvent)>,0,"{
    if (mState == STATE_NONE) {
        return false;
    }
    final int action = me.getAction();
    if (action == MotionEvent.ACTION_DOWN) {
        if (isPointInside(me.getX(), me.getY())) {
            setState(STATE_DRAGGING);
            if (mListAdapter == null && mList != null) {
                getSectionsFromIndexer();
            }
            cancelFling();
            return true;
        }
    } else if (action == MotionEvent.ACTION_UP) {
        if (mState == STATE_DRAGGING) {
            setState(STATE_VISIBLE);
            final Handler handler = mHandler;
            handler.removeCallbacks(mScrollFade);
            handler.postDelayed(mScrollFade, 1000);
            return true;
        }
    } else if (action == MotionEvent.ACTION_MOVE) {
        if (mState == STATE_DRAGGING) {
            final int viewHeight = mList.getHeight();
            // Jitter
            int newThumbY = (int) me.getY() - mThumbH + 10;
            if (newThumbY < 0) {
                newThumbY = 0;
            } else if (newThumbY + mThumbH > viewHeight) {
                newThumbY = viewHeight - mThumbH;
            }
            if (Math.abs(mThumbY - newThumbY) < 2) {
                return true;
            }
            mThumbY = newThumbY;
            // If the previous scrollTo is still pending
            if (mScrollCompleted) {
                scrollTo((float) mThumbY / (viewHeight - mThumbH));
            }
            return true;
        }
    }
    return false;
}","{
    if (mState == STATE_NONE) {
        return false;
    }
    final int action = me.getAction();
    if (action == MotionEvent.ACTION_DOWN) {
        if (isPointInside(me.getX(), me.getY())) {
            setState(STATE_DRAGGING);
            if (mListAdapter == null && mList != null) {
                getSectionsFromIndexer();
            }
            if (mList != null) {
                mList.requestDisallowInterceptTouchEvent(true);
                mList.reportScrollStateChange(OnScrollListener.SCROLL_STATE_TOUCH_SCROLL);
            }
            cancelFling();
            return true;
        }
    } else if (action == MotionEvent.ACTION_UP) {
        // don't add ACTION_CANCEL here
        if (mState == STATE_DRAGGING) {
            if (mList != null) {
                // ViewGroup does the right thing already, but there might
                // be other classes that don't properly reset on touch-up,
                // so do this explicitly just in case.
                mList.requestDisallowInterceptTouchEvent(false);
                mList.reportScrollStateChange(OnScrollListener.SCROLL_STATE_IDLE);
            }
            setState(STATE_VISIBLE);
            final Handler handler = mHandler;
            handler.removeCallbacks(mScrollFade);
            handler.postDelayed(mScrollFade, 1000);
            return true;
        }
    } else if (action == MotionEvent.ACTION_MOVE) {
        if (mState == STATE_DRAGGING) {
            final int viewHeight = mList.getHeight();
            // Jitter
            int newThumbY = (int) me.getY() - mThumbH + 10;
            if (newThumbY < 0) {
                newThumbY = 0;
            } else if (newThumbY + mThumbH > viewHeight) {
                newThumbY = viewHeight - mThumbH;
            }
            if (Math.abs(mThumbY - newThumbY) < 2) {
                return true;
            }
            mThumbY = newThumbY;
            // If the previous scrollTo is still pending
            if (mScrollCompleted) {
                scrollTo((float) mThumbY / (viewHeight - mThumbH));
            }
            return true;
        }
    }
    return false;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,4,0,The late implementation has introduced additional method calls to `mList.requestDisallowInterceptTouchEvent()` and `mList.reportScrollStateChange()` within the 'if' branches corresponding to `MotionEvent.ACTION_DOWN` and `MotionEvent.ACTION_UP` actions. This falls under the category 4: Other statement change.,"Although there's a change in the implementation, it does not lead to a compatibility issue. The returned values and exceptions thrown in the early and late versions are the same under all conditions. Thus, the type of CI is 0: No Compatibility Issue exist."
242,"<android.webkit.Network: boolean requestURL(String,Map<String, String>,byte[],LoadListener)>",7,8,"<android.webkit.Network: boolean requestURL(String,Map<String, String>,byte[],LoadListener)>","<android.webkit.Network: boolean requestURL(String,Map<String, String>,byte[],LoadListener)>",0,"{
    String url = loader.url();
    // Not a valid url, return false because we won't service the request!
    if (!URLUtil.isValidUrl(url)) {
        return false;
    }
    // This only handles network request.
    if (URLUtil.isAssetUrl(url) || URLUtil.isFileUrl(url) || URLUtil.isDataUrl(url)) {
        return false;
    }
    /* FIXME: this is lame.  Pass an InputStream in, rather than
           making this lame one here */
    InputStream bodyProvider = null;
    int bodyLength = 0;
    if (postData != null) {
        bodyLength = postData.length;
        bodyProvider = new ByteArrayInputStream(postData);
    }
    RequestQueue q = mRequestQueue;
    if (loader.isSynchronous()) {
        q = new RequestQueue(loader.getContext(), 1);
    }
    RequestHandle handle = q.queueRequest(url, loader.getWebAddress(), method, headers, loader, bodyProvider, bodyLength);
    loader.attachRequestHandle(handle);
    if (loader.isSynchronous()) {
        handle.waitUntilComplete();
        loader.loadSynchronousMessages();
        q.shutdown();
    }
    return true;
}","{
    String url = loader.url();
    // Not a valid url, return false because we won't service the request!
    if (!URLUtil.isValidUrl(url)) {
        return false;
    }
    // path. This only handles network request.
    if (URLUtil.isAssetUrl(url) || URLUtil.isResourceUrl(url) || URLUtil.isFileUrl(url) || URLUtil.isDataUrl(url)) {
        return false;
    }
    /* FIXME: this is lame.  Pass an InputStream in, rather than
           making this lame one here */
    InputStream bodyProvider = null;
    int bodyLength = 0;
    if (postData != null) {
        bodyLength = postData.length;
        bodyProvider = new ByteArrayInputStream(postData);
    }
    RequestQueue q = mRequestQueue;
    RequestHandle handle = null;
    if (loader.isSynchronous()) {
        handle = q.queueSynchronousRequest(url, loader.getWebAddress(), method, headers, loader, bodyProvider, bodyLength);
        loader.attachRequestHandle(handle);
        handle.processRequest();
        loader.loadSynchronousMessages();
    } else {
        handle = q.queueRequest(url, loader.getWebAddress(), method, headers, loader, bodyProvider, bodyLength);
        // FIXME: Although this is probably a rare condition, normal network
        // requests are processed in a separate thread. This means that it
        // is possible to process part of the request before setting the
        // request handle on the loader. We should probably refactor this to
        // ensure the handle is attached before processing begins.
        loader.attachRequestHandle(handle);
    }
    return true;
}",1,"/**
 * Request a url from either the network or the file system.
 * @param url The url to load.
 * @param method The http method.
 * @param headers The http headers.
 * @param postData The body of the request.
 * @param loader A LoadListener for receiving the results of the request.
 * @return True if the request was successfully queued.
 */
","/**
 * Request a url from either the network or the file system.
 * @param url The url to load.
 * @param method The http method.
 * @param headers The http headers.
 * @param postData The body of the request.
 * @param loader A LoadListener for receiving the results of the request.
 * @return True if the request was successfully queued.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3,5",1,"The second condition statement in the 'if' clause and the calling method within 'if (loader.isSynchronous())' block have been changed. Additionally, the API it depended 'queueSynchronousRequest' and 'processRequest' is new. Hence, the code change type is set as 1,3,5.","Due to the change in the method handling condition and the dependent API, a different return value could potentially be produced, resulting in the CI of type 1."
244,"<android.webkit.WebTextView: void onSelectionChanged(int,int)>",7,8,"<android.webkit.WebTextView: void onSelectionChanged(int,int)>","<android.webkit.WebTextView: void onSelectionChanged(int,int)>",0,"{
    // This code is copied from TextView.onDraw().  That code does not get
    // executed, however, because the WebTextView does not draw, allowing
    // webkit's drawing to show through.
    InputMethodManager imm = InputMethodManager.peekInstance();
    if (imm != null && imm.isActive(this)) {
        Spannable sp = (Spannable) getText();
        int candStart = EditableInputConnection.getComposingSpanStart(sp);
        int candEnd = EditableInputConnection.getComposingSpanEnd(sp);
        imm.updateSelection(this, selStart, selEnd, candStart, candEnd);
    }
    if (!mFromWebKit && mWebView != null) {
        if (DebugFlags.WEB_TEXT_VIEW) {
            Log.v(LOGTAG, ""onSelectionChanged selStart="" + selStart + "" selEnd="" + selEnd);
        }
        mWebView.setSelection(selStart, selEnd);
    }
}","{
    if (mInSetTextAndKeepSelection)
        return;
    // This code is copied from TextView.onDraw().  That code does not get
    // executed, however, because the WebTextView does not draw, allowing
    // webkit's drawing to show through.
    InputMethodManager imm = InputMethodManager.peekInstance();
    if (imm != null && imm.isActive(this)) {
        Spannable sp = (Spannable) getText();
        int candStart = EditableInputConnection.getComposingSpanStart(sp);
        int candEnd = EditableInputConnection.getComposingSpanEnd(sp);
        imm.updateSelection(this, selStart, selEnd, candStart, candEnd);
    }
    if (!mFromWebKit && !mFromFocusChange && !mFromSetInputType && mWebView != null) {
        if (DebugFlags.WEB_TEXT_VIEW) {
            Log.v(LOGTAG, ""onSelectionChanged selStart="" + selStart + "" selEnd="" + selEnd);
        }
        mWebView.setSelection(selStart, selEnd);
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,3",1,"A new return statement is introduced in the late version which introduces a new branch in code execution, so the change type is 1 and 3.","Considering that the new return can avoid the rest of the code which can lead to a change in behavior of the API, i.e., the API could potentially return at a different point and avoid the remaining execution. Thus, it leads to a compatibility issue of type 1 (Return statement changed)."
245,<android.content.ContentValues: Short getAsShort(String)>,7,8,<android.content.ContentValues: Short getAsShort(String)>,<android.content.ContentValues: Short getAsShort(String)>,0,"{
    Object value = mValues.get(key);
    try {
        return value != null ? ((Number) value).shortValue() : null;
    } catch (ClassCastException e) {
        if (value instanceof CharSequence) {
            try {
                return Short.valueOf(value.toString());
            } catch (NumberFormatException e2) {
                Log.e(TAG, ""Cannot parse Short value for "" + value + "" at key "" + key);
                return null;
            }
        } else {
            Log.e(TAG, ""Cannot cast value for "" + key + "" to a Short"");
            return null;
        }
    }
}","{
    Object value = mValues.get(key);
    try {
        return value != null ? ((Number) value).shortValue() : null;
    } catch (ClassCastException e) {
        if (value instanceof CharSequence) {
            try {
                return Short.valueOf(value.toString());
            } catch (NumberFormatException e2) {
                Log.e(TAG, ""Cannot parse Short value for "" + value + "" at key "" + key);
                return null;
            }
        } else {
            Log.e(TAG, ""Cannot cast value for "" + key + "" to a Short: "" + value, e);
            return null;
        }
    }
}",1,"/**
 * Gets a value and converts it to a Short.
 *
 * @param key the value to get
 * @return the Short value, or null if the value is missing or cannot be converted
 */
","/**
 * Gets a value and converts it to a Short.
 *
 * @param key the value to get
 * @return the Short value, or null if the value is missing or cannot be converted
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The change is in the log print statement ""Log.e(TAG, ""Cannot cast value for "" + key + "" to a Short"");"" where the exception ""e"" is added in the new version. So, the code change type is 4.","The changes made are about a log statement, not reflecting any difference in how the API functions or its results. Therefore, no compatibility issue exists, so the CI type is 0."
247,<android.database.sqlite.SQLiteDatabase: long getPageSize()>,7,8,<android.database.sqlite.SQLiteDatabase: long getPageSize()>,<android.database.sqlite.SQLiteDatabase: long getPageSize()>,0,"{
    SQLiteStatement prog = null;
    lock();
    try {
        prog = new SQLiteStatement(this, ""PRAGMA page_size;"");
        long size = prog.simpleQueryForLong();
        return size;
    } finally {
        if (prog != null)
            prog.close();
        unlock();
    }
}","{
    SQLiteStatement prog = null;
    lock();
    if (!isOpen()) {
        throw new IllegalStateException(""database not open"");
    }
    try {
        prog = new SQLiteStatement(this, ""PRAGMA page_size;"");
        long size = prog.simpleQueryForLong();
        return size;
    } finally {
        if (prog != null)
            prog.close();
        unlock();
    }
}",1,"/**
 * Returns the current database page size, in bytes.
 *
 * @return the database page size, in bytes
 */
","/**
 * Returns the current database page size, in bytes.
 *
 * @return the database page size, in bytes
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,3",2,"The method has added an 'if' statement to check whether the database is open and throws an exception if it is not, so the change type is 2,3.","The additional 'if' statement might potentially cause a new IllegalStateException to be thrown when the database is not open. This behaviour was not in the earlier version, therefore the CI type is 2."
248,<android.webkit.WebViewDatabase: long getCacheTotalSize()>,7,8,<android.webkit.WebViewDatabase: long getCacheTotalSize()>,<android.webkit.WebViewDatabase: long getCacheTotalSize()>,0,"{
    long size = 0;
    Cursor cursor = mCacheDatabase.rawQuery(""SELECT SUM(contentlength) as sum FROM cache"", null);
    if (cursor.moveToFirst()) {
        size = cursor.getLong(0);
    }
    cursor.close();
    return size;
}","{
    long size = 0;
    Cursor cursor = null;
    final String query = ""SELECT SUM(contentlength) as sum FROM cache"";
    try {
        cursor = mCacheDatabase.rawQuery(query, null);
        if (cursor.moveToFirst()) {
            size = cursor.getLong(0);
        }
    } catch (IllegalStateException e) {
        Log.e(LOGTAG, ""getCacheTotalSize"", e);
    } finally {
        if (cursor != null)
            cursor.close();
    }
    return size;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"2,3","1,2","In the late version, the method query()'s execution is within a 'try' block and a new exception handling statement 'catch (IllegalStateException e)' is introduced. Thus, the change types are 2 and 3.","The 'catch (IllegalStateException e)' does not throw any exception but just logs the error, which is not the same as the early version. Plus, if the IllegalStateException is thrown, the method won't go through the rest codes and will return current 'size'. Therefore, CI type is 1 and 2."
249,<android.pim.vcard.VCardConfig: boolean needsToConvertPhoneticString(int)>,7,8,<android.pim.vcard.VCardConfig: boolean needsToConvertPhoneticString(int)>,<android.pim.vcard.VCardConfig: boolean needsToConvertPhoneticString(int)>,0,"{
    return (vcardType == VCARD_TYPE_DOCOMO);
}","{
    return ((vcardType & FLAG_CONVERT_PHONETIC_NAME_STRINGS) != 0);
}",1,"/**
 * @return true when Japanese phonetic string must be converted to a string
 * containing only half-width katakana. This method exists since Japanese mobile
 * phones usually use only half-width katakana for expressing phonetic names and
 * some devices are not ready for parsing other phonetic strings like hiragana and
 * full-width katakana.
 */
",,-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The return statement has changed from (vcardType == VCARD_TYPE_DOCOMO) to ((vcardType & FLAG_CONVERT_PHONETIC_NAME_STRINGS) != 0) and also, the condition inside the return statement has been replaced, so the code change type is 1,5.","The change of return statement will make the API potentially return a different value, so the CI type is 1."
250,<android.widget.TabWidget: void addView(View)>,7,8,<android.widget.TabWidget: void addView(View)>,<android.widget.TabWidget: void addView(View)>,0,"{
    if (child.getLayoutParams() == null) {
        final LinearLayout.LayoutParams lp = new LayoutParams(0, ViewGroup.LayoutParams.FILL_PARENT, 1.0f);
        lp.setMargins(0, 0, 0, 0);
        child.setLayoutParams(lp);
    }
    // Ensure you can navigate to the tab with the keyboard, and you can touch it
    child.setFocusable(true);
    child.setClickable(true);
    // tab, then add a divider before adding the next tab.
    if (mDividerDrawable != null && getTabCount() > 0) {
        ImageView divider = new ImageView(mContext);
        final LinearLayout.LayoutParams lp = new LayoutParams(mDividerDrawable.getIntrinsicWidth(), LayoutParams.FILL_PARENT);
        lp.setMargins(0, 0, 0, 0);
        divider.setLayoutParams(lp);
        divider.setBackgroundDrawable(mDividerDrawable);
        super.addView(divider);
    }
    super.addView(child);
    // TODO: detect this via geometry with a tabwidget listener rather
    // than potentially interfere with the view's listener
    child.setOnClickListener(new TabClickListener(getTabCount() - 1));
    child.setOnFocusChangeListener(this);
}","{
    if (child.getLayoutParams() == null) {
        final LinearLayout.LayoutParams lp = new LayoutParams(0, ViewGroup.LayoutParams.MATCH_PARENT, 1.0f);
        lp.setMargins(0, 0, 0, 0);
        child.setLayoutParams(lp);
    }
    // Ensure you can navigate to the tab with the keyboard, and you can touch it
    child.setFocusable(true);
    child.setClickable(true);
    // tab, then add a divider before adding the next tab.
    if (mDividerDrawable != null && getTabCount() > 0) {
        ImageView divider = new ImageView(mContext);
        final LinearLayout.LayoutParams lp = new LayoutParams(mDividerDrawable.getIntrinsicWidth(), LayoutParams.MATCH_PARENT);
        lp.setMargins(0, 0, 0, 0);
        divider.setLayoutParams(lp);
        divider.setBackgroundDrawable(mDividerDrawable);
        super.addView(divider);
    }
    super.addView(child);
    // TODO: detect this via geometry with a tabwidget listener rather
    // than potentially interfere with the view's listener
    child.setOnClickListener(new TabClickListener(getTabCount() - 1));
    child.setOnFocusChangeListener(this);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"The function argument within a method call in the API implementation has been changed. The second argument to the 'LayoutParams' constructor changes from ViewGroup.LayoutParams.FILL_PARENT to ViewGroup.LayoutParams.MATCH_PARENT. Thus, the change is classified as type 4 (Other statement changed).","Although the argument passed to the 'LayoutParams' constructor is modified, it doesn't directly alter the behaviour of the 'addView' method in a way that would affect the return value or thrown exceptions. Thus, there is no Compatibility Issue (class 0)."
254,<android.database.sqlite.SQLiteStatement: long simpleQueryForLong()>,7,8,<android.database.sqlite.SQLiteStatement: long simpleQueryForLong()>,<android.database.sqlite.SQLiteStatement: long simpleQueryForLong()>,0,"{
    mDatabase.lock();
    boolean logStats = mDatabase.mLogStats;
    long startTime = logStats ? SystemClock.elapsedRealtime() : 0;
    acquireReference();
    try {
        if (SQLiteDebug.DEBUG_SQL_STATEMENTS) {
            Log.v(TAG, ""simpleQueryForLong() for ["" + mSql + ""]"");
        }
        long retValue = native_1x1_long();
        if (logStats) {
            mDatabase.logTimeStat(false, /* write */
            startTime, SystemClock.elapsedRealtime());
        }
        return retValue;
    } finally {
        releaseReference();
        mDatabase.unlock();
    }
}","{
    if (!mDatabase.isOpen()) {
        throw new IllegalStateException(""database "" + mDatabase.getPath() + "" already closed"");
    }
    long timeStart = SystemClock.uptimeMillis();
    mDatabase.lock();
    acquireReference();
    try {
        long retValue = native_1x1_long();
        mDatabase.logTimeStat(mSql, timeStart);
        return retValue;
    } finally {
        releaseReference();
        mDatabase.unlock();
    }
}",1,"/**
 * Execute a statement that returns a 1 by 1 table with a numeric value.
 * For example, SELECT COUNT(*) FROM table;
 *
 * @return The result of the query.
 *
 * @throws android.database.sqlite.SQLiteDoneException if the query returns zero rows
 */
","/**
 * Execute a statement that returns a 1 by 1 table with a numeric value.
 * For example, SELECT COUNT(*) FROM table;
 *
 * @return The result of the query.
 *
 * @throws android.database.sqlite.SQLiteDoneException if the query returns zero rows
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3,4","1,2","The return statement and the exception handling statement stay the same between the two versions. But the control statements and other typical statements (logStats, startTime, logTimeStat(false, startTime, SystemClock.elapsedRealtime())) have changed. Moreover, a new condition statement if (!mDatabase.isOpen()) is introduced which would throw new IllegalStateException, therefore the code change type is 1,3 and 4.","The newly added statement 'throw new IllegalStateException' can make the method throw a new exception. Also, the change of logStats and startTime statements can potentially affect the return value retValue, hence the CI type is 1,2."
256,"<android.database.sqlite.SQLiteProgram: void bindBlob(int,byte[])>",7,8,"<android.database.sqlite.SQLiteProgram: void bindBlob(int,byte[])>","<android.database.sqlite.SQLiteProgram: void bindBlob(int,byte[])>",0,"{
    if (value == null) {
        throw new IllegalArgumentException(""the bind value at index "" + index + "" is null"");
    }
    acquireReference();
    try {
        native_bind_blob(index, value);
    } finally {
        releaseReference();
    }
}","{
    if (value == null) {
        throw new IllegalArgumentException(""the bind value at index "" + index + "" is null"");
    }
    if (!mDatabase.isOpen()) {
        throw new IllegalStateException(""database "" + mDatabase.getPath() + "" already closed"");
    }
    acquireReference();
    try {
        native_bind_blob(index, value);
    } finally {
        releaseReference();
    }
}",1,"/**
 * Bind a byte array value to this statement. The value remains bound until
 * {@link #clearBindings} is called.
 *
 * @param index The 1-based index to the parameter to bind
 * @param value The value to bind
 */
","/**
 * Bind a byte array value to this statement. The value remains bound until
 * {@link #clearBindings} is called.
 *
 * @param index The 1-based index to the parameter to bind
 * @param value The value to bind
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,2",2,"There was a new exception handling statement introduced (throw new IllegalStateException(""database "" + mDatabase.getPath() + "" already closed"")), so the code change type is 2,3.","Due to the introduced exception handling, the invocation of late version API would possibly throws a new exception differing from early version, thus the CI type is 2 ."
258,"<android.text.method.PasswordTransformationMethod: void onTextChanged(CharSequence,int,int,int)>",7,8,"<android.text.method.PasswordTransformationMethod: void onTextChanged(CharSequence,int,int,int)>","<android.text.method.PasswordTransformationMethod: void onTextChanged(CharSequence,int,int,int)>",0,"{
    if (s instanceof Spannable) {
        Spannable sp = (Spannable) s;
        ViewReference[] vr = sp.getSpans(0, s.length(), ViewReference.class);
        if (vr.length == 0) {
            return;
        }
        /*
             * There should generally only be one ViewReference in the text,
             * but make sure to look through all of them if necessary in case
             * something strange is going on.  (We might still end up with
             * multiple ViewReferences if someone moves text from one password
             * field to another.)
             */
        View v = null;
        for (int i = 0; v == null && i < vr.length; i++) {
            v = vr[i].get();
        }
        if (v == null) {
            return;
        }
        int pref = TextKeyListener.getInstance().getPrefs(v.getContext());
        if ((pref & TextKeyListener.SHOW_PASSWORD) != 0) {
            if (count > 0) {
                Visible[] old = sp.getSpans(0, sp.length(), Visible.class);
                for (int i = 0; i < old.length; i++) {
                    sp.removeSpan(old[i]);
                }
                if (count == 1) {
                    sp.setSpan(new Visible(sp, this), start, start + count, Spannable.SPAN_EXCLUSIVE_EXCLUSIVE);
                }
            }
        }
    }
}","{
    if (s instanceof Spannable) {
        Spannable sp = (Spannable) s;
        ViewReference[] vr = sp.getSpans(0, s.length(), ViewReference.class);
        if (vr.length == 0) {
            return;
        }
        /*
             * There should generally only be one ViewReference in the text,
             * but make sure to look through all of them if necessary in case
             * something strange is going on.  (We might still end up with
             * multiple ViewReferences if someone moves text from one password
             * field to another.)
             */
        View v = null;
        for (int i = 0; v == null && i < vr.length; i++) {
            v = vr[i].get();
        }
        if (v == null) {
            return;
        }
        int pref = TextKeyListener.getInstance().getPrefs(v.getContext());
        if ((pref & TextKeyListener.SHOW_PASSWORD) != 0) {
            if (count > 0) {
                removeVisibleSpans(sp);
                if (count == 1) {
                    sp.setSpan(new Visible(sp, this), start, start + count, Spannable.SPAN_EXCLUSIVE_EXCLUSIVE);
                }
            }
        }
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"4,5",1,"In the for-loop of the original code, there are lines of code that includes ""sp.removeSpan(old[i]);"", which are replaced in the late version by a function call ""removeVisibleSpans(sp);"". It is assumed that this function performs the same actions as the replaced code. So, the change type is 4 (other statement changed, i.e., the function call replaces the old implementation of removing spans) and 5 (dependent API changed, i.e., this function depends on the `removeVisibleSpans` function whose API definition isn't given).","This change might cause a compatibility issue (type 1) since the behavior of the updated code depends on the 'removeVisibleSpans' function. If the implementation of 'removeVisibleSpans' doesn't closely match the removed segment of code, it would likely change the return of onTextChanged, hence a potential different return."
259,"<android.pim.vcard.VCardUtils: void insertStructuredPostalDataUsingContactsStruct(int,Builder,PostalData)>",7,8,"<android.pim.vcard.VCardUtils: void insertStructuredPostalDataUsingContactsStruct(int,Builder,PostalData)>","<android.pim.vcard.VCardUtils: void insertStructuredPostalDataUsingContactsStruct(int,Builder,PostalData)>",0,"{
    builder.withValueBackReference(StructuredPostal.RAW_CONTACT_ID, 0);
    builder.withValue(Data.MIMETYPE, StructuredPostal.CONTENT_ITEM_TYPE);
    builder.withValue(StructuredPostal.TYPE, postalData.type);
    if (postalData.type == StructuredPostal.TYPE_CUSTOM) {
        builder.withValue(StructuredPostal.LABEL, postalData.label);
    }
    builder.withValue(StructuredPostal.POBOX, postalData.pobox);
    // Extended address is dropped since there's no relevant entry in ContactsContract.
    builder.withValue(StructuredPostal.STREET, postalData.street);
    builder.withValue(StructuredPostal.CITY, postalData.localty);
    builder.withValue(StructuredPostal.REGION, postalData.region);
    builder.withValue(StructuredPostal.POSTCODE, postalData.postalCode);
    builder.withValue(StructuredPostal.COUNTRY, postalData.country);
    builder.withValue(StructuredPostal.FORMATTED_ADDRESS, postalData.getFormattedAddress(vcardType));
    if (postalData.isPrimary) {
        builder.withValue(Data.IS_PRIMARY, 1);
    }
}","{
    builder.withValueBackReference(StructuredPostal.RAW_CONTACT_ID, 0);
    builder.withValue(Data.MIMETYPE, StructuredPostal.CONTENT_ITEM_TYPE);
    builder.withValue(StructuredPostal.TYPE, postalData.type);
    if (postalData.type == StructuredPostal.TYPE_CUSTOM) {
        builder.withValue(StructuredPostal.LABEL, postalData.label);
    }
    final String streetString;
    if (TextUtils.isEmpty(postalData.street)) {
        if (TextUtils.isEmpty(postalData.extendedAddress)) {
            streetString = null;
        } else {
            streetString = postalData.extendedAddress;
        }
    } else {
        if (TextUtils.isEmpty(postalData.extendedAddress)) {
            streetString = postalData.street;
        } else {
            streetString = postalData.street + "" "" + postalData.extendedAddress;
        }
    }
    builder.withValue(StructuredPostal.POBOX, postalData.pobox);
    builder.withValue(StructuredPostal.STREET, streetString);
    builder.withValue(StructuredPostal.CITY, postalData.localty);
    builder.withValue(StructuredPostal.REGION, postalData.region);
    builder.withValue(StructuredPostal.POSTCODE, postalData.postalCode);
    builder.withValue(StructuredPostal.COUNTRY, postalData.country);
    builder.withValue(StructuredPostal.FORMATTED_ADDRESS, postalData.getFormattedAddress(vcardType));
    if (postalData.isPrimary) {
        builder.withValue(Data.IS_PRIMARY, 1);
    }
}",1,"/**
 * Inserts postal data into the builder object.
 *
 * Note that the data structure of ContactsContract is different from that defined in vCard.
 * So some conversion may be performed in this method. See also
 * {{@link #getVCardPostalElements(ContentValues)}
 */
","/**
 * Inserts postal data into the builder object.
 *
 * Note that the data structure of ContactsContract is different from that defined in vCard.
 * So some conversion may be performed in this method.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",1,"The control statement for assigning the value to `streetString` has been added. Also, the value of `StructuredPostal.STREET` has been changed. So the code change types are 3,4.","The added control statement and the changes to `StructuredPostal.STREET` will result in potentially different behaviors of the method. Hence, there is a compatibility issue due to the potential different return values, so the CI type is 1."
260,<android.content.AsyncQueryHandler.WorkerHandler: void handleMessage(Message)>,7,8,<android.content.AsyncQueryHandler.WorkerHandler: void handleMessage(Message)>,<android.content.AsyncQueryHandler.WorkerHandler: void handleMessage(Message)>,0,"{
    final ContentResolver resolver = mResolver.get();
    if (resolver == null)
        return;
    WorkerArgs args = (WorkerArgs) msg.obj;
    int token = msg.what;
    int event = msg.arg1;
    switch(event) {
        case EVENT_ARG_QUERY:
            Cursor cursor;
            try {
                cursor = resolver.query(args.uri, args.projection, args.selection, args.selectionArgs, args.orderBy);
                // which will make the first access on the main thread a lot faster.
                if (cursor != null) {
                    cursor.getCount();
                }
            } catch (Exception e) {
                Log.w(TAG, e.toString());
                cursor = null;
            }
            args.result = cursor;
            break;
        case EVENT_ARG_QUERY_ENTITIES:
            EntityIterator iterator = null;
            try {
                iterator = resolver.queryEntities(args.uri, args.selection, args.selectionArgs, args.orderBy);
            } catch (Exception e) {
                Log.w(TAG, e.toString());
            }
            args.result = iterator;
            break;
        case EVENT_ARG_INSERT:
            args.result = resolver.insert(args.uri, args.values);
            break;
        case EVENT_ARG_UPDATE:
            args.result = resolver.update(args.uri, args.values, args.selection, args.selectionArgs);
            break;
        case EVENT_ARG_DELETE:
            args.result = resolver.delete(args.uri, args.selection, args.selectionArgs);
            break;
    }
    // passing the original token value back to the caller
    // on top of the event values in arg1.
    Message reply = args.handler.obtainMessage(token);
    reply.obj = args;
    reply.arg1 = msg.arg1;
    if (localLOGV) {
        Log.d(TAG, ""WorkerHandler.handleMsg: msg.arg1="" + msg.arg1 + "", reply.what="" + reply.what);
    }
    reply.sendToTarget();
}","{
    final ContentResolver resolver = mResolver.get();
    if (resolver == null)
        return;
    WorkerArgs args = (WorkerArgs) msg.obj;
    int token = msg.what;
    int event = msg.arg1;
    switch(event) {
        case EVENT_ARG_QUERY:
            Cursor cursor;
            try {
                cursor = resolver.query(args.uri, args.projection, args.selection, args.selectionArgs, args.orderBy);
                // which will make the first access on the main thread a lot faster.
                if (cursor != null) {
                    cursor.getCount();
                }
            } catch (Exception e) {
                Log.w(TAG, e.toString());
                cursor = null;
            }
            args.result = cursor;
            break;
        case EVENT_ARG_INSERT:
            args.result = resolver.insert(args.uri, args.values);
            break;
        case EVENT_ARG_UPDATE:
            args.result = resolver.update(args.uri, args.values, args.selection, args.selectionArgs);
            break;
        case EVENT_ARG_DELETE:
            args.result = resolver.delete(args.uri, args.selection, args.selectionArgs);
            break;
    }
    // passing the original token value back to the caller
    // on top of the event values in arg1.
    Message reply = args.handler.obtainMessage(token);
    reply.obj = args;
    reply.arg1 = msg.arg1;
    if (localLOGV) {
        Log.d(TAG, ""WorkerHandler.handleMsg: msg.arg1="" + msg.arg1 + "", reply.what="" + reply.what);
    }
    reply.sendToTarget();
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,3,1,"The 'case EVENT_ARG_QUERY_ENTITIES:' statement, along with its associated code, is removed from the switch statement in the Late Version compared to the Early Version. So, the code change type is 3 (Control dependency change).","The omission of the 'case EVENT_ARG_QUERY_ENTITIES:' might lead to different return values, as this change might affect the value assigned to 'args.result', which will potentially change the behavior of the API. So, the Compatibility Issue type is 1 (Compatibility Issue caused by potential different return values or types)."
263,<android.webkit.FileLoader: boolean setupStreamAndSendStatus()>,7,8,<android.webkit.FileLoader: boolean setupStreamAndSendStatus()>,<android.webkit.FileLoader: boolean setupStreamAndSendStatus()>,0,"{
    try {
        if (mIsAsset) {
            try {
                mDataStream = mContext.getAssets().open(mPath);
            } catch (java.io.FileNotFoundException ex) {
                // try the rest files included in the package
                mDataStream = mContext.getAssets().openNonAsset(mPath);
            }
        } else {
            if (!mAllowFileAccess) {
                mHandler.error(EventHandler.FILE_ERROR, mContext.getString(R.string.httpErrorFileNotFound));
                return false;
            }
            mDataStream = new FileInputStream(mPath);
            mContentLength = (new File(mPath)).length();
        }
        mHandler.status(1, 1, 0, ""OK"");
    } catch (java.io.FileNotFoundException ex) {
        mHandler.error(EventHandler.FILE_NOT_FOUND_ERROR, errString(ex));
        return false;
    } catch (java.io.IOException ex) {
        mHandler.error(EventHandler.FILE_ERROR, errString(ex));
        return false;
    }
    return true;
}","{
    try {
        if (mType == TYPE_ASSET) {
            try {
                mDataStream = mContext.getAssets().open(mPath);
            } catch (java.io.FileNotFoundException ex) {
                // try the rest files included in the package
                mDataStream = mContext.getAssets().openNonAsset(mPath);
            }
        } else if (mType == TYPE_RES) {
            // ""<package>.R$drawable""
            if (mPath == null || mPath.length() == 0) {
                Log.e(LOGTAG, ""Need a path to resolve the res file"");
                mLoadListener.error(EventHandler.FILE_ERROR, mContext.getString(R.string.httpErrorFileNotFound));
                return false;
            }
            int slash = mPath.indexOf('/');
            int dot = mPath.indexOf('.', slash);
            if (slash == -1 || dot == -1) {
                Log.e(LOGTAG, ""Incorrect res path: "" + mPath);
                mLoadListener.error(EventHandler.FILE_ERROR, mContext.getString(R.string.httpErrorFileNotFound));
                return false;
            }
            String subClassName = mPath.substring(0, slash);
            String fieldName = mPath.substring(slash + 1, dot);
            String errorMsg = null;
            try {
                final Class<?> d = mContext.getApplicationContext().getClassLoader().loadClass(mContext.getPackageName() + "".R$"" + subClassName);
                final Field field = d.getField(fieldName);
                final int id = field.getInt(null);
                TypedValue value = new TypedValue();
                mContext.getResources().getValue(id, value, true);
                if (value.type == TypedValue.TYPE_STRING) {
                    mDataStream = mContext.getAssets().openNonAsset(value.assetCookie, value.string.toString(), AssetManager.ACCESS_STREAMING);
                } else {
                    errorMsg = ""Only support TYPE_STRING for the res files"";
                }
            } catch (ClassNotFoundException e) {
                errorMsg = ""Can't find class:  "" + mContext.getPackageName() + "".R$"" + subClassName;
            } catch (SecurityException e) {
                errorMsg = ""Caught SecurityException: "" + e;
            } catch (NoSuchFieldException e) {
                errorMsg = ""Can't find field:  "" + fieldName + "" in "" + mContext.getPackageName() + "".R$"" + subClassName;
            } catch (IllegalArgumentException e) {
                errorMsg = ""Caught IllegalArgumentException: "" + e;
            } catch (IllegalAccessException e) {
                errorMsg = ""Caught IllegalAccessException: "" + e;
            }
            if (errorMsg != null) {
                mLoadListener.error(EventHandler.FILE_ERROR, mContext.getString(R.string.httpErrorFileNotFound));
                return false;
            }
        } else {
            if (!mAllowFileAccess) {
                mLoadListener.error(EventHandler.FILE_ERROR, mContext.getString(R.string.httpErrorFileNotFound));
                return false;
            }
            mDataStream = new FileInputStream(mPath);
            mContentLength = (new File(mPath)).length();
        }
        mLoadListener.status(1, 1, 200, ""OK"");
    } catch (java.io.FileNotFoundException ex) {
        mLoadListener.error(EventHandler.FILE_NOT_FOUND_ERROR, errString(ex));
        return false;
    } catch (java.io.IOException ex) {
        mLoadListener.error(EventHandler.FILE_ERROR, errString(ex));
        return false;
    }
    return true;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,3,4,5","1,2","The variable ""mIsAsset"" is replaced by ""mType"" and there is a new `else if` condition added checking if `mType == TYPE_RES` in the late version. Apart from that, there are changes in the method calls, wherein `mHandler.status` has been changed to `mLoadListener.status`, and `mHandler.error` to `mLoadListener.error`. Additionally, new exceptions are being handled in the newly added condition (ClassNotFoundException, SecurityException, NoSuchFieldException, IllegalArgumentException, and IllegalAccessException). So, the change types are 1,3,4,5.","The variable ""mIsAsset"" was replaced with ""mType"" changing the control flow of the code, thereby potentially leading to a different behaviour in different situations, specifically returning different results or potentially throwing different exceptions. Thus, the CI types are 1,2."
264,<android.widget.ScrollView: boolean onInterceptTouchEvent(MotionEvent)>,7,8,<android.widget.ScrollView: boolean onInterceptTouchEvent(MotionEvent)>,<android.widget.ScrollView: boolean onInterceptTouchEvent(MotionEvent)>,0,"{
    /*
         * This method JUST determines whether we want to intercept the motion.
         * If we return true, onMotionEvent will be called and we do the actual
         * scrolling there.
         */
    /*
        * Shortcut the most recurring case: the user is in the dragging
        * state and he is moving his finger.  We want to intercept this
        * motion.
        */
    final int action = ev.getAction();
    if ((action == MotionEvent.ACTION_MOVE) && (mIsBeingDragged)) {
        return true;
    }
    if (!canScroll()) {
        mIsBeingDragged = false;
        return false;
    }
    final float y = ev.getY();
    switch(action) {
        case MotionEvent.ACTION_MOVE:
            /*
                 * mIsBeingDragged == false, otherwise the shortcut would have caught it. Check
                 * whether the user has moved far enough from his original down touch.
                 */
            /*
                * Locally do absolute value. mLastMotionY is set to the y value
                * of the down event.
                */
            final int yDiff = (int) Math.abs(y - mLastMotionY);
            if (yDiff > mTouchSlop) {
                mIsBeingDragged = true;
            }
            break;
        case MotionEvent.ACTION_DOWN:
            /* Remember location of down touch */
            mLastMotionY = y;
            /*
                * If being flinged and user touches the screen, initiate drag;
                * otherwise don't.  mScroller.isFinished should be false when
                * being flinged.
                */
            mIsBeingDragged = !mScroller.isFinished();
            break;
        case MotionEvent.ACTION_CANCEL:
        case MotionEvent.ACTION_UP:
            /* Release the drag */
            mIsBeingDragged = false;
            break;
    }
    /*
        * The only time we want to intercept motion events is if we are in the
        * drag mode.
        */
    return mIsBeingDragged;
}","{
    /*
         * This method JUST determines whether we want to intercept the motion.
         * If we return true, onMotionEvent will be called and we do the actual
         * scrolling there.
         */
    /*
        * Shortcut the most recurring case: the user is in the dragging
        * state and he is moving his finger.  We want to intercept this
        * motion.
        */
    final int action = ev.getAction();
    if ((action == MotionEvent.ACTION_MOVE) && (mIsBeingDragged)) {
        return true;
    }
    switch(action & MotionEvent.ACTION_MASK) {
        case MotionEvent.ACTION_MOVE:
            {
                /*
                 * mIsBeingDragged == false, otherwise the shortcut would have caught it. Check
                 * whether the user has moved far enough from his original down touch.
                 */
                /*
                * Locally do absolute value. mLastMotionY is set to the y value
                * of the down event.
                */
                final int activePointerId = mActivePointerId;
                if (activePointerId == INVALID_POINTER) {
                    // If we don't have a valid id, the touch down wasn't on content.
                    break;
                }
                final int pointerIndex = ev.findPointerIndex(activePointerId);
                final float y = ev.getY(pointerIndex);
                final int yDiff = (int) Math.abs(y - mLastMotionY);
                if (yDiff > mTouchSlop) {
                    mIsBeingDragged = true;
                    mLastMotionY = y;
                }
                break;
            }
        case MotionEvent.ACTION_DOWN:
            {
                final float y = ev.getY();
                if (!inChild((int) ev.getX(), (int) y)) {
                    mIsBeingDragged = false;
                    break;
                }
                /*
                 * Remember location of down touch.
                 * ACTION_DOWN always refers to pointer index 0.
                 */
                mLastMotionY = y;
                mActivePointerId = ev.getPointerId(0);
                /*
                * If being flinged and user touches the screen, initiate drag;
                * otherwise don't.  mScroller.isFinished should be false when
                * being flinged.
                */
                mIsBeingDragged = !mScroller.isFinished();
                break;
            }
        case MotionEvent.ACTION_CANCEL:
        case MotionEvent.ACTION_UP:
            /* Release the drag */
            mIsBeingDragged = false;
            mActivePointerId = INVALID_POINTER;
            break;
        case MotionEvent.ACTION_POINTER_UP:
            onSecondaryPointerUp(ev);
            break;
    }
    /*
        * The only time we want to intercept motion events is if we are in the
        * drag mode.
        */
    return mIsBeingDragged;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,4",1,"The control statement 'switch(action)' in the early version has been changed to 'switch(action & MotionEvent.ACTION_MASK)' in the late version, and there are also several new statements ('final int activePointerId = mActivePointerId;', 'final int pointerIndex = ev.findPointerIndex(activePointerId);', 'final float y = ev.getY(pointerIndex);', 'mLastMotionY = y;', 'if (!inChild((int) ev.getX(), (int) y))', 'mActivePointerId = ev.getPointerId(0);', 'mActivePointerId = INVALID_POINTER;', 'onSecondaryPointerUp(ev);') introduced in the late version, so the code change type is 3,4.","Statement changes related with the change of 'if' condition, the additions 'final float y = ev.getY(pointerIndex);' and the deletion 'final float y = ev.getY();' (which occurs in the Late_Implementation within the case MotionEvent.ACTION_MOVE part), and the change of the return variable 'mIsBeingDragged' may cause the API to return a different value, so the CI type is 1."
266,"<android.os.Message: void writeToParcel(Parcel,int)>",7,8,"<android.os.Message: void writeToParcel(Parcel,int)>","<android.os.Message: void writeToParcel(Parcel,int)>",0,"{
    if (obj != null || callback != null) {
        throw new RuntimeException(""Can't marshal objects across processes."");
    }
    dest.writeInt(what);
    dest.writeInt(arg1);
    dest.writeInt(arg2);
    dest.writeLong(when);
    dest.writeBundle(data);
    Messenger.writeMessengerOrNullToParcel(replyTo, dest);
}","{
    if (callback != null) {
        throw new RuntimeException(""Can't marshal callbacks across processes."");
    }
    dest.writeInt(what);
    dest.writeInt(arg1);
    dest.writeInt(arg2);
    if (obj != null) {
        try {
            Parcelable p = (Parcelable) obj;
            dest.writeInt(1);
            dest.writeParcelable(p, flags);
        } catch (ClassCastException e) {
            throw new RuntimeException(""Can't marshal non-Parcelable objects across processes."");
        }
    } else {
        dest.writeInt(0);
    }
    dest.writeLong(when);
    dest.writeBundle(data);
    Messenger.writeMessengerOrNullToParcel(replyTo, dest);
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"1,2,3,4","1,2","The condition statement ""if (obj != null || callback != null)"" is changed in late version and new return and exception handling statements are added. The change type is 1,2,3,4.","The changes may make the API throw or return different values. For example, in the late version, if 'obj' is not null and leads to 'ClassCastException', a different type of exception will be thrown. Meanwhile, the variable 'dest' can have different values because of additional statements such as 'dest.writeInt(1)', 'dest.writeInt(0)', and 'dest.writeParcelable(p, flags)'. Therefore, the CI type is 1,2."
267,<android.net.http.SslCertificate: String getValidNotBefore()>,7,8,<android.net.http.SslCertificate: String getValidNotBefore()>,<android.net.http.SslCertificate: String getValidNotBefore()>,0,"{
    return mValidNotBefore != null ? mValidNotBefore : """";
}","{
    return formatDate(mValidNotBefore);
}",1,"/**
 * @return Not-before date from the certificate validity period or
 * """" if none has been set
 */
","/**
 * @return Not-before date from the certificate validity period in
 * ISO 8601 format or """" if none has been set
 *
 * @deprecated Use {@link #getValidNotBeforeDate()}
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The return statement has changed from 'return mValidNotBefore != null ? mValidNotBefore : """";' to 'return formatDate(mValidNotBefore);' and the method being invoked also changed, so the code change type is 1,5.","The change of return statement will make the API potentially return a different value, so the CI type is 1."
268,"<android.content.ContentResolver: Object addStatusChangeListener(int,SyncStatusObserver)>",7,8,"<android.content.ContentResolver: Object addStatusChangeListener(int,SyncStatusObserver)>","<android.content.ContentResolver: Object addStatusChangeListener(int,SyncStatusObserver)>",0,"{
    try {
        ISyncStatusObserver.Stub observer = new ISyncStatusObserver.Stub() {

            public void onStatusChanged(int which) throws RemoteException {
                callback.onStatusChanged(which);
            }
        };
        getContentService().addStatusChangeListener(mask, observer);
        return observer;
    } catch (RemoteException e) {
        throw new RuntimeException(""the ContentService should always be reachable"", e);
    }
}","{
    if (callback == null) {
        throw new IllegalArgumentException(""you passed in a null callback"");
    }
    try {
        ISyncStatusObserver.Stub observer = new ISyncStatusObserver.Stub() {

            public void onStatusChanged(int which) throws RemoteException {
                callback.onStatusChanged(which);
            }
        };
        getContentService().addStatusChangeListener(mask, observer);
        return observer;
    } catch (RemoteException e) {
        throw new RuntimeException(""the ContentService should always be reachable"", e);
    }
}",1,,"/**
 * Request notifications when the different aspects of the SyncManager change. The
 * different items that can be requested are:
 * <ul>
 * <li> {@link #SYNC_OBSERVER_TYPE_PENDING}
 * <li> {@link #SYNC_OBSERVER_TYPE_ACTIVE}
 * <li> {@link #SYNC_OBSERVER_TYPE_SETTINGS}
 * </ul>
 * The caller can set one or more of the status types in the mask for any
 * given listener registration.
 * @param mask the status change types that will cause the callback to be invoked
 * @param callback observer to be invoked when the status changes
 * @return a handle that can be used to remove the listener at a later time
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,2","1,2","In the later version, an additional check for null parameter and corresponding exception throw statement has been added before the try block. This leads to change in control dependencies (i.e., control statements under which subsequent statements are determined) and exception handling statement. Therefore, the code change type is 3,2.","The addition of the null parameter check could potentially lead the API to throw a new type of exception (`IllegalArgumentException`) in the late version if `callback` is null, which was not the case in the early version. Additionally, the introduction of new exception throwing could change the originally returned value in such cases, thereby potentially changing return behaviour. Thus, the Compatibility Issue types are 1,2."
269,"<android.view.animation.Animation: boolean getTransformation(long,Transformation)>",7,8,"<android.view.animation.Animation: boolean getTransformation(long,Transformation)>","<android.view.animation.Animation: boolean getTransformation(long,Transformation)>",0,"{
    if (mStartTime == -1) {
        mStartTime = currentTime;
    }
    final long startOffset = getStartOffset();
    final long duration = mDuration;
    float normalizedTime;
    if (duration != 0) {
        normalizedTime = ((float) (currentTime - (mStartTime + startOffset))) / (float) duration;
    } else {
        // time is a step-change with a zero duration
        normalizedTime = currentTime < mStartTime ? 0.0f : 1.0f;
    }
    final boolean expired = normalizedTime >= 1.0f;
    mMore = !expired;
    if (!mFillEnabled)
        normalizedTime = Math.max(Math.min(normalizedTime, 1.0f), 0.0f);
    if ((normalizedTime >= 0.0f || mFillBefore) && (normalizedTime <= 1.0f || mFillAfter)) {
        if (!mStarted) {
            if (mListener != null) {
                mListener.onAnimationStart(this);
            }
            mStarted = true;
        }
        if (mFillEnabled)
            normalizedTime = Math.max(Math.min(normalizedTime, 1.0f), 0.0f);
        if (mCycleFlip) {
            normalizedTime = 1.0f - normalizedTime;
        }
        final float interpolatedTime = mInterpolator.getInterpolation(normalizedTime);
        applyTransformation(interpolatedTime, outTransformation);
    }
    if (expired) {
        if (mRepeatCount == mRepeated) {
            if (!mEnded) {
                if (mListener != null) {
                    mListener.onAnimationEnd(this);
                }
                mEnded = true;
            }
        } else {
            if (mRepeatCount > 0) {
                mRepeated++;
            }
            if (mRepeatMode == REVERSE) {
                mCycleFlip = !mCycleFlip;
            }
            mStartTime = -1;
            mMore = true;
            if (mListener != null) {
                mListener.onAnimationRepeat(this);
            }
        }
    }
    if (!mMore && mOneMoreTime) {
        mOneMoreTime = false;
        return true;
    }
    return mMore;
}","{
    if (mStartTime == -1) {
        mStartTime = currentTime;
    }
    final long startOffset = getStartOffset();
    final long duration = mDuration;
    float normalizedTime;
    if (duration != 0) {
        normalizedTime = ((float) (currentTime - (mStartTime + startOffset))) / (float) duration;
    } else {
        // time is a step-change with a zero duration
        normalizedTime = currentTime < mStartTime ? 0.0f : 1.0f;
    }
    final boolean expired = normalizedTime >= 1.0f;
    mMore = !expired;
    if (!mFillEnabled)
        normalizedTime = Math.max(Math.min(normalizedTime, 1.0f), 0.0f);
    if ((normalizedTime >= 0.0f || mFillBefore) && (normalizedTime <= 1.0f || mFillAfter)) {
        if (!mStarted) {
            if (mListener != null) {
                mListener.onAnimationStart(this);
            }
            mStarted = true;
        }
        if (mFillEnabled)
            normalizedTime = Math.max(Math.min(normalizedTime, 1.0f), 0.0f);
        if (mCycleFlip) {
            normalizedTime = 1.0f - normalizedTime;
        }
        final float interpolatedTime = mInterpolator.getInterpolation(normalizedTime);
        applyTransformation(interpolatedTime, outTransformation);
    }
    if (expired) {
        if (mRepeatCount == mRepeated) {
            if (!mEnded) {
                mEnded = true;
                if (mListener != null) {
                    mListener.onAnimationEnd(this);
                }
            }
        } else {
            if (mRepeatCount > 0) {
                mRepeated++;
            }
            if (mRepeatMode == REVERSE) {
                mCycleFlip = !mCycleFlip;
            }
            mStartTime = -1;
            mMore = true;
            if (mListener != null) {
                mListener.onAnimationRepeat(this);
            }
        }
    }
    if (!mMore && mOneMoreTime) {
        mOneMoreTime = false;
        return true;
    }
    return mMore;
}",1,"/**
 * Gets the transformation to apply at a specified point in time. Implementations of this
 * method should always replace the specified Transformation or document they are doing
 * otherwise.
 *
 * @param currentTime Where we are in the animation. This is wall clock time.
 * @param outTransformation A tranformation object that is provided by the
 * caller and will be filled in by the animation.
 * @return True if the animation is still running
 */
","/**
 * Gets the transformation to apply at a specified point in time. Implementations of this
 * method should always replace the specified Transformation or document they are doing
 * otherwise.
 *
 * @param currentTime Where we are in the animation. This is wall clock time.
 * @param outTransformation A tranformation object that is provided by the
 * caller and will be filled in by the animation.
 * @return True if the animation is still running
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The statement ""mEnded = true;"" moved before ""if (mListener != null) { mListener.onAnimationEnd(this); }"", just a sequence change inside the same context, the change type is 4.","The sequence change in the code won't cause the API to return a different variable or throw different exceptions, so no CI exists, the CI type is 0."
271,<android.webkit.WebView: void rebuildWebTextView()>,7,8,<android.webkit.WebView: void rebuildWebTextView()>,<android.webkit.WebView: void rebuildWebTextView()>,0,"{
    // If the WebView does not have focus, do nothing until it gains focus.
    if (!hasFocus() && (null == mWebTextView || !mWebTextView.hasFocus())) {
        return;
    }
    boolean alreadyThere = inEditingMode();
    // so we can safely call remove() if (alreadyThere)
    if (0 == mNativeClass || !nativeFocusCandidateIsTextInput()) {
        if (alreadyThere) {
            mWebTextView.remove();
        }
        return;
    }
    // and create the WebTextView if necessary.
    if (mWebTextView == null) {
        mWebTextView = new WebTextView(mContext, WebView.this);
        // Initialize our generation number.
        mTextGeneration = 0;
    }
    mWebTextView.setTextSize(TypedValue.COMPLEX_UNIT_PX, contentToViewDimension(nativeFocusCandidateTextSize()));
    Rect visibleRect = new Rect();
    calcOurContentVisibleRect(visibleRect);
    // Note that sendOurVisibleRect calls viewToContent, so the coordinates
    // should be in content coordinates.
    Rect bounds = nativeFocusCandidateNodeBounds();
    if (!Rect.intersects(bounds, visibleRect)) {
        mWebTextView.bringIntoView();
    }
    String text = nativeFocusCandidateText();
    int nodePointer = nativeFocusCandidatePointer();
    if (alreadyThere && mWebTextView.isSameTextField(nodePointer)) {
        // It is possible that we have the same textfield, but it has moved,
        // i.e. In the case of opening/closing the screen.
        // In that case, we need to set the dimensions, but not the other
        // aspects.
        // We also need to restore the selection, which gets wrecked by
        // calling setTextEntryRect.
        Spannable spannable = (Spannable) mWebTextView.getText();
        int start = Selection.getSelectionStart(spannable);
        int end = Selection.getSelectionEnd(spannable);
        // another update when that text is recognized.
        if (text != null && !text.equals(spannable.toString()) && nativeTextGeneration() == mTextGeneration) {
            mWebTextView.setTextAndKeepSelection(text);
        } else {
            Selection.setSelection(spannable, start, end);
        }
    } else {
        Rect vBox = contentToViewRect(bounds);
        mWebTextView.setRect(vBox.left, vBox.top, vBox.width(), vBox.height());
        mWebTextView.setGravity(nativeFocusCandidateIsRtlText() ? Gravity.RIGHT : Gravity.NO_GRAVITY);
        // this needs to be called before update adapter thread starts to
        // ensure the mWebTextView has the same node pointer
        mWebTextView.setNodePointer(nodePointer);
        int maxLength = -1;
        boolean isTextField = nativeFocusCandidateIsTextField();
        if (isTextField) {
            maxLength = nativeFocusCandidateMaxLength();
            String name = nativeFocusCandidateName();
            if (mWebViewCore.getSettings().getSaveFormData() && name != null) {
                Message update = mPrivateHandler.obtainMessage(REQUEST_FORM_DATA, nodePointer);
                RequestFormData updater = new RequestFormData(name, getUrl(), update);
                Thread t = new Thread(updater);
                t.start();
            }
        }
        mWebTextView.setMaxLength(maxLength);
        AutoCompleteAdapter adapter = null;
        mWebTextView.setAdapterCustom(adapter);
        mWebTextView.setSingleLine(isTextField);
        mWebTextView.setInPassword(nativeFocusCandidateIsPassword());
        if (null == text) {
            mWebTextView.setText("""", 0, 0);
            if (DebugFlags.WEB_VIEW) {
                Log.v(LOGTAG, ""rebuildWebTextView null == text"");
            }
        } else {
            // selection at the end, and textareas at the beginning.
            if (false) {
                mWebTextView.setText(text, 0, text.length());
            } else if (isTextField) {
                int length = text.length();
                mWebTextView.setText(text, length, length);
                if (DebugFlags.WEB_VIEW) {
                    Log.v(LOGTAG, ""rebuildWebTextView length="" + length);
                }
            } else {
                mWebTextView.setText(text, 0, 0);
                if (DebugFlags.WEB_VIEW) {
                    Log.v(LOGTAG, ""rebuildWebTextView !isTextField"");
                }
            }
        }
        mWebTextView.requestFocus();
    }
}","{
    // If the WebView does not have focus, do nothing until it gains focus.
    if (!hasFocus() && (null == mWebTextView || !mWebTextView.hasFocus())) {
        return;
    }
    boolean alreadyThere = inEditingMode();
    // so we can safely call remove() if (alreadyThere)
    if (0 == mNativeClass || !nativeFocusCandidateIsTextInput()) {
        if (alreadyThere) {
            mWebTextView.remove();
        }
        return;
    }
    // and create the WebTextView if necessary.
    if (mWebTextView == null) {
        mWebTextView = new WebTextView(mContext, WebView.this);
        // Initialize our generation number.
        mTextGeneration = 0;
    }
    mWebTextView.setTextSize(TypedValue.COMPLEX_UNIT_PX, contentToViewDimension(nativeFocusCandidateTextSize()));
    Rect visibleRect = new Rect();
    calcOurContentVisibleRect(visibleRect);
    // Note that sendOurVisibleRect calls viewToContent, so the coordinates
    // should be in content coordinates.
    Rect bounds = nativeFocusCandidateNodeBounds();
    Rect vBox = contentToViewRect(bounds);
    mWebTextView.setRect(vBox.left, vBox.top, vBox.width(), vBox.height());
    if (!Rect.intersects(bounds, visibleRect)) {
        mWebTextView.bringIntoView();
    }
    String text = nativeFocusCandidateText();
    int nodePointer = nativeFocusCandidatePointer();
    if (alreadyThere && mWebTextView.isSameTextField(nodePointer)) {
        // another update when that text is recognized.
        if (text != null && !text.equals(mWebTextView.getText().toString()) && nativeTextGeneration() == mTextGeneration) {
            mWebTextView.setTextAndKeepSelection(text);
        }
    } else {
        mWebTextView.setGravity(nativeFocusCandidateIsRtlText() ? Gravity.RIGHT : Gravity.NO_GRAVITY);
        // This needs to be called before setType, which may call
        // requestFormData, and it needs to have the correct nodePointer.
        mWebTextView.setNodePointer(nodePointer);
        mWebTextView.setType(nativeFocusCandidateType());
        if (null == text) {
            if (DebugFlags.WEB_VIEW) {
                Log.v(LOGTAG, ""rebuildWebTextView null == text"");
            }
            text = """";
        }
        mWebTextView.setTextAndKeepSelection(text);
        InputMethodManager imm = InputMethodManager.peekInstance();
        if (imm != null && imm.isActive(mWebTextView)) {
            imm.restartInput(mWebTextView);
        }
    }
    mWebTextView.requestFocus();
}",1,"/* package */
","/* package */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",1,"The implementation of this method has changed as control dependencies (i.e., if clauses in the 'alreadyThere' section) have been altered, and there are several modifications to some function calls and assignments (e.g., missing call to mWebTextView.setSingleLine(), added call to mWebTextView.setType() and the 'if (null == text)' section). Therefore, the code change type is 3,4.","The changes in the implementation could lead to potential different behaviours of the API. For example, the changes in the 'if' statements could lead to accessing different part of the code which could potentially affect the return value of this void method, which means the side effect is different, thus the CI type is 1."
272,<android.content.ContentValues: Boolean getAsBoolean(String)>,7,8,<android.content.ContentValues: Boolean getAsBoolean(String)>,<android.content.ContentValues: Boolean getAsBoolean(String)>,0,"{
    Object value = mValues.get(key);
    try {
        return (Boolean) value;
    } catch (ClassCastException e) {
        if (value instanceof CharSequence) {
            return Boolean.valueOf(value.toString());
        } else {
            Log.e(TAG, ""Cannot cast value for "" + key + "" to a Boolean"");
            return null;
        }
    }
}","{
    Object value = mValues.get(key);
    try {
        return (Boolean) value;
    } catch (ClassCastException e) {
        if (value instanceof CharSequence) {
            return Boolean.valueOf(value.toString());
        } else {
            Log.e(TAG, ""Cannot cast value for "" + key + "" to a Boolean: "" + value, e);
            return null;
        }
    }
}",1,"/**
 * Gets a value and converts it to a Boolean.
 *
 * @param key the value to get
 * @return the Boolean value, or null if the value is missing or cannot be converted
 */
","/**
 * Gets a value and converts it to a Boolean.
 *
 * @param key the value to get
 * @return the Boolean value, or null if the value is missing or cannot be converted
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"Only the log message in Log.e() has been changed from ""Cannot cast value for "" + key + "" to a Boolean"" to ""Cannot cast value for "" + key + "" to a Boolean: "" + value, e. Therefore, the code change type is 4.","Since the only change is in the log message, and this doesn't affect the functionality or result of the method, there is no Compatibility Issue. Thus, the CI type is 0."
273,"<android.widget.AutoCompleteTextView: boolean setFrame(int,int,int,int)>",7,8,"<android.widget.AutoCompleteTextView: boolean setFrame(int,int,int,int)>","<android.widget.AutoCompleteTextView: boolean setFrame(int,int,int,int)>",0,"{
    boolean result = super.setFrame(l, t, r, b);
    if (mPopup.isShowing()) {
        mPopup.update(this, r - l, -1);
    }
    return result;
}","{
    boolean result = super.setFrame(l, t, r, b);
    if (mPopup.isShowing()) {
        showDropDown();
    }
    return result;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"The API statement mPopup.update(this, r - l, -1) has been replaced by showDropDown() but this doesn't affect the return results of the method. So the code change type is 4.","There are no changes affecting the return values or the exception handling, hence no compatibility issues exist, and the CI Type is 0."
275,<android.webkit.MimeTypeMap: MimeTypeMap getSingleton()>,7,8,<android.webkit.MimeTypeMap: MimeTypeMap getSingleton()>,<android.webkit.MimeTypeMap: MimeTypeMap getSingleton()>,0,"{
    if (sMimeTypeMap == null) {
        sMimeTypeMap = new MimeTypeMap();
        // The following table is based on /etc/mime.types data minus
        // chemical/* MIME types and MIME types that don't map to any
        // file extensions. We also exclude top-level domain names to
        // deal with cases like:
        // 
        // mail.google.com/a/google.com
        // 
        // and ""active"" MIME types (due to potential security issues).
        sMimeTypeMap.loadEntry(""application/andrew-inset"", ""ez"");
        sMimeTypeMap.loadEntry(""application/dsptype"", ""tsp"");
        sMimeTypeMap.loadEntry(""application/futuresplash"", ""spl"");
        sMimeTypeMap.loadEntry(""application/hta"", ""hta"");
        sMimeTypeMap.loadEntry(""application/mac-binhex40"", ""hqx"");
        sMimeTypeMap.loadEntry(""application/mac-compactpro"", ""cpt"");
        sMimeTypeMap.loadEntry(""application/mathematica"", ""nb"");
        sMimeTypeMap.loadEntry(""application/msaccess"", ""mdb"");
        sMimeTypeMap.loadEntry(""application/oda"", ""oda"");
        sMimeTypeMap.loadEntry(""application/ogg"", ""ogg"");
        sMimeTypeMap.loadEntry(""application/pdf"", ""pdf"");
        sMimeTypeMap.loadEntry(""application/pgp-keys"", ""key"");
        sMimeTypeMap.loadEntry(""application/pgp-signature"", ""pgp"");
        sMimeTypeMap.loadEntry(""application/pics-rules"", ""prf"");
        sMimeTypeMap.loadEntry(""application/rar"", ""rar"");
        sMimeTypeMap.loadEntry(""application/rdf+xml"", ""rdf"");
        sMimeTypeMap.loadEntry(""application/rss+xml"", ""rss"");
        sMimeTypeMap.loadEntry(""application/zip"", ""zip"");
        sMimeTypeMap.loadEntry(""application/vnd.android.package-archive"", ""apk"");
        sMimeTypeMap.loadEntry(""application/vnd.cinderella"", ""cdy"");
        sMimeTypeMap.loadEntry(""application/vnd.ms-pki.stl"", ""stl"");
        sMimeTypeMap.loadEntry(""application/vnd.oasis.opendocument.database"", ""odb"");
        sMimeTypeMap.loadEntry(""application/vnd.oasis.opendocument.formula"", ""odf"");
        sMimeTypeMap.loadEntry(""application/vnd.oasis.opendocument.graphics"", ""odg"");
        sMimeTypeMap.loadEntry(""application/vnd.oasis.opendocument.graphics-template"", ""otg"");
        sMimeTypeMap.loadEntry(""application/vnd.oasis.opendocument.image"", ""odi"");
        sMimeTypeMap.loadEntry(""application/vnd.oasis.opendocument.spreadsheet"", ""ods"");
        sMimeTypeMap.loadEntry(""application/vnd.oasis.opendocument.spreadsheet-template"", ""ots"");
        sMimeTypeMap.loadEntry(""application/vnd.oasis.opendocument.text"", ""odt"");
        sMimeTypeMap.loadEntry(""application/vnd.oasis.opendocument.text-master"", ""odm"");
        sMimeTypeMap.loadEntry(""application/vnd.oasis.opendocument.text-template"", ""ott"");
        sMimeTypeMap.loadEntry(""application/vnd.oasis.opendocument.text-web"", ""oth"");
        sMimeTypeMap.loadEntry(""application/msword"", ""doc"");
        sMimeTypeMap.loadEntry(""application/msword"", ""dot"");
        sMimeTypeMap.loadEntry(""application/vnd.openxmlformats-officedocument.wordprocessingml.document"", ""docx"");
        sMimeTypeMap.loadEntry(""application/vnd.openxmlformats-officedocument.wordprocessingml.template"", ""dotx"");
        sMimeTypeMap.loadEntry(""application/vnd.ms-excel"", ""xls"");
        sMimeTypeMap.loadEntry(""application/vnd.ms-excel"", ""xlt"");
        sMimeTypeMap.loadEntry(""application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"", ""xlsx"");
        sMimeTypeMap.loadEntry(""application/vnd.openxmlformats-officedocument.spreadsheetml.template"", ""xltx"");
        sMimeTypeMap.loadEntry(""application/vnd.ms-powerpoint"", ""ppt"");
        sMimeTypeMap.loadEntry(""application/vnd.ms-powerpoint"", ""pot"");
        sMimeTypeMap.loadEntry(""application/vnd.ms-powerpoint"", ""pps"");
        sMimeTypeMap.loadEntry(""application/vnd.openxmlformats-officedocument.presentationml.presentation"", ""pptx"");
        sMimeTypeMap.loadEntry(""application/vnd.openxmlformats-officedocument.presentationml.template"", ""potx"");
        sMimeTypeMap.loadEntry(""application/vnd.openxmlformats-officedocument.presentationml.slideshow"", ""ppsx"");
        sMimeTypeMap.loadEntry(""application/vnd.rim.cod"", ""cod"");
        sMimeTypeMap.loadEntry(""application/vnd.smaf"", ""mmf"");
        sMimeTypeMap.loadEntry(""application/vnd.stardivision.calc"", ""sdc"");
        sMimeTypeMap.loadEntry(""application/vnd.stardivision.draw"", ""sda"");
        sMimeTypeMap.loadEntry(""application/vnd.stardivision.impress"", ""sdd"");
        sMimeTypeMap.loadEntry(""application/vnd.stardivision.impress"", ""sdp"");
        sMimeTypeMap.loadEntry(""application/vnd.stardivision.math"", ""smf"");
        sMimeTypeMap.loadEntry(""application/vnd.stardivision.writer"", ""sdw"");
        sMimeTypeMap.loadEntry(""application/vnd.stardivision.writer"", ""vor"");
        sMimeTypeMap.loadEntry(""application/vnd.stardivision.writer-global"", ""sgl"");
        sMimeTypeMap.loadEntry(""application/vnd.sun.xml.calc"", ""sxc"");
        sMimeTypeMap.loadEntry(""application/vnd.sun.xml.calc.template"", ""stc"");
        sMimeTypeMap.loadEntry(""application/vnd.sun.xml.draw"", ""sxd"");
        sMimeTypeMap.loadEntry(""application/vnd.sun.xml.draw.template"", ""std"");
        sMimeTypeMap.loadEntry(""application/vnd.sun.xml.impress"", ""sxi"");
        sMimeTypeMap.loadEntry(""application/vnd.sun.xml.impress.template"", ""sti"");
        sMimeTypeMap.loadEntry(""application/vnd.sun.xml.math"", ""sxm"");
        sMimeTypeMap.loadEntry(""application/vnd.sun.xml.writer"", ""sxw"");
        sMimeTypeMap.loadEntry(""application/vnd.sun.xml.writer.global"", ""sxg"");
        sMimeTypeMap.loadEntry(""application/vnd.sun.xml.writer.template"", ""stw"");
        sMimeTypeMap.loadEntry(""application/vnd.visio"", ""vsd"");
        sMimeTypeMap.loadEntry(""application/x-abiword"", ""abw"");
        sMimeTypeMap.loadEntry(""application/x-apple-diskimage"", ""dmg"");
        sMimeTypeMap.loadEntry(""application/x-bcpio"", ""bcpio"");
        sMimeTypeMap.loadEntry(""application/x-bittorrent"", ""torrent"");
        sMimeTypeMap.loadEntry(""application/x-cdf"", ""cdf"");
        sMimeTypeMap.loadEntry(""application/x-cdlink"", ""vcd"");
        sMimeTypeMap.loadEntry(""application/x-chess-pgn"", ""pgn"");
        sMimeTypeMap.loadEntry(""application/x-cpio"", ""cpio"");
        sMimeTypeMap.loadEntry(""application/x-debian-package"", ""deb"");
        sMimeTypeMap.loadEntry(""application/x-debian-package"", ""udeb"");
        sMimeTypeMap.loadEntry(""application/x-director"", ""dcr"");
        sMimeTypeMap.loadEntry(""application/x-director"", ""dir"");
        sMimeTypeMap.loadEntry(""application/x-director"", ""dxr"");
        sMimeTypeMap.loadEntry(""application/x-dms"", ""dms"");
        sMimeTypeMap.loadEntry(""application/x-doom"", ""wad"");
        sMimeTypeMap.loadEntry(""application/x-dvi"", ""dvi"");
        sMimeTypeMap.loadEntry(""application/x-flac"", ""flac"");
        sMimeTypeMap.loadEntry(""application/x-font"", ""pfa"");
        sMimeTypeMap.loadEntry(""application/x-font"", ""pfb"");
        sMimeTypeMap.loadEntry(""application/x-font"", ""gsf"");
        sMimeTypeMap.loadEntry(""application/x-font"", ""pcf"");
        sMimeTypeMap.loadEntry(""application/x-font"", ""pcf.Z"");
        sMimeTypeMap.loadEntry(""application/x-freemind"", ""mm"");
        sMimeTypeMap.loadEntry(""application/x-futuresplash"", ""spl"");
        sMimeTypeMap.loadEntry(""application/x-gnumeric"", ""gnumeric"");
        sMimeTypeMap.loadEntry(""application/x-go-sgf"", ""sgf"");
        sMimeTypeMap.loadEntry(""application/x-graphing-calculator"", ""gcf"");
        sMimeTypeMap.loadEntry(""application/x-gtar"", ""gtar"");
        sMimeTypeMap.loadEntry(""application/x-gtar"", ""tgz"");
        sMimeTypeMap.loadEntry(""application/x-gtar"", ""taz"");
        sMimeTypeMap.loadEntry(""application/x-hdf"", ""hdf"");
        sMimeTypeMap.loadEntry(""application/x-ica"", ""ica"");
        sMimeTypeMap.loadEntry(""application/x-internet-signup"", ""ins"");
        sMimeTypeMap.loadEntry(""application/x-internet-signup"", ""isp"");
        sMimeTypeMap.loadEntry(""application/x-iphone"", ""iii"");
        sMimeTypeMap.loadEntry(""application/x-iso9660-image"", ""iso"");
        sMimeTypeMap.loadEntry(""application/x-jmol"", ""jmz"");
        sMimeTypeMap.loadEntry(""application/x-kchart"", ""chrt"");
        sMimeTypeMap.loadEntry(""application/x-killustrator"", ""kil"");
        sMimeTypeMap.loadEntry(""application/x-koan"", ""skp"");
        sMimeTypeMap.loadEntry(""application/x-koan"", ""skd"");
        sMimeTypeMap.loadEntry(""application/x-koan"", ""skt"");
        sMimeTypeMap.loadEntry(""application/x-koan"", ""skm"");
        sMimeTypeMap.loadEntry(""application/x-kpresenter"", ""kpr"");
        sMimeTypeMap.loadEntry(""application/x-kpresenter"", ""kpt"");
        sMimeTypeMap.loadEntry(""application/x-kspread"", ""ksp"");
        sMimeTypeMap.loadEntry(""application/x-kword"", ""kwd"");
        sMimeTypeMap.loadEntry(""application/x-kword"", ""kwt"");
        sMimeTypeMap.loadEntry(""application/x-latex"", ""latex"");
        sMimeTypeMap.loadEntry(""application/x-lha"", ""lha"");
        sMimeTypeMap.loadEntry(""application/x-lzh"", ""lzh"");
        sMimeTypeMap.loadEntry(""application/x-lzx"", ""lzx"");
        sMimeTypeMap.loadEntry(""application/x-maker"", ""frm"");
        sMimeTypeMap.loadEntry(""application/x-maker"", ""maker"");
        sMimeTypeMap.loadEntry(""application/x-maker"", ""frame"");
        sMimeTypeMap.loadEntry(""application/x-maker"", ""fb"");
        sMimeTypeMap.loadEntry(""application/x-maker"", ""book"");
        sMimeTypeMap.loadEntry(""application/x-maker"", ""fbdoc"");
        sMimeTypeMap.loadEntry(""application/x-mif"", ""mif"");
        sMimeTypeMap.loadEntry(""application/x-ms-wmd"", ""wmd"");
        sMimeTypeMap.loadEntry(""application/x-ms-wmz"", ""wmz"");
        sMimeTypeMap.loadEntry(""application/x-msi"", ""msi"");
        sMimeTypeMap.loadEntry(""application/x-ns-proxy-autoconfig"", ""pac"");
        sMimeTypeMap.loadEntry(""application/x-nwc"", ""nwc"");
        sMimeTypeMap.loadEntry(""application/x-object"", ""o"");
        sMimeTypeMap.loadEntry(""application/x-oz-application"", ""oza"");
        sMimeTypeMap.loadEntry(""application/x-pkcs12"", ""p12"");
        sMimeTypeMap.loadEntry(""application/x-pkcs7-certreqresp"", ""p7r"");
        sMimeTypeMap.loadEntry(""application/x-pkcs7-crl"", ""crl"");
        sMimeTypeMap.loadEntry(""application/x-quicktimeplayer"", ""qtl"");
        sMimeTypeMap.loadEntry(""application/x-shar"", ""shar"");
        sMimeTypeMap.loadEntry(""application/x-stuffit"", ""sit"");
        sMimeTypeMap.loadEntry(""application/x-sv4cpio"", ""sv4cpio"");
        sMimeTypeMap.loadEntry(""application/x-sv4crc"", ""sv4crc"");
        sMimeTypeMap.loadEntry(""application/x-tar"", ""tar"");
        sMimeTypeMap.loadEntry(""application/x-texinfo"", ""texinfo"");
        sMimeTypeMap.loadEntry(""application/x-texinfo"", ""texi"");
        sMimeTypeMap.loadEntry(""application/x-troff"", ""t"");
        sMimeTypeMap.loadEntry(""application/x-troff"", ""roff"");
        sMimeTypeMap.loadEntry(""application/x-troff-man"", ""man"");
        sMimeTypeMap.loadEntry(""application/x-ustar"", ""ustar"");
        sMimeTypeMap.loadEntry(""application/x-wais-source"", ""src"");
        sMimeTypeMap.loadEntry(""application/x-wingz"", ""wz"");
        sMimeTypeMap.loadEntry(""application/x-webarchive"", ""webarchive"");
        sMimeTypeMap.loadEntry(""application/x-x509-ca-cert"", ""crt"");
        sMimeTypeMap.loadEntry(""application/x-x509-user-cert"", ""crt"");
        sMimeTypeMap.loadEntry(""application/x-xcf"", ""xcf"");
        sMimeTypeMap.loadEntry(""application/x-xfig"", ""fig"");
        sMimeTypeMap.loadEntry(""application/xhtml+xml"", ""xhtml"");
        sMimeTypeMap.loadEntry(""audio/basic"", ""snd"");
        sMimeTypeMap.loadEntry(""audio/midi"", ""mid"");
        sMimeTypeMap.loadEntry(""audio/midi"", ""midi"");
        sMimeTypeMap.loadEntry(""audio/midi"", ""kar"");
        sMimeTypeMap.loadEntry(""audio/mpeg"", ""mpga"");
        sMimeTypeMap.loadEntry(""audio/mpeg"", ""mpega"");
        sMimeTypeMap.loadEntry(""audio/mpeg"", ""mp2"");
        sMimeTypeMap.loadEntry(""audio/mpeg"", ""mp3"");
        sMimeTypeMap.loadEntry(""audio/mpeg"", ""m4a"");
        sMimeTypeMap.loadEntry(""audio/mpegurl"", ""m3u"");
        sMimeTypeMap.loadEntry(""audio/prs.sid"", ""sid"");
        sMimeTypeMap.loadEntry(""audio/x-aiff"", ""aif"");
        sMimeTypeMap.loadEntry(""audio/x-aiff"", ""aiff"");
        sMimeTypeMap.loadEntry(""audio/x-aiff"", ""aifc"");
        sMimeTypeMap.loadEntry(""audio/x-gsm"", ""gsm"");
        sMimeTypeMap.loadEntry(""audio/x-mpegurl"", ""m3u"");
        sMimeTypeMap.loadEntry(""audio/x-ms-wma"", ""wma"");
        sMimeTypeMap.loadEntry(""audio/x-ms-wax"", ""wax"");
        sMimeTypeMap.loadEntry(""audio/x-pn-realaudio"", ""ra"");
        sMimeTypeMap.loadEntry(""audio/x-pn-realaudio"", ""rm"");
        sMimeTypeMap.loadEntry(""audio/x-pn-realaudio"", ""ram"");
        sMimeTypeMap.loadEntry(""audio/x-realaudio"", ""ra"");
        sMimeTypeMap.loadEntry(""audio/x-scpls"", ""pls"");
        sMimeTypeMap.loadEntry(""audio/x-sd2"", ""sd2"");
        sMimeTypeMap.loadEntry(""audio/x-wav"", ""wav"");
        sMimeTypeMap.loadEntry(""image/bmp"", ""bmp"");
        sMimeTypeMap.loadEntry(""image/gif"", ""gif"");
        sMimeTypeMap.loadEntry(""image/ico"", ""cur"");
        sMimeTypeMap.loadEntry(""image/ico"", ""ico"");
        sMimeTypeMap.loadEntry(""image/ief"", ""ief"");
        sMimeTypeMap.loadEntry(""image/jpeg"", ""jpeg"");
        sMimeTypeMap.loadEntry(""image/jpeg"", ""jpg"");
        sMimeTypeMap.loadEntry(""image/jpeg"", ""jpe"");
        sMimeTypeMap.loadEntry(""image/pcx"", ""pcx"");
        sMimeTypeMap.loadEntry(""image/png"", ""png"");
        sMimeTypeMap.loadEntry(""image/svg+xml"", ""svg"");
        sMimeTypeMap.loadEntry(""image/svg+xml"", ""svgz"");
        sMimeTypeMap.loadEntry(""image/tiff"", ""tiff"");
        sMimeTypeMap.loadEntry(""image/tiff"", ""tif"");
        sMimeTypeMap.loadEntry(""image/vnd.djvu"", ""djvu"");
        sMimeTypeMap.loadEntry(""image/vnd.djvu"", ""djv"");
        sMimeTypeMap.loadEntry(""image/vnd.wap.wbmp"", ""wbmp"");
        sMimeTypeMap.loadEntry(""image/x-cmu-raster"", ""ras"");
        sMimeTypeMap.loadEntry(""image/x-coreldraw"", ""cdr"");
        sMimeTypeMap.loadEntry(""image/x-coreldrawpattern"", ""pat"");
        sMimeTypeMap.loadEntry(""image/x-coreldrawtemplate"", ""cdt"");
        sMimeTypeMap.loadEntry(""image/x-corelphotopaint"", ""cpt"");
        sMimeTypeMap.loadEntry(""image/x-icon"", ""ico"");
        sMimeTypeMap.loadEntry(""image/x-jg"", ""art"");
        sMimeTypeMap.loadEntry(""image/x-jng"", ""jng"");
        sMimeTypeMap.loadEntry(""image/x-ms-bmp"", ""bmp"");
        sMimeTypeMap.loadEntry(""image/x-photoshop"", ""psd"");
        sMimeTypeMap.loadEntry(""image/x-portable-anymap"", ""pnm"");
        sMimeTypeMap.loadEntry(""image/x-portable-bitmap"", ""pbm"");
        sMimeTypeMap.loadEntry(""image/x-portable-graymap"", ""pgm"");
        sMimeTypeMap.loadEntry(""image/x-portable-pixmap"", ""ppm"");
        sMimeTypeMap.loadEntry(""image/x-rgb"", ""rgb"");
        sMimeTypeMap.loadEntry(""image/x-xbitmap"", ""xbm"");
        sMimeTypeMap.loadEntry(""image/x-xpixmap"", ""xpm"");
        sMimeTypeMap.loadEntry(""image/x-xwindowdump"", ""xwd"");
        sMimeTypeMap.loadEntry(""model/iges"", ""igs"");
        sMimeTypeMap.loadEntry(""model/iges"", ""iges"");
        sMimeTypeMap.loadEntry(""model/mesh"", ""msh"");
        sMimeTypeMap.loadEntry(""model/mesh"", ""mesh"");
        sMimeTypeMap.loadEntry(""model/mesh"", ""silo"");
        sMimeTypeMap.loadEntry(""text/calendar"", ""ics"");
        sMimeTypeMap.loadEntry(""text/calendar"", ""icz"");
        sMimeTypeMap.loadEntry(""text/comma-separated-values"", ""csv"");
        sMimeTypeMap.loadEntry(""text/css"", ""css"");
        sMimeTypeMap.loadEntry(""text/h323"", ""323"");
        sMimeTypeMap.loadEntry(""text/iuls"", ""uls"");
        sMimeTypeMap.loadEntry(""text/mathml"", ""mml"");
        // add it first so it will be the default for ExtensionFromMimeType
        sMimeTypeMap.loadEntry(""text/plain"", ""txt"");
        sMimeTypeMap.loadEntry(""text/plain"", ""asc"");
        sMimeTypeMap.loadEntry(""text/plain"", ""text"");
        sMimeTypeMap.loadEntry(""text/plain"", ""diff"");
        // reserve ""pot"" for vnd.ms-powerpoint
        sMimeTypeMap.loadEntry(""text/plain"", ""po"");
        sMimeTypeMap.loadEntry(""text/richtext"", ""rtx"");
        sMimeTypeMap.loadEntry(""text/rtf"", ""rtf"");
        sMimeTypeMap.loadEntry(""text/texmacs"", ""ts"");
        sMimeTypeMap.loadEntry(""text/text"", ""phps"");
        sMimeTypeMap.loadEntry(""text/tab-separated-values"", ""tsv"");
        sMimeTypeMap.loadEntry(""text/xml"", ""xml"");
        sMimeTypeMap.loadEntry(""text/x-bibtex"", ""bib"");
        sMimeTypeMap.loadEntry(""text/x-boo"", ""boo"");
        sMimeTypeMap.loadEntry(""text/x-c++hdr"", ""h++"");
        sMimeTypeMap.loadEntry(""text/x-c++hdr"", ""hpp"");
        sMimeTypeMap.loadEntry(""text/x-c++hdr"", ""hxx"");
        sMimeTypeMap.loadEntry(""text/x-c++hdr"", ""hh"");
        sMimeTypeMap.loadEntry(""text/x-c++src"", ""c++"");
        sMimeTypeMap.loadEntry(""text/x-c++src"", ""cpp"");
        sMimeTypeMap.loadEntry(""text/x-c++src"", ""cxx"");
        sMimeTypeMap.loadEntry(""text/x-chdr"", ""h"");
        sMimeTypeMap.loadEntry(""text/x-component"", ""htc"");
        sMimeTypeMap.loadEntry(""text/x-csh"", ""csh"");
        sMimeTypeMap.loadEntry(""text/x-csrc"", ""c"");
        sMimeTypeMap.loadEntry(""text/x-dsrc"", ""d"");
        sMimeTypeMap.loadEntry(""text/x-haskell"", ""hs"");
        sMimeTypeMap.loadEntry(""text/x-java"", ""java"");
        sMimeTypeMap.loadEntry(""text/x-literate-haskell"", ""lhs"");
        sMimeTypeMap.loadEntry(""text/x-moc"", ""moc"");
        sMimeTypeMap.loadEntry(""text/x-pascal"", ""p"");
        sMimeTypeMap.loadEntry(""text/x-pascal"", ""pas"");
        sMimeTypeMap.loadEntry(""text/x-pcs-gcd"", ""gcd"");
        sMimeTypeMap.loadEntry(""text/x-setext"", ""etx"");
        sMimeTypeMap.loadEntry(""text/x-tcl"", ""tcl"");
        sMimeTypeMap.loadEntry(""text/x-tex"", ""tex"");
        sMimeTypeMap.loadEntry(""text/x-tex"", ""ltx"");
        sMimeTypeMap.loadEntry(""text/x-tex"", ""sty"");
        sMimeTypeMap.loadEntry(""text/x-tex"", ""cls"");
        sMimeTypeMap.loadEntry(""text/x-vcalendar"", ""vcs"");
        sMimeTypeMap.loadEntry(""text/x-vcard"", ""vcf"");
        sMimeTypeMap.loadEntry(""video/3gpp"", ""3gp"");
        sMimeTypeMap.loadEntry(""video/3gpp"", ""3g2"");
        sMimeTypeMap.loadEntry(""video/dl"", ""dl"");
        sMimeTypeMap.loadEntry(""video/dv"", ""dif"");
        sMimeTypeMap.loadEntry(""video/dv"", ""dv"");
        sMimeTypeMap.loadEntry(""video/fli"", ""fli"");
        sMimeTypeMap.loadEntry(""video/mpeg"", ""mpeg"");
        sMimeTypeMap.loadEntry(""video/mpeg"", ""mpg"");
        sMimeTypeMap.loadEntry(""video/mpeg"", ""mpe"");
        sMimeTypeMap.loadEntry(""video/mp4"", ""mp4"");
        sMimeTypeMap.loadEntry(""video/mpeg"", ""VOB"");
        sMimeTypeMap.loadEntry(""video/quicktime"", ""qt"");
        sMimeTypeMap.loadEntry(""video/quicktime"", ""mov"");
        sMimeTypeMap.loadEntry(""video/vnd.mpegurl"", ""mxu"");
        sMimeTypeMap.loadEntry(""video/x-la-asf"", ""lsf"");
        sMimeTypeMap.loadEntry(""video/x-la-asf"", ""lsx"");
        sMimeTypeMap.loadEntry(""video/x-mng"", ""mng"");
        sMimeTypeMap.loadEntry(""video/x-ms-asf"", ""asf"");
        sMimeTypeMap.loadEntry(""video/x-ms-asf"", ""asx"");
        sMimeTypeMap.loadEntry(""video/x-ms-wm"", ""wm"");
        sMimeTypeMap.loadEntry(""video/x-ms-wmv"", ""wmv"");
        sMimeTypeMap.loadEntry(""video/x-ms-wmx"", ""wmx"");
        sMimeTypeMap.loadEntry(""video/x-ms-wvx"", ""wvx"");
        sMimeTypeMap.loadEntry(""video/x-msvideo"", ""avi"");
        sMimeTypeMap.loadEntry(""video/x-sgi-movie"", ""movie"");
        sMimeTypeMap.loadEntry(""x-conference/x-cooltalk"", ""ice"");
        sMimeTypeMap.loadEntry(""x-epoc/x-sisx-app"", ""sisx"");
    }
    return sMimeTypeMap;
}","{
    if (sMimeTypeMap == null) {
        sMimeTypeMap = new MimeTypeMap();
        // The following table is based on /etc/mime.types data minus
        // chemical/* MIME types and MIME types that don't map to any
        // file extensions. We also exclude top-level domain names to
        // deal with cases like:
        // 
        // mail.google.com/a/google.com
        // 
        // and ""active"" MIME types (due to potential security issues).
        sMimeTypeMap.loadEntry(""application/andrew-inset"", ""ez"");
        sMimeTypeMap.loadEntry(""application/dsptype"", ""tsp"");
        sMimeTypeMap.loadEntry(""application/futuresplash"", ""spl"");
        sMimeTypeMap.loadEntry(""application/hta"", ""hta"");
        sMimeTypeMap.loadEntry(""application/mac-binhex40"", ""hqx"");
        sMimeTypeMap.loadEntry(""application/mac-compactpro"", ""cpt"");
        sMimeTypeMap.loadEntry(""application/mathematica"", ""nb"");
        sMimeTypeMap.loadEntry(""application/msaccess"", ""mdb"");
        sMimeTypeMap.loadEntry(""application/oda"", ""oda"");
        sMimeTypeMap.loadEntry(""application/ogg"", ""ogg"");
        sMimeTypeMap.loadEntry(""application/pdf"", ""pdf"");
        sMimeTypeMap.loadEntry(""application/pgp-keys"", ""key"");
        sMimeTypeMap.loadEntry(""application/pgp-signature"", ""pgp"");
        sMimeTypeMap.loadEntry(""application/pics-rules"", ""prf"");
        sMimeTypeMap.loadEntry(""application/rar"", ""rar"");
        sMimeTypeMap.loadEntry(""application/rdf+xml"", ""rdf"");
        sMimeTypeMap.loadEntry(""application/rss+xml"", ""rss"");
        sMimeTypeMap.loadEntry(""application/zip"", ""zip"");
        sMimeTypeMap.loadEntry(""application/vnd.android.package-archive"", ""apk"");
        sMimeTypeMap.loadEntry(""application/vnd.cinderella"", ""cdy"");
        sMimeTypeMap.loadEntry(""application/vnd.ms-pki.stl"", ""stl"");
        sMimeTypeMap.loadEntry(""application/vnd.oasis.opendocument.database"", ""odb"");
        sMimeTypeMap.loadEntry(""application/vnd.oasis.opendocument.formula"", ""odf"");
        sMimeTypeMap.loadEntry(""application/vnd.oasis.opendocument.graphics"", ""odg"");
        sMimeTypeMap.loadEntry(""application/vnd.oasis.opendocument.graphics-template"", ""otg"");
        sMimeTypeMap.loadEntry(""application/vnd.oasis.opendocument.image"", ""odi"");
        sMimeTypeMap.loadEntry(""application/vnd.oasis.opendocument.spreadsheet"", ""ods"");
        sMimeTypeMap.loadEntry(""application/vnd.oasis.opendocument.spreadsheet-template"", ""ots"");
        sMimeTypeMap.loadEntry(""application/vnd.oasis.opendocument.text"", ""odt"");
        sMimeTypeMap.loadEntry(""application/vnd.oasis.opendocument.text-master"", ""odm"");
        sMimeTypeMap.loadEntry(""application/vnd.oasis.opendocument.text-template"", ""ott"");
        sMimeTypeMap.loadEntry(""application/vnd.oasis.opendocument.text-web"", ""oth"");
        sMimeTypeMap.loadEntry(""application/msword"", ""doc"");
        sMimeTypeMap.loadEntry(""application/msword"", ""dot"");
        sMimeTypeMap.loadEntry(""application/vnd.openxmlformats-officedocument.wordprocessingml.document"", ""docx"");
        sMimeTypeMap.loadEntry(""application/vnd.openxmlformats-officedocument.wordprocessingml.template"", ""dotx"");
        sMimeTypeMap.loadEntry(""application/vnd.ms-excel"", ""xls"");
        sMimeTypeMap.loadEntry(""application/vnd.ms-excel"", ""xlt"");
        sMimeTypeMap.loadEntry(""application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"", ""xlsx"");
        sMimeTypeMap.loadEntry(""application/vnd.openxmlformats-officedocument.spreadsheetml.template"", ""xltx"");
        sMimeTypeMap.loadEntry(""application/vnd.ms-powerpoint"", ""ppt"");
        sMimeTypeMap.loadEntry(""application/vnd.ms-powerpoint"", ""pot"");
        sMimeTypeMap.loadEntry(""application/vnd.ms-powerpoint"", ""pps"");
        sMimeTypeMap.loadEntry(""application/vnd.openxmlformats-officedocument.presentationml.presentation"", ""pptx"");
        sMimeTypeMap.loadEntry(""application/vnd.openxmlformats-officedocument.presentationml.template"", ""potx"");
        sMimeTypeMap.loadEntry(""application/vnd.openxmlformats-officedocument.presentationml.slideshow"", ""ppsx"");
        sMimeTypeMap.loadEntry(""application/vnd.rim.cod"", ""cod"");
        sMimeTypeMap.loadEntry(""application/vnd.smaf"", ""mmf"");
        sMimeTypeMap.loadEntry(""application/vnd.stardivision.calc"", ""sdc"");
        sMimeTypeMap.loadEntry(""application/vnd.stardivision.draw"", ""sda"");
        sMimeTypeMap.loadEntry(""application/vnd.stardivision.impress"", ""sdd"");
        sMimeTypeMap.loadEntry(""application/vnd.stardivision.impress"", ""sdp"");
        sMimeTypeMap.loadEntry(""application/vnd.stardivision.math"", ""smf"");
        sMimeTypeMap.loadEntry(""application/vnd.stardivision.writer"", ""sdw"");
        sMimeTypeMap.loadEntry(""application/vnd.stardivision.writer"", ""vor"");
        sMimeTypeMap.loadEntry(""application/vnd.stardivision.writer-global"", ""sgl"");
        sMimeTypeMap.loadEntry(""application/vnd.sun.xml.calc"", ""sxc"");
        sMimeTypeMap.loadEntry(""application/vnd.sun.xml.calc.template"", ""stc"");
        sMimeTypeMap.loadEntry(""application/vnd.sun.xml.draw"", ""sxd"");
        sMimeTypeMap.loadEntry(""application/vnd.sun.xml.draw.template"", ""std"");
        sMimeTypeMap.loadEntry(""application/vnd.sun.xml.impress"", ""sxi"");
        sMimeTypeMap.loadEntry(""application/vnd.sun.xml.impress.template"", ""sti"");
        sMimeTypeMap.loadEntry(""application/vnd.sun.xml.math"", ""sxm"");
        sMimeTypeMap.loadEntry(""application/vnd.sun.xml.writer"", ""sxw"");
        sMimeTypeMap.loadEntry(""application/vnd.sun.xml.writer.global"", ""sxg"");
        sMimeTypeMap.loadEntry(""application/vnd.sun.xml.writer.template"", ""stw"");
        sMimeTypeMap.loadEntry(""application/vnd.visio"", ""vsd"");
        sMimeTypeMap.loadEntry(""application/x-abiword"", ""abw"");
        sMimeTypeMap.loadEntry(""application/x-apple-diskimage"", ""dmg"");
        sMimeTypeMap.loadEntry(""application/x-bcpio"", ""bcpio"");
        sMimeTypeMap.loadEntry(""application/x-bittorrent"", ""torrent"");
        sMimeTypeMap.loadEntry(""application/x-cdf"", ""cdf"");
        sMimeTypeMap.loadEntry(""application/x-cdlink"", ""vcd"");
        sMimeTypeMap.loadEntry(""application/x-chess-pgn"", ""pgn"");
        sMimeTypeMap.loadEntry(""application/x-cpio"", ""cpio"");
        sMimeTypeMap.loadEntry(""application/x-debian-package"", ""deb"");
        sMimeTypeMap.loadEntry(""application/x-debian-package"", ""udeb"");
        sMimeTypeMap.loadEntry(""application/x-director"", ""dcr"");
        sMimeTypeMap.loadEntry(""application/x-director"", ""dir"");
        sMimeTypeMap.loadEntry(""application/x-director"", ""dxr"");
        sMimeTypeMap.loadEntry(""application/x-dms"", ""dms"");
        sMimeTypeMap.loadEntry(""application/x-doom"", ""wad"");
        sMimeTypeMap.loadEntry(""application/x-dvi"", ""dvi"");
        sMimeTypeMap.loadEntry(""application/x-flac"", ""flac"");
        sMimeTypeMap.loadEntry(""application/x-font"", ""pfa"");
        sMimeTypeMap.loadEntry(""application/x-font"", ""pfb"");
        sMimeTypeMap.loadEntry(""application/x-font"", ""gsf"");
        sMimeTypeMap.loadEntry(""application/x-font"", ""pcf"");
        sMimeTypeMap.loadEntry(""application/x-font"", ""pcf.Z"");
        sMimeTypeMap.loadEntry(""application/x-freemind"", ""mm"");
        sMimeTypeMap.loadEntry(""application/x-futuresplash"", ""spl"");
        sMimeTypeMap.loadEntry(""application/x-gnumeric"", ""gnumeric"");
        sMimeTypeMap.loadEntry(""application/x-go-sgf"", ""sgf"");
        sMimeTypeMap.loadEntry(""application/x-graphing-calculator"", ""gcf"");
        sMimeTypeMap.loadEntry(""application/x-gtar"", ""gtar"");
        sMimeTypeMap.loadEntry(""application/x-gtar"", ""tgz"");
        sMimeTypeMap.loadEntry(""application/x-gtar"", ""taz"");
        sMimeTypeMap.loadEntry(""application/x-hdf"", ""hdf"");
        sMimeTypeMap.loadEntry(""application/x-ica"", ""ica"");
        sMimeTypeMap.loadEntry(""application/x-internet-signup"", ""ins"");
        sMimeTypeMap.loadEntry(""application/x-internet-signup"", ""isp"");
        sMimeTypeMap.loadEntry(""application/x-iphone"", ""iii"");
        sMimeTypeMap.loadEntry(""application/x-iso9660-image"", ""iso"");
        sMimeTypeMap.loadEntry(""application/x-jmol"", ""jmz"");
        sMimeTypeMap.loadEntry(""application/x-kchart"", ""chrt"");
        sMimeTypeMap.loadEntry(""application/x-killustrator"", ""kil"");
        sMimeTypeMap.loadEntry(""application/x-koan"", ""skp"");
        sMimeTypeMap.loadEntry(""application/x-koan"", ""skd"");
        sMimeTypeMap.loadEntry(""application/x-koan"", ""skt"");
        sMimeTypeMap.loadEntry(""application/x-koan"", ""skm"");
        sMimeTypeMap.loadEntry(""application/x-kpresenter"", ""kpr"");
        sMimeTypeMap.loadEntry(""application/x-kpresenter"", ""kpt"");
        sMimeTypeMap.loadEntry(""application/x-kspread"", ""ksp"");
        sMimeTypeMap.loadEntry(""application/x-kword"", ""kwd"");
        sMimeTypeMap.loadEntry(""application/x-kword"", ""kwt"");
        sMimeTypeMap.loadEntry(""application/x-latex"", ""latex"");
        sMimeTypeMap.loadEntry(""application/x-lha"", ""lha"");
        sMimeTypeMap.loadEntry(""application/x-lzh"", ""lzh"");
        sMimeTypeMap.loadEntry(""application/x-lzx"", ""lzx"");
        sMimeTypeMap.loadEntry(""application/x-maker"", ""frm"");
        sMimeTypeMap.loadEntry(""application/x-maker"", ""maker"");
        sMimeTypeMap.loadEntry(""application/x-maker"", ""frame"");
        sMimeTypeMap.loadEntry(""application/x-maker"", ""fb"");
        sMimeTypeMap.loadEntry(""application/x-maker"", ""book"");
        sMimeTypeMap.loadEntry(""application/x-maker"", ""fbdoc"");
        sMimeTypeMap.loadEntry(""application/x-mif"", ""mif"");
        sMimeTypeMap.loadEntry(""application/x-ms-wmd"", ""wmd"");
        sMimeTypeMap.loadEntry(""application/x-ms-wmz"", ""wmz"");
        sMimeTypeMap.loadEntry(""application/x-msi"", ""msi"");
        sMimeTypeMap.loadEntry(""application/x-ns-proxy-autoconfig"", ""pac"");
        sMimeTypeMap.loadEntry(""application/x-nwc"", ""nwc"");
        sMimeTypeMap.loadEntry(""application/x-object"", ""o"");
        sMimeTypeMap.loadEntry(""application/x-oz-application"", ""oza"");
        sMimeTypeMap.loadEntry(""application/x-pkcs12"", ""p12"");
        sMimeTypeMap.loadEntry(""application/x-pkcs7-certreqresp"", ""p7r"");
        sMimeTypeMap.loadEntry(""application/x-pkcs7-crl"", ""crl"");
        sMimeTypeMap.loadEntry(""application/x-quicktimeplayer"", ""qtl"");
        sMimeTypeMap.loadEntry(""application/x-shar"", ""shar"");
        sMimeTypeMap.loadEntry(""application/x-shockwave-flash"", ""swf"");
        sMimeTypeMap.loadEntry(""application/x-stuffit"", ""sit"");
        sMimeTypeMap.loadEntry(""application/x-sv4cpio"", ""sv4cpio"");
        sMimeTypeMap.loadEntry(""application/x-sv4crc"", ""sv4crc"");
        sMimeTypeMap.loadEntry(""application/x-tar"", ""tar"");
        sMimeTypeMap.loadEntry(""application/x-texinfo"", ""texinfo"");
        sMimeTypeMap.loadEntry(""application/x-texinfo"", ""texi"");
        sMimeTypeMap.loadEntry(""application/x-troff"", ""t"");
        sMimeTypeMap.loadEntry(""application/x-troff"", ""roff"");
        sMimeTypeMap.loadEntry(""application/x-troff-man"", ""man"");
        sMimeTypeMap.loadEntry(""application/x-ustar"", ""ustar"");
        sMimeTypeMap.loadEntry(""application/x-wais-source"", ""src"");
        sMimeTypeMap.loadEntry(""application/x-wingz"", ""wz"");
        sMimeTypeMap.loadEntry(""application/x-webarchive"", ""webarchive"");
        sMimeTypeMap.loadEntry(""application/x-x509-ca-cert"", ""crt"");
        sMimeTypeMap.loadEntry(""application/x-x509-user-cert"", ""crt"");
        sMimeTypeMap.loadEntry(""application/x-xcf"", ""xcf"");
        sMimeTypeMap.loadEntry(""application/x-xfig"", ""fig"");
        sMimeTypeMap.loadEntry(""application/xhtml+xml"", ""xhtml"");
        sMimeTypeMap.loadEntry(""audio/3gpp"", ""3gpp"");
        sMimeTypeMap.loadEntry(""audio/basic"", ""snd"");
        sMimeTypeMap.loadEntry(""audio/midi"", ""mid"");
        sMimeTypeMap.loadEntry(""audio/midi"", ""midi"");
        sMimeTypeMap.loadEntry(""audio/midi"", ""kar"");
        sMimeTypeMap.loadEntry(""audio/mpeg"", ""mpga"");
        sMimeTypeMap.loadEntry(""audio/mpeg"", ""mpega"");
        sMimeTypeMap.loadEntry(""audio/mpeg"", ""mp2"");
        sMimeTypeMap.loadEntry(""audio/mpeg"", ""mp3"");
        sMimeTypeMap.loadEntry(""audio/mpeg"", ""m4a"");
        sMimeTypeMap.loadEntry(""audio/mpegurl"", ""m3u"");
        sMimeTypeMap.loadEntry(""audio/prs.sid"", ""sid"");
        sMimeTypeMap.loadEntry(""audio/x-aiff"", ""aif"");
        sMimeTypeMap.loadEntry(""audio/x-aiff"", ""aiff"");
        sMimeTypeMap.loadEntry(""audio/x-aiff"", ""aifc"");
        sMimeTypeMap.loadEntry(""audio/x-gsm"", ""gsm"");
        sMimeTypeMap.loadEntry(""audio/x-mpegurl"", ""m3u"");
        sMimeTypeMap.loadEntry(""audio/x-ms-wma"", ""wma"");
        sMimeTypeMap.loadEntry(""audio/x-ms-wax"", ""wax"");
        sMimeTypeMap.loadEntry(""audio/x-pn-realaudio"", ""ra"");
        sMimeTypeMap.loadEntry(""audio/x-pn-realaudio"", ""rm"");
        sMimeTypeMap.loadEntry(""audio/x-pn-realaudio"", ""ram"");
        sMimeTypeMap.loadEntry(""audio/x-realaudio"", ""ra"");
        sMimeTypeMap.loadEntry(""audio/x-scpls"", ""pls"");
        sMimeTypeMap.loadEntry(""audio/x-sd2"", ""sd2"");
        sMimeTypeMap.loadEntry(""audio/x-wav"", ""wav"");
        sMimeTypeMap.loadEntry(""image/bmp"", ""bmp"");
        sMimeTypeMap.loadEntry(""image/gif"", ""gif"");
        sMimeTypeMap.loadEntry(""image/ico"", ""cur"");
        sMimeTypeMap.loadEntry(""image/ico"", ""ico"");
        sMimeTypeMap.loadEntry(""image/ief"", ""ief"");
        sMimeTypeMap.loadEntry(""image/jpeg"", ""jpeg"");
        sMimeTypeMap.loadEntry(""image/jpeg"", ""jpg"");
        sMimeTypeMap.loadEntry(""image/jpeg"", ""jpe"");
        sMimeTypeMap.loadEntry(""image/pcx"", ""pcx"");
        sMimeTypeMap.loadEntry(""image/png"", ""png"");
        sMimeTypeMap.loadEntry(""image/svg+xml"", ""svg"");
        sMimeTypeMap.loadEntry(""image/svg+xml"", ""svgz"");
        sMimeTypeMap.loadEntry(""image/tiff"", ""tiff"");
        sMimeTypeMap.loadEntry(""image/tiff"", ""tif"");
        sMimeTypeMap.loadEntry(""image/vnd.djvu"", ""djvu"");
        sMimeTypeMap.loadEntry(""image/vnd.djvu"", ""djv"");
        sMimeTypeMap.loadEntry(""image/vnd.wap.wbmp"", ""wbmp"");
        sMimeTypeMap.loadEntry(""image/x-cmu-raster"", ""ras"");
        sMimeTypeMap.loadEntry(""image/x-coreldraw"", ""cdr"");
        sMimeTypeMap.loadEntry(""image/x-coreldrawpattern"", ""pat"");
        sMimeTypeMap.loadEntry(""image/x-coreldrawtemplate"", ""cdt"");
        sMimeTypeMap.loadEntry(""image/x-corelphotopaint"", ""cpt"");
        sMimeTypeMap.loadEntry(""image/x-icon"", ""ico"");
        sMimeTypeMap.loadEntry(""image/x-jg"", ""art"");
        sMimeTypeMap.loadEntry(""image/x-jng"", ""jng"");
        sMimeTypeMap.loadEntry(""image/x-ms-bmp"", ""bmp"");
        sMimeTypeMap.loadEntry(""image/x-photoshop"", ""psd"");
        sMimeTypeMap.loadEntry(""image/x-portable-anymap"", ""pnm"");
        sMimeTypeMap.loadEntry(""image/x-portable-bitmap"", ""pbm"");
        sMimeTypeMap.loadEntry(""image/x-portable-graymap"", ""pgm"");
        sMimeTypeMap.loadEntry(""image/x-portable-pixmap"", ""ppm"");
        sMimeTypeMap.loadEntry(""image/x-rgb"", ""rgb"");
        sMimeTypeMap.loadEntry(""image/x-xbitmap"", ""xbm"");
        sMimeTypeMap.loadEntry(""image/x-xpixmap"", ""xpm"");
        sMimeTypeMap.loadEntry(""image/x-xwindowdump"", ""xwd"");
        sMimeTypeMap.loadEntry(""model/iges"", ""igs"");
        sMimeTypeMap.loadEntry(""model/iges"", ""iges"");
        sMimeTypeMap.loadEntry(""model/mesh"", ""msh"");
        sMimeTypeMap.loadEntry(""model/mesh"", ""mesh"");
        sMimeTypeMap.loadEntry(""model/mesh"", ""silo"");
        sMimeTypeMap.loadEntry(""text/calendar"", ""ics"");
        sMimeTypeMap.loadEntry(""text/calendar"", ""icz"");
        sMimeTypeMap.loadEntry(""text/comma-separated-values"", ""csv"");
        sMimeTypeMap.loadEntry(""text/css"", ""css"");
        sMimeTypeMap.loadEntry(""text/html"", ""htm"");
        sMimeTypeMap.loadEntry(""text/html"", ""html"");
        sMimeTypeMap.loadEntry(""text/h323"", ""323"");
        sMimeTypeMap.loadEntry(""text/iuls"", ""uls"");
        sMimeTypeMap.loadEntry(""text/mathml"", ""mml"");
        // add it first so it will be the default for ExtensionFromMimeType
        sMimeTypeMap.loadEntry(""text/plain"", ""txt"");
        sMimeTypeMap.loadEntry(""text/plain"", ""asc"");
        sMimeTypeMap.loadEntry(""text/plain"", ""text"");
        sMimeTypeMap.loadEntry(""text/plain"", ""diff"");
        // reserve ""pot"" for vnd.ms-powerpoint
        sMimeTypeMap.loadEntry(""text/plain"", ""po"");
        sMimeTypeMap.loadEntry(""text/richtext"", ""rtx"");
        sMimeTypeMap.loadEntry(""text/rtf"", ""rtf"");
        sMimeTypeMap.loadEntry(""text/texmacs"", ""ts"");
        sMimeTypeMap.loadEntry(""text/text"", ""phps"");
        sMimeTypeMap.loadEntry(""text/tab-separated-values"", ""tsv"");
        sMimeTypeMap.loadEntry(""text/xml"", ""xml"");
        sMimeTypeMap.loadEntry(""text/x-bibtex"", ""bib"");
        sMimeTypeMap.loadEntry(""text/x-boo"", ""boo"");
        sMimeTypeMap.loadEntry(""text/x-c++hdr"", ""h++"");
        sMimeTypeMap.loadEntry(""text/x-c++hdr"", ""hpp"");
        sMimeTypeMap.loadEntry(""text/x-c++hdr"", ""hxx"");
        sMimeTypeMap.loadEntry(""text/x-c++hdr"", ""hh"");
        sMimeTypeMap.loadEntry(""text/x-c++src"", ""c++"");
        sMimeTypeMap.loadEntry(""text/x-c++src"", ""cpp"");
        sMimeTypeMap.loadEntry(""text/x-c++src"", ""cxx"");
        sMimeTypeMap.loadEntry(""text/x-chdr"", ""h"");
        sMimeTypeMap.loadEntry(""text/x-component"", ""htc"");
        sMimeTypeMap.loadEntry(""text/x-csh"", ""csh"");
        sMimeTypeMap.loadEntry(""text/x-csrc"", ""c"");
        sMimeTypeMap.loadEntry(""text/x-dsrc"", ""d"");
        sMimeTypeMap.loadEntry(""text/x-haskell"", ""hs"");
        sMimeTypeMap.loadEntry(""text/x-java"", ""java"");
        sMimeTypeMap.loadEntry(""text/x-literate-haskell"", ""lhs"");
        sMimeTypeMap.loadEntry(""text/x-moc"", ""moc"");
        sMimeTypeMap.loadEntry(""text/x-pascal"", ""p"");
        sMimeTypeMap.loadEntry(""text/x-pascal"", ""pas"");
        sMimeTypeMap.loadEntry(""text/x-pcs-gcd"", ""gcd"");
        sMimeTypeMap.loadEntry(""text/x-setext"", ""etx"");
        sMimeTypeMap.loadEntry(""text/x-tcl"", ""tcl"");
        sMimeTypeMap.loadEntry(""text/x-tex"", ""tex"");
        sMimeTypeMap.loadEntry(""text/x-tex"", ""ltx"");
        sMimeTypeMap.loadEntry(""text/x-tex"", ""sty"");
        sMimeTypeMap.loadEntry(""text/x-tex"", ""cls"");
        sMimeTypeMap.loadEntry(""text/x-vcalendar"", ""vcs"");
        sMimeTypeMap.loadEntry(""text/x-vcard"", ""vcf"");
        sMimeTypeMap.loadEntry(""video/3gpp"", ""3gpp"");
        sMimeTypeMap.loadEntry(""video/3gpp"", ""3gp"");
        sMimeTypeMap.loadEntry(""video/3gpp"", ""3g2"");
        sMimeTypeMap.loadEntry(""video/dl"", ""dl"");
        sMimeTypeMap.loadEntry(""video/dv"", ""dif"");
        sMimeTypeMap.loadEntry(""video/dv"", ""dv"");
        sMimeTypeMap.loadEntry(""video/fli"", ""fli"");
        sMimeTypeMap.loadEntry(""video/m4v"", ""m4v"");
        sMimeTypeMap.loadEntry(""video/mpeg"", ""mpeg"");
        sMimeTypeMap.loadEntry(""video/mpeg"", ""mpg"");
        sMimeTypeMap.loadEntry(""video/mpeg"", ""mpe"");
        sMimeTypeMap.loadEntry(""video/mp4"", ""mp4"");
        sMimeTypeMap.loadEntry(""video/mpeg"", ""VOB"");
        sMimeTypeMap.loadEntry(""video/quicktime"", ""qt"");
        sMimeTypeMap.loadEntry(""video/quicktime"", ""mov"");
        sMimeTypeMap.loadEntry(""video/vnd.mpegurl"", ""mxu"");
        sMimeTypeMap.loadEntry(""video/x-la-asf"", ""lsf"");
        sMimeTypeMap.loadEntry(""video/x-la-asf"", ""lsx"");
        sMimeTypeMap.loadEntry(""video/x-mng"", ""mng"");
        sMimeTypeMap.loadEntry(""video/x-ms-asf"", ""asf"");
        sMimeTypeMap.loadEntry(""video/x-ms-asf"", ""asx"");
        sMimeTypeMap.loadEntry(""video/x-ms-wm"", ""wm"");
        sMimeTypeMap.loadEntry(""video/x-ms-wmv"", ""wmv"");
        sMimeTypeMap.loadEntry(""video/x-ms-wmx"", ""wmx"");
        sMimeTypeMap.loadEntry(""video/x-ms-wvx"", ""wvx"");
        sMimeTypeMap.loadEntry(""video/x-msvideo"", ""avi"");
        sMimeTypeMap.loadEntry(""video/x-sgi-movie"", ""movie"");
        sMimeTypeMap.loadEntry(""x-conference/x-cooltalk"", ""ice"");
        sMimeTypeMap.loadEntry(""x-epoc/x-sisx-app"", ""sisx"");
    }
    return sMimeTypeMap;
}",1,"/**
 * Get the singleton instance of MimeTypeMap.
 * @return The singleton instance of the MIME-type map.
 */
","/**
 * Get the singleton instance of MimeTypeMap.
 * @return The singleton instance of the MIME-type map.
 */
",-1,,,-1,-1,-1,-1,-1,-1,,,,
276,<android.content.res.Configuration: int diff(Configuration)>,7,8,<android.content.res.Configuration: int diff(Configuration)>,<android.content.res.Configuration: int diff(Configuration)>,0,"{
    int changed = 0;
    if (delta.fontScale > 0 && fontScale != delta.fontScale) {
        changed |= ActivityInfo.CONFIG_FONT_SCALE;
    }
    if (delta.mcc != 0 && mcc != delta.mcc) {
        changed |= ActivityInfo.CONFIG_MCC;
    }
    if (delta.mnc != 0 && mnc != delta.mnc) {
        changed |= ActivityInfo.CONFIG_MNC;
    }
    if (delta.locale != null && (locale == null || !locale.equals(delta.locale))) {
        changed |= ActivityInfo.CONFIG_LOCALE;
    }
    if (delta.touchscreen != TOUCHSCREEN_UNDEFINED && touchscreen != delta.touchscreen) {
        changed |= ActivityInfo.CONFIG_TOUCHSCREEN;
    }
    if (delta.keyboard != KEYBOARD_UNDEFINED && keyboard != delta.keyboard) {
        changed |= ActivityInfo.CONFIG_KEYBOARD;
    }
    if (delta.keyboardHidden != KEYBOARDHIDDEN_UNDEFINED && keyboardHidden != delta.keyboardHidden) {
        changed |= ActivityInfo.CONFIG_KEYBOARD_HIDDEN;
    }
    if (delta.hardKeyboardHidden != HARDKEYBOARDHIDDEN_UNDEFINED && hardKeyboardHidden != delta.hardKeyboardHidden) {
        changed |= ActivityInfo.CONFIG_KEYBOARD_HIDDEN;
    }
    if (delta.navigation != NAVIGATION_UNDEFINED && navigation != delta.navigation) {
        changed |= ActivityInfo.CONFIG_NAVIGATION;
    }
    if (delta.navigationHidden != NAVIGATIONHIDDEN_UNDEFINED && navigationHidden != delta.navigationHidden) {
        changed |= ActivityInfo.CONFIG_KEYBOARD_HIDDEN;
    }
    if (delta.orientation != ORIENTATION_UNDEFINED && orientation != delta.orientation) {
        changed |= ActivityInfo.CONFIG_ORIENTATION;
    }
    if (delta.screenLayout != SCREENLAYOUT_SIZE_UNDEFINED && screenLayout != delta.screenLayout) {
        changed |= ActivityInfo.CONFIG_SCREEN_LAYOUT;
    }
    return changed;
}","{
    int changed = 0;
    if (delta.fontScale > 0 && fontScale != delta.fontScale) {
        changed |= ActivityInfo.CONFIG_FONT_SCALE;
    }
    if (delta.mcc != 0 && mcc != delta.mcc) {
        changed |= ActivityInfo.CONFIG_MCC;
    }
    if (delta.mnc != 0 && mnc != delta.mnc) {
        changed |= ActivityInfo.CONFIG_MNC;
    }
    if (delta.locale != null && (locale == null || !locale.equals(delta.locale))) {
        changed |= ActivityInfo.CONFIG_LOCALE;
    }
    if (delta.touchscreen != TOUCHSCREEN_UNDEFINED && touchscreen != delta.touchscreen) {
        changed |= ActivityInfo.CONFIG_TOUCHSCREEN;
    }
    if (delta.keyboard != KEYBOARD_UNDEFINED && keyboard != delta.keyboard) {
        changed |= ActivityInfo.CONFIG_KEYBOARD;
    }
    if (delta.keyboardHidden != KEYBOARDHIDDEN_UNDEFINED && keyboardHidden != delta.keyboardHidden) {
        changed |= ActivityInfo.CONFIG_KEYBOARD_HIDDEN;
    }
    if (delta.hardKeyboardHidden != HARDKEYBOARDHIDDEN_UNDEFINED && hardKeyboardHidden != delta.hardKeyboardHidden) {
        changed |= ActivityInfo.CONFIG_KEYBOARD_HIDDEN;
    }
    if (delta.navigation != NAVIGATION_UNDEFINED && navigation != delta.navigation) {
        changed |= ActivityInfo.CONFIG_NAVIGATION;
    }
    if (delta.navigationHidden != NAVIGATIONHIDDEN_UNDEFINED && navigationHidden != delta.navigationHidden) {
        changed |= ActivityInfo.CONFIG_KEYBOARD_HIDDEN;
    }
    if (delta.orientation != ORIENTATION_UNDEFINED && orientation != delta.orientation) {
        changed |= ActivityInfo.CONFIG_ORIENTATION;
    }
    if (delta.screenLayout != SCREENLAYOUT_SIZE_UNDEFINED && screenLayout != delta.screenLayout) {
        changed |= ActivityInfo.CONFIG_SCREEN_LAYOUT;
    }
    if (delta.uiMode != (UI_MODE_TYPE_UNDEFINED | UI_MODE_NIGHT_UNDEFINED) && uiMode != delta.uiMode) {
        changed |= ActivityInfo.CONFIG_UI_MODE;
    }
    return changed;
}",1,"/**
 * Return a bit mask of the differences between this Configuration
 * object and the given one.  Does not change the values of either.  Any
 * undefined fields in <var>delta</var> are ignored.
 * @return Returns a bit mask indicating which configuration
 * values has changed, containing any combination of
 * {@link android.content.pm.ActivityInfo#CONFIG_FONT_SCALE
 * PackageManager.ActivityInfo.CONFIG_FONT_SCALE},
 * {@link android.content.pm.ActivityInfo#CONFIG_MCC
 * PackageManager.ActivityInfo.CONFIG_MCC},
 * {@link android.content.pm.ActivityInfo#CONFIG_MNC
 * PackageManager.ActivityInfo.CONFIG_MNC},
 * {@link android.content.pm.ActivityInfo#CONFIG_LOCALE
 * PackageManager.ActivityInfo.CONFIG_LOCALE},
 * {@link android.content.pm.ActivityInfo#CONFIG_TOUCHSCREEN
 * PackageManager.ActivityInfo.CONFIG_TOUCHSCREEN},
 * {@link android.content.pm.ActivityInfo#CONFIG_KEYBOARD
 * PackageManager.ActivityInfo.CONFIG_KEYBOARD},
 * {@link android.content.pm.ActivityInfo#CONFIG_NAVIGATION
 * PackageManager.ActivityInfo.CONFIG_NAVIGATION},
 * {@link android.content.pm.ActivityInfo#CONFIG_ORIENTATION
 * PackageManager.ActivityInfo.CONFIG_ORIENTATION}, or
 * {@link android.content.pm.ActivityInfo#CONFIG_SCREEN_LAYOUT
 * PackageManager.ActivityInfo.CONFIG_SCREEN_LAYOUT}.
 */
","/**
 * Return a bit mask of the differences between this Configuration
 * object and the given one.  Does not change the values of either.  Any
 * undefined fields in <var>delta</var> are ignored.
 * @return Returns a bit mask indicating which configuration
 * values has changed, containing any combination of
 * {@link android.content.pm.ActivityInfo#CONFIG_FONT_SCALE
 * PackageManager.ActivityInfo.CONFIG_FONT_SCALE},
 * {@link android.content.pm.ActivityInfo#CONFIG_MCC
 * PackageManager.ActivityInfo.CONFIG_MCC},
 * {@link android.content.pm.ActivityInfo#CONFIG_MNC
 * PackageManager.ActivityInfo.CONFIG_MNC},
 * {@link android.content.pm.ActivityInfo#CONFIG_LOCALE
 * PackageManager.ActivityInfo.CONFIG_LOCALE},
 * {@link android.content.pm.ActivityInfo#CONFIG_TOUCHSCREEN
 * PackageManager.ActivityInfo.CONFIG_TOUCHSCREEN},
 * {@link android.content.pm.ActivityInfo#CONFIG_KEYBOARD
 * PackageManager.ActivityInfo.CONFIG_KEYBOARD},
 * {@link android.content.pm.ActivityInfo#CONFIG_NAVIGATION
 * PackageManager.ActivityInfo.CONFIG_NAVIGATION},
 * {@link android.content.pm.ActivityInfo#CONFIG_ORIENTATION
 * PackageManager.ActivityInfo.CONFIG_ORIENTATION}, or
 * {@link android.content.pm.ActivityInfo#CONFIG_SCREEN_LAYOUT
 * PackageManager.ActivityInfo.CONFIG_SCREEN_LAYOUT}.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3",1,"A new control dependency is introduced in the late version where it checks whether 'delta.uiMode' is not equal to an or-ed computation and also 'uiMode' is not equal to 'delta.uiMode'. If this condition is true, it will change the value of 'changed' (`changed |= ActivityInfo.CONFIG_UI_MODE`). This is a control dependency changed (3). Also, there is a new return statement (`changed |= ActivityInfo.CONFIG_UI_MODE`) introduced in the late version so the return statement has been changed (1).","The change of return statement will make the API potentially return a different value. Therefore, the CI type is 1."
277,"<android.webkit.WebView: void loadDataWithBaseURL(String,String,String,String,String)>",7,8,"<android.webkit.WebView: void loadDataWithBaseURL(String,String,String,String,String)>","<android.webkit.WebView: void loadDataWithBaseURL(String,String,String,String,String)>",0,"{
    if (baseUrl != null && baseUrl.toLowerCase().startsWith(""data:"")) {
        loadData(data, mimeType, encoding);
        return;
    }
    switchOutDrawHistory();
    WebViewCore.BaseUrlData arg = new WebViewCore.BaseUrlData();
    arg.mBaseUrl = baseUrl;
    arg.mData = data;
    arg.mMimeType = mimeType;
    arg.mEncoding = encoding;
    arg.mFailUrl = failUrl;
    mWebViewCore.sendMessage(EventHub.LOAD_DATA, arg);
    clearTextEntry();
}","{
    if (baseUrl != null && baseUrl.toLowerCase().startsWith(""data:"")) {
        loadData(data, mimeType, encoding);
        return;
    }
    switchOutDrawHistory();
    WebViewCore.BaseUrlData arg = new WebViewCore.BaseUrlData();
    arg.mBaseUrl = baseUrl;
    arg.mData = data;
    arg.mMimeType = mimeType;
    arg.mEncoding = encoding;
    arg.mHistoryUrl = historyUrl;
    mWebViewCore.sendMessage(EventHub.LOAD_DATA, arg);
    clearTextEntry(false);
}",1,"/**
 * Load the given data into the WebView, use the provided URL as the base
 * URL for the content. The base URL is the URL that represents the page
 * that is loaded through this interface. As such, it is used for the
 * history entry and to resolve any relative URLs. The failUrl is used if
 * browser fails to load the data provided. If it is empty or null, and the
 * load fails, then no history entry is created.
 * <p>
 * Note for post 1.0. Due to the change in the WebKit, the access to asset
 * files through ""file:///android_asset/"" for the sub resources is more
 * restricted. If you provide null or empty string as baseUrl, you won't be
 * able to access asset files. If the baseUrl is anything other than
 * http(s)/ftp(s)/about/javascript as scheme, you can access asset files for
 * sub resources.
 *
 * @param baseUrl Url to resolve relative paths with, if null defaults to
 * ""about:blank""
 * @param data A String of data in the given encoding.
 * @param mimeType The MIMEType of the data. i.e. text/html. If null,
 * defaults to ""text/html""
 * @param encoding The encoding of the data. i.e. utf-8, us-ascii
 * @param failUrl URL to use if the content fails to load or null.
 */
","/**
 * Load the given data into the WebView, use the provided URL as the base
 * URL for the content. The base URL is the URL that represents the page
 * that is loaded through this interface. As such, it is used to resolve any
 * relative URLs. The historyUrl is used for the history entry.
 * <p>
 * Note for post 1.0. Due to the change in the WebKit, the access to asset
 * files through ""file:///android_asset/"" for the sub resources is more
 * restricted. If you provide null or empty string as baseUrl, you won't be
 * able to access asset files. If the baseUrl is anything other than
 * http(s)/ftp(s)/about/javascript as scheme, you can access asset files for
 * sub resources.
 *
 * @param baseUrl Url to resolve relative paths with, if null defaults to
 * ""about:blank""
 * @param data A String of data in the given encoding.
 * @param mimeType The MIMEType of the data. i.e. text/html. If null,
 * defaults to ""text/html""
 * @param encoding The encoding of the data. i.e. utf-8, us-ascii
 * @param historyUrl URL to use as the history entry.  Can be null.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"The change is minor. In Late_Implementation, arg.mFailUrl was changed to arg.mHistoryUrl, the parameter in clearTextEntry() has changed, probably because it's based on the version of package WebViewCore. So, the type is 4,5.","There is no Compatibility Issue here because the changes wouldn't cause the API to return a different value/type or throw a different exception. So, the prediction is 0."
279,<android.provider.Browser: boolean canClearHistory(ContentResolver)>,7,8,<android.provider.Browser: boolean canClearHistory(ContentResolver)>,<android.provider.Browser: boolean canClearHistory(ContentResolver)>,0,"{
    try {
        Cursor c = cr.query(BOOKMARKS_URI, new String[] { BookmarkColumns._ID, BookmarkColumns.BOOKMARK, BookmarkColumns.VISITS }, ""bookmark = 0 OR visits > 0"", null, null);
        boolean ret = c.moveToFirst();
        c.deactivate();
        return ret;
    } catch (IllegalStateException e) {
        return false;
    }
}","{
    Cursor c = null;
    boolean ret = false;
    try {
        c = cr.query(BOOKMARKS_URI, new String[] { BookmarkColumns._ID, BookmarkColumns.BOOKMARK, BookmarkColumns.VISITS }, ""bookmark = 0 OR visits > 0"", null, null);
        ret = c.moveToFirst();
    } catch (IllegalStateException e) {
        Log.e(LOGTAG, ""canClearHistory"", e);
    } finally {
        if (c != null)
            c.close();
    }
    return ret;
}",1,"/**
 * Returns whether there is any history to clear.
 * Requires {@link android.Manifest.permission#READ_HISTORY_BOOKMARKS}
 * @param cr   The ContentResolver used to access the database.
 * @return boolean  True if the history can be cleared.
 */
","/**
 * Returns whether there is any history to clear.
 * Requires {@link android.Manifest.permission#READ_HISTORY_BOOKMARKS}
 * @param cr   The ContentResolver used to access the database.
 * @return boolean  True if the history can be cleared.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,4","1,2","The exception handling statement has changed: In the early version, it returns false if an IllegalStateException occurred, whereas in the later version it logs an error without changing the return value. There are also other statement changes, particularly in the structure of try-catch block and the new finally block, which closes the Cursor instance. Hence the change types are 2,4.","Changes to exception handling could potentially cause different behavior when an IllegalStateException is encountered. Also, variable 'ret' initially defaults to false in the later version, which could cause the method to return a different value under certain conditions, such as an exception occurring before 'ret' is assigned a new value. Hence, the Compatibility Issue types are 1,2."
280,"<android.accounts.AccountManager: String getUserData(Account,String)>",7,8,"<android.accounts.AccountManager: String getUserData(Account,String)>","<android.accounts.AccountManager: String getUserData(Account,String)>",0,"{
    try {
        return mService.getUserData(account, key);
    } catch (RemoteException e) {
        // will never happen
        throw new RuntimeException(e);
    }
}","{
    if (account == null)
        throw new IllegalArgumentException(""account is null"");
    if (key == null)
        throw new IllegalArgumentException(""key is null"");
    try {
        return mService.getUserData(account, key);
    } catch (RemoteException e) {
        // will never happen
        throw new RuntimeException(e);
    }
}",1,"/**
 * Get the user data named by ""key"" that is associated with the account.
 * Returns null if the account does not exist or if it does not have a value for key.
 * <p>
 * Requires that the caller has permission
 * {@link android.Manifest.permission#AUTHENTICATE_ACCOUNTS} and is running
 * with the same UID as the Authenticator for the account.
 */
","/**
 * Gets the user data named by ""key"" associated with the account.
 * This is intended for authenticators and related code to store
 * arbitrary metadata along with accounts.  The meaning of the keys
 * and values is up to the authenticator for the account.
 *
 * <p>It is safe to call this method from the main thread.
 *
 * <p>This method requires the caller to hold the permission
 * {@link android.Manifest.permission#AUTHENTICATE_ACCOUNTS}
 * and to have the same UID as the account's authenticator.
 *
 * @param account The account to query for user data
 * @return The user data, null if the account or key doesn't exist
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,3,4","1,2","The late version introduces new control statements to check if 'account' and 'key' are null, and throws an IllegalArgumentException if either is null. There are also changes to the logic control and additional statements added. So the code change types are 2,3,4.","The addition of control statements that throw exceptions means the API potentially returns a different type (IllegalArgumentException vs. String) and may also throw different exceptions (IllegalArgumentException vs. RuntimeException). So, the Compatibility Issue types are 1,2."
281,<android.speech.tts.TextToSpeech: int isLanguageAvailable(Locale)>,7,8,<android.speech.tts.TextToSpeech: int isLanguageAvailable(Locale)>,<android.speech.tts.TextToSpeech: int isLanguageAvailable(Locale)>,0,"{
    synchronized (mStartLock) {
        int result = LANG_NOT_SUPPORTED;
        if (!mStarted) {
            return result;
        }
        try {
            result = mITts.isLanguageAvailable(loc.getISO3Language(), loc.getISO3Country(), loc.getVariant());
        } catch (RemoteException e) {
            // TTS died; restart it.
            Log.e(""TextToSpeech.java - isLanguageAvailable"", ""RemoteException"");
            e.printStackTrace();
            mStarted = false;
            initTts();
        } catch (NullPointerException e) {
            // TTS died; restart it.
            Log.e(""TextToSpeech.java - isLanguageAvailable"", ""NullPointerException"");
            e.printStackTrace();
            mStarted = false;
            initTts();
        } catch (IllegalStateException e) {
            // TTS died; restart it.
            Log.e(""TextToSpeech.java - isLanguageAvailable"", ""IllegalStateException"");
            e.printStackTrace();
            mStarted = false;
            initTts();
        } finally {
            return result;
        }
    }
}","{
    synchronized (mStartLock) {
        int result = LANG_NOT_SUPPORTED;
        if (!mStarted) {
            return result;
        }
        try {
            result = mITts.isLanguageAvailable(loc.getISO3Language(), loc.getISO3Country(), loc.getVariant(), mCachedParams);
        } catch (RemoteException e) {
            // TTS died; restart it.
            Log.e(""TextToSpeech.java - isLanguageAvailable"", ""RemoteException"");
            e.printStackTrace();
            mStarted = false;
            initTts();
        } catch (NullPointerException e) {
            // TTS died; restart it.
            Log.e(""TextToSpeech.java - isLanguageAvailable"", ""NullPointerException"");
            e.printStackTrace();
            mStarted = false;
            initTts();
        } catch (IllegalStateException e) {
            // TTS died; restart it.
            Log.e(""TextToSpeech.java - isLanguageAvailable"", ""IllegalStateException"");
            e.printStackTrace();
            mStarted = false;
            initTts();
        } finally {
            return result;
        }
    }
}",1,"/**
 * Checks if the specified language as represented by the Locale is available and supported.
 *
 * @param loc
 * The Locale describing the language to be used.
 *
 * @return code indicating the support status for the locale. See {@link #LANG_AVAILABLE},
 * {@link #LANG_COUNTRY_AVAILABLE}, {@link #LANG_COUNTRY_VAR_AVAILABLE},
 * {@link #LANG_MISSING_DATA} and {@link #LANG_NOT_SUPPORTED}.
 */
","/**
 * Checks if the specified language as represented by the Locale is available and supported.
 *
 * @param loc
 * The Locale describing the language to be used.
 *
 * @return code indicating the support status for the locale. See {@link #LANG_AVAILABLE},
 * {@link #LANG_COUNTRY_AVAILABLE}, {@link #LANG_COUNTRY_VAR_AVAILABLE},
 * {@link #LANG_MISSING_DATA} and {@link #LANG_NOT_SUPPORTED}.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The API in the try block, mITts.isLanguageAvailable()'s signature has changed, with additional argument added 'mCachedParams' in the late version. Therefore, the type of code change is 1 (Return statement changed) and 5 (Dependent API changed).","Since the additional argument 'mCachedParams' in the call of mITts.isLanguageAvailable in the late version might lead to a potential different return value. Therefore, a compatibility issue exists and its type is 1 (Compatibility Issue caused by potential different return values or types)."
282,<android.pim.vcard.VCardParser_V30: void handleAgent(String)>,7,8,<android.pim.vcard.VCardParser_V30: void handleAgent(String)>,<android.pim.vcard.VCardParser_V30: void handleAgent(String)>,0,"{
    // throw new VCardException(""AGENT in vCard 3.0 is not supported yet."");
    if (!mEmittedAgentWarning) {
        Log.w(LOG_TAG, ""AGENT in vCard 3.0 is not supported yet. Ignore it"");
        mEmittedAgentWarning = true;
    }
// Just ignore the line for now, since we cannot know how to handle it...
}","{
    // Just ignore the line for now, since we cannot know how to handle it...
    if (!mEmittedAgentWarning) {
        Log.w(LOG_TAG, ""AGENT in vCard 3.0 is not supported yet. Ignore it"");
        mEmittedAgentWarning = true;
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,3,0,"The position of comment line and function codes have been changed between the two versions, so the code change type is 3.","Despite the order of the code lines has changed, the behavior of the method will not affected because none of the executing codes changed. Therefore, there is no CI, and the CI type is 0."
284,<android.webkit.WebView: boolean onTouchEvent(MotionEvent)>,7,8,<android.webkit.WebView: boolean onTouchEvent(MotionEvent)>,<android.webkit.WebView: boolean onTouchEvent(MotionEvent)>,0,"{
    if (mNativeClass == 0 || !isClickable() || !isLongClickable()) {
        return false;
    }
    if (DebugFlags.WEB_VIEW) {
        Log.v(LOGTAG, ev + "" at "" + ev.getEventTime() + "" mTouchMode="" + mTouchMode);
    }
    int action;
    float x, y;
    long eventTime = ev.getEventTime();
    // events later.
    if (mSupportMultiTouch && mMinZoomScale < mMaxZoomScale && ev.getPointerCount() > 1) {
        mScaleDetector.onTouchEvent(ev);
        if (mScaleDetector.isInProgress()) {
            mLastTouchTime = eventTime;
            return true;
        }
        x = mScaleDetector.getFocusX();
        y = mScaleDetector.getFocusY();
        action = ev.getAction() & MotionEvent.ACTION_MASK;
        if (action == MotionEvent.ACTION_POINTER_DOWN) {
            cancelTouch();
            action = MotionEvent.ACTION_DOWN;
        } else if (action == MotionEvent.ACTION_POINTER_UP) {
            // set mLastTouchX/Y to the remaining point
            mLastTouchX = x;
            mLastTouchY = y;
        } else if (action == MotionEvent.ACTION_MOVE) {
            // negative x or y indicate it is on the edge, skip it.
            if (x < 0 || y < 0) {
                return true;
            }
        }
    } else {
        action = ev.getAction();
        x = ev.getX();
        y = ev.getY();
    }
    // getViewWidth(). Same applied to the height.
    if (x > getViewWidth() - 1) {
        x = getViewWidth() - 1;
    }
    if (y > getViewHeightWithTitle() - 1) {
        y = getViewHeightWithTitle() - 1;
    }
    // pass the touch events from UI thread to WebCore thread
    if (mForwardTouchEvents && (action != MotionEvent.ACTION_MOVE || eventTime - mLastSentTouchTime > TOUCH_SENT_INTERVAL)) {
        WebViewCore.TouchEventData ted = new WebViewCore.TouchEventData();
        ted.mAction = action;
        ted.mX = viewToContentX((int) x + mScrollX);
        ted.mY = viewToContentY((int) y + mScrollY);
        mWebViewCore.sendMessage(EventHub.TOUCH_EVENT, ted);
        mLastSentTouchTime = eventTime;
    }
    int deltaX = (int) (mLastTouchX - x);
    int deltaY = (int) (mLastTouchY - y);
    switch(action) {
        case MotionEvent.ACTION_DOWN:
            {
                mPreventDrag = PREVENT_DRAG_NO;
                if (!mScroller.isFinished()) {
                    // stop the current scroll animation, but if this is
                    // the start of a fling, allow it to add to the current
                    // fling's velocity
                    mScroller.abortAnimation();
                    mTouchMode = TOUCH_DRAG_START_MODE;
                    mPrivateHandler.removeMessages(RESUME_WEBCORE_UPDATE);
                } else if (mShiftIsPressed) {
                    mSelectX = mScrollX + (int) x;
                    mSelectY = mScrollY + (int) y;
                    mTouchMode = TOUCH_SELECT_MODE;
                    if (DebugFlags.WEB_VIEW) {
                        Log.v(LOGTAG, ""select="" + mSelectX + "","" + mSelectY);
                    }
                    nativeMoveSelection(viewToContentX(mSelectX), viewToContentY(mSelectY), false);
                    mTouchSelection = mExtendSelection = true;
                } else if (mPrivateHandler.hasMessages(RELEASE_SINGLE_TAP)) {
                    mPrivateHandler.removeMessages(RELEASE_SINGLE_TAP);
                    if (deltaX * deltaX + deltaY * deltaY < mDoubleTapSlopSquare) {
                        mTouchMode = TOUCH_DOUBLE_TAP_MODE;
                    } else {
                        // commit the short press action for the previous tap
                        doShortPress();
                    // continue, mTouchMode should be still TOUCH_INIT_MODE
                    }
                } else {
                    mPreviewZoomOnly = false;
                    mTouchMode = TOUCH_INIT_MODE;
                    mPreventDrag = mForwardTouchEvents ? PREVENT_DRAG_MAYBE_YES : PREVENT_DRAG_NO;
                    mWebViewCore.sendMessage(EventHub.UPDATE_FRAME_CACHE_IF_LOADING);
                    if (mLogEvent && eventTime - mLastTouchUpTime < 1000) {
                        EventLog.writeEvent(EVENT_LOG_DOUBLE_TAP_DURATION, (eventTime - mLastTouchUpTime), eventTime);
                    }
                }
                // Trigger the link
                if (mTouchMode == TOUCH_INIT_MODE || mTouchMode == TOUCH_DOUBLE_TAP_MODE) {
                    mPrivateHandler.sendMessageDelayed(mPrivateHandler.obtainMessage(SWITCH_TO_SHORTPRESS), TAP_TIMEOUT);
                }
                // Remember where the motion event started
                startTouch(x, y, eventTime);
                if (mDragTracker != null) {
                    mDragTrackerHandler = new DragTrackerHandler(x, y, mDragTracker);
                }
                break;
            }
        case MotionEvent.ACTION_MOVE:
            {
                if (mTouchMode == TOUCH_DONE_MODE) {
                    // no dragging during scroll zoom animation
                    break;
                }
                mVelocityTracker.addMovement(ev);
                if (mTouchMode != TOUCH_DRAG_MODE) {
                    if (mTouchMode == TOUCH_SELECT_MODE) {
                        mSelectX = mScrollX + (int) x;
                        mSelectY = mScrollY + (int) y;
                        if (DebugFlags.WEB_VIEW) {
                            Log.v(LOGTAG, ""xtend="" + mSelectX + "","" + mSelectY);
                        }
                        nativeMoveSelection(viewToContentX(mSelectX), viewToContentY(mSelectY), true);
                        invalidate();
                        break;
                    }
                    if ((deltaX * deltaX + deltaY * deltaY) < mTouchSlopSquare) {
                        break;
                    }
                    if (mPreventDrag == PREVENT_DRAG_MAYBE_YES) {
                        // track mLastTouchTime as we may need to do fling at
                        // ACTION_UP
                        mLastTouchTime = eventTime;
                        break;
                    }
                    if (mTouchMode == TOUCH_SHORTPRESS_MODE || mTouchMode == TOUCH_SHORTPRESS_START_MODE) {
                        mPrivateHandler.removeMessages(SWITCH_TO_LONGPRESS);
                    } else if (mTouchMode == TOUCH_INIT_MODE || mTouchMode == TOUCH_DOUBLE_TAP_MODE) {
                        mPrivateHandler.removeMessages(SWITCH_TO_SHORTPRESS);
                    }
                    // if it starts nearly horizontal or vertical, enforce it
                    int ax = Math.abs(deltaX);
                    int ay = Math.abs(deltaY);
                    if (ax > MAX_SLOPE_FOR_DIAG * ay) {
                        mSnapScrollMode = SNAP_X;
                        mSnapPositive = deltaX > 0;
                    } else if (ay > MAX_SLOPE_FOR_DIAG * ax) {
                        mSnapScrollMode = SNAP_Y;
                        mSnapPositive = deltaY > 0;
                    }
                    mTouchMode = TOUCH_DRAG_MODE;
                    WebViewCore.pauseUpdate(mWebViewCore);
                    if (!mDragFromTextInput) {
                        nativeHideCursor();
                    }
                    WebSettings settings = getSettings();
                    if (settings.supportZoom() && settings.getBuiltInZoomControls() && !mZoomButtonsController.isVisible() && mMinZoomScale < mMaxZoomScale) {
                        mZoomButtonsController.setVisible(true);
                        int count = settings.getDoubleTapToastCount();
                        if (mInZoomOverview && count > 0) {
                            settings.setDoubleTapToastCount(--count);
                            Toast.makeText(mContext, com.android.internal.R.string.double_tap_toast, Toast.LENGTH_LONG).show();
                        }
                    }
                }
                // do pan
                int newScrollX = pinLocX(mScrollX + deltaX);
                deltaX = newScrollX - mScrollX;
                int newScrollY = pinLocY(mScrollY + deltaY);
                deltaY = newScrollY - mScrollY;
                boolean done = false;
                if (deltaX == 0 && deltaY == 0) {
                    done = true;
                } else {
                    if (mSnapScrollMode == SNAP_X || mSnapScrollMode == SNAP_Y) {
                        int ax = Math.abs(deltaX);
                        int ay = Math.abs(deltaY);
                        if (mSnapScrollMode == SNAP_X) {
                            // radical change means getting out of snap mode
                            if (ay > MAX_SLOPE_FOR_DIAG * ax && ay > MIN_BREAK_SNAP_CROSS_DISTANCE) {
                                mSnapScrollMode = SNAP_NONE;
                            }
                            // reverse direction means lock in the snap mode
                            if ((ax > MAX_SLOPE_FOR_DIAG * ay) && ((mSnapPositive && deltaX < -mMinLockSnapReverseDistance) || (!mSnapPositive && deltaX > mMinLockSnapReverseDistance))) {
                                mSnapScrollMode = SNAP_X_LOCK;
                            }
                        } else {
                            // radical change means getting out of snap mode
                            if ((ax > MAX_SLOPE_FOR_DIAG * ay) && ax > MIN_BREAK_SNAP_CROSS_DISTANCE) {
                                mSnapScrollMode = SNAP_NONE;
                            }
                            // reverse direction means lock in the snap mode
                            if ((ay > MAX_SLOPE_FOR_DIAG * ax) && ((mSnapPositive && deltaY < -mMinLockSnapReverseDistance) || (!mSnapPositive && deltaY > mMinLockSnapReverseDistance))) {
                                mSnapScrollMode = SNAP_Y_LOCK;
                            }
                        }
                    }
                    if (mSnapScrollMode == SNAP_X || mSnapScrollMode == SNAP_X_LOCK) {
                        if (deltaX == 0) {
                            // keep the scrollbar on the screen even there is no
                            // scroll
                            awakenScrollBars(ViewConfiguration.getScrollDefaultDelay(), false);
                        } else {
                            scrollBy(deltaX, 0);
                        }
                        mLastTouchX = x;
                    } else if (mSnapScrollMode == SNAP_Y || mSnapScrollMode == SNAP_Y_LOCK) {
                        if (deltaY == 0) {
                            // keep the scrollbar on the screen even there is no
                            // scroll
                            awakenScrollBars(ViewConfiguration.getScrollDefaultDelay(), false);
                        } else {
                            scrollBy(0, deltaY);
                        }
                        mLastTouchY = y;
                    } else {
                        scrollBy(deltaX, deltaY);
                        mLastTouchX = x;
                        mLastTouchY = y;
                    }
                    mLastTouchTime = eventTime;
                    mUserScroll = true;
                }
                if (!getSettings().getBuiltInZoomControls()) {
                    boolean showPlusMinus = mMinZoomScale < mMaxZoomScale;
                    if (mZoomControls != null && showPlusMinus) {
                        if (mZoomControls.getVisibility() == View.VISIBLE) {
                            mPrivateHandler.removeCallbacks(mZoomControlRunnable);
                        } else {
                            mZoomControls.show(showPlusMinus, false);
                        }
                        mPrivateHandler.postDelayed(mZoomControlRunnable, ZOOM_CONTROLS_TIMEOUT);
                    }
                }
                if (mDragTrackerHandler != null) {
                    mDragTrackerHandler.dragTo(x, y);
                }
                if (done) {
                    // keep the scrollbar on the screen even there is no scroll
                    awakenScrollBars(ViewConfiguration.getScrollDefaultDelay(), false);
                    // view space
                    return false;
                }
                break;
            }
        case MotionEvent.ACTION_UP:
            {
                if (mDragTrackerHandler != null) {
                    mDragTrackerHandler.stopDrag();
                    mDragTrackerHandler = null;
                }
                mLastTouchUpTime = eventTime;
                switch(mTouchMode) {
                    case // double tap
                    TOUCH_DOUBLE_TAP_MODE:
                        mPrivateHandler.removeMessages(SWITCH_TO_SHORTPRESS);
                        mTouchMode = TOUCH_DONE_MODE;
                        doDoubleTap();
                        break;
                    case TOUCH_SELECT_MODE:
                        commitCopy();
                        mTouchSelection = false;
                        break;
                    // tap
                    case TOUCH_INIT_MODE:
                    case TOUCH_SHORTPRESS_START_MODE:
                    case TOUCH_SHORTPRESS_MODE:
                        mPrivateHandler.removeMessages(SWITCH_TO_SHORTPRESS);
                        mPrivateHandler.removeMessages(SWITCH_TO_LONGPRESS);
                        if ((deltaX * deltaX + deltaY * deltaY) > mTouchSlopSquare) {
                            Log.w(LOGTAG, ""Miss a drag as we are waiting for"" + "" WebCore's response for touch down."");
                            if (computeHorizontalScrollExtent() < computeHorizontalScrollRange() || computeVerticalScrollExtent() < computeVerticalScrollRange()) {
                                // we will not rewrite drag code here, but we
                                // will try fling if it applies.
                                WebViewCore.pauseUpdate(mWebViewCore);
                            // fall through to TOUCH_DRAG_MODE
                            } else {
                                break;
                            }
                        } else {
                            if (mPreventDrag == PREVENT_DRAG_MAYBE_YES) {
                                // if mPreventDrag is not confirmed, treat it as
                                // no so that it won't block tap or double tap.
                                mPreventDrag = PREVENT_DRAG_NO;
                            }
                            if (mPreventDrag == PREVENT_DRAG_NO) {
                                if (mTouchMode == TOUCH_INIT_MODE) {
                                    mPrivateHandler.sendMessageDelayed(mPrivateHandler.obtainMessage(RELEASE_SINGLE_TAP), ViewConfiguration.getDoubleTapTimeout());
                                } else {
                                    mTouchMode = TOUCH_DONE_MODE;
                                    doShortPress();
                                }
                            }
                            break;
                        }
                    case TOUCH_DRAG_MODE:
                        // redraw in high-quality, as we're done dragging
                        invalidate();
                        // up, we don't want to do a fling
                        if (eventTime - mLastTouchTime <= MIN_FLING_TIME) {
                            mVelocityTracker.addMovement(ev);
                            doFling();
                            break;
                        }
                        mLastVelocity = 0;
                        WebViewCore.resumeUpdate(mWebViewCore);
                        break;
                    case TOUCH_DRAG_START_MODE:
                    case TOUCH_DONE_MODE:
                        // do nothing
                        break;
                }
                // mode in the drawing code
                if (mVelocityTracker != null) {
                    mVelocityTracker.recycle();
                    mVelocityTracker = null;
                }
                break;
            }
        case MotionEvent.ACTION_CANCEL:
            {
                if (mDragTrackerHandler != null) {
                    mDragTrackerHandler.stopDrag();
                    mDragTrackerHandler = null;
                }
                cancelTouch();
                break;
            }
    }
    return true;
}","{
    if (mNativeClass == 0 || !isClickable() || !isLongClickable()) {
        return false;
    }
    if (DebugFlags.WEB_VIEW) {
        Log.v(LOGTAG, ev + "" at "" + ev.getEventTime() + "" mTouchMode="" + mTouchMode);
    }
    int action;
    float x, y;
    long eventTime = ev.getEventTime();
    // events later.
    if (mSupportMultiTouch && ev.getPointerCount() > 1) {
        if (mMinZoomScale < mMaxZoomScale) {
            mScaleDetector.onTouchEvent(ev);
            if (mScaleDetector.isInProgress()) {
                mLastTouchTime = eventTime;
                return true;
            }
            x = mScaleDetector.getFocusX();
            y = mScaleDetector.getFocusY();
            action = ev.getAction() & MotionEvent.ACTION_MASK;
            if (action == MotionEvent.ACTION_POINTER_DOWN) {
                cancelTouch();
                action = MotionEvent.ACTION_DOWN;
            } else if (action == MotionEvent.ACTION_POINTER_UP) {
                // set mLastTouchX/Y to the remaining point
                mLastTouchX = x;
                mLastTouchY = y;
            } else if (action == MotionEvent.ACTION_MOVE) {
                // negative x or y indicate it is on the edge, skip it.
                if (x < 0 || y < 0) {
                    return true;
                }
            }
        } else {
            // if the page disallow zoom, skip multi-pointer action
            return true;
        }
    } else {
        action = ev.getAction();
        x = ev.getX();
        y = ev.getY();
    }
    // getViewWidth(). Same applied to the height.
    if (x > getViewWidth() - 1) {
        x = getViewWidth() - 1;
    }
    if (y > getViewHeightWithTitle() - 1) {
        y = getViewHeightWithTitle() - 1;
    }
    float fDeltaX = mLastTouchX - x;
    float fDeltaY = mLastTouchY - y;
    int deltaX = (int) fDeltaX;
    int deltaY = (int) fDeltaY;
    int contentX = viewToContentX((int) x + mScrollX);
    int contentY = viewToContentY((int) y + mScrollY);
    switch(action) {
        case MotionEvent.ACTION_DOWN:
            {
                mPreventDefault = PREVENT_DEFAULT_NO;
                mConfirmMove = false;
                if (!mScroller.isFinished()) {
                    // stop the current scroll animation, but if this is
                    // the start of a fling, allow it to add to the current
                    // fling's velocity
                    mScroller.abortAnimation();
                    mTouchMode = TOUCH_DRAG_START_MODE;
                    mConfirmMove = true;
                    mPrivateHandler.removeMessages(RESUME_WEBCORE_PRIORITY);
                } else if (!inFullScreenMode() && mShiftIsPressed) {
                    mSelectX = mScrollX + (int) x;
                    mSelectY = mScrollY + (int) y;
                    mTouchMode = TOUCH_SELECT_MODE;
                    if (DebugFlags.WEB_VIEW) {
                        Log.v(LOGTAG, ""select="" + mSelectX + "","" + mSelectY);
                    }
                    nativeMoveSelection(contentX, contentY, false);
                    mTouchSelection = mExtendSelection = true;
                    // draw the i-beam instead of the arrow
                    invalidate();
                } else if (mPrivateHandler.hasMessages(RELEASE_SINGLE_TAP)) {
                    mPrivateHandler.removeMessages(RELEASE_SINGLE_TAP);
                    if (deltaX * deltaX + deltaY * deltaY < mDoubleTapSlopSquare) {
                        mTouchMode = TOUCH_DOUBLE_TAP_MODE;
                    } else {
                        // commit the short press action for the previous tap
                        doShortPress();
                        mTouchMode = TOUCH_INIT_MODE;
                        mDeferTouchProcess = (!inFullScreenMode() && mForwardTouchEvents) ? hitFocusedPlugin(contentX, contentY) : false;
                    }
                } else {
                    // the normal case
                    mPreviewZoomOnly = false;
                    mTouchMode = TOUCH_INIT_MODE;
                    mDeferTouchProcess = (!inFullScreenMode() && mForwardTouchEvents) ? hitFocusedPlugin(contentX, contentY) : false;
                    mWebViewCore.sendMessage(EventHub.UPDATE_FRAME_CACHE_IF_LOADING);
                    if (mLogEvent && eventTime - mLastTouchUpTime < 1000) {
                        EventLog.writeEvent(EventLogTags.BROWSER_DOUBLE_TAP_DURATION, (eventTime - mLastTouchUpTime), eventTime);
                    }
                }
                // Trigger the link
                if (mTouchMode == TOUCH_INIT_MODE || mTouchMode == TOUCH_DOUBLE_TAP_MODE) {
                    mPrivateHandler.sendEmptyMessageDelayed(SWITCH_TO_SHORTPRESS, TAP_TIMEOUT);
                    mPrivateHandler.sendEmptyMessageDelayed(SWITCH_TO_LONGPRESS, LONG_PRESS_TIMEOUT);
                    if (inFullScreenMode() || mDeferTouchProcess) {
                        mPreventDefault = PREVENT_DEFAULT_YES;
                    } else if (mForwardTouchEvents) {
                        mPreventDefault = PREVENT_DEFAULT_MAYBE_YES;
                    } else {
                        mPreventDefault = PREVENT_DEFAULT_NO;
                    }
                    // pass the touch events from UI thread to WebCore thread
                    if (shouldForwardTouchEvent()) {
                        TouchEventData ted = new TouchEventData();
                        ted.mAction = action;
                        ted.mX = contentX;
                        ted.mY = contentY;
                        ted.mMetaState = ev.getMetaState();
                        ted.mReprocess = mDeferTouchProcess;
                        if (mDeferTouchProcess) {
                            // still needs to set them for compute deltaX/Y
                            mLastTouchX = x;
                            mLastTouchY = y;
                            ted.mViewX = x;
                            ted.mViewY = y;
                            mWebViewCore.sendMessage(EventHub.TOUCH_EVENT, ted);
                            break;
                        }
                        mWebViewCore.sendMessage(EventHub.TOUCH_EVENT, ted);
                        if (!inFullScreenMode()) {
                            mPrivateHandler.sendMessageDelayed(mPrivateHandler.obtainMessage(PREVENT_DEFAULT_TIMEOUT, action, 0), TAP_TIMEOUT);
                        }
                    }
                }
                startTouch(x, y, eventTime);
                break;
            }
        case MotionEvent.ACTION_MOVE:
            {
                boolean firstMove = false;
                if (!mConfirmMove && (deltaX * deltaX + deltaY * deltaY) >= mTouchSlopSquare) {
                    mPrivateHandler.removeMessages(SWITCH_TO_SHORTPRESS);
                    mPrivateHandler.removeMessages(SWITCH_TO_LONGPRESS);
                    mConfirmMove = true;
                    firstMove = true;
                    if (mTouchMode == TOUCH_DOUBLE_TAP_MODE) {
                        mTouchMode = TOUCH_INIT_MODE;
                    }
                }
                // pass the touch events from UI thread to WebCore thread
                if (shouldForwardTouchEvent() && mConfirmMove && (firstMove || eventTime - mLastSentTouchTime > mCurrentTouchInterval)) {
                    mLastSentTouchTime = eventTime;
                    TouchEventData ted = new TouchEventData();
                    ted.mAction = action;
                    ted.mX = contentX;
                    ted.mY = contentY;
                    ted.mMetaState = ev.getMetaState();
                    ted.mReprocess = mDeferTouchProcess;
                    if (mDeferTouchProcess) {
                        ted.mViewX = x;
                        ted.mViewY = y;
                        mWebViewCore.sendMessage(EventHub.TOUCH_EVENT, ted);
                        break;
                    }
                    mWebViewCore.sendMessage(EventHub.TOUCH_EVENT, ted);
                    if (firstMove && !inFullScreenMode()) {
                        mPrivateHandler.sendMessageDelayed(mPrivateHandler.obtainMessage(PREVENT_DEFAULT_TIMEOUT, action, 0), TAP_TIMEOUT);
                    }
                }
                if (mTouchMode == TOUCH_DONE_MODE || mPreventDefault == PREVENT_DEFAULT_YES) {
                    // default is yes
                    break;
                }
                if (mVelocityTracker == null) {
                    Log.e(LOGTAG, ""Got null mVelocityTracker when "" + ""mPreventDefault = "" + mPreventDefault + "" mDeferTouchProcess = "" + mDeferTouchProcess + "" mTouchMode = "" + mTouchMode);
                }
                mVelocityTracker.addMovement(ev);
                if (mTouchMode != TOUCH_DRAG_MODE) {
                    if (mTouchMode == TOUCH_SELECT_MODE) {
                        mSelectX = mScrollX + (int) x;
                        mSelectY = mScrollY + (int) y;
                        if (DebugFlags.WEB_VIEW) {
                            Log.v(LOGTAG, ""xtend="" + mSelectX + "","" + mSelectY);
                        }
                        nativeMoveSelection(contentX, contentY, true);
                        invalidate();
                        break;
                    }
                    if (!mConfirmMove) {
                        break;
                    }
                    if (mPreventDefault == PREVENT_DEFAULT_MAYBE_YES || mPreventDefault == PREVENT_DEFAULT_NO_FROM_TOUCH_DOWN) {
                        // track mLastTouchTime as we may need to do fling at
                        // ACTION_UP
                        mLastTouchTime = eventTime;
                        break;
                    }
                    // if it starts nearly horizontal or vertical, enforce it
                    int ax = Math.abs(deltaX);
                    int ay = Math.abs(deltaY);
                    if (ax > MAX_SLOPE_FOR_DIAG * ay) {
                        mSnapScrollMode = SNAP_X;
                        mSnapPositive = deltaX > 0;
                    } else if (ay > MAX_SLOPE_FOR_DIAG * ax) {
                        mSnapScrollMode = SNAP_Y;
                        mSnapPositive = deltaY > 0;
                    }
                    mTouchMode = TOUCH_DRAG_MODE;
                    mLastTouchX = x;
                    mLastTouchY = y;
                    fDeltaX = 0.0f;
                    fDeltaY = 0.0f;
                    deltaX = 0;
                    deltaY = 0;
                    startDrag();
                }
                if (mDragTrackerHandler != null) {
                    mDragTrackerHandler.dragTo(x, y);
                }
                // do pan
                int newScrollX = pinLocX(mScrollX + deltaX);
                int newDeltaX = newScrollX - mScrollX;
                if (deltaX != newDeltaX) {
                    deltaX = newDeltaX;
                    fDeltaX = (float) newDeltaX;
                }
                int newScrollY = pinLocY(mScrollY + deltaY);
                int newDeltaY = newScrollY - mScrollY;
                if (deltaY != newDeltaY) {
                    deltaY = newDeltaY;
                    fDeltaY = (float) newDeltaY;
                }
                boolean done = false;
                boolean keepScrollBarsVisible = false;
                if (Math.abs(fDeltaX) < 1.0f && Math.abs(fDeltaY) < 1.0f) {
                    mLastTouchX = x;
                    mLastTouchY = y;
                    keepScrollBarsVisible = done = true;
                } else {
                    if (mSnapScrollMode == SNAP_X || mSnapScrollMode == SNAP_Y) {
                        int ax = Math.abs(deltaX);
                        int ay = Math.abs(deltaY);
                        if (mSnapScrollMode == SNAP_X) {
                            // radical change means getting out of snap mode
                            if (ay > MAX_SLOPE_FOR_DIAG * ax && ay > MIN_BREAK_SNAP_CROSS_DISTANCE) {
                                mSnapScrollMode = SNAP_NONE;
                            }
                            // reverse direction means lock in the snap mode
                            if (ax > MAX_SLOPE_FOR_DIAG * ay && (mSnapPositive ? deltaX < -mMinLockSnapReverseDistance : deltaX > mMinLockSnapReverseDistance)) {
                                mSnapScrollMode |= SNAP_LOCK;
                            }
                        } else {
                            // radical change means getting out of snap mode
                            if (ax > MAX_SLOPE_FOR_DIAG * ay && ax > MIN_BREAK_SNAP_CROSS_DISTANCE) {
                                mSnapScrollMode = SNAP_NONE;
                            }
                            // reverse direction means lock in the snap mode
                            if (ay > MAX_SLOPE_FOR_DIAG * ax && (mSnapPositive ? deltaY < -mMinLockSnapReverseDistance : deltaY > mMinLockSnapReverseDistance)) {
                                mSnapScrollMode |= SNAP_LOCK;
                            }
                        }
                    }
                    if (mSnapScrollMode != SNAP_NONE) {
                        if ((mSnapScrollMode & SNAP_X) == SNAP_X) {
                            deltaY = 0;
                        } else {
                            deltaX = 0;
                        }
                    }
                    if ((deltaX | deltaY) != 0) {
                        if (deltaX != 0) {
                            mLastTouchX = x;
                        }
                        if (deltaY != 0) {
                            mLastTouchY = y;
                        }
                        mHeldMotionless = MOTIONLESS_FALSE;
                    } else {
                        // keep the scrollbar on the screen even there is no
                        // scroll
                        mLastTouchX = x;
                        mLastTouchY = y;
                        keepScrollBarsVisible = true;
                    }
                    mLastTouchTime = eventTime;
                    mUserScroll = true;
                }
                doDrag(deltaX, deltaY);
                if (keepScrollBarsVisible) {
                    if (mHeldMotionless != MOTIONLESS_TRUE) {
                        mHeldMotionless = MOTIONLESS_TRUE;
                        invalidate();
                    }
                    // keep the scrollbar on the screen even there is no scroll
                    awakenScrollBars(ViewConfiguration.getScrollDefaultDelay(), false);
                    // view space
                    return !done;
                }
                break;
            }
        case MotionEvent.ACTION_UP:
            {
                // pass the touch events from UI thread to WebCore thread
                if (shouldForwardTouchEvent()) {
                    TouchEventData ted = new TouchEventData();
                    ted.mAction = action;
                    ted.mX = contentX;
                    ted.mY = contentY;
                    ted.mMetaState = ev.getMetaState();
                    ted.mReprocess = mDeferTouchProcess;
                    if (mDeferTouchProcess) {
                        ted.mViewX = x;
                        ted.mViewY = y;
                    }
                    mWebViewCore.sendMessage(EventHub.TOUCH_EVENT, ted);
                }
                mLastTouchUpTime = eventTime;
                switch(mTouchMode) {
                    case // double tap
                    TOUCH_DOUBLE_TAP_MODE:
                        mPrivateHandler.removeMessages(SWITCH_TO_SHORTPRESS);
                        mPrivateHandler.removeMessages(SWITCH_TO_LONGPRESS);
                        if (inFullScreenMode() || mDeferTouchProcess) {
                            TouchEventData ted = new TouchEventData();
                            ted.mAction = WebViewCore.ACTION_DOUBLETAP;
                            ted.mX = contentX;
                            ted.mY = contentY;
                            ted.mMetaState = ev.getMetaState();
                            ted.mReprocess = mDeferTouchProcess;
                            if (mDeferTouchProcess) {
                                ted.mViewX = x;
                                ted.mViewY = y;
                            }
                            mWebViewCore.sendMessage(EventHub.TOUCH_EVENT, ted);
                        } else if (mPreventDefault != PREVENT_DEFAULT_YES) {
                            doDoubleTap();
                            mTouchMode = TOUCH_DONE_MODE;
                        }
                        break;
                    case TOUCH_SELECT_MODE:
                        commitCopy();
                        mTouchSelection = false;
                        break;
                    // tap
                    case TOUCH_INIT_MODE:
                    case TOUCH_SHORTPRESS_START_MODE:
                    case TOUCH_SHORTPRESS_MODE:
                        mPrivateHandler.removeMessages(SWITCH_TO_SHORTPRESS);
                        mPrivateHandler.removeMessages(SWITCH_TO_LONGPRESS);
                        if (mConfirmMove) {
                            Log.w(LOGTAG, ""Miss a drag as we are waiting for"" + "" WebCore's response for touch down."");
                            if (mPreventDefault != PREVENT_DEFAULT_YES && (computeMaxScrollX() > 0 || computeMaxScrollY() > 0)) {
                                // UI takes control back, cancel WebCore touch
                                cancelWebCoreTouchEvent(contentX, contentY, true);
                                // we will not rewrite drag code here, but we
                                // will try fling if it applies.
                                WebViewCore.reducePriority();
                                // to get better performance, pause updating the
                                // picture
                                WebViewCore.pauseUpdatePicture(mWebViewCore);
                            // fall through to TOUCH_DRAG_MODE
                            } else {
                                // WebKit may consume the touch event and modify
                                // DOM. drawContentPicture() will be called with
                                // animateSroll as true for better performance.
                                // Force redraw in high-quality.
                                invalidate();
                                break;
                            }
                        } else {
                            if (mTouchMode == TOUCH_INIT_MODE) {
                                mPrivateHandler.sendEmptyMessageDelayed(RELEASE_SINGLE_TAP, ViewConfiguration.getDoubleTapTimeout());
                            } else {
                                doShortPress();
                            }
                            break;
                        }
                    case TOUCH_DRAG_MODE:
                        mPrivateHandler.removeMessages(DRAG_HELD_MOTIONLESS);
                        mPrivateHandler.removeMessages(AWAKEN_SCROLL_BARS);
                        // up, we don't want to do a fling
                        if (eventTime - mLastTouchTime <= MIN_FLING_TIME) {
                            if (mVelocityTracker == null) {
                                Log.e(LOGTAG, ""Got null mVelocityTracker when "" + ""mPreventDefault = "" + mPreventDefault + "" mDeferTouchProcess = "" + mDeferTouchProcess);
                            }
                            mVelocityTracker.addMovement(ev);
                            // set to MOTIONLESS_IGNORE so that it won't keep
                            // removing and sending message in
                            // drawCoreAndCursorRing()
                            mHeldMotionless = MOTIONLESS_IGNORE;
                            doFling();
                            break;
                        }
                        // redraw in high-quality, as we're done dragging
                        mHeldMotionless = MOTIONLESS_TRUE;
                        invalidate();
                    // fall through
                    case TOUCH_DRAG_START_MODE:
                        // TOUCH_DRAG_START_MODE should not happen for the real
                        // device as we almost certain will get a MOVE. But this
                        // is possible on emulator.
                        mLastVelocity = 0;
                        WebViewCore.resumePriority();
                        WebViewCore.resumeUpdatePicture(mWebViewCore);
                        break;
                }
                stopTouch();
                break;
            }
        case MotionEvent.ACTION_CANCEL:
            {
                if (mTouchMode == TOUCH_DRAG_MODE) {
                    invalidate();
                }
                cancelWebCoreTouchEvent(contentX, contentY, false);
                cancelTouch();
                break;
            }
    }
    return true;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,,,,
285,"<android.text.Layout: float getDesiredWidth(CharSequence,int,int,TextPaint)>",7,8,"<android.text.Layout: float getDesiredWidth(CharSequence,int,int,TextPaint)>","<android.text.Layout: float getDesiredWidth(CharSequence,int,int,TextPaint)>",0,"{
    float need = 0;
    TextPaint workPaint = new TextPaint();
    int next;
    for (int i = start; i <= end; i = next) {
        next = TextUtils.indexOf(source, '\n', i, end);
        if (next < 0)
            next = end;
        float w = measureText(paint, workPaint, source, i, next, null, true, null);
        if (w > need)
            need = w;
        next++;
    }
    return need;
}","{
    float need = 0;
    TextPaint workPaint = new TextPaint();
    int next;
    for (int i = start; i <= end; i = next) {
        next = TextUtils.indexOf(source, '\n', i, end);
        if (next < 0)
            next = end;
        // note, omits trailing paragraph char
        float w = measureText(paint, workPaint, source, i, next, null, true, null);
        if (w > need)
            need = w;
        next++;
    }
    return need;
}",1,"/**
 * Return how wide a layout would be necessary to display the
 * specified text slice with one line per paragraph.
 */
","/**
 * Return how wide a layout must be in order to display the
 * specified text slice with one line per paragraph.
 */
",-1,,,-1,-1,-1,-1,-1,-1,0,0,"No code change is detected between the two versions. A comment line ""// note, omits trailing paragraph char"" is added, but it's not considered as code change.","Since there is no code change between the two versions, no Compatibility Issue (CI) exists."
287,"<android.net.SSLCertificateSocketFactory: Socket createSocket(Socket,String,int,boolean)>",7,8,"<android.net.SSLCertificateSocketFactory: Socket createSocket(Socket,String,int,boolean)>","<android.net.SSLCertificateSocketFactory: Socket createSocket(Socket,String,int,boolean)>",0,"{
    throw new IOException(""Cannot validate certification without a hostname"");
}","{
    OpenSSLSocketImpl s = (OpenSSLSocketImpl) getDelegate().createSocket(k, host, port, close);
    s.setHandshakeTimeout(mHandshakeTimeoutMillis);
    return s;
}",1,,,-1,,[@Override],-1,-1,-1,-1,-1,-1,"1,4","1,2","The previous 'throw' statement in the early version has been removed, and new different statements are introduced in the late version, including a return statement. Hence, the code change types are 1,4.","The early version of the method always throws an IOException, whereas the late version creates and returns a new 'OpenSSLSocketImpl' object. This leads to two potential different behaviors. Hence, the CI types are 1,2."
288,<android.webkit.LoadListener: void headers(Headers)>,7,8,<android.webkit.LoadListener: void headers(Headers)>,<android.webkit.LoadListener: void headers(Headers)>,0,"{
    if (DebugFlags.LOAD_LISTENER)
        Log.v(LOGTAG, ""LoadListener.headers"");
    sendMessageInternal(obtainMessage(MSG_CONTENT_HEADERS, headers));
}","{
    if (DebugFlags.LOAD_LISTENER)
        Log.v(LOGTAG, ""LoadListener.headers"");
    // call db (setCookie) in the non-WebCore thread
    if (mCancelled)
        return;
    ArrayList<String> cookies = headers.getSetCookie();
    for (int i = 0; i < cookies.size(); ++i) {
        CookieManager.getInstance().setCookie(mUri, cookies.get(i));
    }
    sendMessageInternal(obtainMessage(MSG_CONTENT_HEADERS, headers));
}",1,"/**
 * Parse the headers sent from the server.
 * @param headers gives up the HeaderGroup
 * IMPORTANT: as this is called from network thread, can't call native
 * directly
 */
","/**
 * Parse the headers sent from the server.
 * @param headers gives up the HeaderGroup
 * IMPORTANT: as this is called from network thread, can't call native
 * directly
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,1,"Additional statements have been introduced in the late version. These include a check for 'mCancelled', retrieval of cookies from headers and for loop to set cookie for each cookie in cookies list. So, the code change type is 4 (Other statements changed).","Even there is no explicit return statement changes, but the introduction of 'mCancelled' check can make the method return earlier, which changes the control flow of the method and potentially leads to the API return nothing. So, the CI type is 1."
289,<android.speech.tts.TextToSpeech: int setLanguage(Locale)>,7,8,<android.speech.tts.TextToSpeech: int setLanguage(Locale)>,<android.speech.tts.TextToSpeech: int setLanguage(Locale)>,0,"{
    synchronized (mStartLock) {
        int result = LANG_NOT_SUPPORTED;
        if (!mStarted) {
            return result;
        }
        try {
            mCachedParams[Engine.PARAM_POSITION_LANGUAGE + 1] = loc.getISO3Language();
            mCachedParams[Engine.PARAM_POSITION_COUNTRY + 1] = loc.getISO3Country();
            mCachedParams[Engine.PARAM_POSITION_VARIANT + 1] = loc.getVariant();
            // the language is not set here, instead it is cached so it will be associated
            // with all upcoming utterances. But we still need to report the language support,
            // which is achieved by calling isLanguageAvailable()
            result = mITts.isLanguageAvailable(mCachedParams[Engine.PARAM_POSITION_LANGUAGE + 1], mCachedParams[Engine.PARAM_POSITION_COUNTRY + 1], mCachedParams[Engine.PARAM_POSITION_VARIANT + 1]);
        } catch (RemoteException e) {
            // TTS died; restart it.
            Log.e(""TextToSpeech.java - setLanguage"", ""RemoteException"");
            e.printStackTrace();
            mStarted = false;
            initTts();
        } catch (NullPointerException e) {
            // TTS died; restart it.
            Log.e(""TextToSpeech.java - setLanguage"", ""NullPointerException"");
            e.printStackTrace();
            mStarted = false;
            initTts();
        } catch (IllegalStateException e) {
            // TTS died; restart it.
            Log.e(""TextToSpeech.java - setLanguage"", ""IllegalStateException"");
            e.printStackTrace();
            mStarted = false;
            initTts();
        } finally {
            return result;
        }
    }
}","{
    synchronized (mStartLock) {
        int result = LANG_NOT_SUPPORTED;
        if (!mStarted) {
            return result;
        }
        try {
            String language = loc.getISO3Language();
            String country = loc.getISO3Country();
            String variant = loc.getVariant();
            // Check if the language, country, variant are available, and cache
            // the available parts.
            // Note that the language is not actually set here, instead it is cached so it
            // will be associated with all upcoming utterances.
            result = mITts.isLanguageAvailable(language, country, variant, mCachedParams);
            if (result >= LANG_AVAILABLE) {
                mCachedParams[Engine.PARAM_POSITION_LANGUAGE + 1] = language;
                if (result >= LANG_COUNTRY_AVAILABLE) {
                    mCachedParams[Engine.PARAM_POSITION_COUNTRY + 1] = country;
                } else {
                    mCachedParams[Engine.PARAM_POSITION_COUNTRY + 1] = """";
                }
                if (result >= LANG_COUNTRY_VAR_AVAILABLE) {
                    mCachedParams[Engine.PARAM_POSITION_VARIANT + 1] = variant;
                } else {
                    mCachedParams[Engine.PARAM_POSITION_VARIANT + 1] = """";
                }
            }
        } catch (RemoteException e) {
            // TTS died; restart it.
            Log.e(""TextToSpeech.java - setLanguage"", ""RemoteException"");
            e.printStackTrace();
            mStarted = false;
            initTts();
        } catch (NullPointerException e) {
            // TTS died; restart it.
            Log.e(""TextToSpeech.java - setLanguage"", ""NullPointerException"");
            e.printStackTrace();
            mStarted = false;
            initTts();
        } catch (IllegalStateException e) {
            // TTS died; restart it.
            Log.e(""TextToSpeech.java - setLanguage"", ""IllegalStateException"");
            e.printStackTrace();
            mStarted = false;
            initTts();
        } finally {
            return result;
        }
    }
}",1,"/**
 * Sets the language for the TextToSpeech engine.
 * The TextToSpeech engine will try to use the closest match to the specified
 * language as represented by the Locale, but there is no guarantee that the exact same Locale
 * will be used. Use {@link #isLanguageAvailable(Locale)} to check the level of support
 * before choosing the language to use for the next utterances.
 *
 * @param loc
 * The locale describing the language to be used.
 *
 * @return code indicating the support status for the locale. See {@link #LANG_AVAILABLE},
 * {@link #LANG_COUNTRY_AVAILABLE}, {@link #LANG_COUNTRY_VAR_AVAILABLE},
 * {@link #LANG_MISSING_DATA} and {@link #LANG_NOT_SUPPORTED}.
 */
","/**
 * Sets the language for the TextToSpeech engine.
 * The TextToSpeech engine will try to use the closest match to the specified
 * language as represented by the Locale, but there is no guarantee that the exact same Locale
 * will be used. Use {@link #isLanguageAvailable(Locale)} to check the level of support
 * before choosing the language to use for the next utterances.
 *
 * @param loc
 * The locale describing the language to be used.
 *
 * @return code indicating the support status for the locale. See {@link #LANG_AVAILABLE},
 * {@link #LANG_COUNTRY_AVAILABLE}, {@link #LANG_COUNTRY_VAR_AVAILABLE},
 * {@link #LANG_MISSING_DATA} and {@link #LANG_NOT_SUPPORTED}.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3,4",1,"The variable assignment statement (mCachedParams) has changed, and control dependency (if structure) and other statements (variable declaration and string assignment) are introduced. So the code change type is 1,3,4.","The return value of function might change due to changes in variable assignments and if conditionals that determine how the 'result' is calculated. So, the CI type is 1."
290,<android.server.BluetoothService.BondState: boolean isAutoPairingBlacklisted(String)>,7,8,<android.server.BluetoothService.BondState: boolean isAutoPairingBlacklisted(String)>,<android.server.BluetoothService.BondState: boolean isAutoPairingBlacklisted(String)>,0,"{
    for (String blacklistAddress : mAutoPairingAddressBlacklist) {
        if (address.startsWith(blacklistAddress))
            return true;
    }
    String name = getRemoteName(address);
    if (name != null) {
        for (String blacklistName : mAutoPairingExactNameBlacklist) {
            if (name.equals(blacklistName))
                return true;
        }
        for (String blacklistName : mAutoPairingPartialNameBlacklist) {
            if (name.startsWith(blacklistName))
                return true;
        }
    }
    return false;
}","{
    if (mAutoPairingAddressBlacklist != null) {
        for (String blacklistAddress : mAutoPairingAddressBlacklist) {
            if (address.startsWith(blacklistAddress))
                return true;
        }
    }
    if (mAutoPairingDynamicAddressBlacklist != null) {
        for (String blacklistAddress : mAutoPairingDynamicAddressBlacklist) {
            if (address.equals(blacklistAddress))
                return true;
        }
    }
    String name = getRemoteName(address);
    if (name != null) {
        if (mAutoPairingExactNameBlacklist != null) {
            for (String blacklistName : mAutoPairingExactNameBlacklist) {
                if (name.equals(blacklistName))
                    return true;
            }
        }
        if (mAutoPairingPartialNameBlacklist != null) {
            for (String blacklistName : mAutoPairingPartialNameBlacklist) {
                if (name.startsWith(blacklistName))
                    return true;
            }
        }
    }
    return false;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"3,4,5",1,"There are several control statements (if conditions and for loops) are added in the later version of the method. Also, a new list mAutoPairingDynamicAddressBlacklist is introduced and checked, and notably, one dependent API address.equals(blacklistAddress) is used while it's not used in earlier version implementation.",#CI_description
291,<android.content.pm.ApplicationInfo: CharSequence loadDescription(PackageManager)>,7,8,<android.content.pm.ApplicationInfo: CharSequence loadDescription(PackageManager)>,<android.content.pm.ApplicationInfo: CharSequence loadDescription(PackageManager)>,0,"{
    if (descriptionRes != 0) {
        CharSequence label = pm.getText(packageName, descriptionRes, null);
        if (label != null) {
            return label;
        }
    }
    return null;
}","{
    if (descriptionRes != 0) {
        CharSequence label = pm.getText(packageName, descriptionRes, this);
        if (label != null) {
            return label;
        }
    }
    return null;
}",1,"/**
 * Retrieve the textual description of the application.  This
 * will call back on the given PackageManager to load the description from
 * the application.
 *
 * @param pm A PackageManager from which the label can be loaded; usually
 * the PackageManager from which you originally retrieved this item.
 *
 * @return Returns a CharSequence containing the application's description.
 * If there is no description, null is returned.
 */
","/**
 * Retrieve the textual description of the application.  This
 * will call back on the given PackageManager to load the description from
 * the application.
 *
 * @param pm A PackageManager from which the label can be loaded; usually
 * the PackageManager from which you originally retrieved this item.
 *
 * @return Returns a CharSequence containing the application's description.
 * If there is no description, null is returned.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,1,"The third argument fed into the pm.getText method has changed from 'null' to 'this', so the code change type is 4.","Due to the change in the third argument of pm.getText, the return value of the method 'loadDescription' could potentially change, resulting in a CI of type 1."
292,<android.pim.vcard.VCardParser_V21: void handleValue(String)>,7,8,<android.pim.vcard.VCardParser_V21: void handleValue(String)>,<android.pim.vcard.VCardParser_V21: void handleValue(String)>,0,"{
    if (sKnownValueSet.contains(pvalueval.toUpperCase()) || pvalueval.startsWith(""X-"")) {
        if (mBuilder != null) {
            mBuilder.propertyParamType(""VALUE"");
            mBuilder.propertyParamValue(pvalueval);
        }
    } else {
        throw new VCardException(""Unknown value \"""" + pvalueval + ""\"""");
    }
}","{
    if (!sKnownValueSet.contains(pvalueval.toUpperCase()) && pvalueval.startsWith(""X-"") && !mUnknownValueMap.contains(pvalueval)) {
        mUnknownValueMap.add(pvalueval);
        Log.w(LOG_TAG, ""VALUE unsupported by vCard 2.1: "" + pvalueval);
    }
    if (mBuilder != null) {
        mBuilder.propertyParamType(""VALUE"");
        mBuilder.propertyParamValue(pvalueval);
    }
}",1,"/**
 * pvalueval = ""INLINE"" / ""URL"" / ""CONTENT-ID"" / ""CID"" / ""X-"" word
 */
","/**
 * pvalueval = ""INLINE"" / ""URL"" / ""CONTENT-ID"" / ""CID"" / ""X-"" word
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4","1,2","The control dependency (logical conditions inside the ""if"" statement) and exception handling (throw new VCardException) statements have changed and other statements within the conditional block have also changed. Therefore, the code change type is 3,4.","The change in the control dependency can potentially alter the flow of the program, which could possibly lead to different returns or values. The removal of ""throw new VCardException"" in the early version to logging (Log.w) in the late version means the exception handling has also changed between the two versions. The CI type therefore is 1,2."
293,<android.gesture.GestureStore: ArrayList<Prediction> recognize(Gesture)>,7,8,<android.gesture.GestureStore: ArrayList<Prediction> recognize(Gesture)>,<android.gesture.GestureStore: ArrayList<Prediction> recognize(Gesture)>,0,"{
    Instance instance = Instance.createInstance(mSequenceType, mOrientationStyle, gesture, null);
    return mClassifier.classify(mSequenceType, instance.vector);
}","{
    Instance instance = Instance.createInstance(mSequenceType, mOrientationStyle, gesture, null);
    return mClassifier.classify(mSequenceType, mOrientationStyle, instance.vector);
}",1,"/**
 * Recognize a gesture
 *
 * @param gesture the query
 * @return a list of predictions of possible entries for a given gesture
 */
","/**
 * Recognize a gesture
 *
 * @param gesture the query
 * @return a list of predictions of possible entries for a given gesture
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The return statement has been modified and the dependent method 'classify' also changed in its parameters, so the code change type is 1,5.","The method call to 'mClassifier.classify' has changed, which may potentially affect the return value of the 'recognize' method. Thus, the type of compatibility issue is 1."
294,<android.widget.ExpandableListConnector: boolean expandGroup(PositionMetadata)>,7,8,<android.widget.ExpandableListConnector: boolean expandGroup(PositionMetadata)>,<android.widget.ExpandableListConnector: boolean expandGroup(PositionMetadata)>,0,"{
    if (posMetadata.position.groupPos < 0) {
        // TODO clean exit
        throw new RuntimeException(""Need group"");
    }
    if (mMaxExpGroupCount == 0)
        return false;
    // Check to see if it's already expanded
    if (posMetadata.groupMetadata != null)
        return false;
    /* Restrict number of exp groups to mMaxExpGroupCount */
    if (mExpGroupMetadataList.size() >= mMaxExpGroupCount) {
        /* Collapse a group */
        // TODO: Collapse something not on the screen instead of the first one?
        // TODO: Could write overloaded function to take GroupMetadata to collapse
        GroupMetadata collapsedGm = mExpGroupMetadataList.get(0);
        int collapsedIndex = mExpGroupMetadataList.indexOf(collapsedGm);
        collapseGroup(collapsedGm.gPos);
        /* Decrement index if it is after the group we removed */
        if (posMetadata.groupInsertIndex > collapsedIndex) {
            posMetadata.groupInsertIndex--;
        }
    }
    GroupMetadata expandedGm = GroupMetadata.obtain(GroupMetadata.REFRESH, GroupMetadata.REFRESH, posMetadata.position.groupPos, mExpandableListAdapter.getGroupId(posMetadata.position.groupPos));
    mExpGroupMetadataList.add(posMetadata.groupInsertIndex, expandedGm);
    // Refresh the metadata
    refreshExpGroupMetadataList(false, false);
    // Notify of change
    notifyDataSetChanged();
    // Give the callback
    mExpandableListAdapter.onGroupExpanded(expandedGm.gPos);
    return true;
}","{
    if (posMetadata.position.groupPos < 0) {
        // TODO clean exit
        throw new RuntimeException(""Need group"");
    }
    if (mMaxExpGroupCount == 0)
        return false;
    // Check to see if it's already expanded
    if (posMetadata.groupMetadata != null)
        return false;
    /* Restrict number of expanded groups to mMaxExpGroupCount */
    if (mExpGroupMetadataList.size() >= mMaxExpGroupCount) {
        /* Collapse a group */
        // TODO: Collapse something not on the screen instead of the first one?
        // TODO: Could write overloaded function to take GroupMetadata to collapse
        GroupMetadata collapsedGm = mExpGroupMetadataList.get(0);
        int collapsedIndex = mExpGroupMetadataList.indexOf(collapsedGm);
        collapseGroup(collapsedGm.gPos);
        /* Decrement index if it is after the group we removed */
        if (posMetadata.groupInsertIndex > collapsedIndex) {
            posMetadata.groupInsertIndex--;
        }
    }
    GroupMetadata expandedGm = GroupMetadata.obtain(GroupMetadata.REFRESH, GroupMetadata.REFRESH, posMetadata.position.groupPos, mExpandableListAdapter.getGroupId(posMetadata.position.groupPos));
    mExpGroupMetadataList.add(posMetadata.groupInsertIndex, expandedGm);
    // Refresh the metadata
    refreshExpGroupMetadataList(false, false);
    // Notify of change
    notifyDataSetChanged();
    // Give the callback
    mExpandableListAdapter.onGroupExpanded(expandedGm.gPos);
    return true;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,0,0,"There is no change between the early and late versions of the code, therefore the code change type is 0.","Since there is no change in the code, there is no compatibility issue. Therefore, the CI type is 0."
295,<android.hardware.Camera.Parameters: List<Integer> getSupportedPictureFormats()>,7,8,<android.hardware.Camera.Parameters: List<Integer> getSupportedPictureFormats()>,<android.hardware.Camera.Parameters: List<Integer> getSupportedPictureFormats()>,0,"{
    String str = get(KEY_PICTURE_FORMAT + SUPPORTED_VALUES_SUFFIX);
    ArrayList<Integer> formats = new ArrayList<Integer>();
    for (String s : split(str)) {
        int f = pixelFormatForCameraFormat(s);
        if (f == PixelFormat.UNKNOWN)
            continue;
        formats.add(f);
    }
    return formats;
}","{
    String str = get(KEY_PICTURE_FORMAT + SUPPORTED_VALUES_SUFFIX);
    ArrayList<Integer> formats = new ArrayList<Integer>();
    for (String s : split(str)) {
        int f = pixelFormatForCameraFormat(s);
        if (f == ImageFormat.UNKNOWN)
            continue;
        formats.add(f);
    }
    return formats;
}",1,"/**
 * Gets the supported picture formats.
 *
 * @return a List of Integer objects (values are PixelFormat.XXX). This
 * method will always return a list with at least one element.
 */
","/**
 * Gets the supported picture formats.
 *
 * @return supported picture formats. This method will always return a
 * list with at least one element.
 * @see android.graphics.ImageFormat
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,1,"Instead of a PixelFormat being checked for UNKNOWN, an ImageFormat is checked for UNKNOWN in the 'if' statement. This is classified as 'other statements changed'.","Due to the change from PixelFormat to ImageFormat, depending on the ImageFormats being processed, the returned List of integers may differ compared to the original function, leading to potential compatibility issues."
296,"<android.provider.Settings.System: String getString(ContentResolver,String)>",7,8,"<android.provider.Settings.System: String getString(ContentResolver,String)>","<android.provider.Settings.System: String getString(ContentResolver,String)>",0,"{
    if (MOVED_TO_SECURE.contains(name)) {
        Log.w(TAG, ""Setting "" + name + "" has moved from android.provider.Settings.System"" + "" to android.provider.Settings.Secure, returning read-only value."");
        return Secure.getString(resolver, name);
    }
    if (mNameValueCache == null) {
        mNameValueCache = new NameValueCache(SYS_PROP_SETTING_VERSION, CONTENT_URI);
    }
    return mNameValueCache.getString(resolver, name);
}","{
    if (MOVED_TO_SECURE.contains(name)) {
        Log.w(TAG, ""Setting "" + name + "" has moved from android.provider.Settings.System"" + "" to android.provider.Settings.Secure, returning read-only value."");
        return Secure.getString(resolver, name);
    }
    if (sNameValueCache == null) {
        sNameValueCache = new NameValueCache(SYS_PROP_SETTING_VERSION, CONTENT_URI, CALL_METHOD_GET_SYSTEM);
    }
    return sNameValueCache.getString(resolver, name);
}",1,"/**
 * Look up a name in the database.
 * @param resolver to access the database with
 * @param name to look up in the table
 * @return the corresponding value, or null if not present
 */
","/**
 * Look up a name in the database.
 * @param resolver to access the database with
 * @param name to look up in the table
 * @return the corresponding value, or null if not present
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,4,5",1,"The return statements have not changed, but the objects and the method that are being called have changed. This indicates that there has been a change in the dependent API and other statements in the method. Hence, the change types are 1, 4, and 5.","Since there have been changes in the variables and the dependent APIs, the return values of the method could potentially be different. Therefore, a compatibility issue exists and it's caused by potential different return values, making the CI type 1."
297,"<android.pim.vcard.VCardUtils: String constructNameFromElements(int,String,String,String,String,String)>",7,8,"<android.pim.vcard.VCardUtils: String constructNameFromElements(int,String,String,String,String,String)>","<android.pim.vcard.VCardUtils: String constructNameFromElements(int,String,String,String,String,String)>",0,"{
    StringBuilder builder = new StringBuilder();
    String[] nameList = sortNameElements(nameOrderType, familyName, middleName, givenName);
    boolean first = true;
    if (!TextUtils.isEmpty(prefix)) {
        first = false;
        builder.append(prefix);
    }
    for (String namePart : nameList) {
        if (!TextUtils.isEmpty(namePart)) {
            if (first) {
                first = false;
            } else {
                builder.append(' ');
            }
            builder.append(namePart);
        }
    }
    if (!TextUtils.isEmpty(suffix)) {
        if (!first) {
            builder.append(' ');
        }
        builder.append(suffix);
    }
    return builder.toString();
}","{
    final StringBuilder builder = new StringBuilder();
    final String[] nameList = sortNameElements(vcardType, familyName, middleName, givenName);
    boolean first = true;
    if (!TextUtils.isEmpty(prefix)) {
        first = false;
        builder.append(prefix);
    }
    for (final String namePart : nameList) {
        if (!TextUtils.isEmpty(namePart)) {
            if (first) {
                first = false;
            } else {
                builder.append(' ');
            }
            builder.append(namePart);
        }
    }
    if (!TextUtils.isEmpty(suffix)) {
        if (!first) {
            builder.append(' ');
        }
        builder.append(suffix);
    }
    return builder.toString();
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"4,5",1,"The change occur in the initialization of the String array 'nameList', specifically, the parameter 'nameOrderType' changed to 'vcardType' which affects the outcome of 'sortNameElements()' method. Therefore, the statement and dependent API are changed and the change is classified as 4,5.","The change in the parameter of the 'sortNameElements()' function could potentially lead to a different sequence of sorted name elements, which is likely to result in a different return value from the 'constructNameFromElements()' method. Thus, it gives rise to compatibility issue of type 1."
300,<android.content.SyncContext: IBinder getSyncContextBinder()>,7,8,<android.content.SyncContext: IBinder getSyncContextBinder()>,<android.content.SyncContext: IBinder getSyncContextBinder()>,0,"{
    return mSyncContext.asBinder();
}","{
    return (mSyncContext == null) ? null : mSyncContext.asBinder();
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,1,1,"The return statement has been changed from `return mSyncContext.asBinder()` to `return (mSyncContext == null) ? null : mSyncContext.asBinder()` to handle `null` scenario. So, the classification of the change is 1, representing ""Return statement changed"".","In the late code version, a condition is introduced to check if `mSyncContext` is `null`, this addition potentially changes the return value of the function. If `mSyncContext` is null, in the early version an error would be thrown, while in the late version `null` would be returned. This modification can lead to a different behaviour between two versions, hence a compatibility issue of type 1 (Compatibility Issue caused by potential different return values or types) arises."
302,<android.widget.HorizontalScrollView: boolean onInterceptTouchEvent(MotionEvent)>,7,8,<android.widget.HorizontalScrollView: boolean onInterceptTouchEvent(MotionEvent)>,<android.widget.HorizontalScrollView: boolean onInterceptTouchEvent(MotionEvent)>,0,"{
    /*
         * This method JUST determines whether we want to intercept the motion.
         * If we return true, onMotionEvent will be called and we do the actual
         * scrolling there.
         */
    /*
        * Shortcut the most recurring case: the user is in the dragging
        * state and he is moving his finger.  We want to intercept this
        * motion.
        */
    final int action = ev.getAction();
    if ((action == MotionEvent.ACTION_MOVE) && (mIsBeingDragged)) {
        return true;
    }
    if (!canScroll()) {
        mIsBeingDragged = false;
        return false;
    }
    final float x = ev.getX();
    switch(action) {
        case MotionEvent.ACTION_MOVE:
            /*
                 * mIsBeingDragged == false, otherwise the shortcut would have caught it. Check
                 * whether the user has moved far enough from his original down touch.
                 */
            /*
                * Locally do absolute value. mLastMotionX is set to the x value
                * of the down event.
                */
            final int xDiff = (int) Math.abs(x - mLastMotionX);
            if (xDiff > mTouchSlop) {
                mIsBeingDragged = true;
                if (mParent != null)
                    mParent.requestDisallowInterceptTouchEvent(true);
            }
            break;
        case MotionEvent.ACTION_DOWN:
            /* Remember location of down touch */
            mLastMotionX = x;
            /*
                * If being flinged and user touches the screen, initiate drag;
                * otherwise don't.  mScroller.isFinished should be false when
                * being flinged.
                */
            mIsBeingDragged = !mScroller.isFinished();
            break;
        case MotionEvent.ACTION_CANCEL:
        case MotionEvent.ACTION_UP:
            /* Release the drag */
            mIsBeingDragged = false;
            break;
    }
    /*
        * The only time we want to intercept motion events is if we are in the
        * drag mode.
        */
    return mIsBeingDragged;
}","{
    /*
         * This method JUST determines whether we want to intercept the motion.
         * If we return true, onMotionEvent will be called and we do the actual
         * scrolling there.
         */
    /*
        * Shortcut the most recurring case: the user is in the dragging
        * state and he is moving his finger.  We want to intercept this
        * motion.
        */
    final int action = ev.getAction();
    if ((action == MotionEvent.ACTION_MOVE) && (mIsBeingDragged)) {
        return true;
    }
    switch(action & MotionEvent.ACTION_MASK) {
        case MotionEvent.ACTION_MOVE:
            {
                /*
                 * mIsBeingDragged == false, otherwise the shortcut would have caught it. Check
                 * whether the user has moved far enough from his original down touch.
                 */
                /*
                * Locally do absolute value. mLastMotionX is set to the x value
                * of the down event.
                */
                final int activePointerId = mActivePointerId;
                if (activePointerId == INVALID_POINTER) {
                    // If we don't have a valid id, the touch down wasn't on content.
                    break;
                }
                final int pointerIndex = ev.findPointerIndex(activePointerId);
                final float x = ev.getX(pointerIndex);
                final int xDiff = (int) Math.abs(x - mLastMotionX);
                if (xDiff > mTouchSlop) {
                    mIsBeingDragged = true;
                    mLastMotionX = x;
                    if (mParent != null)
                        mParent.requestDisallowInterceptTouchEvent(true);
                }
                break;
            }
        case MotionEvent.ACTION_DOWN:
            {
                final float x = ev.getX();
                if (!inChild((int) x, (int) ev.getY())) {
                    mIsBeingDragged = false;
                    break;
                }
                /*
                 * Remember location of down touch.
                 * ACTION_DOWN always refers to pointer index 0.
                 */
                mLastMotionX = x;
                mActivePointerId = ev.getPointerId(0);
                /*
                * If being flinged and user touches the screen, initiate drag;
                * otherwise don't.  mScroller.isFinished should be false when
                * being flinged.
                */
                mIsBeingDragged = !mScroller.isFinished();
                break;
            }
        case MotionEvent.ACTION_CANCEL:
        case MotionEvent.ACTION_UP:
            /* Release the drag */
            mIsBeingDragged = false;
            mActivePointerId = INVALID_POINTER;
            break;
        case MotionEvent.ACTION_POINTER_UP:
            onSecondaryPointerUp(ev);
            break;
    }
    /*
        * The only time we want to intercept motion events is if we are in the
        * drag mode.
        */
    return mIsBeingDragged;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,4",1,"The logic related to control dependency (i.e., the condition statements and 'switch' case handler) and several other statements have changed, so the code change type is 3,4.","As the conditons for setting the boolean type return variable mIsBeingDragged change, the value returned by getRootView() may potentially be different, thus the CI type is 1."
303,"<android.webkit.WebViewDatabase: void addCache(String,CacheResult)>",7,8,"<android.webkit.WebViewDatabase: void addCache(String,CacheResult)>","<android.webkit.WebViewDatabase: void addCache(String,CacheResult)>",0,"{
    if (url == null || mCacheDatabase == null) {
        return;
    }
    mCacheInserter.prepareForInsert();
    mCacheInserter.bind(mCacheUrlColIndex, url);
    mCacheInserter.bind(mCacheFilePathColIndex, c.localPath);
    mCacheInserter.bind(mCacheLastModifyColIndex, c.lastModified);
    mCacheInserter.bind(mCacheETagColIndex, c.etag);
    mCacheInserter.bind(mCacheExpiresColIndex, c.expires);
    mCacheInserter.bind(mCacheExpiresStringColIndex, c.expiresString);
    mCacheInserter.bind(mCacheMimeTypeColIndex, c.mimeType);
    mCacheInserter.bind(mCacheEncodingColIndex, c.encoding);
    mCacheInserter.bind(mCacheHttpStatusColIndex, c.httpStatusCode);
    mCacheInserter.bind(mCacheLocationColIndex, c.location);
    mCacheInserter.bind(mCacheContentLengthColIndex, c.contentLength);
    mCacheInserter.bind(mCacheContentDispositionColIndex, c.contentdisposition);
    mCacheInserter.execute();
}","{
    if (url == null || mCacheDatabase == null) {
        return;
    }
    mCacheInserter.prepareForInsert();
    mCacheInserter.bind(mCacheUrlColIndex, url);
    mCacheInserter.bind(mCacheFilePathColIndex, c.localPath);
    mCacheInserter.bind(mCacheLastModifyColIndex, c.lastModified);
    mCacheInserter.bind(mCacheETagColIndex, c.etag);
    mCacheInserter.bind(mCacheExpiresColIndex, c.expires);
    mCacheInserter.bind(mCacheExpiresStringColIndex, c.expiresString);
    mCacheInserter.bind(mCacheMimeTypeColIndex, c.mimeType);
    mCacheInserter.bind(mCacheEncodingColIndex, c.encoding);
    mCacheInserter.bind(mCacheHttpStatusColIndex, c.httpStatusCode);
    mCacheInserter.bind(mCacheLocationColIndex, c.location);
    mCacheInserter.bind(mCacheContentLengthColIndex, c.contentLength);
    mCacheInserter.bind(mCacheContentDispositionColIndex, c.contentdisposition);
    mCacheInserter.bind(mCacheCrossDomainColIndex, c.crossDomain);
    mCacheInserter.execute();
}",1,"/**
 * Add or update a cache. CACHE_URL_COL is unique in the table.
 *
 * @param url The url
 * @param c The CacheManager.CacheResult
 */
","/**
 * Add or update a cache. CACHE_URL_COL is unique in the table.
 *
 * @param url The url
 * @param c The CacheManager.CacheResult
 */
",-1,,,-1,-1,-1,-1,-1,-1,1,0,"There's an additional line of binding cross domain index with value c.crossDomain in the late implementation. So, the type of change is 1.","The added statement is about binding an additional attribute in database and it doesn't produce any different return value or exception handling, so there should be no compatibility issue. Therefore, the CI type is 0."
304,<android.server.search.Searchables: void buildSearchableList()>,7,8,<android.server.search.Searchables: void buildSearchableList()>,<android.server.search.Searchables: void buildSearchableList()>,0,"{
    // These will become the new values at the end of the method
    HashMap<ComponentName, SearchableInfo> newSearchablesMap = new HashMap<ComponentName, SearchableInfo>();
    ArrayList<SearchableInfo> newSearchablesList = new ArrayList<SearchableInfo>();
    ArrayList<SearchableInfo> newSearchablesInGlobalSearchList = new ArrayList<SearchableInfo>();
    ArrayList<SearchableInfo> newSearchablesForWebSearchList = new ArrayList<SearchableInfo>();
    final PackageManager pm = mContext.getPackageManager();
    // Use intent resolver to generate list of ACTION_SEARCH & ACTION_WEB_SEARCH receivers.
    List<ResolveInfo> searchList;
    final Intent intent = new Intent(Intent.ACTION_SEARCH);
    searchList = pm.queryIntentActivities(intent, PackageManager.GET_META_DATA);
    List<ResolveInfo> webSearchInfoList;
    final Intent webSearchIntent = new Intent(Intent.ACTION_WEB_SEARCH);
    webSearchInfoList = pm.queryIntentActivities(webSearchIntent, PackageManager.GET_META_DATA);
    // analyze each one, generate a Searchables record, and record
    if (searchList != null || webSearchInfoList != null) {
        int search_count = (searchList == null ? 0 : searchList.size());
        int web_search_count = (webSearchInfoList == null ? 0 : webSearchInfoList.size());
        int count = search_count + web_search_count;
        for (int ii = 0; ii < count; ii++) {
            // for each component, try to find metadata
            ResolveInfo info = (ii < search_count) ? searchList.get(ii) : webSearchInfoList.get(ii - search_count);
            ActivityInfo ai = info.activityInfo;
            // Check first to avoid duplicate entries.
            if (newSearchablesMap.get(new ComponentName(ai.packageName, ai.name)) == null) {
                SearchableInfo searchable = SearchableInfo.getActivityMetaData(mContext, ai);
                if (searchable != null) {
                    newSearchablesList.add(searchable);
                    newSearchablesMap.put(searchable.getSearchActivity(), searchable);
                    if (searchable.shouldIncludeInGlobalSearch()) {
                        newSearchablesInGlobalSearchList.add(searchable);
                    }
                }
            }
        }
    }
    if (webSearchInfoList != null) {
        for (int i = 0; i < webSearchInfoList.size(); ++i) {
            ActivityInfo ai = webSearchInfoList.get(i).activityInfo;
            ComponentName component = new ComponentName(ai.packageName, ai.name);
            SearchableInfo searchable = newSearchablesMap.get(component);
            if (searchable == null) {
                Log.w(LOG_TAG, ""did not find component in searchables: "" + component);
            } else {
                newSearchablesForWebSearchList.add(searchable);
            }
        }
    }
    // Find the global search provider
    Intent globalSearchIntent = new Intent(SearchManager.INTENT_ACTION_GLOBAL_SEARCH);
    ComponentName globalSearchActivity = globalSearchIntent.resolveActivity(pm);
    SearchableInfo newDefaultSearchable = newSearchablesMap.get(globalSearchActivity);
    if (newDefaultSearchable == null) {
        Log.w(LOG_TAG, ""No searchable info found for new default searchable activity "" + globalSearchActivity);
    }
    // Find the default web search provider.
    ComponentName webSearchActivity = getPreferredWebSearchActivity(mContext);
    SearchableInfo newDefaultSearchableForWebSearch = null;
    if (webSearchActivity != null) {
        newDefaultSearchableForWebSearch = newSearchablesMap.get(webSearchActivity);
    }
    if (newDefaultSearchableForWebSearch == null) {
        Log.w(LOG_TAG, ""No searchable info found for new default web search activity "" + webSearchActivity);
    }
    // Store a consistent set of new values
    synchronized (this) {
        mSearchablesMap = newSearchablesMap;
        mSearchablesList = newSearchablesList;
        mSearchablesInGlobalSearchList = newSearchablesInGlobalSearchList;
        mSearchablesForWebSearchList = newSearchablesForWebSearchList;
        mDefaultSearchable = newDefaultSearchable;
        mDefaultSearchableForWebSearch = newDefaultSearchableForWebSearch;
    }
}","{
    // These will become the new values at the end of the method
    HashMap<ComponentName, SearchableInfo> newSearchablesMap = new HashMap<ComponentName, SearchableInfo>();
    ArrayList<SearchableInfo> newSearchablesList = new ArrayList<SearchableInfo>();
    ArrayList<SearchableInfo> newSearchablesInGlobalSearchList = new ArrayList<SearchableInfo>();
    final PackageManager pm = mContext.getPackageManager();
    // Use intent resolver to generate list of ACTION_SEARCH & ACTION_WEB_SEARCH receivers.
    List<ResolveInfo> searchList;
    final Intent intent = new Intent(Intent.ACTION_SEARCH);
    searchList = pm.queryIntentActivities(intent, PackageManager.GET_META_DATA);
    List<ResolveInfo> webSearchInfoList;
    final Intent webSearchIntent = new Intent(Intent.ACTION_WEB_SEARCH);
    webSearchInfoList = pm.queryIntentActivities(webSearchIntent, PackageManager.GET_META_DATA);
    // analyze each one, generate a Searchables record, and record
    if (searchList != null || webSearchInfoList != null) {
        int search_count = (searchList == null ? 0 : searchList.size());
        int web_search_count = (webSearchInfoList == null ? 0 : webSearchInfoList.size());
        int count = search_count + web_search_count;
        for (int ii = 0; ii < count; ii++) {
            // for each component, try to find metadata
            ResolveInfo info = (ii < search_count) ? searchList.get(ii) : webSearchInfoList.get(ii - search_count);
            ActivityInfo ai = info.activityInfo;
            // Check first to avoid duplicate entries.
            if (newSearchablesMap.get(new ComponentName(ai.packageName, ai.name)) == null) {
                SearchableInfo searchable = SearchableInfo.getActivityMetaData(mContext, ai);
                if (searchable != null) {
                    newSearchablesList.add(searchable);
                    newSearchablesMap.put(searchable.getSearchActivity(), searchable);
                    if (searchable.shouldIncludeInGlobalSearch()) {
                        newSearchablesInGlobalSearchList.add(searchable);
                    }
                }
            }
        }
    }
    // Find the global search activity
    ComponentName newGlobalSearchActivity = findGlobalSearchActivity();
    // Find the web search activity
    ComponentName newWebSearchActivity = findWebSearchActivity(newGlobalSearchActivity);
    // Store a consistent set of new values
    synchronized (this) {
        mSearchablesMap = newSearchablesMap;
        mSearchablesList = newSearchablesList;
        mSearchablesInGlobalSearchList = newSearchablesInGlobalSearchList;
        mGlobalSearchActivity = newGlobalSearchActivity;
        mWebSearchActivity = newWebSearchActivity;
    }
}",1,"/**
 * Builds an entire list (suitable for display) of
 * activities that are searchable, by iterating the entire set of
 * ACTION_SEARCH & ACTION_WEB_SEARCH intents.
 *
 * Also clears the hash of all activities -> searches which will
 * refill as the user clicks ""search"".
 *
 * This should only be done at startup and again if we know that the
 * list has changed.
 *
 * TODO: every activity that provides a ACTION_SEARCH intent should
 * also provide searchability meta-data.  There are a bunch of checks here
 * that, if data is not found, silently skip to the next activity.  This
 * won't help a developer trying to figure out why their activity isn't
 * showing up in the list, but an exception here is too rough.  I would
 * like to find a better notification mechanism.
 *
 * TODO: sort the list somehow?  UI choice.
 */
","/**
 * Builds an entire list (suitable for display) of
 * activities that are searchable, by iterating the entire set of
 * ACTION_SEARCH & ACTION_WEB_SEARCH intents.
 *
 * Also clears the hash of all activities -> searches which will
 * refill as the user clicks ""search"".
 *
 * This should only be done at startup and again if we know that the
 * list has changed.
 *
 * TODO: every activity that provides a ACTION_SEARCH intent should
 * also provide searchability meta-data.  There are a bunch of checks here
 * that, if data is not found, silently skip to the next activity.  This
 * won't help a developer trying to figure out why their activity isn't
 * showing up in the list, but an exception here is too rough.  I would
 * like to find a better notification mechanism.
 *
 * TODO: sort the list somehow?  UI choice.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The operations for finding global search activity and web search activity have been encapsulated into two new methods 'findGlobalSearchActivity()' and 'findWebSearchActivity(newGlobalSearchActivity)'. Given no changes to the method signatures, and the overall behavior of the API method, the code change type is 4.","Although the specific operations to find global search activity and web search activity have been altered, this doesn't cause any Compatibility Issue, as the changes don't affect the return value or exception thrown by the API. Therefore, the CI type is 0."
305,"<android.webkit.CacheManager: CacheResult getCacheFile(String,Map<String, String>)>",7,8,"<android.webkit.CacheManager: CacheResult getCacheFile(String,Map<String, String>)>","<android.webkit.CacheManager: CacheResult getCacheFile(String,Map<String, String>)>",0,"{
    if (mDisabled) {
        return null;
    }
    CacheResult result = mDataBase.getCache(url);
    if (result != null) {
        if (result.contentLength == 0) {
            if (!checkCacheRedirect(result.httpStatusCode)) {
                // this should not happen. If it does, remove it.
                mDataBase.removeCache(url);
                return null;
            }
        } else {
            File src = new File(mBaseDir, result.localPath);
            try {
                // open here so that even the file is deleted, the content
                // is still readable by the caller until close() is called
                result.inStream = new FileInputStream(src);
            } catch (FileNotFoundException e) {
                // the files in the cache directory can be removed by the
                // system. If it is gone, clean up the database
                mDataBase.removeCache(url);
                return null;
            }
        }
    } else {
        return null;
    }
    // negative expires means time in the far future.
    if (headers != null && result.expires >= 0 && result.expires <= System.currentTimeMillis()) {
        if (result.lastModified == null && result.etag == null) {
            return null;
        }
        // for requesting validation
        if (result.etag != null) {
            headers.put(HEADER_KEY_IFNONEMATCH, result.etag);
        }
        if (result.lastModified != null) {
            headers.put(HEADER_KEY_IFMODIFIEDSINCE, result.lastModified);
        }
    }
    if (DebugFlags.CACHE_MANAGER) {
        Log.v(LOGTAG, ""getCacheFile for url "" + url);
    }
    return result;
}","{
    return getCacheFile(url, 0, headers);
}",1,"// only called from WebCore thread
","/**
 * Given a url, returns the CacheResult if exists. Otherwise returns null.
 * If headers are provided and a cache needs validation,
 * HEADER_KEY_IFNONEMATCH or HEADER_KEY_IFMODIFIEDSINCE will be set in the
 * cached headers.
 *
 * @return the CacheResult for a given url
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The whole body of the method has been replaced by a single return statement, hence the return statement is changed and the Dependent API also changed, making the change types 1 and 5.","The original method was performing multiple operations and had several return statements based on different conditions. However, in the late version, the method simply returns the result from `getCacheFile(url, 0, headers)`. This change will likely cause the method to return different values, hence the compatibility issue type is 1."
306,"<android.widget.HorizontalScrollView: void smoothScrollBy(int,int)>",7,8,"<android.widget.HorizontalScrollView: void smoothScrollBy(int,int)>","<android.widget.HorizontalScrollView: void smoothScrollBy(int,int)>",0,"{
    long duration = AnimationUtils.currentAnimationTimeMillis() - mLastScroll;
    if (duration > ANIMATED_SCROLL_GAP) {
        mScroller.startScroll(mScrollX, mScrollY, dx, dy);
        awakenScrollBars(mScroller.getDuration());
        invalidate();
    } else {
        if (!mScroller.isFinished()) {
            mScroller.abortAnimation();
        }
        scrollBy(dx, dy);
    }
    mLastScroll = AnimationUtils.currentAnimationTimeMillis();
}","{
    if (getChildCount() == 0) {
        // Nothing to do.
        return;
    }
    long duration = AnimationUtils.currentAnimationTimeMillis() - mLastScroll;
    if (duration > ANIMATED_SCROLL_GAP) {
        final int width = getWidth() - mPaddingRight - mPaddingLeft;
        final int right = getChildAt(0).getWidth();
        final int maxX = Math.max(0, right - width);
        final int scrollX = mScrollX;
        dx = Math.max(0, Math.min(scrollX + dx, maxX)) - scrollX;
        mScroller.startScroll(scrollX, mScrollY, dx, 0);
        invalidate();
    } else {
        if (!mScroller.isFinished()) {
            mScroller.abortAnimation();
        }
        scrollBy(dx, dy);
    }
    mLastScroll = AnimationUtils.currentAnimationTimeMillis();
}",1,"/**
 * Like {@link View#scrollBy}, but scroll smoothly instead of immediately.
 *
 * @param dx the number of pixels to scroll by on the X axis
 * @param dy the number of pixels to scroll by on the Y axis
 */
","/**
 * Like {@link View#scrollBy}, but scroll smoothly instead of immediately.
 *
 * @param dx the number of pixels to scroll by on the X axis
 * @param dy the number of pixels to scroll by on the Y axis
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3,4",1,"Early vs. late version changes include a new early return check control implemented if child count is zero, hence, the code change type is 3. Additionally, the parameter used in the 'startScroll' function has changed, so the code change type is 1. A new calculation is done for 'dx', hence the code change type is 4.","The new return in the condition check for child count being zero, as well as the changed calculation of 'dx', could potentially lead to different behaviors in the late version (may return nothing or different values), thus the CI type is 1."
307,<android.webkit.WebViewDatabase: String[] getUsernamePassword(String)>,7,8,<android.webkit.WebViewDatabase: String[] getUsernamePassword(String)>,<android.webkit.WebViewDatabase: String[] getUsernamePassword(String)>,0,"{
    if (schemePlusHost == null || mDatabase == null) {
        return null;
    }
    final String[] columns = new String[] { PASSWORD_USERNAME_COL, PASSWORD_PASSWORD_COL };
    final String selection = ""("" + PASSWORD_HOST_COL + "" == ?)"";
    synchronized (mPasswordLock) {
        String[] ret = null;
        Cursor cursor = mDatabase.query(mTableNames[TABLE_PASSWORD_ID], columns, selection, new String[] { schemePlusHost }, null, null, null);
        if (cursor.moveToFirst()) {
            ret = new String[2];
            ret[0] = cursor.getString(cursor.getColumnIndex(PASSWORD_USERNAME_COL));
            ret[1] = cursor.getString(cursor.getColumnIndex(PASSWORD_PASSWORD_COL));
        }
        cursor.close();
        return ret;
    }
}","{
    if (schemePlusHost == null || mDatabase == null) {
        return null;
    }
    final String[] columns = new String[] { PASSWORD_USERNAME_COL, PASSWORD_PASSWORD_COL };
    final String selection = ""("" + PASSWORD_HOST_COL + "" == ?)"";
    synchronized (mPasswordLock) {
        String[] ret = null;
        Cursor cursor = null;
        try {
            cursor = mDatabase.query(mTableNames[TABLE_PASSWORD_ID], columns, selection, new String[] { schemePlusHost }, null, null, null);
            if (cursor.moveToFirst()) {
                ret = new String[2];
                ret[0] = cursor.getString(cursor.getColumnIndex(PASSWORD_USERNAME_COL));
                ret[1] = cursor.getString(cursor.getColumnIndex(PASSWORD_PASSWORD_COL));
            }
        } catch (IllegalStateException e) {
            Log.e(LOGTAG, ""getUsernamePassword"", e);
        } finally {
            if (cursor != null)
                cursor.close();
        }
        return ret;
    }
}",1,"/**
 * Retrieve the username and password for a given host
 *
 * @param schemePlusHost The scheme and host which passwords applies to
 * @return String[] if found, String[0] is username, which can be null and
 * String[1] is password. Return null if it can't find anything.
 */
","/**
 * Retrieve the username and password for a given host
 *
 * @param schemePlusHost The scheme and host which passwords applies to
 * @return String[] if found, String[0] is username, which can be null and
 * String[1] is password. Return null if it can't find anything.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,3","1,2","The main changes are the introduction of a try-catch block and the move of the Cursor null check and close() call to the finally block, which shows that Exceptions and control dependencies have changed, categorized as 2,3.","The introduction of exception handling could lead to behavior changes in the form of potentially different exceptions thrown when the late version API is invoked. Also, the 'return ret' can be different due to the introduction of exception statement. Thus, the CI type is 1,2."
308,<android.widget.ExpandableListView: int getFlatListPosition(long)>,7,8,<android.widget.ExpandableListView: int getFlatListPosition(long)>,<android.widget.ExpandableListView: int getFlatListPosition(long)>,0,"{
    PositionMetadata pm = mConnector.getFlattenedPos(ExpandableListPosition.obtainPosition(packedPosition));
    int retValue = pm.position.flatListPos;
    pm.recycle();
    return retValue;
}","{
    PositionMetadata pm = mConnector.getFlattenedPos(ExpandableListPosition.obtainPosition(packedPosition));
    final int flatListPosition = pm.position.flatListPos;
    pm.recycle();
    return getAbsoluteFlatPosition(flatListPosition);
}",1,"/**
 * Converts a group and/or child position to a flat list position. This is
 * useful in situations where the caller needs to use the underlying
 * {@link ListView}'s methods.
 *
 * @param packedPosition The group and/or child positions to be converted in
 * packed position representation. Use
 * {@link #getPackedPositionForChild(int, int)} or
 * {@link #getPackedPositionForGroup(int)}.
 * @return The flat list position for the given child or group.
 */
","/**
 * Converts a group and/or child position to a flat list position. This is
 * useful in situations where the caller needs to use the underlying
 * {@link ListView}'s methods.
 *
 * @param packedPosition The group and/or child positions to be converted in
 * packed position representation. Use
 * {@link #getPackedPositionForChild(int, int)} or
 * {@link #getPackedPositionForGroup(int)}.
 * @return The flat list position for the given child or group.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The return statement has changed from ""return retValue"" to ""return getAbsoluteFlatPosition(flatListPosition)"" and the dependent method has changed as well. Therefore, the code change is of type 1 and 5.","The different return statements in both version APIs could potentially lead to different return values. Thus, there is a compatibility issue of type 1."
309,"<android.util.Log: int e(String,String)>",7,8,"<android.util.Log: int e(String,String)>","<android.util.Log: int e(String,String)>",0,"{
    return println(ERROR, tag, msg);
}","{
    return println_native(LOG_ID_MAIN, ERROR, tag, msg);
}",1,"/**
 * Send an {@link #ERROR} log message.
 * @param tag Used to identify the source of a log message.  It usually identifies
 * the class or activity where the log call occurs.
 * @param msg The message you would like logged.
 */
","/**
 * Send an {@link #ERROR} log message.
 * @param tag Used to identify the source of a log message.  It usually identifies
 * the class or activity where the log call occurs.
 * @param msg The message you would like logged.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The return statement changed from println(ERROR, tag, msg) to println_native(LOG_ID_MAIN, ERROR, tag, msg), and the dependent API name and arguments changed.",#CI_description
310,<android.text.Layout: int getHeight()>,7,8,<android.text.Layout: int getHeight()>,<android.text.Layout: int getHeight()>,0,"{
    // same as getLineBottom(getLineCount() - 1);
    return getLineTop(getLineCount());
}","{
    return getLineTop(getLineCount());
}",1,"/**
 * Return the total height of this layout.
 */
","/**
 * Return the total height of this layout.
 */
",-1,,,-1,-1,-1,-1,-1,-1,0,0,There is no change between the early version and the late version.,"Since there is no change between the early version and the late version, no compatibility issue exists."
311,"<android.widget.ScrollView: void smoothScrollBy(int,int)>",7,8,"<android.widget.ScrollView: void smoothScrollBy(int,int)>","<android.widget.ScrollView: void smoothScrollBy(int,int)>",0,"{
    long duration = AnimationUtils.currentAnimationTimeMillis() - mLastScroll;
    if (duration > ANIMATED_SCROLL_GAP) {
        mScroller.startScroll(mScrollX, mScrollY, dx, dy);
        awakenScrollBars(mScroller.getDuration());
        invalidate();
    } else {
        if (!mScroller.isFinished()) {
            mScroller.abortAnimation();
        }
        scrollBy(dx, dy);
    }
    mLastScroll = AnimationUtils.currentAnimationTimeMillis();
}","{
    if (getChildCount() == 0) {
        // Nothing to do.
        return;
    }
    long duration = AnimationUtils.currentAnimationTimeMillis() - mLastScroll;
    if (duration > ANIMATED_SCROLL_GAP) {
        final int height = getHeight() - mPaddingBottom - mPaddingTop;
        final int bottom = getChildAt(0).getHeight();
        final int maxY = Math.max(0, bottom - height);
        final int scrollY = mScrollY;
        dy = Math.max(0, Math.min(scrollY + dy, maxY)) - scrollY;
        mScroller.startScroll(mScrollX, scrollY, 0, dy);
        invalidate();
    } else {
        if (!mScroller.isFinished()) {
            mScroller.abortAnimation();
        }
        scrollBy(dx, dy);
    }
    mLastScroll = AnimationUtils.currentAnimationTimeMillis();
}",1,"/**
 * Like {@link View#scrollBy}, but scroll smoothly instead of immediately.
 *
 * @param dx the number of pixels to scroll by on the X axis
 * @param dy the number of pixels to scroll by on the Y axis
 */
","/**
 * Like {@link View#scrollBy}, but scroll smoothly instead of immediately.
 *
 * @param dx the number of pixels to scroll by on the X axis
 * @param dy the number of pixels to scroll by on the Y axis
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3,4",1,Multiple changes detectable here: ,"3) Some new variable assignments are not related to control dependencies, marked as 4."
313,"<android.accounts.AccountManager: String blockingGetAuthToken(Account,String,boolean)>",7,8,"<android.accounts.AccountManager: String blockingGetAuthToken(Account,String,boolean)>","<android.accounts.AccountManager: String blockingGetAuthToken(Account,String,boolean)>",0,"{
    Bundle bundle = getAuthToken(account, authTokenType, notifyAuthFailure, null, /* callback */
    null).getResult();
    return bundle.getString(KEY_AUTHTOKEN);
}","{
    if (account == null)
        throw new IllegalArgumentException(""account is null"");
    if (authTokenType == null)
        throw new IllegalArgumentException(""authTokenType is null"");
    Bundle bundle = getAuthToken(account, authTokenType, notifyAuthFailure, null, /* callback */
    null).getResult();
    if (bundle == null) {
        // This should never happen, but it does, occasionally. If it does return null to
        // signify that we were not able to get the authtoken.
        // TODO: remove this when the bug is found that sometimes causes a null bundle to be
        // returned
        Log.e(TAG, ""blockingGetAuthToken: null was returned from getResult() for "" + account + "", authTokenType "" + authTokenType);
        return null;
    }
    return bundle.getString(KEY_AUTHTOKEN);
}",1,"/**
 * Convenience method that makes a blocking call to
 * {@link #getAuthToken(Account, String, boolean, AccountManagerCallback, Handler)}
 * then extracts and returns the value of {@link #KEY_AUTHTOKEN} from its result.
 * <p>
 * Requires that the caller has permission {@link android.Manifest.permission#USE_CREDENTIALS}.
 * @param account the account whose authtoken is to be retrieved, must not be null
 * @param authTokenType the type of authtoken to retrieve
 * @param notifyAuthFailure if true, cause the AccountManager to put up a ""sign-on"" notification
 * for the account if no authtoken is cached by the AccountManager and the the authenticator
 * does not have valid credentials to get an authtoken.
 * @return an authtoken for the given account and authTokenType, if one is cached by the
 * AccountManager, null otherwise.
 * @throws AuthenticatorException if the authenticator is not present, unreachable or returns
 * an invalid response.
 * @throws OperationCanceledException if the request is canceled for any reason
 * @throws java.io.IOException if the authenticator experiences an IOException while attempting
 * to communicate with its backend server.
 */
","/**
 * This convenience helper synchronously gets an auth token with
 * {@link #getAuthToken(Account, String, boolean, AccountManagerCallback, Handler)}.
 *
 * <p>This method may block while a network request completes, and must
 * never be made from the main thread.
 *
 * <p>This method requires the caller to hold the permission
 * {@link android.Manifest.permission#USE_CREDENTIALS}.
 *
 * @param account The account to fetch an auth token for
 * @param authTokenType The auth token type, see {#link getAuthToken}
 * @param notifyAuthFailure If true, display a notification and return null
 * if authentication fails; if false, prompt and wait for the user to
 * re-enter correct credentials before returning
 * @return An auth token of the specified type for this account, or null
 * if authentication fails or none can be fetched.
 * @throws AuthenticatorException if the authenticator failed to respond
 * @throws OperationCanceledException if the request was canceled for any
 * reason, including the user canceling a credential request
 * @throws java.io.IOException if the authenticator experienced an I/O problem
 * creating a new auth token, usually because of network trouble
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,2,3","1,2","The change consists of an addition of two exception statements, one return statement and a change in control flow due to the introduced condition handling. Thus, the code change types are 1 (return statement changed), 2 (exception handling statement changed) and 3 (control dependency change).","Both code change types 1 and 2 could lead to Compatibility Issue. The additional 'return null;' statement could lead to the API returning a different value (null), hence Potential Compatibility Issue type is 1. Also, the throwing of IllegalArgumentException under new conditions in the late version can also lead to a different behavior, so Compatibility Issue type 2 exists as well."
314,"<android.content.ContentProviderProxy: Cursor query(Uri,String[],String,String[],String)>",7,8,"<android.content.ContentProviderProxy: Cursor query(Uri,String[],String,String[],String)>","<android.content.ContentProviderProxy: Cursor query(Uri,String[],String,String[],String)>",0,"{
    // TODO make a pool of windows so we can reuse memory dealers
    CursorWindow window = new CursorWindow(false);
    BulkCursorToCursorAdaptor adaptor = new BulkCursorToCursorAdaptor();
    IBulkCursor bulkCursor = bulkQuery(url, projection, selection, selectionArgs, sortOrder, adaptor.getObserver(), window);
    if (bulkCursor == null) {
        return null;
    }
    adaptor.set(bulkCursor);
    return adaptor;
}","{
    // TODO make a pool of windows so we can reuse memory dealers
    CursorWindow window = new CursorWindow(false);
    BulkCursorToCursorAdaptor adaptor = new BulkCursorToCursorAdaptor();
    IBulkCursor bulkCursor = bulkQueryInternal(url, projection, selection, selectionArgs, sortOrder, adaptor.getObserver(), window, adaptor);
    if (bulkCursor == null) {
        return null;
    }
    return adaptor;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"4,5",1,"The method ""bulkQuery()"" has been changed to ""bulkQueryInternal()"" with an additional parameter ""adaptor"". This indicates that the dependent API has changed(5), and an other statement has been changed as well(4).","The method ""bulkQueryInternal()"" might have a different implementation than ""bulkQuery()"" and it might return a different output when called with the same input. Thus, there could be a potential Compatibility Issue caused by potential different return values (1)."
315,"<android.net.SSLCertificateSocketFactory: Socket createSocket(String,int,InetAddress,int)>",7,8,"<android.net.SSLCertificateSocketFactory: Socket createSocket(String,int,InetAddress,int)>","<android.net.SSLCertificateSocketFactory: Socket createSocket(String,int,InetAddress,int)>",0,"{
    SSLSocket sslSock = (SSLSocket) mFactory.createSocket(s, i, inaddr, j);
    if (mSocketReadTimeoutForSslHandshake >= 0) {
        sslSock.setSoTimeout(mSocketReadTimeoutForSslHandshake);
    }
    validateSocket(sslSock, s);
    sslSock.setSoTimeout(0);
    return sslSock;
}","{
    OpenSSLSocketImpl s = (OpenSSLSocketImpl) getDelegate().createSocket(host, port, localAddr, localPort);
    s.setHandshakeTimeout(mHandshakeTimeoutMillis);
    return s;
}",1,,,-1,,[@Override],-1,-1,-1,-1,-1,-1,"1,4",1,"The return statement has changed from 'return sslSock' to 'return s', and other non-control statements also changed (e.g., the initialization and properties setting of the socket object), so the code change type is 1,4.","The API potentially returns a different object in the two versions, and thus the CI type is 1."
316,<android.content.SyncContext: void onFinished(SyncResult)>,7,8,<android.content.SyncContext: void onFinished(SyncResult)>,<android.content.SyncContext: void onFinished(SyncResult)>,0,"{
    try {
        mSyncContext.onFinished(result);
    } catch (RemoteException e) {
    // this should never happen
    }
}","{
    try {
        if (mSyncContext != null) {
            mSyncContext.onFinished(result);
        }
    } catch (RemoteException e) {
    // this should never happen
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,3,0,"The code change is about adding if (mSyncContext != null) before calling mSyncContext.onFinished(result), leading to a change in the condition of control flow, so the code change type is 3.","This change doesn't lead to a CI. The added null check for mSyncContext is a safety improvement, if mSyncContext is null, both versions would raise a NullPointerException. Because they have the same behavior, no CI."
318,<android.net.SSLCertificateSocketFactory: String[] getSupportedCipherSuites()>,7,8,<android.net.SSLCertificateSocketFactory: String[] getSupportedCipherSuites()>,<android.net.SSLCertificateSocketFactory: String[] getSupportedCipherSuites()>,0,"{
    return mFactory.getSupportedCipherSuites();
}","{
    return getDelegate().getSupportedCipherSuites();
}",1,,,-1,,[@Override],-1,-1,-1,-1,-1,-1,"1,5",1,"Here, the return statement is changing with a different method call from `mFactory.getSupportedCipherSuites();` to `getDelegate().getSupportedCipherSuites();`. So, the change categories are 1,5, a change in the Return statement and a change in the Dependent API.","Since the method called in the return statement has changed, it might lead to a different return value. Therefore, a potential Compatibility Issue exists due to the possibility of different return values or types. Hence, CI type is 1."
319,"<android.database.sqlite.SQLiteProgram: void compile(String,boolean)>",7,8,"<android.database.sqlite.SQLiteProgram: void compile(String,boolean)>","<android.database.sqlite.SQLiteProgram: void compile(String,boolean)>",0,"{
    // explicitly requested a recompile.
    if (nStatement == 0 || forceCompilation) {
        mDatabase.lock();
        try {
            // Note that the native_compile() takes care of destroying any previously
            // existing programs before it compiles.
            acquireReference();
            native_compile(sql);
        } finally {
            releaseReference();
            mDatabase.unlock();
        }
    }
}","{
// TODO is there a need for this?
}",1,"/**
 * Compiles the given SQL into a SQLite byte code program using sqlite3_prepare_v2(). If
 * this method has been called previously without a call to close and forCompilation is set
 * to false the previous compilation will be used. Setting forceCompilation to true will
 * always re-compile the program and should be done if you pass differing SQL strings to this
 * method.
 *
 * <P>Note: this method acquires the database lock.</P>
 *
 * @param sql the SQL string to compile
 * @param forceCompilation forces the SQL to be recompiled in the event that there is an
 * existing compiled SQL program already around
 */
","/**
 * @deprecated This method is deprecated and must not be used.
 *
 * @param sql the SQL string to compile
 * @param forceCompilation forces the SQL to be recompiled in the event that there is an
 * existing compiled SQL program already around
 */
",-1,,[@Deprecated],-1,-1,-1,-1,-1,-1,4,"2, 1","The entire implementation of the method has been changed, so the change type is 4.","The new version doesn't have any exceptions, whereas the original version does due to the database lock operation, which could raise an exception. Also, the new version doesn't return anything, whereas the original version might have had a return from the native_compile() method. Therefore, the CI type is 2, 1."
320,<android.content.pm.PackageParser.Activity: String toString()>,7,8,<android.content.pm.PackageParser.Activity: String toString()>,<android.content.pm.PackageParser.Activity: String toString()>,0,"{
    return ""Activity{"" + Integer.toHexString(System.identityHashCode(this)) + "" "" + component.flattenToString() + ""}"";
}","{
    return ""Activity{"" + Integer.toHexString(System.identityHashCode(this)) + "" "" + getComponentShortName() + ""}"";
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"4,5",1,The method called in the return statement was changed from component.flattenToString() to getComponentShortName(). So the change types are 4 (Other statement change) and 5 (Dependent API changed).,"Because of the change in the method called in the return statement, the return value of this function may change. Therefore, the Compatibility Issue (CI) type is 1 (Compatibility Issue caused by potential different return values or types)."
322,"<android.os.FileObserver.ObserverThread: void onEvent(int,int,String)>",7,8,"<android.os.FileObserver.ObserverThread: void onEvent(int,int,String)>","<android.os.FileObserver.ObserverThread: void onEvent(int,int,String)>",0,"{
    // look up our observer, fixing up the map if necessary...
    FileObserver observer;
    synchronized (m_observers) {
        WeakReference weak = m_observers.get(wfd);
        observer = (FileObserver) weak.get();
        if (observer == null) {
            m_observers.remove(wfd);
        }
    }
    // ...then call out to the observer without the sync lock held
    if (observer != null) {
        try {
            observer.onEvent(mask, path);
        } catch (Throwable throwable) {
            Log.e(LOG_TAG, ""Unhandled throwable "" + throwable.toString() + "" (returned by observer "" + observer + "")"", throwable);
            RuntimeInit.crash(""FileObserver"", throwable);
        }
    }
}","{
    // look up our observer, fixing up the map if necessary...
    FileObserver observer = null;
    synchronized (m_observers) {
        WeakReference weak = m_observers.get(wfd);
        if (weak != null) {
            // can happen with lots of events from a dead wfd
            observer = (FileObserver) weak.get();
            if (observer == null) {
                m_observers.remove(wfd);
            }
        }
    }
    // ...then call out to the observer without the sync lock held
    if (observer != null) {
        try {
            observer.onEvent(mask, path);
        } catch (Throwable throwable) {
            Log.wtf(LOG_TAG, ""Unhandled exception in FileObserver "" + observer, throwable);
        }
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"2,3,4",2,"There are changes in control dependency where an extra null check is added (if (weak != null)). There is also a change in exception handling statement where 'RuntimeInit.crash(""FileObserver"", throwable);' is removed and the logging tag changes from Log.e() to Log.wtf(). In addition, the variable 'observer' is initialized at the beginning in the late version. Therefore, the code change type is 2,3,4.","Due to the change in the exception handling statement, the late version will not throw a crash when an exception is caught, while the early version will. This could lead to different exception handlings. Hence, the CI type is 2."
323,<android.pim.vcard.VCardUtils: String toHalfWidthString(String)>,7,8,<android.pim.vcard.VCardUtils: String toHalfWidthString(String)>,<android.pim.vcard.VCardUtils: String toHalfWidthString(String)>,0,"{
    if (TextUtils.isEmpty(orgString)) {
        return null;
    }
    StringBuilder builder = new StringBuilder();
    int length = orgString.length();
    for (int i = 0; i < length; i++) {
        // All Japanese character is able to be expressed by char.
        // Do not need to use String#codepPointAt().
        char ch = orgString.charAt(i);
        CharSequence halfWidthText = JapaneseUtils.tryGetHalfWidthText(ch);
        if (halfWidthText != null) {
            builder.append(halfWidthText);
        } else {
            builder.append(ch);
        }
    }
    return builder.toString();
}","{
    if (TextUtils.isEmpty(orgString)) {
        return null;
    }
    final StringBuilder builder = new StringBuilder();
    final int length = orgString.length();
    for (int i = 0; i < length; i = orgString.offsetByCodePoints(i, 1)) {
        // All Japanese character is able to be expressed by char.
        // Do not need to use String#codepPointAt().
        final char ch = orgString.charAt(i);
        final String halfWidthText = JapaneseUtils.tryGetHalfWidthText(ch);
        if (halfWidthText != null) {
            builder.append(halfWidthText);
        } else {
            builder.append(ch);
        }
    }
    return builder.toString();
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,4,0,"The code change includes the addition of 'final' keyword on some of the variables and the code 'i = orgString.offsetByCodePoints(i, 1)' in the for loop, so the code change type is 4.","The changes are addition of 'final' keywords and control statement in 'for' loop, they do not lead to potential different behaviours of API, therefore, there is no compatibility issue, thus the CI type is 0."
325,"<android.content.ContentResolver: int delete(Uri,String,String[])>",7,8,"<android.content.ContentResolver: int delete(Uri,String,String[])>","<android.content.ContentResolver: int delete(Uri,String,String[])>",0,"{
    IContentProvider provider = acquireProvider(url);
    if (provider == null) {
        throw new IllegalArgumentException(""Unknown URL "" + url);
    }
    try {
        return provider.delete(url, where, selectionArgs);
    } catch (RemoteException e) {
        return -1;
    } finally {
        releaseProvider(provider);
    }
}","{
    IContentProvider provider = acquireProvider(url);
    if (provider == null) {
        throw new IllegalArgumentException(""Unknown URL "" + url);
    }
    try {
        long startTime = SystemClock.uptimeMillis();
        int rowsDeleted = provider.delete(url, where, selectionArgs);
        long durationMillis = SystemClock.uptimeMillis() - startTime;
        maybeLogUpdateToEventLog(durationMillis, url, ""delete"", where);
        return rowsDeleted;
    } catch (RemoteException e) {
        return -1;
    } finally {
        releaseProvider(provider);
    }
}",1,"/**
 * Deletes row(s) specified by a content URI.
 *
 * If the content provider supports transactions, the deletion will be atomic.
 *
 * @param url The URL of the row to delete.
 * @param where A filter to apply to rows before deleting, formatted as an SQL WHERE clause
 * (excluding the WHERE itself).
 * @return The number of rows deleted.
 */
","/**
 * Deletes row(s) specified by a content URI.
 *
 * If the content provider supports transactions, the deletion will be atomic.
 *
 * @param url The URL of the row to delete.
 * @param where A filter to apply to rows before deleting, formatted as an SQL WHERE clause
 * (excluding the WHERE itself).
 * @return The number of rows deleted.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,4",0,"In the later version, some additional instructions and a new return statement (rowsDeleted) has been added in the try block which are tracked for some system value (uptimeMillis) and log related information. Those changes are caterogized as type 1 and 4.","No Compatibility Issue exists because, despite the additional lines and return statement, the essence of the method's action and its output remains the same. The value returned by method is the same (rowsDeleted). The additional lines in the newer version are just used for logging and technical value tracking purposes. They don't"
327,"<android.widget.VideoView: int resolveAdjustedSize(int,int)>",7,8,"<android.widget.VideoView: int resolveAdjustedSize(int,int)>","<android.widget.VideoView: int resolveAdjustedSize(int,int)>",0,"{
    int result = desiredSize;
    int specMode = MeasureSpec.getMode(measureSpec);
    int specSize = MeasureSpec.getSize(measureSpec);
    switch(specMode) {
        case MeasureSpec.UNSPECIFIED:
            /* Parent says we can be as big as we want. Just don't be larger
                 * than max size imposed on ourselves.
                 */
            result = desiredSize;
            break;
        case MeasureSpec.AT_MOST:
            /* Parent says we can be as big as we want, up to specSize. 
                 * Don't be larger than specSize, and don't be larger than 
                 * the max size imposed on ourselves.
                 */
            result = Math.min(desiredSize, specSize);
            break;
        case MeasureSpec.EXACTLY:
            // No choice. Do what we are told.
            result = specSize;
            break;
    }
    return result;
}","{
    int result = desiredSize;
    int specMode = MeasureSpec.getMode(measureSpec);
    int specSize = MeasureSpec.getSize(measureSpec);
    switch(specMode) {
        case MeasureSpec.UNSPECIFIED:
            /* Parent says we can be as big as we want. Just don't be larger
                 * than max size imposed on ourselves.
                 */
            result = desiredSize;
            break;
        case MeasureSpec.AT_MOST:
            /* Parent says we can be as big as we want, up to specSize.
                 * Don't be larger than specSize, and don't be larger than
                 * the max size imposed on ourselves.
                 */
            result = Math.min(desiredSize, specSize);
            break;
        case MeasureSpec.EXACTLY:
            // No choice. Do what we are told.
            result = specSize;
            break;
    }
    return result;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,0,0,There has been no code change between the early and late versions.,"Since there is no code change, no Compatibility Issue can arise."
328,"<android.util.Log: int w(String,Throwable)>",7,8,"<android.util.Log: int w(String,Throwable)>","<android.util.Log: int w(String,Throwable)>",0,"{
    return println(WARN, tag, getStackTraceString(tr));
}","{
    return println_native(LOG_ID_MAIN, WARN, tag, getStackTraceString(tr));
}",1,"/*
     * Send a {@link #WARN} log message and log the exception.
     * @param tag Used to identify the source of a log message.  It usually identifies
     *        the class or activity where the log call occurs.
     * @param tr An exception to log
     */
","/*
     * Send a {@link #WARN} log message and log the exception.
     * @param tag Used to identify the source of a log message.  It usually identifies
     *        the class or activity where the log call occurs.
     * @param tr An exception to log
     */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The function 'println' is replaced with 'println_native' which has different parameters. So the code change type is 1,5. ","The switch from calling 'println' to 'println_native' could result in different behaviours due to their difference in parameters, thus possibly returning a different value from this method. Hence, the CI type is 1."
329,<android.webkit.WebView: int computeVerticalScrollRange()>,7,8,<android.webkit.WebView: int computeVerticalScrollRange()>,<android.webkit.WebView: int computeVerticalScrollRange()>,0,"{
    if (mDrawHistory) {
        return mHistoryHeight;
    } else {
        // to avoid rounding error caused unnecessary scrollbar, use floor
        return (int) Math.floor(mContentHeight * mActualScale);
    }
}","{
    if (mDrawHistory) {
        return mHistoryHeight;
    } else if (mVerticalScrollBarMode == SCROLLBAR_ALWAYSOFF && (mActualScale - mMinZoomScale <= MINIMUM_SCALE_INCREMENT)) {
        // only honor the scrollbar mode when it is at minimum zoom level
        return computeVerticalScrollExtent();
    } else {
        // to avoid rounding error caused unnecessary scrollbar, use floor
        return (int) Math.floor(mContentHeight * mActualScale);
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,1",1,"A new control dependency statement (else if) has been introduced in the late version, which potentially affects the return statement 'return computeVerticalScrollExtent();', Classification of change: 3,1.","The introduction of new return statement 'return computeVerticalScrollExtent();' under new 'else if' condition will potentially make the API return different values. Therefore, the CI type is 1."
330,<android.app.SearchManager: void stopSearch()>,7,8,<android.app.SearchManager: void stopSearch()>,<android.app.SearchManager: void stopSearch()>,0,"{
    if (DBG)
        debug(""stopSearch()"");
    try {
        mService.stopSearch();
    } catch (RemoteException ex) {
    }
}","{
    if (mSearchDialog != null) {
        mSearchDialog.cancel();
    }
}",1,"/**
 * Terminate search UI.
 *
 * <p>Typically the user will terminate the search UI by launching a
 * search or by canceling.  This function allows the underlying application
 * or activity to cancel the search prematurely (for any reason).
 *
 * <p>This function can be safely called at any time (even if no search is active.)
 *
 * @see #startSearch
 */
","/**
 * Terminate search UI.
 *
 * <p>Typically the user will terminate the search UI by launching a
 * search or by canceling.  This function allows the underlying application
 * or activity to cancel the search prematurely (for any reason).
 *
 * <p>This function can be safely called at any time (even if no search is active.)
 *
 * @see #startSearch
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,4",1,"The early version stops a search via mService.stopSearch(), but the late version cancels a Search Dialog via mSearchDialog.cancel(), both operations are completely different. Therefore, the code change type is 1,4.","Given the new implementation can lead to a different behaviour scenario, it can bring about a different return (in the case of side effects) in the late version, hence, the CI type is 1."
331,"<android.webkit.WebView: boolean requestFocus(int,Rect)>",7,8,"<android.webkit.WebView: boolean requestFocus(int,Rect)>","<android.webkit.WebView: boolean requestFocus(int,Rect)>",0,"{
    boolean result = false;
    if (inEditingMode()) {
        result = mWebTextView.requestFocus(direction, previouslyFocusedRect);
    } else {
        result = super.requestFocus(direction, previouslyFocusedRect);
        if (mWebViewCore.getSettings().getNeedInitialFocus()) {
            // For cases such as GMail, where we gain focus from a direction,
            // we want to move to the first available link.
            // FIXME: If there are no visible links, we may not want to
            int fakeKeyDirection = 0;
            switch(direction) {
                case View.FOCUS_UP:
                    fakeKeyDirection = KeyEvent.KEYCODE_DPAD_UP;
                    break;
                case View.FOCUS_DOWN:
                    fakeKeyDirection = KeyEvent.KEYCODE_DPAD_DOWN;
                    break;
                case View.FOCUS_LEFT:
                    fakeKeyDirection = KeyEvent.KEYCODE_DPAD_LEFT;
                    break;
                case View.FOCUS_RIGHT:
                    fakeKeyDirection = KeyEvent.KEYCODE_DPAD_RIGHT;
                    break;
                default:
                    return result;
            }
            if (mNativeClass != 0 && !nativeHasCursorNode()) {
                navHandledKey(fakeKeyDirection, 1, true, 0, true);
            }
        }
    }
    return result;
}","{
    boolean result = false;
    if (inEditingMode()) {
        result = mWebTextView.requestFocus(direction, previouslyFocusedRect);
    } else {
        result = super.requestFocus(direction, previouslyFocusedRect);
        if (mWebViewCore.getSettings().getNeedInitialFocus()) {
            // For cases such as GMail, where we gain focus from a direction,
            // we want to move to the first available link.
            // FIXME: If there are no visible links, we may not want to
            int fakeKeyDirection = 0;
            switch(direction) {
                case View.FOCUS_UP:
                    fakeKeyDirection = KeyEvent.KEYCODE_DPAD_UP;
                    break;
                case View.FOCUS_DOWN:
                    fakeKeyDirection = KeyEvent.KEYCODE_DPAD_DOWN;
                    break;
                case View.FOCUS_LEFT:
                    fakeKeyDirection = KeyEvent.KEYCODE_DPAD_LEFT;
                    break;
                case View.FOCUS_RIGHT:
                    fakeKeyDirection = KeyEvent.KEYCODE_DPAD_RIGHT;
                    break;
                default:
                    return result;
            }
            if (mNativeClass != 0 && !nativeHasCursorNode()) {
                navHandledKey(fakeKeyDirection, 1, true, 0);
            }
        }
    }
    return result;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,1,"The statement 'navHandledKey(fakeKeyDirection, 1, true, 0, true)' from the early version has been changed in the later version to 'navHandledKey(fakeKeyDirection, 1, true, 0)'. So the code change type is 4.","The missing parameter in the 'navHandledKey' method call in the later version could potentially cause the 'requestFocus' API to behave differently since a different function might get invoked due to function overloading. Hence, the API may return different results and the CI type is 1."
332,<android.widget.AbsListView.RecycleBin: void addScrapView(View)>,7,8,<android.widget.AbsListView.RecycleBin: void addScrapView(View)>,<android.widget.AbsListView.RecycleBin: void addScrapView(View)>,0,"{
    AbsListView.LayoutParams lp = (AbsListView.LayoutParams) scrap.getLayoutParams();
    if (lp == null) {
        return;
    }
    // Don't put header or footer views or views that should be ignored
    // into the scrap heap
    int viewType = lp.viewType;
    if (!shouldRecycleViewType(viewType)) {
        return;
    }
    if (mViewTypeCount == 1) {
        mCurrentScrap.add(scrap);
    } else {
        mScrapViews[viewType].add(scrap);
    }
    if (mRecyclerListener != null) {
        mRecyclerListener.onMovedToScrapHeap(scrap);
    }
}","{
    AbsListView.LayoutParams lp = (AbsListView.LayoutParams) scrap.getLayoutParams();
    if (lp == null) {
        return;
    }
    // Don't put header or footer views or views that should be ignored
    // into the scrap heap
    int viewType = lp.viewType;
    if (!shouldRecycleViewType(viewType)) {
        if (viewType != ITEM_VIEW_TYPE_HEADER_OR_FOOTER) {
            removeDetachedView(scrap, false);
        }
        return;
    }
    if (mViewTypeCount == 1) {
        scrap.dispatchStartTemporaryDetach();
        mCurrentScrap.add(scrap);
    } else {
        scrap.dispatchStartTemporaryDetach();
        mScrapViews[viewType].add(scrap);
    }
    if (mRecyclerListener != null) {
        mRecyclerListener.onMovedToScrapHeap(scrap);
    }
}",1,"/**
 * Put a view into the ScapViews list. These views are unordered.
 *
 * @param scrap The view to add
 */
","/**
 * Put a view into the ScapViews list. These views are unordered.
 *
 * @param scrap The view to add
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3,4",1,"A new condition judgement 'if (viewType != ITEM_VIEW_TYPE_HEADER_OR_FOOTER)' and a new operation 'removeDetachedView(scrap, false)' inside the 'shouldRecycleViewType(viewType)' if block got added. A new operation 'scrap.dispatchStartTemporaryDetach();' is also added before 'mCurrentScrap.add(scrap);' and 'mScrapViews[viewType].add(scrap);'. These indicatate change types 1, 3 and 4.","Considering the newly added operation 'removeDetachedView(scrap, false)' under specific condition which didn't exist in early version and new operation 'scrap.dispatchStartTemporaryDetach();' before the scrap add operations, it may affect the behavior of the API leading to a potential different returned value. Therefore, the CI type is 1."
334,<android.webkit.WebView: void destroy()>,7,8,<android.webkit.WebView: void destroy()>,<android.webkit.WebView: void destroy()>,0,"{
    clearTextEntry();
    if (mWebViewCore != null) {
        // Set the handlers to null before destroying WebViewCore so no
        // more messages will be posted.
        mCallbackProxy.setWebViewClient(null);
        mCallbackProxy.setWebChromeClient(null);
        // Tell WebViewCore to destroy itself
        WebViewCore webViewCore = mWebViewCore;
        // prevent using partial webViewCore
        mWebViewCore = null;
        webViewCore.destroy();
        // Remove any pending messages that might not be serviced yet.
        mPrivateHandler.removeCallbacksAndMessages(null);
        mCallbackProxy.removeCallbacksAndMessages(null);
        // javascript dialog.
        synchronized (mCallbackProxy) {
            mCallbackProxy.notify();
        }
    }
    if (mNativeClass != 0) {
        nativeDestroy();
        mNativeClass = 0;
    }
}","{
    clearTextEntry(false);
    if (mWebViewCore != null) {
        // Set the handlers to null before destroying WebViewCore so no
        // more messages will be posted.
        mCallbackProxy.setWebViewClient(null);
        mCallbackProxy.setWebChromeClient(null);
        // Tell WebViewCore to destroy itself
        synchronized (this) {
            WebViewCore webViewCore = mWebViewCore;
            // prevent using partial webViewCore
            mWebViewCore = null;
            webViewCore.destroy();
        }
        // Remove any pending messages that might not be serviced yet.
        mPrivateHandler.removeCallbacksAndMessages(null);
        mCallbackProxy.removeCallbacksAndMessages(null);
        // javascript dialog.
        synchronized (mCallbackProxy) {
            mCallbackProxy.notify();
        }
    }
    if (mNativeClass != 0) {
        nativeDestroy();
        mNativeClass = 0;
    }
}",1,"/**
 * Destroy the internal state of the WebView. This method should be called
 * after the WebView has been removed from the view system. No other
 * methods may be called on a WebView after destroy.
 */
","/**
 * Destroy the internal state of the WebView. This method should be called
 * after the WebView has been removed from the view system. No other
 * methods may be called on a WebView after destroy.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",0,"The change occurs in the input of method clearTextEntry() where it was initially a method without input but now it takes an input and in addition, synchronization added into the middle of the implementation increases the system's concurrency handling. Therefore the types of changes are 3 because a change in control statements and 4 because non-return and non-exception statements were modified.","In this case, none of the changes can cause a different return value or an exception to be thrown, so there is no compatibility issue (0)."
336,<android.webkit.WebTextView: boolean onTouchEvent(MotionEvent)>,7,8,<android.webkit.WebTextView: boolean onTouchEvent(MotionEvent)>,<android.webkit.WebTextView: boolean onTouchEvent(MotionEvent)>,0,"{
    switch(event.getAction()) {
        case MotionEvent.ACTION_DOWN:
            super.onTouchEvent(event);
            // This event may be the start of a drag, so store it to pass to the
            // WebView if it is.
            mDragStartX = event.getX();
            mDragStartY = event.getY();
            mDragStartTime = event.getEventTime();
            mDragSent = false;
            mScrolled = false;
            mGotTouchDown = true;
            break;
        case MotionEvent.ACTION_MOVE:
            int slop = ViewConfiguration.get(mContext).getScaledTouchSlop();
            Spannable buffer = getText();
            int initialScrollX = Touch.getInitialScrollX(this, buffer);
            int initialScrollY = Touch.getInitialScrollY(this, buffer);
            super.onTouchEvent(event);
            int dx = Math.abs(mScrollX - initialScrollX);
            int dy = Math.abs(mScrollY - initialScrollY);
            // Use a smaller slop when checking to see if we've moved far enough
            // to scroll the text, because experimentally, slop has shown to be
            // to big for the case of a small textfield.
            int smallerSlop = slop / 2;
            if (dx > smallerSlop || dy > smallerSlop) {
                if (mWebView != null) {
                    float maxScrollX = (float) Touch.getMaxScrollX(this, getLayout(), mScrollY);
                    if (DebugFlags.WEB_TEXT_VIEW) {
                        Log.v(LOGTAG, ""onTouchEvent x="" + mScrollX + "" y="" + mScrollY + "" maxX="" + maxScrollX);
                    }
                    mWebView.scrollFocusedTextInput(maxScrollX > 0 ? mScrollX / maxScrollX : 0, mScrollY);
                }
                mScrolled = true;
                return true;
            }
            if (Math.abs((int) event.getX() - mDragStartX) < slop && Math.abs((int) event.getY() - mDragStartY) < slop) {
                // their finger, we will change the selection.
                return true;
            }
            if (mWebView != null) {
                // Only want to set the initial state once.
                if (!mDragSent) {
                    mWebView.initiateTextFieldDrag(mDragStartX, mDragStartY, mDragStartTime);
                    mDragSent = true;
                }
                boolean scrolled = mWebView.textFieldDrag(event);
                if (scrolled) {
                    mScrolled = true;
                    cancelLongPress();
                    return true;
                }
            }
            return false;
        case MotionEvent.ACTION_UP:
        case MotionEvent.ACTION_CANCEL:
            if (!mScrolled) {
                // If the page scrolled, or the TextView scrolled, we do not
                // want to change the selection
                cancelLongPress();
                if (mGotTouchDown && mWebView != null) {
                    mWebView.touchUpOnTextField(event);
                }
            }
            // Necessary for the WebView to reset its state
            if (mWebView != null && mDragSent) {
                mWebView.onTouchEvent(event);
            }
            mGotTouchDown = false;
            break;
        default:
            break;
    }
    return true;
}","{
    switch(event.getAction()) {
        case MotionEvent.ACTION_DOWN:
            super.onTouchEvent(event);
            // This event may be the start of a drag, so store it to pass to the
            // WebView if it is.
            mDragStartX = event.getX();
            mDragStartY = event.getY();
            mDragStartTime = event.getEventTime();
            mDragSent = false;
            mScrolled = false;
            mGotTouchDown = true;
            mHasPerformedLongClick = false;
            break;
        case MotionEvent.ACTION_MOVE:
            if (mHasPerformedLongClick) {
                mGotTouchDown = false;
                return false;
            }
            int slop = ViewConfiguration.get(mContext).getScaledTouchSlop();
            Spannable buffer = getText();
            int initialScrollX = Touch.getInitialScrollX(this, buffer);
            int initialScrollY = Touch.getInitialScrollY(this, buffer);
            super.onTouchEvent(event);
            int dx = Math.abs(mScrollX - initialScrollX);
            int dy = Math.abs(mScrollY - initialScrollY);
            // Use a smaller slop when checking to see if we've moved far enough
            // to scroll the text, because experimentally, slop has shown to be
            // to big for the case of a small textfield.
            int smallerSlop = slop / 2;
            if (dx > smallerSlop || dy > smallerSlop) {
                if (mWebView != null) {
                    float maxScrollX = (float) Touch.getMaxScrollX(this, getLayout(), mScrollY);
                    if (DebugFlags.WEB_TEXT_VIEW) {
                        Log.v(LOGTAG, ""onTouchEvent x="" + mScrollX + "" y="" + mScrollY + "" maxX="" + maxScrollX);
                    }
                    mWebView.scrollFocusedTextInput(maxScrollX > 0 ? mScrollX / maxScrollX : 0, mScrollY);
                }
                mScrolled = true;
                cancelLongPress();
                return true;
            }
            if (Math.abs((int) event.getX() - mDragStartX) < slop && Math.abs((int) event.getY() - mDragStartY) < slop) {
                // their finger, we will change the selection.
                return true;
            }
            if (mWebView != null) {
                // Only want to set the initial state once.
                if (!mDragSent) {
                    mWebView.initiateTextFieldDrag(mDragStartX, mDragStartY, mDragStartTime);
                    mDragSent = true;
                }
                boolean scrolled = mWebView.textFieldDrag(event);
                if (scrolled) {
                    mScrolled = true;
                    cancelLongPress();
                    return true;
                }
            }
            return false;
        case MotionEvent.ACTION_UP:
        case MotionEvent.ACTION_CANCEL:
            if (mHasPerformedLongClick) {
                mGotTouchDown = false;
                return false;
            }
            if (!mScrolled) {
                // If the page scrolled, or the TextView scrolled, we do not
                // want to change the selection
                cancelLongPress();
                if (mGotTouchDown && mWebView != null) {
                    mWebView.touchUpOnTextField(event);
                }
            }
            // Necessary for the WebView to reset its state
            if (mWebView != null && mDragSent) {
                mWebView.onTouchEvent(event);
            }
            mGotTouchDown = false;
            break;
        default:
            break;
    }
    return true;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,3",1,"There are two main changes in the code. Firstly, an additional variable (mHasPerformedLongClick) has been introduced in the MotionEvent.ACTION_DOWN and MotionEvent.ACTION_MOVE cases, which is returned in several cases when this variable is true. Secondly, a new condition checking mHasPerformedLongClick is added in two cases of the switch event.getAction(), which potentially changes the control flow of the code when the condition is met. Therefore, the code change type is 1 (Return statement changed) and 3 (Control dependency change).","The return statements conditionally return either true or false depending on the newly added variable (mHasPerformedLongClick). This can potentially lead to this API returning different values in the two versions when the condition is met. So, the compatibility issue type is 1 (Compatibility Issue caused by potential different return values or types)."
337,<android.view.GestureDetector: boolean onTouchEvent(MotionEvent)>,7,8,<android.view.GestureDetector: boolean onTouchEvent(MotionEvent)>,<android.view.GestureDetector: boolean onTouchEvent(MotionEvent)>,0,"{
    final int action = ev.getAction();
    final float y = ev.getY();
    final float x = ev.getX();
    if (mVelocityTracker == null) {
        mVelocityTracker = VelocityTracker.obtain();
    }
    mVelocityTracker.addMovement(ev);
    boolean handled = false;
    switch(action) {
        case MotionEvent.ACTION_DOWN:
            if (mDoubleTapListener != null) {
                boolean hadTapMessage = mHandler.hasMessages(TAP);
                if (hadTapMessage)
                    mHandler.removeMessages(TAP);
                if ((mCurrentDownEvent != null) && (mPreviousUpEvent != null) && hadTapMessage && isConsideredDoubleTap(mCurrentDownEvent, mPreviousUpEvent, ev)) {
                    // This is a second tap
                    mIsDoubleTapping = true;
                    // Give a callback with the first tap of the double-tap
                    handled |= mDoubleTapListener.onDoubleTap(mCurrentDownEvent);
                    // Give a callback with down event of the double-tap
                    handled |= mDoubleTapListener.onDoubleTapEvent(ev);
                } else {
                    // This is a first tap
                    mHandler.sendEmptyMessageDelayed(TAP, DOUBLE_TAP_TIMEOUT);
                }
            }
            mLastMotionX = x;
            mLastMotionY = y;
            mCurrentDownEvent = MotionEvent.obtain(ev);
            mAlwaysInTapRegion = true;
            mAlwaysInBiggerTapRegion = true;
            mStillDown = true;
            mInLongPress = false;
            if (mIsLongpressEnabled) {
                mHandler.removeMessages(LONG_PRESS);
                mHandler.sendEmptyMessageAtTime(LONG_PRESS, mCurrentDownEvent.getDownTime() + TAP_TIMEOUT + LONGPRESS_TIMEOUT);
            }
            mHandler.sendEmptyMessageAtTime(SHOW_PRESS, mCurrentDownEvent.getDownTime() + TAP_TIMEOUT);
            handled |= mListener.onDown(ev);
            break;
        case MotionEvent.ACTION_MOVE:
            if (mInLongPress) {
                break;
            }
            final float scrollX = mLastMotionX - x;
            final float scrollY = mLastMotionY - y;
            if (mIsDoubleTapping) {
                // Give the move events of the double-tap
                handled |= mDoubleTapListener.onDoubleTapEvent(ev);
            } else if (mAlwaysInTapRegion) {
                final int deltaX = (int) (x - mCurrentDownEvent.getX());
                final int deltaY = (int) (y - mCurrentDownEvent.getY());
                int distance = (deltaX * deltaX) + (deltaY * deltaY);
                if (distance > mTouchSlopSquare) {
                    handled = mListener.onScroll(mCurrentDownEvent, ev, scrollX, scrollY);
                    mLastMotionX = x;
                    mLastMotionY = y;
                    mAlwaysInTapRegion = false;
                    mHandler.removeMessages(TAP);
                    mHandler.removeMessages(SHOW_PRESS);
                    mHandler.removeMessages(LONG_PRESS);
                }
                if (distance > mBiggerTouchSlopSquare) {
                    mAlwaysInBiggerTapRegion = false;
                }
            } else if ((Math.abs(scrollX) >= 1) || (Math.abs(scrollY) >= 1)) {
                handled = mListener.onScroll(mCurrentDownEvent, ev, scrollX, scrollY);
                mLastMotionX = x;
                mLastMotionY = y;
            }
            break;
        case MotionEvent.ACTION_UP:
            mStillDown = false;
            MotionEvent currentUpEvent = MotionEvent.obtain(ev);
            if (mIsDoubleTapping) {
                // Finally, give the up event of the double-tap
                handled |= mDoubleTapListener.onDoubleTapEvent(ev);
            } else if (mInLongPress) {
                mHandler.removeMessages(TAP);
                mInLongPress = false;
            } else if (mAlwaysInTapRegion) {
                handled = mListener.onSingleTapUp(ev);
            } else {
                // A fling must travel the minimum tap distance
                final VelocityTracker velocityTracker = mVelocityTracker;
                velocityTracker.computeCurrentVelocity(1000, mMaximumFlingVelocity);
                final float velocityY = velocityTracker.getYVelocity();
                final float velocityX = velocityTracker.getXVelocity();
                if ((Math.abs(velocityY) > mMinimumFlingVelocity) || (Math.abs(velocityX) > mMinimumFlingVelocity)) {
                    handled = mListener.onFling(mCurrentDownEvent, currentUpEvent, velocityX, velocityY);
                }
            }
            mPreviousUpEvent = MotionEvent.obtain(ev);
            mVelocityTracker.recycle();
            mVelocityTracker = null;
            mIsDoubleTapping = false;
            mHandler.removeMessages(SHOW_PRESS);
            mHandler.removeMessages(LONG_PRESS);
            break;
        case MotionEvent.ACTION_CANCEL:
            mHandler.removeMessages(SHOW_PRESS);
            mHandler.removeMessages(LONG_PRESS);
            mHandler.removeMessages(TAP);
            mVelocityTracker.recycle();
            mVelocityTracker = null;
            mIsDoubleTapping = false;
            mStillDown = false;
            if (mInLongPress) {
                mInLongPress = false;
                break;
            }
    }
    return handled;
}","{
    final int action = ev.getAction();
    final float y = ev.getY();
    final float x = ev.getX();
    if (mVelocityTracker == null) {
        mVelocityTracker = VelocityTracker.obtain();
    }
    mVelocityTracker.addMovement(ev);
    boolean handled = false;
    switch(action & MotionEvent.ACTION_MASK) {
        case MotionEvent.ACTION_POINTER_DOWN:
            if (mIgnoreMultitouch) {
                // Multitouch event - abort.
                cancel();
            }
            break;
        case MotionEvent.ACTION_POINTER_UP:
            // Ending a multitouch gesture and going back to 1 finger
            if (mIgnoreMultitouch && ev.getPointerCount() == 2) {
                int index = (((action & MotionEvent.ACTION_POINTER_INDEX_MASK) >> MotionEvent.ACTION_POINTER_INDEX_SHIFT) == 0) ? 1 : 0;
                mLastMotionX = ev.getX(index);
                mLastMotionY = ev.getY(index);
                mVelocityTracker.recycle();
                mVelocityTracker = VelocityTracker.obtain();
            }
            break;
        case MotionEvent.ACTION_DOWN:
            if (mDoubleTapListener != null) {
                boolean hadTapMessage = mHandler.hasMessages(TAP);
                if (hadTapMessage)
                    mHandler.removeMessages(TAP);
                if ((mCurrentDownEvent != null) && (mPreviousUpEvent != null) && hadTapMessage && isConsideredDoubleTap(mCurrentDownEvent, mPreviousUpEvent, ev)) {
                    // This is a second tap
                    mIsDoubleTapping = true;
                    // Give a callback with the first tap of the double-tap
                    handled |= mDoubleTapListener.onDoubleTap(mCurrentDownEvent);
                    // Give a callback with down event of the double-tap
                    handled |= mDoubleTapListener.onDoubleTapEvent(ev);
                } else {
                    // This is a first tap
                    mHandler.sendEmptyMessageDelayed(TAP, DOUBLE_TAP_TIMEOUT);
                }
            }
            mLastMotionX = x;
            mLastMotionY = y;
            if (mCurrentDownEvent != null) {
                mCurrentDownEvent.recycle();
            }
            mCurrentDownEvent = MotionEvent.obtain(ev);
            mAlwaysInTapRegion = true;
            mAlwaysInBiggerTapRegion = true;
            mStillDown = true;
            mInLongPress = false;
            if (mIsLongpressEnabled) {
                mHandler.removeMessages(LONG_PRESS);
                mHandler.sendEmptyMessageAtTime(LONG_PRESS, mCurrentDownEvent.getDownTime() + TAP_TIMEOUT + LONGPRESS_TIMEOUT);
            }
            mHandler.sendEmptyMessageAtTime(SHOW_PRESS, mCurrentDownEvent.getDownTime() + TAP_TIMEOUT);
            handled |= mListener.onDown(ev);
            break;
        case MotionEvent.ACTION_MOVE:
            if (mInLongPress || (mIgnoreMultitouch && ev.getPointerCount() > 1)) {
                break;
            }
            final float scrollX = mLastMotionX - x;
            final float scrollY = mLastMotionY - y;
            if (mIsDoubleTapping) {
                // Give the move events of the double-tap
                handled |= mDoubleTapListener.onDoubleTapEvent(ev);
            } else if (mAlwaysInTapRegion) {
                final int deltaX = (int) (x - mCurrentDownEvent.getX());
                final int deltaY = (int) (y - mCurrentDownEvent.getY());
                int distance = (deltaX * deltaX) + (deltaY * deltaY);
                if (distance > mTouchSlopSquare) {
                    handled = mListener.onScroll(mCurrentDownEvent, ev, scrollX, scrollY);
                    mLastMotionX = x;
                    mLastMotionY = y;
                    mAlwaysInTapRegion = false;
                    mHandler.removeMessages(TAP);
                    mHandler.removeMessages(SHOW_PRESS);
                    mHandler.removeMessages(LONG_PRESS);
                }
                if (distance > mBiggerTouchSlopSquare) {
                    mAlwaysInBiggerTapRegion = false;
                }
            } else if ((Math.abs(scrollX) >= 1) || (Math.abs(scrollY) >= 1)) {
                handled = mListener.onScroll(mCurrentDownEvent, ev, scrollX, scrollY);
                mLastMotionX = x;
                mLastMotionY = y;
            }
            break;
        case MotionEvent.ACTION_UP:
            mStillDown = false;
            MotionEvent currentUpEvent = MotionEvent.obtain(ev);
            if (mIsDoubleTapping) {
                // Finally, give the up event of the double-tap
                handled |= mDoubleTapListener.onDoubleTapEvent(ev);
            } else if (mInLongPress) {
                mHandler.removeMessages(TAP);
                mInLongPress = false;
            } else if (mAlwaysInTapRegion) {
                handled = mListener.onSingleTapUp(ev);
            } else {
                // A fling must travel the minimum tap distance
                final VelocityTracker velocityTracker = mVelocityTracker;
                velocityTracker.computeCurrentVelocity(1000, mMaximumFlingVelocity);
                final float velocityY = velocityTracker.getYVelocity();
                final float velocityX = velocityTracker.getXVelocity();
                if ((Math.abs(velocityY) > mMinimumFlingVelocity) || (Math.abs(velocityX) > mMinimumFlingVelocity)) {
                    handled = mListener.onFling(mCurrentDownEvent, ev, velocityX, velocityY);
                }
            }
            if (mPreviousUpEvent != null) {
                mPreviousUpEvent.recycle();
            }
            // Hold the event we obtained above - listeners may have changed the original.
            mPreviousUpEvent = currentUpEvent;
            mVelocityTracker.recycle();
            mVelocityTracker = null;
            mIsDoubleTapping = false;
            mHandler.removeMessages(SHOW_PRESS);
            mHandler.removeMessages(LONG_PRESS);
            break;
        case MotionEvent.ACTION_CANCEL:
            cancel();
    }
    return handled;
}",1,"/**
 * Analyzes the given motion event and if applicable triggers the
 * appropriate callbacks on the {@link OnGestureListener} supplied.
 *
 * @param ev The current motion event.
 * @return true if the {@link OnGestureListener} consumed the event,
 * else false.
 */
","/**
 * Analyzes the given motion event and if applicable triggers the
 * appropriate callbacks on the {@link OnGestureListener} supplied.
 *
 * @param ev The current motion event.
 * @return true if the {@link OnGestureListener} consumed the event,
 * else false.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4","1,2","Between the two versions, the condition for 'switch' statements and 'if' statements have changed, so the change type is 3. There are also introduction of new method 'cancel()' and more conditions in handling MotionEvent, modifying the behavior of the function, so we also categorize it as 4.","The change in 'switch' and 'if' condition, and the introduction of new 'cancel()' method could potentially change the API behavior to returning different values and throwing different exceptions. Hence, the CI types are 1,2."
338,<android.content.res.Configuration: int compareTo(Configuration)>,7,8,<android.content.res.Configuration: int compareTo(Configuration)>,<android.content.res.Configuration: int compareTo(Configuration)>,0,"{
    int n;
    float a = this.fontScale;
    float b = that.fontScale;
    if (a < b)
        return -1;
    if (a > b)
        return 1;
    n = this.mcc - that.mcc;
    if (n != 0)
        return n;
    n = this.mnc - that.mnc;
    if (n != 0)
        return n;
    n = this.locale.getLanguage().compareTo(that.locale.getLanguage());
    if (n != 0)
        return n;
    n = this.locale.getCountry().compareTo(that.locale.getCountry());
    if (n != 0)
        return n;
    n = this.locale.getVariant().compareTo(that.locale.getVariant());
    if (n != 0)
        return n;
    n = this.touchscreen - that.touchscreen;
    if (n != 0)
        return n;
    n = this.keyboard - that.keyboard;
    if (n != 0)
        return n;
    n = this.keyboardHidden - that.keyboardHidden;
    if (n != 0)
        return n;
    n = this.hardKeyboardHidden - that.hardKeyboardHidden;
    if (n != 0)
        return n;
    n = this.navigation - that.navigation;
    if (n != 0)
        return n;
    n = this.navigationHidden - that.navigationHidden;
    if (n != 0)
        return n;
    n = this.orientation - that.orientation;
    if (n != 0)
        return n;
    n = this.screenLayout - that.screenLayout;
    // if (n != 0) return n;
    return n;
}","{
    int n;
    float a = this.fontScale;
    float b = that.fontScale;
    if (a < b)
        return -1;
    if (a > b)
        return 1;
    n = this.mcc - that.mcc;
    if (n != 0)
        return n;
    n = this.mnc - that.mnc;
    if (n != 0)
        return n;
    if (this.locale == null) {
        if (that.locale != null)
            return 1;
    } else if (that.locale == null) {
        return -1;
    } else {
        n = this.locale.getLanguage().compareTo(that.locale.getLanguage());
        if (n != 0)
            return n;
        n = this.locale.getCountry().compareTo(that.locale.getCountry());
        if (n != 0)
            return n;
        n = this.locale.getVariant().compareTo(that.locale.getVariant());
        if (n != 0)
            return n;
    }
    n = this.touchscreen - that.touchscreen;
    if (n != 0)
        return n;
    n = this.keyboard - that.keyboard;
    if (n != 0)
        return n;
    n = this.keyboardHidden - that.keyboardHidden;
    if (n != 0)
        return n;
    n = this.hardKeyboardHidden - that.hardKeyboardHidden;
    if (n != 0)
        return n;
    n = this.navigation - that.navigation;
    if (n != 0)
        return n;
    n = this.navigationHidden - that.navigationHidden;
    if (n != 0)
        return n;
    n = this.orientation - that.orientation;
    if (n != 0)
        return n;
    n = this.screenLayout - that.screenLayout;
    if (n != 0)
        return n;
    n = this.uiMode - that.uiMode;
    // if (n != 0) return n;
    return n;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"1,3",1,"The late version implementation introduces a new control dependency check compared to the early version (with the introduction of the locale null check via if-else condition). Also, a new return statement is introduced: 'n = this.uiMode - that.uiMode', hence the change is of type 1,3.","There is a compatibility issue introduced in the late version implementation as it potentially returns a different value due to the introduction of the locale null check and because of the new return statement 'n = this.uiMode - that.uiMode'. Hence, the Compatibility Issue situation is 1."
340,<android.net.SSLCertificateSocketFactory: SocketFactory getDefault(int)>,7,8,<android.net.SSLCertificateSocketFactory: SocketFactory getDefault(int)>,<android.net.SSLCertificateSocketFactory: SocketFactory getDefault(int)>,0,"{
    return getDefault(socketReadTimeoutForSslHandshake, null);
}","{
    return new SSLCertificateSocketFactory(handshakeTimeoutMillis, null, true);
}",1,"/**
 * Returns a new instance of a socket factory using the specified socket read
 * timeout while connecting with the server/negotiating an ssl session.
 *
 * @param socketReadTimeoutForSslHandshake the socket read timeout used for performing
 * ssl handshake. The socket read timeout is set back to 0 after the handshake.
 * @return a new SocketFactory, or null on error
 */
","/**
 * Returns a new socket factory instance with an optional handshake timeout.
 *
 * @param handshakeTimeoutMillis to use for SSL connection handshake, or 0
 * for none.  The socket timeout is reset to 0 after the handshake.
 * @return a new SocketFactory with the specified parameters
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The return statement has changed from getDefault(socketReadTimeoutForSslHandshake, null) to new SSLCertificateSocketFactory(handshakeTimeoutMillis, null, true), and it also changes the type of the dependent API, so the code change type is 1,5.","The return statement has changed which will cause this method to return a different type of value. Therefore, the CI type is 1."
342,"<android.content.ContentProviderProxy: IBulkCursor bulkQuery(Uri,String[],String,String[],String,IContentObserver,CursorWindow)>",7,8,"<android.content.ContentProviderProxy: IBulkCursor bulkQuery(Uri,String[],String,String[],String,IContentObserver,CursorWindow)>","<android.content.ContentProviderProxy: IBulkCursor bulkQuery(Uri,String[],String,String[],String,IContentObserver,CursorWindow)>",0,"{
    Parcel data = Parcel.obtain();
    Parcel reply = Parcel.obtain();
    data.writeInterfaceToken(IContentProvider.descriptor);
    url.writeToParcel(data, 0);
    int length = 0;
    if (projection != null) {
        length = projection.length;
    }
    data.writeInt(length);
    for (int i = 0; i < length; i++) {
        data.writeString(projection[i]);
    }
    data.writeString(selection);
    if (selectionArgs != null) {
        length = selectionArgs.length;
    } else {
        length = 0;
    }
    data.writeInt(length);
    for (int i = 0; i < length; i++) {
        data.writeString(selectionArgs[i]);
    }
    data.writeString(sortOrder);
    data.writeStrongBinder(observer.asBinder());
    window.writeToParcel(data, 0);
    mRemote.transact(IContentProvider.QUERY_TRANSACTION, data, reply, 0);
    DatabaseUtils.readExceptionFromParcel(reply);
    IBulkCursor bulkCursor = null;
    IBinder bulkCursorBinder = reply.readStrongBinder();
    if (bulkCursorBinder != null) {
        bulkCursor = BulkCursorNative.asInterface(bulkCursorBinder);
    }
    data.recycle();
    reply.recycle();
    return bulkCursor;
}","{
    return bulkQueryInternal(url, projection, selection, selectionArgs, sortOrder, observer, window, null);
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"1,4",1,"The whole implementation of the API has been replaced by the invocation of another method `bulkQueryInternal()`, so the change category is 1 (Return statement changed) and 4 (Other statement changed).","The returned result of the late version API will be completely dependent on the method `bulkQueryInternal()`, which is different from the previous version where the result is computed within the method. Therefore, it potentially returns a different variable, leading to a Compatibility Issue in category 1 (Compatibility Issue caused by potential different return values or types)."
343,<android.widget.ScrollView: boolean executeKeyEvent(KeyEvent)>,7,8,<android.widget.ScrollView: boolean executeKeyEvent(KeyEvent)>,<android.widget.ScrollView: boolean executeKeyEvent(KeyEvent)>,0,"{
    mTempRect.setEmpty();
    if (!canScroll()) {
        if (isFocused()) {
            View currentFocused = findFocus();
            if (currentFocused == this)
                currentFocused = null;
            View nextFocused = FocusFinder.getInstance().findNextFocus(this, currentFocused, View.FOCUS_DOWN);
            return nextFocused != null && nextFocused != this && nextFocused.requestFocus(View.FOCUS_DOWN);
        }
        return false;
    }
    boolean handled = false;
    if (event.getAction() == KeyEvent.ACTION_DOWN) {
        switch(event.getKeyCode()) {
            case KeyEvent.KEYCODE_DPAD_UP:
                if (!event.isAltPressed()) {
                    handled = arrowScroll(View.FOCUS_UP);
                } else {
                    handled = fullScroll(View.FOCUS_UP);
                }
                break;
            case KeyEvent.KEYCODE_DPAD_DOWN:
                if (!event.isAltPressed()) {
                    handled = arrowScroll(View.FOCUS_DOWN);
                } else {
                    handled = fullScroll(View.FOCUS_DOWN);
                }
                break;
            case KeyEvent.KEYCODE_SPACE:
                pageScroll(event.isShiftPressed() ? View.FOCUS_UP : View.FOCUS_DOWN);
                break;
        }
    }
    return handled;
}","{
    mTempRect.setEmpty();
    if (!canScroll()) {
        if (isFocused() && event.getKeyCode() != KeyEvent.KEYCODE_BACK) {
            View currentFocused = findFocus();
            if (currentFocused == this)
                currentFocused = null;
            View nextFocused = FocusFinder.getInstance().findNextFocus(this, currentFocused, View.FOCUS_DOWN);
            return nextFocused != null && nextFocused != this && nextFocused.requestFocus(View.FOCUS_DOWN);
        }
        return false;
    }
    boolean handled = false;
    if (event.getAction() == KeyEvent.ACTION_DOWN) {
        switch(event.getKeyCode()) {
            case KeyEvent.KEYCODE_DPAD_UP:
                if (!event.isAltPressed()) {
                    handled = arrowScroll(View.FOCUS_UP);
                } else {
                    handled = fullScroll(View.FOCUS_UP);
                }
                break;
            case KeyEvent.KEYCODE_DPAD_DOWN:
                if (!event.isAltPressed()) {
                    handled = arrowScroll(View.FOCUS_DOWN);
                } else {
                    handled = fullScroll(View.FOCUS_DOWN);
                }
                break;
            case KeyEvent.KEYCODE_SPACE:
                pageScroll(event.isShiftPressed() ? View.FOCUS_UP : View.FOCUS_DOWN);
                break;
        }
    }
    return handled;
}",1,"/**
 * You can call this function yourself to have the scroll view perform
 * scrolling from a key event, just as if the event had been dispatched to
 * it by the view hierarchy.
 *
 * @param event The key event to execute.
 * @return Return true if the event was handled, else false.
 */
","/**
 * You can call this function yourself to have the scroll view perform
 * scrolling from a key event, just as if the event had been dispatched to
 * it by the view hierarchy.
 *
 * @param event The key event to execute.
 * @return Return true if the event was handled, else false.
 */
",-1,,,-1,-1,-1,-1,-1,-1,3,1,The condition expression 'isFocused() && event.getKeyCode() != KeyEvent.KEYCODE_BACK' has been changed in if statement. ,"Considering the change in control structure, such as `isFocused() && event.getKeyCode() != KeyEvent.KEYCODE_BACK`, there is a potential different return value from `return nextFocused != null && nextFocused != this && nextFocused.requestFocus(View.FOCUS_DOWN);` and `return false;`. So the CI type is 1."
344,<android.os.ParcelFileDescriptor: ParcelFileDescriptor fromSocket(Socket)>,7,8,<android.os.ParcelFileDescriptor: ParcelFileDescriptor fromSocket(Socket)>,<android.os.ParcelFileDescriptor: ParcelFileDescriptor fromSocket(Socket)>,0,"{
    FileDescriptor fd = getFileDescriptorFromSocket(socket);
    return new ParcelFileDescriptor(fd);
}","{
    FileDescriptor fd = getFileDescriptorFromSocket(socket);
    return fd != null ? new ParcelFileDescriptor(fd) : null;
}",1,"/**
 * Create a new ParcelFileDescriptor from the specified Socket.
 *
 * @param socket The Socket whose FileDescriptor is used to create
 * a new ParcelFileDescriptor.
 *
 * @return A new ParcelFileDescriptor with the FileDescriptor of the
 * specified Socket.
 */
","/**
 * Create a new ParcelFileDescriptor from the specified Socket.
 *
 * @param socket The Socket whose FileDescriptor is used to create
 * a new ParcelFileDescriptor.
 *
 * @return A new ParcelFileDescriptor with the FileDescriptor of the
 * specified Socket.
 */
",-1,,,-1,-1,-1,-1,-1,-1,1,1,"The return statement in the late version includes a condition that checks if 'fd' is not null which is a change in the logic of the implementation, so the code change type is 1.","The added null checking condition potentially causes the API to return a different value (either a `ParcelFileDescriptor` object or `null`), making the type of CI to be 1."
345,<android.webkit.DateSorter: String getLabel(int)>,7,8,<android.webkit.DateSorter: String getLabel(int)>,<android.webkit.DateSorter: String getLabel(int)>,0,"{
    return mLabels[index];
}","{
    if (index < 0 || index >= DAY_COUNT)
        return """";
    return mLabels[index];
}",1,"/**
 * @param index date bin index as returned by getIndex()
 * @return string label suitable for display to user
 */
","/**
 * @param index date bin index as returned by getIndex()
 * @return string label suitable for display to user
 */
",-1,,,-1,-1,-1,-1,-1,-1,3,1,"In the late version, an if-condition statement has been added at the beginning of the method. Hence, the change type is 3 (Control dependency change).","The new if-condition statement potentially alters the methods return value: if the condition is met, an empty string will be returned; otherwise, the original return statement is executed. Therefore, the CI type is 1 (Compatibility Issue caused by potential different return values)."
346,<android.webkit.WebViewDatabase: boolean endCacheTransaction()>,7,8,<android.webkit.WebViewDatabase: boolean endCacheTransaction()>,<android.webkit.WebViewDatabase: boolean endCacheTransaction()>,0,"{
    if (--mCacheTransactionRefcount == 0) {
        try {
            mCacheDatabase.setTransactionSuccessful();
        } finally {
            mCacheDatabase.endTransaction();
        }
        return true;
    }
    return false;
}","{
    if (--mCacheTransactionRefcount == 0) {
        if (!Thread.currentThread().equals(WebViewWorker.getHandler().getLooper().getThread())) {
            Log.w(LOGTAG, ""endCacheTransaction should be called from "" + ""WebViewWorkerThread instead of from "" + Thread.currentThread().getName());
        }
        try {
            mCacheDatabase.setTransactionSuccessful();
        } finally {
            mCacheDatabase.endTransaction();
        }
        return true;
    }
    return false;
}",1,,"// only called from WebViewWorkerThread
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",0,"A new condition handling statement is introduced to handle the case when current thread is not the WebViewWorker thread, so the code change type is 3. In addition, a new logging statement is added under this condition handling, so the change type is also 4.","The changes such as addition of condition handling and logging statement do not affect the return value or exception handling of the method. Therefore, there is no Compatibility Issue (CI). The CI type is 0."
347,"<android.app.ActivityThread.ApplicationThread: void dump(FileDescriptor,PrintWriter,String[])>",7,8,"<android.app.ActivityThread.ApplicationThread: void dump(FileDescriptor,PrintWriter,String[])>","<android.app.ActivityThread.ApplicationThread: void dump(FileDescriptor,PrintWriter,String[])>",0,"{
    long nativeMax = Debug.getNativeHeapSize() / 1024;
    long nativeAllocated = Debug.getNativeHeapAllocatedSize() / 1024;
    long nativeFree = Debug.getNativeHeapFreeSize() / 1024;
    Debug.MemoryInfo memInfo = new Debug.MemoryInfo();
    Debug.getMemoryInfo(memInfo);
    final int nativeShared = memInfo.nativeSharedDirty;
    final int dalvikShared = memInfo.dalvikSharedDirty;
    final int otherShared = memInfo.otherSharedDirty;
    final int nativePrivate = memInfo.nativePrivateDirty;
    final int dalvikPrivate = memInfo.dalvikPrivateDirty;
    final int otherPrivate = memInfo.otherPrivateDirty;
    Runtime runtime = Runtime.getRuntime();
    long dalvikMax = runtime.totalMemory() / 1024;
    long dalvikFree = runtime.freeMemory() / 1024;
    long dalvikAllocated = dalvikMax - dalvikFree;
    long viewInstanceCount = ViewDebug.getViewInstanceCount();
    long viewRootInstanceCount = ViewDebug.getViewRootInstanceCount();
    long appContextInstanceCount = ApplicationContext.getInstanceCount();
    long activityInstanceCount = Activity.getInstanceCount();
    int globalAssetCount = AssetManager.getGlobalAssetCount();
    int globalAssetManagerCount = AssetManager.getGlobalAssetManagerCount();
    int binderLocalObjectCount = Debug.getBinderLocalObjectCount();
    int binderProxyObjectCount = Debug.getBinderProxyObjectCount();
    int binderDeathObjectCount = Debug.getBinderDeathObjectCount();
    int openSslSocketCount = OpenSSLSocketImpl.getInstanceCount();
    long sqliteAllocated = SQLiteDebug.getHeapAllocatedSize() / 1024;
    SQLiteDebug.PagerStats stats = new SQLiteDebug.PagerStats();
    SQLiteDebug.getPagerStats(stats);
    // Check to see if we were called by checkin server. If so, print terse format.
    boolean doCheckinFormat = false;
    if (args != null) {
        for (String arg : args) {
            if (""-c"".equals(arg))
                doCheckinFormat = true;
        }
    }
    // For checkin, we print one long comma-separated list of values
    if (doCheckinFormat) {
        // NOTE: if you change anything significant below, also consider changing
        // ACTIVITY_THREAD_CHECKIN_VERSION.
        String processName = (mBoundApplication != null) ? mBoundApplication.processName : ""unknown"";
        // Header
        pw.print(ACTIVITY_THREAD_CHECKIN_VERSION);
        pw.print(',');
        pw.print(Process.myPid());
        pw.print(',');
        pw.print(processName);
        pw.print(',');
        // Heap info - max
        pw.print(nativeMax);
        pw.print(',');
        pw.print(dalvikMax);
        pw.print(',');
        pw.print(""N/A,"");
        pw.print(nativeMax + dalvikMax);
        pw.print(',');
        // Heap info - allocated
        pw.print(nativeAllocated);
        pw.print(',');
        pw.print(dalvikAllocated);
        pw.print(',');
        pw.print(""N/A,"");
        pw.print(nativeAllocated + dalvikAllocated);
        pw.print(',');
        // Heap info - free
        pw.print(nativeFree);
        pw.print(',');
        pw.print(dalvikFree);
        pw.print(',');
        pw.print(""N/A,"");
        pw.print(nativeFree + dalvikFree);
        pw.print(',');
        // Heap info - proportional set size
        pw.print(memInfo.nativePss);
        pw.print(',');
        pw.print(memInfo.dalvikPss);
        pw.print(',');
        pw.print(memInfo.otherPss);
        pw.print(',');
        pw.print(memInfo.nativePss + memInfo.dalvikPss + memInfo.otherPss);
        pw.print(',');
        // Heap info - shared
        pw.print(nativeShared);
        pw.print(',');
        pw.print(dalvikShared);
        pw.print(',');
        pw.print(otherShared);
        pw.print(',');
        pw.print(nativeShared + dalvikShared + otherShared);
        pw.print(',');
        // Heap info - private
        pw.print(nativePrivate);
        pw.print(',');
        pw.print(dalvikPrivate);
        pw.print(',');
        pw.print(otherPrivate);
        pw.print(',');
        pw.print(nativePrivate + dalvikPrivate + otherPrivate);
        pw.print(',');
        // Object counts
        pw.print(viewInstanceCount);
        pw.print(',');
        pw.print(viewRootInstanceCount);
        pw.print(',');
        pw.print(appContextInstanceCount);
        pw.print(',');
        pw.print(activityInstanceCount);
        pw.print(',');
        pw.print(globalAssetCount);
        pw.print(',');
        pw.print(globalAssetManagerCount);
        pw.print(',');
        pw.print(binderLocalObjectCount);
        pw.print(',');
        pw.print(binderProxyObjectCount);
        pw.print(',');
        pw.print(binderDeathObjectCount);
        pw.print(',');
        pw.print(openSslSocketCount);
        pw.print(',');
        // SQL
        pw.print(sqliteAllocated);
        pw.print(',');
        pw.print(stats.databaseBytes / 1024);
        pw.print(',');
        pw.print(stats.numPagers);
        pw.print(',');
        pw.print((stats.totalBytes - stats.referencedBytes) / 1024);
        pw.print(',');
        pw.print(stats.referencedBytes / 1024);
        pw.print('\n');
        return;
    }
    // otherwise, show human-readable format
    printRow(pw, HEAP_COLUMN, """", ""native"", ""dalvik"", ""other"", ""total"");
    printRow(pw, HEAP_COLUMN, ""size:"", nativeMax, dalvikMax, ""N/A"", nativeMax + dalvikMax);
    printRow(pw, HEAP_COLUMN, ""allocated:"", nativeAllocated, dalvikAllocated, ""N/A"", nativeAllocated + dalvikAllocated);
    printRow(pw, HEAP_COLUMN, ""free:"", nativeFree, dalvikFree, ""N/A"", nativeFree + dalvikFree);
    printRow(pw, HEAP_COLUMN, ""(Pss):"", memInfo.nativePss, memInfo.dalvikPss, memInfo.otherPss, memInfo.nativePss + memInfo.dalvikPss + memInfo.otherPss);
    printRow(pw, HEAP_COLUMN, ""(shared dirty):"", nativeShared, dalvikShared, otherShared, nativeShared + dalvikShared + otherShared);
    printRow(pw, HEAP_COLUMN, ""(priv dirty):"", nativePrivate, dalvikPrivate, otherPrivate, nativePrivate + dalvikPrivate + otherPrivate);
    pw.println("" "");
    pw.println("" Objects"");
    printRow(pw, TWO_COUNT_COLUMNS, ""Views:"", viewInstanceCount, ""ViewRoots:"", viewRootInstanceCount);
    printRow(pw, TWO_COUNT_COLUMNS, ""AppContexts:"", appContextInstanceCount, ""Activities:"", activityInstanceCount);
    printRow(pw, TWO_COUNT_COLUMNS, ""Assets:"", globalAssetCount, ""AssetManagers:"", globalAssetManagerCount);
    printRow(pw, TWO_COUNT_COLUMNS, ""Local Binders:"", binderLocalObjectCount, ""Proxy Binders:"", binderProxyObjectCount);
    printRow(pw, ONE_COUNT_COLUMN, ""Death Recipients:"", binderDeathObjectCount);
    printRow(pw, ONE_COUNT_COLUMN, ""OpenSSL Sockets:"", openSslSocketCount);
    // SQLite mem info
    pw.println("" "");
    pw.println("" SQL"");
    printRow(pw, TWO_COUNT_COLUMNS, ""heap:"", sqliteAllocated, ""dbFiles:"", stats.databaseBytes / 1024);
    printRow(pw, TWO_COUNT_COLUMNS, ""numPagers:"", stats.numPagers, ""inactivePageKB:"", (stats.totalBytes - stats.referencedBytes) / 1024);
    printRow(pw, ONE_COUNT_COLUMN, ""activePageKB:"", stats.referencedBytes / 1024);
    // Asset details.
    String assetAlloc = AssetManager.getAssetAllocations();
    if (assetAlloc != null) {
        pw.println("" "");
        pw.println("" Asset Allocations"");
        pw.print(assetAlloc);
    }
}","{
    long nativeMax = Debug.getNativeHeapSize() / 1024;
    long nativeAllocated = Debug.getNativeHeapAllocatedSize() / 1024;
    long nativeFree = Debug.getNativeHeapFreeSize() / 1024;
    Debug.MemoryInfo memInfo = new Debug.MemoryInfo();
    Debug.getMemoryInfo(memInfo);
    final int nativeShared = memInfo.nativeSharedDirty;
    final int dalvikShared = memInfo.dalvikSharedDirty;
    final int otherShared = memInfo.otherSharedDirty;
    final int nativePrivate = memInfo.nativePrivateDirty;
    final int dalvikPrivate = memInfo.dalvikPrivateDirty;
    final int otherPrivate = memInfo.otherPrivateDirty;
    Runtime runtime = Runtime.getRuntime();
    long dalvikMax = runtime.totalMemory() / 1024;
    long dalvikFree = runtime.freeMemory() / 1024;
    long dalvikAllocated = dalvikMax - dalvikFree;
    long viewInstanceCount = ViewDebug.getViewInstanceCount();
    long viewRootInstanceCount = ViewDebug.getViewRootInstanceCount();
    long appContextInstanceCount = ContextImpl.getInstanceCount();
    long activityInstanceCount = Activity.getInstanceCount();
    int globalAssetCount = AssetManager.getGlobalAssetCount();
    int globalAssetManagerCount = AssetManager.getGlobalAssetManagerCount();
    int binderLocalObjectCount = Debug.getBinderLocalObjectCount();
    int binderProxyObjectCount = Debug.getBinderProxyObjectCount();
    int binderDeathObjectCount = Debug.getBinderDeathObjectCount();
    int openSslSocketCount = OpenSSLSocketImpl.getInstanceCount();
    long sqliteAllocated = SQLiteDebug.getHeapAllocatedSize() / 1024;
    SQLiteDebug.PagerStats stats = SQLiteDebug.getDatabaseInfo();
    // Check to see if we were called by checkin server. If so, print terse format.
    boolean doCheckinFormat = false;
    if (args != null) {
        for (String arg : args) {
            if (""-c"".equals(arg))
                doCheckinFormat = true;
        }
    }
    // For checkin, we print one long comma-separated list of values
    if (doCheckinFormat) {
        // NOTE: if you change anything significant below, also consider changing
        // ACTIVITY_THREAD_CHECKIN_VERSION.
        String processName = (mBoundApplication != null) ? mBoundApplication.processName : ""unknown"";
        // Header
        pw.print(ACTIVITY_THREAD_CHECKIN_VERSION);
        pw.print(',');
        pw.print(Process.myPid());
        pw.print(',');
        pw.print(processName);
        pw.print(',');
        // Heap info - max
        pw.print(nativeMax);
        pw.print(',');
        pw.print(dalvikMax);
        pw.print(',');
        pw.print(""N/A,"");
        pw.print(nativeMax + dalvikMax);
        pw.print(',');
        // Heap info - allocated
        pw.print(nativeAllocated);
        pw.print(',');
        pw.print(dalvikAllocated);
        pw.print(',');
        pw.print(""N/A,"");
        pw.print(nativeAllocated + dalvikAllocated);
        pw.print(',');
        // Heap info - free
        pw.print(nativeFree);
        pw.print(',');
        pw.print(dalvikFree);
        pw.print(',');
        pw.print(""N/A,"");
        pw.print(nativeFree + dalvikFree);
        pw.print(',');
        // Heap info - proportional set size
        pw.print(memInfo.nativePss);
        pw.print(',');
        pw.print(memInfo.dalvikPss);
        pw.print(',');
        pw.print(memInfo.otherPss);
        pw.print(',');
        pw.print(memInfo.nativePss + memInfo.dalvikPss + memInfo.otherPss);
        pw.print(',');
        // Heap info - shared
        pw.print(nativeShared);
        pw.print(',');
        pw.print(dalvikShared);
        pw.print(',');
        pw.print(otherShared);
        pw.print(',');
        pw.print(nativeShared + dalvikShared + otherShared);
        pw.print(',');
        // Heap info - private
        pw.print(nativePrivate);
        pw.print(',');
        pw.print(dalvikPrivate);
        pw.print(',');
        pw.print(otherPrivate);
        pw.print(',');
        pw.print(nativePrivate + dalvikPrivate + otherPrivate);
        pw.print(',');
        // Object counts
        pw.print(viewInstanceCount);
        pw.print(',');
        pw.print(viewRootInstanceCount);
        pw.print(',');
        pw.print(appContextInstanceCount);
        pw.print(',');
        pw.print(activityInstanceCount);
        pw.print(',');
        pw.print(globalAssetCount);
        pw.print(',');
        pw.print(globalAssetManagerCount);
        pw.print(',');
        pw.print(binderLocalObjectCount);
        pw.print(',');
        pw.print(binderProxyObjectCount);
        pw.print(',');
        pw.print(binderDeathObjectCount);
        pw.print(',');
        pw.print(openSslSocketCount);
        pw.print(',');
        // SQL
        pw.print(sqliteAllocated);
        pw.print(',');
        pw.print(stats.memoryUsed / 1024);
        pw.print(',');
        pw.print(stats.pageCacheOverflo / 1024);
        pw.print(',');
        pw.print(stats.largestMemAlloc / 1024);
        pw.print(',');
        for (int i = 0; i < stats.dbStats.size(); i++) {
            DbStats dbStats = stats.dbStats.get(i);
            printRow(pw, DB_INFO_FORMAT, dbStats.pageSize, dbStats.dbSize, dbStats.lookaside, dbStats.dbName);
            pw.print(',');
        }
        return;
    }
    // otherwise, show human-readable format
    printRow(pw, HEAP_COLUMN, """", ""native"", ""dalvik"", ""other"", ""total"");
    printRow(pw, HEAP_COLUMN, ""size:"", nativeMax, dalvikMax, ""N/A"", nativeMax + dalvikMax);
    printRow(pw, HEAP_COLUMN, ""allocated:"", nativeAllocated, dalvikAllocated, ""N/A"", nativeAllocated + dalvikAllocated);
    printRow(pw, HEAP_COLUMN, ""free:"", nativeFree, dalvikFree, ""N/A"", nativeFree + dalvikFree);
    printRow(pw, HEAP_COLUMN, ""(Pss):"", memInfo.nativePss, memInfo.dalvikPss, memInfo.otherPss, memInfo.nativePss + memInfo.dalvikPss + memInfo.otherPss);
    printRow(pw, HEAP_COLUMN, ""(shared dirty):"", nativeShared, dalvikShared, otherShared, nativeShared + dalvikShared + otherShared);
    printRow(pw, HEAP_COLUMN, ""(priv dirty):"", nativePrivate, dalvikPrivate, otherPrivate, nativePrivate + dalvikPrivate + otherPrivate);
    pw.println("" "");
    pw.println("" Objects"");
    printRow(pw, TWO_COUNT_COLUMNS, ""Views:"", viewInstanceCount, ""ViewRoots:"", viewRootInstanceCount);
    printRow(pw, TWO_COUNT_COLUMNS, ""AppContexts:"", appContextInstanceCount, ""Activities:"", activityInstanceCount);
    printRow(pw, TWO_COUNT_COLUMNS, ""Assets:"", globalAssetCount, ""AssetManagers:"", globalAssetManagerCount);
    printRow(pw, TWO_COUNT_COLUMNS, ""Local Binders:"", binderLocalObjectCount, ""Proxy Binders:"", binderProxyObjectCount);
    printRow(pw, ONE_COUNT_COLUMN, ""Death Recipients:"", binderDeathObjectCount);
    printRow(pw, ONE_COUNT_COLUMN, ""OpenSSL Sockets:"", openSslSocketCount);
    // SQLite mem info
    pw.println("" "");
    pw.println("" SQL"");
    printRow(pw, TWO_COUNT_COLUMNS, ""heap:"", sqliteAllocated, ""memoryUsed:"", stats.memoryUsed / 1024);
    printRow(pw, TWO_COUNT_COLUMNS, ""pageCacheOverflo:"", stats.pageCacheOverflo / 1024, ""largestMemAlloc:"", stats.largestMemAlloc / 1024);
    pw.println("" "");
    int N = stats.dbStats.size();
    if (N > 0) {
        pw.println("" DATABASES"");
        printRow(pw, ""  %8s %8s %10s  %s"", ""Pagesize"", ""Dbsize"", ""Lookaside"", ""Dbname"");
        for (int i = 0; i < N; i++) {
            DbStats dbStats = stats.dbStats.get(i);
            printRow(pw, DB_INFO_FORMAT, dbStats.pageSize, dbStats.dbSize, dbStats.lookaside, dbStats.dbName);
        }
    }
    // Asset details.
    String assetAlloc = AssetManager.getAssetAllocations();
    if (assetAlloc != null) {
        pw.println("" "");
        pw.println("" Asset Allocations"");
        pw.print(assetAlloc);
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,,,,
350,<android.webkit.URLUtil: boolean isValidUrl(String)>,7,8,<android.webkit.URLUtil: boolean isValidUrl(String)>,<android.webkit.URLUtil: boolean isValidUrl(String)>,0,"{
    if (url == null || url.length() == 0) {
        return false;
    }
    return (isAssetUrl(url) || isFileUrl(url) || isAboutUrl(url) || isHttpUrl(url) || isHttpsUrl(url) || isJavaScriptUrl(url) || isContentUrl(url));
}","{
    if (url == null || url.length() == 0) {
        return false;
    }
    return (isAssetUrl(url) || isResourceUrl(url) || isFileUrl(url) || isAboutUrl(url) || isHttpUrl(url) || isHttpsUrl(url) || isJavaScriptUrl(url) || isContentUrl(url));
}",1,"/**
 * @return True iff the url is valid.
 */
","/**
 * @return True iff the url is valid.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The return statement has changed, as the list of validation methods for 'url' has included a new method 'isResourceUrl(url)' in the late version. The addition of a new validation check amounts to the modification of a dependent API call. Therefore, the code change type is 1,5.","The addition of 'isResourceUrl(url)' in the return statement validation checks may cause the API to potentially return a different value depending on the provided 'url'. Therefore, the CI type is 1."
352,"<android.webkit.ViewManager.ChildView: void attachView(int,int,int,int)>",7,8,"<android.webkit.ViewManager.ChildView: void attachView(int,int,int,int)>","<android.webkit.ViewManager.ChildView: void attachView(int,int,int,int)>",0,"{
    if (mView == null) {
        return;
    }
    setBounds(x, y, width, height);
    final AbsoluteLayout.LayoutParams lp = new AbsoluteLayout.LayoutParams(ctvD(width), ctvD(height), ctvX(x), ctvY(y));
    mWebView.mPrivateHandler.post(new Runnable() {

        public void run() {
            // children.
            if (mView.getParent() != null) {
                mView.setLayoutParams(lp);
            } else {
                attachViewOnUIThread(lp);
            }
        }
    });
}","{
    if (mView == null) {
        return;
    }
    setBounds(x, y, width, height);
    mWebView.mPrivateHandler.post(new Runnable() {

        public void run() {
            // This method may be called multiple times. If the view is
            // already attached, just set the new LayoutParams,
            // otherwise attach the view and add it to the list of
            // children.
            requestLayout(ChildView.this);
            if (mView.getParent() == null) {
                attachViewOnUIThread();
            }
        }
    });
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"3,4",1,"The control flow of the code has been changed, and certain statements (creation of AbsoluteLayout.LayoutParams and its use) are not present in the late version, therefore, the code changed type is 3,4.","Because of the change in control flow and the removal of some instructions, it is likely that the late version behaves differently and has the potential to return different variables, causing the CI type to be 1."
353,"<android.pim.RecurrenceSet: boolean populateComponent(ContentValues,Component)>",7,8,"<android.pim.RecurrenceSet: boolean populateComponent(ContentValues,Component)>","<android.pim.RecurrenceSet: boolean populateComponent(ContentValues,Component)>",0,"{
    long dtstart = -1;
    if (values.containsKey(Calendar.Events.DTSTART)) {
        dtstart = values.getAsLong(Calendar.Events.DTSTART);
    }
    String duration = values.getAsString(Calendar.Events.DURATION);
    String tzid = values.getAsString(Calendar.Events.EVENT_TIMEZONE);
    String rruleStr = values.getAsString(Calendar.Events.RRULE);
    String rdateStr = values.getAsString(Calendar.Events.RDATE);
    String exruleStr = values.getAsString(Calendar.Events.EXRULE);
    String exdateStr = values.getAsString(Calendar.Events.EXDATE);
    boolean allDay = values.getAsInteger(Calendar.Events.ALL_DAY) == 1;
    if ((dtstart == -1) || (TextUtils.isEmpty(duration)) || ((TextUtils.isEmpty(rruleStr)) && (TextUtils.isEmpty(rdateStr)))) {
        // no recurrence.
        return false;
    }
    ICalendar.Property dtstartProp = new ICalendar.Property(""DTSTART"");
    Time dtstartTime = null;
    if (!TextUtils.isEmpty(tzid)) {
        if (!allDay) {
            dtstartProp.addParameter(new ICalendar.Parameter(""TZID"", tzid));
        }
        dtstartTime = new Time(tzid);
    } else {
        // use the ""floating"" timezone
        dtstartTime = new Time(Time.TIMEZONE_UTC);
    }
    dtstartTime.set(dtstart);
    // TODO: android.pim.Time really should take care of this for us.
    if (allDay) {
        dtstartProp.addParameter(new ICalendar.Parameter(""VALUE"", ""DATE""));
        dtstartTime.allDay = true;
        dtstartTime.hour = 0;
        dtstartTime.minute = 0;
        dtstartTime.second = 0;
    }
    dtstartProp.setValue(dtstartTime.format2445());
    component.addProperty(dtstartProp);
    ICalendar.Property durationProp = new ICalendar.Property(""DURATION"");
    durationProp.setValue(duration);
    component.addProperty(durationProp);
    addPropertiesForRuleStr(component, ""RRULE"", rruleStr);
    addPropertyForDateStr(component, ""RDATE"", rdateStr);
    addPropertiesForRuleStr(component, ""EXRULE"", exruleStr);
    addPropertyForDateStr(component, ""EXDATE"", exdateStr);
    return true;
}","{
    long dtstart = -1;
    if (values.containsKey(Calendar.Events.DTSTART)) {
        dtstart = values.getAsLong(Calendar.Events.DTSTART);
    }
    String duration = values.getAsString(Calendar.Events.DURATION);
    String tzid = values.getAsString(Calendar.Events.EVENT_TIMEZONE);
    String rruleStr = values.getAsString(Calendar.Events.RRULE);
    String rdateStr = values.getAsString(Calendar.Events.RDATE);
    String exruleStr = values.getAsString(Calendar.Events.EXRULE);
    String exdateStr = values.getAsString(Calendar.Events.EXDATE);
    Integer allDayInteger = values.getAsInteger(Calendar.Events.ALL_DAY);
    boolean allDay = (null != allDayInteger) ? (allDayInteger == 1) : false;
    if ((dtstart == -1) || (TextUtils.isEmpty(duration)) || ((TextUtils.isEmpty(rruleStr)) && (TextUtils.isEmpty(rdateStr)))) {
        // no recurrence.
        return false;
    }
    ICalendar.Property dtstartProp = new ICalendar.Property(""DTSTART"");
    Time dtstartTime = null;
    if (!TextUtils.isEmpty(tzid)) {
        if (!allDay) {
            dtstartProp.addParameter(new ICalendar.Parameter(""TZID"", tzid));
        }
        dtstartTime = new Time(tzid);
    } else {
        // use the ""floating"" timezone
        dtstartTime = new Time(Time.TIMEZONE_UTC);
    }
    dtstartTime.set(dtstart);
    // TODO: android.pim.Time really should take care of this for us.
    if (allDay) {
        dtstartProp.addParameter(new ICalendar.Parameter(""VALUE"", ""DATE""));
        dtstartTime.allDay = true;
        dtstartTime.hour = 0;
        dtstartTime.minute = 0;
        dtstartTime.second = 0;
    }
    dtstartProp.setValue(dtstartTime.format2445());
    component.addProperty(dtstartProp);
    ICalendar.Property durationProp = new ICalendar.Property(""DURATION"");
    durationProp.setValue(duration);
    component.addProperty(durationProp);
    addPropertiesForRuleStr(component, ""RRULE"", rruleStr);
    addPropertyForDateStr(component, ""RDATE"", rdateStr);
    addPropertiesForRuleStr(component, ""EXRULE"", exruleStr);
    addPropertyForDateStr(component, ""EXDATE"", exdateStr);
    return true;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,3,0,The assignment of "allDay" has been changed to handle the potential null value of values.getAsInteger(). This falls under type 3 change: control dependency change.,"Though there is a change in the code logic, it doesn't seem to affect the return type/values or exception handlings of the method. Hence no compatibility issue observed. So the CI Type is 0."
356,"<android.accounts.AccountManager: AccountManagerFuture<Bundle> getAuthTokenByFeatures(String,String,String[],Activity,Bundle,Bundle,AccountManagerCallback<Bundle>,Handler)>",7,8,"<android.accounts.AccountManager: AccountManagerFuture<Bundle> getAuthTokenByFeatures(String,String,String[],Activity,Bundle,Bundle,AccountManagerCallback<Bundle>,Handler)>","<android.accounts.AccountManager: AccountManagerFuture<Bundle> getAuthTokenByFeatures(String,String,String[],Activity,Bundle,Bundle,AccountManagerCallback<Bundle>,Handler)>",0,"{
    if (accountType == null)
        throw new IllegalArgumentException(""account type is null"");
    if (authTokenType == null)
        throw new IllegalArgumentException(""authTokenType is null"");
    final GetAuthTokenByTypeAndFeaturesTask task = new GetAuthTokenByTypeAndFeaturesTask(accountType, authTokenType, features, activityForPrompting, addAccountOptions, getAuthTokenOptions, callback, handler);
    task.start();
    return task;
}","{
    if (accountType == null)
        throw new IllegalArgumentException(""account type is null"");
    if (authTokenType == null)
        throw new IllegalArgumentException(""authTokenType is null"");
    final GetAuthTokenByTypeAndFeaturesTask task = new GetAuthTokenByTypeAndFeaturesTask(accountType, authTokenType, features, activity, addAccountOptions, getAuthTokenOptions, callback, handler);
    task.start();
    return task;
}",1,"/**
 * Convenience method that combines the functionality of {@link #getAccountsByTypeAndFeatures},
 * {@link #getAuthToken(Account, String, Bundle, Activity, AccountManagerCallback, Handler)},
 * and {@link #addAccount}. It first gets the list of accounts that match accountType and the
 * feature set. If there are none then {@link #addAccount} is invoked with the authTokenType
 * feature set, and addAccountOptions. If there is exactly one then
 * {@link #getAuthToken(Account, String, Bundle, Activity, AccountManagerCallback, Handler)} is
 * called with that account. If there are more than one then a chooser activity is launched
 * to prompt the user to select one of them and then the authtoken is retrieved for it,
 * <p>
 * This call returns immediately but runs asynchronously and the result is accessed via the
 * {@link AccountManagerFuture} that is returned. This future is also passed as the sole
 * parameter to the {@link AccountManagerCallback}. If the caller wished to use this
 * method asynchronously then they will generally pass in a callback object that will get
 * invoked with the {@link AccountManagerFuture}. If they wish to use it synchronously then
 * they will generally pass null for the callback and instead call
 * {@link android.accounts.AccountManagerFuture#getResult()} on this method's return value,
 * which will then block until the request completes.
 * <p>
 * Requires that the caller has permission {@link android.Manifest.permission#MANAGE_ACCOUNTS}.
 *
 * @param accountType the accountType to query; this must be non-null
 * @param authTokenType the type of authtoken to retrieve; this must be non-null
 * @param features a filter for the accounts. See {@link #getAccountsByTypeAndFeatures}.
 * @param activityForPrompting The activity used to start any account management
 * activities that are required to fulfill this request. This may be null.
 * @param addAccountOptions authenticator-specific options used if an account needs to be added
 * @param getAuthTokenOptions authenticator-specific options passed to getAuthToken
 * @param callback A callback to invoke when the request completes. If null then
 * no callback is invoked.
 * @param handler The {@link Handler} to use to invoke the callback. If null then the
 * main thread's {@link Handler} is used.
 * @return an {@link AccountManagerFuture} that represents the future result of the call.
 * The future result is a {@link Bundle} that contains either:
 * <ul>
 * <li> {@link #KEY_INTENT}, if no activity is supplied yet an activity needs to launched to
 * fulfill the request.
 * <li> {@link #KEY_ACCOUNT_NAME}, {@link #KEY_ACCOUNT_TYPE} and {@link #KEY_AUTHTOKEN} if the
 * request completes successfully.
 * </ul>
 * If the user presses ""back"" then the request will be canceled.
 */
","/**
 * This convenience helper combines the functionality of
 * {@link #getAccountsByTypeAndFeatures}, {@link #getAuthToken}, and
 * {@link #addAccount}.
 *
 * <p>This method gets a list of the accounts matching the
 * specified type and feature set; if there is exactly one, it is
 * used; if there are more than one, the user is prompted to pick one;
 * if there are none, the user is prompted to add one.  Finally,
 * an auth token is acquired for the chosen account.
 *
 * <p>This method may be called from any thread, but the returned
 * {@link AccountManagerFuture} must not be used on the main thread.
 *
 * <p>This method requires the caller to hold the permission
 * {@link android.Manifest.permission#MANAGE_ACCOUNTS}.
 *
 * @param accountType The account type required
 * (see {@link #getAccountsByType}), must not be null
 * @param authTokenType The desired auth token type
 * (see {@link #getAuthToken}), must not be null
 * @param features Required features for the account
 * (see {@link #getAccountsByTypeAndFeatures}), may be null or empty
 * @param activity The {@link Activity} context to use for launching new
 * sub-Activities to prompt to add an account, select an account,
 * and/or enter a password, as necessary; used only to call
 * startActivity(); should not be null
 * @param addAccountOptions Authenticator-specific options to use for
 * adding new accounts; may be null or empty
 * @param getAuthTokenOptions Authenticator-specific options to use for
 * getting auth tokens; may be null or empty
 * @param callback Callback to invoke when the request completes,
 * null for no callback
 * @param handler {@link Handler} identifying the callback thread,
 * null for the main thread
 * @return An {@link AccountManagerFuture} which resolves to a Bundle with
 * at least the following fields:
 * <ul>
 * <li> {@link #KEY_ACCOUNT_NAME} - the name of the account
 * <li> {@link #KEY_ACCOUNT_TYPE} - the type of the account
 * <li> {@link #KEY_AUTHTOKEN} - the auth token you wanted
 * </ul>
 *
 * <p>If an error occurred, {@link AccountManagerFuture#getResult()} throws:
 * <ul>
 * <li> {@link AuthenticatorException} if no authenticator was registered for
 * this account type or the authenticator failed to respond
 * <li> {@link OperationCanceledException} if the operation was canceled for
 * any reason, including the user canceling any operation
 * <li> {@link IOException} if the authenticator experienced an I/O problem
 * updating settings, usually because of network trouble
 * </ul>
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The change is only one word in the instantiation of GetAuthTokenByTypeAndFeaturesTask where 'activityForPrompting' is replaced with 'activity', so the code change is the type 4.","The instantiated GetAuthTokenByTypeAndFeaturesTask is not returned directly, and the changed word does not affect the final result of the return statement, therefore there are no compatibility issues."
357,<android.ddm.DdmHandleHeap: Chunk handleChunk(Chunk)>,7,8,<android.ddm.DdmHandleHeap: Chunk handleChunk(Chunk)>,<android.ddm.DdmHandleHeap: Chunk handleChunk(Chunk)>,0,"{
    if (Config.LOGV)
        Log.v(""ddm-heap"", ""Handling "" + name(request.type) + "" chunk"");
    int type = request.type;
    if (type == CHUNK_HPIF) {
        return handleHPIF(request);
    } else if (type == CHUNK_HPSG) {
        return handleHPSGNHSG(request, false);
    } else if (type == CHUNK_HPDU) {
        return handleHPDU(request);
    } else if (type == CHUNK_NHSG) {
        return handleHPSGNHSG(request, true);
    } else if (type == CHUNK_HPGC) {
        return handleHPGC(request);
    } else if (type == CHUNK_REAE) {
        return handleREAE(request);
    } else if (type == CHUNK_REAQ) {
        return handleREAQ(request);
    } else if (type == CHUNK_REAL) {
        return handleREAL(request);
    } else {
        throw new RuntimeException(""Unknown packet "" + ChunkHandler.name(type));
    }
}","{
    if (Config.LOGV)
        Log.v(""ddm-heap"", ""Handling "" + name(request.type) + "" chunk"");
    int type = request.type;
    if (type == CHUNK_HPIF) {
        return handleHPIF(request);
    } else if (type == CHUNK_HPSG) {
        return handleHPSGNHSG(request, false);
    } else if (type == CHUNK_HPDU) {
        return handleHPDU(request);
    } else if (type == CHUNK_HPDS) {
        return handleHPDS(request);
    } else if (type == CHUNK_NHSG) {
        return handleHPSGNHSG(request, true);
    } else if (type == CHUNK_HPGC) {
        return handleHPGC(request);
    } else if (type == CHUNK_REAE) {
        return handleREAE(request);
    } else if (type == CHUNK_REAQ) {
        return handleREAQ(request);
    } else if (type == CHUNK_REAL) {
        return handleREAL(request);
    } else {
        throw new RuntimeException(""Unknown packet "" + ChunkHandler.name(type));
    }
}",1,"/**
 * Handle a chunk of data.
 */
","/**
 * Handle a chunk of data.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3",1,"An 'if else' branch has been added between CHUNK_HPDU and CHUNK_NHSG, and thus a new return statement has been added too. Hence, the change type is 1,3.","The newly added 'if else' branch could potentially lead to a different return value, so the Compatibility Issue type is 1."
358,<android.app.ActivityManager: void restartPackage(String)>,7,8,<android.app.ActivityManager: void restartPackage(String)>,<android.app.ActivityManager: void restartPackage(String)>,0,"{
    try {
        ActivityManagerNative.getDefault().restartPackage(packageName);
    } catch (RemoteException e) {
    }
}","{
    killBackgroundProcesses(packageName);
}",1,"/**
 * Have the system perform a force stop of everything associated with
 * the given application package.  All processes that share its uid
 * will be killed, all services it has running stopped, all activities
 * removed, etc.  In addition, a {@link Intent#ACTION_PACKAGE_RESTARTED}
 * broadcast will be sent, so that any of its registered alarms can
 * be stopped, notifications removed, etc.
 *
 * <p>You must hold the permission
 * {@link android.Manifest.permission#RESTART_PACKAGES} to be able to
 * call this method.
 *
 * @param packageName The name of the package to be stopped.
 */
","/**
 * @deprecated This is now just a wrapper for
 * {@link #killBackgroundProcesses(String)}; the previous behavior here
 * is no longer available to applications because it allows them to
 * break other applications by removing their alarms, stopping their
 * services, etc.
 */
",-1,,[@Deprecated],-1,-1,-1,-1,-1,-1,"1,5",1,"The implementation has completely changed. Early version uses ActivityManagerNative.getDefault().restartPackage(packageName), while the late version implements it using killBackgroundProcesses(packageName). Thus, the code change type is 1,5.","Since the method called in the implementation has changed, it potentially causes the API to return a different variable (value or type). Thus, it can be regarded as a compatibility issue of type 1."
361,<android.widget.HorizontalScrollView: int computeHorizontalScrollRange()>,7,8,<android.widget.HorizontalScrollView: int computeHorizontalScrollRange()>,<android.widget.HorizontalScrollView: int computeHorizontalScrollRange()>,0,"{
    int count = getChildCount();
    return count == 0 ? getWidth() : getChildAt(0).getRight();
}","{
    final int count = getChildCount();
    final int contentWidth = getWidth() - mPaddingLeft - mPaddingRight;
    if (count == 0) {
        return contentWidth;
    }
    return getChildAt(0).getRight();
}",1,"/**
 * <p>The scroll range of a scroll view is the overall width of all of its
 * children.</p>
 */
","/**
 * <p>The scroll range of a scroll view is the overall width of all of its
 * children.</p>
 */
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,1,"The calculation logic for the variable 'contentWidth' has been introduced in the latest implementation. Hence, the change category is 4, indicating changes in other statements and computations in the method.","The newly introduced calculation logic for computing the contentWidth may potentially impact the return value of the method, potentially causing the API to return a different result. Hence, we have a Compatibility Issue caused by potential different return values or types, which is category 1."
363,"<android.app.ActivityThread.PackageInfo.ReceiverDispatcher.InnerReceiver: void performReceive(Intent,int,String,Bundle,boolean,boolean)>",7,8,"<android.app.ActivityThread.PackageInfo.ReceiverDispatcher.InnerReceiver: void performReceive(Intent,int,String,Bundle,boolean,boolean)>","<android.app.ActivityThread.PackageInfo.ReceiverDispatcher.InnerReceiver: void performReceive(Intent,int,String,Bundle,boolean,boolean)>",0,"{
    ReceiverDispatcher rd = mDispatcher.get();
    if (DEBUG_BROADCAST) {
        int seq = intent.getIntExtra(""seq"", -1);
        Log.i(TAG, ""Receiving broadcast "" + intent.getAction() + "" seq="" + seq + "" to "" + rd);
    }
    if (rd != null) {
        rd.performReceive(intent, resultCode, data, extras, ordered, sticky);
    } else {
        // behalf so that the system's broadcast sequence can continue.
        if (DEBUG_BROADCAST) {
            Log.i(TAG, ""Broadcast to unregistered receiver"");
        }
        IActivityManager mgr = ActivityManagerNative.getDefault();
        try {
            mgr.finishReceiver(this, resultCode, data, extras, false);
        } catch (RemoteException e) {
            Log.w(TAG, ""Couldn't finish broadcast to unregistered receiver"");
        }
    }
}","{
    ReceiverDispatcher rd = mDispatcher.get();
    if (DEBUG_BROADCAST) {
        int seq = intent.getIntExtra(""seq"", -1);
        Slog.i(TAG, ""Receiving broadcast "" + intent.getAction() + "" seq="" + seq + "" to "" + (rd != null ? rd.mReceiver : null));
    }
    if (rd != null) {
        rd.performReceive(intent, resultCode, data, extras, ordered, sticky);
    } else {
        // behalf so that the system's broadcast sequence can continue.
        if (DEBUG_BROADCAST)
            Slog.i(TAG, ""Finishing broadcast to unregistered receiver"");
        IActivityManager mgr = ActivityManagerNative.getDefault();
        try {
            mgr.finishReceiver(this, resultCode, data, extras, false);
        } catch (RemoteException e) {
            Slog.w(TAG, ""Couldn't finish broadcast to unregistered receiver"");
        }
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,4,0,"The changes between the two versions are the addition of ""rd != null ? rd.mReceiver : null"" in the second Slog.i statement in the DEBUG_BROADCAST conditional block and the replacement of Log.i, Log.w functions with Slog.i, Slog.w respectively. Neither of these changes impact the return and exception handling mechanism nor any dependent APIs or control dependency. Thus, the type of change is 4 (Other statement changed).","The changes between the versions do not result in any alterations to the return values, types, or exceptions thrown by the API across versions. Therefore, there is no Compatibility Issue exist, and the CI type is 0."
364,"<android.content.ContentProviderOperation: ContentValues resolveValueBackReferences(ContentProviderResult[],int)>",7,8,"<android.content.ContentProviderOperation: ContentValues resolveValueBackReferences(ContentProviderResult[],int)>","<android.content.ContentProviderOperation: ContentValues resolveValueBackReferences(ContentProviderResult[],int)>",0,"{
    if (mValuesBackReferences == null) {
        return mValues;
    }
    final ContentValues values;
    if (mValues == null) {
        values = new ContentValues();
    } else {
        values = new ContentValues(mValues);
    }
    for (Map.Entry<String, Object> entry : mValuesBackReferences.valueSet()) {
        String key = entry.getKey();
        Integer backRefIndex = mValuesBackReferences.getAsInteger(key);
        if (backRefIndex == null) {
            throw new IllegalArgumentException(""values backref "" + key + "" is not an integer"");
        }
        values.put(key, backRefToValue(backRefs, numBackRefs, backRefIndex));
    }
    return values;
}","{
    if (mValuesBackReferences == null) {
        return mValues;
    }
    final ContentValues values;
    if (mValues == null) {
        values = new ContentValues();
    } else {
        values = new ContentValues(mValues);
    }
    for (Map.Entry<String, Object> entry : mValuesBackReferences.valueSet()) {
        String key = entry.getKey();
        Integer backRefIndex = mValuesBackReferences.getAsInteger(key);
        if (backRefIndex == null) {
            Log.e(TAG, this.toString());
            throw new IllegalArgumentException(""values backref "" + key + "" is not an integer"");
        }
        values.put(key, backRefToValue(backRefs, numBackRefs, backRefIndex));
    }
    return values;
}",1,"/**
 * The ContentValues back references are represented as a ContentValues object where the
 * key refers to a column and the value is an index of the back reference whose
 * valued should be associated with the column.
 * @param backRefs an array of previous results
 * @param numBackRefs the number of valid previous results in backRefs
 * @return the ContentValues that should be used in this operation application after
 * expansion of back references. This can be called if either mValues or mValuesBackReferences
 * is null
 * @VisibleForTesting this is intended to be a private method but it is exposed for
 * unit testing purposes
 */
","/**
 * The ContentValues back references are represented as a ContentValues object where the
 * key refers to a column and the value is an index of the back reference whose
 * valued should be associated with the column.
 * @param backRefs an array of previous results
 * @param numBackRefs the number of valid previous results in backRefs
 * @return the ContentValues that should be used in this operation application after
 * expansion of back references. This can be called if either mValues or mValuesBackReferences
 * is null
 * @VisibleForTesting this is intended to be a private method but it is exposed for
 * unit testing purposes
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,4",2,"There is a new logging statement added before the ""throw new IllegalArgumentException"" statement in the late version, so the change type is 2,4.","The addition of a new logging statement doesn't cause any compatibility issues regarding returned values. However, given that the logging statement is right before throwing an exception, it can be inferred that the exception's handling could be affected, which introduces a compatibility issue. Thus, the CI type is 2."
365,"<android.pim.vcard.VCardUtils: String[] sortNameElements(int,String,String,String)>",7,8,"<android.pim.vcard.VCardUtils: String[] sortNameElements(int,String,String,String)>","<android.pim.vcard.VCardUtils: String[] sortNameElements(int,String,String,String)>",0,"{
    String[] list = new String[3];
    switch(VCardConfig.getNameOrderType(vcardType)) {
        case VCardConfig.NAME_ORDER_JAPANESE:
            // TODO: Should handle Ascii case?
            list[0] = familyName;
            list[1] = middleName;
            list[2] = givenName;
            break;
        case VCardConfig.NAME_ORDER_EUROPE:
            list[0] = middleName;
            list[1] = givenName;
            list[2] = familyName;
            break;
        default:
            list[0] = givenName;
            list[1] = middleName;
            list[2] = familyName;
            break;
    }
    return list;
}","{
    final String[] list = new String[3];
    final int nameOrderType = VCardConfig.getNameOrderType(vcardType);
    switch(nameOrderType) {
        case VCardConfig.NAME_ORDER_JAPANESE:
            {
                if (containsOnlyPrintableAscii(familyName) && containsOnlyPrintableAscii(givenName)) {
                    list[0] = givenName;
                    list[1] = middleName;
                    list[2] = familyName;
                } else {
                    list[0] = familyName;
                    list[1] = middleName;
                    list[2] = givenName;
                }
                break;
            }
        case VCardConfig.NAME_ORDER_EUROPE:
            {
                list[0] = middleName;
                list[1] = givenName;
                list[2] = familyName;
                break;
            }
        default:
            {
                list[0] = givenName;
                list[1] = middleName;
                list[2] = familyName;
                break;
            }
    }
    return list;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"1,3",1,"In late version implementation, a new condition is added under `VCardConfig.NAME_ORDER_JAPANESE` switch case, using two new methods `containsOnlyPrintableAscii(familyName)` and `containsOnlyPrintableAscii(givenName)`. So there is a control dependency change. Also, the return elements under `VCardConfig.NAME_ORDER_JAPANESE` are different in certain conditions in late version compared to early version, indicating a return statement change.","Because of the change in the condition under `VCardConfig.NAME_ORDER_JAPANESE` and use of new methods `containsOnlyPrintableAscii(familyName)` and `containsOnlyPrintableAscii(givenName)`, the elements in return list `list` may not be the same in early version and late version, resulting in a potential different return values. This introduces a compatibility issue of type 1."
366,"<android.pim.vcard.VCardUtils: String constructNameFromElements(int,String,String,String)>",7,8,"<android.pim.vcard.VCardUtils: String constructNameFromElements(int,String,String,String)>","<android.pim.vcard.VCardUtils: String constructNameFromElements(int,String,String,String)>",0,"{
    return constructNameFromElements(nameOrderType, familyName, middleName, givenName, null, null);
}","{
    return constructNameFromElements(vcardType, familyName, middleName, givenName, null, null);
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The parameter of constructNameFromElements() has changed from 'nameOrderType' to 'vcardType', so the code change type is 5,1.","Since the parameter of the function that forms the return value has changed, there is a potential that the return value could also be different between the two versions and thus leads to a compatibility issue of type 1."
368,<android.webkit.WebViewDatabase: boolean hasCache()>,7,8,<android.webkit.WebViewDatabase: boolean hasCache()>,<android.webkit.WebViewDatabase: boolean hasCache()>,0,"{
    if (mCacheDatabase == null) {
        return false;
    }
    Cursor cursor = mCacheDatabase.query(""cache"", ID_PROJECTION, null, null, null, null, null);
    boolean ret = cursor.moveToFirst() == true;
    cursor.close();
    return ret;
}","{
    if (mCacheDatabase == null) {
        return false;
    }
    Cursor cursor = null;
    boolean ret = false;
    try {
        cursor = mCacheDatabase.query(""cache"", ID_PROJECTION, null, null, null, null, null);
        ret = cursor.moveToFirst() == true;
    } catch (IllegalStateException e) {
        Log.e(LOGTAG, ""hasCache"", e);
    } finally {
        if (cursor != null)
            cursor.close();
    }
    return ret;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"2,3","1,2","In the late version, exception handling (catch block) is introduced and control dependency (try-finally block) is changed, so the code change type is 2,3.","With the new exception handling, when an IllegalStateException occurs, the API now returns false instead of previously propagating the exception. Also, as the cursor closing operation is now in the finally block, which alters the control dependency of the code, it might affect the return statement as well. Thus the CI type is 1,2."
369,"<android.webkit.LoadListener: boolean checkCache(Map<String, String>)>",7,8,"<android.webkit.LoadListener: boolean checkCache(Map<String, String>)>","<android.webkit.LoadListener: boolean checkCache(Map<String, String>)>",0,"{
    // Get the cache file name for the current URL
    CacheResult result = CacheManager.getCacheFile(url(), headers);
    // Go ahead and set the cache loader to null in case the result is
    // null.
    mCacheLoader = null;
    // reset the flag
    mFromCache = false;
    if (result != null) {
        // The contents of the cache may need to be revalidated so just
        // remember the cache loader in the case that the server responds
        // positively to the cached content. This is also used to detect if
        // a redirect came from the cache.
        mCacheLoader = new CacheLoader(this, result);
        // added, then the cached content valid, we should use it.
        if (!headers.containsKey(CacheManager.HEADER_KEY_IFNONEMATCH) && !headers.containsKey(CacheManager.HEADER_KEY_IFMODIFIEDSINCE)) {
            if (DebugFlags.LOAD_LISTENER) {
                Log.v(LOGTAG, ""FrameLoader: HTTP URL in cache "" + ""and usable: "" + url());
            }
            // Load the cached file
            mCacheLoader.load();
            mFromCache = true;
            return true;
        }
    }
    return false;
}","{
    // Get the cache file name for the current URL
    CacheResult result = CacheManager.getCacheFile(url(), mPostIdentifier, headers);
    // Go ahead and set the cache loader to null in case the result is
    // null.
    mCacheLoader = null;
    // reset the flag
    mFromCache = false;
    if (result != null) {
        // The contents of the cache may need to be revalidated so just
        // remember the cache loader in the case that the server responds
        // positively to the cached content. This is also used to detect if
        // a redirect came from the cache.
        mCacheLoader = new CacheLoader(this, result);
        // added, then the cached content valid, we should use it.
        if (!headers.containsKey(CacheManager.HEADER_KEY_IFNONEMATCH) && !headers.containsKey(CacheManager.HEADER_KEY_IFMODIFIEDSINCE)) {
            if (DebugFlags.LOAD_LISTENER) {
                Log.v(LOGTAG, ""FrameLoader: HTTP URL in cache "" + ""and usable: "" + url());
            }
            if (isSynchronous()) {
                mCacheLoader.load();
            } else {
                // Load the cached file in a separate thread
                WebViewWorker.getHandler().obtainMessage(WebViewWorker.MSG_ADD_STREAMLOADER, mCacheLoader).sendToTarget();
            }
            mFromCache = true;
            return true;
        }
    }
    return false;
}",1,"/**
 * Check the cache for the current URL, and load it if it is valid.
 *
 * @param headers for the request
 * @return true if cached response is used.
 */
","/**
 * Check the cache for the current URL, and load it if it is valid.
 *
 * @param headers for the request
 * @return true if cached response is used.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3,4,5",1,"The parameter list of method CacheManager.getCacheFile() has changed and an if-else statement block is introduced in the late version, which lead to different return statements (either mCacheLoader.load() or the run() method of the runnable object returned by WebViewWorker.getHandler().obtainMessage().). So, the changes are classified across multiple categories: 1) Return statement changed; 3) Control dependency changed; 4) Other statement changes; 5) Dependent API changed.","The differences in return statements (mCacheLoader.load() vs mCacheLoader.run()) between the two versions could lead to a different returned value. Thus, the Compatibility Issue type is 1."
370,<android.widget.AbsListView: int computeVerticalScrollRange()>,7,8,<android.widget.AbsListView: int computeVerticalScrollRange()>,<android.widget.AbsListView: int computeVerticalScrollRange()>,0,"{
    return mSmoothScrollbarEnabled ? Math.max(mItemCount * 100, 0) : mItemCount;
}","{
    int result;
    if (mSmoothScrollbarEnabled) {
        result = Math.max(mItemCount * 100, 0);
    } else {
        result = mItemCount;
    }
    return result;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,3,0,"The change is an expansion of the conditional operator to an if and else block in the new version, which falls under type 3, Control dependency changed.","The change will not result in a compatibility issue because the results returned in both versions are the same. Thus, no Compatibility Issue exists."
371,"<android.app.ActivityThread.PackageInfo: Application makeApplication(boolean,Instrumentation)>",7,8,"<android.app.ActivityThread.PackageInfo: Application makeApplication(boolean,Instrumentation)>","<android.app.ActivityThread.PackageInfo: Application makeApplication(boolean,Instrumentation)>",0,"{
    if (mApplication != null) {
        return mApplication;
    }
    Application app = null;
    String appClass = mApplicationInfo.className;
    if (forceDefaultAppClass || (appClass == null)) {
        appClass = ""android.app.Application"";
    }
    try {
        java.lang.ClassLoader cl = getClassLoader();
        ApplicationContext appContext = new ApplicationContext();
        appContext.init(this, null, mActivityThread);
        app = mActivityThread.mInstrumentation.newApplication(cl, appClass, appContext);
        appContext.setOuterContext(app);
    } catch (Exception e) {
        if (!mActivityThread.mInstrumentation.onException(app, e)) {
            throw new RuntimeException(""Unable to instantiate application "" + appClass + "": "" + e.toString(), e);
        }
    }
    mActivityThread.mAllApplications.add(app);
    mApplication = app;
    if (instrumentation != null) {
        try {
            instrumentation.callApplicationOnCreate(app);
        } catch (Exception e) {
            if (!instrumentation.onException(app, e)) {
                throw new RuntimeException(""Unable to create application "" + app.getClass().getName() + "": "" + e.toString(), e);
            }
        }
    }
    return app;
}","{
    if (mApplication != null) {
        return mApplication;
    }
    Application app = null;
    String appClass = mApplicationInfo.className;
    if (forceDefaultAppClass || (appClass == null)) {
        appClass = ""android.app.Application"";
    }
    try {
        java.lang.ClassLoader cl = getClassLoader();
        ContextImpl appContext = new ContextImpl();
        appContext.init(this, null, mActivityThread);
        app = mActivityThread.mInstrumentation.newApplication(cl, appClass, appContext);
        appContext.setOuterContext(app);
    } catch (Exception e) {
        if (!mActivityThread.mInstrumentation.onException(app, e)) {
            throw new RuntimeException(""Unable to instantiate application "" + appClass + "": "" + e.toString(), e);
        }
    }
    mActivityThread.mAllApplications.add(app);
    mApplication = app;
    if (instrumentation != null) {
        try {
            instrumentation.callApplicationOnCreate(app);
        } catch (Exception e) {
            if (!instrumentation.onException(app, e)) {
                throw new RuntimeException(""Unable to create application "" + app.getClass().getName() + "": "" + e.toString(), e);
            }
        }
    }
    return app;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,4,1,"The type of variable 'appContext' has changed from 'ApplicationContext' to 'ContextImpl', so the code change type is 4.","The change in the statement may affect the outcome variable 'app'. Since different class type is used to initialize the 'appContext', the 'app' returned by the API could potentially behave differently thus the CI type is 1."
374,<android.widget.AbsListView: int computeVerticalScrollOffset()>,7,8,<android.widget.AbsListView: int computeVerticalScrollOffset()>,<android.widget.AbsListView: int computeVerticalScrollOffset()>,0,"{
    final int firstPosition = mFirstPosition;
    final int childCount = getChildCount();
    if (firstPosition >= 0 && childCount > 0) {
        if (mSmoothScrollbarEnabled) {
            final View view = getChildAt(0);
            final int top = view.getTop();
            int height = view.getHeight();
            if (height > 0) {
                return Math.max(firstPosition * 100 - (top * 100) / height, 0);
            }
        } else {
            int index;
            final int count = mItemCount;
            if (firstPosition == 0) {
                index = 0;
            } else if (firstPosition + childCount == count) {
                index = count;
            } else {
                index = firstPosition + childCount / 2;
            }
            return (int) (firstPosition + childCount * (index / (float) count));
        }
    }
    return 0;
}","{
    final int firstPosition = mFirstPosition;
    final int childCount = getChildCount();
    if (firstPosition >= 0 && childCount > 0) {
        if (mSmoothScrollbarEnabled) {
            final View view = getChildAt(0);
            final int top = view.getTop();
            int height = view.getHeight();
            if (height > 0) {
                return Math.max(firstPosition * 100 - (top * 100) / height + (int) ((float) mScrollY / getHeight() * mItemCount * 100), 0);
            }
        } else {
            int index;
            final int count = mItemCount;
            if (firstPosition == 0) {
                index = 0;
            } else if (firstPosition + childCount == count) {
                index = count;
            } else {
                index = firstPosition + childCount / 2;
            }
            return (int) (firstPosition + childCount * (index / (float) count));
        }
    }
    return 0;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,1,1,"The change from the early version to the late version is located in the return statement in the conditional ""if (mSmoothScrollbarEnabled)"", with additional terms in the returned computation as ""(int) ((float) mScrollY / getHeight() * mItemCount * 100)"". Therefore, the code change type is 1.","The introduced additional term in the return statement could make the return value different from the early version, leading to potential different behaviors in the same scenarios. Therefore, the Compatibility Issue type is 1."
376,<android.accounts.AccountAuthenticatorResponse: void onRequestContinued()>,7,8,<android.accounts.AccountAuthenticatorResponse: void onRequestContinued()>,<android.accounts.AccountAuthenticatorResponse: void onRequestContinued()>,0,"{
    try {
        mAccountAuthenticatorResponse.onRequestContinued();
    } catch (RemoteException e) {
    // this should never happen
    }
}","{
    if (Log.isLoggable(TAG, Log.VERBOSE)) {
        Log.v(TAG, ""AccountAuthenticatorResponse.onRequestContinued"");
    }
    try {
        mAccountAuthenticatorResponse.onRequestContinued();
    } catch (RemoteException e) {
    // this should never happen
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,4,0,"Some log statement was added. Neither return statements, exceptions, control dependencies nor dependent APIs have changed, hence the change is of type 4.","Although a log statement was added, it does not affect the behavior of the method. Thus, it doesn't cause any compatibility issues."
377,<android.service.wallpaper.WallpaperService.Engine: void detach()>,7,8,<android.service.wallpaper.WallpaperService.Engine: void detach()>,<android.service.wallpaper.WallpaperService.Engine: void detach()>,0,"{
    if (mDestroyed) {
        return;
    }
    mDestroyed = true;
    if (mVisible) {
        mVisible = false;
        if (DEBUG)
            Log.v(TAG, ""onVisibilityChanged(false): "" + this);
        onVisibilityChanged(false);
    }
    if (mDestroyReportNeeded) {
        mDestroyReportNeeded = false;
        SurfaceHolder.Callback[] callbacks;
        synchronized (mSurfaceHolder.mCallbacks) {
            callbacks = new SurfaceHolder.Callback[mSurfaceHolder.mCallbacks.size()];
            mSurfaceHolder.mCallbacks.toArray(callbacks);
        }
        for (SurfaceHolder.Callback c : callbacks) {
            c.surfaceDestroyed(mSurfaceHolder);
        }
        if (DEBUG)
            Log.v(TAG, ""onSurfaceDestroyed("" + mSurfaceHolder + ""): "" + this);
        onSurfaceDestroyed(mSurfaceHolder);
    }
    if (DEBUG)
        Log.v(TAG, ""onDestroy(): "" + this);
    onDestroy();
    unregisterReceiver(mReceiver);
    if (mCreated) {
        try {
            mSession.remove(mWindow);
        } catch (RemoteException e) {
        }
        mSurfaceHolder.mSurface.release();
        mCreated = false;
    }
}","{
    if (mDestroyed) {
        return;
    }
    mDestroyed = true;
    if (mVisible) {
        mVisible = false;
        if (DEBUG)
            Log.v(TAG, ""onVisibilityChanged(false): "" + this);
        onVisibilityChanged(false);
    }
    reportSurfaceDestroyed();
    if (DEBUG)
        Log.v(TAG, ""onDestroy(): "" + this);
    onDestroy();
    unregisterReceiver(mReceiver);
    if (mCreated) {
        try {
            if (DEBUG)
                Log.v(TAG, ""Removing window and destroying surface "" + mSurfaceHolder.getSurface() + "" of: "" + this);
            mSession.remove(mWindow);
        } catch (RemoteException e) {
        }
        mSurfaceHolder.mSurface.release();
        mCreated = false;
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,The original block of code designed to destroy the surface has been replaced with a call to reportSurfaceDestroyed(). This can be classified as a change in both the other statements (type 4) and the dependent API (type 5).,"Although the implementation of API changes, these changes only affect inner logic and specific processes inside the API. Hence, they do not affect the return value or the exceptions the function might throw. So, no compatibility issue (type 0) exists here."
379,"<android.provider.Calendar.CalendarAlerts: boolean alarmExists(ContentResolver,long,long,long)>",7,8,"<android.provider.Calendar.CalendarAlerts: boolean alarmExists(ContentResolver,long,long,long)>","<android.provider.Calendar.CalendarAlerts: boolean alarmExists(ContentResolver,long,long,long)>",0,"{
    String selection = CalendarAlerts.EVENT_ID + ""="" + eventId + "" AND "" + CalendarAlerts.BEGIN + ""="" + begin + "" AND "" + CalendarAlerts.ALARM_TIME + ""="" + alarmTime;
    // TODO: construct an explicit SQL query so that we can add
    // ""LIMIT 1"" to the end and get just one result.
    String[] projection = new String[] { CalendarAlerts.ALARM_TIME };
    Cursor cursor = query(cr, projection, selection, null);
    boolean found = false;
    try {
        if (cursor != null && cursor.getCount() > 0) {
            found = true;
        }
    } finally {
        if (cursor != null) {
            cursor.close();
        }
    }
    return found;
}","{
    // TODO: construct an explicit SQL query so that we can add
    // ""LIMIT 1"" to the end and get just one result.
    String[] projection = new String[] { ALARM_TIME };
    Cursor cursor = query(cr, projection, WHERE_ALARM_EXISTS, new String[] { Long.toString(eventId), Long.toString(begin), Long.toString(alarmTime) }, null);
    boolean found = false;
    try {
        if (cursor != null && cursor.getCount() > 0) {
            found = true;
        }
    } finally {
        if (cursor != null) {
            cursor.close();
        }
    }
    return found;
}",1,"/**
 * Searches for an entry in the CalendarAlerts table that matches
 * the given event id, begin time and alarm time.  If one is found
 * then this alarm already exists and this method returns true.
 *
 * @param cr the ContentResolver
 * @param eventId the event id to match
 * @param begin the start time of the event in UTC millis
 * @param alarmTime the alarm time of the event in UTC millis
 * @return true if there is already an alarm for the given event
 * with the same start time and alarm time.
 */
","/**
 * Searches for an entry in the CalendarAlerts table that matches
 * the given event id, begin time and alarm time.  If one is found
 * then this alarm already exists and this method returns true.
 *
 * @param cr the ContentResolver
 * @param eventId the event id to match
 * @param begin the start time of the event in UTC millis
 * @param alarmTime the alarm time of the event in UTC millis
 * @return true if there is already an alarm for the given event
 * with the same start time and alarm time.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The change occurs in how the 'query' method is called. Instead of using explicit String concatenation to build the SQL query, they now use a WHERE_ALARM_EXISTS constant and an array of parameter values, which will be bound by the query method itself. So the code change type is 4.","The execution logic and return value of the API remain the same, so no Compatibility Issue exists."
380,"<android.content.res.Resources: void updateConfiguration(Configuration,DisplayMetrics)>",7,8,"<android.content.res.Resources: void updateConfiguration(Configuration,DisplayMetrics)>","<android.content.res.Resources: void updateConfiguration(Configuration,DisplayMetrics)>",0,"{
    synchronized (mTmpValue) {
        int configChanges = 0xfffffff;
        if (config != null) {
            configChanges = mConfiguration.updateFrom(config);
        }
        if (metrics != null) {
            mMetrics.setTo(metrics);
            mMetrics.updateMetrics(mCompatibilityInfo, mConfiguration.orientation, mConfiguration.screenLayout);
        }
        mMetrics.scaledDensity = mMetrics.density * mConfiguration.fontScale;
        String locale = null;
        if (mConfiguration.locale != null) {
            locale = mConfiguration.locale.getLanguage();
            if (mConfiguration.locale.getCountry() != null) {
                locale += ""-"" + mConfiguration.locale.getCountry();
            }
        }
        int width, height;
        if (mMetrics.widthPixels >= mMetrics.heightPixels) {
            width = mMetrics.widthPixels;
            height = mMetrics.heightPixels;
        } else {
            // noinspection SuspiciousNameCombination
            width = mMetrics.heightPixels;
            // noinspection SuspiciousNameCombination
            height = mMetrics.widthPixels;
        }
        int keyboardHidden = mConfiguration.keyboardHidden;
        if (keyboardHidden == Configuration.HARDKEYBOARDHIDDEN_NO && mConfiguration.hardKeyboardHidden == Configuration.HARDKEYBOARDHIDDEN_YES) {
            keyboardHidden = Configuration.KEYBOARDHIDDEN_SOFT;
        }
        mAssets.setConfiguration(mConfiguration.mcc, mConfiguration.mnc, locale, mConfiguration.orientation, mConfiguration.touchscreen, (int) (mMetrics.density * 160), mConfiguration.keyboard, keyboardHidden, mConfiguration.navigation, width, height, mConfiguration.screenLayout, sSdkVersion);
        int N = mDrawableCache.size();
        if (DEBUG_CONFIG) {
            Log.d(TAG, ""Cleaning up drawables config changes: 0x"" + Integer.toHexString(configChanges));
        }
        for (int i = 0; i < N; i++) {
            WeakReference<Drawable.ConstantState> ref = mDrawableCache.valueAt(i);
            if (ref != null) {
                Drawable.ConstantState cs = ref.get();
                if (cs != null) {
                    if (Configuration.needNewResources(configChanges, cs.getChangingConfigurations())) {
                        if (DEBUG_CONFIG) {
                            Log.d(TAG, ""FLUSHING #0x"" + Long.toHexString(mDrawableCache.keyAt(i)) + "" / "" + cs + "" with changes: 0x"" + Integer.toHexString(cs.getChangingConfigurations()));
                        }
                        mDrawableCache.setValueAt(i, null);
                    } else if (DEBUG_CONFIG) {
                        Log.d(TAG, ""(Keeping #0x"" + Long.toHexString(mDrawableCache.keyAt(i)) + "" / "" + cs + "" with changes: 0x"" + Integer.toHexString(cs.getChangingConfigurations()) + "")"");
                    }
                }
            }
        }
        mDrawableCache.clear();
        mColorStateListCache.clear();
        flushLayoutCache();
    }
    synchronized (mSync) {
        if (mPluralRule != null) {
            mPluralRule = PluralRules.ruleForLocale(config.locale);
        }
    }
}","{
    synchronized (mTmpValue) {
        int configChanges = 0xfffffff;
        if (config != null) {
            configChanges = mConfiguration.updateFrom(config);
        }
        if (mConfiguration.locale == null) {
            mConfiguration.locale = Locale.getDefault();
        }
        if (metrics != null) {
            mMetrics.setTo(metrics);
            mMetrics.updateMetrics(mCompatibilityInfo, mConfiguration.orientation, mConfiguration.screenLayout);
        }
        mMetrics.scaledDensity = mMetrics.density * mConfiguration.fontScale;
        String locale = null;
        if (mConfiguration.locale != null) {
            locale = mConfiguration.locale.getLanguage();
            if (mConfiguration.locale.getCountry() != null) {
                locale += ""-"" + mConfiguration.locale.getCountry();
            }
        }
        int width, height;
        if (mMetrics.widthPixels >= mMetrics.heightPixels) {
            width = mMetrics.widthPixels;
            height = mMetrics.heightPixels;
        } else {
            // noinspection SuspiciousNameCombination
            width = mMetrics.heightPixels;
            // noinspection SuspiciousNameCombination
            height = mMetrics.widthPixels;
        }
        int keyboardHidden = mConfiguration.keyboardHidden;
        if (keyboardHidden == Configuration.HARDKEYBOARDHIDDEN_NO && mConfiguration.hardKeyboardHidden == Configuration.HARDKEYBOARDHIDDEN_YES) {
            keyboardHidden = Configuration.KEYBOARDHIDDEN_SOFT;
        }
        mAssets.setConfiguration(mConfiguration.mcc, mConfiguration.mnc, locale, mConfiguration.orientation, mConfiguration.touchscreen, (int) (mMetrics.density * 160), mConfiguration.keyboard, keyboardHidden, mConfiguration.navigation, width, height, mConfiguration.screenLayout, mConfiguration.uiMode, sSdkVersion);
        int N = mDrawableCache.size();
        if (DEBUG_CONFIG) {
            Log.d(TAG, ""Cleaning up drawables config changes: 0x"" + Integer.toHexString(configChanges));
        }
        for (int i = 0; i < N; i++) {
            WeakReference<Drawable.ConstantState> ref = mDrawableCache.valueAt(i);
            if (ref != null) {
                Drawable.ConstantState cs = ref.get();
                if (cs != null) {
                    if (Configuration.needNewResources(configChanges, cs.getChangingConfigurations())) {
                        if (DEBUG_CONFIG) {
                            Log.d(TAG, ""FLUSHING #0x"" + Long.toHexString(mDrawableCache.keyAt(i)) + "" / "" + cs + "" with changes: 0x"" + Integer.toHexString(cs.getChangingConfigurations()));
                        }
                        mDrawableCache.setValueAt(i, null);
                    } else if (DEBUG_CONFIG) {
                        Log.d(TAG, ""(Keeping #0x"" + Long.toHexString(mDrawableCache.keyAt(i)) + "" / "" + cs + "" with changes: 0x"" + Integer.toHexString(cs.getChangingConfigurations()) + "")"");
                    }
                }
            }
        }
        mDrawableCache.clear();
        mColorStateListCache.clear();
        flushLayoutCache();
    }
    synchronized (mSync) {
        if (mPluralRule != null) {
            mPluralRule = PluralRules.ruleForLocale(config.locale);
        }
    }
}",1,"/**
 * Store the newly updated configuration.
 */
","/**
 * Store the newly updated configuration.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",0,"There is an addition of a new condition block that assigns a default locale if mConfiguration.locale is null. Also, there is a change in mAssets.setConfiguration() where mConfiguration.uiMode has been added to the set of parameters. Therefore, the change is classified as types 3 and 4.","Although API has undergone some changes, they do not constitute a compatibility issue. The addition of a new condition block or an argument to a function does not alter the potential behaviour of the API in a way that causes it to return a different variable type, value, or throw an exception differently. Therefore, the Compatibility Issue type is 0."
382,<android.database.sqlite.SQLiteDatabase: int getVersion()>,7,8,<android.database.sqlite.SQLiteDatabase: int getVersion()>,<android.database.sqlite.SQLiteDatabase: int getVersion()>,0,"{
    SQLiteStatement prog = null;
    lock();
    try {
        prog = new SQLiteStatement(this, ""PRAGMA user_version;"");
        long version = prog.simpleQueryForLong();
        return (int) version;
    } finally {
        if (prog != null)
            prog.close();
        unlock();
    }
}","{
    SQLiteStatement prog = null;
    lock();
    if (!isOpen()) {
        throw new IllegalStateException(""database not open"");
    }
    try {
        prog = new SQLiteStatement(this, ""PRAGMA user_version;"");
        long version = prog.simpleQueryForLong();
        return (int) version;
    } finally {
        if (prog != null)
            prog.close();
        unlock();
    }
}",1,"/**
 * Gets the database version.
 *
 * @return the database version
 */
","/**
 * Gets the database version.
 *
 * @return the database version
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,3","1,2",A new condition check 'if (!isOpen())' is added and an exception is thrown when the condition is met. So the code change type is 2 (Exception handling statement changed) and 3 (Control dependency changed).,"Due to the condition check, if the database is not open, the late version API will throw a new exception. This will make the behaviour of the API different from the early version, which affects the return value of the API. Thus, the CI type is 1 (Compatibility Issue caused by potential different return values or types) and 2 (Compatibility Issue caused by potential different exception handlings)."
383,"<android.accounts.AbstractAccountAuthenticator.Transport: void getAuthTokenLabel(IAccountAuthenticatorResponse,String)>",7,8,"<android.accounts.AbstractAccountAuthenticator.Transport: void getAuthTokenLabel(IAccountAuthenticatorResponse,String)>","<android.accounts.AbstractAccountAuthenticator.Transport: void getAuthTokenLabel(IAccountAuthenticatorResponse,String)>",0,"{
    checkBinderPermission();
    try {
        Bundle result = new Bundle();
        result.putString(AccountManager.KEY_AUTH_TOKEN_LABEL, AbstractAccountAuthenticator.this.getAuthTokenLabel(authTokenType));
        response.onResult(result);
    } catch (IllegalArgumentException e) {
        response.onError(AccountManager.ERROR_CODE_BAD_ARGUMENTS, ""unknown authTokenType"");
    } catch (UnsupportedOperationException e) {
        response.onError(AccountManager.ERROR_CODE_UNSUPPORTED_OPERATION, ""getAuthTokenTypeLabel not supported"");
    }
}","{
    if (Log.isLoggable(TAG, Log.VERBOSE)) {
        Log.v(TAG, ""getAuthTokenLabel: authTokenType "" + authTokenType);
    }
    checkBinderPermission();
    try {
        Bundle result = new Bundle();
        result.putString(AccountManager.KEY_AUTH_TOKEN_LABEL, AbstractAccountAuthenticator.this.getAuthTokenLabel(authTokenType));
        if (Log.isLoggable(TAG, Log.VERBOSE)) {
            // force it to be unparcelled
            result.keySet();
            Log.v(TAG, ""getAuthTokenLabel: result "" + AccountManager.sanitizeResult(result));
        }
        if (result != null) {
            response.onResult(result);
        }
    } catch (IllegalArgumentException e) {
        if (Log.isLoggable(TAG, Log.VERBOSE)) {
            Log.v(TAG, ""getAuthTokenLabel"", e);
        }
        response.onError(AccountManager.ERROR_CODE_BAD_ARGUMENTS, ""unknown authTokenType"");
    } catch (UnsupportedOperationException e) {
        if (Log.isLoggable(TAG, Log.VERBOSE)) {
            Log.v(TAG, ""getAuthTokenLabel"", e);
        }
        response.onError(AccountManager.ERROR_CODE_UNSUPPORTED_OPERATION, ""getAuthTokenTypeLabel not supported"");
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"3,4",0,"The implementation of Early_Version checks the 'Binder' permission without using any logging mechanisms. However, the Late_Version not only checks the 'Binder' permission but also logs the authTokenType and result using 'Log.isLoggable' and 'Log.v'. There is a change in the condition statement as the Late_Version additionally checks whether result is not null before executing 'response.onResult(result)', hence, the code change type is 3,4.","Though there is a change in the logging and condition check, these changes won't affect the behaviour of the method, neither they cause returning of different types or values, nor does it cause any different exception handlings. Therefore, no compatibility issue is expected."
385,"<android.provider.MediaStore.Images.Thumbnails: Bitmap getThumbnail(ContentResolver,long,int,Options)>",7,8,"<android.provider.MediaStore.Images.Thumbnails: Bitmap getThumbnail(ContentResolver,long,int,Options)>","<android.provider.MediaStore.Images.Thumbnails: Bitmap getThumbnail(ContentResolver,long,int,Options)>",0,"{
    return InternalThumbnails.getThumbnail(cr, origId, kind, options, EXTERNAL_CONTENT_URI, false);
}","{
    return InternalThumbnails.getThumbnail(cr, origId, InternalThumbnails.DEFAULT_GROUP_ID, kind, options, EXTERNAL_CONTENT_URI, false);
}",1,"/**
 * This method checks if the thumbnails of the specified image (origId) has been created.
 * It will be blocked until the thumbnails are generated.
 *
 * @param cr ContentResolver used to dispatch queries to MediaProvider.
 * @param origId Original image id associated with thumbnail of interest.
 * @param kind The type of thumbnail to fetch. Should be either MINI_KIND or MICRO_KIND.
 * @param options this is only used for MINI_KIND when decoding the Bitmap
 * @return A Bitmap instance. It could be null if the original image
 * associated with origId doesn't exist or memory is not enough.
 */
","/**
 * This method checks if the thumbnails of the specified image (origId) has been created.
 * It will be blocked until the thumbnails are generated.
 *
 * @param cr ContentResolver used to dispatch queries to MediaProvider.
 * @param origId Original image id associated with thumbnail of interest.
 * @param kind The type of thumbnail to fetch. Should be either MINI_KIND or MICRO_KIND.
 * @param options this is only used for MINI_KIND when decoding the Bitmap
 * @return A Bitmap instance. It could be null if the original image
 * associated with origId doesn't exist or memory is not enough.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The dependent method 'InternalThumbnails.getThumbnail' has been modified to support a new parameter 'InternalThumbnails.DEFAULT_GROUP_ID', which changes the return statement. So, the change type is 1,5.","The method 'getThumbnail' has changed its behaviour by introducing a new argument 'InternalThumbnails.DEFAULT_GROUP_ID', as a result, it may cause the 'getThumbnail' method returning different values between two versions. So, the CI type is 1."
386,<android.database.sqlite.SQLiteClosable: void acquireReference()>,7,8,<android.database.sqlite.SQLiteClosable: void acquireReference()>,<android.database.sqlite.SQLiteClosable: void acquireReference()>,0,"{
    synchronized (mLock) {
        if (mReferenceCount <= 0) {
            throw new IllegalStateException(""attempt to acquire a reference on a close SQLiteClosable"");
        }
        mReferenceCount++;
    }
}","{
    synchronized (mLock) {
        if (mReferenceCount <= 0) {
            throw new IllegalStateException(""attempt to re-open an already-closed object: "" + getObjInfo());
        }
        mReferenceCount++;
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"2,4",2,"The message in the thrown IllegalStateException has been changed, and one more dependent method, 'getObjInfo()', is invoked when the exception is thrown, hence the change type is 2,4.","The message in the thrown IllegalStateException between two continuous versions are changed and this IllegalStateException is handled differently, hence the Compatibility Issue type is 2."
388,<android.widget.TabHost: void addTab(TabSpec)>,7,8,<android.widget.TabHost: void addTab(TabSpec)>,<android.widget.TabHost: void addTab(TabSpec)>,0,"{
    if (tabSpec.mIndicatorStrategy == null) {
        throw new IllegalArgumentException(""you must specify a way to create the tab indicator."");
    }
    if (tabSpec.mContentStrategy == null) {
        throw new IllegalArgumentException(""you must specify a way to create the tab content"");
    }
    View tabIndicator = tabSpec.mIndicatorStrategy.createIndicatorView();
    tabIndicator.setOnKeyListener(mTabKeyListener);
    // the tab indicators.
    if (tabSpec.mIndicatorStrategy instanceof ViewIndicatorStrategy) {
        mTabWidget.setDrawBottomStrips(false);
    }
    mTabWidget.addView(tabIndicator);
    mTabSpecs.add(tabSpec);
    if (mCurrentTab == -1) {
        setCurrentTab(0);
    }
}","{
    if (tabSpec.mIndicatorStrategy == null) {
        throw new IllegalArgumentException(""you must specify a way to create the tab indicator."");
    }
    if (tabSpec.mContentStrategy == null) {
        throw new IllegalArgumentException(""you must specify a way to create the tab content"");
    }
    View tabIndicator = tabSpec.mIndicatorStrategy.createIndicatorView();
    tabIndicator.setOnKeyListener(mTabKeyListener);
    // the tab indicators.
    if (tabSpec.mIndicatorStrategy instanceof ViewIndicatorStrategy) {
        mTabWidget.setStripEnabled(false);
    }
    mTabWidget.addView(tabIndicator);
    mTabSpecs.add(tabSpec);
    if (mCurrentTab == -1) {
        setCurrentTab(0);
    }
}",1,"/**
 * Add a tab.
 * @param tabSpec Specifies how to create the indicator and content.
 */
","/**
 * Add a tab.
 * @param tabSpec Specifies how to create the indicator and content.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",1,"The statement 'mTabWidget.setDrawBottomStrips(false)' changes to 'mTabWidget.setStripEnabled(false)', which shows a method name change of the dependent API mTabWidget and thus the code change type is 4,5.","The change 'mTabWidget.setDrawBottomStrips(false)' to 'mTabWidget.setStripEnabled(false)' could potentially influence the final behavior of the method (output state), so the Compatibility Issue type is 1."
389,<android.pim.vcard.VCardComposer.HandlerForOutputStream: boolean onInit(Context)>,7,8,<android.pim.vcard.VCardComposer.HandlerForOutputStream: boolean onInit(Context)>,<android.pim.vcard.VCardComposer.HandlerForOutputStream: boolean onInit(Context)>,0,"{
    try {
        mWriter = new BufferedWriter(new OutputStreamWriter(mOutputStream, mCharsetString));
    } catch (UnsupportedEncodingException e1) {
        Log.e(LOG_TAG, ""Unsupported charset: "" + mCharsetString);
        mErrorReason = ""Encoding is not supported (usually this does not happen!): "" + mCharsetString;
        return false;
    }
    if (mIsDoCoMo) {
        try {
            // Create one empty entry.
            mWriter.write(createOneEntryInternal(""-1""));
        } catch (IOException e) {
            Log.e(LOG_TAG, ""IOException occurred during exportOneContactData: "" + e.getMessage());
            mErrorReason = ""IOException occurred: "" + e.getMessage();
            return false;
        }
    }
    return true;
}","{
    try {
        mWriter = new BufferedWriter(new OutputStreamWriter(mOutputStream, mCharsetString));
    } catch (UnsupportedEncodingException e1) {
        Log.e(LOG_TAG, ""Unsupported charset: "" + mCharsetString);
        mErrorReason = ""Encoding is not supported (usually this does not happen!): "" + mCharsetString;
        return false;
    }
    if (mIsDoCoMo) {
        try {
            // Create one empty entry.
            mWriter.write(createOneEntryInternal(""-1"", null));
        } catch (VCardException e) {
            Log.e(LOG_TAG, ""VCardException has been thrown during on Init(): "" + e.getMessage());
            return false;
        } catch (IOException e) {
            Log.e(LOG_TAG, ""IOException occurred during exportOneContactData: "" + e.getMessage());
            mErrorReason = ""IOException occurred: "" + e.getMessage();
            return false;
        }
    }
    return true;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"1,2,5","1,2","In the Late Implementation, one argument, `null`, is added in the call to `createOneEntryInternal`. Besides, a `VCardException` is introduced and captured using a `catch` clause. Therefore, the change involving return statement, exception handling, and dependent API changes, so the change type is 1,2,5.","The introduction of a new exception type `VCardException` and the modification of the `createOneEntryInternal` method potentially leads to different exception handling and return values between Early and Late versions, hence the CI type is 1,2."
391,<android.inputmethodservice.InputMethodService: void startExtractingText(boolean)>,7,8,<android.inputmethodservice.InputMethodService: void startExtractingText(boolean)>,<android.inputmethodservice.InputMethodService: void startExtractingText(boolean)>,0,"{
    final ExtractEditText eet = mExtractEditText;
    if (eet != null && getCurrentInputStarted() && isFullscreenMode()) {
        mExtractedToken++;
        ExtractedTextRequest req = new ExtractedTextRequest();
        req.token = mExtractedToken;
        req.flags = InputConnection.GET_TEXT_WITH_STYLES;
        req.hintMaxLines = 10;
        req.hintMaxChars = 10000;
        InputConnection ic = getCurrentInputConnection();
        mExtractedText = ic == null ? null : ic.getExtractedText(req, InputConnection.GET_EXTRACTED_TEXT_MONITOR);
        final EditorInfo ei = getCurrentInputEditorInfo();
        try {
            eet.startInternalChanges();
            onUpdateExtractingVisibility(ei);
            onUpdateExtractingViews(ei);
            int inputType = ei.inputType;
            if ((inputType & EditorInfo.TYPE_MASK_CLASS) == EditorInfo.TYPE_CLASS_TEXT) {
                if ((inputType & EditorInfo.TYPE_TEXT_FLAG_IME_MULTI_LINE) != 0) {
                    inputType |= EditorInfo.TYPE_TEXT_FLAG_MULTI_LINE;
                }
            }
            eet.setInputType(inputType);
            eet.setHint(ei.hintText);
            if (mExtractedText != null) {
                eet.setEnabled(true);
                eet.setExtractedText(mExtractedText);
            } else {
                eet.setEnabled(false);
                eet.setText("""");
            }
        } finally {
            eet.finishInternalChanges();
        }
        if (inputChanged) {
            onExtractingInputChanged(ei);
        }
    }
}","{
    final ExtractEditText eet = mExtractEditText;
    if (eet != null && getCurrentInputStarted() && isFullscreenMode()) {
        mExtractedToken++;
        ExtractedTextRequest req = new ExtractedTextRequest();
        req.token = mExtractedToken;
        req.flags = InputConnection.GET_TEXT_WITH_STYLES;
        req.hintMaxLines = 10;
        req.hintMaxChars = 10000;
        InputConnection ic = getCurrentInputConnection();
        mExtractedText = ic == null ? null : ic.getExtractedText(req, InputConnection.GET_EXTRACTED_TEXT_MONITOR);
        if (mExtractedText == null || ic == null) {
            Log.e(TAG, ""Unexpected null in startExtractingText : mExtractedText = "" + mExtractedText + "", input connection = "" + ic);
        }
        final EditorInfo ei = getCurrentInputEditorInfo();
        try {
            eet.startInternalChanges();
            onUpdateExtractingVisibility(ei);
            onUpdateExtractingViews(ei);
            int inputType = ei.inputType;
            if ((inputType & EditorInfo.TYPE_MASK_CLASS) == EditorInfo.TYPE_CLASS_TEXT) {
                if ((inputType & EditorInfo.TYPE_TEXT_FLAG_IME_MULTI_LINE) != 0) {
                    inputType |= EditorInfo.TYPE_TEXT_FLAG_MULTI_LINE;
                }
            }
            eet.setInputType(inputType);
            eet.setHint(ei.hintText);
            if (mExtractedText != null) {
                eet.setEnabled(true);
                eet.setExtractedText(mExtractedText);
            } else {
                eet.setEnabled(false);
                eet.setText("""");
            }
        } finally {
            eet.finishInternalChanges();
        }
        if (inputChanged) {
            onExtractingInputChanged(ei);
        }
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,4,0,"An additional log statement has been introduced in the late version when the condition ""mExtractedText == null || ic == null"" is met, so the code change type is 4.","Logging does not contribute to the function's control flow or output, thus there's no compatibility issue. So the code change type is 0."
392,"<android.pim.vcard.VCardComposer: boolean init(String,String[])>",7,8,"<android.pim.vcard.VCardComposer: boolean init(String,String[])>","<android.pim.vcard.VCardComposer: boolean init(String,String[])>",0,"{
    if (mCareHandlerErrors) {
        List<OneEntryHandler> finishedList = new ArrayList<OneEntryHandler>(mHandlerList.size());
        for (OneEntryHandler handler : mHandlerList) {
            if (!handler.onInit(mContext)) {
                for (OneEntryHandler finished : finishedList) {
                    finished.onTerminate();
                }
                return false;
            }
        }
    } else {
        // Just ignore the false returned from onInit().
        for (OneEntryHandler handler : mHandlerList) {
            handler.onInit(mContext);
        }
    }
    if (mIsCallLogComposer) {
        mCursor = mContentResolver.query(CallLog.Calls.CONTENT_URI, sCallLogProjection, selection, selectionArgs, null);
    } else {
        mCursor = mContentResolver.query(Contacts.CONTENT_URI, sContactsProjection, selection, selectionArgs, null);
    }
    if (mCursor == null) {
        mErrorReason = FAILURE_REASON_FAILED_TO_GET_DATABASE_INFO;
        return false;
    }
    if (getCount() == 0 || !mCursor.moveToFirst()) {
        try {
            mCursor.close();
        } catch (SQLiteException e) {
            Log.e(LOG_TAG, ""SQLiteException on Cursor#close(): "" + e.getMessage());
        } finally {
            mCursor = null;
            mErrorReason = FAILURE_REASON_NO_ENTRY;
        }
        return false;
    }
    if (mIsCallLogComposer) {
        mIdColumn = -1;
    } else {
        mIdColumn = mCursor.getColumnIndex(Contacts._ID);
    }
    return true;
}","{
    return init(Contacts.CONTENT_URI, selection, selectionArgs, null);
}",1,"/**
 * @return Returns true when initialization is successful and all the other
 * methods are available. Returns false otherwise.
 */
",,-1,,,-1,-1,-1,-1,-1,-1,"1,4",1,"The early implementation has multiple 'return' statements and a complex logical structure, while the late implementation contains only a single line of code that returns the result of calling the 'init' function, so the change types are 1,4. ","The late version may yield different results or behave differently from the earlier version because the method's implementation has been completely replaced. Thus, the CI type is 1."
395,"<android.net.SSLCertificateSocketFactory: Socket createSocket(InetAddress,int)>",7,8,"<android.net.SSLCertificateSocketFactory: Socket createSocket(InetAddress,int)>","<android.net.SSLCertificateSocketFactory: Socket createSocket(InetAddress,int)>",0,"{
    throw new IOException(""Cannot validate certification without a hostname"");
}","{
    OpenSSLSocketImpl s = (OpenSSLSocketImpl) getDelegate().createSocket(addr, port);
    s.setHandshakeTimeout(mHandshakeTimeoutMillis);
    return s;
}",1,,,-1,,[@Override],-1,-1,-1,-1,-1,-1,"1,4","1,2","The early version throws an exception straight away while in the late version, it creates and returns a socket. So, the change type is 1,4 (Return statement and Other statement changed).","Due to the changes, the API could potentially return different types/values: in the earlier version, it just throws an exception, whereas in the later version, it returns a socket depending on the successful execution of the newly written code. Also, the late version implementation might throw different exceptions compared to the early version. Hence, the Compatibility Issue types are 1,2 (Compatibility Issue caused by potential different return values or types and Compatibility Issue caused by potential different exception handlings)."
396,<android.webkit.WebViewDatabase: boolean startCacheTransaction()>,7,8,<android.webkit.WebViewDatabase: boolean startCacheTransaction()>,<android.webkit.WebViewDatabase: boolean startCacheTransaction()>,0,"{
    if (++mCacheTransactionRefcount == 1) {
        mCacheDatabase.beginTransaction();
        return true;
    }
    return false;
}","{
    if (++mCacheTransactionRefcount == 1) {
        if (!Thread.currentThread().equals(WebViewWorker.getHandler().getLooper().getThread())) {
            Log.w(LOGTAG, ""startCacheTransaction should be called from "" + ""WebViewWorkerThread instead of from "" + Thread.currentThread().getName());
        }
        mCacheDatabase.beginTransaction();
        return true;
    }
    return false;
}",1,,"// only called from WebViewWorkerThread
",-1,,,-1,-1,-1,-1,-1,-1,3,0,"A new log statement has been inserted for notifying users about thread constraints when the condition (++mCacheTransactionRefcount == 1) is true, so the code change type is 3.","There are no potentially different return types or values and it's not throwing a different exception. It just added a log notification, so no compatibility issue, giving CI type as 0."
397,"<android.view.inputmethod.BaseInputConnection: CharSequence getTextAfterCursor(int,int)>",7,8,"<android.view.inputmethod.BaseInputConnection: CharSequence getTextAfterCursor(int,int)>","<android.view.inputmethod.BaseInputConnection: CharSequence getTextAfterCursor(int,int)>",0,"{
    final Editable content = getEditable();
    if (content == null)
        return null;
    int a = Selection.getSelectionStart(content);
    int b = Selection.getSelectionEnd(content);
    if (a > b) {
        int tmp = a;
        a = b;
        b = tmp;
    }
    if (b + length > content.length()) {
        length = content.length() - b;
    }
    if ((flags & GET_TEXT_WITH_STYLES) != 0) {
        return content.subSequence(b, b + length);
    }
    return TextUtils.substring(content, b, b + length);
}","{
    final Editable content = getEditable();
    if (content == null)
        return null;
    int a = Selection.getSelectionStart(content);
    int b = Selection.getSelectionEnd(content);
    if (a > b) {
        int tmp = a;
        a = b;
        b = tmp;
    }
    // Guard against the case where the cursor has not been positioned yet.
    if (b < 0) {
        b = 0;
    }
    if (b + length > content.length()) {
        length = content.length() - b;
    }
    if ((flags & GET_TEXT_WITH_STYLES) != 0) {
        return content.subSequence(b, b + length);
    }
    return TextUtils.substring(content, b, b + length);
}",1,"/**
 * The default implementation returns the given amount of text from the
 * current cursor position in the buffer.
 */
","/**
 * The default implementation returns the given amount of text from the
 * current cursor position in the buffer.
 */
",-1,,,-1,-1,-1,-1,-1,-1,3,1,"The change is in the while loop condition, where there is a new condition added to guard against the case where the cursor has not been positioned yet. So the code change type is 3.","This condition change in the while loop potentially changes the behavior of the loop as the variable 'b' might be changed to '0'. As 'b' plays a role in following 'return' statements, it makes those returns possibly different compared with the early version. So the CI type is 1."
398,<android.preference.PreferenceGroupAdapter: int getViewTypeCount()>,7,8,<android.preference.PreferenceGroupAdapter: int getViewTypeCount()>,<android.preference.PreferenceGroupAdapter: int getViewTypeCount()>,0,"{
    if (!mHasReturnedViewTypeCount) {
        mHasReturnedViewTypeCount = true;
    }
    return Math.max(1, mPreferenceClassNames.size());
}","{
    if (!mHasReturnedViewTypeCount) {
        mHasReturnedViewTypeCount = true;
    }
    return Math.max(1, mPreferenceLayouts.size());
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,5",1,"The return statement has changed from returning the size of the container ""mPreferenceClassNames"" to ""mPreferenceLayouts"". This change also modifies the API that the current method depends on. Thus, the change type is 1,5.","The changed return statement would potentially alter the value returned by the API, implying that the type of compatibility issue is 1."
399,"<android.webkit.CallbackProxy: void onReceivedTouchIconUrl(String,boolean)>",7,8,"<android.webkit.CallbackProxy: void onReceivedTouchIconUrl(String,boolean)>","<android.webkit.CallbackProxy: void onReceivedTouchIconUrl(String,boolean)>",0,"{
    // We should have a current item but we do not want to crash so check
    // for null.
    WebHistoryItem i = mBackForwardList.getCurrentItem();
    if (i != null) {
        if (precomposed || i.getTouchIconUrl() != null) {
            i.setTouchIconUrl(url);
        }
    }
    // been set.
    if (mWebChromeClient == null) {
        return;
    }
    sendMessage(obtainMessage(RECEIVED_TOUCH_ICON_URL, precomposed ? 1 : 0, 0, url));
}","{
    // We should have a current item but we do not want to crash so check
    // for null.
    WebHistoryItem i = mBackForwardList.getCurrentItem();
    if (i != null) {
        if (precomposed || i.getTouchIconUrl() == null) {
            i.setTouchIconUrl(url);
        }
    }
    // been set.
    if (mWebChromeClient == null) {
        return;
    }
    sendMessage(obtainMessage(RECEIVED_TOUCH_ICON_URL, precomposed ? 1 : 0, 0, url));
}",1,"/* package */
","/* package */
",-1,,,-1,-1,-1,-1,-1,-1,3,1,"The conditional statement inside the first 'if' block has been changed from 'i.getTouchIconUrl() != null' in the early version to 'i.getTouchIconUrl() == null' in the late version, therefore, the code change type is 3.","Due to the change in the condition dependency, it can potentially lead the program to call 'setTouchIconUrl(url)' under different circumstances and consequently leads to potentially different return values. Hence, the CI type is 1."
402,<android.view.ViewDebug: void stopRecyclerTracing()>,7,8,<android.view.ViewDebug: void stopRecyclerTracing()>,<android.view.ViewDebug: void stopRecyclerTracing()>,0,"{
    // noinspection PointlessBooleanExpression,ConstantConditions
    if (!TRACE_RECYCLER) {
        return;
    }
    if (sRecyclerOwnerView == null || sRecyclerViews == null) {
        throw new IllegalStateException(""You must call startRecyclerTracing() before"" + "" stopRecyclerTracing()!"");
    }
    File recyclerDump = new File(Environment.getExternalStorageDirectory(), ""view-recycler/"");
    // noinspection ResultOfMethodCallIgnored
    recyclerDump.mkdirs();
    recyclerDump = new File(recyclerDump, sRecyclerTracePrefix + "".recycler"");
    try {
        final BufferedWriter out = new BufferedWriter(new FileWriter(recyclerDump), 8 * 1024);
        for (View view : sRecyclerViews) {
            final String name = view.getClass().getName();
            out.write(name);
            out.newLine();
        }
        out.close();
    } catch (IOException e) {
        Log.e(""View"", ""Could not dump recycler content"");
        return;
    }
    recyclerDump = new File(Environment.getExternalStorageDirectory(), ""view-recycler/"");
    recyclerDump = new File(recyclerDump, sRecyclerTracePrefix + "".traces"");
    try {
        final FileOutputStream file = new FileOutputStream(recyclerDump);
        final DataOutputStream out = new DataOutputStream(file);
        for (RecyclerTrace trace : sRecyclerTraces) {
            out.writeInt(trace.view);
            out.writeInt(trace.type.ordinal());
            out.writeInt(trace.position);
            out.writeInt(trace.indexOnScreen);
            out.flush();
        }
        out.close();
    } catch (IOException e) {
        Log.e(""View"", ""Could not dump recycler traces"");
        return;
    }
    sRecyclerViews.clear();
    sRecyclerViews = null;
    sRecyclerTraces.clear();
    sRecyclerTraces = null;
    sRecyclerOwnerView = null;
}","{
    // noinspection PointlessBooleanExpression,ConstantConditions
    if (!TRACE_RECYCLER) {
        return;
    }
    if (sRecyclerOwnerView == null || sRecyclerViews == null) {
        throw new IllegalStateException(""You must call startRecyclerTracing() before"" + "" stopRecyclerTracing()!"");
    }
    File recyclerDump = new File(Environment.getExternalStorageDirectory(), ""view-recycler/"");
    // noinspection ResultOfMethodCallIgnored
    recyclerDump.mkdirs();
    recyclerDump = new File(recyclerDump, sRecyclerTracePrefix + "".recycler"");
    try {
        final BufferedWriter out = new BufferedWriter(new FileWriter(recyclerDump), 8 * 1024);
        for (View view : sRecyclerViews) {
            final String name = view.getClass().getName();
            out.write(name);
            out.newLine();
        }
        out.close();
    } catch (IOException e) {
        Log.e(""View"", ""Could not dump recycler content"");
        return;
    }
    recyclerDump = new File(Environment.getExternalStorageDirectory(), ""view-recycler/"");
    recyclerDump = new File(recyclerDump, sRecyclerTracePrefix + "".traces"");
    try {
        if (recyclerDump.exists()) {
            recyclerDump.delete();
        }
        final FileOutputStream file = new FileOutputStream(recyclerDump);
        final DataOutputStream out = new DataOutputStream(file);
        for (RecyclerTrace trace : sRecyclerTraces) {
            out.writeInt(trace.view);
            out.writeInt(trace.type.ordinal());
            out.writeInt(trace.position);
            out.writeInt(trace.indexOnScreen);
            out.flush();
        }
        out.close();
    } catch (IOException e) {
        Log.e(""View"", ""Could not dump recycler traces"");
        return;
    }
    sRecyclerViews.clear();
    sRecyclerViews = null;
    sRecyclerTraces.clear();
    sRecyclerTraces = null;
    sRecyclerOwnerView = null;
}",1,"/**
 * Stops the current view recycer tracing.
 *
 * Calling this method creates the file <code>/EXTERNAL/view-recycler/PREFIX.traces</code>
 * containing all the traces (or method calls) relative to the specified view's recycler.
 *
 * Calling this method creates the file <code>/EXTERNAL/view-recycler/PREFIX.recycler</code>
 * containing all of the views used by the recycler of the view supplied to
 * {@link #startRecyclerTracing(String, View)}.
 *
 * This method will return immediately if TRACE_RECYCLER is false.
 *
 * @see #startRecyclerTracing(String, View)
 * @see #trace(View, android.view.ViewDebug.RecyclerTraceType, int[])
 */
","/**
 * Stops the current view recycer tracing.
 *
 * Calling this method creates the file <code>/EXTERNAL/view-recycler/PREFIX.traces</code>
 * containing all the traces (or method calls) relative to the specified view's recycler.
 *
 * Calling this method creates the file <code>/EXTERNAL/view-recycler/PREFIX.recycler</code>
 * containing all of the views used by the recycler of the view supplied to
 * {@link #startRecyclerTracing(String, View)}.
 *
 * This method will return immediately if TRACE_RECYCLER is false.
 *
 * @see #startRecyclerTracing(String, View)
 * @see #trace(View, android.view.ViewDebug.RecyclerTraceType, int[])
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",0,"The addition of two new statements: if(recyclerDump.exists()) {recyclerDump.delete();} is observed thus it represents control dependency change type that is 3. Also, these two new statements represents other statements which do not involve return or exception handling statements, nor do they represent dependent API change, hence they also represent the change type 4.","The new statements only delete an existing file and do not affect the return type or the exception handling, therefore, there is no CI present."
403,"<android.webkit.WebView: boolean onKeyUp(int,KeyEvent)>",7,8,"<android.webkit.WebView: boolean onKeyUp(int,KeyEvent)>","<android.webkit.WebView: boolean onKeyUp(int,KeyEvent)>",0,"{
    if (DebugFlags.WEB_VIEW) {
        Log.v(LOGTAG, ""keyUp at "" + System.currentTimeMillis() + "", "" + event + "", unicode="" + event.getUnicodeChar());
    }
    if (mNativeClass == 0) {
        return false;
    }
    // special CALL handling when cursor node's href is ""tel:XXX""
    if (keyCode == KeyEvent.KEYCODE_CALL && nativeHasCursorNode()) {
        String text = nativeCursorText();
        if (!nativeCursorIsTextInput() && text != null && text.startsWith(SCHEME_TEL)) {
            Intent intent = new Intent(Intent.ACTION_DIAL, Uri.parse(text));
            getContext().startActivity(intent);
            return true;
        }
    }
    // 2. the host application wants to handle it;
    if (event.isSystem() || mCallbackProxy.uiOverrideKeyEvent(event)) {
        return false;
    }
    if (keyCode == KeyEvent.KEYCODE_SHIFT_LEFT || keyCode == KeyEvent.KEYCODE_SHIFT_RIGHT) {
        if (commitCopy()) {
            return true;
        }
    }
    if (keyCode >= KeyEvent.KEYCODE_DPAD_UP && keyCode <= KeyEvent.KEYCODE_DPAD_RIGHT) {
        // Bubble up the key event as WebView doesn't handle it
        return false;
    }
    if (keyCode == KeyEvent.KEYCODE_DPAD_CENTER) {
        // remove the long press message first
        mPrivateHandler.removeMessages(LONG_PRESS_CENTER);
        mGotCenterDown = false;
        if (mShiftIsPressed) {
            return false;
        }
        // perform the single click
        Rect visibleRect = sendOurVisibleRect();
        // coordinates should be in content coordinates.
        if (!nativeCursorIntersects(visibleRect)) {
            return false;
        }
        nativeSetFollowedLink(true);
        nativeUpdatePluginReceivesEvents();
        WebViewCore.CursorData data = cursorData();
        mWebViewCore.sendMessage(EventHub.SET_MOVE_MOUSE, data);
        playSoundEffect(SoundEffectConstants.CLICK);
        boolean isTextInput = nativeCursorIsTextInput();
        if (isTextInput || !mCallbackProxy.uiOverrideUrlLoading(nativeCursorText())) {
            mWebViewCore.sendMessage(EventHub.CLICK, data.mFrame, nativeCursorNodePointer());
        }
        if (isTextInput) {
            rebuildWebTextView();
            displaySoftKeyboard(true);
        }
        return true;
    }
    // TODO: should we pass all the keys to DOM or check the meta tag
    if (nativeCursorWantsKeyEvents() || true) {
        // pass the key to DOM
        mWebViewCore.sendMessage(EventHub.KEY_UP, event);
        // return true as DOM handles the key
        return true;
    }
    // Bubble up the key event as WebView doesn't handle it
    return false;
}","{
    if (DebugFlags.WEB_VIEW) {
        Log.v(LOGTAG, ""keyUp at "" + System.currentTimeMillis() + "", "" + event + "", unicode="" + event.getUnicodeChar());
    }
    if (mNativeClass == 0) {
        return false;
    }
    // special CALL handling when cursor node's href is ""tel:XXX""
    if (keyCode == KeyEvent.KEYCODE_CALL && nativeHasCursorNode()) {
        String text = nativeCursorText();
        if (!nativeCursorIsTextInput() && text != null && text.startsWith(SCHEME_TEL)) {
            Intent intent = new Intent(Intent.ACTION_DIAL, Uri.parse(text));
            getContext().startActivity(intent);
            return true;
        }
    }
    // 2. the host application wants to handle it;
    if (event.isSystem() || mCallbackProxy.uiOverrideKeyEvent(event)) {
        return false;
    }
    if (keyCode == KeyEvent.KEYCODE_SHIFT_LEFT || keyCode == KeyEvent.KEYCODE_SHIFT_RIGHT) {
        if (nativeFocusIsPlugin()) {
            mShiftIsPressed = false;
        } else if (commitCopy()) {
            return true;
        }
    }
    if (keyCode >= KeyEvent.KEYCODE_DPAD_UP && keyCode <= KeyEvent.KEYCODE_DPAD_RIGHT) {
        if (nativeFocusIsPlugin()) {
            letPluginHandleNavKey(keyCode, event.getEventTime(), false);
            return true;
        }
        // Bubble up the key event as WebView doesn't handle it
        return false;
    }
    if (keyCode == KeyEvent.KEYCODE_DPAD_CENTER) {
        // remove the long press message first
        mPrivateHandler.removeMessages(LONG_PRESS_CENTER);
        mGotCenterDown = false;
        if (mShiftIsPressed && !nativeFocusIsPlugin()) {
            if (mExtendSelection) {
                commitCopy();
            } else {
                mExtendSelection = true;
                // draw the i-beam instead of the arrow
                invalidate();
            }
            // discard press if copy in progress
            return true;
        }
        // perform the single click
        Rect visibleRect = sendOurVisibleRect();
        // coordinates should be in content coordinates.
        if (!nativeCursorIntersects(visibleRect)) {
            return false;
        }
        WebViewCore.CursorData data = cursorData();
        mWebViewCore.sendMessage(EventHub.SET_MOVE_MOUSE, data);
        playSoundEffect(SoundEffectConstants.CLICK);
        if (nativeCursorIsTextInput()) {
            rebuildWebTextView();
            centerKeyPressOnTextField();
            if (inEditingMode()) {
                mWebTextView.setDefaultSelection();
            }
            return true;
        }
        clearTextEntry(true);
        nativeSetFollowedLink(true);
        if (!mCallbackProxy.uiOverrideUrlLoading(nativeCursorText())) {
            mWebViewCore.sendMessage(EventHub.CLICK, data.mFrame, nativeCursorNodePointer());
        }
        return true;
    }
    // TODO: should we pass all the keys to DOM or check the meta tag
    if (nativeCursorWantsKeyEvents() || true) {
        // pass the key to DOM
        mWebViewCore.sendMessage(EventHub.KEY_UP, event);
        // return true as DOM handles the key
        return true;
    }
    // Bubble up the key event as WebView doesn't handle it
    return false;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,3,4",1,"The return statements are changed in multiple condition blocks (e.g. if (keyCode == KeyEvent.KEYCODE_SHIFT_LEFT || keyCode == KeyEvent.KEYCODE_SHIFT_RIGHT), if (keyCode >= KeyEvent.KEYCODE_DPAD_UP && keyCode <= KeyEvent.KEYCODE_DPAD_RIGHT) and if (keyCode == KeyEvent.KEYCODE_DPAD_CENTER)), control dependencies are changed (The condition statements in these blocks are updated) and other functional statements also have changes (e.g. the addition of mShiftIsPressed = false, letPluginHandleNavKey(keyCode, event.getEventTime(), false), etc.), so the code change type is 1,3,4.","The changes in return statements and control dependency will make the API potentially return different values in different version, so the CI type is 1."
406,"<android.text.method.ArrowKeyMovementMethod: boolean onTouchEvent(TextView,Spannable,MotionEvent)>",7,8,"<android.text.method.ArrowKeyMovementMethod: boolean onTouchEvent(TextView,Spannable,MotionEvent)>","<android.text.method.ArrowKeyMovementMethod: boolean onTouchEvent(TextView,Spannable,MotionEvent)>",0,"{
    int initialScrollX = -1, initialScrollY = -1;
    if (event.getAction() == MotionEvent.ACTION_UP) {
        initialScrollX = Touch.getInitialScrollX(widget, buffer);
        initialScrollY = Touch.getInitialScrollY(widget, buffer);
    }
    boolean handled = Touch.onTouchEvent(widget, buffer, event);
    if (widget.isFocused() && !widget.didTouchFocusSelect()) {
        if (event.getAction() == MotionEvent.ACTION_UP) {
            // to show it.
            if ((initialScrollY >= 0 && initialScrollY != widget.getScrollY()) || (initialScrollX >= 0 && initialScrollX != widget.getScrollX())) {
                widget.moveCursorToVisibleOffset();
                return true;
            }
            int x = (int) event.getX();
            int y = (int) event.getY();
            x -= widget.getTotalPaddingLeft();
            y -= widget.getTotalPaddingTop();
            // Clamp the position to inside of the view.
            if (x < 0) {
                x = 0;
            } else if (x >= (widget.getWidth() - widget.getTotalPaddingRight())) {
                x = widget.getWidth() - widget.getTotalPaddingRight() - 1;
            }
            if (y < 0) {
                y = 0;
            } else if (y >= (widget.getHeight() - widget.getTotalPaddingBottom())) {
                y = widget.getHeight() - widget.getTotalPaddingBottom() - 1;
            }
            x += widget.getScrollX();
            y += widget.getScrollY();
            Layout layout = widget.getLayout();
            int line = layout.getLineForVertical(y);
            int off = layout.getOffsetForHorizontal(line, x);
            // XXX should do the same adjust for x as we do for the line.
            boolean cap = (MetaKeyKeyListener.getMetaState(buffer, KeyEvent.META_SHIFT_ON) == 1) || (MetaKeyKeyListener.getMetaState(buffer, MetaKeyKeyListener.META_SELECTING) != 0);
            DoubleTapState[] tap = buffer.getSpans(0, buffer.length(), DoubleTapState.class);
            boolean doubletap = false;
            if (tap.length > 0) {
                if (event.getEventTime() - tap[0].mWhen <= ViewConfiguration.getDoubleTapTimeout()) {
                    if (sameWord(buffer, off, Selection.getSelectionEnd(buffer))) {
                        doubletap = true;
                    }
                }
                tap[0].mWhen = event.getEventTime();
            } else {
                DoubleTapState newtap = new DoubleTapState();
                newtap.mWhen = event.getEventTime();
                buffer.setSpan(newtap, 0, buffer.length(), Spannable.SPAN_INCLUSIVE_INCLUSIVE);
            }
            if (cap) {
                Selection.extendSelection(buffer, off);
            } else if (doubletap) {
                Selection.setSelection(buffer, findWordStart(buffer, off), findWordEnd(buffer, off));
            } else {
                Selection.setSelection(buffer, off);
            }
            MetaKeyKeyListener.adjustMetaAfterKeypress(buffer);
            MetaKeyKeyListener.resetLockedMeta(buffer);
            return true;
        }
    }
    return handled;
}","{
    int initialScrollX = -1, initialScrollY = -1;
    if (event.getAction() == MotionEvent.ACTION_UP) {
        initialScrollX = Touch.getInitialScrollX(widget, buffer);
        initialScrollY = Touch.getInitialScrollY(widget, buffer);
    }
    boolean handled = Touch.onTouchEvent(widget, buffer, event);
    if (widget.isFocused() && !widget.didTouchFocusSelect()) {
        if (event.getAction() == MotionEvent.ACTION_DOWN) {
            boolean cap = (MetaKeyKeyListener.getMetaState(buffer, KeyEvent.META_SHIFT_ON) == 1) || (MetaKeyKeyListener.getMetaState(buffer, MetaKeyKeyListener.META_SELECTING) != 0);
            int x = (int) event.getX();
            int y = (int) event.getY();
            int offset = getOffset(x, y, widget);
            if (cap) {
                buffer.setSpan(LAST_TAP_DOWN, offset, offset, Spannable.SPAN_POINT_POINT);
                // Disallow intercepting of the touch events, so that
                // users can scroll and select at the same time.
                // without this, users would get booted out of select
                // mode once the view detected it needed to scroll.
                widget.getParent().requestDisallowInterceptTouchEvent(true);
            } else {
                OnePointFiveTapState[] tap = buffer.getSpans(0, buffer.length(), OnePointFiveTapState.class);
                if (tap.length > 0) {
                    if (event.getEventTime() - tap[0].mWhen <= ViewConfiguration.getDoubleTapTimeout() && sameWord(buffer, offset, Selection.getSelectionEnd(buffer))) {
                        tap[0].active = true;
                        MetaKeyKeyListener.startSelecting(widget, buffer);
                        widget.getParent().requestDisallowInterceptTouchEvent(true);
                        buffer.setSpan(LAST_TAP_DOWN, offset, offset, Spannable.SPAN_POINT_POINT);
                    }
                    tap[0].mWhen = event.getEventTime();
                } else {
                    OnePointFiveTapState newtap = new OnePointFiveTapState();
                    newtap.mWhen = event.getEventTime();
                    newtap.active = false;
                    buffer.setSpan(newtap, 0, buffer.length(), Spannable.SPAN_INCLUSIVE_INCLUSIVE);
                }
            }
        } else if (event.getAction() == MotionEvent.ACTION_MOVE) {
            boolean cap = (MetaKeyKeyListener.getMetaState(buffer, KeyEvent.META_SHIFT_ON) == 1) || (MetaKeyKeyListener.getMetaState(buffer, MetaKeyKeyListener.META_SELECTING) != 0);
            if (cap && handled) {
                // Before selecting, make sure we've moved out of the ""slop"".
                // handled will be true, if we're in select mode AND we're
                // OUT of the slop
                // Turn long press off while we're selecting. User needs to
                // re-tap on the selection to enable longpress
                widget.cancelLongPress();
                // Update selection as we're moving the selection area.
                // Get the current touch position
                int x = (int) event.getX();
                int y = (int) event.getY();
                int offset = getOffset(x, y, widget);
                final OnePointFiveTapState[] tap = buffer.getSpans(0, buffer.length(), OnePointFiveTapState.class);
                if (tap.length > 0 && tap[0].active) {
                    // Get the last down touch position (the position at which the
                    // user started the selection)
                    int lastDownOffset = buffer.getSpanStart(LAST_TAP_DOWN);
                    // Compute the selection boundaries
                    int spanstart;
                    int spanend;
                    if (offset >= lastDownOffset) {
                        // Expand from word start of the original tap to new word
                        // end, since we are selecting ""forwards""
                        spanstart = findWordStart(buffer, lastDownOffset);
                        spanend = findWordEnd(buffer, offset);
                    } else {
                        // Expand to from new word start to word end of the original
                        // tap since we are selecting ""backwards"".
                        // The spanend will always need to be associated with the touch
                        // up position, so that refining the selection with the
                        // trackball will work as expected.
                        spanstart = findWordEnd(buffer, lastDownOffset);
                        spanend = findWordStart(buffer, offset);
                    }
                    Selection.setSelection(buffer, spanstart, spanend);
                } else {
                    Selection.extendSelection(buffer, offset);
                }
                return true;
            }
        } else if (event.getAction() == MotionEvent.ACTION_UP) {
            // to show it.
            if ((initialScrollY >= 0 && initialScrollY != widget.getScrollY()) || (initialScrollX >= 0 && initialScrollX != widget.getScrollX())) {
                widget.moveCursorToVisibleOffset();
                return true;
            }
            int x = (int) event.getX();
            int y = (int) event.getY();
            int off = getOffset(x, y, widget);
            // XXX should do the same adjust for x as we do for the line.
            OnePointFiveTapState[] onepointfivetap = buffer.getSpans(0, buffer.length(), OnePointFiveTapState.class);
            if (onepointfivetap.length > 0 && onepointfivetap[0].active && Selection.getSelectionStart(buffer) == Selection.getSelectionEnd(buffer)) {
                // If we've set select mode, because there was a onepointfivetap,
                // but there was no ensuing swipe gesture, undo the select mode
                // and remove reference to the last onepointfivetap.
                MetaKeyKeyListener.stopSelecting(widget, buffer);
                for (int i = 0; i < onepointfivetap.length; i++) {
                    buffer.removeSpan(onepointfivetap[i]);
                }
                buffer.removeSpan(LAST_TAP_DOWN);
            }
            boolean cap = (MetaKeyKeyListener.getMetaState(buffer, KeyEvent.META_SHIFT_ON) == 1) || (MetaKeyKeyListener.getMetaState(buffer, MetaKeyKeyListener.META_SELECTING) != 0);
            DoubleTapState[] tap = buffer.getSpans(0, buffer.length(), DoubleTapState.class);
            boolean doubletap = false;
            if (tap.length > 0) {
                if (event.getEventTime() - tap[0].mWhen <= ViewConfiguration.getDoubleTapTimeout() && sameWord(buffer, off, Selection.getSelectionEnd(buffer))) {
                    doubletap = true;
                }
                tap[0].mWhen = event.getEventTime();
            } else {
                DoubleTapState newtap = new DoubleTapState();
                newtap.mWhen = event.getEventTime();
                buffer.setSpan(newtap, 0, buffer.length(), Spannable.SPAN_INCLUSIVE_INCLUSIVE);
            }
            if (cap) {
                buffer.removeSpan(LAST_TAP_DOWN);
                if (onepointfivetap.length > 0 && onepointfivetap[0].active) {
                    // If we selecting something with the onepointfivetap-and
                    // swipe gesture, stop it on finger up.
                    MetaKeyKeyListener.stopSelecting(widget, buffer);
                } else {
                    Selection.extendSelection(buffer, off);
                }
            } else if (doubletap) {
                Selection.setSelection(buffer, findWordStart(buffer, off), findWordEnd(buffer, off));
            } else {
                Selection.setSelection(buffer, off);
            }
            MetaKeyKeyListener.adjustMetaAfterKeypress(buffer);
            MetaKeyKeyListener.resetLockedMeta(buffer);
            return true;
        }
    }
    return handled;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"3,4",1,"The code logic has changed significantly in the late version. New conditions checking MotionEvent.ACTION_DOWN and MotionEvent.ACTION_MOVE have been added, and the existing logic inside MotionEvent.ACTION_UP has also been changed accordingly. However, the type of statements changed can not be clearly classified into categories like return statements, exception handling dependencies, or dependent API changes. So, the code change type is 3,4 (Control dependency changed and Other statement changed).","The change in the control statements in the ACTION_UP part may cause the API to return different boolean values. Therefore, the CI type is 1 (Potential different return values)."
407,<android.database.sqlite.SQLiteDatabase: long getMaximumSize()>,7,8,<android.database.sqlite.SQLiteDatabase: long getMaximumSize()>,<android.database.sqlite.SQLiteDatabase: long getMaximumSize()>,0,"{
    SQLiteStatement prog = null;
    lock();
    try {
        prog = new SQLiteStatement(this, ""PRAGMA max_page_count;"");
        long pageCount = prog.simpleQueryForLong();
        return pageCount * getPageSize();
    } finally {
        if (prog != null)
            prog.close();
        unlock();
    }
}","{
    SQLiteStatement prog = null;
    lock();
    if (!isOpen()) {
        throw new IllegalStateException(""database not open"");
    }
    try {
        prog = new SQLiteStatement(this, ""PRAGMA max_page_count;"");
        long pageCount = prog.simpleQueryForLong();
        return pageCount * getPageSize();
    } finally {
        if (prog != null)
            prog.close();
        unlock();
    }
}",1,"/**
 * Returns the maximum size the database may grow to.
 *
 * @return the new maximum database size
 */
","/**
 * Returns the maximum size the database may grow to.
 *
 * @return the new maximum database size
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,3","1,2","The new code introduces an 'if' statement, which can throw a new IllegalStateException. Therefore, the control dependency (type of 3) and exception handling statement (type of 2) has changed.","The introduction of the 'isOpen' condition results in a new exception (IllegalStateException) being thrown in some cases, creating a new branch logic that can cause a change in behavior of the method (type 2). Furthermore, the IllegalStateException can lead the method to not return the same variable (type 1)."
410,"<android.content.res.AssetManager: InputStream open(String,int)>",7,8,"<android.content.res.AssetManager: InputStream open(String,int)>","<android.content.res.AssetManager: InputStream open(String,int)>",0,"{
    synchronized (this) {
        if (!mOpen) {
            throw new RuntimeException(""Assetmanager has been closed"");
        }
        int asset = openAsset(fileName, accessMode);
        if (asset != 0) {
            mNumRefs++;
            return new AssetInputStream(asset);
        }
    }
    throw new FileNotFoundException(""Asset file: "" + fileName);
}","{
    synchronized (this) {
        if (!mOpen) {
            throw new RuntimeException(""Assetmanager has been closed"");
        }
        int asset = openAsset(fileName, accessMode);
        if (asset != 0) {
            AssetInputStream res = new AssetInputStream(asset);
            incRefsLocked(res.hashCode());
            return res;
        }
    }
    throw new FileNotFoundException(""Asset file: "" + fileName);
}",1,"/**
 * Open an asset using an explicit access mode, returning an InputStream to
 * read its contents.  This provides access to files that have been bundled
 * with an application as assets -- that is, files placed in to the
 * ""assets"" directory.
 *
 * @param fileName The name of the asset to open.  This name can be
 * hierarchical.
 * @param accessMode Desired access mode for retrieving the data.
 *
 * @see #ACCESS_UNKNOWN
 * @see #ACCESS_STREAMING
 * @see #ACCESS_RANDOM
 * @see #ACCESS_BUFFER
 * @see #open(String)
 * @see #list
 */
","/**
 * Open an asset using an explicit access mode, returning an InputStream to
 * read its contents.  This provides access to files that have been bundled
 * with an application as assets -- that is, files placed in to the
 * ""assets"" directory.
 *
 * @param fileName The name of the asset to open.  This name can be
 * hierarchical.
 * @param accessMode Desired access mode for retrieving the data.
 *
 * @see #ACCESS_UNKNOWN
 * @see #ACCESS_STREAMING
 * @see #ACCESS_RANDOM
 * @see #ACCESS_BUFFER
 * @see #open(String)
 * @see #list
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,4",0,"In the return statement, 'mNumRefs++' was replaced with 'incRefsLocked(res.hashCode())'. Also, a new variable 'res' was introduced in the late version. Therefore, the code changes consist of both return statement changes (type 1) and an additional introduction of a new variable (type 4).","This code change will not cause Compatibility Issue (CI). Although there are modifications in the return statement and a new variable is introduced, the type and value of the result returned by the function remain consistent between the two versions (ie., 'return new AssetInputStream(asset)' vs 'return res' where res -> new AssetInputStream(asset)). Therefore, no Compatibility Issue exists (type 0)."
411,<android.content.ContentValues: Long getAsLong(String)>,7,8,<android.content.ContentValues: Long getAsLong(String)>,<android.content.ContentValues: Long getAsLong(String)>,0,"{
    Object value = mValues.get(key);
    try {
        return value != null ? ((Number) value).longValue() : null;
    } catch (ClassCastException e) {
        if (value instanceof CharSequence) {
            try {
                return Long.valueOf(value.toString());
            } catch (NumberFormatException e2) {
                Log.e(TAG, ""Cannot parse Long value for "" + value + "" at key "" + key);
                return null;
            }
        } else {
            Log.e(TAG, ""Cannot cast value for "" + key + "" to a Long"");
            return null;
        }
    }
}","{
    Object value = mValues.get(key);
    try {
        return value != null ? ((Number) value).longValue() : null;
    } catch (ClassCastException e) {
        if (value instanceof CharSequence) {
            try {
                return Long.valueOf(value.toString());
            } catch (NumberFormatException e2) {
                Log.e(TAG, ""Cannot parse Long value for "" + value + "" at key "" + key);
                return null;
            }
        } else {
            Log.e(TAG, ""Cannot cast value for "" + key + "" to a Long: "" + value, e);
            return null;
        }
    }
}",1,"/**
 * Gets a value and converts it to a Long.
 *
 * @param key the value to get
 * @return the Long value, or null if the value is missing or cannot be converted
 */
","/**
 * Gets a value and converts it to a Long.
 *
 * @param key the value to get
 * @return the Long value, or null if the value is missing or cannot be converted
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The only code change here is in the logging statement which now also includes throwing the exception 'e' as part of the logging. This kind of change can be classified as 'Other statement changed' since it doesn't affect the control dependency, the return statements or the exception handling directly and also not the dependent APIs. ","There is no Compatibility Issue (CI) because the change does not affect the behavior of the function, it just throws an additional value in the case of a logging operation. Log operations do not have an impact on the functionality (e.g., what values are returned, or which exceptions might be thrown by the method) therefore this change should not introduce any compatibility issues. The potential return values and exceptions thrown by the method remain the same between the two versions."
412,<android.webkit.CookieSyncManager: CookieSyncManager createInstance(Context)>,7,8,<android.webkit.CookieSyncManager: CookieSyncManager createInstance(Context)>,<android.webkit.CookieSyncManager: CookieSyncManager createInstance(Context)>,0,"{
    if (sRef == null) {
        sRef = new CookieSyncManager(context);
    }
    return sRef;
}","{
    if (sRef == null) {
        sRef = new CookieSyncManager(context.getApplicationContext());
    }
    return sRef;
}",1,"/**
 * Create a singleton CookieSyncManager within a context
 * @param context
 * @return CookieSyncManager
 */
","/**
 * Create a singleton CookieSyncManager within a context
 * @param context
 * @return CookieSyncManager
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The implementation of the method changes in how it creates a new instance of CookieSyncManager. In the early version, context is passed directly to create a new instance; however, in the late version, getApplicationContext() is called on the context before passing it to create a new instance. So the dependent API createInstance changed here.","There are changes in the return statement and dependent API. As the instances created in the two versions are not exactly the same due to the changes of the context, it will potentially cause the API to return a different value. The Compatibility Issue is due to potential different return values."
413,"<android.webkit.WebView: void postUrl(String,byte[])>",7,8,"<android.webkit.WebView: void postUrl(String,byte[])>","<android.webkit.WebView: void postUrl(String,byte[])>",0,"{
    if (URLUtil.isNetworkUrl(url)) {
        switchOutDrawHistory();
        WebViewCore.PostUrlData arg = new WebViewCore.PostUrlData();
        arg.mUrl = url;
        arg.mPostData = postData;
        mWebViewCore.sendMessage(EventHub.POST_URL, arg);
        clearTextEntry();
    } else {
        loadUrl(url);
    }
}","{
    if (URLUtil.isNetworkUrl(url)) {
        switchOutDrawHistory();
        WebViewCore.PostUrlData arg = new WebViewCore.PostUrlData();
        arg.mUrl = url;
        arg.mPostData = postData;
        mWebViewCore.sendMessage(EventHub.POST_URL, arg);
        clearTextEntry(false);
    } else {
        loadUrl(url);
    }
}",1,"/**
 * Load the url with postData using ""POST"" method into the WebView. If url
 * is not a network url, it will be loaded with {link
 * {@link #loadUrl(String)} instead.
 *
 * @param url The url of the resource to load.
 * @param postData The data will be passed to ""POST"" request.
 */
","/**
 * Load the url with postData using ""POST"" method into the WebView. If url
 * is not a network url, it will be loaded with {link
 * {@link #loadUrl(String)} instead.
 *
 * @param url The url of the resource to load.
 * @param postData The data will be passed to ""POST"" request.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The parameter of 'clearTextEntry()' function has changed, so the code change type is 4.","Even though the 'clearTextEntry()' function has been changed, this does not lead to potential different return types or values, or different exceptions. Therefore, there are no compatibility issues, and the CI type is 0."
414,<android.accounts.AccountManager: String getPassword(Account)>,7,8,<android.accounts.AccountManager: String getPassword(Account)>,<android.accounts.AccountManager: String getPassword(Account)>,0,"{
    try {
        return mService.getPassword(account);
    } catch (RemoteException e) {
        // will never happen
        throw new RuntimeException(e);
    }
}","{
    if (account == null)
        throw new IllegalArgumentException(""account is null"");
    try {
        return mService.getPassword(account);
    } catch (RemoteException e) {
        // will never happen
        throw new RuntimeException(e);
    }
}",1,"/**
 * Get the password that is associated with the account. Returns null if the account does
 * not exist.
 * <p>
 * Requires that the caller has permission
 * {@link android.Manifest.permission#AUTHENTICATE_ACCOUNTS} and is running
 * with the same UID as the Authenticator for the account.
 */
","/**
 * Gets the saved password associated with the account.
 * This is intended for authenticators and related code; applications
 * should get an auth token instead.
 *
 * <p>It is safe to call this method from the main thread.
 *
 * <p>This method requires the caller to hold the permission
 * {@link android.Manifest.permission#AUTHENTICATE_ACCOUNTS}
 * and to have the same UID as the account's authenticator.
 *
 * @param account The account to query for a password
 * @return The account's password, null if none or if the account doesn't exist
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,2","1,2","An IllegalArgumentException has been introduced in the updated version when the account value is null. Thus, the change type is 3 for control dependency change where new control block was added and 2 for exception handling statement changed.","This change could potentially cause the API to return an exception if the account is null in the updated version which was not the case in the original version. This introduces a new potential return type of IllegalArgumentException. Thus, the CI type is 1 caused by potential different return values or types and 2 caused by potential different exception handlings."
415,<android.accounts.AccountManager: void clearPassword(Account)>,7,8,<android.accounts.AccountManager: void clearPassword(Account)>,<android.accounts.AccountManager: void clearPassword(Account)>,0,"{
    if (account == null) {
        Log.e(TAG, ""the account must not be null"");
        return;
    }
    try {
        mService.clearPassword(account);
    } catch (RemoteException e) {
        // won't ever happen
        throw new RuntimeException(e);
    }
}","{
    if (account == null)
        throw new IllegalArgumentException(""account is null"");
    try {
        mService.clearPassword(account);
    } catch (RemoteException e) {
        // won't ever happen
        throw new RuntimeException(e);
    }
}",1,"/**
 * Sets the password for account to null. If the account does not exist then this call
 * has no effect.
 * <p>
 * Requires that the caller has permission {@link android.Manifest.permission#MANAGE_ACCOUNTS}.
 * @param account the account whose password is to be cleared. Must not be null.
 */
","/**
 * Forgets a saved password.  This erases the local copy of the password;
 * it does not change the user's account password on the server.
 * Has the same effect as setPassword(account, null) but requires fewer
 * permissions, and may be used by applications or management interfaces
 * to ""sign out"" from an account.
 *
 * <p>It is safe to call this method from the main thread.
 *
 * <p>This method requires the caller to hold the permission
 * {@link android.Manifest.permission#MANAGE_ACCOUNTS}
 *
 * @param account The account whose password to clear
 */
",-1,,,-1,-1,-1,-1,-1,-1,2,2,The change is the replacement of a Log error message and a return statement with a throw new IllegalArgumentException() for null account check in the beginning.,"The late version throws IllegalArgumentException for null accounts, meaning the exception handling has changed, causing a potential compatibility issue."
416,<android.pim.vcard.VCardUtils: boolean containsOnlyPrintableAscii(String)>,7,8,<android.pim.vcard.VCardUtils: boolean containsOnlyPrintableAscii(String)>,<android.pim.vcard.VCardUtils: boolean containsOnlyPrintableAscii(String)>,0,"{
    if (TextUtils.isEmpty(str)) {
        return true;
    }
    final int length = str.length();
    final int asciiFirst = 0x20;
    final int asciiLast = 0x126;
    for (int i = 0; i < length; i = str.offsetByCodePoints(i, 1)) {
        int c = str.codePointAt(i);
        if (c < asciiFirst || asciiLast < c) {
            return false;
        }
    }
    return true;
}","{
    if (values == null) {
        return true;
    }
    return containsOnlyPrintableAscii(Arrays.asList(values));
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"1,3,4",1,"The entire body of the method has been changed. The early version checks whether the given string contains only printable ASCII characters and the late version checks whether the specified values are printable ASCII characters. This includes changes in return statements (different conditions for 'return true'), control dependency (loop in the early version was replaced with a method call in late version), and other statements (use of Arrays.asList and different method call), so the change falls under categories 1, 3, and 4.","Due to the change, the function returns true in much different conditions in the late implementation than the early one. Therefore, the compatibility issue type is 1, as this change may cause the function to return different results when applied to the same string."
417,<android.widget.ExpandableListConnector: int getViewTypeCount()>,7,8,<android.widget.ExpandableListConnector: int getViewTypeCount()>,<android.widget.ExpandableListConnector: int getViewTypeCount()>,0,"{
    return 2;
}","{
    if (mExpandableListAdapter instanceof HeterogeneousExpandableList) {
        HeterogeneousExpandableList adapter = (HeterogeneousExpandableList) mExpandableListAdapter;
        return adapter.getGroupTypeCount() + adapter.getChildTypeCount();
    } else {
        return 2;
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,3",1,"In the late version implementation, a new condition statement is added and the return statement ""return 2;"" has been moved into the else clause. It also includes a new return statement ""return adapter.getGroupTypeCount() + adapter.getChildTypeCount();"". So the change type is 1,3.","Since the return statement has changed and it might potentially return a different value based on the newly added condition, the CI type is 1."
420,"<android.provider.Browser: void addSearchUrl(ContentResolver,String)>",7,8,"<android.provider.Browser: void addSearchUrl(ContentResolver,String)>","<android.provider.Browser: void addSearchUrl(ContentResolver,String)>",0,"{
    long now = new Date().getTime();
    try {
        Cursor c = cr.query(SEARCHES_URI, SEARCHES_PROJECTION, SEARCHES_WHERE_CLAUSE, new String[] { search }, null);
        ContentValues map = new ContentValues();
        map.put(SearchColumns.SEARCH, search);
        map.put(SearchColumns.DATE, now);
        /* We should only get one answer that is exactly the same. */
        if (c.moveToFirst()) {
            cr.update(SEARCHES_URI, map, ""_id = "" + c.getInt(0), null);
        } else {
            cr.insert(SEARCHES_URI, map);
        }
        c.deactivate();
    } catch (IllegalStateException e) {
        Log.e(LOGTAG, ""addSearchUrl"", e);
        return;
    }
}","{
    long now = new Date().getTime();
    Cursor c = null;
    try {
        c = cr.query(SEARCHES_URI, SEARCHES_PROJECTION, SEARCHES_WHERE_CLAUSE, new String[] { search }, null);
        ContentValues map = new ContentValues();
        map.put(SearchColumns.SEARCH, search);
        map.put(SearchColumns.DATE, now);
        /* We should only get one answer that is exactly the same. */
        if (c.moveToFirst()) {
            cr.update(SEARCHES_URI, map, ""_id = "" + c.getInt(0), null);
        } else {
            cr.insert(SEARCHES_URI, map);
        }
    } catch (IllegalStateException e) {
        Log.e(LOGTAG, ""addSearchUrl"", e);
    } finally {
        if (c != null)
            c.close();
    }
}",1,"/**
 * Add a search string to the searches database.
 * Requires {@link android.Manifest.permission#READ_HISTORY_BOOKMARKS}
 * Requires {@link android.Manifest.permission#WRITE_HISTORY_BOOKMARKS}
 * @param cr   The ContentResolver used to access the database.
 * @param search    The string to add to the searches database.
 */
","/**
 * Add a search string to the searches database.
 * Requires {@link android.Manifest.permission#READ_HISTORY_BOOKMARKS}
 * Requires {@link android.Manifest.permission#WRITE_HISTORY_BOOKMARKS}
 * @param cr   The ContentResolver used to access the database.
 * @param search    The string to add to the searches database.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",0,"The declaration of the Cursor variable 'c' has been moved outside the try-catch block, and a finally block has been added to close the 'c' Cursor if it's not null. These changes relate to control dependencies and variable assignment, placing them in the code change categories 3 and 4.","Despite these changes, none of them should result in potential difference in return values/types or exception handling as far as client-facing behavior is concerned. Therefore, no Compatibility Issues should exist between these versions."
422,"<android.widget.AbsSeekBar: boolean onKeyDown(int,KeyEvent)>",7,8,"<android.widget.AbsSeekBar: boolean onKeyDown(int,KeyEvent)>","<android.widget.AbsSeekBar: boolean onKeyDown(int,KeyEvent)>",0,"{
    int progress = getProgress();
    switch(keyCode) {
        case KeyEvent.KEYCODE_DPAD_LEFT:
            if (progress <= 0)
                break;
            setProgress(progress - mKeyProgressIncrement, true);
            onKeyChange();
            return true;
        case KeyEvent.KEYCODE_DPAD_RIGHT:
            if (progress >= getMax())
                break;
            setProgress(progress + mKeyProgressIncrement, true);
            onKeyChange();
            return true;
    }
    return super.onKeyDown(keyCode, event);
}","{
    if (isEnabled()) {
        int progress = getProgress();
        switch(keyCode) {
            case KeyEvent.KEYCODE_DPAD_LEFT:
                if (progress <= 0)
                    break;
                setProgress(progress - mKeyProgressIncrement, true);
                onKeyChange();
                return true;
            case KeyEvent.KEYCODE_DPAD_RIGHT:
                if (progress >= getMax())
                    break;
                setProgress(progress + mKeyProgressIncrement, true);
                onKeyChange();
                return true;
        }
    }
    return super.onKeyDown(keyCode, event);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,3,1,"The change is the introduction of a new 'if' control statement at the start of the method, so the code change type is 3.","The new 'if' statement changes the original flow of the method. Depending whether it is enabled or not, it may not execute the key events as it used to and return a different value, so the CI type is 1."
423,"<android.widget.ListView: boolean performItemClick(View,int,long)>",7,8,"<android.widget.ListView: boolean performItemClick(View,int,long)>","<android.widget.ListView: boolean performItemClick(View,int,long)>",0,"{
    boolean handled = false;
    if (mChoiceMode != CHOICE_MODE_NONE) {
        handled = true;
        if (mChoiceMode == CHOICE_MODE_MULTIPLE) {
            boolean oldValue = mCheckStates.get(position, false);
            mCheckStates.put(position, !oldValue);
        } else {
            boolean oldValue = mCheckStates.get(position, false);
            if (!oldValue) {
                mCheckStates.clear();
                mCheckStates.put(position, true);
            }
        }
        mDataChanged = true;
        rememberSyncState();
        requestLayout();
    }
    handled |= super.performItemClick(view, position, id);
    return handled;
}","{
    boolean handled = false;
    if (mChoiceMode != CHOICE_MODE_NONE) {
        handled = true;
        if (mChoiceMode == CHOICE_MODE_MULTIPLE) {
            boolean newValue = !mCheckStates.get(position, false);
            mCheckStates.put(position, newValue);
            if (mCheckedIdStates != null && mAdapter.hasStableIds()) {
                if (newValue) {
                    mCheckedIdStates.put(mAdapter.getItemId(position), Boolean.TRUE);
                } else {
                    mCheckedIdStates.delete(mAdapter.getItemId(position));
                }
            }
        } else {
            boolean newValue = !mCheckStates.get(position, false);
            if (newValue) {
                mCheckStates.clear();
                mCheckStates.put(position, true);
                if (mCheckedIdStates != null && mAdapter.hasStableIds()) {
                    mCheckedIdStates.clear();
                    mCheckedIdStates.put(mAdapter.getItemId(position), Boolean.TRUE);
                }
            }
        }
        mDataChanged = true;
        rememberSyncState();
        requestLayout();
    }
    handled |= super.performItemClick(view, position, id);
    return handled;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"4,5",1,"The assignment statement and method invocation has been modified within ""if"" block for updating ""mCheckStates"" and ""mCheckedIdStates"". Clear and delete methods are also introduced in 'if' statement in late version where 'mAdapter.getItemId()' function is now being used. So, the change types are 4,5.","The introduction of 'mCheckedIdStates.clear()' and 'mCheckedIdStates.delete()' as well as the different way of updating 'mCheckStates' and 'mCheckedIdStates' values in the late version may change the return value of 'handled' variable, so the CI type is 1."
424,"<android.content.res.Configuration: void writeToParcel(Parcel,int)>",7,8,"<android.content.res.Configuration: void writeToParcel(Parcel,int)>","<android.content.res.Configuration: void writeToParcel(Parcel,int)>",0,"{
    dest.writeFloat(fontScale);
    dest.writeInt(mcc);
    dest.writeInt(mnc);
    if (locale == null) {
        dest.writeInt(0);
    } else {
        dest.writeInt(1);
        dest.writeString(locale.getLanguage());
        dest.writeString(locale.getCountry());
        dest.writeString(locale.getVariant());
    }
    if (userSetLocale) {
        dest.writeInt(1);
    } else {
        dest.writeInt(0);
    }
    dest.writeInt(touchscreen);
    dest.writeInt(keyboard);
    dest.writeInt(keyboardHidden);
    dest.writeInt(hardKeyboardHidden);
    dest.writeInt(navigation);
    dest.writeInt(navigationHidden);
    dest.writeInt(orientation);
    dest.writeInt(screenLayout);
}","{
    dest.writeFloat(fontScale);
    dest.writeInt(mcc);
    dest.writeInt(mnc);
    if (locale == null) {
        dest.writeInt(0);
    } else {
        dest.writeInt(1);
        dest.writeString(locale.getLanguage());
        dest.writeString(locale.getCountry());
        dest.writeString(locale.getVariant());
    }
    if (userSetLocale) {
        dest.writeInt(1);
    } else {
        dest.writeInt(0);
    }
    dest.writeInt(touchscreen);
    dest.writeInt(keyboard);
    dest.writeInt(keyboardHidden);
    dest.writeInt(hardKeyboardHidden);
    dest.writeInt(navigation);
    dest.writeInt(navigationHidden);
    dest.writeInt(orientation);
    dest.writeInt(screenLayout);
    dest.writeInt(uiMode);
    dest.writeInt(seq);
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,4,1,"Two new statements, dest.writeInt(uiMode) and dest.writeInt(seq) have been added in the Late_Implementation and no other change were observed. Therefore the type of change is classified as 4 (Other statement changed).","The newly added statements change the content written into the Parcel object which can lead to different return values in the Late_Version when retrieved, therefore, the CI type is 1 (Compatibility Issue caused by potential different return values)."
425,<android.content.pm.PackageParser.Instrumentation: String toString()>,7,8,<android.content.pm.PackageParser.Instrumentation: String toString()>,<android.content.pm.PackageParser.Instrumentation: String toString()>,0,"{
    return ""Instrumentation{"" + Integer.toHexString(System.identityHashCode(this)) + "" "" + component.flattenToString() + ""}"";
}","{
    return ""Instrumentation{"" + Integer.toHexString(System.identityHashCode(this)) + "" "" + getComponentShortName() + ""}"";
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The return statement has changed from ""component.flattenToString()"" to ""getComponentShortName()"", which represents the type 1 and 5 code change.","Due to the change in the return statement,this could potentially yield a different result, thus leading to Compatibility Issue of type 1."
427,<android.hardware.Camera.EventHandler: void handleMessage(Message)>,7,8,<android.hardware.Camera.EventHandler: void handleMessage(Message)>,<android.hardware.Camera.EventHandler: void handleMessage(Message)>,0,"{
    switch(msg.what) {
        case CAMERA_MSG_SHUTTER:
            if (mShutterCallback != null) {
                mShutterCallback.onShutter();
            }
            return;
        case CAMERA_MSG_RAW_IMAGE:
            if (mRawImageCallback != null) {
                mRawImageCallback.onPictureTaken((byte[]) msg.obj, mCamera);
            }
            return;
        case CAMERA_MSG_COMPRESSED_IMAGE:
            if (mJpegCallback != null) {
                mJpegCallback.onPictureTaken((byte[]) msg.obj, mCamera);
            }
            return;
        case CAMERA_MSG_PREVIEW_FRAME:
            if (mPreviewCallback != null) {
                PreviewCallback cb = mPreviewCallback;
                if (mOneShot) {
                    // Clear the callback variable before the callback
                    // in case the app calls setPreviewCallback from
                    // the callback function
                    mPreviewCallback = null;
                } else if (!mWithBuffer) {
                    // We're faking the camera preview mode to prevent
                    // the app from being flooded with preview frames.
                    // Set to oneshot mode again.
                    setHasPreviewCallback(true, false);
                }
                cb.onPreviewFrame((byte[]) msg.obj, mCamera);
            }
            return;
        case CAMERA_MSG_POSTVIEW_FRAME:
            if (mPostviewCallback != null) {
                mPostviewCallback.onPictureTaken((byte[]) msg.obj, mCamera);
            }
            return;
        case CAMERA_MSG_FOCUS:
            if (mAutoFocusCallback != null) {
                mAutoFocusCallback.onAutoFocus(msg.arg1 == 0 ? false : true, mCamera);
            }
            return;
        case CAMERA_MSG_ZOOM:
            if (mZoomCallback != null) {
                mZoomCallback.onZoomUpdate(msg.arg1, msg.arg2 != 0, mCamera);
            }
            return;
        case CAMERA_MSG_ERROR:
            Log.e(TAG, ""Error "" + msg.arg1);
            if (mErrorCallback != null) {
                mErrorCallback.onError(msg.arg1, mCamera);
            }
            return;
        default:
            Log.e(TAG, ""Unknown message type "" + msg.what);
            return;
    }
}","{
    switch(msg.what) {
        case CAMERA_MSG_SHUTTER:
            if (mShutterCallback != null) {
                mShutterCallback.onShutter();
            }
            return;
        case CAMERA_MSG_RAW_IMAGE:
            if (mRawImageCallback != null) {
                mRawImageCallback.onPictureTaken((byte[]) msg.obj, mCamera);
            }
            return;
        case CAMERA_MSG_COMPRESSED_IMAGE:
            if (mJpegCallback != null) {
                mJpegCallback.onPictureTaken((byte[]) msg.obj, mCamera);
            }
            return;
        case CAMERA_MSG_PREVIEW_FRAME:
            if (mPreviewCallback != null) {
                PreviewCallback cb = mPreviewCallback;
                if (mOneShot) {
                    // Clear the callback variable before the callback
                    // in case the app calls setPreviewCallback from
                    // the callback function
                    mPreviewCallback = null;
                } else if (!mWithBuffer) {
                    // We're faking the camera preview mode to prevent
                    // the app from being flooded with preview frames.
                    // Set to oneshot mode again.
                    setHasPreviewCallback(true, false);
                }
                cb.onPreviewFrame((byte[]) msg.obj, mCamera);
            }
            return;
        case CAMERA_MSG_POSTVIEW_FRAME:
            if (mPostviewCallback != null) {
                mPostviewCallback.onPictureTaken((byte[]) msg.obj, mCamera);
            }
            return;
        case CAMERA_MSG_FOCUS:
            if (mAutoFocusCallback != null) {
                mAutoFocusCallback.onAutoFocus(msg.arg1 == 0 ? false : true, mCamera);
            }
            return;
        case CAMERA_MSG_ZOOM:
            if (mZoomListener != null) {
                mZoomListener.onZoomChange(msg.arg1, msg.arg2 != 0, mCamera);
            }
            return;
        case CAMERA_MSG_ERROR:
            Log.e(TAG, ""Error "" + msg.arg1);
            if (mErrorCallback != null) {
                mErrorCallback.onError(msg.arg1, mCamera);
            }
            return;
        default:
            Log.e(TAG, ""Unknown message type "" + msg.what);
            return;
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"4,5",1,"In the case CAMERA_MSG_ZOOM, the callback variable changed from ""mZoomCallback"" to ""mZoomListener"", and the method called changed from ""onZoomUpdate"" to ""onZoomChange"", thus, the code change type is 4,5.","As the callback behaviour (from ""onZoomUpdate"" to ""onZoomChange"") is altered in the late version, the method may behave differently when the message's type is CAMERA_MSG_ZOOM, hence, the Compatibility Issue type is 1."
428,<android.content.ContentValues: Byte getAsByte(String)>,7,8,<android.content.ContentValues: Byte getAsByte(String)>,<android.content.ContentValues: Byte getAsByte(String)>,0,"{
    Object value = mValues.get(key);
    try {
        return value != null ? ((Number) value).byteValue() : null;
    } catch (ClassCastException e) {
        if (value instanceof CharSequence) {
            try {
                return Byte.valueOf(value.toString());
            } catch (NumberFormatException e2) {
                Log.e(TAG, ""Cannot parse Byte value for "" + value + "" at key "" + key);
                return null;
            }
        } else {
            Log.e(TAG, ""Cannot cast value for "" + key + "" to a Byte"");
            return null;
        }
    }
}","{
    Object value = mValues.get(key);
    try {
        return value != null ? ((Number) value).byteValue() : null;
    } catch (ClassCastException e) {
        if (value instanceof CharSequence) {
            try {
                return Byte.valueOf(value.toString());
            } catch (NumberFormatException e2) {
                Log.e(TAG, ""Cannot parse Byte value for "" + value + "" at key "" + key);
                return null;
            }
        } else {
            Log.e(TAG, ""Cannot cast value for "" + key + "" to a Byte: "" + value, e);
            return null;
        }
    }
}",1,"/**
 * Gets a value and converts it to a Byte.
 *
 * @param key the value to get
 * @return the Byte value, or null if the value is missing or cannot be converted
 */
","/**
 * Gets a value and converts it to a Byte.
 *
 * @param key the value to get
 * @return the Byte value, or null if the value is missing or cannot be converted
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"An error log message is changed to include more detailed information about the exception. This type of change falls under ""other statement changed"" category, so the code change type is 4.","This change only affects the debug log. It does not change the behavior of the program or affect API compatibility. Therefore, no compatibility issue exists here, thus the CI type is 0."
429,<android.webkit.WebViewDatabase: WebViewDatabase getInstance(Context)>,7,8,<android.webkit.WebViewDatabase: WebViewDatabase getInstance(Context)>,<android.webkit.WebViewDatabase: WebViewDatabase getInstance(Context)>,0,"{
    if (mInstance == null) {
        mInstance = new WebViewDatabase();
        mDatabase = context.openOrCreateDatabase(DATABASE_FILE, 0, null);
        // the only case is RequestAPI test has problem to create db
        if (mDatabase != null && mDatabase.getVersion() != DATABASE_VERSION) {
            mDatabase.beginTransaction();
            try {
                upgradeDatabase();
                mDatabase.setTransactionSuccessful();
            } finally {
                mDatabase.endTransaction();
            }
        }
        if (mDatabase != null) {
            // use per table Mutex lock, turn off database lock, this
            // improves performance as database's ReentrantLock is expansive
            mDatabase.setLockingEnabled(false);
        }
        mCacheDatabase = context.openOrCreateDatabase(CACHE_DATABASE_FILE, 0, null);
        // the only case is RequestAPI test has problem to create db
        if (mCacheDatabase != null && mCacheDatabase.getVersion() != CACHE_DATABASE_VERSION) {
            mCacheDatabase.beginTransaction();
            try {
                upgradeCacheDatabase();
                bootstrapCacheDatabase();
                mCacheDatabase.setTransactionSuccessful();
            } finally {
                mCacheDatabase.endTransaction();
            }
            // Erase the files from the file system in the
            // case that the database was updated and the
            // there were existing cache content
            CacheManager.removeAllCacheFiles();
        }
        if (mCacheDatabase != null) {
            // use InsertHelper for faster insertion
            mCacheInserter = new DatabaseUtils.InsertHelper(mCacheDatabase, ""cache"");
            mCacheUrlColIndex = mCacheInserter.getColumnIndex(CACHE_URL_COL);
            mCacheFilePathColIndex = mCacheInserter.getColumnIndex(CACHE_FILE_PATH_COL);
            mCacheLastModifyColIndex = mCacheInserter.getColumnIndex(CACHE_LAST_MODIFY_COL);
            mCacheETagColIndex = mCacheInserter.getColumnIndex(CACHE_ETAG_COL);
            mCacheExpiresColIndex = mCacheInserter.getColumnIndex(CACHE_EXPIRES_COL);
            mCacheExpiresStringColIndex = mCacheInserter.getColumnIndex(CACHE_EXPIRES_STRING_COL);
            mCacheMimeTypeColIndex = mCacheInserter.getColumnIndex(CACHE_MIMETYPE_COL);
            mCacheEncodingColIndex = mCacheInserter.getColumnIndex(CACHE_ENCODING_COL);
            mCacheHttpStatusColIndex = mCacheInserter.getColumnIndex(CACHE_HTTP_STATUS_COL);
            mCacheLocationColIndex = mCacheInserter.getColumnIndex(CACHE_LOCATION_COL);
            mCacheContentLengthColIndex = mCacheInserter.getColumnIndex(CACHE_CONTENTLENGTH_COL);
            mCacheContentDispositionColIndex = mCacheInserter.getColumnIndex(CACHE_CONTENTDISPOSITION_COL);
        }
    }
    return mInstance;
}","{
    if (mInstance == null) {
        mInstance = new WebViewDatabase();
        try {
            mDatabase = context.openOrCreateDatabase(DATABASE_FILE, 0, null);
        } catch (SQLiteException e) {
            // try again by deleting the old db and create a new one
            if (context.deleteDatabase(DATABASE_FILE)) {
                mDatabase = context.openOrCreateDatabase(DATABASE_FILE, 0, null);
            }
        }
        // the only case is RequestAPI test has problem to create db
        if (mDatabase != null && mDatabase.getVersion() != DATABASE_VERSION) {
            mDatabase.beginTransaction();
            try {
                upgradeDatabase();
                mDatabase.setTransactionSuccessful();
            } finally {
                mDatabase.endTransaction();
            }
        }
        if (mDatabase != null) {
            // use per table Mutex lock, turn off database lock, this
            // improves performance as database's ReentrantLock is expansive
            mDatabase.setLockingEnabled(false);
        }
        try {
            mCacheDatabase = context.openOrCreateDatabase(CACHE_DATABASE_FILE, 0, null);
        } catch (SQLiteException e) {
            // try again by deleting the old db and create a new one
            if (context.deleteDatabase(CACHE_DATABASE_FILE)) {
                mCacheDatabase = context.openOrCreateDatabase(CACHE_DATABASE_FILE, 0, null);
            }
        }
        // the only case is RequestAPI test has problem to create db
        if (mCacheDatabase != null && mCacheDatabase.getVersion() != CACHE_DATABASE_VERSION) {
            mCacheDatabase.beginTransaction();
            try {
                upgradeCacheDatabase();
                bootstrapCacheDatabase();
                mCacheDatabase.setTransactionSuccessful();
            } finally {
                mCacheDatabase.endTransaction();
            }
            // Erase the files from the file system in the
            // case that the database was updated and the
            // there were existing cache content
            CacheManager.removeAllCacheFiles();
        }
        if (mCacheDatabase != null) {
            // use read_uncommitted to speed up READ
            mCacheDatabase.execSQL(""PRAGMA read_uncommitted = true;"");
            // as only READ can be called in the non-WebViewWorkerThread,
            // and read_uncommitted is used, we can turn off database lock
            // to use transaction.
            mCacheDatabase.setLockingEnabled(false);
            // use InsertHelper for faster insertion
            mCacheInserter = new DatabaseUtils.InsertHelper(mCacheDatabase, ""cache"");
            mCacheUrlColIndex = mCacheInserter.getColumnIndex(CACHE_URL_COL);
            mCacheFilePathColIndex = mCacheInserter.getColumnIndex(CACHE_FILE_PATH_COL);
            mCacheLastModifyColIndex = mCacheInserter.getColumnIndex(CACHE_LAST_MODIFY_COL);
            mCacheETagColIndex = mCacheInserter.getColumnIndex(CACHE_ETAG_COL);
            mCacheExpiresColIndex = mCacheInserter.getColumnIndex(CACHE_EXPIRES_COL);
            mCacheExpiresStringColIndex = mCacheInserter.getColumnIndex(CACHE_EXPIRES_STRING_COL);
            mCacheMimeTypeColIndex = mCacheInserter.getColumnIndex(CACHE_MIMETYPE_COL);
            mCacheEncodingColIndex = mCacheInserter.getColumnIndex(CACHE_ENCODING_COL);
            mCacheHttpStatusColIndex = mCacheInserter.getColumnIndex(CACHE_HTTP_STATUS_COL);
            mCacheLocationColIndex = mCacheInserter.getColumnIndex(CACHE_LOCATION_COL);
            mCacheContentLengthColIndex = mCacheInserter.getColumnIndex(CACHE_CONTENTLENGTH_COL);
            mCacheContentDispositionColIndex = mCacheInserter.getColumnIndex(CACHE_CONTENTDISPOSITION_COL);
            mCacheCrossDomainColIndex = mCacheInserter.getColumnIndex(CACHE_CROSSDOMAIN_COL);
        }
    }
    return mInstance;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"2,3,4","1,2","New exception handling has been introduced to both `mDatabase` and `mCacheDatabase` instantiation with a new control statement 'try-catch'. Besides, several other lines of code are introduced to modify the 'mCacheDatabase' object and 'mCacheDatabase' related variables, so the code change type is 2,3,4.","The new exception handling could lead to different exception thrown, which may cause a compatibility issue. Meanwhile, due to the changes of multiple statements and condition checks, the result returned by the method may also be affected which can lead to different return behavior. Therefore, the CI type is 1,2."
430,<android.gesture.GestureStroke: OrientedBoundingBox computeOrientedBoundingBox()>,7,8,<android.gesture.GestureStroke: OrientedBoundingBox computeOrientedBoundingBox()>,<android.gesture.GestureStroke: OrientedBoundingBox computeOrientedBoundingBox()>,0,"{
    return GestureUtilities.computeOrientedBoundingBox(points);
}","{
    return GestureUtils.computeOrientedBoundingBox(points);
}",1,"/**
 * Compute an oriented bounding box of the stroke
 * @return OrientedBoundingBox
 */
","/**
 * Computes an oriented bounding box of the stroke.
 *
 * @return OrientedBoundingBox
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The return statement has changed from GestureUtilities.computeOrientedBoundingBox(points) to GestureUtils.computeOrientedBoundingBox(points) and the dependent API has been changed from GestureUtilities to GestureUtils, so the code change type is 1,5.","This change of return statement will make the API potentially return a different value, so the CI type is 1."
431,<android.webkit.WebView: void invokeZoomPicker()>,7,8,<android.webkit.WebView: void invokeZoomPicker()>,<android.webkit.WebView: void invokeZoomPicker()>,0,"{
    if (!getSettings().supportZoom()) {
        Log.w(LOGTAG, ""This WebView doesn't support zoom."");
        return;
    }
    clearTextEntry();
    if (getSettings().getBuiltInZoomControls()) {
        mZoomButtonsController.setVisible(true);
    } else {
        mPrivateHandler.removeCallbacks(mZoomControlRunnable);
        mPrivateHandler.postDelayed(mZoomControlRunnable, ZOOM_CONTROLS_TIMEOUT);
    }
}","{
    if (!getSettings().supportZoom()) {
        Log.w(LOGTAG, ""This WebView doesn't support zoom."");
        return;
    }
    clearTextEntry(false);
    if (getSettings().getBuiltInZoomControls()) {
        getZoomButtonsController().setVisible(true);
    } else {
        mPrivateHandler.removeCallbacks(mZoomControlRunnable);
        mPrivateHandler.postDelayed(mZoomControlRunnable, ZOOM_CONTROLS_TIMEOUT);
    }
}",1,"/**
 * Invoke the graphical zoom picker widget for this WebView. This will
 * result in the zoom widget appearing on the screen to control the zoom
 * level of this WebView.
 */
","/**
 * Invoke the graphical zoom picker widget for this WebView. This will
 * result in the zoom widget appearing on the screen to control the zoom
 * level of this WebView.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,4,5",1,"The methods clearTextEntry() and mZoomButtonsController.setVisible(true) were changed to clearTextEntry(false) and getZoomButtonsController().setVisible(true), respectively. In addition, the method signature of clearTextEntry() has changed. Thus, the code change falls under categories 1 (Return statement changed), 4 (Other statement changed), and 5 (Dependent API changed).","Due to the change in method implementation, namely clearTextEntry() and mZoomButtonsController.setVisible(true), the behavior of the API, WebView:invokeZoomPicker(), may have changed. Thus, this could potentially leads to Compatibility Issue by returning different values. Therefore, the CI type is 1."
432,<android.widget.HeaderViewListAdapter: long getItemId(int)>,7,8,<android.widget.HeaderViewListAdapter: long getItemId(int)>,<android.widget.HeaderViewListAdapter: long getItemId(int)>,0,"{
    int numHeaders = getHeadersCount();
    if (mAdapter != null && position >= numHeaders) {
        int adjPosition = position - numHeaders;
        int adapterCnt = mAdapter.getCount();
        if (adjPosition < adapterCnt) {
            return mAdapter.getItemId(adjPosition);
        }
    }
    return -1;
}","{
    int numHeaders = getHeadersCount();
    if (mAdapter != null && position >= numHeaders) {
        int adjPosition = position - numHeaders;
        int adapterCount = mAdapter.getCount();
        if (adjPosition < adapterCount) {
            return mAdapter.getItemId(adjPosition);
        }
    }
    return -1;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,0,0,"No actual change has been made between the two versions; only the name of the variable ""adapterCnt"" in the early version has been modified to ""adapterCount"" in the late version, without altering the behavior of the method.","As there are no substantial modifications between the two versions, no compatibility issue exists."
434,<android.os.PowerManager.WakeLock: void finalize()>,7,8,<android.os.PowerManager.WakeLock: void finalize()>,<android.os.PowerManager.WakeLock: void finalize()>,0,"{
    synchronized (mToken) {
        if (mHeld) {
            try {
                mService.releaseWakeLock(mToken, 0);
            } catch (RemoteException e) {
            }
            RuntimeInit.crash(TAG, new Exception(""WakeLock finalized while still held: "" + mTag));
        }
    }
}","{
    synchronized (mToken) {
        if (mHeld) {
            Log.wtf(TAG, ""WakeLock finalized while still held: "" + mTag);
            try {
                mService.releaseWakeLock(mToken, 0);
            } catch (RemoteException e) {
            }
        }
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,2,"Some log statement and exception throwing statement has been changed, so the change type is 4.","The throwing of the exception depends on the condition 'if (mHeld)'. Now that condition remains the same, however, the exception ""new Exception"" was thrown before, and the 'Log.wtf' just writes the log without throwing the exception. Even though they have a similar result, the mechanism (fatal error) is different. Thus the type is 2."
435,<android.webkit.DataLoader: boolean setupStreamAndSendStatus()>,7,8,<android.webkit.DataLoader: boolean setupStreamAndSendStatus()>,<android.webkit.DataLoader: boolean setupStreamAndSendStatus()>,0,"{
    mHandler.status(1, 1, 0, ""OK"");
    return true;
}","{
    if (mDataStream != null) {
        mLoadListener.status(1, 1, 200, ""OK"");
        return true;
    } else {
        mLoadListener.error(EventHandler.ERROR, mContext.getString(R.string.httpError));
        return false;
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,3","1,2","In the early version, the function always returns true; however, in the late version, the function contains a condition (if dataStream is not null) and has the potential to return false. Therefore, a new if-control statement is introduced and the return statement has changed. This leads to a type of change 1,3.","Since the late version of function introduces a conditional control statement, the return value and the error handling have changed. When the DataStream is null, the function will throw an exception ('mLoadListener.error') and return false. Thus, this leads to compatibility issues 1 and 2."
437,"<android.widget.ExpandableListView: boolean setSelectedChild(int,int,boolean)>",7,8,"<android.widget.ExpandableListView: boolean setSelectedChild(int,int,boolean)>","<android.widget.ExpandableListView: boolean setSelectedChild(int,int,boolean)>",0,"{
    ExpandableListPosition elChildPos = ExpandableListPosition.obtainChildPosition(groupPosition, childPosition);
    PositionMetadata flatChildPos = mConnector.getFlattenedPos(elChildPos);
    if (flatChildPos == null) {
        // Shouldn't expand the group, so return false for we didn't set the selection
        if (!shouldExpandGroup)
            return false;
        expandGroup(groupPosition);
        flatChildPos = mConnector.getFlattenedPos(elChildPos);
        // Sanity check
        if (flatChildPos == null) {
            throw new IllegalStateException(""Could not find child"");
        }
    }
    super.setSelection(flatChildPos.position.flatListPos);
    elChildPos.recycle();
    flatChildPos.recycle();
    return true;
}","{
    ExpandableListPosition elChildPos = ExpandableListPosition.obtainChildPosition(groupPosition, childPosition);
    PositionMetadata flatChildPos = mConnector.getFlattenedPos(elChildPos);
    if (flatChildPos == null) {
        // Shouldn't expand the group, so return false for we didn't set the selection
        if (!shouldExpandGroup)
            return false;
        expandGroup(groupPosition);
        flatChildPos = mConnector.getFlattenedPos(elChildPos);
        // Sanity check
        if (flatChildPos == null) {
            throw new IllegalStateException(""Could not find child"");
        }
    }
    int absoluteFlatPosition = getAbsoluteFlatPosition(flatChildPos.position.flatListPos);
    super.setSelection(absoluteFlatPosition);
    elChildPos.recycle();
    flatChildPos.recycle();
    return true;
}",1,"/**
 * Sets the selection to the specified child. If the child is in a collapsed
 * group, the group will only be expanded and child subsequently selected if
 * shouldExpandGroup is set to true, otherwise the method will return false.
 *
 * @param groupPosition The position of the group that contains the child.
 * @param childPosition The position of the child within the group.
 * @param shouldExpandGroup Whether the child's group should be expanded if
 * it is collapsed.
 * @return Whether the selection was successfully set on the child.
 */
","/**
 * Sets the selection to the specified child. If the child is in a collapsed
 * group, the group will only be expanded and child subsequently selected if
 * shouldExpandGroup is set to true, otherwise the method will return false.
 *
 * @param groupPosition The position of the group that contains the child.
 * @param childPosition The position of the child within the group.
 * @param shouldExpandGroup Whether the child's group should be expanded if
 * it is collapsed.
 * @return Whether the selection was successfully set on the child.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1, 4, 5",1,"The code change category is 1, 4, 5. The value returned from super.setSelection() has been changed to an absolute value calculated by the getAbsoluteFlatPosition(), which can be considered as another return statement. Additionally, the method getAbsoluteFlatPosition() was introduced, which is not present in the early implementation, implying a dependent API has changed.",The Compatibility Issue category is 1. The return statement change (from super.setSelection() to getAbsoluteFlatPosition()) could potentially change the behavior of the API causing it to return a different value which might lead to an inconsistency for applications using this API and can be categorized as a Compatibility Issue.
438,<android.widget.ProgressBar: void startAnimation()>,7,8,<android.widget.ProgressBar: void startAnimation()>,<android.widget.ProgressBar: void startAnimation()>,0,"{
    int visibility = getVisibility();
    if (visibility != VISIBLE) {
        return;
    }
    if (mIndeterminateDrawable instanceof Animatable) {
        mShouldStartAnimationDrawable = true;
        mAnimation = null;
    } else {
        if (mInterpolator == null) {
            mInterpolator = new LinearInterpolator();
        }
        mTransformation = new Transformation();
        mAnimation = new AlphaAnimation(0.0f, 1.0f);
        mAnimation.setRepeatMode(mBehavior);
        mAnimation.setRepeatCount(Animation.INFINITE);
        mAnimation.setDuration(mDuration);
        mAnimation.setInterpolator(mInterpolator);
        mAnimation.setStartTime(Animation.START_ON_FIRST_FRAME);
        postInvalidate();
    }
}","{
    if (getVisibility() != VISIBLE) {
        return;
    }
    if (mIndeterminateDrawable instanceof Animatable) {
        mShouldStartAnimationDrawable = true;
        mAnimation = null;
    } else {
        if (mInterpolator == null) {
            mInterpolator = new LinearInterpolator();
        }
        mTransformation = new Transformation();
        mAnimation = new AlphaAnimation(0.0f, 1.0f);
        mAnimation.setRepeatMode(mBehavior);
        mAnimation.setRepeatCount(Animation.INFINITE);
        mAnimation.setDuration(mDuration);
        mAnimation.setInterpolator(mInterpolator);
        mAnimation.setStartTime(Animation.START_ON_FIRST_FRAME);
        postInvalidate();
    }
}",1,"/**
 * <p>Start the indeterminate progress animation.</p>
 */
","/**
 * <p>Start the indeterminate progress animation.</p>
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The visibility check condition (getVisibility() != VISIBLE) has been moved up to the first line in the late version implementation. Hence, the value of the variable 'visibility' is not stored in the late version as in the early version. So the code change type is 4.","There is no Compatibility Issue here because the change does not affect the function of the API or its potential behavior. Hence, the CI type is 0."
439,"<android.provider.Calendar.CalendarAlerts: long findNextAlarmTime(ContentResolver,long)>",7,8,"<android.provider.Calendar.CalendarAlerts: long findNextAlarmTime(ContentResolver,long)>","<android.provider.Calendar.CalendarAlerts: long findNextAlarmTime(ContentResolver,long)>",0,"{
    String selection = ALARM_TIME + "">="" + millis;
    // TODO: construct an explicit SQL query so that we can add
    // ""LIMIT 1"" to the end and get just one result.
    String[] projection = new String[] { ALARM_TIME };
    Cursor cursor = query(cr, projection, selection, null);
    long alarmTime = -1;
    try {
        if (cursor != null && cursor.moveToFirst()) {
            alarmTime = cursor.getLong(0);
        }
    } finally {
        if (cursor != null) {
            cursor.close();
        }
    }
    return alarmTime;
}","{
    String selection = ALARM_TIME + "">="" + millis;
    // TODO: construct an explicit SQL query so that we can add
    // ""LIMIT 1"" to the end and get just one result.
    String[] projection = new String[] { ALARM_TIME };
    Cursor cursor = query(cr, projection, WHERE_FINDNEXTALARMTIME, new String[] { Long.toString(millis) }, SORT_ORDER_ALARMTIME_ASC);
    long alarmTime = -1;
    try {
        if (cursor != null && cursor.moveToFirst()) {
            alarmTime = cursor.getLong(0);
        }
    } finally {
        if (cursor != null) {
            cursor.close();
        }
    }
    return alarmTime;
}",1,"/**
 * Finds the next alarm after (or equal to) the given time and returns
 * the time of that alarm or -1 if no such alarm exists.
 *
 * @param cr the ContentResolver
 * @param millis the time in UTC milliseconds
 * @return the next alarm time greater than or equal to ""millis"", or -1
 * if no such alarm exists.
 */
","/**
 * Finds the next alarm after (or equal to) the given time and returns
 * the time of that alarm or -1 if no such alarm exists.
 *
 * @param cr the ContentResolver
 * @param millis the time in UTC milliseconds
 * @return the next alarm time greater than or equal to ""millis"", or -1
 * if no such alarm exists.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",1,There's a change in the query method of the cursor object. It no longer uses a null argument but instead uses WHERE_FINDNEXTALARMTIME and a SORT_ORDER_ALARMTIME_ASC constant. This can be classified as both an Other statement change (4) and a Dependent API change (5).,"The change in the query method with the different arguments could potentially cause the query result to be different leading to a different value being returned from this API, which validates this as a Compatibility Issue caused by potential different return values or types (1)."
440,<android.content.ContentValues: Integer getAsInteger(String)>,7,8,<android.content.ContentValues: Integer getAsInteger(String)>,<android.content.ContentValues: Integer getAsInteger(String)>,0,"{
    Object value = mValues.get(key);
    try {
        return value != null ? ((Number) value).intValue() : null;
    } catch (ClassCastException e) {
        if (value instanceof CharSequence) {
            try {
                return Integer.valueOf(value.toString());
            } catch (NumberFormatException e2) {
                Log.e(TAG, ""Cannot parse Integer value for "" + value + "" at key "" + key);
                return null;
            }
        } else {
            Log.e(TAG, ""Cannot cast value for "" + key + "" to a Integer"");
            return null;
        }
    }
}","{
    Object value = mValues.get(key);
    try {
        return value != null ? ((Number) value).intValue() : null;
    } catch (ClassCastException e) {
        if (value instanceof CharSequence) {
            try {
                return Integer.valueOf(value.toString());
            } catch (NumberFormatException e2) {
                Log.e(TAG, ""Cannot parse Integer value for "" + value + "" at key "" + key);
                return null;
            }
        } else {
            Log.e(TAG, ""Cannot cast value for "" + key + "" to a Integer: "" + value, e);
            return null;
        }
    }
}",1,"/**
 * Gets a value and converts it to an Integer.
 *
 * @param key the value to get
 * @return the Integer value, or null if the value is missing or cannot be converted
 */
","/**
 * Gets a value and converts it to an Integer.
 *
 * @param key the value to get
 * @return the Integer value, or null if the value is missing or cannot be converted
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The Log message under the else statement has changed, so the code change type is 4.","The change in logging message will not change the behavior of this function or the values it returns, so no compatibility issue exists (type 0)."
441,<android.pim.vcard.VCardConfig: int getVCardTypeFromString(String)>,7,8,<android.pim.vcard.VCardConfig: int getVCardTypeFromString(String)>,<android.pim.vcard.VCardConfig: int getVCardTypeFromString(String)>,0,"{
    String loweredKey = vcardTypeString.toLowerCase();
    if (VCARD_TYPES_MAP.containsKey(loweredKey)) {
        return VCARD_TYPES_MAP.get(loweredKey);
    } else {
        // XXX: should return the value indicating the input is invalid?
        return VCARD_TYPE_DEFAULT;
    }
}","{
    final String loweredKey = vcardTypeString.toLowerCase();
    if (sVCardTypeMap.containsKey(loweredKey)) {
        return sVCardTypeMap.get(loweredKey);
    } else if (""default"".equalsIgnoreCase(vcardTypeString)) {
        return VCARD_TYPE_DEFAULT;
    } else {
        Log.e(LOG_TAG, ""Unknown vCard type String: \"""" + vcardTypeString + ""\"""");
        return VCARD_TYPE_DEFAULT;
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"1,3",1,"There is a new conditional statement inclusion ""else if"" in the late version and there is a change in the 'if' condition where sVCardTypeMap replaces VCARD_TYPES_MAP in the late version. Also, the value return of the 'else' statement is the same, but a Log.e() statement has been added in the late version. Hence, change types are 1 and 3.","The introduction of the 'else if' condition and the replacement of VCARD_TYPES_MAP by sVCardTypeMap may cause the method to return different values in the early and late versions when the same argument is used. Hence, the CI type is 1."
442,<android.database.sqlite.SQLiteProgram: void clearBindings()>,7,8,<android.database.sqlite.SQLiteProgram: void clearBindings()>,<android.database.sqlite.SQLiteProgram: void clearBindings()>,0,"{
    acquireReference();
    try {
        native_clear_bindings();
    } finally {
        releaseReference();
    }
}","{
    if (!mDatabase.isOpen()) {
        throw new IllegalStateException(""database "" + mDatabase.getPath() + "" already closed"");
    }
    acquireReference();
    try {
        native_clear_bindings();
    } finally {
        releaseReference();
    }
}",1,"/**
 * Clears all existing bindings. Unset bindings are treated as NULL.
 */
","/**
 * Clears all existing bindings. Unset bindings are treated as NULL.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,3",2,"In the later version, a new condition statement checking if the database is open is introduced and an exception is thrown when database is not open. Therefore, this is a change type 2 and 3.","In the later version, a IllegalStateException is introduced which is potentially thrown when the database is not open. This could lead to different handling of exception compared to the early version, hence a CI of type 2."
443,<android.database.sqlite.SQLiteDatabase: void execSQL(String)>,7,8,<android.database.sqlite.SQLiteDatabase: void execSQL(String)>,<android.database.sqlite.SQLiteDatabase: void execSQL(String)>,0,"{
    boolean logStats = mLogStats;
    long timeStart = logStats ? SystemClock.elapsedRealtime() : 0;
    lock();
    try {
        native_execSQL(sql);
    } catch (SQLiteDatabaseCorruptException e) {
        onCorruption();
        throw e;
    } finally {
        unlock();
    }
    if (logStats) {
        logTimeStat(false, /* not a read */
        timeStart, SystemClock.elapsedRealtime());
    }
}","{
    long timeStart = SystemClock.uptimeMillis();
    lock();
    if (!isOpen()) {
        throw new IllegalStateException(""database not open"");
    }
    logTimeStat(mLastSqlStatement, timeStart, GET_LOCK_LOG_PREFIX);
    try {
        native_execSQL(sql);
    } catch (SQLiteDatabaseCorruptException e) {
        onCorruption();
        throw e;
    } finally {
        unlock();
    }
    // equality to COMMIT_SQL is safe here.
    if (sql == COMMIT_SQL) {
        logTimeStat(mLastSqlStatement, timeStart, COMMIT_SQL);
    } else {
        logTimeStat(sql, timeStart, null);
    }
}",1,"/**
 * Execute a single SQL statement that is not a query. For example, CREATE
 * TABLE, DELETE, INSERT, etc. Multiple statements separated by ;s are not
 * supported. it takes a write lock
 *
 * @throws SQLException If the SQL string is invalid for some reason
 */
","/**
 * Execute a single SQL statement that is not a query. For example, CREATE
 * TABLE, DELETE, INSERT, etc. Multiple statements separated by ;s are not
 * supported. it takes a write lock
 *
 * @throws SQLException If the SQL string is invalid for some reason
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,2,3,4","1,2","The early version and late version implementations of the method are significantly different. The first variable initialization and if statement have completely changed. An additional exception is thrown under a new condition, and the call to 'logTimeStat' has an extra condition compared to the initial version.",
444,"<android.content.ContentResolver: int bulkInsert(Uri,ContentValues[])>",7,8,"<android.content.ContentResolver: int bulkInsert(Uri,ContentValues[])>","<android.content.ContentResolver: int bulkInsert(Uri,ContentValues[])>",0,"{
    IContentProvider provider = acquireProvider(url);
    if (provider == null) {
        throw new IllegalArgumentException(""Unknown URL "" + url);
    }
    try {
        return provider.bulkInsert(url, values);
    } catch (RemoteException e) {
        return 0;
    } finally {
        releaseProvider(provider);
    }
}","{
    IContentProvider provider = acquireProvider(url);
    if (provider == null) {
        throw new IllegalArgumentException(""Unknown URL "" + url);
    }
    try {
        long startTime = SystemClock.uptimeMillis();
        int rowsCreated = provider.bulkInsert(url, values);
        long durationMillis = SystemClock.uptimeMillis() - startTime;
        maybeLogUpdateToEventLog(durationMillis, url, ""bulkinsert"", null);
        return rowsCreated;
    } catch (RemoteException e) {
        return 0;
    } finally {
        releaseProvider(provider);
    }
}",1,"/**
 * Inserts multiple rows into a table at the given URL.
 *
 * This function make no guarantees about the atomicity of the insertions.
 *
 * @param url The URL of the table to insert into.
 * @param values The initial values for the newly inserted rows. The key is the column name for
 * the field. Passing null will create an empty row.
 * @return the number of newly created rows.
 */
","/**
 * Inserts multiple rows into a table at the given URL.
 *
 * This function make no guarantees about the atomicity of the insertions.
 *
 * @param url The URL of the table to insert into.
 * @param values The initial values for the newly inserted rows. The key is the column name for
 * the field. Passing null will create an empty row.
 * @return the number of newly created rows.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The new inserted statements (lines 6-9 in the late version) are about measuring the duration of provider.bulkInsert(url, values) function and possibly logging the update to event log. The changes do not affect the logic and behavior of the code, thus, the change type is 4.","Despite the changes made to the late version implementation, the return value and exceptions thrown are still maintained. The API cannot potentially return a different value or throw a different exception. Therefore, no compatibility issue (CI) exists."
447,"<android.util.Log: int e(String,String,Throwable)>",7,8,"<android.util.Log: int e(String,String,Throwable)>","<android.util.Log: int e(String,String,Throwable)>",0,"{
    int r = println(ERROR, tag, msg + '\n' + getStackTraceString(tr));
    // asynchronous
    RuntimeInit.reportException(tag, tr, false);
    return r;
}","{
    return println_native(LOG_ID_MAIN, ERROR, tag, msg + '\n' + getStackTraceString(tr));
}",1,"/**
 * Send a {@link #ERROR} log message and log the exception.
 * @param tag Used to identify the source of a log message.  It usually identifies
 * the class or activity where the log call occurs.
 * @param msg The message you would like logged.
 * @param tr An exception to log
 */
","/**
 * Send a {@link #ERROR} log message and log the exception.
 * @param tag Used to identify the source of a log message.  It usually identifies
 * the class or activity where the log call occurs.
 * @param msg The message you would like logged.
 * @param tr An exception to log
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,4,5",1,"Both the return statement and other function calls inside the method body have been changed. The early version uses println and RuntimeInit.reportException while the latter uses println_native. This change can be classified into types 1, 4, 5. ","The change in the method implementation potentially led to a different return value for the same input parameters as the println_native and println functions might behave differently. Therefore, a Compatibility Issue caused by potential different return value exists, i.e., CI type 1."
448,<android.accounts.AccountManager: void removeOnAccountsUpdatedListener(OnAccountsUpdateListener)>,7,8,<android.accounts.AccountManager: void removeOnAccountsUpdatedListener(OnAccountsUpdateListener)>,<android.accounts.AccountManager: void removeOnAccountsUpdatedListener(OnAccountsUpdateListener)>,0,"{
    if (listener == null) {
        Log.e(TAG, ""Missing listener"");
        return;
    }
    synchronized (mAccountsUpdatedListeners) {
        if (!mAccountsUpdatedListeners.containsKey(listener)) {
            Log.e(TAG, ""Listener was not previously added"");
            return;
        }
        mAccountsUpdatedListeners.remove(listener);
        if (mAccountsUpdatedListeners.isEmpty()) {
            mContext.unregisterReceiver(mAccountsChangedBroadcastReceiver);
        }
    }
}","{
    if (listener == null)
        throw new IllegalArgumentException(""listener is null"");
    synchronized (mAccountsUpdatedListeners) {
        if (!mAccountsUpdatedListeners.containsKey(listener)) {
            Log.e(TAG, ""Listener was not previously added"");
            return;
        }
        mAccountsUpdatedListeners.remove(listener);
        if (mAccountsUpdatedListeners.isEmpty()) {
            mContext.unregisterReceiver(mAccountsChangedBroadcastReceiver);
        }
    }
}",1,"/**
 * Remove an {@link OnAccountsUpdateListener} that was previously registered with
 * {@link #addOnAccountsUpdatedListener}.
 * @param listener the listener to remove
 * @throws IllegalArgumentException if listener is null
 * @throws IllegalStateException if listener was not already added
 */
","/**
 * Removes an {@link OnAccountsUpdateListener} previously registered with
 * {@link #addOnAccountsUpdatedListener}.  The listener will no longer
 * receive notifications of account changes.
 *
 * <p>It is safe to call this method from the main thread.
 *
 * <p>No permission is required to call this method.
 *
 * @param listener The previously added listener to remove
 * @throws IllegalArgumentException if listener is null
 * @throws IllegalStateException if listener was not already added
 */
",-1,,,-1,-1,-1,-1,-1,-1,2,2,"The way how the API handles the null listener argument has changed: early version only logs error while the late version throws IllegalArgumentException, so the code change type is 2.","With the new exception handling statement, the API will potentially throw a different exception if receives null listener, thus the CI type is 2."
449,<android.app.ActivityThread.ApplicationThread: void setSchedulingGroup(int)>,7,8,<android.app.ActivityThread.ApplicationThread: void setSchedulingGroup(int)>,<android.app.ActivityThread.ApplicationThread: void setSchedulingGroup(int)>,0,"{
    // we are done before sending us to the background.
    try {
        Process.setProcessGroup(Process.myPid(), group);
    } catch (Exception e) {
        Log.w(TAG, ""Failed setting process group to "" + group, e);
    }
}","{
    // we are done before sending us to the background.
    try {
        Process.setProcessGroup(Process.myPid(), group);
    } catch (Exception e) {
        Slog.w(TAG, ""Failed setting process group to "" + group, e);
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,4,0,"The change happened here is the different logging functions in the 'catch' block. It changed from ""Log.w"" to ""Slog.w"". This type of change falls under the category of 'Other statement changed', so the code change type is 4.","The altered part is just about how to log the exception, which doesn't affect the API's behavior like returning different variables or throwing different exceptions. As such, there's no compatibility issue, so the CI type is 0."
451,<android.widget.TabHost: void setCurrentTab(int)>,7,8,<android.widget.TabHost: void setCurrentTab(int)>,<android.widget.TabHost: void setCurrentTab(int)>,0,"{
    if (index < 0 || index >= mTabSpecs.size()) {
        return;
    }
    if (index == mCurrentTab) {
        return;
    }
    // notify old tab content
    if (mCurrentTab != -1) {
        mTabSpecs.get(mCurrentTab).mContentStrategy.tabClosed();
    }
    mCurrentTab = index;
    final TabHost.TabSpec spec = mTabSpecs.get(index);
    // Call the tab widget's focusCurrentTab(), instead of just
    // selecting the tab.
    mTabWidget.focusCurrentTab(mCurrentTab);
    // tab content
    mCurrentView = spec.mContentStrategy.getContentView();
    if (mCurrentView.getParent() == null) {
        mTabContent.addView(mCurrentView, new ViewGroup.LayoutParams(ViewGroup.LayoutParams.FILL_PARENT, ViewGroup.LayoutParams.FILL_PARENT));
    }
    if (!mTabWidget.hasFocus()) {
        // if the tab widget didn't take focus (likely because we're in touch mode)
        // give the current tab content view a shot
        mCurrentView.requestFocus();
    }
    // mTabContent.requestFocus(View.FOCUS_FORWARD);
    invokeOnTabChangeListener();
}","{
    if (index < 0 || index >= mTabSpecs.size()) {
        return;
    }
    if (index == mCurrentTab) {
        return;
    }
    // notify old tab content
    if (mCurrentTab != -1) {
        mTabSpecs.get(mCurrentTab).mContentStrategy.tabClosed();
    }
    mCurrentTab = index;
    final TabHost.TabSpec spec = mTabSpecs.get(index);
    // Call the tab widget's focusCurrentTab(), instead of just
    // selecting the tab.
    mTabWidget.focusCurrentTab(mCurrentTab);
    // tab content
    mCurrentView = spec.mContentStrategy.getContentView();
    if (mCurrentView.getParent() == null) {
        mTabContent.addView(mCurrentView, new ViewGroup.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.MATCH_PARENT));
    }
    if (!mTabWidget.hasFocus()) {
        // if the tab widget didn't take focus (likely because we're in touch mode)
        // give the current tab content view a shot
        mCurrentView.requestFocus();
    }
    // mTabContent.requestFocus(View.FOCUS_FORWARD);
    invokeOnTabChangeListener();
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,4,0,"The parameters in the creation of new ViewGroup.LayoutParams object has changed from FILL_PARENT to MATCH_PARENT, so the code change type is 4.","The change of parameters in ViewGroup.LayoutParams will not influence the method's return values or the exceptions it might throw, so no Compatibility Issue exists, the CI type is 0."
452,<android.app.Activity: void performStop()>,7,8,<android.app.Activity: void performStop()>,<android.app.Activity: void performStop()>,0,"{
    if (!mStopped) {
        if (mWindow != null) {
            mWindow.closeAllPanels();
        }
        mCalled = false;
        mInstrumentation.callActivityOnStop(this);
        if (!mCalled) {
            throw new SuperNotCalledException(""Activity "" + mComponent.toShortString() + "" did not call through to super.onStop()"");
        }
        final int N = mManagedCursors.size();
        for (int i = 0; i < N; i++) {
            ManagedCursor mc = mManagedCursors.get(i);
            if (!mc.mReleased) {
                mc.mCursor.deactivate();
                mc.mReleased = true;
            }
        }
        mStopped = true;
    }
    mResumed = false;
}","{
    if (!mStopped) {
        if (mWindow != null) {
            mWindow.closeAllPanels();
        }
        mCalled = false;
        mInstrumentation.callActivityOnStop(this);
        if (!mCalled) {
            throw new SuperNotCalledException(""Activity "" + mComponent.toShortString() + "" did not call through to super.onStop()"");
        }
        synchronized (mManagedCursors) {
            final int N = mManagedCursors.size();
            for (int i = 0; i < N; i++) {
                ManagedCursor mc = mManagedCursors.get(i);
                if (!mc.mReleased) {
                    mc.mCursor.deactivate();
                    mc.mReleased = true;
                }
            }
        }
        mStopped = true;
    }
    mResumed = false;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,3,0,"The 'synchronized' keyword has been added to ensure that the code block containing the mManagedCursors manipulation is thread-safe. Hence, the code change type is 3 for control dependency change.","The change in the method, the addition of the 'synchronized' keyword, does not alter the method's behaviour. It only ensures that the block of code it applies to is executed by only one thread at a time. Therefore, it doesn't lead to compatibility issues, so CI type is 0 - no compatibility issue."
453,<android.database.sqlite.SQLiteDatabase: long setMaximumSize(long)>,7,8,<android.database.sqlite.SQLiteDatabase: long setMaximumSize(long)>,<android.database.sqlite.SQLiteDatabase: long setMaximumSize(long)>,0,"{
    SQLiteStatement prog = null;
    lock();
    try {
        long pageSize = getPageSize();
        long numPages = numBytes / pageSize;
        // If numBytes isn't a multiple of pageSize, bump up a page
        if ((numBytes % pageSize) != 0) {
            numPages++;
        }
        prog = new SQLiteStatement(this, ""PRAGMA max_page_count = "" + numPages);
        long newPageCount = prog.simpleQueryForLong();
        return newPageCount * pageSize;
    } finally {
        if (prog != null)
            prog.close();
        unlock();
    }
}","{
    SQLiteStatement prog = null;
    lock();
    if (!isOpen()) {
        throw new IllegalStateException(""database not open"");
    }
    try {
        long pageSize = getPageSize();
        long numPages = numBytes / pageSize;
        // If numBytes isn't a multiple of pageSize, bump up a page
        if ((numBytes % pageSize) != 0) {
            numPages++;
        }
        prog = new SQLiteStatement(this, ""PRAGMA max_page_count = "" + numPages);
        long newPageCount = prog.simpleQueryForLong();
        return newPageCount * pageSize;
    } finally {
        if (prog != null)
            prog.close();
        unlock();
    }
}",1,"/**
 * Sets the maximum size the database will grow to. The maximum size cannot
 * be set below the current size.
 *
 * @param numBytes the maximum database size, in bytes
 * @return the new maximum database size
 */
","/**
 * Sets the maximum size the database will grow to. The maximum size cannot
 * be set below the current size.
 *
 * @param numBytes the maximum database size, in bytes
 * @return the new maximum database size
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,3","1,2","In the late version, an additional 'throw' statement has been added if the database is not open. Also there is a new conditional statement that checks whether the database is open. So the type of code change is 2,3.","The addition of the 'throw' statement could introduce a new exception that wasn't thrown in the earlier version and the change in the condition statement could potentially lead the API to return a different value. Therefore, the CI type is 1,2."
454,"<android.webkit.GeolocationPermissions: void getAllowed(String,ValueCallback<Boolean>)>",7,8,"<android.webkit.GeolocationPermissions: void getAllowed(String,ValueCallback<Boolean>)>","<android.webkit.GeolocationPermissions: void getAllowed(String,ValueCallback<Boolean>)>",0,"{
    if (callback == null) {
        return;
    }
    if (origin == null) {
        callback.onReceiveValue(null);
        return;
    }
    if (WebViewCore.THREAD_NAME.equals(Thread.currentThread().getName())) {
        getAllowedImpl(origin);
        callback.onReceiveValue(new Boolean(mAllowed));
    } else {
        Map values = new HashMap<String, Object>();
        values.put(ORIGIN, origin);
        values.put(CALLBACK, callback);
        postMessage(Message.obtain(null, GET_ALLOWED, values));
    }
}","{
    if (callback == null) {
        return;
    }
    if (origin == null) {
        callback.onReceiveValue(null);
        return;
    }
    if (WebViewCore.THREAD_NAME.equals(Thread.currentThread().getName())) {
        boolean allowed = nativeGetAllowed(origin);
        callback.onReceiveValue(new Boolean(allowed));
    } else {
        Map values = new HashMap<String, Object>();
        values.put(ORIGIN, origin);
        values.put(CALLBACK, callback);
        postMessage(Message.obtain(null, GET_ALLOWED, values));
    }
}",1,"/**
 * Gets the permission state for the specified origin.
 *
 * Callback is a ValueCallback object whose onReceiveValue method will be
 * called asynchronously with the permission state for the origin.
 */
","/**
 * Gets the permission state for the specified origin.
 *
 * Callback is a ValueCallback object whose onReceiveValue method will be
 * called asynchronously with the permission state for the origin.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,4,5",1,"The statement within the 'if' condition statement, `getAllowedImpl(origin);` has been replaced with `boolean allowed = nativeGetAllowed(origin);` in the late version. Also, in the subsequent `callback.onReceiveValue(new Boolean(mAllowed))`, `mAllowed` has been replaced with `allowed`. Thus, the code change type is 1,4,5.","Since the changed lines could affect the value returned by the callback function, it could potentially return a different value, so the CI type is 1."
455,<android.pim.vcard.VCardParser_V30: String maybeUnescapeText(String)>,7,8,<android.pim.vcard.VCardParser_V30: String maybeUnescapeText(String)>,<android.pim.vcard.VCardParser_V30: String maybeUnescapeText(String)>,0,"{
    StringBuilder builder = new StringBuilder();
    int length = text.length();
    for (int i = 0; i < length; i++) {
        char ch = text.charAt(i);
        if (ch == '\\' && i < length - 1) {
            char next_ch = text.charAt(++i);
            if (next_ch == 'n' || next_ch == 'N') {
                builder.append(""\n"");
            } else {
                builder.append(next_ch);
            }
        } else {
            builder.append(ch);
        }
    }
    return builder.toString();
}","{
    return unescapeText(text);
}",1,"/**
 * ESCAPED-CHAR = ""\\"" / ""\;"" / ""\,"" / ""\n"" / ""\N"")
 * ; \\ encodes \, \n or \N encodes newline
 * ; \; encodes ;, \, encodes ,
 *
 * Note: Apple escape ':' into '\:' while does not escape '\'
 */
","/**
 * ESCAPED-CHAR = ""\\"" / ""\;"" / ""\,"" / ""\n"" / ""\N"")
 * ; \\ encodes \, \n or \N encodes newline
 * ; \; encodes ;, \, encodes ,
 *
 * Note: Apple escapes ':' into '\:' while does not escape '\'
 */
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,5",1,The entire function body has been replaced with a single return statement that calls a different function. This is a return statement change (type 1) and a dependent API change (type 5).,"Since the entire function body has been replaced by a function call to 'unescapeText(text)', the returned value might be potentially different. This indicates a CI caused by potential different return values or types (type 1)."
457,"<android.text.Layout: int getLineBounds(int,Rect)>",7,8,"<android.text.Layout: int getLineBounds(int,Rect)>","<android.text.Layout: int getLineBounds(int,Rect)>",0,"{
    if (bounds != null) {
        // ???
        bounds.left = 0;
        bounds.top = getLineTop(line);
        // ???
        bounds.right = mWidth;
        bounds.bottom = getLineBottom(line);
    }
    return getLineBaseline(line);
}","{
    if (bounds != null) {
        // ???
        bounds.left = 0;
        bounds.top = getLineTop(line);
        // ???
        bounds.right = mWidth;
        bounds.bottom = getLineTop(line + 1);
    }
    return getLineBaseline(line);
}",1,"/**
 * Return the baseline for the specified line (0&hellip;getLineCount() - 1)
 * If bounds is not null, return the top, left, right, bottom extents
 * of the specified line in it.
 * @param line which line to examine (0..getLineCount() - 1)
 * @param bounds Optional. If not null, it returns the extent of the line
 * @return the Y-coordinate of the baseline
 */
","/**
 * Return the baseline for the specified line (0&hellip;getLineCount() - 1)
 * If bounds is not null, return the top, left, right, bottom extents
 * of the specified line in it.
 * @param line which line to examine (0..getLineCount() - 1)
 * @param bounds Optional. If not null, it returns the extent of the line
 * @return the Y-coordinate of the baseline
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The only difference is the parameter of the method call getLineTop(line + 1) in late implementation instead of getLineBottom(line) in early implementation, this method call does not affect the return value and does not throw an exception. So, the code change belongs to the Other statement changed category (4).","Despite there being a change in the code, it would not result in a Compatibility Issue as the return type and value haven't changed and exceptions have not been introduced or removed. So, no Compatibility Issue exists(0)."
458,"<android.database.sqlite.SQLiteDatabase: long replace(String,String,ContentValues)>",7,8,"<android.database.sqlite.SQLiteDatabase: long replace(String,String,ContentValues)>","<android.database.sqlite.SQLiteDatabase: long replace(String,String,ContentValues)>",0,"{
    try {
        return insertWithOnConflict(table, nullColumnHack, initialValues, ConflictAlgorithm.REPLACE);
    } catch (SQLException e) {
        Log.e(TAG, ""Error inserting "" + initialValues, e);
        return -1;
    }
}","{
    try {
        return insertWithOnConflict(table, nullColumnHack, initialValues, CONFLICT_REPLACE);
    } catch (SQLException e) {
        Log.e(TAG, ""Error inserting "" + initialValues, e);
        return -1;
    }
}",1,"/**
 * Convenience method for replacing a row in the database.
 *
 * @param table the table in which to replace the row
 * @param nullColumnHack SQL doesn't allow inserting a completely empty row,
 * so if initialValues is empty this row will explicitly be
 * assigned a NULL value
 * @param initialValues this map contains the initial column values for
 * the row. The key
 * @return the row ID of the newly inserted row, or -1 if an error occurred
 */
","/**
 * Convenience method for replacing a row in the database.
 *
 * @param table the table in which to replace the row
 * @param nullColumnHack SQL doesn't allow inserting a completely empty row,
 * so if initialValues is empty this row will explicitly be
 * assigned a NULL value
 * @param initialValues this map contains the initial column values for
 * the row. The key
 * @return the row ID of the newly inserted row, or -1 if an error occurred
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,1,"The dependent API, insertWithOnConflict(), has changed its parameter from ConflictAlgorithm.REPLACE to CONFLICT_REPLACE, so the change type can be classified as 5 (Dependent API changed).","The change in the parameter of the dependent method may lead to different behaviors, therefore, the return value may be different. So the CI type is 1 (Compatibility Issue caused by potential different return values or types)."
459,<android.widget.ScrollView: boolean onTouchEvent(MotionEvent)>,7,8,<android.widget.ScrollView: boolean onTouchEvent(MotionEvent)>,<android.widget.ScrollView: boolean onTouchEvent(MotionEvent)>,0,"{
    if (ev.getAction() == MotionEvent.ACTION_DOWN && ev.getEdgeFlags() != 0) {
        // descendants.
        return false;
    }
    if (!canScroll()) {
        return false;
    }
    if (mVelocityTracker == null) {
        mVelocityTracker = VelocityTracker.obtain();
    }
    mVelocityTracker.addMovement(ev);
    final int action = ev.getAction();
    final float y = ev.getY();
    switch(action) {
        case MotionEvent.ACTION_DOWN:
            /*
                * If being flinged and user touches, stop the fling. isFinished
                * will be false if being flinged.
                */
            if (!mScroller.isFinished()) {
                mScroller.abortAnimation();
            }
            // Remember where the motion event started
            mLastMotionY = y;
            break;
        case MotionEvent.ACTION_MOVE:
            // Scroll to follow the motion event
            final int deltaY = (int) (mLastMotionY - y);
            mLastMotionY = y;
            if (deltaY < 0) {
                if (mScrollY > 0) {
                    scrollBy(0, deltaY);
                }
            } else if (deltaY > 0) {
                final int bottomEdge = getHeight() - mPaddingBottom;
                final int availableToScroll = getChildAt(0).getBottom() - mScrollY - bottomEdge;
                if (availableToScroll > 0) {
                    scrollBy(0, Math.min(availableToScroll, deltaY));
                }
            }
            break;
        case MotionEvent.ACTION_UP:
            final VelocityTracker velocityTracker = mVelocityTracker;
            velocityTracker.computeCurrentVelocity(1000, mMaximumVelocity);
            int initialVelocity = (int) velocityTracker.getYVelocity();
            if ((Math.abs(initialVelocity) > mMinimumVelocity) && getChildCount() > 0) {
                fling(-initialVelocity);
            }
            if (mVelocityTracker != null) {
                mVelocityTracker.recycle();
                mVelocityTracker = null;
            }
    }
    return true;
}","{
    if (ev.getAction() == MotionEvent.ACTION_DOWN && ev.getEdgeFlags() != 0) {
        // descendants.
        return false;
    }
    if (mVelocityTracker == null) {
        mVelocityTracker = VelocityTracker.obtain();
    }
    mVelocityTracker.addMovement(ev);
    final int action = ev.getAction();
    switch(action & MotionEvent.ACTION_MASK) {
        case MotionEvent.ACTION_DOWN:
            {
                final float y = ev.getY();
                if (!(mIsBeingDragged = inChild((int) ev.getX(), (int) y))) {
                    return false;
                }
                /*
                 * If being flinged and user touches, stop the fling. isFinished
                 * will be false if being flinged.
                 */
                if (!mScroller.isFinished()) {
                    mScroller.abortAnimation();
                }
                // Remember where the motion event started
                mLastMotionY = y;
                mActivePointerId = ev.getPointerId(0);
                break;
            }
        case MotionEvent.ACTION_MOVE:
            if (mIsBeingDragged) {
                // Scroll to follow the motion event
                final int activePointerIndex = ev.findPointerIndex(mActivePointerId);
                final float y = ev.getY(activePointerIndex);
                final int deltaY = (int) (mLastMotionY - y);
                mLastMotionY = y;
                scrollBy(0, deltaY);
            }
            break;
        case MotionEvent.ACTION_UP:
            if (mIsBeingDragged) {
                final VelocityTracker velocityTracker = mVelocityTracker;
                velocityTracker.computeCurrentVelocity(1000, mMaximumVelocity);
                int initialVelocity = (int) velocityTracker.getYVelocity(mActivePointerId);
                if (getChildCount() > 0 && Math.abs(initialVelocity) > mMinimumVelocity) {
                    fling(-initialVelocity);
                }
                mActivePointerId = INVALID_POINTER;
                mIsBeingDragged = false;
                if (mVelocityTracker != null) {
                    mVelocityTracker.recycle();
                    mVelocityTracker = null;
                }
            }
            break;
        case MotionEvent.ACTION_CANCEL:
            if (mIsBeingDragged && getChildCount() > 0) {
                mActivePointerId = INVALID_POINTER;
                mIsBeingDragged = false;
                if (mVelocityTracker != null) {
                    mVelocityTracker.recycle();
                    mVelocityTracker = null;
                }
            }
            break;
        case MotionEvent.ACTION_POINTER_UP:
            onSecondaryPointerUp(ev);
            break;
    }
    return true;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,4",1,"The control dependencies inside the switch-case statements have changed, and other statements, such as assignments, comparisons, and method invocations, are also different, therefore, the code change type is 3 and 4.","The changes in the control dependencies and other statements have altered the conditions where the function returns, which could potentially lead to the function returning a different value. Thus, the CI type is 1."
460,<android.widget.LinearLayout: LayoutParams generateDefaultLayoutParams()>,7,8,<android.widget.LinearLayout: LayoutParams generateDefaultLayoutParams()>,<android.widget.LinearLayout: LayoutParams generateDefaultLayoutParams()>,0,"{
    if (mOrientation == HORIZONTAL) {
        return new LayoutParams(LayoutParams.WRAP_CONTENT, LayoutParams.WRAP_CONTENT);
    } else if (mOrientation == VERTICAL) {
        return new LayoutParams(LayoutParams.FILL_PARENT, LayoutParams.WRAP_CONTENT);
    }
    return null;
}","{
    if (mOrientation == HORIZONTAL) {
        return new LayoutParams(LayoutParams.WRAP_CONTENT, LayoutParams.WRAP_CONTENT);
    } else if (mOrientation == VERTICAL) {
        return new LayoutParams(LayoutParams.MATCH_PARENT, LayoutParams.WRAP_CONTENT);
    }
    return null;
}",1,"/**
 * Returns a set of layout parameters with a width of
 * {@link android.view.ViewGroup.LayoutParams#FILL_PARENT}
 * and a height of {@link android.view.ViewGroup.LayoutParams#WRAP_CONTENT}
 * when the layout's orientation is {@link #VERTICAL}. When the orientation is
 * {@link #HORIZONTAL}, the width is set to {@link LayoutParams#WRAP_CONTENT}
 * and the height to {@link LayoutParams#WRAP_CONTENT}.
 */
","/**
 * Returns a set of layout parameters with a width of
 * {@link android.view.ViewGroup.LayoutParams#MATCH_PARENT}
 * and a height of {@link android.view.ViewGroup.LayoutParams#WRAP_CONTENT}
 * when the layout's orientation is {@link #VERTICAL}. When the orientation is
 * {@link #HORIZONTAL}, the width is set to {@link LayoutParams#WRAP_CONTENT}
 * and the height to {@link LayoutParams#WRAP_CONTENT}.
 */
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,1,1,"The return statement has changed from new LayoutParams(LayoutParams.FILL_PARENT, LayoutParams.WRAP_CONTENT) to new LayoutParams(LayoutParams.MATCH_PARENT, LayoutParams.WRAP_CONTENT), so the code change type is 1.","The change of return statement will make the API potentially return a different value, so the CI type is 1."
462,<android.widget.TabHost: boolean dispatchKeyEvent(KeyEvent)>,7,8,<android.widget.TabHost: boolean dispatchKeyEvent(KeyEvent)>,<android.widget.TabHost: boolean dispatchKeyEvent(KeyEvent)>,0,"{
    final boolean handled = super.dispatchKeyEvent(event);
    // when there is nothing that will take focus from default focus searching
    if (!handled && (event.getAction() == KeyEvent.ACTION_DOWN) && (event.getKeyCode() == KeyEvent.KEYCODE_DPAD_UP) && (mCurrentView.isRootNamespace()) && (mCurrentView.hasFocus()) && (mCurrentView.findFocus().focusSearch(View.FOCUS_UP) == null)) {
        mTabWidget.getChildTabViewAt(mCurrentTab).requestFocus();
        playSoundEffect(SoundEffectConstants.NAVIGATION_UP);
        return true;
    }
    return handled;
}","{
    final boolean handled = super.dispatchKeyEvent(event);
    // when there is nothing that will take focus from default focus searching
    if (!handled && (event.getAction() == KeyEvent.ACTION_DOWN) && (event.getKeyCode() == KeyEvent.KEYCODE_DPAD_UP) && (mCurrentView != null) && (mCurrentView.isRootNamespace()) && (mCurrentView.hasFocus()) && (mCurrentView.findFocus().focusSearch(View.FOCUS_UP) == null)) {
        mTabWidget.getChildTabViewAt(mCurrentTab).requestFocus();
        playSoundEffect(SoundEffectConstants.NAVIGATION_UP);
        return true;
    }
    return handled;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,3,1,"The 'if' condition check statement has changed from 'mCurrentView.isRootNamespace()' to 'mCurrentView != null' which implies a change in control dependency of the code, thus the code change type is 3.","The change in the 'if' condition check may potentially lead to a different return value, thus the Compatibility Issue type is 1."
466,"<android.accounts.AccountManager: AccountManagerFuture<Bundle> updateCredentials(Account,String,Bundle,Activity,AccountManagerCallback<Bundle>,Handler)>",7,8,"<android.accounts.AccountManager: AccountManagerFuture<Bundle> updateCredentials(Account,String,Bundle,Activity,AccountManagerCallback<Bundle>,Handler)>","<android.accounts.AccountManager: AccountManagerFuture<Bundle> updateCredentials(Account,String,Bundle,Activity,AccountManagerCallback<Bundle>,Handler)>",0,"{
    return new AmsTask(activity, handler, callback) {

        public void doWork() throws RemoteException {
            mService.updateCredentials(mResponse, account, authTokenType, activity != null, options);
        }
    }.start();
}","{
    if (account == null)
        throw new IllegalArgumentException(""account is null"");
    return new AmsTask(activity, handler, callback) {

        public void doWork() throws RemoteException {
            mService.updateCredentials(mResponse, account, authTokenType, activity != null, options);
        }
    }.start();
}",1,"/**
 * Requests that the authenticator update the the credentials for a user. This is typically
 * done by returning an intent to an activity that will prompt the user to update the stored
 * credentials for the account. This request
 * is processed by the authenticator for the account. If no matching authenticator is
 * registered in the system then {@link AuthenticatorException} is thrown.
 * <p>
 * This call returns immediately but runs asynchronously and the result is accessed via the
 * {@link AccountManagerFuture} that is returned. This future is also passed as the sole
 * parameter to the {@link AccountManagerCallback}. If the caller wished to use this
 * method asynchronously then they will generally pass in a callback object that will get
 * invoked with the {@link AccountManagerFuture}. If they wish to use it synchronously then
 * they will generally pass null for the callback and instead call
 * {@link android.accounts.AccountManagerFuture#getResult()} on this method's return value,
 * which will then block until the request completes.
 * <p>
 * Requires that the caller has permission {@link android.Manifest.permission#MANAGE_ACCOUNTS}.
 *
 * @param account The account whose credentials are to be updated.
 * @param authTokenType the auth token to retrieve as part of updating the credentials.
 * May be null.
 * @param options authenticator specific options for the request
 * @param activity If the authenticator returns a {@link #KEY_INTENT} in the result then
 * the intent will be started with this activity. If activity is null then the result will
 * be returned as-is.
 * @param callback A callback to invoke when the request completes. If null then
 * no callback is invoked.
 * @param handler The {@link Handler} to use to invoke the callback. If null then the
 * main thread's {@link Handler} is used.
 * @return an {@link AccountManagerFuture} that represents the future result of the call.
 * The future result is a {@link Bundle} that contains either:
 * <ul>
 * <li> {@link #KEY_INTENT}, which is to be used to prompt the user for the credentials
 * <li> {@link #KEY_ACCOUNT_NAME} and {@link #KEY_ACCOUNT_TYPE} if the user enters the correct
 * credentials, and optionally a {@link #KEY_AUTHTOKEN} if an authTokenType was provided.
 * </ul>
 * If the user presses ""back"" then the request will be canceled.
 */
","/**
 * Asks the user to enter a new password for an account, updating the
 * saved credentials for the account.  Normally this happens automatically
 * when the server rejects credentials during an auth token fetch, but this
 * can be invoked directly to ensure we have the correct credentials stored.
 *
 * <p>This method may be called from any thread, but the returned
 * {@link AccountManagerFuture} must not be used on the main thread.
 *
 * <p>This method requires the caller to hold the permission
 * {@link android.Manifest.permission#MANAGE_ACCOUNTS}.
 *
 * @param account The account to update credentials for
 * @param authTokenType The credentials entered must allow an auth token
 * of this type to be created (but no actual auth token is returned);
 * may be null
 * @param options Authenticator-specific options for the request;
 * may be null or empty
 * @param activity The {@link Activity} context to use for launching a new
 * authenticator-defined sub-Activity to prompt the user to enter a
 * password; used only to call startActivity(); if null, the prompt
 * will not be launched directly, but the necessary {@link Intent}
 * will be returned to the caller instead
 * @param callback Callback to invoke when the request completes,
 * null for no callback
 * @param handler {@link Handler} identifying the callback thread,
 * null for the main thread
 * @return An {@link AccountManagerFuture} which resolves to a Bundle
 * with these fields if an activity was supplied and the account
 * credentials were successfully updated:
 * <ul>
 * <li> {@link #KEY_ACCOUNT_NAME} - the name of the account created
 * <li> {@link #KEY_ACCOUNT_TYPE} - the type of the account
 * </ul>
 *
 * If no activity was specified, the returned Bundle contains only
 * {@link #KEY_INTENT} with the {@link Intent} needed to launch the
 * password prompt.
 *
 * <p>If an error occurred, {@link AccountManagerFuture#getResult()} throws:
 * <ul>
 * <li> {@link AuthenticatorException} if the authenticator failed to respond
 * <li> {@link OperationCanceledException} if the operation was canceled for
 * any reason, including the user canceling the password prompt
 * <li> {@link IOException} if the authenticator experienced an I/O problem
 * verifying the password, usually because of network trouble
 * </ul>
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,3",2,"A new exception throwing statement ""throw new IllegalArgumentException(""account is null"")"" is added when 'account' is null and one 'if' control statement has been introduced, so the code change type is 2,3.","The newly added exception throwing statement could cause the function to throw a different exception in late version, thus the CI Type is 2."
467,<android.appwidget.AppWidgetHostView: View getDefaultView()>,7,8,<android.appwidget.AppWidgetHostView: View getDefaultView()>,<android.appwidget.AppWidgetHostView: View getDefaultView()>,0,"{
    View defaultView = null;
    Exception exception = null;
    try {
        if (mInfo != null) {
            Context theirContext = mContext.createPackageContext(mInfo.provider.getPackageName(), Context.CONTEXT_RESTRICTED);
            mRemoteContext = theirContext;
            LayoutInflater inflater = (LayoutInflater) theirContext.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
            inflater = inflater.cloneInContext(theirContext);
            inflater.setFilter(sInflaterFilter);
            defaultView = inflater.inflate(mInfo.initialLayout, this, false);
        } else {
            Log.w(TAG, ""can't inflate defaultView because mInfo is missing"");
        }
    } catch (PackageManager.NameNotFoundException e) {
        exception = e;
    } catch (RuntimeException e) {
        exception = e;
    }
    if (exception != null) {
        Log.w(TAG, ""Error inflating AppWidget "" + mInfo + "": "" + exception.toString());
    }
    if (defaultView == null) {
        if (LOGD)
            Log.d(TAG, ""getDefaultView couldn't find any view, so inflating error"");
        defaultView = getErrorView();
    }
    return defaultView;
}","{
    if (LOGD) {
        Log.d(TAG, ""getDefaultView"");
    }
    View defaultView = null;
    Exception exception = null;
    try {
        if (mInfo != null) {
            Context theirContext = mContext.createPackageContext(mInfo.provider.getPackageName(), Context.CONTEXT_RESTRICTED);
            mRemoteContext = theirContext;
            LayoutInflater inflater = (LayoutInflater) theirContext.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
            inflater = inflater.cloneInContext(theirContext);
            inflater.setFilter(sInflaterFilter);
            defaultView = inflater.inflate(mInfo.initialLayout, this, false);
        } else {
            Log.w(TAG, ""can't inflate defaultView because mInfo is missing"");
        }
    } catch (PackageManager.NameNotFoundException e) {
        exception = e;
    } catch (RuntimeException e) {
        exception = e;
    }
    if (exception != null) {
        Log.w(TAG, ""Error inflating AppWidget "" + mInfo + "": "" + exception.toString());
    }
    if (defaultView == null) {
        if (LOGD)
            Log.d(TAG, ""getDefaultView couldn't find any view, so inflating error"");
        defaultView = getErrorView();
    }
    return defaultView;
}",1,"/**
 * Inflate and return the default layout requested by AppWidget provider.
 */
","/**
 * Inflate and return the default layout requested by AppWidget provider.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"There is a new logging statement (Log.d(TAG, ""getDefaultView"");) added in the late version, so the change type is 4.","The newly added logging statement does not result in a different return value or exception handling and, therefore, does not cause any compatibility issue. So, no Compatibility Issue exists (type 0)."
468,<android.content.pm.PackageItemInfo: Drawable loadIcon(PackageManager)>,7,8,<android.content.pm.PackageItemInfo: Drawable loadIcon(PackageManager)>,<android.content.pm.PackageItemInfo: Drawable loadIcon(PackageManager)>,0,"{
    if (icon != 0) {
        Drawable dr = pm.getDrawable(packageName, icon, null);
        if (dr != null) {
            return dr;
        }
    }
    return pm.getDefaultActivityIcon();
}","{
    if (icon != 0) {
        Drawable dr = pm.getDrawable(packageName, icon, getApplicationInfo());
        if (dr != null) {
            return dr;
        }
    }
    return loadDefaultIcon(pm);
}",1,"/**
 * Retrieve the current graphical icon associated with this item.  This
 * will call back on the given PackageManager to load the icon from
 * the application.
 *
 * @param pm A PackageManager from which the icon can be loaded; usually
 * the PackageManager from which you originally retrieved this item.
 *
 * @return Returns a Drawable containing the item's icon.  If the
 * item does not have an icon, the default activity icon is returned.
 */
","/**
 * Retrieve the current graphical icon associated with this item.  This
 * will call back on the given PackageManager to load the icon from
 * the application.
 *
 * @param pm A PackageManager from which the icon can be loaded; usually
 * the PackageManager from which you originally retrieved this item.
 *
 * @return Returns a Drawable containing the item's icon.  If the
 * item does not have an icon, the item's default icon is returned
 * such as the default activity icon.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,4,5",1,"There's a change in the return statements: 'pm.getDrawable(packageName, icon, null)' has changed to 'pm.getDrawable(packageName, icon, getApplicationInfo())', and 'pm.getDefaultActivityIcon()' has changed to 'loadDefaultIcon(pm)', hence the change type is 1. The method parameter in 'pm.getDrawable()' also changed. The new function 'getApplicationInfo()' is being called now instead of null, the change type is 4. In addition, the dependent API 'pm.getDefaultActivityIcon()' has changed to 'loadDefaultIcon(pm)', hence the change type is 5.","Both return statements 'return dr' and 'return loadDefaultIcon(pm)' could potentially lead to different return values, thus causing a CI with type 1."
469,<android.pim.vcard.VCardParser_V21: void handleParams(String)>,7,8,<android.pim.vcard.VCardParser_V21: void handleParams(String)>,<android.pim.vcard.VCardParser_V21: void handleParams(String)>,0,"{
    String[] strArray = params.split(""="", 2);
    if (strArray.length == 2) {
        String paramName = strArray[0].trim();
        String paramValue = strArray[1].trim();
        if (paramName.equals(""TYPE"")) {
            handleType(paramValue);
        } else if (paramName.equals(""VALUE"")) {
            handleValue(paramValue);
        } else if (paramName.equals(""ENCODING"")) {
            handleEncoding(paramValue);
        } else if (paramName.equals(""CHARSET"")) {
            handleCharset(paramValue);
        } else if (paramName.equals(""LANGUAGE"")) {
            handleLanguage(paramValue);
        } else if (paramName.startsWith(""X-"")) {
            handleAnyParam(paramName, paramValue);
        } else {
            throw new VCardException(""Unknown type \"""" + paramName + ""\"""");
        }
    } else {
        handleType(strArray[0]);
    }
}","{
    String[] strArray = params.split(""="", 2);
    if (strArray.length == 2) {
        final String paramName = strArray[0].trim().toUpperCase();
        String paramValue = strArray[1].trim();
        if (paramName.equals(""TYPE"")) {
            handleType(paramValue);
        } else if (paramName.equals(""VALUE"")) {
            handleValue(paramValue);
        } else if (paramName.equals(""ENCODING"")) {
            handleEncoding(paramValue);
        } else if (paramName.equals(""CHARSET"")) {
            handleCharset(paramValue);
        } else if (paramName.equals(""LANGUAGE"")) {
            handleLanguage(paramValue);
        } else if (paramName.startsWith(""X-"")) {
            handleAnyParam(paramName, paramValue);
        } else {
            throw new VCardException(""Unknown type \"""" + paramName + ""\"""");
        }
    } else {
        handleParamWithoutName(strArray[0]);
    }
}",1,"/**
 * params      = "";"" [ws] paramlist
 * paramlist   = paramlist [ws] "";"" [ws] param
 * / param
 * param       = ""TYPE"" [ws] ""="" [ws] ptypeval
 * / ""VALUE"" [ws] ""="" [ws] pvalueval
 * / ""ENCODING"" [ws] ""="" [ws] pencodingval
 * / ""CHARSET"" [ws] ""="" [ws] charsetval
 * / ""LANGUAGE"" [ws] ""="" [ws] langval
 * / ""X-"" word [ws] ""="" [ws] word
 * / knowntype
 */
","/**
 * params     = "";"" [ws] paramlist
 * paramlist  = paramlist [ws] "";"" [ws] param
 * / param
 * param      = ""TYPE"" [ws] ""="" [ws] ptypeval
 * / ""VALUE"" [ws] ""="" [ws] pvalueval
 * / ""ENCODING"" [ws] ""="" [ws] pencodingval
 * / ""CHARSET"" [ws] ""="" [ws] charsetval
 * / ""LANGUAGE"" [ws] ""="" [ws] langval
 * / ""X-"" word [ws] ""="" [ws] word
 * / knowntype
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3,4","1,2","Since a new statement paramName.toUpperCase() has been introduced and the method handleParamWithoutName() has replaced handleType() function, the code change types are 1, 3 and 4.","Due to the change of function handleType to handleParamWithoutName and the addition of paramName.toUpperCase(), this could result in a different return value thus the CI type is 1. Also,the change in control flow due to the introduction of toUpperCase() might result in the throwing of a different exception, so the CI type is also 2."
471,"<android.database.sqlite.SQLiteDatabase: void execSQL(String,Object[])>",7,8,"<android.database.sqlite.SQLiteDatabase: void execSQL(String,Object[])>","<android.database.sqlite.SQLiteDatabase: void execSQL(String,Object[])>",0,"{
    if (bindArgs == null) {
        throw new IllegalArgumentException(""Empty bindArgs"");
    }
    boolean logStats = mLogStats;
    long timeStart = logStats ? SystemClock.elapsedRealtime() : 0;
    lock();
    SQLiteStatement statement = null;
    try {
        statement = compileStatement(sql);
        if (bindArgs != null) {
            int numArgs = bindArgs.length;
            for (int i = 0; i < numArgs; i++) {
                DatabaseUtils.bindObjectToProgram(statement, i + 1, bindArgs[i]);
            }
        }
        statement.execute();
    } catch (SQLiteDatabaseCorruptException e) {
        onCorruption();
        throw e;
    } finally {
        if (statement != null) {
            statement.close();
        }
        unlock();
    }
    if (logStats) {
        logTimeStat(false, /* not a read */
        timeStart, SystemClock.elapsedRealtime());
    }
}","{
    if (bindArgs == null) {
        throw new IllegalArgumentException(""Empty bindArgs"");
    }
    long timeStart = SystemClock.uptimeMillis();
    lock();
    if (!isOpen()) {
        throw new IllegalStateException(""database not open"");
    }
    SQLiteStatement statement = null;
    try {
        statement = compileStatement(sql);
        if (bindArgs != null) {
            int numArgs = bindArgs.length;
            for (int i = 0; i < numArgs; i++) {
                DatabaseUtils.bindObjectToProgram(statement, i + 1, bindArgs[i]);
            }
        }
        statement.execute();
    } catch (SQLiteDatabaseCorruptException e) {
        onCorruption();
        throw e;
    } finally {
        if (statement != null) {
            statement.close();
        }
        unlock();
    }
    logTimeStat(sql, timeStart);
}",1,"/**
 * Execute a single SQL statement that is not a query. For example, CREATE
 * TABLE, DELETE, INSERT, etc. Multiple statements separated by ;s are not
 * supported. it takes a write lock,
 *
 * @param sql
 * @param bindArgs only byte[], String, Long and Double are supported in bindArgs.
 * @throws SQLException If the SQL string is invalid for some reason
 */
","/**
 * Execute a single SQL statement that is not a query. For example, CREATE
 * TABLE, DELETE, INSERT, etc. Multiple statements separated by ;s are not
 * supported. it takes a write lock,
 *
 * @param sql
 * @param bindArgs only byte[], String, Long and Double are supported in bindArgs.
 * @throws SQLException If the SQL string is invalid for some reason
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,2,3,4","1,2",There are several changes in the code: ,"3) Added a new if condition (isOpen()). If the database is not open, the method throws a new IllegalStateException(""database not open""). "
473,<android.widget.AbsListView.FlingRunnable: void run()>,7,8,<android.widget.AbsListView.FlingRunnable: void run()>,<android.widget.AbsListView.FlingRunnable: void run()>,0,"{
    if (mTouchMode != TOUCH_MODE_FLING) {
        return;
    }
    if (mItemCount == 0 || getChildCount() == 0) {
        endFling();
        return;
    }
    final Scroller scroller = mScroller;
    boolean more = scroller.computeScrollOffset();
    final int y = scroller.getCurrY();
    // Flip sign to convert finger direction to list items direction
    // (e.g. finger moving down means list is moving towards the top)
    int delta = mLastFlingY - y;
    // Pretend that each frame of a fling scroll is a touch scroll
    if (delta > 0) {
        // List is moving towards the top. Use first view as mMotionPosition
        mMotionPosition = mFirstPosition;
        final View firstView = getChildAt(0);
        mMotionViewOriginalTop = firstView.getTop();
        // Don't fling more than 1 screen
        delta = Math.min(getHeight() - mPaddingBottom - mPaddingTop - 1, delta);
    } else {
        // List is moving towards the bottom. Use last view as mMotionPosition
        int offsetToLast = getChildCount() - 1;
        mMotionPosition = mFirstPosition + offsetToLast;
        final View lastView = getChildAt(offsetToLast);
        mMotionViewOriginalTop = lastView.getTop();
        // Don't fling more than 1 screen
        delta = Math.max(-(getHeight() - mPaddingBottom - mPaddingTop - 1), delta);
    }
    trackMotionScroll(delta, delta);
    // Check to see if we have bumped into the scroll limit
    View motionView = getChildAt(mMotionPosition - mFirstPosition);
    if (motionView != null) {
        // supposed to be
        if (motionView.getTop() != mMotionViewNewTop) {
            more = false;
        }
    }
    if (more) {
        invalidate();
        mLastFlingY = y;
        post(this);
    } else {
        endFling();
        if (PROFILE_FLINGING) {
            if (mFlingProfilingStarted) {
                Debug.stopMethodTracing();
                mFlingProfilingStarted = false;
            }
        }
    }
}","{
    switch(mTouchMode) {
        default:
            return;
        case TOUCH_MODE_FLING:
            {
                if (mItemCount == 0 || getChildCount() == 0) {
                    endFling();
                    return;
                }
                final Scroller scroller = mScroller;
                boolean more = scroller.computeScrollOffset();
                final int y = scroller.getCurrY();
                // Flip sign to convert finger direction to list items direction
                // (e.g. finger moving down means list is moving towards the top)
                int delta = mLastFlingY - y;
                // Pretend that each frame of a fling scroll is a touch scroll
                if (delta > 0) {
                    // List is moving towards the top. Use first view as mMotionPosition
                    mMotionPosition = mFirstPosition;
                    final View firstView = getChildAt(0);
                    mMotionViewOriginalTop = firstView.getTop();
                    // Don't fling more than 1 screen
                    delta = Math.min(getHeight() - mPaddingBottom - mPaddingTop - 1, delta);
                } else {
                    // List is moving towards the bottom. Use last view as mMotionPosition
                    int offsetToLast = getChildCount() - 1;
                    mMotionPosition = mFirstPosition + offsetToLast;
                    final View lastView = getChildAt(offsetToLast);
                    mMotionViewOriginalTop = lastView.getTop();
                    // Don't fling more than 1 screen
                    delta = Math.max(-(getHeight() - mPaddingBottom - mPaddingTop - 1), delta);
                }
                final boolean atEnd = trackMotionScroll(delta, delta);
                if (more && !atEnd) {
                    invalidate();
                    mLastFlingY = y;
                    post(this);
                } else {
                    endFling();
                    if (PROFILE_FLINGING) {
                        if (mFlingProfilingStarted) {
                            Debug.stopMethodTracing();
                            mFlingProfilingStarted = false;
                        }
                    }
                }
                break;
            }
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"3,4",0,"The code has changed from simple 'if' conditions to a 'switch' case in the latest version. Apart from this, there is a slight change to the statement where 'trackMotionScroll(delta, delta)' is now getting assigned to 'atEnd' which is new in the newer version. Hence, the change type is 3,4.","Even though, the 'if' condition changed to 'switch' case and a new variable 'atEnd' is introduced, these changes do not make the API return a different value or throws a different exception. Therefore, no Compatibility Issue exists, and the CI type is 0."
474,"<android.text.util.Linkify: boolean addLinks(Spannable,int)>",7,8,"<android.text.util.Linkify: boolean addLinks(Spannable,int)>","<android.text.util.Linkify: boolean addLinks(Spannable,int)>",0,"{
    if (mask == 0) {
        return false;
    }
    URLSpan[] old = text.getSpans(0, text.length(), URLSpan.class);
    for (int i = old.length - 1; i >= 0; i--) {
        text.removeSpan(old[i]);
    }
    ArrayList<LinkSpec> links = new ArrayList<LinkSpec>();
    if ((mask & WEB_URLS) != 0) {
        gatherLinks(links, text, Regex.WEB_URL_PATTERN, new String[] { ""http://"", ""https://"", ""rtsp://"" }, sUrlMatchFilter, null);
    }
    if ((mask & EMAIL_ADDRESSES) != 0) {
        gatherLinks(links, text, Regex.EMAIL_ADDRESS_PATTERN, new String[] { ""mailto:"" }, null, null);
    }
    if ((mask & PHONE_NUMBERS) != 0) {
        gatherLinks(links, text, Regex.PHONE_PATTERN, new String[] { ""tel:"" }, sPhoneNumberMatchFilter, sPhoneNumberTransformFilter);
    }
    if ((mask & MAP_ADDRESSES) != 0) {
        gatherMapLinks(links, text);
    }
    pruneOverlaps(links);
    if (links.size() == 0) {
        return false;
    }
    for (LinkSpec link : links) {
        applyLink(link.url, link.start, link.end, text);
    }
    return true;
}","{
    if (mask == 0) {
        return false;
    }
    URLSpan[] old = text.getSpans(0, text.length(), URLSpan.class);
    for (int i = old.length - 1; i >= 0; i--) {
        text.removeSpan(old[i]);
    }
    ArrayList<LinkSpec> links = new ArrayList<LinkSpec>();
    if ((mask & WEB_URLS) != 0) {
        gatherLinks(links, text, Patterns.WEB_URL, new String[] { ""http://"", ""https://"", ""rtsp://"" }, sUrlMatchFilter, null);
    }
    if ((mask & EMAIL_ADDRESSES) != 0) {
        gatherLinks(links, text, Patterns.EMAIL_ADDRESS, new String[] { ""mailto:"" }, null, null);
    }
    if ((mask & PHONE_NUMBERS) != 0) {
        gatherLinks(links, text, Patterns.PHONE, new String[] { ""tel:"" }, sPhoneNumberMatchFilter, sPhoneNumberTransformFilter);
    }
    if ((mask & MAP_ADDRESSES) != 0) {
        gatherMapLinks(links, text);
    }
    pruneOverlaps(links);
    if (links.size() == 0) {
        return false;
    }
    for (LinkSpec link : links) {
        applyLink(link.url, link.start, link.end, text);
    }
    return true;
}",1,"/**
 * Scans the text of the provided Spannable and turns all occurrences
 * of the link types indicated in the mask into clickable links.
 * If the mask is nonzero, it also removes any existing URLSpans
 * attached to the Spannable, to avoid problems if you call it
 * repeatedly on the same text.
 */
","/**
 * Scans the text of the provided Spannable and turns all occurrences
 * of the link types indicated in the mask into clickable links.
 * If the mask is nonzero, it also removes any existing URLSpans
 * attached to the Spannable, to avoid problems if you call it
 * repeatedly on the same text.
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,1,"We see the dependent APIs being used inside `gatherLinks()` method, such as `Regex.WEB_URL_PATTERN`, `Regex.EMAIL_ADDRESS_PATTERN` and `Regex.PHONE_PATTERN` have been changed to `Patterns.WEB_URL`, `Patterns.EMAIL_ADDRESS` and `Patterns.PHONE`, respectively. Hence, the change type is 5.","Even though the APIs look similar, they still might behave or return values differently. Therefore, changes in dependent APIs could potentially return different variables, leading to a CI of type 1."
475,"<android.widget.AbsListView: boolean sendToTextFilter(int,int,KeyEvent)>",7,8,"<android.widget.AbsListView: boolean sendToTextFilter(int,int,KeyEvent)>","<android.widget.AbsListView: boolean sendToTextFilter(int,int,KeyEvent)>",0,"{
    if (!acceptFilter()) {
        return false;
    }
    boolean handled = false;
    boolean okToSend = true;
    switch(keyCode) {
        case KeyEvent.KEYCODE_DPAD_UP:
        case KeyEvent.KEYCODE_DPAD_DOWN:
        case KeyEvent.KEYCODE_DPAD_LEFT:
        case KeyEvent.KEYCODE_DPAD_RIGHT:
        case KeyEvent.KEYCODE_DPAD_CENTER:
        case KeyEvent.KEYCODE_ENTER:
            okToSend = false;
            break;
        case KeyEvent.KEYCODE_BACK:
            if (mFiltered && mPopup != null && mPopup.isShowing()) {
                if (event.getAction() == KeyEvent.ACTION_DOWN && event.getRepeatCount() == 0) {
                    getKeyDispatcherState().startTracking(event, this);
                    handled = true;
                } else if (event.getAction() == KeyEvent.ACTION_UP && event.isTracking() && !event.isCanceled()) {
                    handled = true;
                    mTextFilter.setText("""");
                }
            }
            okToSend = false;
            break;
        case KeyEvent.KEYCODE_SPACE:
            // Only send spaces once we are filtered
            okToSend = mFiltered = true;
            break;
    }
    if (okToSend) {
        createTextFilter(true);
        KeyEvent forwardEvent = event;
        if (forwardEvent.getRepeatCount() > 0) {
            forwardEvent = KeyEvent.changeTimeRepeat(event, event.getEventTime(), 0);
        }
        int action = event.getAction();
        switch(action) {
            case KeyEvent.ACTION_DOWN:
                handled = mTextFilter.onKeyDown(keyCode, forwardEvent);
                break;
            case KeyEvent.ACTION_UP:
                handled = mTextFilter.onKeyUp(keyCode, forwardEvent);
                break;
            case KeyEvent.ACTION_MULTIPLE:
                handled = mTextFilter.onKeyMultiple(keyCode, count, event);
                break;
        }
    }
    return handled;
}","{
    if (!acceptFilter()) {
        return false;
    }
    boolean handled = false;
    boolean okToSend = true;
    switch(keyCode) {
        case KeyEvent.KEYCODE_DPAD_UP:
        case KeyEvent.KEYCODE_DPAD_DOWN:
        case KeyEvent.KEYCODE_DPAD_LEFT:
        case KeyEvent.KEYCODE_DPAD_RIGHT:
        case KeyEvent.KEYCODE_DPAD_CENTER:
        case KeyEvent.KEYCODE_ENTER:
            okToSend = false;
            break;
        case KeyEvent.KEYCODE_BACK:
            if (mFiltered && mPopup != null && mPopup.isShowing()) {
                if (event.getAction() == KeyEvent.ACTION_DOWN && event.getRepeatCount() == 0) {
                    getKeyDispatcherState().startTracking(event, this);
                    handled = true;
                } else if (event.getAction() == KeyEvent.ACTION_UP && event.isTracking() && !event.isCanceled()) {
                    handled = true;
                    mTextFilter.setText("""");
                }
            }
            okToSend = false;
            break;
        case KeyEvent.KEYCODE_SPACE:
            // Only send spaces once we are filtered
            okToSend = mFiltered;
            break;
    }
    if (okToSend) {
        createTextFilter(true);
        KeyEvent forwardEvent = event;
        if (forwardEvent.getRepeatCount() > 0) {
            forwardEvent = KeyEvent.changeTimeRepeat(event, event.getEventTime(), 0);
        }
        int action = event.getAction();
        switch(action) {
            case KeyEvent.ACTION_DOWN:
                handled = mTextFilter.onKeyDown(keyCode, forwardEvent);
                break;
            case KeyEvent.ACTION_UP:
                handled = mTextFilter.onKeyUp(keyCode, forwardEvent);
                break;
            case KeyEvent.ACTION_MULTIPLE:
                handled = mTextFilter.onKeyMultiple(keyCode, count, event);
                break;
        }
    }
    return handled;
}",1,"/**
 * Sends a key to the text filter window
 *
 * @param keyCode The keycode for the event
 * @param event The actual key event
 *
 * @return True if the text filter handled the event, false otherwise.
 */
","/**
 * Sends a key to the text filter window
 *
 * @param keyCode The keycode for the event
 * @param event The actual key event
 *
 * @return True if the text filter handled the event, false otherwise.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3",1,"In the switch statement, the assignment of variable 'okToSend' in KeyEvent.KEYCODE_SPACE has changed. This indicates it is a control dependency change (type 3). Moreover, because we also have modification in the resulting return value (type 1).","As the assignment of variable 'okToSend' has changed, it may affect the control branches that subsequently execute and the final return value, which leads to a compatibility issue (type 1)."
476,<android.app.Activity: void performRestart()>,7,8,<android.app.Activity: void performRestart()>,<android.app.Activity: void performRestart()>,0,"{
    final int N = mManagedCursors.size();
    for (int i = 0; i < N; i++) {
        ManagedCursor mc = mManagedCursors.get(i);
        if (mc.mReleased || mc.mUpdated) {
            mc.mCursor.requery();
            mc.mReleased = false;
            mc.mUpdated = false;
        }
    }
    if (mStopped) {
        mStopped = false;
        mCalled = false;
        mInstrumentation.callActivityOnRestart(this);
        if (!mCalled) {
            throw new SuperNotCalledException(""Activity "" + mComponent.toShortString() + "" did not call through to super.onRestart()"");
        }
        performStart();
    }
}","{
    synchronized (mManagedCursors) {
        final int N = mManagedCursors.size();
        for (int i = 0; i < N; i++) {
            ManagedCursor mc = mManagedCursors.get(i);
            if (mc.mReleased || mc.mUpdated) {
                mc.mCursor.requery();
                mc.mReleased = false;
                mc.mUpdated = false;
            }
        }
    }
    if (mStopped) {
        mStopped = false;
        mCalled = false;
        mInstrumentation.callActivityOnRestart(this);
        if (!mCalled) {
            throw new SuperNotCalledException(""Activity "" + mComponent.toShortString() + "" did not call through to super.onRestart()"");
        }
        performStart();
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,3,0,"The code responsible for handling ManagedCursor objects is now enclosed in a synchronized block, so the code change type is 3.","The synchronization does not affect the functionality of the method or the results returned, so no Compatibility Issue (CI) exists."
479,<android.accounts.AccountManagerService.Session: void onResult(Bundle)>,7,8,<android.accounts.AccountManagerService.Session: void onResult(Bundle)>,<android.accounts.AccountManagerService.Session: void onResult(Bundle)>,0,"{
    mNumResults++;
    if (result != null && !TextUtils.isEmpty(result.getString(AccountManager.KEY_AUTHTOKEN))) {
        String accountName = result.getString(AccountManager.KEY_ACCOUNT_NAME);
        String accountType = result.getString(AccountManager.KEY_ACCOUNT_TYPE);
        if (!TextUtils.isEmpty(accountName) && !TextUtils.isEmpty(accountType)) {
            Account account = new Account(accountName, accountType);
            cancelNotification(getSigninRequiredNotificationId(account));
        }
    }
    IAccountManagerResponse response;
    if (mExpectActivityLaunch && result != null && result.containsKey(AccountManager.KEY_INTENT)) {
        response = mResponse;
    } else {
        response = getResponseAndClose();
    }
    if (response != null) {
        try {
            if (result == null) {
                response.onError(AccountManager.ERROR_CODE_INVALID_RESPONSE, ""null bundle returned"");
            } else {
                response.onResult(result);
            }
        } catch (RemoteException e) {
            // if the caller is dead then there is no one to care about remote exceptions
            if (Log.isLoggable(TAG, Log.VERBOSE)) {
                Log.v(TAG, ""failure while notifying response"", e);
            }
        }
    }
}","{
    mNumResults++;
    if (result != null && !TextUtils.isEmpty(result.getString(AccountManager.KEY_AUTHTOKEN))) {
        String accountName = result.getString(AccountManager.KEY_ACCOUNT_NAME);
        String accountType = result.getString(AccountManager.KEY_ACCOUNT_TYPE);
        if (!TextUtils.isEmpty(accountName) && !TextUtils.isEmpty(accountType)) {
            Account account = new Account(accountName, accountType);
            cancelNotification(getSigninRequiredNotificationId(account));
        }
    }
    IAccountManagerResponse response;
    if (mExpectActivityLaunch && result != null && result.containsKey(AccountManager.KEY_INTENT)) {
        response = mResponse;
    } else {
        response = getResponseAndClose();
    }
    if (response != null) {
        try {
            if (result == null) {
                response.onError(AccountManager.ERROR_CODE_INVALID_RESPONSE, ""null bundle returned"");
            } else {
                if (mStripAuthTokenFromResult) {
                    result.remove(AccountManager.KEY_AUTHTOKEN);
                }
                response.onResult(result);
            }
        } catch (RemoteException e) {
            // if the caller is dead then there is no one to care about remote exceptions
            if (Log.isLoggable(TAG, Log.VERBOSE)) {
                Log.v(TAG, ""failure while notifying response"", e);
            }
        }
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"3,4",1,"There is an added control statement ""if (mStripAuthTokenFromResult) { result.remove(AccountManager.KEY_AUTHTOKEN) }"" before 'response.onResult(result);', which modifies the 'result' that is returned. Thus, the code change type is 3,4.","The extra control statement and the modification on 'result' will potentially lead to different return values (due to the fact that the authToken may be removed from 'result'), making the CI type 1."
480,<android.content.SyncResult: void clear()>,7,8,<android.content.SyncResult: void clear()>,<android.content.SyncResult: void clear()>,0,"{
    if (syncAlreadyInProgress) {
        throw new UnsupportedOperationException(""you are not allowed to clear the ALREADY_IN_PROGRESS SyncStats"");
    }
    tooManyDeletions = false;
    tooManyRetries = false;
    databaseError = false;
    fullSyncRequested = false;
    partialSyncUnavailable = false;
    moreRecordsToGet = false;
    stats.clear();
}","{
    if (syncAlreadyInProgress) {
        throw new UnsupportedOperationException(""you are not allowed to clear the ALREADY_IN_PROGRESS SyncStats"");
    }
    tooManyDeletions = false;
    tooManyRetries = false;
    databaseError = false;
    fullSyncRequested = false;
    partialSyncUnavailable = false;
    moreRecordsToGet = false;
    delayUntil = 0;
    stats.clear();
}",1,,"/**
 * Clears the SyncResult to a clean state. Throws an {@link UnsupportedOperationException}
 * if this is called when {@link #syncAlreadyInProgress} is set.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,No Compatibility Issue exist,Another statement 'delayUntil = 0' has been added in the late version. So the code change type is 4 (Other statement changed).,"The change 'delayUntil = 0' added in the late version didn't affect the return type or value, and it didn't change the set of exceptions that the method may throw. So, there's no compatibility issue."
482,<android.view.WindowManager.LayoutParams: int copyFrom(LayoutParams)>,7,8,<android.view.WindowManager.LayoutParams: int copyFrom(LayoutParams)>,<android.view.WindowManager.LayoutParams: int copyFrom(LayoutParams)>,0,"{
    int changes = 0;
    if (width != o.width) {
        width = o.width;
        changes |= LAYOUT_CHANGED;
    }
    if (height != o.height) {
        height = o.height;
        changes |= LAYOUT_CHANGED;
    }
    if (x != o.x) {
        x = o.x;
        changes |= LAYOUT_CHANGED;
    }
    if (y != o.y) {
        y = o.y;
        changes |= LAYOUT_CHANGED;
    }
    if (horizontalWeight != o.horizontalWeight) {
        horizontalWeight = o.horizontalWeight;
        changes |= LAYOUT_CHANGED;
    }
    if (verticalWeight != o.verticalWeight) {
        verticalWeight = o.verticalWeight;
        changes |= LAYOUT_CHANGED;
    }
    if (horizontalMargin != o.horizontalMargin) {
        horizontalMargin = o.horizontalMargin;
        changes |= LAYOUT_CHANGED;
    }
    if (verticalMargin != o.verticalMargin) {
        verticalMargin = o.verticalMargin;
        changes |= LAYOUT_CHANGED;
    }
    if (type != o.type) {
        type = o.type;
        changes |= TYPE_CHANGED;
    }
    if (memoryType != o.memoryType) {
        memoryType = o.memoryType;
        changes |= MEMORY_TYPE_CHANGED;
    }
    if (flags != o.flags) {
        flags = o.flags;
        changes |= FLAGS_CHANGED;
    }
    if (softInputMode != o.softInputMode) {
        softInputMode = o.softInputMode;
        changes |= SOFT_INPUT_MODE_CHANGED;
    }
    if (gravity != o.gravity) {
        gravity = o.gravity;
        changes |= LAYOUT_CHANGED;
    }
    if (horizontalMargin != o.horizontalMargin) {
        horizontalMargin = o.horizontalMargin;
        changes |= LAYOUT_CHANGED;
    }
    if (verticalMargin != o.verticalMargin) {
        verticalMargin = o.verticalMargin;
        changes |= LAYOUT_CHANGED;
    }
    if (format != o.format) {
        format = o.format;
        changes |= FORMAT_CHANGED;
    }
    if (windowAnimations != o.windowAnimations) {
        windowAnimations = o.windowAnimations;
        changes |= ANIMATION_CHANGED;
    }
    if (token == null) {
        // NOTE: token only copied if the recipient doesn't
        // already have one.
        token = o.token;
    }
    if (packageName == null) {
        // NOTE: packageName only copied if the recipient doesn't
        // already have one.
        packageName = o.packageName;
    }
    if (!mTitle.equals(o.mTitle)) {
        mTitle = o.mTitle;
        changes |= TITLE_CHANGED;
    }
    if (alpha != o.alpha) {
        alpha = o.alpha;
        changes |= ALPHA_CHANGED;
    }
    if (dimAmount != o.dimAmount) {
        dimAmount = o.dimAmount;
        changes |= DIM_AMOUNT_CHANGED;
    }
    if (screenBrightness != o.screenBrightness) {
        screenBrightness = o.screenBrightness;
        changes |= SCREEN_BRIGHTNESS_CHANGED;
    }
    if (screenOrientation != o.screenOrientation) {
        screenOrientation = o.screenOrientation;
        changes |= SCREEN_ORIENTATION_CHANGED;
    }
    return changes;
}","{
    int changes = 0;
    if (width != o.width) {
        width = o.width;
        changes |= LAYOUT_CHANGED;
    }
    if (height != o.height) {
        height = o.height;
        changes |= LAYOUT_CHANGED;
    }
    if (x != o.x) {
        x = o.x;
        changes |= LAYOUT_CHANGED;
    }
    if (y != o.y) {
        y = o.y;
        changes |= LAYOUT_CHANGED;
    }
    if (horizontalWeight != o.horizontalWeight) {
        horizontalWeight = o.horizontalWeight;
        changes |= LAYOUT_CHANGED;
    }
    if (verticalWeight != o.verticalWeight) {
        verticalWeight = o.verticalWeight;
        changes |= LAYOUT_CHANGED;
    }
    if (horizontalMargin != o.horizontalMargin) {
        horizontalMargin = o.horizontalMargin;
        changes |= LAYOUT_CHANGED;
    }
    if (verticalMargin != o.verticalMargin) {
        verticalMargin = o.verticalMargin;
        changes |= LAYOUT_CHANGED;
    }
    if (type != o.type) {
        type = o.type;
        changes |= TYPE_CHANGED;
    }
    if (memoryType != o.memoryType) {
        memoryType = o.memoryType;
        changes |= MEMORY_TYPE_CHANGED;
    }
    if (flags != o.flags) {
        flags = o.flags;
        changes |= FLAGS_CHANGED;
    }
    if (softInputMode != o.softInputMode) {
        softInputMode = o.softInputMode;
        changes |= SOFT_INPUT_MODE_CHANGED;
    }
    if (gravity != o.gravity) {
        gravity = o.gravity;
        changes |= LAYOUT_CHANGED;
    }
    if (horizontalMargin != o.horizontalMargin) {
        horizontalMargin = o.horizontalMargin;
        changes |= LAYOUT_CHANGED;
    }
    if (verticalMargin != o.verticalMargin) {
        verticalMargin = o.verticalMargin;
        changes |= LAYOUT_CHANGED;
    }
    if (format != o.format) {
        format = o.format;
        changes |= FORMAT_CHANGED;
    }
    if (windowAnimations != o.windowAnimations) {
        windowAnimations = o.windowAnimations;
        changes |= ANIMATION_CHANGED;
    }
    if (token == null) {
        // NOTE: token only copied if the recipient doesn't
        // already have one.
        token = o.token;
    }
    if (packageName == null) {
        // NOTE: packageName only copied if the recipient doesn't
        // already have one.
        packageName = o.packageName;
    }
    if (!mTitle.equals(o.mTitle)) {
        mTitle = o.mTitle;
        changes |= TITLE_CHANGED;
    }
    if (alpha != o.alpha) {
        alpha = o.alpha;
        changes |= ALPHA_CHANGED;
    }
    if (dimAmount != o.dimAmount) {
        dimAmount = o.dimAmount;
        changes |= DIM_AMOUNT_CHANGED;
    }
    if (screenBrightness != o.screenBrightness) {
        screenBrightness = o.screenBrightness;
        changes |= SCREEN_BRIGHTNESS_CHANGED;
    }
    if (buttonBrightness != o.buttonBrightness) {
        buttonBrightness = o.buttonBrightness;
        changes |= BUTTON_BRIGHTNESS_CHANGED;
    }
    if (screenOrientation != o.screenOrientation) {
        screenOrientation = o.screenOrientation;
        changes |= SCREEN_ORIENTATION_CHANGED;
    }
    return changes;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"1,3",1,"There is a a new condition added for buttonBrightness in the late version code, so the change type is 3. Since return statement is also affected by this condition, change type 1 is also considered.","The addition of the new condition can make the API return a different value, so CI type is 1."
483,<android.content.res.Configuration: int updateFrom(Configuration)>,7,8,<android.content.res.Configuration: int updateFrom(Configuration)>,<android.content.res.Configuration: int updateFrom(Configuration)>,0,"{
    int changed = 0;
    if (delta.fontScale > 0 && fontScale != delta.fontScale) {
        changed |= ActivityInfo.CONFIG_FONT_SCALE;
        fontScale = delta.fontScale;
    }
    if (delta.mcc != 0 && mcc != delta.mcc) {
        changed |= ActivityInfo.CONFIG_MCC;
        mcc = delta.mcc;
    }
    if (delta.mnc != 0 && mnc != delta.mnc) {
        changed |= ActivityInfo.CONFIG_MNC;
        mnc = delta.mnc;
    }
    if (delta.locale != null && (locale == null || !locale.equals(delta.locale))) {
        changed |= ActivityInfo.CONFIG_LOCALE;
        locale = delta.locale != null ? (Locale) delta.locale.clone() : null;
    }
    if (delta.userSetLocale && (!userSetLocale || ((changed & ActivityInfo.CONFIG_LOCALE) != 0))) {
        userSetLocale = true;
        changed |= ActivityInfo.CONFIG_LOCALE;
    }
    if (delta.touchscreen != TOUCHSCREEN_UNDEFINED && touchscreen != delta.touchscreen) {
        changed |= ActivityInfo.CONFIG_TOUCHSCREEN;
        touchscreen = delta.touchscreen;
    }
    if (delta.keyboard != KEYBOARD_UNDEFINED && keyboard != delta.keyboard) {
        changed |= ActivityInfo.CONFIG_KEYBOARD;
        keyboard = delta.keyboard;
    }
    if (delta.keyboardHidden != KEYBOARDHIDDEN_UNDEFINED && keyboardHidden != delta.keyboardHidden) {
        changed |= ActivityInfo.CONFIG_KEYBOARD_HIDDEN;
        keyboardHidden = delta.keyboardHidden;
    }
    if (delta.hardKeyboardHidden != HARDKEYBOARDHIDDEN_UNDEFINED && hardKeyboardHidden != delta.hardKeyboardHidden) {
        changed |= ActivityInfo.CONFIG_KEYBOARD_HIDDEN;
        hardKeyboardHidden = delta.hardKeyboardHidden;
    }
    if (delta.navigation != NAVIGATION_UNDEFINED && navigation != delta.navigation) {
        changed |= ActivityInfo.CONFIG_NAVIGATION;
        navigation = delta.navigation;
    }
    if (delta.navigationHidden != NAVIGATIONHIDDEN_UNDEFINED && navigationHidden != delta.navigationHidden) {
        changed |= ActivityInfo.CONFIG_KEYBOARD_HIDDEN;
        navigationHidden = delta.navigationHidden;
    }
    if (delta.orientation != ORIENTATION_UNDEFINED && orientation != delta.orientation) {
        changed |= ActivityInfo.CONFIG_ORIENTATION;
        orientation = delta.orientation;
    }
    if (delta.screenLayout != SCREENLAYOUT_SIZE_UNDEFINED && screenLayout != delta.screenLayout) {
        changed |= ActivityInfo.CONFIG_SCREEN_LAYOUT;
        screenLayout = delta.screenLayout;
    }
    return changed;
}","{
    int changed = 0;
    if (delta.fontScale > 0 && fontScale != delta.fontScale) {
        changed |= ActivityInfo.CONFIG_FONT_SCALE;
        fontScale = delta.fontScale;
    }
    if (delta.mcc != 0 && mcc != delta.mcc) {
        changed |= ActivityInfo.CONFIG_MCC;
        mcc = delta.mcc;
    }
    if (delta.mnc != 0 && mnc != delta.mnc) {
        changed |= ActivityInfo.CONFIG_MNC;
        mnc = delta.mnc;
    }
    if (delta.locale != null && (locale == null || !locale.equals(delta.locale))) {
        changed |= ActivityInfo.CONFIG_LOCALE;
        locale = delta.locale != null ? (Locale) delta.locale.clone() : null;
    }
    if (delta.userSetLocale && (!userSetLocale || ((changed & ActivityInfo.CONFIG_LOCALE) != 0))) {
        userSetLocale = true;
        changed |= ActivityInfo.CONFIG_LOCALE;
    }
    if (delta.touchscreen != TOUCHSCREEN_UNDEFINED && touchscreen != delta.touchscreen) {
        changed |= ActivityInfo.CONFIG_TOUCHSCREEN;
        touchscreen = delta.touchscreen;
    }
    if (delta.keyboard != KEYBOARD_UNDEFINED && keyboard != delta.keyboard) {
        changed |= ActivityInfo.CONFIG_KEYBOARD;
        keyboard = delta.keyboard;
    }
    if (delta.keyboardHidden != KEYBOARDHIDDEN_UNDEFINED && keyboardHidden != delta.keyboardHidden) {
        changed |= ActivityInfo.CONFIG_KEYBOARD_HIDDEN;
        keyboardHidden = delta.keyboardHidden;
    }
    if (delta.hardKeyboardHidden != HARDKEYBOARDHIDDEN_UNDEFINED && hardKeyboardHidden != delta.hardKeyboardHidden) {
        changed |= ActivityInfo.CONFIG_KEYBOARD_HIDDEN;
        hardKeyboardHidden = delta.hardKeyboardHidden;
    }
    if (delta.navigation != NAVIGATION_UNDEFINED && navigation != delta.navigation) {
        changed |= ActivityInfo.CONFIG_NAVIGATION;
        navigation = delta.navigation;
    }
    if (delta.navigationHidden != NAVIGATIONHIDDEN_UNDEFINED && navigationHidden != delta.navigationHidden) {
        changed |= ActivityInfo.CONFIG_KEYBOARD_HIDDEN;
        navigationHidden = delta.navigationHidden;
    }
    if (delta.orientation != ORIENTATION_UNDEFINED && orientation != delta.orientation) {
        changed |= ActivityInfo.CONFIG_ORIENTATION;
        orientation = delta.orientation;
    }
    if (delta.screenLayout != SCREENLAYOUT_SIZE_UNDEFINED && screenLayout != delta.screenLayout) {
        changed |= ActivityInfo.CONFIG_SCREEN_LAYOUT;
        screenLayout = delta.screenLayout;
    }
    if (delta.uiMode != (UI_MODE_TYPE_UNDEFINED | UI_MODE_NIGHT_UNDEFINED) && uiMode != delta.uiMode) {
        changed |= ActivityInfo.CONFIG_UI_MODE;
        if ((delta.uiMode & UI_MODE_TYPE_MASK) != UI_MODE_TYPE_UNDEFINED) {
            uiMode = (uiMode & ~UI_MODE_TYPE_MASK) | (delta.uiMode & UI_MODE_TYPE_MASK);
        }
        if ((delta.uiMode & UI_MODE_NIGHT_MASK) != UI_MODE_NIGHT_UNDEFINED) {
            uiMode = (uiMode & ~UI_MODE_NIGHT_MASK) | (delta.uiMode & UI_MODE_NIGHT_MASK);
        }
    }
    if (delta.seq != 0) {
        seq = delta.seq;
    }
    return changed;
}",1,"/**
 * Copy the fields from delta into this Configuration object, keeping
 * track of which ones have changed.  Any undefined fields in
 * <var>delta</var> are ignored and not copied in to the current
 * Configuration.
 * @return Returns a bit mask of the changed fields, as per
 * {@link #diff}.
 */
","/**
 * Copy the fields from delta into this Configuration object, keeping
 * track of which ones have changed.  Any undefined fields in
 * <var>delta</var> are ignored and not copied in to the current
 * Configuration.
 * @return Returns a bit mask of the changed fields, as per
 * {@link #diff}.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3",1,"Several new conditions and assignments are introduced in 'Late_Implementation' compared to 'Early_Implementation'. These include the updates regarding 'uiMode' and 'seq', which leads to the change in the returned value 'changed'; thus the code change type is 1,3.","The addition of new conditions in 'Late_Implementation' change the way the 'changed' value is calculated and returned. As it affects the return values of the method, the CI type is 1."
484,"<android.text.TextUtils: int getCapsMode(CharSequence,int,int)>",7,8,"<android.text.TextUtils: int getCapsMode(CharSequence,int,int)>","<android.text.TextUtils: int getCapsMode(CharSequence,int,int)>",0,"{
    int i;
    char c;
    int mode = 0;
    if ((reqModes & CAP_MODE_CHARACTERS) != 0) {
        mode |= CAP_MODE_CHARACTERS;
    }
    if ((reqModes & (CAP_MODE_WORDS | CAP_MODE_SENTENCES)) == 0) {
        return mode;
    }
    for (i = off; i > 0; i--) {
        c = cs.charAt(i - 1);
        if (c != '""' && c != '\'' && Character.getType(c) != Character.START_PUNCTUATION) {
            break;
        }
    }
    // Start of paragraph, with optional whitespace.
    int j = i;
    while (j > 0 && ((c = cs.charAt(j - 1)) == ' ' || c == '\t')) {
        j--;
    }
    if (j == 0 || cs.charAt(j - 1) == '\n') {
        return mode | CAP_MODE_WORDS;
    }
    if ((reqModes & CAP_MODE_SENTENCES) == 0) {
        if (i != j)
            mode |= CAP_MODE_WORDS;
        return mode;
    }
    if (i == j) {
        return mode;
    }
    for (; j > 0; j--) {
        c = cs.charAt(j - 1);
        if (c != '""' && c != '\'' && Character.getType(c) != Character.END_PUNCTUATION) {
            break;
        }
    }
    if (j > 0) {
        c = cs.charAt(j - 1);
        if (c == '.' || c == '?' || c == '!') {
            if (c == '.') {
                for (int k = j - 2; k >= 0; k--) {
                    c = cs.charAt(k);
                    if (c == '.') {
                        return mode;
                    }
                    if (!Character.isLetter(c)) {
                        break;
                    }
                }
            }
            return mode | CAP_MODE_SENTENCES;
        }
    }
    return mode;
}","{
    if (off < 0) {
        return 0;
    }
    int i;
    char c;
    int mode = 0;
    if ((reqModes & CAP_MODE_CHARACTERS) != 0) {
        mode |= CAP_MODE_CHARACTERS;
    }
    if ((reqModes & (CAP_MODE_WORDS | CAP_MODE_SENTENCES)) == 0) {
        return mode;
    }
    for (i = off; i > 0; i--) {
        c = cs.charAt(i - 1);
        if (c != '""' && c != '\'' && Character.getType(c) != Character.START_PUNCTUATION) {
            break;
        }
    }
    // Start of paragraph, with optional whitespace.
    int j = i;
    while (j > 0 && ((c = cs.charAt(j - 1)) == ' ' || c == '\t')) {
        j--;
    }
    if (j == 0 || cs.charAt(j - 1) == '\n') {
        return mode | CAP_MODE_WORDS;
    }
    if ((reqModes & CAP_MODE_SENTENCES) == 0) {
        if (i != j)
            mode |= CAP_MODE_WORDS;
        return mode;
    }
    if (i == j) {
        return mode;
    }
    for (; j > 0; j--) {
        c = cs.charAt(j - 1);
        if (c != '""' && c != '\'' && Character.getType(c) != Character.END_PUNCTUATION) {
            break;
        }
    }
    if (j > 0) {
        c = cs.charAt(j - 1);
        if (c == '.' || c == '?' || c == '!') {
            if (c == '.') {
                for (int k = j - 2; k >= 0; k--) {
                    c = cs.charAt(k);
                    if (c == '.') {
                        return mode;
                    }
                    if (!Character.isLetter(c)) {
                        break;
                    }
                }
            }
            return mode | CAP_MODE_SENTENCES;
        }
    }
    return mode;
}",1,"/**
 * Determine what caps mode should be in effect at the current offset in
 * the text.  Only the mode bits set in <var>reqModes</var> will be
 * checked.  Note that the caps mode flags here are explicitly defined
 * to match those in {@link InputType}.
 *
 * @param cs The text that should be checked for caps modes.
 * @param off Location in the text at which to check.
 * @param reqModes The modes to be checked: may be any combination of
 * {@link #CAP_MODE_CHARACTERS}, {@link #CAP_MODE_WORDS}, and
 * {@link #CAP_MODE_SENTENCES}.
 *
 * @return Returns the actual capitalization modes that can be in effect
 * at the current position, which is any combination of
 * {@link #CAP_MODE_CHARACTERS}, {@link #CAP_MODE_WORDS}, and
 * {@link #CAP_MODE_SENTENCES}.
 */
","/**
 * Determine what caps mode should be in effect at the current offset in
 * the text.  Only the mode bits set in <var>reqModes</var> will be
 * checked.  Note that the caps mode flags here are explicitly defined
 * to match those in {@link InputType}.
 *
 * @param cs The text that should be checked for caps modes.
 * @param off Location in the text at which to check.
 * @param reqModes The modes to be checked: may be any combination of
 * {@link #CAP_MODE_CHARACTERS}, {@link #CAP_MODE_WORDS}, and
 * {@link #CAP_MODE_SENTENCES}.
 *
 * @return Returns the actual capitalization modes that can be in effect
 * at the current position, which is any combination of
 * {@link #CAP_MODE_CHARACTERS}, {@link #CAP_MODE_WORDS}, and
 * {@link #CAP_MODE_SENTENCES}.
 */
",-1,,,-1,-1,-1,-1,-1,-1,1,1,"The late version has a new statement 'if (off < 0)', and based on it, a new return statement 'return 0' is introduced. Thus, the code change type is 1.","The newly introduced 'if' statement could potentially make the late version of the API return a different value in certain cases (when 'off' is smaller than 0). Therefore, the CI type is 1."
485,"<android.database.sqlite.SQLiteDatabase: int delete(String,String,String[])>",7,8,"<android.database.sqlite.SQLiteDatabase: int delete(String,String,String[])>","<android.database.sqlite.SQLiteDatabase: int delete(String,String,String[])>",0,"{
    if (!isOpen()) {
        throw new IllegalStateException(""database not open"");
    }
    lock();
    SQLiteStatement statement = null;
    try {
        statement = compileStatement(""DELETE FROM "" + table + (!TextUtils.isEmpty(whereClause) ? "" WHERE "" + whereClause : """"));
        if (whereArgs != null) {
            int numArgs = whereArgs.length;
            for (int i = 0; i < numArgs; i++) {
                DatabaseUtils.bindObjectToProgram(statement, i + 1, whereArgs[i]);
            }
        }
        statement.execute();
        statement.close();
        return lastChangeCount();
    } catch (SQLiteDatabaseCorruptException e) {
        onCorruption();
        throw e;
    } finally {
        if (statement != null) {
            statement.close();
        }
        unlock();
    }
}","{
    lock();
    if (!isOpen()) {
        throw new IllegalStateException(""database not open"");
    }
    SQLiteStatement statement = null;
    try {
        statement = compileStatement(""DELETE FROM "" + table + (!TextUtils.isEmpty(whereClause) ? "" WHERE "" + whereClause : """"));
        if (whereArgs != null) {
            int numArgs = whereArgs.length;
            for (int i = 0; i < numArgs; i++) {
                DatabaseUtils.bindObjectToProgram(statement, i + 1, whereArgs[i]);
            }
        }
        statement.execute();
        return lastChangeCount();
    } catch (SQLiteDatabaseCorruptException e) {
        onCorruption();
        throw e;
    } finally {
        if (statement != null) {
            statement.close();
        }
        unlock();
    }
}",1,"/**
 * Convenience method for deleting rows in the database.
 *
 * @param table the table to delete from
 * @param whereClause the optional WHERE clause to apply when deleting.
 * Passing null will delete all rows.
 * @return the number of rows affected if a whereClause is passed in, 0
 * otherwise. To remove all rows and get a count pass ""1"" as the
 * whereClause.
 */
","/**
 * Convenience method for deleting rows in the database.
 *
 * @param table the table to delete from
 * @param whereClause the optional WHERE clause to apply when deleting.
 * Passing null will delete all rows.
 * @return the number of rows affected if a whereClause is passed in, 0
 * otherwise. To remove all rows and get a count pass ""1"" as the
 * whereClause.
 */
",-1,,,-1,-1,-1,-1,-1,-1,3,0,The only change between the two versions is the order of calling the function lock() and checking if the database is open. So the code change type is 3.,"The change in the order of the lock() function and the isOpen() check doesn't impact the behavior of the method or its return value or type. Therefore, the CI type is 0, which means no Compatibility Issue exists."
487,<android.view.WindowManager.LayoutParams: String toString()>,7,8,<android.view.WindowManager.LayoutParams: String toString()>,<android.view.WindowManager.LayoutParams: String toString()>,0,"{
    StringBuilder sb = new StringBuilder(256);
    sb.append(""WM.LayoutParams{"");
    sb.append(""("");
    sb.append(x);
    sb.append(',');
    sb.append(y);
    sb.append("")("");
    sb.append((width == FILL_PARENT ? ""fill"" : (width == WRAP_CONTENT ? ""wrap"" : width)));
    sb.append('x');
    sb.append((height == FILL_PARENT ? ""fill"" : (height == WRAP_CONTENT ? ""wrap"" : height)));
    sb.append("")"");
    if (softInputMode != 0) {
        sb.append("" sim=#"");
        sb.append(Integer.toHexString(softInputMode));
    }
    if (gravity != 0) {
        sb.append("" gr=#"");
        sb.append(Integer.toHexString(gravity));
    }
    sb.append("" ty="");
    sb.append(type);
    sb.append("" fl=#"");
    sb.append(Integer.toHexString(flags));
    sb.append("" fmt="");
    sb.append(format);
    if (windowAnimations != 0) {
        sb.append("" wanim=0x"");
        sb.append(Integer.toHexString(windowAnimations));
    }
    if (screenOrientation != ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED) {
        sb.append("" or="");
        sb.append(screenOrientation);
    }
    if ((flags & FLAG_COMPATIBLE_WINDOW) != 0) {
        sb.append("" compatible=true"");
    }
    sb.append('}');
    return sb.toString();
}","{
    StringBuilder sb = new StringBuilder(256);
    sb.append(""WM.LayoutParams{"");
    sb.append(""("");
    sb.append(x);
    sb.append(',');
    sb.append(y);
    sb.append("")("");
    sb.append((width == MATCH_PARENT ? ""fill"" : (width == WRAP_CONTENT ? ""wrap"" : width)));
    sb.append('x');
    sb.append((height == MATCH_PARENT ? ""fill"" : (height == WRAP_CONTENT ? ""wrap"" : height)));
    sb.append("")"");
    if (softInputMode != 0) {
        sb.append("" sim=#"");
        sb.append(Integer.toHexString(softInputMode));
    }
    if (gravity != 0) {
        sb.append("" gr=#"");
        sb.append(Integer.toHexString(gravity));
    }
    sb.append("" ty="");
    sb.append(type);
    sb.append("" fl=#"");
    sb.append(Integer.toHexString(flags));
    sb.append("" fmt="");
    sb.append(format);
    if (windowAnimations != 0) {
        sb.append("" wanim=0x"");
        sb.append(Integer.toHexString(windowAnimations));
    }
    if (screenOrientation != ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED) {
        sb.append("" or="");
        sb.append(screenOrientation);
    }
    if ((flags & FLAG_COMPATIBLE_WINDOW) != 0) {
        sb.append("" compatible=true"");
    }
    sb.append('}');
    return sb.toString();
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,1,"The original API used 'FILL_PARENT' in determining the 'wrap' or 'fill' status of 'width' and 'height'. In the new version, it has been replaced by 'MATCH_PARENT'. Hence, the change type is 4 (Other statement changed).","This change can result in a different string in the return statement if 'width' or 'height' is equal to 'FILL_PARENT' or 'MATCH_PARENT'. As a result, the API in the later version could possibly return a different value. Thus, this is a Compatibility Issue caused by potential different return values or types i.e., Type 1."
488,<android.widget.AbsSpinner: LayoutParams generateDefaultLayoutParams()>,7,8,<android.widget.AbsSpinner: LayoutParams generateDefaultLayoutParams()>,<android.widget.AbsSpinner: LayoutParams generateDefaultLayoutParams()>,0,"{
    return new ViewGroup.LayoutParams(ViewGroup.LayoutParams.FILL_PARENT, ViewGroup.LayoutParams.WRAP_CONTENT);
}","{
    return new ViewGroup.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.WRAP_CONTENT);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,5",1,"The return statement has changed from using FILL_PARENT constant to MATCH_PARENT constant in Viewgroup.LayoutParams instantiation, so the code change type is 1,5.","Changing the return statement from FILL_PARENT to MATCH_PARENT may potentially cause this API to return a different set of LayoutParams. Therefore, this constitutes a compatibility issue of type 1."
489,<android.content.AbstractThreadedSyncAdapter.SyncThread: void run()>,7,8,<android.content.AbstractThreadedSyncAdapter.SyncThread: void run()>,<android.content.AbstractThreadedSyncAdapter.SyncThread: void run()>,0,"{
    Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);
    if (isCanceled()) {
        return;
    }
    SyncResult syncResult = new SyncResult();
    int uid = Process.myUid();
    mInitialTxBytes = NetStat.getUidTxBytes(uid);
    mInitialRxBytes = NetStat.getUidRxBytes(uid);
    ContentProviderClient provider = null;
    try {
        provider = mContext.getContentResolver().acquireContentProviderClient(mAuthority);
        if (provider != null) {
            AbstractThreadedSyncAdapter.this.onPerformSync(mAccount, mExtras, mAuthority, provider, syncResult);
        } else {
            syncResult.databaseError = true;
        }
    } finally {
        if (provider != null) {
            provider.release();
        }
        if (!isCanceled()) {
            mSyncContext.onFinished(syncResult);
        }
        onLogSyncDetails(NetStat.getUidTxBytes(uid) - mInitialTxBytes, NetStat.getUidRxBytes(uid) - mInitialRxBytes, syncResult);
        // that also synchronize accesses to mSyncThread
        synchronized (mSyncThreadLock) {
            mSyncThread = null;
        }
    }
}","{
    Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);
    if (isCanceled()) {
        return;
    }
    SyncResult syncResult = new SyncResult();
    ContentProviderClient provider = null;
    try {
        provider = mContext.getContentResolver().acquireContentProviderClient(mAuthority);
        if (provider != null) {
            AbstractThreadedSyncAdapter.this.onPerformSync(mAccount, mExtras, mAuthority, provider, syncResult);
        } else {
            syncResult.databaseError = true;
        }
    } finally {
        if (provider != null) {
            provider.release();
        }
        if (!isCanceled()) {
            mSyncContext.onFinished(syncResult);
        }
        // that also synchronize accesses to mSyncThread
        synchronized (mSyncThreadLock) {
            mSyncThread = null;
        }
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,4,0,"The code removed the load of uid, mInitialTxBytes and mInitialTxBytes and the call to the method onLogSyncDetails(). This corresponds to a code change type of 4 (Other statement changed).","The removed part doesn't affect the return result, nor does it throw any exceptions that have been changed so there shouldn't be a compatibility issue."
491,<android.content.SyncResult: String toString()>,7,8,<android.content.SyncResult: String toString()>,<android.content.SyncResult: String toString()>,0,"{
    StringBuilder sb = new StringBuilder();
    sb.append(""SyncResult:"");
    if (syncAlreadyInProgress) {
        sb.append("" syncAlreadyInProgress: "").append(syncAlreadyInProgress);
    }
    if (tooManyDeletions)
        sb.append("" tooManyDeletions: "").append(tooManyDeletions);
    if (tooManyRetries)
        sb.append("" tooManyRetries: "").append(tooManyRetries);
    if (databaseError)
        sb.append("" databaseError: "").append(databaseError);
    if (fullSyncRequested)
        sb.append("" fullSyncRequested: "").append(fullSyncRequested);
    if (partialSyncUnavailable) {
        sb.append("" partialSyncUnavailable: "").append(partialSyncUnavailable);
    }
    if (moreRecordsToGet)
        sb.append("" moreRecordsToGet: "").append(moreRecordsToGet);
    sb.append(stats);
    return sb.toString();
}","{
    StringBuilder sb = new StringBuilder();
    sb.append(""SyncResult:"");
    if (syncAlreadyInProgress) {
        sb.append("" syncAlreadyInProgress: "").append(syncAlreadyInProgress);
    }
    if (tooManyDeletions)
        sb.append("" tooManyDeletions: "").append(tooManyDeletions);
    if (tooManyRetries)
        sb.append("" tooManyRetries: "").append(tooManyRetries);
    if (databaseError)
        sb.append("" databaseError: "").append(databaseError);
    if (fullSyncRequested)
        sb.append("" fullSyncRequested: "").append(fullSyncRequested);
    if (partialSyncUnavailable) {
        sb.append("" partialSyncUnavailable: "").append(partialSyncUnavailable);
    }
    if (moreRecordsToGet)
        sb.append("" moreRecordsToGet: "").append(moreRecordsToGet);
    if (delayUntil > 0)
        sb.append("" delayUntil: "").append(delayUntil);
    sb.append(stats);
    return sb.toString();
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,3",1,"There is a new addition of an 'if block' in the late implementation. Specifically, ""if (delayUntil > 0) sb.append("" delayUntil: "").append(delayUntil);"" was added to the late implementation. This counts as a Change under type 1 (Return statement changed) because it affects the returned value of the function. It also counts as a change of type 3 (Control dependency changed) because a new condition has been introduced.","The added 'if condition' in the late implementation causes a difference in the output string of the 'toString()' method depending on the value of 'delayUntil'. This means that the same method will produce a different return value in version 8 than it did in version 7 when 'delayUntil' is greater than 0. Therefore, it points to the existence of a Compatibility Issue of type 1 (Compatibility Issue caused by potential different return values)."
492,<android.webkit.CookieManager: ArrayList<Cookie> deleteLRUDomain()>,7,8,<android.webkit.CookieManager: ArrayList<Cookie> deleteLRUDomain()>,<android.webkit.CookieManager: ArrayList<Cookie> deleteLRUDomain()>,0,"{
    int count = 0;
    int byteCount = 0;
    int mapSize = mCookieMap.size();
    if (mapSize < MAX_RAM_DOMAIN_COUNT) {
        Collection<ArrayList<Cookie>> cookieLists = mCookieMap.values();
        Iterator<ArrayList<Cookie>> listIter = cookieLists.iterator();
        while (listIter.hasNext() && count < MAX_RAM_COOKIES_COUNT) {
            ArrayList<Cookie> list = listIter.next();
            if (DebugFlags.COOKIE_MANAGER) {
                Iterator<Cookie> iter = list.iterator();
                while (iter.hasNext() && count < MAX_RAM_COOKIES_COUNT) {
                    Cookie cookie = iter.next();
                    // 14 is 3 * sizeof(long) + sizeof(boolean)
                    // + sizeof(byte)
                    byteCount += cookie.domain.length() + cookie.path.length() + cookie.name.length() + cookie.value.length() + 14;
                    count++;
                }
            } else {
                count += list.size();
            }
        }
    }
    ArrayList<Cookie> retlist = new ArrayList<Cookie>();
    if (mapSize >= MAX_RAM_DOMAIN_COUNT || count >= MAX_RAM_COOKIES_COUNT) {
        if (DebugFlags.COOKIE_MANAGER) {
            Log.v(LOGTAG, count + "" cookies used "" + byteCount + "" bytes with "" + mapSize + "" domains"");
        }
        Object[] domains = mCookieMap.keySet().toArray();
        int toGo = mapSize / 10 + 1;
        while (toGo-- > 0) {
            String domain = domains[toGo].toString();
            if (DebugFlags.COOKIE_MANAGER) {
                Log.v(LOGTAG, ""delete domain: "" + domain + "" from RAM cache"");
            }
            retlist.addAll(mCookieMap.get(domain));
            mCookieMap.remove(domain);
        }
    }
    return retlist;
}","{
    int count = 0;
    int byteCount = 0;
    int mapSize = mCookieMap.size();
    if (mapSize < MAX_RAM_DOMAIN_COUNT) {
        Collection<ArrayList<Cookie>> cookieLists = mCookieMap.values();
        Iterator<ArrayList<Cookie>> listIter = cookieLists.iterator();
        while (listIter.hasNext() && count < MAX_RAM_COOKIES_COUNT) {
            ArrayList<Cookie> list = listIter.next();
            if (DebugFlags.COOKIE_MANAGER) {
                Iterator<Cookie> iter = list.iterator();
                while (iter.hasNext() && count < MAX_RAM_COOKIES_COUNT) {
                    Cookie cookie = iter.next();
                    // 14 is 3 * sizeof(long) + sizeof(boolean)
                    // + sizeof(byte)
                    byteCount += cookie.domain.length() + cookie.path.length() + cookie.name.length() + (cookie.value != null ? cookie.value.length() : 0) + 14;
                    count++;
                }
            } else {
                count += list.size();
            }
        }
    }
    ArrayList<Cookie> retlist = new ArrayList<Cookie>();
    if (mapSize >= MAX_RAM_DOMAIN_COUNT || count >= MAX_RAM_COOKIES_COUNT) {
        if (DebugFlags.COOKIE_MANAGER) {
            Log.v(LOGTAG, count + "" cookies used "" + byteCount + "" bytes with "" + mapSize + "" domains"");
        }
        Object[] domains = mCookieMap.keySet().toArray();
        int toGo = mapSize / 10 + 1;
        while (toGo-- > 0) {
            String domain = domains[toGo].toString();
            if (DebugFlags.COOKIE_MANAGER) {
                Log.v(LOGTAG, ""delete domain: "" + domain + "" from RAM cache"");
            }
            retlist.addAll(mCookieMap.get(domain));
            mCookieMap.remove(domain);
        }
    }
    return retlist;
}",1,"/**
 * Package level api, called from CookieSyncManager
 *
 * Delete the least recent used domains if the total cookie count in RAM
 * exceeds the limit
 * @return A list of cookies which are removed from RAM
 */
","/**
 * Package level api, called from CookieSyncManager
 *
 * Delete the least recent used domains if the total cookie count in RAM
 * exceeds the limit
 * @return A list of cookies which are removed from RAM
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The code change happens within an 'if' segment and is a null-checking added for cookie.value before invoking the length() method, so the code change type is 4.","The null checking for cookie.value does not change the potential return value or potential exceptions raised by the API, so there is no Compatibility Issue, and the CI type is 0."
493,"<android.widget.ListView: void setItemChecked(int,boolean)>",7,8,"<android.widget.ListView: void setItemChecked(int,boolean)>","<android.widget.ListView: void setItemChecked(int,boolean)>",0,"{
    if (mChoiceMode == CHOICE_MODE_NONE) {
        return;
    }
    if (mChoiceMode == CHOICE_MODE_MULTIPLE) {
        mCheckStates.put(position, value);
    } else {
        // selected item
        if (value || isItemChecked(position)) {
            mCheckStates.clear();
        }
        // we ensure length of mCheckStates is 1, a fact getCheckedItemPosition relies on
        if (value) {
            mCheckStates.put(position, true);
        }
    }
    // Do not generate a data change while we are in the layout phase
    if (!mInLayout && !mBlockLayoutRequests) {
        mDataChanged = true;
        rememberSyncState();
        requestLayout();
    }
}","{
    if (mChoiceMode == CHOICE_MODE_NONE) {
        return;
    }
    if (mChoiceMode == CHOICE_MODE_MULTIPLE) {
        mCheckStates.put(position, value);
        if (mCheckedIdStates != null && mAdapter.hasStableIds()) {
            if (value) {
                mCheckedIdStates.put(mAdapter.getItemId(position), Boolean.TRUE);
            } else {
                mCheckedIdStates.delete(mAdapter.getItemId(position));
            }
        }
    } else {
        boolean updateIds = mCheckedIdStates != null && mAdapter.hasStableIds();
        // selected item
        if (value || isItemChecked(position)) {
            mCheckStates.clear();
            if (updateIds) {
                mCheckedIdStates.clear();
            }
        }
        // we ensure length of mCheckStates is 1, a fact getCheckedItemPosition relies on
        if (value) {
            mCheckStates.put(position, true);
            if (updateIds) {
                mCheckedIdStates.put(mAdapter.getItemId(position), Boolean.TRUE);
            }
        }
    }
    // Do not generate a data change while we are in the layout phase
    if (!mInLayout && !mBlockLayoutRequests) {
        mDataChanged = true;
        rememberSyncState();
        requestLayout();
    }
}",1,"/**
 * Sets the checked state of the specified position. The is only valid if
 * the choice mode has been set to {@link #CHOICE_MODE_SINGLE} or
 * {@link #CHOICE_MODE_MULTIPLE}.
 *
 * @param position The item whose checked state is to be checked
 * @param value The new checked sate for the item
 */
","/**
 * Sets the checked state of the specified position. The is only valid if
 * the choice mode has been set to {@link #CHOICE_MODE_SINGLE} or
 * {@link #CHOICE_MODE_MULTIPLE}.
 *
 * @param position The item whose checked state is to be checked
 * @param value The new checked state for the item
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",1,"The implementation of the method has changed due to a new logic introduced which involved variables `mCheckedIdStates` and `mAdapter`. There are changes in the method's body, specifically additional `if` conditions and method calls inside them. Therefore, it implies a control dependency change (type 3) and other statement change (type 4).","Due to the changes in implementation, additional conditions and method calls are used which affects the behavior of the function, hence there is a potential for the latter version to produce different results than the initial version. That implies a compatibility issue caused by potential different return values or types (type 1)."
495,<android.webkit.HttpAuthHandler: void cancel()>,7,8,<android.webkit.HttpAuthHandler: void cancel()>,<android.webkit.HttpAuthHandler: void cancel()>,0,"{
    sendMessage(obtainMessage(AUTH_CANCEL));
}","{
    if (handleResponseForSynchronousRequest(null, null)) {
        signalRequestComplete();
        return;
    }
    sendMessage(obtainMessage(AUTH_CANCEL));
    signalRequestComplete();
}",1,"/**
 * Cancel the authorization request
 */
","/**
 * Cancel the authorization request
 *
 * May be called on the UI thread, rather than the WebCore thread.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1, 3",1,"In the newer version, a conditional check along with two method calls is added and a new return statement is introduced inside the conditional block. Also, there is an extra execution of the method signalRequestComplete() irrespective of the condition. Thus the code change type is 1,3",The return statement being moved inside the condition check along with the presence of new method calls could lead to the method returning different outcomes based on the condition. So the CI is of type 1.
496,"<android.app.SearchManager: void startSearch(String,boolean,ComponentName,Bundle,boolean)>",7,8,"<android.app.SearchManager: void startSearch(String,boolean,ComponentName,Bundle,boolean)>","<android.app.SearchManager: void startSearch(String,boolean,ComponentName,Bundle,boolean)>",0,"{
    if (mIdent == 0)
        throw new IllegalArgumentException(""Called from outside of an Activity context"");
    if (!globalSearch && !mAssociatedPackage.equals(launchActivity.getPackageName())) {
        Log.w(TAG, ""invoking app search on a different package "" + ""not associated with this search manager"");
    }
    try {
        // activate the search manager and start it up!
        mService.startSearch(initialQuery, selectInitialQuery, launchActivity, appSearchData, globalSearch, mSearchManagerCallback, mIdent);
    } catch (RemoteException ex) {
        Log.e(TAG, ""startSearch() failed."", ex);
    }
}","{
    if (globalSearch) {
        startGlobalSearch(initialQuery, selectInitialQuery, appSearchData);
        return;
    }
    ensureSearchDialog();
    mSearchDialog.show(initialQuery, selectInitialQuery, launchActivity, appSearchData);
}",1,"/**
 * Launch search UI.
 *
 * <p>The search manager will open a search widget in an overlapping
 * window, and the underlying activity may be obscured.  The search
 * entry state will remain in effect until one of the following events:
 * <ul>
 * <li>The user completes the search.  In most cases this will launch
 * a search intent.</li>
 * <li>The user uses the back, home, or other keys to exit the search.</li>
 * <li>The application calls the {@link #stopSearch}
 * method, which will hide the search window and return focus to the
 * activity from which it was launched.</li>
 *
 * <p>Most applications will <i>not</i> use this interface to invoke search.
 * The primary method for invoking search is to call
 * {@link android.app.Activity#onSearchRequested Activity.onSearchRequested()} or
 * {@link android.app.Activity#startSearch Activity.startSearch()}.
 *
 * @param initialQuery A search string can be pre-entered here, but this
 * is typically null or empty.
 * @param selectInitialQuery If true, the intial query will be preselected, which means that
 * any further typing will replace it.  This is useful for cases where an entire pre-formed
 * query is being inserted.  If false, the selection point will be placed at the end of the
 * inserted query.  This is useful when the inserted query is text that the user entered,
 * and the user would expect to be able to keep typing.  <i>This parameter is only meaningful
 * if initialQuery is a non-empty string.</i>
 * @param launchActivity The ComponentName of the activity that has launched this search.
 * @param appSearchData An application can insert application-specific
 * context here, in order to improve quality or specificity of its own
 * searches.  This data will be returned with SEARCH intent(s).  Null if
 * no extra data is required.
 * @param globalSearch If false, this will only launch the search that has been specifically
 * defined by the application (which is usually defined as a local search).  If no default
 * search is defined in the current application or activity, global search will be launched.
 * If true, this will always launch a platform-global (e.g. web-based) search instead.
 *
 * @see android.app.Activity#onSearchRequested
 * @see #stopSearch
 */
","/**
 * Launch search UI.
 *
 * <p>The search manager will open a search widget in an overlapping
 * window, and the underlying activity may be obscured.  The search
 * entry state will remain in effect until one of the following events:
 * <ul>
 * <li>The user completes the search.  In most cases this will launch
 * a search intent.</li>
 * <li>The user uses the back, home, or other keys to exit the search.</li>
 * <li>The application calls the {@link #stopSearch}
 * method, which will hide the search window and return focus to the
 * activity from which it was launched.</li>
 *
 * <p>Most applications will <i>not</i> use this interface to invoke search.
 * The primary method for invoking search is to call
 * {@link android.app.Activity#onSearchRequested Activity.onSearchRequested()} or
 * {@link android.app.Activity#startSearch Activity.startSearch()}.
 *
 * @param initialQuery A search string can be pre-entered here, but this
 * is typically null or empty.
 * @param selectInitialQuery If true, the intial query will be preselected, which means that
 * any further typing will replace it.  This is useful for cases where an entire pre-formed
 * query is being inserted.  If false, the selection point will be placed at the end of the
 * inserted query.  This is useful when the inserted query is text that the user entered,
 * and the user would expect to be able to keep typing.  <i>This parameter is only meaningful
 * if initialQuery is a non-empty string.</i>
 * @param launchActivity The ComponentName of the activity that has launched this search.
 * @param appSearchData An application can insert application-specific
 * context here, in order to improve quality or specificity of its own
 * searches.  This data will be returned with SEARCH intent(s).  Null if
 * no extra data is required.
 * @param globalSearch If false, this will only launch the search that has been specifically
 * defined by the application (which is usually defined as a local search).  If no default
 * search is defined in the current application or activity, global search will be launched.
 * If true, this will always launch a platform-global (e.g. web-based) search instead.
 *
 * @see android.app.Activity#onSearchRequested
 * @see #stopSearch
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3,4","1,2","The function behavior in handling global search has been completely changed which is not just a simple statement change, but statement deletion and new addition. The exception handling removed in the late version leading to change type as 1. The 'if' condition check for 'globalSearch' has also been changed, this leads to type 3. The removal of method calls to 'mService.startSearch()' and additions of 'startGlobalSearch' and 'mSearchDialog.show()' causes the code change to be type 4 as well.","Due to these changes in the late version, especially the complete change of how global search is handled and the removal of exception handling, the API could behave completely differently compared to the early version for the same inputs. Hence, it could potentially return a different value and it could handle exceptions differently as well. Therefore it's type 1 and 2 Compatibility Issue."
497,<android.database.sqlite.SQLiteStatement: void execute()>,7,8,<android.database.sqlite.SQLiteStatement: void execute()>,<android.database.sqlite.SQLiteStatement: void execute()>,0,"{
    mDatabase.lock();
    boolean logStats = mDatabase.mLogStats;
    long startTime = logStats ? SystemClock.elapsedRealtime() : 0;
    acquireReference();
    try {
        if (SQLiteDebug.DEBUG_SQL_STATEMENTS) {
            Log.v(TAG, ""execute() for ["" + mSql + ""]"");
        }
        native_execute();
        if (logStats) {
            mDatabase.logTimeStat(false, /* write */
            startTime, SystemClock.elapsedRealtime());
        }
    } finally {
        releaseReference();
        mDatabase.unlock();
    }
}","{
    if (!mDatabase.isOpen()) {
        throw new IllegalStateException(""database "" + mDatabase.getPath() + "" already closed"");
    }
    long timeStart = SystemClock.uptimeMillis();
    mDatabase.lock();
    acquireReference();
    try {
        native_execute();
        mDatabase.logTimeStat(mSql, timeStart);
    } finally {
        releaseReference();
        mDatabase.unlock();
    }
}",1,"/**
 * Execute this SQL statement, if it is not a query. For example,
 * CREATE TABLE, DELTE, INSERT, etc.
 *
 * @throws android.database.SQLException If the SQL string is invalid for
 * some reason
 */
","/**
 * Execute this SQL statement, if it is not a query. For example,
 * CREATE TABLE, DELTE, INSERT, etc.
 *
 * @throws android.database.SQLException If the SQL string is invalid for
 * some reason
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,2,3,4","1,2","A new exception handling statement is introduced at the beginning of the late implementation, which is a change type of 2. Several statements are deleted and new statements are added into the late version including the return statements, which is a type of 1 and 4. The control dependency (If statement) is also a type of 3.","The introduced new exception might be thrown differently, which is the CI type of 2. The removed and added return statements might also lead the API to return differently, which is the CI type of 1."
498,<android.app.Dialog: void show()>,7,8,<android.app.Dialog: void show()>,<android.app.Dialog: void show()>,0,"{
    if (mShowing) {
        if (Config.LOGV)
            Log.v(LOG_TAG, ""[Dialog] start: already showing, ignore"");
        if (mDecor != null) {
            mDecor.setVisibility(View.VISIBLE);
        }
        return;
    }
    if (!mCreated) {
        dispatchOnCreate(null);
    }
    onStart();
    mDecor = mWindow.getDecorView();
    WindowManager.LayoutParams l = mWindow.getAttributes();
    if ((l.softInputMode & WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION) == 0) {
        WindowManager.LayoutParams nl = new WindowManager.LayoutParams();
        nl.copyFrom(l);
        nl.softInputMode |= WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION;
        l = nl;
    }
    mWindowManager.addView(mDecor, l);
    mShowing = true;
    sendShowMessage();
}","{
    if (mShowing) {
        if (mDecor != null) {
            mDecor.setVisibility(View.VISIBLE);
        }
        return;
    }
    if (!mCreated) {
        dispatchOnCreate(null);
    }
    onStart();
    mDecor = mWindow.getDecorView();
    WindowManager.LayoutParams l = mWindow.getAttributes();
    if ((l.softInputMode & WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION) == 0) {
        WindowManager.LayoutParams nl = new WindowManager.LayoutParams();
        nl.copyFrom(l);
        nl.softInputMode |= WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION;
        l = nl;
    }
    try {
        mWindowManager.addView(mDecor, l);
        mShowing = true;
        sendShowMessage();
    } finally {
    }
}",1,"/**
 * Start the dialog and display it on screen.  The window is placed in the
 * application layer and opaque.  Note that you should not override this
 * method to do initialization when the dialog is shown, instead implement
 * that in {@link #onStart}.
 */
","/**
 * Start the dialog and display it on screen.  The window is placed in the
 * application layer and opaque.  Note that you should not override this
 * method to do initialization when the dialog is shown, instead implement
 * that in {@link #onStart}.
 */
",-1,,,-1,-1,-1,-1,-1,-1,2,0,"Exception handling statements with 'try' and 'finally' have been added in the late version, but no actual exception handling code is present inside. Therefore, the change type is 2.","Even though exception handling statements have been added in the late version, the code inside the try block has not been changed and the finally block is empty. Therefore, no behaviour change is introduced that would cause a compatibility issue. The CI type is 0."
501,<android.webkit.BrowserFrame: void handleMessage(Message)>,7,8,<android.webkit.BrowserFrame: void handleMessage(Message)>,<android.webkit.BrowserFrame: void handleMessage(Message)>,0,"{
    switch(msg.what) {
        case FRAME_COMPLETED:
            {
                if (mSettings.getSavePassword() && hasPasswordField()) {
                    WebHistoryItem item = mCallbackProxy.getBackForwardList().getCurrentItem();
                    if (item != null) {
                        WebAddress uri = new WebAddress(item.getUrl());
                        String schemePlusHost = uri.mScheme + uri.mHost;
                        String[] up = mDatabase.getUsernamePassword(schemePlusHost);
                        if (up != null && up[0] != null) {
                            setUsernamePassword(up[0], up[1]);
                        }
                    }
                }
                CacheManager.trimCacheIfNeeded();
                break;
            }
        case POLICY_FUNCTION:
            {
                nativeCallPolicyFunction(msg.arg1, msg.arg2);
                break;
            }
        default:
            break;
    }
}","{
    if (mBlockMessages) {
        return;
    }
    switch(msg.what) {
        case FRAME_COMPLETED:
            {
                if (mSettings.getSavePassword() && hasPasswordField()) {
                    WebHistoryItem item = mCallbackProxy.getBackForwardList().getCurrentItem();
                    if (item != null) {
                        WebAddress uri = new WebAddress(item.getUrl());
                        String schemePlusHost = uri.mScheme + uri.mHost;
                        String[] up = mDatabase.getUsernamePassword(schemePlusHost);
                        if (up != null && up[0] != null) {
                            setUsernamePassword(up[0], up[1]);
                        }
                    }
                }
                WebViewWorker.getHandler().sendEmptyMessage(WebViewWorker.MSG_TRIM_CACHE);
                break;
            }
        case POLICY_FUNCTION:
            {
                nativeCallPolicyFunction(msg.arg1, msg.arg2);
                break;
            }
        case ORIENTATION_CHANGED:
            {
                nativeOrientationChanged(msg.arg1);
                break;
            }
        default:
            break;
    }
}",1,"/**
 * Handle messages posted to us.
 * @param msg The message to handle.
 */
","/**
 * Handle messages posted to us.
 * @param msg The message to handle.
 */
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,4",0,"There has been the introduction of the 'if' condition statement 'if (mBlockMessages) { return; }' at the beginning of the method (type 3), and also the change in the call of the cache trimming function from 'CacheManager.trimCacheIfNeeded()' to 'WebViewWorker.getHandler().sendEmptyMessage(WebViewWorker.MSG_TRIM_CACHE);' (type 4). Also, a new case of 'ORIENTATION_CHANGED' is added within 'switch' in the late version.","However, these changes do not affect the return type of the method nor does it introduce any new exceptions that may cause the program to fail, thus there is no compatibility issue between the two versions."
502,<android.pim.vcard.VCardParser_V21: String maybeUnescapeCharacter(char)>,7,8,<android.pim.vcard.VCardParser_V21: String maybeUnescapeCharacter(char)>,<android.pim.vcard.VCardParser_V21: String maybeUnescapeCharacter(char)>,0,"{
    // this class allowed them, so keep it as is.
    if (ch == '\\' || ch == ';' || ch == ':' || ch == ',') {
        return String.valueOf(ch);
    } else {
        return null;
    }
}","{
    return unescapeCharacter(ch);
}",1,"/**
 * Returns unescaped String if the character should be unescaped. Return null otherwise.
 * e.g. In vCard 2.1, ""\;"" should be unescaped into "";"" while ""\x"" should not be.
 */
","/**
 * Returns unescaped String if the character should be unescaped. Return null otherwise.
 * e.g. In vCard 2.1, ""\;"" should be unescaped into "";"" while ""\x"" should not be.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The implementation of the function has completely changed from a condition 'if' to a return string. Also, the method that the function depends on has changed from `String.valueOf(ch)` to `unescapeCharacter(ch)`. These changes belong to return statement change and dependent API change, so type 1,5.","The return statement of the function has changed, so the result could potentially be different. Therefore, a compatibility issue caused by potential different return values or types (type 1) exists."
504,<android.inputmethodservice.InputMethodService: boolean onEvaluateFullscreenMode()>,7,8,<android.inputmethodservice.InputMethodService: boolean onEvaluateFullscreenMode()>,<android.inputmethodservice.InputMethodService: boolean onEvaluateFullscreenMode()>,0,"{
    Configuration config = getResources().getConfiguration();
    return config.orientation == Configuration.ORIENTATION_LANDSCAPE;
}","{
    Configuration config = getResources().getConfiguration();
    if (config.orientation != Configuration.ORIENTATION_LANDSCAPE) {
        return false;
    }
    if (mInputEditorInfo != null && (mInputEditorInfo.imeOptions & EditorInfo.IME_FLAG_NO_FULLSCREEN) != 0) {
        return false;
    }
    return true;
}",1,"/**
 * Override this to control when the input method should run in
 * fullscreen mode.  The default implementation runs in fullsceen only
 * when the screen is in landscape mode.  If you change what
 * this returns, you will need to call {@link #updateFullscreenMode()}
 * yourself whenever the returned value may have changed to have it
 * re-evaluated and applied.
 */
","/**
 * Override this to control when the input method should run in
 * fullscreen mode.  The default implementation runs in fullsceen only
 * when the screen is in landscape mode.  If you change what
 * this returns, you will need to call {@link #updateFullscreenMode()}
 * yourself whenever the returned value may have changed to have it
 * re-evaluated and applied.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3",1,"The return statement has been changed from a simple boolean condition to multiple conditional return statements within an 'if' control statement. So the code change type is 1, 3.","Because of the change in the return statement, the late version of the API may potentially return a different boolean value, depending on the conditions in the 'if' statements. So the CI type is 1."
505,<android.webkit.WebView: boolean zoomOut()>,7,8,<android.webkit.WebView: boolean zoomOut()>,<android.webkit.WebView: boolean zoomOut()>,0,"{
    // TODO: alternatively we can disallow this during draw history mode
    switchOutDrawHistory();
    // Center zooming to the center of the screen.
    mZoomCenterX = getViewWidth() * .5f;
    mZoomCenterY = getViewHeight() * .5f;
    mAnchorX = viewToContentX((int) mZoomCenterX + mScrollX);
    mAnchorY = viewToContentY((int) mZoomCenterY + mScrollY);
    return zoomWithPreview(mActualScale * 0.8f);
}","{
    // TODO: alternatively we can disallow this during draw history mode
    switchOutDrawHistory();
    // Center zooming to the center of the screen.
    mZoomCenterX = getViewWidth() * .5f;
    mZoomCenterY = getViewHeight() * .5f;
    mAnchorX = viewToContentX((int) mZoomCenterX + mScrollX);
    mAnchorY = viewToContentY((int) mZoomCenterY + mScrollY);
    return zoomWithPreview(mActualScale * 0.8f, true);
}",1,"/**
 * Perform zoom out in the webview
 * @return TRUE if zoom out succeeds. FALSE if no zoom changes.
 */
","/**
 * Perform zoom out in the webview
 * @return TRUE if zoom out succeeds. FALSE if no zoom changes.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The return statement has changed from zoomWithPreview(mActualScale * 0.8f) to zoomWithPreview(mActualScale * 0.8f, true) and the parameter type of zoomWithPreview() also changed, so the code change type is 1,5.","The change of return statement makes the API potentially return a different value, so the CI type is 1."
506,"<android.database.sqlite.SQLiteDatabase: Cursor rawQueryWithFactory(CursorFactory,String,String[],String)>",7,8,"<android.database.sqlite.SQLiteDatabase: Cursor rawQueryWithFactory(CursorFactory,String,String[],String)>","<android.database.sqlite.SQLiteDatabase: Cursor rawQueryWithFactory(CursorFactory,String,String[],String)>",0,"{
    long timeStart = 0;
    if (Config.LOGV || mSlowQueryThreshold != -1) {
        timeStart = System.currentTimeMillis();
    }
    SQLiteCursorDriver driver = new SQLiteDirectCursorDriver(this, sql, editTable);
    Cursor cursor = null;
    try {
        cursor = driver.query(cursorFactory != null ? cursorFactory : mFactory, selectionArgs);
    } finally {
        if (Config.LOGV || mSlowQueryThreshold != -1) {
            // Force query execution
            if (cursor != null) {
                cursor.moveToFirst();
                cursor.moveToPosition(-1);
            }
            long duration = System.currentTimeMillis() - timeStart;
            if (Config.LOGV || duration >= mSlowQueryThreshold) {
                Log.v(SQLiteCursor.TAG, ""query ("" + duration + "" ms): "" + driver.toString() + "", args are "" + (selectionArgs != null ? TextUtils.join("","", selectionArgs) : ""<null>""));
            }
        }
    }
    return cursor;
}","{
    if (!isOpen()) {
        throw new IllegalStateException(""database not open"");
    }
    long timeStart = 0;
    if (Config.LOGV || mSlowQueryThreshold != -1) {
        timeStart = System.currentTimeMillis();
    }
    SQLiteCursorDriver driver = new SQLiteDirectCursorDriver(this, sql, editTable);
    Cursor cursor = null;
    try {
        cursor = driver.query(cursorFactory != null ? cursorFactory : mFactory, selectionArgs);
    } finally {
        if (Config.LOGV || mSlowQueryThreshold != -1) {
            // Force query execution
            int count = -1;
            if (cursor != null) {
                count = cursor.getCount();
            }
            long duration = System.currentTimeMillis() - timeStart;
            if (Config.LOGV || duration >= mSlowQueryThreshold) {
                Log.v(SQLiteCursor.TAG, ""query ("" + duration + "" ms): "" + driver.toString() + "", args are "" + (selectionArgs != null ? TextUtils.join("","", selectionArgs) : ""<null>"") + "", count is "" + count);
            }
        }
    }
    return cursor;
}",1,"/**
 * Runs the provided SQL and returns a cursor over the result set.
 *
 * @param cursorFactory the cursor factory to use, or null for the default factory
 * @param sql the SQL query. The SQL string must not be ; terminated
 * @param selectionArgs You may include ?s in where clause in the query,
 * which will be replaced by the values from selectionArgs. The
 * values will be bound as Strings.
 * @param editTable the name of the first table, which is editable
 * @return A {@link Cursor} object, which is positioned before the first entry
 */
","/**
 * Runs the provided SQL and returns a cursor over the result set.
 *
 * @param cursorFactory the cursor factory to use, or null for the default factory
 * @param sql the SQL query. The SQL string must not be ; terminated
 * @param selectionArgs You may include ?s in where clause in the query,
 * which will be replaced by the values from selectionArgs. The
 * values will be bound as Strings.
 * @param editTable the name of the first table, which is editable
 * @return A {@link Cursor} object, which is positioned before the first entry
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,3,4",2,"Between the early and late version, several changes have occurred. A new exception has been added at the beginning, an extra logging information has been introduced and there has been a change in the queries executed under the if clause. Code change types are 2,3, and 4.","As a new exception was added (IllegalStateException if the database is not open) that was not there prior, it can give rises to different behaviors leading to a Compatibility Issue of type 2."
507,<android.pim.vcard.VCardParser_V21: boolean parseItem()>,7,8,<android.pim.vcard.VCardParser_V21: boolean parseItem()>,<android.pim.vcard.VCardParser_V21: boolean parseItem()>,0,"{
    mEncoding = sDefaultEncoding;
    String line = getNonEmptyLine();
    long start = System.currentTimeMillis();
    String[] propertyNameAndValue = separateLineAndHandleGroup(line);
    if (propertyNameAndValue == null) {
        return true;
    }
    if (propertyNameAndValue.length != 2) {
        throw new VCardInvalidLineException(""Invalid line \"""" + line + ""\"""");
    }
    String propertyName = propertyNameAndValue[0].toUpperCase();
    String propertyValue = propertyNameAndValue[1];
    mTimeParseLineAndHandleGroup += System.currentTimeMillis() - start;
    if (propertyName.equals(""ADR"") || propertyName.equals(""ORG"") || propertyName.equals(""N"")) {
        start = System.currentTimeMillis();
        handleMultiplePropertyValue(propertyName, propertyValue);
        mTimeParseAdrOrgN += System.currentTimeMillis() - start;
        return false;
    } else if (propertyName.equals(""AGENT"")) {
        handleAgent(propertyValue);
        return false;
    } else if (isValidPropertyName(propertyName)) {
        if (propertyName.equals(""BEGIN"")) {
            if (propertyValue.equals(""VCARD"")) {
                throw new VCardNestedException(""This vCard has nested vCard data in it."");
            } else {
                throw new VCardException(""Unknown BEGIN type: "" + propertyValue);
            }
        } else if (propertyName.equals(""VERSION"") && !propertyValue.equals(getVersion())) {
            throw new VCardVersionException(""Incompatible version: "" + propertyValue + "" != "" + getVersion());
        }
        start = System.currentTimeMillis();
        handlePropertyValue(propertyName, propertyValue);
        mTimeParsePropertyValues += System.currentTimeMillis() - start;
        return false;
    }
    throw new VCardException(""Unknown property name: \"""" + propertyName + ""\"""");
}","{
    mEncoding = sDefaultEncoding;
    final String line = getNonEmptyLine();
    long start = System.currentTimeMillis();
    String[] propertyNameAndValue = separateLineAndHandleGroup(line);
    if (propertyNameAndValue == null) {
        return true;
    }
    if (propertyNameAndValue.length != 2) {
        throw new VCardInvalidLineException(""Invalid line \"""" + line + ""\"""");
    }
    String propertyName = propertyNameAndValue[0].toUpperCase();
    String propertyValue = propertyNameAndValue[1];
    mTimeParseLineAndHandleGroup += System.currentTimeMillis() - start;
    if (propertyName.equals(""ADR"") || propertyName.equals(""ORG"") || propertyName.equals(""N"")) {
        start = System.currentTimeMillis();
        handleMultiplePropertyValue(propertyName, propertyValue);
        mTimeParseAdrOrgN += System.currentTimeMillis() - start;
        return false;
    } else if (propertyName.equals(""AGENT"")) {
        handleAgent(propertyValue);
        return false;
    } else if (isValidPropertyName(propertyName)) {
        if (propertyName.equals(""BEGIN"")) {
            if (propertyValue.equals(""VCARD"")) {
                throw new VCardNestedException(""This vCard has nested vCard data in it."");
            } else {
                throw new VCardException(""Unknown BEGIN type: "" + propertyValue);
            }
        } else if (propertyName.equals(""VERSION"") && !propertyValue.equals(getVersionString())) {
            throw new VCardVersionException(""Incompatible version: "" + propertyValue + "" != "" + getVersionString());
        }
        start = System.currentTimeMillis();
        handlePropertyValue(propertyName, propertyValue);
        mTimeParsePropertyValues += System.currentTimeMillis() - start;
        return false;
    }
    throw new VCardException(""Unknown property name: \"""" + propertyName + ""\"""");
}",1,"/**
 * item = [groups "".""] name    [params] "":"" value CRLF
 * / [groups "".""] ""ADR""   [params] "":"" addressparts CRLF
 * / [groups "".""] ""ORG""   [params] "":"" orgparts CRLF
 * / [groups "".""] ""N""     [params] "":"" nameparts CRLF
 * / [groups "".""] ""AGENT"" [params] "":"" vcard CRLF
 */
","/**
 * item = [groups "".""] name    [params] "":"" value CRLF
 * / [groups "".""] ""ADR""   [params] "":"" addressparts CRLF
 * / [groups "".""] ""ORG""   [params] "":"" orgparts CRLF
 * / [groups "".""] ""N""     [params] "":"" nameparts CRLF
 * / [groups "".""] ""AGENT"" [params] "":"" vcard CRLF
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,1,"The dependent API getVersion() has changed to getVersionString() in the late version, so the change type is 5.","Because the dependent API has changed, this could potentially cause the method to return a different result, so the CI type is 1."
508,<android.database.sqlite.SQLiteProgram: void bindNull(int)>,7,8,<android.database.sqlite.SQLiteProgram: void bindNull(int)>,<android.database.sqlite.SQLiteProgram: void bindNull(int)>,0,"{
    acquireReference();
    try {
        native_bind_null(index);
    } finally {
        releaseReference();
    }
}","{
    if (!mDatabase.isOpen()) {
        throw new IllegalStateException(""database "" + mDatabase.getPath() + "" already closed"");
    }
    acquireReference();
    try {
        native_bind_null(index);
    } finally {
        releaseReference();
    }
}",1,"/**
 * Bind a NULL value to this statement. The value remains bound until
 * {@link #clearBindings} is called.
 *
 * @param index The 1-based index to the parameter to bind null to
 */
","/**
 * Bind a NULL value to this statement. The value remains bound until
 * {@link #clearBindings} is called.
 *
 * @param index The 1-based index to the parameter to bind null to
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,2",2,"A new control statement (if check whether the database is open) and an exception handling statement have been added, so the change type is 3,2.","Since the introduction of the new exception handling statement can change the behavior of the API to throw a new exception, the CI type is 2."
509,<android.accounts.AccountManagerService.MessageHandler: void handleMessage(Message)>,7,8,<android.accounts.AccountManagerService.MessageHandler: void handleMessage(Message)>,<android.accounts.AccountManagerService.MessageHandler: void handleMessage(Message)>,0,"{
    if (mBindHelper.handleMessage(msg)) {
        return;
    }
    switch(msg.what) {
        case MESSAGE_TIMED_OUT:
            Session session = (Session) msg.obj;
            session.onTimedOut();
            break;
        default:
            throw new IllegalStateException(""unhandled message: "" + msg.what);
    }
}","{
    switch(msg.what) {
        case MESSAGE_TIMED_OUT:
            Session session = (Session) msg.obj;
            session.onTimedOut();
            break;
        default:
            throw new IllegalStateException(""unhandled message: "" + msg.what);
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"1,3",1,"In the earlier version, handleMessage used to first check if mBindHelper.handleMessage(msg) was true and return early if so. In the later version, this has been removed, as such the change type is a 1 (return statement changed) and a 3 (control dependency change because the if-statement was deleted).","Because of the deletion of the return statement, the function can behave differently. For instance, in the earlier version, when mBindHelper.handleMessage(msg) is true, the control will return immediately from the function, but in the later version, even if mBindHelper.handleMessage(msg) is true, the switch-case control will be activated. Hence, the behavior changes in these scenarios leading to Compatibility Issue type 1."
510,<android.os.ParcelFileDescriptor: void close()>,7,8,<android.os.ParcelFileDescriptor: void close()>,<android.os.ParcelFileDescriptor: void close()>,0,"{
    mClosed = true;
    if (mParcelDescriptor != null) {
        // If this is a proxy to another file descriptor, just call through to its
        // close method.
        mParcelDescriptor.close();
    } else {
        Parcel.closeFileDescriptor(mFileDescriptor);
    }
}","{
    synchronized (this) {
        if (mClosed)
            return;
        mClosed = true;
    }
    if (mParcelDescriptor != null) {
        // If this is a proxy to another file descriptor, just call through to its
        // close method.
        mParcelDescriptor.close();
    } else {
        Parcel.closeFileDescriptor(mFileDescriptor);
    }
}",1,"/**
 * Close the ParcelFileDescriptor. This implementation closes the underlying
 * OS resources allocated to represent this stream.
 *
 * @throws IOException
 * If an error occurs attempting to close this ParcelFileDescriptor.
 */
","/**
 * Close the ParcelFileDescriptor. This implementation closes the underlying
 * OS resources allocated to represent this stream.
 *
 * @throws IOException
 * If an error occurs attempting to close this ParcelFileDescriptor.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",1,"In the later version, a synchronization block is introduced and an if condition has been added to check whether the file is already closed, so the code change type is 3 (Control dependency changed) and 4 (Other statement change).","The later version introduces a new condition to check if the file is already closed before closing it. If the file is already closed, the function will return immediately. This change potentially impact the behavior of the API as it may not close the file descriptor when called and return directly, so the API may return different values. Thus, there is a CI of type 1 (Compatibility Issue caused by potential different return values or types)."
511,<android.webkit.WebView: void reload()>,7,8,<android.webkit.WebView: void reload()>,<android.webkit.WebView: void reload()>,0,"{
    clearTextEntry();
    switchOutDrawHistory();
    mWebViewCore.sendMessage(EventHub.RELOAD);
}","{
    clearTextEntry(false);
    switchOutDrawHistory();
    mWebViewCore.sendMessage(EventHub.RELOAD);
}",1,"/**
 * Reload the current url.
 */
","/**
 * Reload the current url.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,4,5",1,"The first method call clearTextEntry() in the early version has been changed to clearTextEntry(false) in the late version. This represents a change in the parameters of the function it's calling (change type 5), it's still a return statement (change type 1), and also qualifies as an other statement change (change type 4).","The change within the clearTextEntry() method potentially returns a different value since the parameter value it now accepts has changed, which could lead to a compatibility issue (CI type 1)."
512,"<android.accounts.AbstractAccountAuthenticator.Transport: void updateCredentials(IAccountAuthenticatorResponse,Account,String,Bundle)>",7,8,"<android.accounts.AbstractAccountAuthenticator.Transport: void updateCredentials(IAccountAuthenticatorResponse,Account,String,Bundle)>","<android.accounts.AbstractAccountAuthenticator.Transport: void updateCredentials(IAccountAuthenticatorResponse,Account,String,Bundle)>",0,"{
    checkBinderPermission();
    try {
        final Bundle result = AbstractAccountAuthenticator.this.updateCredentials(new AccountAuthenticatorResponse(response), account, authTokenType, loginOptions);
        if (result != null) {
            response.onResult(result);
        }
    } catch (NetworkErrorException e) {
        response.onError(AccountManager.ERROR_CODE_NETWORK_ERROR, e.getMessage());
    } catch (UnsupportedOperationException e) {
        response.onError(AccountManager.ERROR_CODE_UNSUPPORTED_OPERATION, ""updateCredentials not supported"");
    }
}","{
    if (Log.isLoggable(TAG, Log.VERBOSE)) {
        Log.v(TAG, ""updateCredentials: "" + account + "", authTokenType "" + authTokenType);
    }
    checkBinderPermission();
    try {
        final Bundle result = AbstractAccountAuthenticator.this.updateCredentials(new AccountAuthenticatorResponse(response), account, authTokenType, loginOptions);
        if (Log.isLoggable(TAG, Log.VERBOSE)) {
            // force it to be unparcelled
            result.keySet();
            Log.v(TAG, ""updateCredentials: result "" + AccountManager.sanitizeResult(result));
        }
        if (result != null) {
            response.onResult(result);
        }
    } catch (NetworkErrorException e) {
        if (Log.isLoggable(TAG, Log.VERBOSE)) {
            Log.v(TAG, ""updateCredentials"", e);
        }
        response.onError(AccountManager.ERROR_CODE_NETWORK_ERROR, e.getMessage());
    } catch (UnsupportedOperationException e) {
        if (Log.isLoggable(TAG, Log.VERBOSE)) {
            Log.v(TAG, ""updateCredentials"", e);
        }
        response.onError(AccountManager.ERROR_CODE_UNSUPPORTED_OPERATION, ""updateCredentials not supported"");
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,4,0,"There are several new log outputs introduced in the late version where no actual logic or behaviour of the code is changed. Thus, the change type of code is 4: Other statements changed. ","Although there are changes in the code between the two versions, these changes are related to logging and do not change the behaviour or output of the function. Therefore, there is no compatibility issue, and the CI type is 0."
513,"<android.database.sqlite.SQLiteDatabase: SQLiteDatabase openDatabase(String,CursorFactory,int)>",7,8,"<android.database.sqlite.SQLiteDatabase: SQLiteDatabase openDatabase(String,CursorFactory,int)>","<android.database.sqlite.SQLiteDatabase: SQLiteDatabase openDatabase(String,CursorFactory,int)>",0,"{
    SQLiteDatabase db = null;
    try {
        // Open the database.
        return new SQLiteDatabase(path, factory, flags);
    } catch (SQLiteDatabaseCorruptException e) {
        // Try to recover from this, if we can.
        // TODO: should we do this for other open failures?
        Log.e(TAG, ""Deleting and re-creating corrupt database "" + path, e);
        EventLog.writeEvent(EVENT_DB_CORRUPT, path);
        new File(path).delete();
        return new SQLiteDatabase(path, factory, flags);
    }
}","{
    SQLiteDatabase sqliteDatabase = null;
    try {
        // Open the database.
        sqliteDatabase = new SQLiteDatabase(path, factory, flags);
        if (SQLiteDebug.DEBUG_SQL_STATEMENTS) {
            sqliteDatabase.enableSqlTracing(path);
        }
        if (SQLiteDebug.DEBUG_SQL_TIME) {
            sqliteDatabase.enableSqlProfiling(path);
        }
    } catch (SQLiteDatabaseCorruptException e) {
        // Try to recover from this, if we can.
        // TODO: should we do this for other open failures?
        Log.e(TAG, ""Deleting and re-creating corrupt database "" + path, e);
        EventLog.writeEvent(EVENT_DB_CORRUPT, path);
        if (!path.equalsIgnoreCase("":memory"")) {
            // delete is only for non-memory database files
            new File(path).delete();
        }
        sqliteDatabase = new SQLiteDatabase(path, factory, flags);
    }
    ActiveDatabases.getInstance().mActiveDatabases.add(new WeakReference<SQLiteDatabase>(sqliteDatabase));
    return sqliteDatabase;
}",1,"/**
 * Open the database according to the flags {@link #OPEN_READWRITE}
 * {@link #OPEN_READONLY} {@link #CREATE_IF_NECESSARY} and/or {@link #NO_LOCALIZED_COLLATORS}.
 *
 * <p>Sets the locale of the database to the  the system's current locale.
 * Call {@link #setLocale} if you would like something else.</p>
 *
 * @param path to database file to open and/or create
 * @param factory an optional factory class that is called to instantiate a
 * cursor when query is called, or null for default
 * @param flags to control database access mode
 * @return the newly opened database
 * @throws SQLiteException if the database cannot be opened
 */
","/**
 * Open the database according to the flags {@link #OPEN_READWRITE}
 * {@link #OPEN_READONLY} {@link #CREATE_IF_NECESSARY} and/or {@link #NO_LOCALIZED_COLLATORS}.
 *
 * <p>Sets the locale of the database to the  the system's current locale.
 * Call {@link #setLocale} if you would like something else.</p>
 *
 * @param path to database file to open and/or create
 * @param factory an optional factory class that is called to instantiate a
 * cursor when query is called, or null for default
 * @param flags to control database access mode
 * @return the newly opened database
 * @throws SQLiteException if the database cannot be opened
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1, 3, 4","1,2","The return statements within the 'try' and 'catch' blocks have been removed, and a new return statement has been introduced outside of them. Additionally, the variable returned ('db' to 'sqliteDatabase') and the handling of 'SQLiteDatabaseCorruptException' have changed. Moreover, new 'if' conditions that enable SQLite Debugging have been introduced. Therefore, the code change types are 1 (return statement changed), 3 (control dependency changed), and 4 (other statement changed).","The return statement of the function has changed which could lead to different return values. Furthermore, exception handling for `SQLiteDatabaseCorruptException` has changed. Therefore, this could cause potential differences in return values or types (CI type 1) and potential differences in exception handling (CI type 2)."
514,"<android.webkit.WebView: boolean onKeyDown(int,KeyEvent)>",7,8,"<android.webkit.WebView: boolean onKeyDown(int,KeyEvent)>","<android.webkit.WebView: boolean onKeyDown(int,KeyEvent)>",0,"{
    if (DebugFlags.WEB_VIEW) {
        Log.v(LOGTAG, ""keyDown at "" + System.currentTimeMillis() + "", "" + event + "", unicode="" + event.getUnicodeChar());
    }
    if (mNativeClass == 0) {
        return false;
    }
    // do this hack up front, so it always works, regardless of touch-mode
    if (AUTO_REDRAW_HACK && (keyCode == KeyEvent.KEYCODE_CALL)) {
        mAutoRedraw = !mAutoRedraw;
        if (mAutoRedraw) {
            invalidate();
        }
        return true;
    }
    // 2. the host application wants to handle it;
    if (event.isSystem() || mCallbackProxy.uiOverrideKeyEvent(event)) {
        return false;
    }
    if (mShiftIsPressed == false && nativeCursorWantsKeyEvents() == false && (keyCode == KeyEvent.KEYCODE_SHIFT_LEFT || keyCode == KeyEvent.KEYCODE_SHIFT_RIGHT)) {
        mExtendSelection = false;
        mShiftIsPressed = true;
        if (nativeHasCursorNode()) {
            Rect rect = nativeCursorNodeBounds();
            mSelectX = contentToViewX(rect.left);
            mSelectY = contentToViewY(rect.top);
        } else {
            mSelectX = mScrollX + (int) mLastTouchX;
            mSelectY = mScrollY + (int) mLastTouchY;
        }
        nativeHideCursor();
    }
    if (keyCode >= KeyEvent.KEYCODE_DPAD_UP && keyCode <= KeyEvent.KEYCODE_DPAD_RIGHT) {
        // always handle the navigation keys in the UI thread
        switchOutDrawHistory();
        if (navHandledKey(keyCode, 1, false, event.getEventTime(), false)) {
            playSoundEffect(keyCodeToSoundsEffect(keyCode));
            return true;
        }
        // Bubble up the key event as WebView doesn't handle it
        return false;
    }
    if (keyCode == KeyEvent.KEYCODE_DPAD_CENTER) {
        switchOutDrawHistory();
        if (event.getRepeatCount() == 0) {
            mGotCenterDown = true;
            mPrivateHandler.sendMessageDelayed(mPrivateHandler.obtainMessage(LONG_PRESS_CENTER), LONG_PRESS_TIMEOUT);
            // Already checked mNativeClass, so we do not need to check it
            // again.
            nativeRecordButtons(hasFocus() && hasWindowFocus(), true, true);
            return true;
        }
        // Bubble up the key event as WebView doesn't handle it
        return false;
    }
    if (keyCode != KeyEvent.KEYCODE_SHIFT_LEFT && keyCode != KeyEvent.KEYCODE_SHIFT_RIGHT) {
        // turn off copy select if a shift-key combo is pressed
        mExtendSelection = mShiftIsPressed = false;
        if (mTouchMode == TOUCH_SELECT_MODE) {
            mTouchMode = TOUCH_INIT_MODE;
        }
    }
    if (getSettings().getNavDump()) {
        switch(keyCode) {
            case KeyEvent.KEYCODE_4:
                // ""/data/data/com.android.browser/displayTree.txt""
                nativeDumpDisplayTree(getUrl());
                break;
            case KeyEvent.KEYCODE_5:
            case KeyEvent.KEYCODE_6:
                // 5: dump the dom tree to the file
                // ""/data/data/com.android.browser/domTree.txt""
                // 6: dump the dom tree to the adb log
                mWebViewCore.sendMessage(EventHub.DUMP_DOMTREE, (keyCode == KeyEvent.KEYCODE_5) ? 1 : 0, 0);
                break;
            case KeyEvent.KEYCODE_7:
            case KeyEvent.KEYCODE_8:
                // 7: dump the render tree to the file
                // ""/data/data/com.android.browser/renderTree.txt""
                // 8: dump the render tree to the adb log
                mWebViewCore.sendMessage(EventHub.DUMP_RENDERTREE, (keyCode == KeyEvent.KEYCODE_7) ? 1 : 0, 0);
                break;
            case KeyEvent.KEYCODE_9:
                nativeInstrumentReport();
                return true;
        }
    }
    if (nativeCursorIsPlugin()) {
        nativeUpdatePluginReceivesEvents();
        invalidate();
    } else if (nativeCursorIsTextInput()) {
        // This message will put the node in focus, for the DOM's notion
        // of focus, and make the focuscontroller active
        mWebViewCore.sendMessage(EventHub.CLICK, nativeCursorFramePointer(), nativeCursorNodePointer());
        // This will bring up the WebTextView and put it in focus, for
        // our view system's notion of focus
        rebuildWebTextView();
        // Now we need to pass the event to it
        return mWebTextView.onKeyDown(keyCode, event);
    } else if (nativeHasFocusNode()) {
        // In this case, the cursor is not on a text input, but the focus
        // might be.  Check it, and if so, hand over to the WebTextView.
        rebuildWebTextView();
        if (inEditingMode()) {
            return mWebTextView.onKeyDown(keyCode, event);
        }
    }
    // TODO: should we pass all the keys to DOM or check the meta tag
    if (nativeCursorWantsKeyEvents() || true) {
        // pass the key to DOM
        mWebViewCore.sendMessage(EventHub.KEY_DOWN, event);
        // return true as DOM handles the key
        return true;
    }
    // Bubble up the key event as WebView doesn't handle it
    return false;
}","{
    if (DebugFlags.WEB_VIEW) {
        Log.v(LOGTAG, ""keyDown at "" + System.currentTimeMillis() + "", "" + event + "", unicode="" + event.getUnicodeChar());
    }
    if (mNativeClass == 0) {
        return false;
    }
    // do this hack up front, so it always works, regardless of touch-mode
    if (AUTO_REDRAW_HACK && (keyCode == KeyEvent.KEYCODE_CALL)) {
        mAutoRedraw = !mAutoRedraw;
        if (mAutoRedraw) {
            invalidate();
        }
        return true;
    }
    // 2. the host application wants to handle it;
    if (event.isSystem() || mCallbackProxy.uiOverrideKeyEvent(event)) {
        return false;
    }
    if (keyCode == KeyEvent.KEYCODE_SHIFT_LEFT || keyCode == KeyEvent.KEYCODE_SHIFT_RIGHT) {
        if (nativeFocusIsPlugin()) {
            mShiftIsPressed = true;
        } else if (!nativeCursorWantsKeyEvents() && !mShiftIsPressed) {
            setUpSelectXY();
        }
    }
    if (keyCode >= KeyEvent.KEYCODE_DPAD_UP && keyCode <= KeyEvent.KEYCODE_DPAD_RIGHT) {
        switchOutDrawHistory();
        if (nativeFocusIsPlugin()) {
            letPluginHandleNavKey(keyCode, event.getEventTime(), true);
            return true;
        }
        if (mShiftIsPressed) {
            int xRate = keyCode == KeyEvent.KEYCODE_DPAD_LEFT ? -1 : keyCode == KeyEvent.KEYCODE_DPAD_RIGHT ? 1 : 0;
            int yRate = keyCode == KeyEvent.KEYCODE_DPAD_UP ? -1 : keyCode == KeyEvent.KEYCODE_DPAD_DOWN ? 1 : 0;
            int multiplier = event.getRepeatCount() + 1;
            moveSelection(xRate * multiplier, yRate * multiplier);
            return true;
        }
        if (navHandledKey(keyCode, 1, false, event.getEventTime())) {
            playSoundEffect(keyCodeToSoundsEffect(keyCode));
            return true;
        }
        // Bubble up the key event as WebView doesn't handle it
        return false;
    }
    if (keyCode == KeyEvent.KEYCODE_DPAD_CENTER) {
        switchOutDrawHistory();
        if (event.getRepeatCount() == 0) {
            if (mShiftIsPressed && !nativeFocusIsPlugin()) {
                // discard press if copy in progress
                return true;
            }
            mGotCenterDown = true;
            mPrivateHandler.sendMessageDelayed(mPrivateHandler.obtainMessage(LONG_PRESS_CENTER), LONG_PRESS_TIMEOUT);
            // Already checked mNativeClass, so we do not need to check it
            // again.
            nativeRecordButtons(hasFocus() && hasWindowFocus(), true, true);
            return true;
        }
        // Bubble up the key event as WebView doesn't handle it
        return false;
    }
    if (keyCode != KeyEvent.KEYCODE_SHIFT_LEFT && keyCode != KeyEvent.KEYCODE_SHIFT_RIGHT) {
        // turn off copy select if a shift-key combo is pressed
        mExtendSelection = mShiftIsPressed = false;
        if (mTouchMode == TOUCH_SELECT_MODE) {
            mTouchMode = TOUCH_INIT_MODE;
        }
    }
    if (getSettings().getNavDump()) {
        switch(keyCode) {
            case KeyEvent.KEYCODE_4:
                dumpDisplayTree();
                break;
            case KeyEvent.KEYCODE_5:
            case KeyEvent.KEYCODE_6:
                dumpDomTree(keyCode == KeyEvent.KEYCODE_5);
                break;
            case KeyEvent.KEYCODE_7:
            case KeyEvent.KEYCODE_8:
                dumpRenderTree(keyCode == KeyEvent.KEYCODE_7);
                break;
            case KeyEvent.KEYCODE_9:
                nativeInstrumentReport();
                return true;
        }
    }
    if (nativeCursorIsTextInput()) {
        // This message will put the node in focus, for the DOM's notion
        // of focus, and make the focuscontroller active
        mWebViewCore.sendMessage(EventHub.CLICK, nativeCursorFramePointer(), nativeCursorNodePointer());
        // This will bring up the WebTextView and put it in focus, for
        // our view system's notion of focus
        rebuildWebTextView();
        // Now we need to pass the event to it
        if (inEditingMode()) {
            mWebTextView.setDefaultSelection();
            return mWebTextView.dispatchKeyEvent(event);
        }
    } else if (nativeHasFocusNode()) {
        // In this case, the cursor is not on a text input, but the focus
        // might be.  Check it, and if so, hand over to the WebTextView.
        rebuildWebTextView();
        if (inEditingMode()) {
            mWebTextView.setDefaultSelection();
            return mWebTextView.dispatchKeyEvent(event);
        }
    }
    // TODO: should we pass all the keys to DOM or check the meta tag
    if (nativeCursorWantsKeyEvents() || true) {
        // pass the key to DOM
        mWebViewCore.sendMessage(EventHub.KEY_DOWN, event);
        // return true as DOM handles the key
        return true;
    }
    // Bubble up the key event as WebView doesn't handle it
    return false;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,3,4",1,"Multiple changes have been detected. First, the method calls have changed within 'if' and 'switch' statements and a new method, setUpSelectXY(), has been introduced, qualifying it as type 1 and type 4 changes. The control dependencies (specifically the conditions of if statements) have also been modified, which categorizes it under type 3 change.","Due to the combination of changes in the new return statements and changes in control dependencies, the API can return different results in the early and late version, which may imply potential difference in behavior. This can be classified as a type 1 compatibility issue."
517,"<android.webkit.WebView: boolean restorePicture(Bundle,File)>",7,8,"<android.webkit.WebView: boolean restorePicture(Bundle,File)>","<android.webkit.WebView: boolean restorePicture(Bundle,File)>",0,"{
    if (src == null || b == null) {
        return false;
    }
    if (src.exists()) {
        Picture p = null;
        try {
            final FileInputStream in = new FileInputStream(src);
            p = Picture.createFromStream(in);
            in.close();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        } catch (RuntimeException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        }
        if (p != null) {
            int sx = b.getInt(""scrollX"", 0);
            int sy = b.getInt(""scrollY"", 0);
            float scale = b.getFloat(""scale"", 1.0f);
            mDrawHistory = true;
            mHistoryPicture = p;
            mScrollX = sx;
            mScrollY = sy;
            mHistoryWidth = Math.round(p.getWidth() * scale);
            mHistoryHeight = Math.round(p.getHeight() * scale);
            // as getWidth() / getHeight() of the view are not
            // available yet, set up mActualScale, so that when
            // onSizeChanged() is called, the rest will be set
            // correctly
            mActualScale = scale;
            mTextWrapScale = b.getFloat(""textwrapScale"", scale);
            mInZoomOverview = b.getBoolean(""overview"");
            invalidate();
            return true;
        }
    }
    return false;
}","{
    if (src == null || b == null) {
        return false;
    }
    if (!src.exists()) {
        return false;
    }
    try {
        final FileInputStream in = new FileInputStream(src);
        final Bundle copy = new Bundle(b);
        new Thread(new Runnable() {

            public void run() {
                final Picture p = Picture.createFromStream(in);
                if (p != null) {
                    // Post a runnable on the main thread to update the
                    // history picture fields.
                    mPrivateHandler.post(new Runnable() {

                        public void run() {
                            restoreHistoryPictureFields(p, copy);
                        }
                    });
                }
                try {
                    in.close();
                } catch (Exception e) {
                // Nothing we can do now.
                }
            }
        }).start();
    } catch (FileNotFoundException e) {
        e.printStackTrace();
    }
    return true;
}",1,"/**
 * Restore the display data that was save in {@link #savePicture}. Used in
 * conjunction with {@link #restoreState}.
 * @param b A Bundle containing the saved display data.
 * @param src The file where the picture data was stored.
 * @return True if the picture was successfully restored.
 */
","/**
 * Restore the display data that was save in {@link #savePicture}. Used in
 * conjunction with {@link #restoreState}.
 * @param b A Bundle containing the saved display data.
 * @param src The file where the picture data was stored.
 * @return True if the picture was successfully restored.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,2,3,4","1,2","The return statements and exception handling have been changed. In addition, the ""while"" loop has been replaced by a new Thread implementation, and the business logic inside the method has been altered considerably. This makes the code change type as 1,2,3,4.","The change in the return statements and exception handling, as well as the adjustment in control dependency because of the thread implementation, will lead to potential different behaviors (i.e., different return values and exceptions). Therefore, the CI type is 1,2."
518,"<android.util.Log: int w(String,String)>",7,8,"<android.util.Log: int w(String,String)>","<android.util.Log: int w(String,String)>",0,"{
    return println(WARN, tag, msg);
}","{
    return println_native(LOG_ID_MAIN, WARN, tag, msg);
}",1,"/**
 * Send a {@link #WARN} log message.
 * @param tag Used to identify the source of a log message.  It usually identifies
 * the class or activity where the log call occurs.
 * @param msg The message you would like logged.
 */
","/**
 * Send a {@link #WARN} log message.
 * @param tag Used to identify the source of a log message.  It usually identifies
 * the class or activity where the log call occurs.
 * @param msg The message you would like logged.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The return statement has changed from println(WARN, tag, msg) to println_native(LOG_ID_MAIN, WARN, tag, msg). Here, the dependent method println() has also changed, therefore, the code change types are 1 and 5.",The change in return statement implies that the API may potentially return a different value or type in the late version than in the early version so the type of Compatibility Issue here is 1.
519,<android.util.EventLog.Event: Object getData()>,7,8,<android.util.EventLog.Event: Object getData()>,<android.util.EventLog.Event: Object getData()>,0,"{
    mBuffer.limit(PAYLOAD_START + mBuffer.getShort(LENGTH_OFFSET));
    // Just after the tag.
    mBuffer.position(DATA_START);
    return decodeObject();
}","{
    try {
        mBuffer.limit(PAYLOAD_START + mBuffer.getShort(LENGTH_OFFSET));
        // Just after the tag.
        mBuffer.position(DATA_START);
        return decodeObject();
    } catch (IllegalArgumentException e) {
        Log.wtf(TAG, ""Illegal entry payload: tag="" + getTag(), e);
        return null;
    } catch (BufferUnderflowException e) {
        Log.wtf(TAG, ""Truncated entry payload: tag="" + getTag(), e);
        return null;
    }
}",1,"/**
 * @return one of Integer, Long, String, or List.
 */
","/**
 * @return one of Integer, Long, String, null, or Object[] of same.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,3","1,2","In the late version, the three statements : (1) mBuffer.limit(PAYLOAD_START + mBuffer.getShort(LENGTH_OFFSET)) (2) mBuffer.position(DATA_START) (3) return decodeObject() , previously present, are now within a try block. Two new catch blocks have been introduced, one for IllegalArgumentException and another for BufferUnderflowException. They log an exception and return a null. Therefore, the change types here are Exception handling statement changed (2) and Control dependency changed (3).","Due to the introduction of the catch blocks, the method can now throw new exceptions. It can also return a null value when there is an exception, which was not the case in the early version. Therefore, there is a Compatibility issue due to potential different return values (1) and different exception handlings (2)."
520,<android.webkit.CacheLoader: boolean setupStreamAndSendStatus()>,7,8,<android.webkit.CacheLoader: boolean setupStreamAndSendStatus()>,<android.webkit.CacheLoader: boolean setupStreamAndSendStatus()>,0,"{
    mDataStream = mCacheResult.inStream;
    mContentLength = mCacheResult.contentLength;
    mHandler.status(1, 1, mCacheResult.httpStatusCode, ""OK"");
    return true;
}","{
    mDataStream = mCacheResult.inStream;
    mContentLength = mCacheResult.contentLength;
    mLoadListener.status(1, 1, mCacheResult.httpStatusCode, ""OK"");
    return true;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"Handler's method status() was changed to LoadListener's status(), this represents an instance change to call the same method which is type 4.","Given the fact that the method status() remains the same in the two interfaces handler and loadListener, it doesn't lead to any compatibility issue since the functionality of the method remains intact. Hence, it's compatible and no compatibility issue exists (0)."
521,"<android.widget.ExpandableListView: boolean performItemClick(View,int,long)>",7,8,"<android.widget.ExpandableListView: boolean performItemClick(View,int,long)>","<android.widget.ExpandableListView: boolean performItemClick(View,int,long)>",0,"{
    // Ignore clicks in header/footers
    final int headerViewsCount = getHeaderViewsCount();
    final int footerViewsStart = mItemCount - getFooterViewsCount();
    if (position < headerViewsCount || position >= footerViewsStart) {
        // Clicked on a header/footer, so ignore pass it on to super
        return super.performItemClick(v, position, id);
    }
    // Internally handle the item click
    return handleItemClick(v, position - headerViewsCount, id);
}","{
    // Ignore clicks in header/footers
    if (isHeaderOrFooterPosition(position)) {
        // Clicked on a header/footer, so ignore pass it on to super
        return super.performItemClick(v, position, id);
    }
    // Internally handle the item click
    final int adjustedPosition = getFlatPositionForConnector(position);
    return handleItemClick(v, adjustedPosition, id);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,4,5",1,"The condition in the if statement has been changed from comparing position with headerViewsCount and footerViewsStart to invoking a new method isHeaderOrFooterPosition(). The statements inside the last return have changed as well; 'position - headerViewsCount' is replaced by a new method getFlatPositionForConnector(position). Thus, the code change type is 3,4,5.","These changes to the condition and return statements can potentially lead to the API returning different values, hence the CI type is 1."
522,<android.widget.ListView: void layoutChildren()>,7,8,<android.widget.ListView: void layoutChildren()>,<android.widget.ListView: void layoutChildren()>,0,"{
    final boolean blockLayoutRequests = mBlockLayoutRequests;
    if (!blockLayoutRequests) {
        mBlockLayoutRequests = true;
    } else {
        return;
    }
    try {
        super.layoutChildren();
        invalidate();
        if (mAdapter == null) {
            resetList();
            invokeOnItemScrollListener();
            return;
        }
        int childrenTop = mListPadding.top;
        int childrenBottom = mBottom - mTop - mListPadding.bottom;
        int childCount = getChildCount();
        int index;
        int delta = 0;
        View sel;
        View oldSel = null;
        View oldFirst = null;
        View newSel = null;
        View focusLayoutRestoreView = null;
        // Remember stuff we will need down below
        switch(mLayoutMode) {
            case LAYOUT_SET_SELECTION:
                index = mNextSelectedPosition - mFirstPosition;
                if (index >= 0 && index < childCount) {
                    newSel = getChildAt(index);
                }
                break;
            case LAYOUT_FORCE_TOP:
            case LAYOUT_FORCE_BOTTOM:
            case LAYOUT_SPECIFIC:
            case LAYOUT_SYNC:
                break;
            case LAYOUT_MOVE_SELECTION:
            default:
                // Remember the previously selected view
                index = mSelectedPosition - mFirstPosition;
                if (index >= 0 && index < childCount) {
                    oldSel = getChildAt(index);
                }
                // Remember the previous first child
                oldFirst = getChildAt(0);
                if (mNextSelectedPosition >= 0) {
                    delta = mNextSelectedPosition - mSelectedPosition;
                }
                // Caution: newSel might be null
                newSel = getChildAt(index + delta);
        }
        boolean dataChanged = mDataChanged;
        if (dataChanged) {
            handleDataChanged();
        }
        // and calling it a day
        if (mItemCount == 0) {
            resetList();
            invokeOnItemScrollListener();
            return;
        } else if (mItemCount != mAdapter.getCount()) {
            throw new IllegalStateException(""The content of the adapter has changed but "" + ""ListView did not receive a notification. Make sure the content of "" + ""your adapter is not modified from a background thread, but only "" + ""from the UI thread. [in ListView("" + getId() + "", "" + getClass() + "") with Adapter("" + mAdapter.getClass() + "")]"");
        }
        setSelectedPositionInt(mNextSelectedPosition);
        // Pull all children into the RecycleBin.
        // These views will be reused if possible
        final int firstPosition = mFirstPosition;
        final RecycleBin recycleBin = mRecycler;
        // reset the focus restoration
        View focusLayoutRestoreDirectChild = null;
        // already cached in mHeaderViews;
        if (dataChanged) {
            for (int i = 0; i < childCount; i++) {
                recycleBin.addScrapView(getChildAt(i));
                if (ViewDebug.TRACE_RECYCLER) {
                    ViewDebug.trace(getChildAt(i), ViewDebug.RecyclerTraceType.MOVE_TO_SCRAP_HEAP, index, i);
                }
            }
        } else {
            recycleBin.fillActiveViews(childCount, firstPosition);
        }
        // take focus back to us temporarily to avoid the eventual
        // call to clear focus when removing the focused child below
        // from messing things up when ViewRoot assigns focus back
        // to someone else
        final View focusedChild = getFocusedChild();
        if (focusedChild != null) {
            // data hasn't changed, or if the focused position is a header or footer
            if (!dataChanged || isDirectChildHeaderOrFooter(focusedChild)) {
                focusLayoutRestoreDirectChild = focusedChild;
                // remember the specific view that had focus
                focusLayoutRestoreView = findFocus();
                if (focusLayoutRestoreView != null) {
                    // tell it we are going to mess with it
                    focusLayoutRestoreView.onStartTemporaryDetach();
                }
            }
            requestFocus();
        }
        // Clear out old views
        // removeAllViewsInLayout();
        detachAllViewsFromParent();
        switch(mLayoutMode) {
            case LAYOUT_SET_SELECTION:
                if (newSel != null) {
                    sel = fillFromSelection(newSel.getTop(), childrenTop, childrenBottom);
                } else {
                    sel = fillFromMiddle(childrenTop, childrenBottom);
                }
                break;
            case LAYOUT_SYNC:
                sel = fillSpecific(mSyncPosition, mSpecificTop);
                break;
            case LAYOUT_FORCE_BOTTOM:
                sel = fillUp(mItemCount - 1, childrenBottom);
                adjustViewsUpOrDown();
                break;
            case LAYOUT_FORCE_TOP:
                mFirstPosition = 0;
                sel = fillFromTop(childrenTop);
                adjustViewsUpOrDown();
                break;
            case LAYOUT_SPECIFIC:
                sel = fillSpecific(reconcileSelectedPosition(), mSpecificTop);
                break;
            case LAYOUT_MOVE_SELECTION:
                sel = moveSelection(oldSel, newSel, delta, childrenTop, childrenBottom);
                break;
            default:
                if (childCount == 0) {
                    if (!mStackFromBottom) {
                        final int position = lookForSelectablePosition(0, true);
                        setSelectedPositionInt(position);
                        sel = fillFromTop(childrenTop);
                    } else {
                        final int position = lookForSelectablePosition(mItemCount - 1, false);
                        setSelectedPositionInt(position);
                        sel = fillUp(mItemCount - 1, childrenBottom);
                    }
                } else {
                    if (mSelectedPosition >= 0 && mSelectedPosition < mItemCount) {
                        sel = fillSpecific(mSelectedPosition, oldSel == null ? childrenTop : oldSel.getTop());
                    } else if (mFirstPosition < mItemCount) {
                        sel = fillSpecific(mFirstPosition, oldFirst == null ? childrenTop : oldFirst.getTop());
                    } else {
                        sel = fillSpecific(0, childrenTop);
                    }
                }
                break;
        }
        // Flush any cached views that did not get reused above
        recycleBin.scrapActiveViews();
        if (sel != null) {
            // are focusable
            if (mItemsCanFocus && hasFocus() && !sel.hasFocus()) {
                final boolean focusWasTaken = (sel == focusLayoutRestoreDirectChild && focusLayoutRestoreView.requestFocus()) || sel.requestFocus();
                if (!focusWasTaken) {
                    // selected item didn't take focus, fine, but still want
                    // to make sure something else outside of the selected view
                    // has focus
                    final View focused = getFocusedChild();
                    if (focused != null) {
                        focused.clearFocus();
                    }
                    positionSelector(sel);
                } else {
                    sel.setSelected(false);
                    mSelectorRect.setEmpty();
                }
            } else {
                positionSelector(sel);
            }
            mSelectedTop = sel.getTop();
        } else {
            if (mTouchMode > TOUCH_MODE_DOWN && mTouchMode < TOUCH_MODE_SCROLL) {
                View child = getChildAt(mMotionPosition - mFirstPosition);
                if (child != null)
                    positionSelector(child);
            } else {
                mSelectedTop = 0;
                mSelectorRect.setEmpty();
            }
            // focus (i.e. something focusable in touch mode)
            if (hasFocus() && focusLayoutRestoreView != null) {
                focusLayoutRestoreView.requestFocus();
            }
        }
        // our view hierarchy.
        if (focusLayoutRestoreView != null && focusLayoutRestoreView.getWindowToken() != null) {
            focusLayoutRestoreView.onFinishTemporaryDetach();
        }
        mLayoutMode = LAYOUT_NORMAL;
        mDataChanged = false;
        mNeedSync = false;
        setNextSelectedPositionInt(mSelectedPosition);
        updateScrollIndicators();
        if (mItemCount > 0) {
            checkSelectionChanged();
        }
        invokeOnItemScrollListener();
    } finally {
        if (!blockLayoutRequests) {
            mBlockLayoutRequests = false;
        }
    }
}","{
    final boolean blockLayoutRequests = mBlockLayoutRequests;
    if (!blockLayoutRequests) {
        mBlockLayoutRequests = true;
    } else {
        return;
    }
    try {
        super.layoutChildren();
        invalidate();
        if (mAdapter == null) {
            resetList();
            invokeOnItemScrollListener();
            return;
        }
        int childrenTop = mListPadding.top;
        int childrenBottom = mBottom - mTop - mListPadding.bottom;
        int childCount = getChildCount();
        int index = 0;
        int delta = 0;
        View sel;
        View oldSel = null;
        View oldFirst = null;
        View newSel = null;
        View focusLayoutRestoreView = null;
        // Remember stuff we will need down below
        switch(mLayoutMode) {
            case LAYOUT_SET_SELECTION:
                index = mNextSelectedPosition - mFirstPosition;
                if (index >= 0 && index < childCount) {
                    newSel = getChildAt(index);
                }
                break;
            case LAYOUT_FORCE_TOP:
            case LAYOUT_FORCE_BOTTOM:
            case LAYOUT_SPECIFIC:
            case LAYOUT_SYNC:
                break;
            case LAYOUT_MOVE_SELECTION:
            default:
                // Remember the previously selected view
                index = mSelectedPosition - mFirstPosition;
                if (index >= 0 && index < childCount) {
                    oldSel = getChildAt(index);
                }
                // Remember the previous first child
                oldFirst = getChildAt(0);
                if (mNextSelectedPosition >= 0) {
                    delta = mNextSelectedPosition - mSelectedPosition;
                }
                // Caution: newSel might be null
                newSel = getChildAt(index + delta);
        }
        boolean dataChanged = mDataChanged;
        if (dataChanged) {
            handleDataChanged();
        }
        // and calling it a day
        if (mItemCount == 0) {
            resetList();
            invokeOnItemScrollListener();
            return;
        } else if (mItemCount != mAdapter.getCount()) {
            throw new IllegalStateException(""The content of the adapter has changed but "" + ""ListView did not receive a notification. Make sure the content of "" + ""your adapter is not modified from a background thread, but only "" + ""from the UI thread. [in ListView("" + getId() + "", "" + getClass() + "") with Adapter("" + mAdapter.getClass() + "")]"");
        }
        setSelectedPositionInt(mNextSelectedPosition);
        // Pull all children into the RecycleBin.
        // These views will be reused if possible
        final int firstPosition = mFirstPosition;
        final RecycleBin recycleBin = mRecycler;
        // reset the focus restoration
        View focusLayoutRestoreDirectChild = null;
        // already cached in mHeaderViews;
        if (dataChanged) {
            for (int i = 0; i < childCount; i++) {
                recycleBin.addScrapView(getChildAt(i));
                if (ViewDebug.TRACE_RECYCLER) {
                    ViewDebug.trace(getChildAt(i), ViewDebug.RecyclerTraceType.MOVE_TO_SCRAP_HEAP, index, i);
                }
            }
        } else {
            recycleBin.fillActiveViews(childCount, firstPosition);
        }
        // take focus back to us temporarily to avoid the eventual
        // call to clear focus when removing the focused child below
        // from messing things up when ViewRoot assigns focus back
        // to someone else
        final View focusedChild = getFocusedChild();
        if (focusedChild != null) {
            // data hasn't changed, or if the focused position is a header or footer
            if (!dataChanged || isDirectChildHeaderOrFooter(focusedChild)) {
                focusLayoutRestoreDirectChild = focusedChild;
                // remember the specific view that had focus
                focusLayoutRestoreView = findFocus();
                if (focusLayoutRestoreView != null) {
                    // tell it we are going to mess with it
                    focusLayoutRestoreView.onStartTemporaryDetach();
                }
            }
            requestFocus();
        }
        // Clear out old views
        detachAllViewsFromParent();
        switch(mLayoutMode) {
            case LAYOUT_SET_SELECTION:
                if (newSel != null) {
                    sel = fillFromSelection(newSel.getTop(), childrenTop, childrenBottom);
                } else {
                    sel = fillFromMiddle(childrenTop, childrenBottom);
                }
                break;
            case LAYOUT_SYNC:
                sel = fillSpecific(mSyncPosition, mSpecificTop);
                break;
            case LAYOUT_FORCE_BOTTOM:
                sel = fillUp(mItemCount - 1, childrenBottom);
                adjustViewsUpOrDown();
                break;
            case LAYOUT_FORCE_TOP:
                mFirstPosition = 0;
                sel = fillFromTop(childrenTop);
                adjustViewsUpOrDown();
                break;
            case LAYOUT_SPECIFIC:
                sel = fillSpecific(reconcileSelectedPosition(), mSpecificTop);
                break;
            case LAYOUT_MOVE_SELECTION:
                sel = moveSelection(oldSel, newSel, delta, childrenTop, childrenBottom);
                break;
            default:
                if (childCount == 0) {
                    if (!mStackFromBottom) {
                        final int position = lookForSelectablePosition(0, true);
                        setSelectedPositionInt(position);
                        sel = fillFromTop(childrenTop);
                    } else {
                        final int position = lookForSelectablePosition(mItemCount - 1, false);
                        setSelectedPositionInt(position);
                        sel = fillUp(mItemCount - 1, childrenBottom);
                    }
                } else {
                    if (mSelectedPosition >= 0 && mSelectedPosition < mItemCount) {
                        sel = fillSpecific(mSelectedPosition, oldSel == null ? childrenTop : oldSel.getTop());
                    } else if (mFirstPosition < mItemCount) {
                        sel = fillSpecific(mFirstPosition, oldFirst == null ? childrenTop : oldFirst.getTop());
                    } else {
                        sel = fillSpecific(0, childrenTop);
                    }
                }
                break;
        }
        // Flush any cached views that did not get reused above
        recycleBin.scrapActiveViews();
        if (sel != null) {
            // are focusable
            if (mItemsCanFocus && hasFocus() && !sel.hasFocus()) {
                final boolean focusWasTaken = (sel == focusLayoutRestoreDirectChild && focusLayoutRestoreView.requestFocus()) || sel.requestFocus();
                if (!focusWasTaken) {
                    // selected item didn't take focus, fine, but still want
                    // to make sure something else outside of the selected view
                    // has focus
                    final View focused = getFocusedChild();
                    if (focused != null) {
                        focused.clearFocus();
                    }
                    positionSelector(sel);
                } else {
                    sel.setSelected(false);
                    mSelectorRect.setEmpty();
                }
            } else {
                positionSelector(sel);
            }
            mSelectedTop = sel.getTop();
        } else {
            if (mTouchMode > TOUCH_MODE_DOWN && mTouchMode < TOUCH_MODE_SCROLL) {
                View child = getChildAt(mMotionPosition - mFirstPosition);
                if (child != null)
                    positionSelector(child);
            } else {
                mSelectedTop = 0;
                mSelectorRect.setEmpty();
            }
            // focus (i.e. something focusable in touch mode)
            if (hasFocus() && focusLayoutRestoreView != null) {
                focusLayoutRestoreView.requestFocus();
            }
        }
        // our view hierarchy.
        if (focusLayoutRestoreView != null && focusLayoutRestoreView.getWindowToken() != null) {
            focusLayoutRestoreView.onFinishTemporaryDetach();
        }
        mLayoutMode = LAYOUT_NORMAL;
        mDataChanged = false;
        mNeedSync = false;
        setNextSelectedPositionInt(mSelectedPosition);
        updateScrollIndicators();
        if (mItemCount > 0) {
            checkSelectionChanged();
        }
        invokeOnItemScrollListener();
    } finally {
        if (!blockLayoutRequests) {
            mBlockLayoutRequests = false;
        }
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,,,,
523,<android.hardware.SensorManager.SensorThread.SensorThreadRunnable: void run()>,7,8,<android.hardware.SensorManager.SensorThread.SensorThreadRunnable: void run()>,<android.hardware.SensorManager.SensorThread.SensorThreadRunnable: void run()>,0,"{
    // Log.d(TAG, ""entering main sensor thread"");
    final float[] values = new float[3];
    final int[] status = new int[1];
    final long[] timestamp = new long[1];
    Process.setThreadPriority(Process.THREAD_PRIORITY_DISPLAY);
    if (!open()) {
        return;
    }
    while (true) {
        // wait for an event
        final int sensor = sensors_data_poll(values, status, timestamp);
        int accuracy = status[0];
        synchronized (sListeners) {
            if (sensor == -1 || sListeners.isEmpty()) {
                if (sensor == -1) {
                    // we lost the connection to the event stream. this happens
                    // when the last listener is removed.
                    Log.d(TAG, ""_sensors_data_poll() failed, we bail out."");
                }
                // we have no more listeners or polling failed, terminate the thread
                sensors_data_close();
                mThread = null;
                break;
            }
            final Sensor sensorObject = sHandleToSensor.get(sensor);
            if (sensorObject != null) {
                // report the sensor event to all listeners that
                // care about it.
                final int size = sListeners.size();
                for (int i = 0; i < size; i++) {
                    ListenerDelegate listener = sListeners.get(i);
                    if (listener.hasSensor(sensorObject)) {
                        // this is asynchronous (okay to call
                        // with sListeners lock held).
                        listener.onSensorChangedLocked(sensorObject, values, timestamp, accuracy);
                    }
                }
            }
        }
    }
// Log.d(TAG, ""exiting main sensor thread"");
}","{
    // Log.d(TAG, ""entering main sensor thread"");
    final float[] values = new float[3];
    final int[] status = new int[1];
    final long[] timestamp = new long[1];
    Process.setThreadPriority(Process.THREAD_PRIORITY_URGENT_DISPLAY);
    if (!open()) {
        return;
    }
    synchronized (this) {
        // we've open the driver, we're ready to open the sensors
        mSensorsReady = true;
        this.notify();
    }
    while (true) {
        // wait for an event
        final int sensor = sensors_data_poll(values, status, timestamp);
        int accuracy = status[0];
        synchronized (sListeners) {
            if (sensor == -1 || sListeners.isEmpty()) {
                if (sensor == -1) {
                    // we lost the connection to the event stream. this happens
                    // when the last listener is removed.
                    Log.d(TAG, ""_sensors_data_poll() failed, we bail out."");
                }
                // we have no more listeners or polling failed, terminate the thread
                sensors_data_close();
                mThread = null;
                break;
            }
            final Sensor sensorObject = sHandleToSensor.get(sensor);
            if (sensorObject != null) {
                // report the sensor event to all listeners that
                // care about it.
                final int size = sListeners.size();
                for (int i = 0; i < size; i++) {
                    ListenerDelegate listener = sListeners.get(i);
                    if (listener.hasSensor(sensorObject)) {
                        // this is asynchronous (okay to call
                        // with sListeners lock held).
                        listener.onSensorChangedLocked(sensorObject, values, timestamp, accuracy);
                    }
                }
            }
        }
    }
// Log.d(TAG, ""exiting main sensor thread"");
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,4,0,"The thread priority has been changed (from Process.THREAD_PRIORITY_DISPLAY to Process.THREAD_PRIORITY_URGENT_DISPLAY), and some new statements related to ""mSensorsReady"" and ""this.notify()"" have been added. These changes fall under the category of Other statement changed, so the code change type is 4.","The changes made here do not affect the return values or exceptions thrown by the method, therefore, no Compatibility Issue exists."
524,<android.webkit.CallbackProxy: void handleMessage(Message)>,7,8,<android.webkit.CallbackProxy: void handleMessage(Message)>,<android.webkit.CallbackProxy: void handleMessage(Message)>,0,"{
    // 32-bit reads and writes.
    switch(msg.what) {
        case PAGE_STARTED:
            if (mWebViewClient != null) {
                mWebViewClient.onPageStarted(mWebView, msg.getData().getString(""url""), (Bitmap) msg.obj);
            }
            break;
        case PAGE_FINISHED:
            if (mWebViewClient != null) {
                mWebViewClient.onPageFinished(mWebView, (String) msg.obj);
            }
            break;
        case RECEIVED_ICON:
            if (mWebChromeClient != null) {
                mWebChromeClient.onReceivedIcon(mWebView, (Bitmap) msg.obj);
            }
            break;
        case RECEIVED_TOUCH_ICON_URL:
            if (mWebChromeClient != null) {
                mWebChromeClient.onReceivedTouchIconUrl(mWebView, (String) msg.obj, msg.arg1 == 1);
            }
            break;
        case RECEIVED_TITLE:
            if (mWebChromeClient != null) {
                mWebChromeClient.onReceivedTitle(mWebView, (String) msg.obj);
            }
            break;
        case TOO_MANY_REDIRECTS:
            Message cancelMsg = (Message) msg.getData().getParcelable(""cancelMsg"");
            Message continueMsg = (Message) msg.getData().getParcelable(""continueMsg"");
            if (mWebViewClient != null) {
                mWebViewClient.onTooManyRedirects(mWebView, cancelMsg, continueMsg);
            } else {
                cancelMsg.sendToTarget();
            }
            break;
        case REPORT_ERROR:
            if (mWebViewClient != null) {
                int reasonCode = msg.arg1;
                final String description = msg.getData().getString(""description"");
                final String failUrl = msg.getData().getString(""failingUrl"");
                mWebViewClient.onReceivedError(mWebView, reasonCode, description, failUrl);
            }
            break;
        case RESEND_POST_DATA:
            Message resend = (Message) msg.getData().getParcelable(""resend"");
            Message dontResend = (Message) msg.getData().getParcelable(""dontResend"");
            if (mWebViewClient != null) {
                mWebViewClient.onFormResubmission(mWebView, dontResend, resend);
            } else {
                dontResend.sendToTarget();
            }
            break;
        case OVERRIDE_URL:
            String overrideUrl = msg.getData().getString(""url"");
            boolean override = uiOverrideUrlLoading(overrideUrl);
            ResultTransport<Boolean> result = (ResultTransport<Boolean>) msg.obj;
            synchronized (this) {
                result.setResult(override);
                notify();
            }
            break;
        case AUTH_REQUEST:
            if (mWebViewClient != null) {
                HttpAuthHandler handler = (HttpAuthHandler) msg.obj;
                String host = msg.getData().getString(""host"");
                String realm = msg.getData().getString(""realm"");
                mWebViewClient.onReceivedHttpAuthRequest(mWebView, handler, host, realm);
            }
            break;
        case SSL_ERROR:
            if (mWebViewClient != null) {
                HashMap<String, Object> map = (HashMap<String, Object>) msg.obj;
                mWebViewClient.onReceivedSslError(mWebView, (SslErrorHandler) map.get(""handler""), (SslError) map.get(""error""));
            }
            break;
        case PROGRESS:
            // changed.
            synchronized (this) {
                if (mWebChromeClient != null) {
                    mWebChromeClient.onProgressChanged(mWebView, mLatestProgress);
                }
                mProgressUpdatePending = false;
            }
            break;
        case UPDATE_VISITED:
            if (mWebViewClient != null) {
                mWebViewClient.doUpdateVisitedHistory(mWebView, (String) msg.obj, msg.arg1 != 0);
            }
            break;
        case LOAD_RESOURCE:
            if (mWebViewClient != null) {
                mWebViewClient.onLoadResource(mWebView, (String) msg.obj);
            }
            break;
        case DOWNLOAD_FILE:
            if (mDownloadListener != null) {
                String url = msg.getData().getString(""url"");
                String userAgent = msg.getData().getString(""userAgent"");
                String contentDisposition = msg.getData().getString(""contentDisposition"");
                String mimetype = msg.getData().getString(""mimetype"");
                Long contentLength = msg.getData().getLong(""contentLength"");
                mDownloadListener.onDownloadStart(url, userAgent, contentDisposition, mimetype, contentLength);
            }
            break;
        case CREATE_WINDOW:
            if (mWebChromeClient != null) {
                if (!mWebChromeClient.onCreateWindow(mWebView, msg.arg1 == 1, msg.arg2 == 1, (Message) msg.obj)) {
                    synchronized (this) {
                        notify();
                    }
                }
            }
            break;
        case REQUEST_FOCUS:
            if (mWebChromeClient != null) {
                mWebChromeClient.onRequestFocus(mWebView);
            }
            break;
        case CLOSE_WINDOW:
            if (mWebChromeClient != null) {
                mWebChromeClient.onCloseWindow((WebView) msg.obj);
            }
            break;
        case SAVE_PASSWORD:
            Bundle bundle = msg.getData();
            String schemePlusHost = bundle.getString(""host"");
            String username = bundle.getString(""username"");
            String password = bundle.getString(""password"");
            // will not be sent and we should notify WebCore ourselves.
            if (!mWebView.onSavePassword(schemePlusHost, username, password, (Message) msg.obj)) {
                synchronized (this) {
                    notify();
                }
            }
            break;
        case ASYNC_KEYEVENTS:
            if (mWebViewClient != null) {
                mWebViewClient.onUnhandledKeyEvent(mWebView, (KeyEvent) msg.obj);
            }
            break;
        case EXCEEDED_DATABASE_QUOTA:
            if (mWebChromeClient != null) {
                HashMap<String, Object> map = (HashMap<String, Object>) msg.obj;
                String databaseIdentifier = (String) map.get(""databaseIdentifier"");
                String url = (String) map.get(""url"");
                long currentQuota = ((Long) map.get(""currentQuota"")).longValue();
                long totalUsedQuota = ((Long) map.get(""totalUsedQuota"")).longValue();
                long estimatedSize = ((Long) map.get(""estimatedSize"")).longValue();
                WebStorage.QuotaUpdater quotaUpdater = (WebStorage.QuotaUpdater) map.get(""quotaUpdater"");
                mWebChromeClient.onExceededDatabaseQuota(url, databaseIdentifier, currentQuota, estimatedSize, totalUsedQuota, quotaUpdater);
            }
            break;
        case REACHED_APPCACHE_MAXSIZE:
            if (mWebChromeClient != null) {
                HashMap<String, Object> map = (HashMap<String, Object>) msg.obj;
                long spaceNeeded = ((Long) map.get(""spaceNeeded"")).longValue();
                long totalUsedQuota = ((Long) map.get(""totalUsedQuota"")).longValue();
                WebStorage.QuotaUpdater quotaUpdater = (WebStorage.QuotaUpdater) map.get(""quotaUpdater"");
                mWebChromeClient.onReachedMaxAppCacheSize(spaceNeeded, totalUsedQuota, quotaUpdater);
            }
            break;
        case GEOLOCATION_PERMISSIONS_SHOW_PROMPT:
            if (mWebChromeClient != null) {
                HashMap<String, Object> map = (HashMap<String, Object>) msg.obj;
                String origin = (String) map.get(""origin"");
                GeolocationPermissions.Callback callback = (GeolocationPermissions.Callback) map.get(""callback"");
                mWebChromeClient.onGeolocationPermissionsShowPrompt(origin, callback);
            }
            break;
        case GEOLOCATION_PERMISSIONS_HIDE_PROMPT:
            if (mWebChromeClient != null) {
                mWebChromeClient.onGeolocationPermissionsHidePrompt();
            }
            break;
        case JS_ALERT:
            if (mWebChromeClient != null) {
                final JsResult res = (JsResult) msg.obj;
                String message = msg.getData().getString(""message"");
                String url = msg.getData().getString(""url"");
                if (!mWebChromeClient.onJsAlert(mWebView, url, message, res)) {
                    new AlertDialog.Builder(mContext).setTitle(getJsDialogTitle(url)).setMessage(message).setPositiveButton(R.string.ok, new AlertDialog.OnClickListener() {

                        public void onClick(DialogInterface dialog, int which) {
                            res.confirm();
                        }
                    }).setCancelable(false).show();
                }
                res.setReady();
            }
            break;
        case JS_CONFIRM:
            if (mWebChromeClient != null) {
                final JsResult res = (JsResult) msg.obj;
                String message = msg.getData().getString(""message"");
                String url = msg.getData().getString(""url"");
                if (!mWebChromeClient.onJsConfirm(mWebView, url, message, res)) {
                    new AlertDialog.Builder(mContext).setTitle(getJsDialogTitle(url)).setMessage(message).setPositiveButton(R.string.ok, new DialogInterface.OnClickListener() {

                        public void onClick(DialogInterface dialog, int which) {
                            res.confirm();
                        }
                    }).setNegativeButton(R.string.cancel, new DialogInterface.OnClickListener() {

                        public void onClick(DialogInterface dialog, int which) {
                            res.cancel();
                        }
                    }).show();
                }
                // Tell the JsResult that it is ready for client
                // interaction.
                res.setReady();
            }
            break;
        case JS_PROMPT:
            if (mWebChromeClient != null) {
                final JsPromptResult res = (JsPromptResult) msg.obj;
                String message = msg.getData().getString(""message"");
                String defaultVal = msg.getData().getString(""default"");
                String url = msg.getData().getString(""url"");
                if (!mWebChromeClient.onJsPrompt(mWebView, url, message, defaultVal, res)) {
                    final LayoutInflater factory = LayoutInflater.from(mContext);
                    final View view = factory.inflate(R.layout.js_prompt, null);
                    final EditText v = (EditText) view.findViewById(R.id.value);
                    v.setText(defaultVal);
                    ((TextView) view.findViewById(R.id.message)).setText(message);
                    new AlertDialog.Builder(mContext).setTitle(getJsDialogTitle(url)).setView(view).setPositiveButton(R.string.ok, new DialogInterface.OnClickListener() {

                        public void onClick(DialogInterface dialog, int whichButton) {
                            res.confirm(v.getText().toString());
                        }
                    }).setNegativeButton(R.string.cancel, new DialogInterface.OnClickListener() {

                        public void onClick(DialogInterface dialog, int whichButton) {
                            res.cancel();
                        }
                    }).setOnCancelListener(new DialogInterface.OnCancelListener() {

                        public void onCancel(DialogInterface dialog) {
                            res.cancel();
                        }
                    }).show();
                }
                // Tell the JsResult that it is ready for client
                // interaction.
                res.setReady();
            }
            break;
        case JS_UNLOAD:
            if (mWebChromeClient != null) {
                final JsResult res = (JsResult) msg.obj;
                String message = msg.getData().getString(""message"");
                String url = msg.getData().getString(""url"");
                if (!mWebChromeClient.onJsBeforeUnload(mWebView, url, message, res)) {
                    final String m = mContext.getString(R.string.js_dialog_before_unload, message);
                    new AlertDialog.Builder(mContext).setMessage(m).setPositiveButton(R.string.ok, new DialogInterface.OnClickListener() {

                        public void onClick(DialogInterface dialog, int which) {
                            res.confirm();
                        }
                    }).setNegativeButton(R.string.cancel, new DialogInterface.OnClickListener() {

                        public void onClick(DialogInterface dialog, int which) {
                            res.cancel();
                        }
                    }).show();
                }
                res.setReady();
            }
            break;
        case JS_TIMEOUT:
            if (mWebChromeClient != null) {
                final JsResult res = (JsResult) msg.obj;
                if (mWebChromeClient.onJsTimeout()) {
                    res.confirm();
                } else {
                    res.cancel();
                }
                res.setReady();
            }
            break;
        case RECEIVED_CERTIFICATE:
            mWebView.setCertificate((SslCertificate) msg.obj);
            break;
        case NOTIFY:
            synchronized (this) {
                notify();
            }
            break;
        case SCALE_CHANGED:
            if (mWebViewClient != null) {
                mWebViewClient.onScaleChanged(mWebView, msg.getData().getFloat(""old""), msg.getData().getFloat(""new""));
            }
            break;
        case SWITCH_OUT_HISTORY:
            mWebView.switchOutDrawHistory();
            break;
        case ADD_MESSAGE_TO_CONSOLE:
            String message = msg.getData().getString(""message"");
            String sourceID = msg.getData().getString(""sourceID"");
            int lineNumber = msg.getData().getInt(""lineNumber"");
            mWebChromeClient.onConsoleMessage(message, lineNumber, sourceID);
            break;
        case GET_VISITED_HISTORY:
            if (mWebChromeClient != null) {
                mWebChromeClient.getVisitedHistory((ValueCallback<String[]>) msg.obj);
            }
            break;
    }
}","{
    // 32-bit reads and writes.
    switch(msg.what) {
        case PAGE_STARTED:
            // every time we start a new page, we want to reset the
            // WebView certificate:
            // if the new site is secure, we will reload it and get a
            // new certificate set;
            // if the new site is not secure, the certificate must be
            // null, and that will be the case
            mWebView.setCertificate(null);
            if (mWebViewClient != null) {
                mWebViewClient.onPageStarted(mWebView, msg.getData().getString(""url""), (Bitmap) msg.obj);
            }
            break;
        case PAGE_FINISHED:
            String finishedUrl = (String) msg.obj;
            mWebView.onPageFinished(finishedUrl);
            if (mWebViewClient != null) {
                mWebViewClient.onPageFinished(mWebView, finishedUrl);
            }
            break;
        case RECEIVED_ICON:
            if (mWebChromeClient != null) {
                mWebChromeClient.onReceivedIcon(mWebView, (Bitmap) msg.obj);
            }
            break;
        case RECEIVED_TOUCH_ICON_URL:
            if (mWebChromeClient != null) {
                mWebChromeClient.onReceivedTouchIconUrl(mWebView, (String) msg.obj, msg.arg1 == 1);
            }
            break;
        case RECEIVED_TITLE:
            if (mWebChromeClient != null) {
                mWebChromeClient.onReceivedTitle(mWebView, (String) msg.obj);
            }
            break;
        case REPORT_ERROR:
            if (mWebViewClient != null) {
                int reasonCode = msg.arg1;
                final String description = msg.getData().getString(""description"");
                final String failUrl = msg.getData().getString(""failingUrl"");
                mWebViewClient.onReceivedError(mWebView, reasonCode, description, failUrl);
            }
            break;
        case RESEND_POST_DATA:
            Message resend = (Message) msg.getData().getParcelable(""resend"");
            Message dontResend = (Message) msg.getData().getParcelable(""dontResend"");
            if (mWebViewClient != null) {
                mWebViewClient.onFormResubmission(mWebView, dontResend, resend);
            } else {
                dontResend.sendToTarget();
            }
            break;
        case OVERRIDE_URL:
            String overrideUrl = msg.getData().getString(""url"");
            boolean override = uiOverrideUrlLoading(overrideUrl);
            ResultTransport<Boolean> result = (ResultTransport<Boolean>) msg.obj;
            synchronized (this) {
                result.setResult(override);
                notify();
            }
            break;
        case AUTH_REQUEST:
            if (mWebViewClient != null) {
                HttpAuthHandler handler = (HttpAuthHandler) msg.obj;
                String host = msg.getData().getString(""host"");
                String realm = msg.getData().getString(""realm"");
                mWebViewClient.onReceivedHttpAuthRequest(mWebView, handler, host, realm);
            }
            break;
        case SSL_ERROR:
            if (mWebViewClient != null) {
                HashMap<String, Object> map = (HashMap<String, Object>) msg.obj;
                mWebViewClient.onReceivedSslError(mWebView, (SslErrorHandler) map.get(""handler""), (SslError) map.get(""error""));
            }
            break;
        case PROGRESS:
            // changed.
            synchronized (this) {
                if (mWebChromeClient != null) {
                    mWebChromeClient.onProgressChanged(mWebView, mLatestProgress);
                }
                mProgressUpdatePending = false;
            }
            break;
        case UPDATE_VISITED:
            if (mWebViewClient != null) {
                mWebViewClient.doUpdateVisitedHistory(mWebView, (String) msg.obj, msg.arg1 != 0);
            }
            break;
        case LOAD_RESOURCE:
            if (mWebViewClient != null) {
                mWebViewClient.onLoadResource(mWebView, (String) msg.obj);
            }
            break;
        case DOWNLOAD_FILE:
            if (mDownloadListener != null) {
                String url = msg.getData().getString(""url"");
                String userAgent = msg.getData().getString(""userAgent"");
                String contentDisposition = msg.getData().getString(""contentDisposition"");
                String mimetype = msg.getData().getString(""mimetype"");
                Long contentLength = msg.getData().getLong(""contentLength"");
                mDownloadListener.onDownloadStart(url, userAgent, contentDisposition, mimetype, contentLength);
            }
            break;
        case CREATE_WINDOW:
            if (mWebChromeClient != null) {
                if (!mWebChromeClient.onCreateWindow(mWebView, msg.arg1 == 1, msg.arg2 == 1, (Message) msg.obj)) {
                    synchronized (this) {
                        notify();
                    }
                }
                mWebView.dismissZoomControl();
            }
            break;
        case REQUEST_FOCUS:
            if (mWebChromeClient != null) {
                mWebChromeClient.onRequestFocus(mWebView);
            }
            break;
        case CLOSE_WINDOW:
            if (mWebChromeClient != null) {
                mWebChromeClient.onCloseWindow((WebView) msg.obj);
            }
            break;
        case SAVE_PASSWORD:
            Bundle bundle = msg.getData();
            String schemePlusHost = bundle.getString(""host"");
            String username = bundle.getString(""username"");
            String password = bundle.getString(""password"");
            // will not be sent and we should notify WebCore ourselves.
            if (!mWebView.onSavePassword(schemePlusHost, username, password, (Message) msg.obj)) {
                synchronized (this) {
                    notify();
                }
            }
            break;
        case ASYNC_KEYEVENTS:
            if (mWebViewClient != null) {
                mWebViewClient.onUnhandledKeyEvent(mWebView, (KeyEvent) msg.obj);
            }
            break;
        case EXCEEDED_DATABASE_QUOTA:
            if (mWebChromeClient != null) {
                HashMap<String, Object> map = (HashMap<String, Object>) msg.obj;
                String databaseIdentifier = (String) map.get(""databaseIdentifier"");
                String url = (String) map.get(""url"");
                long currentQuota = ((Long) map.get(""currentQuota"")).longValue();
                long totalUsedQuota = ((Long) map.get(""totalUsedQuota"")).longValue();
                long estimatedSize = ((Long) map.get(""estimatedSize"")).longValue();
                WebStorage.QuotaUpdater quotaUpdater = (WebStorage.QuotaUpdater) map.get(""quotaUpdater"");
                mWebChromeClient.onExceededDatabaseQuota(url, databaseIdentifier, currentQuota, estimatedSize, totalUsedQuota, quotaUpdater);
            }
            break;
        case REACHED_APPCACHE_MAXSIZE:
            if (mWebChromeClient != null) {
                HashMap<String, Object> map = (HashMap<String, Object>) msg.obj;
                long spaceNeeded = ((Long) map.get(""spaceNeeded"")).longValue();
                long totalUsedQuota = ((Long) map.get(""totalUsedQuota"")).longValue();
                WebStorage.QuotaUpdater quotaUpdater = (WebStorage.QuotaUpdater) map.get(""quotaUpdater"");
                mWebChromeClient.onReachedMaxAppCacheSize(spaceNeeded, totalUsedQuota, quotaUpdater);
            }
            break;
        case GEOLOCATION_PERMISSIONS_SHOW_PROMPT:
            if (mWebChromeClient != null) {
                HashMap<String, Object> map = (HashMap<String, Object>) msg.obj;
                String origin = (String) map.get(""origin"");
                GeolocationPermissions.Callback callback = (GeolocationPermissions.Callback) map.get(""callback"");
                mWebChromeClient.onGeolocationPermissionsShowPrompt(origin, callback);
            }
            break;
        case GEOLOCATION_PERMISSIONS_HIDE_PROMPT:
            if (mWebChromeClient != null) {
                mWebChromeClient.onGeolocationPermissionsHidePrompt();
            }
            break;
        case JS_ALERT:
            if (mWebChromeClient != null) {
                final JsResult res = (JsResult) msg.obj;
                String message = msg.getData().getString(""message"");
                String url = msg.getData().getString(""url"");
                if (!mWebChromeClient.onJsAlert(mWebView, url, message, res)) {
                    new AlertDialog.Builder(mContext).setTitle(getJsDialogTitle(url)).setMessage(message).setPositiveButton(R.string.ok, new AlertDialog.OnClickListener() {

                        public void onClick(DialogInterface dialog, int which) {
                            res.confirm();
                        }
                    }).setCancelable(false).show();
                }
                res.setReady();
            }
            break;
        case JS_CONFIRM:
            if (mWebChromeClient != null) {
                final JsResult res = (JsResult) msg.obj;
                String message = msg.getData().getString(""message"");
                String url = msg.getData().getString(""url"");
                if (!mWebChromeClient.onJsConfirm(mWebView, url, message, res)) {
                    new AlertDialog.Builder(mContext).setTitle(getJsDialogTitle(url)).setMessage(message).setPositiveButton(R.string.ok, new DialogInterface.OnClickListener() {

                        public void onClick(DialogInterface dialog, int which) {
                            res.confirm();
                        }
                    }).setNegativeButton(R.string.cancel, new DialogInterface.OnClickListener() {

                        public void onClick(DialogInterface dialog, int which) {
                            res.cancel();
                        }
                    }).setOnCancelListener(new DialogInterface.OnCancelListener() {

                        public void onCancel(DialogInterface dialog) {
                            res.cancel();
                        }
                    }).show();
                }
                // Tell the JsResult that it is ready for client
                // interaction.
                res.setReady();
            }
            break;
        case JS_PROMPT:
            if (mWebChromeClient != null) {
                final JsPromptResult res = (JsPromptResult) msg.obj;
                String message = msg.getData().getString(""message"");
                String defaultVal = msg.getData().getString(""default"");
                String url = msg.getData().getString(""url"");
                if (!mWebChromeClient.onJsPrompt(mWebView, url, message, defaultVal, res)) {
                    final LayoutInflater factory = LayoutInflater.from(mContext);
                    final View view = factory.inflate(R.layout.js_prompt, null);
                    final EditText v = (EditText) view.findViewById(R.id.value);
                    v.setText(defaultVal);
                    ((TextView) view.findViewById(R.id.message)).setText(message);
                    new AlertDialog.Builder(mContext).setTitle(getJsDialogTitle(url)).setView(view).setPositiveButton(R.string.ok, new DialogInterface.OnClickListener() {

                        public void onClick(DialogInterface dialog, int whichButton) {
                            res.confirm(v.getText().toString());
                        }
                    }).setNegativeButton(R.string.cancel, new DialogInterface.OnClickListener() {

                        public void onClick(DialogInterface dialog, int whichButton) {
                            res.cancel();
                        }
                    }).setOnCancelListener(new DialogInterface.OnCancelListener() {

                        public void onCancel(DialogInterface dialog) {
                            res.cancel();
                        }
                    }).show();
                }
                // Tell the JsResult that it is ready for client
                // interaction.
                res.setReady();
            }
            break;
        case JS_UNLOAD:
            if (mWebChromeClient != null) {
                final JsResult res = (JsResult) msg.obj;
                String message = msg.getData().getString(""message"");
                String url = msg.getData().getString(""url"");
                if (!mWebChromeClient.onJsBeforeUnload(mWebView, url, message, res)) {
                    final String m = mContext.getString(R.string.js_dialog_before_unload, message);
                    new AlertDialog.Builder(mContext).setMessage(m).setPositiveButton(R.string.ok, new DialogInterface.OnClickListener() {

                        public void onClick(DialogInterface dialog, int which) {
                            res.confirm();
                        }
                    }).setNegativeButton(R.string.cancel, new DialogInterface.OnClickListener() {

                        public void onClick(DialogInterface dialog, int which) {
                            res.cancel();
                        }
                    }).show();
                }
                res.setReady();
            }
            break;
        case JS_TIMEOUT:
            if (mWebChromeClient != null) {
                final JsResult res = (JsResult) msg.obj;
                if (mWebChromeClient.onJsTimeout()) {
                    res.confirm();
                } else {
                    res.cancel();
                }
                res.setReady();
            }
            break;
        case RECEIVED_CERTIFICATE:
            mWebView.setCertificate((SslCertificate) msg.obj);
            break;
        case NOTIFY:
            synchronized (this) {
                notify();
            }
            break;
        case SCALE_CHANGED:
            if (mWebViewClient != null) {
                mWebViewClient.onScaleChanged(mWebView, msg.getData().getFloat(""old""), msg.getData().getFloat(""new""));
            }
            break;
        case SWITCH_OUT_HISTORY:
            mWebView.switchOutDrawHistory();
            break;
        case ADD_MESSAGE_TO_CONSOLE:
            String message = msg.getData().getString(""message"");
            String sourceID = msg.getData().getString(""sourceID"");
            int lineNumber = msg.getData().getInt(""lineNumber"");
            int msgLevel = msg.getData().getInt(""msgLevel"");
            int numberOfMessageLevels = ConsoleMessage.MessageLevel.values().length;
            // Sanity bounds check as we'll index an array with msgLevel
            if (msgLevel < 0 || msgLevel >= numberOfMessageLevels) {
                msgLevel = 0;
            }
            ConsoleMessage.MessageLevel messageLevel = ConsoleMessage.MessageLevel.values()[msgLevel];
            if (!mWebChromeClient.onConsoleMessage(new ConsoleMessage(message, sourceID, lineNumber, messageLevel))) {
                // If false was returned the user did not provide their own console function so
                // we should output some default messages to the system log.
                String logTag = ""Web Console"";
                String logMessage = message + "" at "" + sourceID + "":"" + lineNumber;
                switch(messageLevel) {
                    case TIP:
                        Log.v(logTag, logMessage);
                        break;
                    case LOG:
                        Log.i(logTag, logMessage);
                        break;
                    case WARNING:
                        Log.w(logTag, logMessage);
                        break;
                    case ERROR:
                        Log.e(logTag, logMessage);
                        break;
                    case DEBUG:
                        Log.d(logTag, logMessage);
                        break;
                }
            }
            break;
        case GET_VISITED_HISTORY:
            if (mWebChromeClient != null) {
                mWebChromeClient.getVisitedHistory((ValueCallback<String[]>) msg.obj);
            }
            break;
        case OPEN_FILE_CHOOSER:
            if (mWebChromeClient != null) {
                mWebChromeClient.openFileChooser((UploadFile) msg.obj);
            }
            break;
        case ADD_HISTORY_ITEM:
            if (mWebBackForwardListClient != null) {
                mWebBackForwardListClient.onNewHistoryItem((WebHistoryItem) msg.obj);
            }
            break;
        case HISTORY_INDEX_CHANGED:
            if (mWebBackForwardListClient != null) {
                mWebBackForwardListClient.onIndexChanged((WebHistoryItem) msg.obj, msg.arg1);
            }
            break;
        case AUTH_CREDENTIALS:
            String host = msg.getData().getString(""host"");
            String realm = msg.getData().getString(""realm"");
            username = msg.getData().getString(""username"");
            password = msg.getData().getString(""password"");
            mWebView.setHttpAuthUsernamePassword(host, realm, username, password);
            break;
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,,,,
526,"<android.webkit.WebView: void moveSelection(float,float)>",7,8,"<android.webkit.WebView: void moveSelection(float,float)>","<android.webkit.WebView: void moveSelection(float,float)>",0,"{
    if (mNativeClass == 0)
        return;
    int width = getViewWidth();
    int height = getViewHeight();
    mSelectX += scaleTrackballX(xRate, width);
    mSelectY += scaleTrackballY(yRate, height);
    int maxX = width + mScrollX;
    int maxY = height + mScrollY;
    mSelectX = Math.min(maxX, Math.max(mScrollX - SELECT_CURSOR_OFFSET, mSelectX));
    mSelectY = Math.min(maxY, Math.max(mScrollY - SELECT_CURSOR_OFFSET, mSelectY));
    if (DebugFlags.WEB_VIEW) {
        Log.v(LOGTAG, ""moveSelection"" + "" mSelectX="" + mSelectX + "" mSelectY="" + mSelectY + "" mScrollX="" + mScrollX + "" mScrollY="" + mScrollY + "" xRate="" + xRate + "" yRate="" + yRate);
    }
    nativeMoveSelection(viewToContentX(mSelectX), viewToContentY(mSelectY), mExtendSelection);
    int scrollX = mSelectX < mScrollX ? -SELECT_CURSOR_OFFSET : mSelectX > maxX - SELECT_CURSOR_OFFSET ? SELECT_CURSOR_OFFSET : 0;
    int scrollY = mSelectY < mScrollY ? -SELECT_CURSOR_OFFSET : mSelectY > maxY - SELECT_CURSOR_OFFSET ? SELECT_CURSOR_OFFSET : 0;
    pinScrollBy(scrollX, scrollY, true, 0);
    Rect select = new Rect(mSelectX, mSelectY, mSelectX + 1, mSelectY + 1);
    requestRectangleOnScreen(select);
    invalidate();
}","{
    if (mNativeClass == 0)
        return;
    int width = getViewWidth();
    int height = getViewHeight();
    mSelectX += xRate;
    mSelectY += yRate;
    int maxX = width + mScrollX;
    int maxY = height + mScrollY;
    mSelectX = Math.min(maxX, Math.max(mScrollX - SELECT_CURSOR_OFFSET, mSelectX));
    mSelectY = Math.min(maxY, Math.max(mScrollY - SELECT_CURSOR_OFFSET, mSelectY));
    if (DebugFlags.WEB_VIEW) {
        Log.v(LOGTAG, ""moveSelection"" + "" mSelectX="" + mSelectX + "" mSelectY="" + mSelectY + "" mScrollX="" + mScrollX + "" mScrollY="" + mScrollY + "" xRate="" + xRate + "" yRate="" + yRate);
    }
    nativeMoveSelection(viewToContentX(mSelectX), viewToContentY(mSelectY), mExtendSelection);
    int scrollX = mSelectX < mScrollX ? -SELECT_CURSOR_OFFSET : mSelectX > maxX - SELECT_CURSOR_OFFSET ? SELECT_CURSOR_OFFSET : 0;
    int scrollY = mSelectY < mScrollY ? -SELECT_CURSOR_OFFSET : mSelectY > maxY - SELECT_CURSOR_OFFSET ? SELECT_CURSOR_OFFSET : 0;
    pinScrollBy(scrollX, scrollY, true, 0);
    Rect select = new Rect(mSelectX, mSelectY, mSelectX + 1, mSelectY + 1);
    requestRectangleOnScreen(select);
    invalidate();
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,4,0,"The change in the two versions of the code is that the method of initialising mSelectX, mSelectY variables has been modified. Instead of using scaleTrackballX and scaleTrackballY methods to scale xRate and yRate for addition to mSelectX and mSelectY respectively, the values are added directly in the later version.","Even though there's been changes, there is no compatibility issue resulting from this code change. The possible values of mSelectX and mSelectY might differ between versions, but they do not change the return type or value since the method is void, nor do they introduce a new exception scenario. Therefore, no compatibility issue is found here."
529,<android.server.BluetoothService.EnableThread: void run()>,7,8,<android.server.BluetoothService.EnableThread: void run()>,<android.server.BluetoothService.EnableThread: void run()>,0,"{
    boolean res = (enableNative() == 0);
    if (res) {
        int retryCount = 2;
        boolean running = false;
        while ((retryCount-- > 0) && !running) {
            mEventLoop.start();
            // it may take a momement for the other thread to do its
            // thing.  Check periodically for a while.
            int pollCount = 5;
            while ((pollCount-- > 0) && !running) {
                if (mEventLoop.isEventLoopRunning()) {
                    running = true;
                    break;
                }
                try {
                    Thread.sleep(100);
                } catch (InterruptedException e) {
                }
            }
        }
        if (!running) {
            log(""bt EnableThread giving up"");
            res = false;
            disableNative();
        }
    }
    if (res) {
        if (!setupNativeDataNative()) {
            return;
        }
        if (mSaveSetting) {
            persistBluetoothOnSetting(true);
        }
        mIsDiscovering = false;
        mBondState.loadBondState();
        mHandler.sendMessageDelayed(mHandler.obtainMessage(MESSAGE_REGISTER_SDP_RECORDS, 1, -1), 3000);
        // Log bluetooth on to battery stats.
        long ident = Binder.clearCallingIdentity();
        try {
            mBatteryStats.noteBluetoothOn();
        } catch (RemoteException e) {
        } finally {
            Binder.restoreCallingIdentity(ident);
        }
    }
    mEnableThread = null;
    setBluetoothState(res ? BluetoothAdapter.STATE_ON : BluetoothAdapter.STATE_OFF);
    if (res) {
        // Update mode
        String[] propVal = { ""Pairable"", getProperty(""Pairable"") };
        mEventLoop.onPropertyChanged(propVal);
    }
    if (mIsAirplaneSensitive && isAirplaneModeOn()) {
        disable(false);
    }
}","{
    boolean res = (enableNative() == 0);
    if (res) {
        int retryCount = 2;
        boolean running = false;
        while ((retryCount-- > 0) && !running) {
            mEventLoop.start();
            // it may take a momement for the other thread to do its
            // thing.  Check periodically for a while.
            int pollCount = 5;
            while ((pollCount-- > 0) && !running) {
                if (mEventLoop.isEventLoopRunning()) {
                    running = true;
                    break;
                }
                try {
                    Thread.sleep(100);
                } catch (InterruptedException e) {
                }
            }
        }
        if (!running) {
            log(""bt EnableThread giving up"");
            res = false;
            disableNative();
        }
    }
    if (res) {
        if (!setupNativeDataNative()) {
            return;
        }
        if (mSaveSetting) {
            persistBluetoothOnSetting(true);
        }
        mIsDiscovering = false;
        mBondState.readAutoPairingData();
        mBondState.loadBondState();
        mHandler.sendMessageDelayed(mHandler.obtainMessage(MESSAGE_REGISTER_SDP_RECORDS, 1, -1), 3000);
        // Log bluetooth on to battery stats.
        long ident = Binder.clearCallingIdentity();
        try {
            mBatteryStats.noteBluetoothOn();
        } catch (RemoteException e) {
        } finally {
            Binder.restoreCallingIdentity(ident);
        }
    }
    mEnableThread = null;
    setBluetoothState(res ? BluetoothAdapter.STATE_ON : BluetoothAdapter.STATE_OFF);
    if (res) {
        // Update mode
        String[] propVal = { ""Pairable"", getProperty(""Pairable"") };
        mEventLoop.onPropertyChanged(propVal);
    }
    if (mIsAirplaneSensitive && isAirplaneModeOn() && !mIsAirplaneToggleable) {
        disable(false);
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"3,4,5",1,"In the late version, a new condition check statement (mIsAirplaneToggleable) is introduced in the 'if' condition at the bottom of the logic, an assignment statement (mBondState.readAutoPairingData()) is inserted, and a dependent API (mBondState.loadBondState())'s performace has changed, so the code change types are 3,4,5.","These changes can possibly affect the return type or value of the method as the control flow of the program may alter due to the changes within the if and while loop and hence, the CI type is 1."
531,"<android.accounts.AccountManager: void setPassword(Account,String)>",7,8,"<android.accounts.AccountManager: void setPassword(Account,String)>","<android.accounts.AccountManager: void setPassword(Account,String)>",0,"{
    if (account == null) {
        Log.e(TAG, ""the account must not be null"");
        return;
    }
    try {
        mService.setPassword(account, password);
    } catch (RemoteException e) {
        // won't ever happen
        throw new RuntimeException(e);
    }
}","{
    if (account == null)
        throw new IllegalArgumentException(""account is null"");
    try {
        mService.setPassword(account, password);
    } catch (RemoteException e) {
        // won't ever happen
        throw new RuntimeException(e);
    }
}",1,"/**
 * Sets the password for the account. The password may be null. If the account does not exist
 * then this call has no affect.
 * <p>
 * Requires that the caller has permission
 * {@link android.Manifest.permission#AUTHENTICATE_ACCOUNTS} and is running
 * with the same UID as the Authenticator for the account.
 * @param account the account whose password is to be set. Must not be null.
 * @param password the password to set for the account. May be null.
 */
","/**
 * Sets or forgets a saved password.  This modifies the local copy of the
 * password used to automatically authenticate the user; it does
 * not change the user's account password on the server.  Intended for use
 * by the authenticator, not directly by applications.
 *
 * <p>It is safe to call this method from the main thread.
 *
 * <p>This method requires the caller to hold the permission
 * {@link android.Manifest.permission#AUTHENTICATE_ACCOUNTS}
 * and have the same UID as the account's authenticator.
 *
 * @param account The account to set a password for
 * @param password The password to set, null to clear the password
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,2","1,2","The early version method returns if the account is null, but in the late version exceptions are thrown. Hence, the change type is 1,2.","The change in the handling of the null account case, specifically an exception being thrown in the later version, may cause a different behavior, such as potentially getting exception instead of a normal return. Hence the CI types are 1 and 2."
533,<android.service.wallpaper.WallpaperService.IWallpaperEngineWrapper: void executeMessage(Message)>,7,8,<android.service.wallpaper.WallpaperService.IWallpaperEngineWrapper: void executeMessage(Message)>,<android.service.wallpaper.WallpaperService.IWallpaperEngineWrapper: void executeMessage(Message)>,0,"{
    switch(message.what) {
        case DO_ATTACH:
            {
                try {
                    mConnection.attachEngine(this);
                } catch (RemoteException e) {
                    Log.w(TAG, ""Wallpaper host disappeared"", e);
                    return;
                }
                Engine engine = onCreateEngine();
                mEngine = engine;
                mActiveEngines.add(engine);
                engine.attach(this);
                return;
            }
        case DO_DETACH:
            {
                mActiveEngines.remove(mEngine);
                mEngine.detach();
                return;
            }
        case DO_SET_DESIRED_SIZE:
            {
                mEngine.doDesiredSizeChanged(message.arg1, message.arg2);
                return;
            }
        case MSG_UPDATE_SURFACE:
            mEngine.updateSurface(true, false);
            break;
        case MSG_VISIBILITY_CHANGED:
            if (DEBUG)
                Log.v(TAG, ""Visibility change in "" + mEngine + "": "" + message.arg1);
            mEngine.doVisibilityChanged(message.arg1 != 0);
            break;
        case MSG_WALLPAPER_OFFSETS:
            {
                mEngine.doOffsetsChanged();
            }
            break;
        case MSG_WALLPAPER_COMMAND:
            {
                WallpaperCommand cmd = (WallpaperCommand) message.obj;
                mEngine.doCommand(cmd);
            }
            break;
        case MSG_WINDOW_RESIZED:
            {
                final boolean reportDraw = message.arg1 != 0;
                mEngine.updateSurface(true, false);
                if (reportDraw) {
                    try {
                        mEngine.mSession.finishDrawing(mEngine.mWindow);
                    } catch (RemoteException e) {
                    }
                }
            }
            break;
        case MSG_TOUCH_EVENT:
            {
                MotionEvent ev = (MotionEvent) message.obj;
                synchronized (mEngine.mLock) {
                    if (mEngine.mPendingMove == ev) {
                        mEngine.mPendingMove = null;
                    }
                }
                if (DEBUG)
                    Log.v(TAG, ""Delivering touch event: "" + ev);
                mEngine.onTouchEvent(ev);
                ev.recycle();
            }
            break;
        default:
            Log.w(TAG, ""Unknown message type "" + message.what);
    }
}","{
    switch(message.what) {
        case DO_ATTACH:
            {
                try {
                    mConnection.attachEngine(this);
                } catch (RemoteException e) {
                    Log.w(TAG, ""Wallpaper host disappeared"", e);
                    return;
                }
                Engine engine = onCreateEngine();
                mEngine = engine;
                mActiveEngines.add(engine);
                engine.attach(this);
                return;
            }
        case DO_DETACH:
            {
                mActiveEngines.remove(mEngine);
                mEngine.detach();
                return;
            }
        case DO_SET_DESIRED_SIZE:
            {
                mEngine.doDesiredSizeChanged(message.arg1, message.arg2);
                return;
            }
        case MSG_UPDATE_SURFACE:
            mEngine.updateSurface(true, false);
            break;
        case MSG_VISIBILITY_CHANGED:
            if (DEBUG)
                Log.v(TAG, ""Visibility change in "" + mEngine + "": "" + message.arg1);
            mEngine.doVisibilityChanged(message.arg1 != 0);
            break;
        case MSG_WALLPAPER_OFFSETS:
            {
                mEngine.doOffsetsChanged();
            }
            break;
        case MSG_WALLPAPER_COMMAND:
            {
                WallpaperCommand cmd = (WallpaperCommand) message.obj;
                mEngine.doCommand(cmd);
            }
            break;
        case MSG_WINDOW_RESIZED:
            {
                final boolean reportDraw = message.arg1 != 0;
                mEngine.updateSurface(true, false);
                mEngine.doOffsetsChanged();
                if (reportDraw) {
                    try {
                        mEngine.mSession.finishDrawing(mEngine.mWindow);
                    } catch (RemoteException e) {
                    }
                }
            }
            break;
        case MSG_TOUCH_EVENT:
            {
                MotionEvent ev = (MotionEvent) message.obj;
                synchronized (mEngine.mLock) {
                    if (mEngine.mPendingMove == ev) {
                        mEngine.mPendingMove = null;
                    }
                }
                if (DEBUG)
                    Log.v(TAG, ""Delivering touch event: "" + ev);
                mEngine.onTouchEvent(ev);
                ev.recycle();
            }
            break;
        default:
            Log.w(TAG, ""Unknown message type "" + message.what);
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"3,4",0,"A new method call 'mEngine.doOffsetsChanged();' has been added under MSG_WINDOW_RESIZED case, which is an addition in the control structure (change type 3). Also, it is an additional operation conducted by the function 'executeMessage', hence categorizing it as other statement change (change type 4).","There should be no compatibility issue due to this change as it seems that it's merely an operation added to handle the specific case 'MSG_WINDOW_RESIZED'. The added functionality doesn't alter the function's return value or the exceptions it might throw, hence no compatibility issue exists (CI Type 0)."
534,<android.view.ViewGroup: boolean dispatchTouchEvent(MotionEvent)>,7,8,<android.view.ViewGroup: boolean dispatchTouchEvent(MotionEvent)>,<android.view.ViewGroup: boolean dispatchTouchEvent(MotionEvent)>,0,"{
    final int action = ev.getAction();
    final float xf = ev.getX();
    final float yf = ev.getY();
    final float scrolledXFloat = xf + mScrollX;
    final float scrolledYFloat = yf + mScrollY;
    final Rect frame = mTempRect;
    boolean disallowIntercept = (mGroupFlags & FLAG_DISALLOW_INTERCEPT) != 0;
    if (action == MotionEvent.ACTION_DOWN) {
        if (mMotionTarget != null) {
            // this is weird, we got a pen down, but we thought it was
            // already down!
            // XXX: We should probably send an ACTION_UP to the current
            // target.
            mMotionTarget = null;
        }
        // intercept
        if (disallowIntercept || !onInterceptTouchEvent(ev)) {
            // reset this event's action (just to protect ourselves)
            ev.setAction(MotionEvent.ACTION_DOWN);
            // We know we want to dispatch the event down, find a child
            // who can handle it, start with the front-most child.
            final int scrolledXInt = (int) scrolledXFloat;
            final int scrolledYInt = (int) scrolledYFloat;
            final View[] children = mChildren;
            final int count = mChildrenCount;
            for (int i = count - 1; i >= 0; i--) {
                final View child = children[i];
                if ((child.mViewFlags & VISIBILITY_MASK) == VISIBLE || child.getAnimation() != null) {
                    child.getHitRect(frame);
                    if (frame.contains(scrolledXInt, scrolledYInt)) {
                        // offset the event to the view's coordinate system
                        final float xc = scrolledXFloat - child.mLeft;
                        final float yc = scrolledYFloat - child.mTop;
                        ev.setLocation(xc, yc);
                        if (child.dispatchTouchEvent(ev)) {
                            // Event handled, we have a target now.
                            mMotionTarget = child;
                            return true;
                        }
                    // The event didn't get handled, try the next view.
                    // Don't reset the event's location, it's not
                    // necessary here.
                    }
                }
            }
        }
    }
    boolean isUpOrCancel = (action == MotionEvent.ACTION_UP) || (action == MotionEvent.ACTION_CANCEL);
    if (isUpOrCancel) {
        // Note, we've already copied the previous state to our local
        // variable, so this takes effect on the next event
        mGroupFlags &= ~FLAG_DISALLOW_INTERCEPT;
    }
    // The event wasn't an ACTION_DOWN, dispatch it to our target if
    // we have one.
    final View target = mMotionTarget;
    if (target == null) {
        // We don't have a target, this means we're handling the
        // event as a regular view.
        ev.setLocation(xf, yf);
        return super.dispatchTouchEvent(ev);
    }
    // events
    if (!disallowIntercept && onInterceptTouchEvent(ev)) {
        final float xc = scrolledXFloat - (float) target.mLeft;
        final float yc = scrolledYFloat - (float) target.mTop;
        ev.setAction(MotionEvent.ACTION_CANCEL);
        ev.setLocation(xc, yc);
        if (!target.dispatchTouchEvent(ev)) {
        // target didn't handle ACTION_CANCEL. not much we can do
        // but they should have.
        }
        // clear the target
        mMotionTarget = null;
        // event to the normal onTouchEvent().
        return true;
    }
    if (isUpOrCancel) {
        mMotionTarget = null;
    }
    // finally offset the event to the target's coordinate system and
    // dispatch the event.
    final float xc = scrolledXFloat - (float) target.mLeft;
    final float yc = scrolledYFloat - (float) target.mTop;
    ev.setLocation(xc, yc);
    return target.dispatchTouchEvent(ev);
}","{
    final int action = ev.getAction();
    final float xf = ev.getX();
    final float yf = ev.getY();
    final float scrolledXFloat = xf + mScrollX;
    final float scrolledYFloat = yf + mScrollY;
    final Rect frame = mTempRect;
    boolean disallowIntercept = (mGroupFlags & FLAG_DISALLOW_INTERCEPT) != 0;
    if (action == MotionEvent.ACTION_DOWN) {
        if (mMotionTarget != null) {
            // this is weird, we got a pen down, but we thought it was
            // already down!
            // XXX: We should probably send an ACTION_UP to the current
            // target.
            mMotionTarget = null;
        }
        // intercept
        if (disallowIntercept || !onInterceptTouchEvent(ev)) {
            // reset this event's action (just to protect ourselves)
            ev.setAction(MotionEvent.ACTION_DOWN);
            // We know we want to dispatch the event down, find a child
            // who can handle it, start with the front-most child.
            final int scrolledXInt = (int) scrolledXFloat;
            final int scrolledYInt = (int) scrolledYFloat;
            final View[] children = mChildren;
            final int count = mChildrenCount;
            for (int i = count - 1; i >= 0; i--) {
                final View child = children[i];
                if ((child.mViewFlags & VISIBILITY_MASK) == VISIBLE || child.getAnimation() != null) {
                    child.getHitRect(frame);
                    if (frame.contains(scrolledXInt, scrolledYInt)) {
                        // offset the event to the view's coordinate system
                        final float xc = scrolledXFloat - child.mLeft;
                        final float yc = scrolledYFloat - child.mTop;
                        ev.setLocation(xc, yc);
                        child.mPrivateFlags &= ~CANCEL_NEXT_UP_EVENT;
                        if (child.dispatchTouchEvent(ev)) {
                            // Event handled, we have a target now.
                            mMotionTarget = child;
                            return true;
                        }
                    // The event didn't get handled, try the next view.
                    // Don't reset the event's location, it's not
                    // necessary here.
                    }
                }
            }
        }
    }
    boolean isUpOrCancel = (action == MotionEvent.ACTION_UP) || (action == MotionEvent.ACTION_CANCEL);
    if (isUpOrCancel) {
        // Note, we've already copied the previous state to our local
        // variable, so this takes effect on the next event
        mGroupFlags &= ~FLAG_DISALLOW_INTERCEPT;
    }
    // The event wasn't an ACTION_DOWN, dispatch it to our target if
    // we have one.
    final View target = mMotionTarget;
    if (target == null) {
        // We don't have a target, this means we're handling the
        // event as a regular view.
        ev.setLocation(xf, yf);
        if ((mPrivateFlags & CANCEL_NEXT_UP_EVENT) != 0) {
            ev.setAction(MotionEvent.ACTION_CANCEL);
            mPrivateFlags &= ~CANCEL_NEXT_UP_EVENT;
        }
        return super.dispatchTouchEvent(ev);
    }
    // events
    if (!disallowIntercept && onInterceptTouchEvent(ev)) {
        final float xc = scrolledXFloat - (float) target.mLeft;
        final float yc = scrolledYFloat - (float) target.mTop;
        mPrivateFlags &= ~CANCEL_NEXT_UP_EVENT;
        ev.setAction(MotionEvent.ACTION_CANCEL);
        ev.setLocation(xc, yc);
        if (!target.dispatchTouchEvent(ev)) {
        // target didn't handle ACTION_CANCEL. not much we can do
        // but they should have.
        }
        // clear the target
        mMotionTarget = null;
        // event to the normal onTouchEvent().
        return true;
    }
    if (isUpOrCancel) {
        mMotionTarget = null;
    }
    // finally offset the event to the target's coordinate system and
    // dispatch the event.
    final float xc = scrolledXFloat - (float) target.mLeft;
    final float yc = scrolledYFloat - (float) target.mTop;
    ev.setLocation(xc, yc);
    if ((target.mPrivateFlags & CANCEL_NEXT_UP_EVENT) != 0) {
        ev.setAction(MotionEvent.ACTION_CANCEL);
        target.mPrivateFlags &= ~CANCEL_NEXT_UP_EVENT;
        mMotionTarget = null;
    }
    return target.dispatchTouchEvent(ev);
}",1,"/**
 * {@inheritDoc}
 */
","/**
 * {@inheritDoc}
 */
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,4",1,"There are changes within the 'if' and 'for' control statements. A new flag check (CANCEL_NEXT_UP_EVENT) and related operations were added to the late version. Therefore, the code change types are 3 and 4.","As the new introduced statement involving CANCEL_NEXT_UP_EVENT flag check and related operations under those control flows, the returned value of 'dispatchTouchEvent(ev)' can be potentially different, thus CI type is 1."
536,<android.webkit.WebView: boolean dispatchKeyEvent(KeyEvent)>,7,8,<android.webkit.WebView: boolean dispatchKeyEvent(KeyEvent)>,<android.webkit.WebView: boolean dispatchKeyEvent(KeyEvent)>,0,"{
    boolean dispatch = true;
    if (!inEditingMode()) {
        if (event.getAction() == KeyEvent.ACTION_DOWN) {
            mGotKeyDown = true;
        } else {
            if (!mGotKeyDown) {
                /*
                     * We got a key up for which we were not the recipient of
                     * the original key down. Don't give it to the view.
                     */
                dispatch = false;
            }
            mGotKeyDown = false;
        }
    }
    if (dispatch) {
        return super.dispatchKeyEvent(event);
    } else {
        // We didn't dispatch, so let something else handle the key
        return false;
    }
}","{
    boolean dispatch = true;
    // another key was released while the shift key was held down.
    if (!inEditingMode() && (mNativeClass == 0 || !nativeFocusIsPlugin())) {
        if (event.getAction() == KeyEvent.ACTION_DOWN) {
            mGotKeyDown = true;
        } else {
            if (!mGotKeyDown) {
                /*
                     * We got a key up for which we were not the recipient of
                     * the original key down. Don't give it to the view.
                     */
                dispatch = false;
            }
            mGotKeyDown = false;
        }
    }
    if (dispatch) {
        return super.dispatchKeyEvent(event);
    } else {
        // We didn't dispatch, so let something else handle the key
        return false;
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,5",1,"The condition 'mNativeClass == 0 || !nativeFocusIsPlugin()' is made in the version 8 is a control dependency change. Also, the invoking of the dependent function 'nativeFocusIsPlugin()' in the else condition is a dependent API change. So the code change types are 3,5.","Depending on the results of '!nativeFocusIsPlugin()' and 'mNativeClass == 0', the 'dispatch' variable, and therefore the return value, could differ. Thus, the CI type is 1."
537,<android.os.Parcel: void writeValue(Object)>,7,8,<android.os.Parcel: void writeValue(Object)>,<android.os.Parcel: void writeValue(Object)>,0,"{
    if (v == null) {
        writeInt(VAL_NULL);
    } else if (v instanceof String) {
        writeInt(VAL_STRING);
        writeString((String) v);
    } else if (v instanceof Integer) {
        writeInt(VAL_INTEGER);
        writeInt((Integer) v);
    } else if (v instanceof Map) {
        writeInt(VAL_MAP);
        writeMap((Map) v);
    } else if (v instanceof Bundle) {
        // Must be before Parcelable
        writeInt(VAL_BUNDLE);
        writeBundle((Bundle) v);
    } else if (v instanceof Parcelable) {
        writeInt(VAL_PARCELABLE);
        writeParcelable((Parcelable) v, 0);
    } else if (v instanceof Short) {
        writeInt(VAL_SHORT);
        writeInt(((Short) v).intValue());
    } else if (v instanceof Long) {
        writeInt(VAL_LONG);
        writeLong((Long) v);
    } else if (v instanceof Float) {
        writeInt(VAL_FLOAT);
        writeFloat((Float) v);
    } else if (v instanceof Double) {
        writeInt(VAL_DOUBLE);
        writeDouble((Double) v);
    } else if (v instanceof Boolean) {
        writeInt(VAL_BOOLEAN);
        writeInt((Boolean) v ? 1 : 0);
    } else if (v instanceof CharSequence) {
        // Must be after String
        writeInt(VAL_CHARSEQUENCE);
        TextUtils.writeToParcel((CharSequence) v, this, 0);
    } else if (v instanceof List) {
        writeInt(VAL_LIST);
        writeList((List) v);
    } else if (v instanceof SparseArray) {
        writeInt(VAL_SPARSEARRAY);
        writeSparseArray((SparseArray) v);
    } else if (v instanceof boolean[]) {
        writeInt(VAL_BOOLEANARRAY);
        writeBooleanArray((boolean[]) v);
    } else if (v instanceof byte[]) {
        writeInt(VAL_BYTEARRAY);
        writeByteArray((byte[]) v);
    } else if (v instanceof String[]) {
        writeInt(VAL_STRINGARRAY);
        writeStringArray((String[]) v);
    } else if (v instanceof IBinder) {
        writeInt(VAL_IBINDER);
        writeStrongBinder((IBinder) v);
    } else if (v instanceof Parcelable[]) {
        writeInt(VAL_PARCELABLEARRAY);
        writeParcelableArray((Parcelable[]) v, 0);
    } else if (v instanceof Object[]) {
        writeInt(VAL_OBJECTARRAY);
        writeArray((Object[]) v);
    } else if (v instanceof int[]) {
        writeInt(VAL_INTARRAY);
        writeIntArray((int[]) v);
    } else if (v instanceof long[]) {
        writeInt(VAL_LONGARRAY);
        writeLongArray((long[]) v);
    } else if (v instanceof Byte) {
        writeInt(VAL_BYTE);
        writeInt((Byte) v);
    } else if (v instanceof Serializable) {
        // Must be last
        writeInt(VAL_SERIALIZABLE);
        writeSerializable((Serializable) v);
    } else {
        throw new RuntimeException(""Parcel: unable to marshal value "" + v);
    }
}","{
    if (v == null) {
        writeInt(VAL_NULL);
    } else if (v instanceof String) {
        writeInt(VAL_STRING);
        writeString((String) v);
    } else if (v instanceof Integer) {
        writeInt(VAL_INTEGER);
        writeInt((Integer) v);
    } else if (v instanceof Map) {
        writeInt(VAL_MAP);
        writeMap((Map) v);
    } else if (v instanceof Bundle) {
        // Must be before Parcelable
        writeInt(VAL_BUNDLE);
        writeBundle((Bundle) v);
    } else if (v instanceof Parcelable) {
        writeInt(VAL_PARCELABLE);
        writeParcelable((Parcelable) v, 0);
    } else if (v instanceof Short) {
        writeInt(VAL_SHORT);
        writeInt(((Short) v).intValue());
    } else if (v instanceof Long) {
        writeInt(VAL_LONG);
        writeLong((Long) v);
    } else if (v instanceof Float) {
        writeInt(VAL_FLOAT);
        writeFloat((Float) v);
    } else if (v instanceof Double) {
        writeInt(VAL_DOUBLE);
        writeDouble((Double) v);
    } else if (v instanceof Boolean) {
        writeInt(VAL_BOOLEAN);
        writeInt((Boolean) v ? 1 : 0);
    } else if (v instanceof CharSequence) {
        // Must be after String
        writeInt(VAL_CHARSEQUENCE);
        writeCharSequence((CharSequence) v);
    } else if (v instanceof List) {
        writeInt(VAL_LIST);
        writeList((List) v);
    } else if (v instanceof SparseArray) {
        writeInt(VAL_SPARSEARRAY);
        writeSparseArray((SparseArray) v);
    } else if (v instanceof boolean[]) {
        writeInt(VAL_BOOLEANARRAY);
        writeBooleanArray((boolean[]) v);
    } else if (v instanceof byte[]) {
        writeInt(VAL_BYTEARRAY);
        writeByteArray((byte[]) v);
    } else if (v instanceof String[]) {
        writeInt(VAL_STRINGARRAY);
        writeStringArray((String[]) v);
    } else if (v instanceof CharSequence[]) {
        // Must be after String[] and before Object[]
        writeInt(VAL_CHARSEQUENCEARRAY);
        writeCharSequenceArray((CharSequence[]) v);
    } else if (v instanceof IBinder) {
        writeInt(VAL_IBINDER);
        writeStrongBinder((IBinder) v);
    } else if (v instanceof Parcelable[]) {
        writeInt(VAL_PARCELABLEARRAY);
        writeParcelableArray((Parcelable[]) v, 0);
    } else if (v instanceof Object[]) {
        writeInt(VAL_OBJECTARRAY);
        writeArray((Object[]) v);
    } else if (v instanceof int[]) {
        writeInt(VAL_INTARRAY);
        writeIntArray((int[]) v);
    } else if (v instanceof long[]) {
        writeInt(VAL_LONGARRAY);
        writeLongArray((long[]) v);
    } else if (v instanceof Byte) {
        writeInt(VAL_BYTE);
        writeInt((Byte) v);
    } else if (v instanceof Serializable) {
        // Must be last
        writeInt(VAL_SERIALIZABLE);
        writeSerializable((Serializable) v);
    } else {
        throw new RuntimeException(""Parcel: unable to marshal value "" + v);
    }
}",1,"/**
 * Flatten a generic object in to a parcel.  The given Object value may
 * currently be one of the following types:
 *
 * <ul>
 * <li> null
 * <li> String
 * <li> Byte
 * <li> Short
 * <li> Integer
 * <li> Long
 * <li> Float
 * <li> Double
 * <li> Boolean
 * <li> String[]
 * <li> boolean[]
 * <li> byte[]
 * <li> int[]
 * <li> long[]
 * <li> Object[] (supporting objects of the same type defined here).
 * <li> {@link Bundle}
 * <li> Map (as supported by {@link #writeMap}).
 * <li> Any object that implements the {@link Parcelable} protocol.
 * <li> Parcelable[]
 * <li> CharSequence (as supported by {@link TextUtils#writeToParcel}).
 * <li> List (as supported by {@link #writeList}).
 * <li> {@link SparseArray} (as supported by {@link #writeSparseArray}).
 * <li> {@link IBinder}
 * <li> Any object that implements Serializable (but see
 * {@link #writeSerializable} for caveats).  Note that all of the
 * previous types have relatively efficient implementations for
 * writing to a Parcel; having to rely on the generic serialization
 * approach is much less efficient and should be avoided whenever
 * possible.
 * </ul>
 */
","/**
 * Flatten a generic object in to a parcel.  The given Object value may
 * currently be one of the following types:
 *
 * <ul>
 * <li> null
 * <li> String
 * <li> Byte
 * <li> Short
 * <li> Integer
 * <li> Long
 * <li> Float
 * <li> Double
 * <li> Boolean
 * <li> String[]
 * <li> boolean[]
 * <li> byte[]
 * <li> int[]
 * <li> long[]
 * <li> Object[] (supporting objects of the same type defined here).
 * <li> {@link Bundle}
 * <li> Map (as supported by {@link #writeMap}).
 * <li> Any object that implements the {@link Parcelable} protocol.
 * <li> Parcelable[]
 * <li> CharSequence (as supported by {@link TextUtils#writeToParcel}).
 * <li> List (as supported by {@link #writeList}).
 * <li> {@link SparseArray} (as supported by {@link #writeSparseArray}).
 * <li> {@link IBinder}
 * <li> Any object that implements Serializable (but see
 * {@link #writeSerializable} for caveats).  Note that all of the
 * previous types have relatively efficient implementations for
 * writing to a Parcel; having to rely on the generic serialization
 * approach is much less efficient and should be avoided whenever
 * possible.
 * </ul>
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",1,"Two changes were observed between the two versions. First, the method to write CharSequence has been changed from TextUtils.writeToParcel((CharSequence) v, this, 0) to writeCharSequence((CharSequence) v). This involves a new method being introduced, this falls under code change type 4. Second, a new condition and its corresponding write method has been introduced for CharSequence array. This falls under code change type 5, as it involves a new type of object that can be handled by the code.","The change of writing method for CharSequence and introduction of a new type (CharSequence array) could lead to different behaviors of the function. The function in the later version can handle more types of input and potentially returns different outputs with the same input compared to the early version. Therefore, it's classified as CI type 1."
539,<android.server.BluetoothService: boolean enable(boolean)>,7,8,<android.server.BluetoothService: boolean enable(boolean)>,<android.server.BluetoothService: boolean enable(boolean)>,0,"{
    mContext.enforceCallingOrSelfPermission(BLUETOOTH_ADMIN_PERM, ""Need BLUETOOTH_ADMIN permission"");
    // Airplane mode can prevent Bluetooth radio from being turned on.
    if (mIsAirplaneSensitive && isAirplaneModeOn()) {
        return false;
    }
    if (mBluetoothState != BluetoothAdapter.STATE_OFF) {
        return false;
    }
    if (mEnableThread != null && mEnableThread.isAlive()) {
        return false;
    }
    setBluetoothState(BluetoothAdapter.STATE_TURNING_ON);
    mEnableThread = new EnableThread(saveSetting);
    mEnableThread.start();
    return true;
}","{
    mContext.enforceCallingOrSelfPermission(BLUETOOTH_ADMIN_PERM, ""Need BLUETOOTH_ADMIN permission"");
    // Airplane mode can prevent Bluetooth radio from being turned on.
    if (mIsAirplaneSensitive && isAirplaneModeOn() && !mIsAirplaneToggleable) {
        return false;
    }
    if (mBluetoothState != BluetoothAdapter.STATE_OFF) {
        return false;
    }
    if (mEnableThread != null && mEnableThread.isAlive()) {
        return false;
    }
    setBluetoothState(BluetoothAdapter.STATE_TURNING_ON);
    mEnableThread = new EnableThread(saveSetting);
    mEnableThread.start();
    return true;
}",1,"/**
 * Enable this Bluetooth device, asynchronously.
 * This turns on/off the underlying hardware.
 *
 * @param saveSetting If true, persist the new state of BT in settings
 * @return True on success (so far)
 */
","/**
 * Enable this Bluetooth device, asynchronously.
 * This turns on/off the underlying hardware.
 *
 * @param saveSetting If true, persist the new state of BT in settings
 * @return True on success (so far)
 */
",-1,,,-1,-1,-1,-1,-1,-1,3,1,"The change has occurred in 'if' condition of the code, where an additional condition of !mIsAirplaneToggleable has been added. Therefore, the code change type is 3.","The introduction of an additional condition (!mIsAirplaneToggleable) in the 'if' statement can impact the return value of the function. As per the updated version, the function may return true or false based on different conditions than the early version. Therefore, the CI type is 1."
541,"<android.util.Log: int d(String,String)>",7,8,"<android.util.Log: int d(String,String)>","<android.util.Log: int d(String,String)>",0,"{
    return println(DEBUG, tag, msg);
}","{
    return println_native(LOG_ID_MAIN, DEBUG, tag, msg);
}",1,"/**
 * Send a {@link #DEBUG} log message.
 * @param tag Used to identify the source of a log message.  It usually identifies
 * the class or activity where the log call occurs.
 * @param msg The message you would like logged.
 */
","/**
 * Send a {@link #DEBUG} log message.
 * @param tag Used to identify the source of a log message.  It usually identifies
 * the class or activity where the log call occurs.
 * @param msg The message you would like logged.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The return statement has changed from println(DEBUG, tag, msg) to println_native(LOG_ID_MAIN, DEBUG, tag, msg). And what's more important, the method println() is replaced by println_native(), and the parameters quantity and types are also changed. So the code change type is 1,5.","The return statement has changed, which means the API could potentially return a different value in the late version, so the CI type is 1."
543,<android.os.MessageQueue: Message next()>,7,8,<android.os.MessageQueue: Message next()>,<android.os.MessageQueue: Message next()>,0,"{
    boolean tryIdle = true;
    while (true) {
        long now;
        Object[] idlers = null;
        // Try to retrieve the next message, returning if found.
        synchronized (this) {
            now = SystemClock.uptimeMillis();
            Message msg = pullNextLocked(now);
            if (msg != null)
                return msg;
            if (tryIdle && mIdleHandlers.size() > 0) {
                idlers = mIdleHandlers.toArray();
            }
        }
        // There was no message so we are going to wait...  but first,
        // if there are any idle handlers let them know.
        boolean didIdle = false;
        if (idlers != null) {
            for (Object idler : idlers) {
                boolean keep = false;
                try {
                    didIdle = true;
                    keep = ((IdleHandler) idler).queueIdle();
                } catch (Throwable t) {
                    Log.e(""MessageQueue"", ""IdleHandler threw exception"", t);
                    RuntimeInit.crash(""MessageQueue"", t);
                }
                if (!keep) {
                    synchronized (this) {
                        mIdleHandlers.remove(idler);
                    }
                }
            }
        }
        // delivered...  so go back and look again for a pending message.
        if (didIdle) {
            tryIdle = false;
            continue;
        }
        synchronized (this) {
            // No messages, nobody to tell about it...  time to wait!
            try {
                if (mMessages != null) {
                    if (mMessages.when - now > 0) {
                        Binder.flushPendingCommands();
                        this.wait(mMessages.when - now);
                    }
                } else {
                    Binder.flushPendingCommands();
                    this.wait();
                }
            } catch (InterruptedException e) {
            }
        }
    }
}","{
    boolean tryIdle = true;
    while (true) {
        long now;
        Object[] idlers = null;
        // Try to retrieve the next message, returning if found.
        synchronized (this) {
            now = SystemClock.uptimeMillis();
            Message msg = pullNextLocked(now);
            if (msg != null)
                return msg;
            if (tryIdle && mIdleHandlers.size() > 0) {
                idlers = mIdleHandlers.toArray();
            }
        }
        // There was no message so we are going to wait...  but first,
        // if there are any idle handlers let them know.
        boolean didIdle = false;
        if (idlers != null) {
            for (Object idler : idlers) {
                boolean keep = false;
                try {
                    didIdle = true;
                    keep = ((IdleHandler) idler).queueIdle();
                } catch (Throwable t) {
                    Log.wtf(""MessageQueue"", ""IdleHandler threw exception"", t);
                }
                if (!keep) {
                    synchronized (this) {
                        mIdleHandlers.remove(idler);
                    }
                }
            }
        }
        // delivered...  so go back and look again for a pending message.
        if (didIdle) {
            tryIdle = false;
            continue;
        }
        synchronized (this) {
            // No messages, nobody to tell about it...  time to wait!
            try {
                if (mMessages != null) {
                    if (mMessages.when - now > 0) {
                        Binder.flushPendingCommands();
                        this.wait(mMessages.when - now);
                    }
                } else {
                    Binder.flushPendingCommands();
                    this.wait();
                }
            } catch (InterruptedException e) {
            }
        }
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,2,2,"The exception handling statement changed from ""RuntimeInit.crash(""MessageQueue"", t);"" to ""Log.wtf(""MessageQueue"", ""IdleHandler threw exception"", t);"", so actually the code change type is 2.","As the exception handling statement has changed, the API can potentially throw a different exception in the late version, so the CI type is 2."
546,<android.app.WallpaperInfo: Drawable loadThumbnail(PackageManager)>,7,8,<android.app.WallpaperInfo: Drawable loadThumbnail(PackageManager)>,<android.app.WallpaperInfo: Drawable loadThumbnail(PackageManager)>,0,"{
    if (mThumbnailResource < 0)
        return null;
    return pm.getDrawable(mService.serviceInfo.packageName, mThumbnailResource, null);
}","{
    if (mThumbnailResource < 0)
        return null;
    return pm.getDrawable(mService.serviceInfo.packageName, mThumbnailResource, mService.serviceInfo.applicationInfo);
}",1,"/**
 * Load the thumbnail image for this wallpaper.
 *
 * @param pm Supply a PackageManager used to load the wallpaper's
 * resources.
 */
","/**
 * Load the thumbnail image for this wallpaper.
 *
 * @param pm Supply a PackageManager used to load the wallpaper's
 * resources.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,1,"The parameters of pm.getDrawable() method has changed from null to mService.serviceInfo.applicationInfo, so the code change type is 4.","Differnet parameters of pm.getDrawable() may draw different Drawable objects. Therefore, the return value can be different in early and late versions, and the CI type is 1."
547,<android.webkit.WebView.DragTrackerHandler: boolean draw(Canvas)>,7,8,<android.webkit.WebView.DragTrackerHandler: boolean draw(Canvas)>,<android.webkit.WebView.DragTrackerHandler: boolean draw(Canvas)>,0,"{
    if (mCurrStretchX != 0 || mCurrStretchY != 0) {
        int sx = getScrollX();
        int sy = getScrollY() - hiddenHeightOfTitleBar();
        if (mSX != sx || mSY != sy) {
            buildBitmap(sx, sy);
            mSX = sx;
            mSY = sy;
        }
        int count = canvas.save(Canvas.MATRIX_SAVE_FLAG);
        canvas.translate(sx, sy);
        mProxy.onDraw(canvas);
        canvas.restoreToCount(count);
        return true;
    }
    if (DebugFlags.DRAG_TRACKER || DEBUG_DRAG_TRACKER) {
        Log.d(DebugFlags.DRAG_TRACKER_LOGTAG, "" -- draw false "" + mCurrStretchX + "" "" + mCurrStretchY);
    }
    return false;
}","{
    if (mCurrStretchX != 0 || mCurrStretchY != 0) {
        int sx = getScrollX();
        int sy = getScrollY() - hiddenHeightOfTitleBar();
        if (mSX != sx || mSY != sy) {
            buildBitmap(sx, sy);
            mSX = sx;
            mSY = sy;
        }
        if (mState == ANIMATING_STATE) {
            Interpolator.Result result = mInterp.timeToValues(mXY);
            if (result == Interpolator.Result.FREEZE_END) {
                mState = FINISHED_STATE;
                return false;
            } else {
                mProxy.onStretchChange(mXY[0], mXY[1]);
                invalidate();
            // fall through to the draw
            }
        }
        int count = canvas.save(Canvas.MATRIX_SAVE_FLAG);
        canvas.translate(sx, sy);
        mProxy.onDraw(canvas);
        canvas.restoreToCount(count);
        return true;
    }
    if (DebugFlags.DRAG_TRACKER || DEBUG_DRAG_TRACKER) {
        Log.d(DebugFlags.DRAG_TRACKER_LOGTAG, "" -- draw false "" + mCurrStretchX + "" "" + mCurrStretchY);
    }
    return false;
}",1,"/*  If the tracker draws, then this returns true, otherwise it will
         return false, and draw nothing.
         */
","/*  If the tracker draws, then this returns true, otherwise it will
            return false, and draw nothing.
         */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3,4","1,2","New control statements evaluating mState == ANIMATING_STATE and the potential return false inside this control statements are added. Also, new statement mProxy.onStretchChange(mXY[0], mXY[1]) and Interpolator.Result result = mInterp.timeToValues(mXY) were introduced. So the change type is 1,3,4.","The added control statements and the potential return false can cause a change in the return value. There's also an exception handling change due to the introduction of mInterp.timeToValues(mXY) call which can potentially throw an exception. So the CI type is 1,2."
548,<android.widget.ScrollView: boolean dispatchKeyEvent(KeyEvent)>,7,8,<android.widget.ScrollView: boolean dispatchKeyEvent(KeyEvent)>,<android.widget.ScrollView: boolean dispatchKeyEvent(KeyEvent)>,0,"{
    // Let the focused view and/or our descendants get the key first
    boolean handled = super.dispatchKeyEvent(event);
    if (handled) {
        return true;
    }
    return executeKeyEvent(event);
}","{
    // Let the focused view and/or our descendants get the key first
    return super.dispatchKeyEvent(event) || executeKeyEvent(event);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,4",1,"The change involves modifying the conditional statements and the return statement, which is a combination of control flow structure modification and altering return value. Thus, the change is classified as type 1 (Return Statement Changed) and type 4 (Other Statement Changed).","Considering the modification to the return statement, the late version of the API might potentially return different boolean value outcomes in comparison to the early version. Hence it falls into the category of type 1, where a Compatibility Issue caused by potential different return values exists."
549,<android.app.ActivityThread.PackageInfo.ReceiverDispatcher.Args: void run()>,7,8,<android.app.ActivityThread.PackageInfo.ReceiverDispatcher.Args: void run()>,<android.app.ActivityThread.PackageInfo.ReceiverDispatcher.Args: void run()>,0,"{
    BroadcastReceiver receiver = mReceiver;
    if (DEBUG_BROADCAST) {
        int seq = mCurIntent.getIntExtra(""seq"", -1);
        Log.i(TAG, ""Dispatching broadcast "" + mCurIntent.getAction() + "" seq="" + seq + "" to "" + mReceiver);
    }
    if (receiver == null) {
        return;
    }
    IActivityManager mgr = ActivityManagerNative.getDefault();
    Intent intent = mCurIntent;
    mCurIntent = null;
    try {
        ClassLoader cl = mReceiver.getClass().getClassLoader();
        intent.setExtrasClassLoader(cl);
        if (mCurMap != null) {
            mCurMap.setClassLoader(cl);
        }
        receiver.setOrderedHint(true);
        receiver.setResult(mCurCode, mCurData, mCurMap);
        receiver.clearAbortBroadcast();
        receiver.setOrderedHint(mCurOrdered);
        receiver.setInitialStickyHint(mCurSticky);
        receiver.onReceive(mContext, intent);
    } catch (Exception e) {
        if (mRegistered && mCurOrdered) {
            try {
                mgr.finishReceiver(mIIntentReceiver, mCurCode, mCurData, mCurMap, false);
            } catch (RemoteException ex) {
            }
        }
        if (mInstrumentation == null || !mInstrumentation.onException(mReceiver, e)) {
            throw new RuntimeException(""Error receiving broadcast "" + intent + "" in "" + mReceiver, e);
        }
    }
    if (mRegistered && mCurOrdered) {
        try {
            mgr.finishReceiver(mIIntentReceiver, receiver.getResultCode(), receiver.getResultData(), receiver.getResultExtras(false), receiver.getAbortBroadcast());
        } catch (RemoteException ex) {
        }
    }
}","{
    BroadcastReceiver receiver = mReceiver;
    if (DEBUG_BROADCAST) {
        int seq = mCurIntent.getIntExtra(""seq"", -1);
        Slog.i(TAG, ""Dispatching broadcast "" + mCurIntent.getAction() + "" seq="" + seq + "" to "" + mReceiver);
        Slog.i(TAG, ""  mRegistered="" + mRegistered + "" mCurOrdered="" + mCurOrdered);
    }
    IActivityManager mgr = ActivityManagerNative.getDefault();
    Intent intent = mCurIntent;
    mCurIntent = null;
    if (receiver == null) {
        if (mRegistered && mCurOrdered) {
            try {
                if (DEBUG_BROADCAST)
                    Slog.i(TAG, ""Finishing null broadcast to "" + mReceiver);
                mgr.finishReceiver(mIIntentReceiver, mCurCode, mCurData, mCurMap, false);
            } catch (RemoteException ex) {
            }
        }
        return;
    }
    try {
        ClassLoader cl = mReceiver.getClass().getClassLoader();
        intent.setExtrasClassLoader(cl);
        if (mCurMap != null) {
            mCurMap.setClassLoader(cl);
        }
        receiver.setOrderedHint(true);
        receiver.setResult(mCurCode, mCurData, mCurMap);
        receiver.clearAbortBroadcast();
        receiver.setOrderedHint(mCurOrdered);
        receiver.setInitialStickyHint(mCurSticky);
        receiver.onReceive(mContext, intent);
    } catch (Exception e) {
        if (mRegistered && mCurOrdered) {
            try {
                if (DEBUG_BROADCAST)
                    Slog.i(TAG, ""Finishing failed broadcast to "" + mReceiver);
                mgr.finishReceiver(mIIntentReceiver, mCurCode, mCurData, mCurMap, false);
            } catch (RemoteException ex) {
            }
        }
        if (mInstrumentation == null || !mInstrumentation.onException(mReceiver, e)) {
            throw new RuntimeException(""Error receiving broadcast "" + intent + "" in "" + mReceiver, e);
        }
    }
    if (mRegistered && mCurOrdered) {
        try {
            if (DEBUG_BROADCAST)
                Slog.i(TAG, ""Finishing broadcast to "" + mReceiver);
            mgr.finishReceiver(mIIntentReceiver, receiver.getResultCode(), receiver.getResultData(), receiver.getResultExtras(false), receiver.getAbortBroadcast());
        } catch (RemoteException ex) {
        }
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"2,3",0,"The sequence of statements and an exception handling statement have changed. There was a return statement moved down under condition checking and an additional logging statement added under exception handling. So the code change types are 2,3.","The changes in the method do not lead to a different return type or value, and it also does not seem to affect the exception handling of the method. So, there is no compatibility issue."
550,<android.pim.vcard.VCardParser_V21: String[] separateLineAndHandleGroup(String)>,7,8,<android.pim.vcard.VCardParser_V21: String[] separateLineAndHandleGroup(String)>,<android.pim.vcard.VCardParser_V21: String[] separateLineAndHandleGroup(String)>,0,"{
    int length = line.length();
    int state = STATE_GROUP_OR_PROPNAME;
    int nameIndex = 0;
    String[] propertyNameAndValue = new String[2];
    if (length > 0 && line.charAt(0) == '#') {
        throw new VCardInvalidCommentLineException();
    }
    for (int i = 0; i < length; i++) {
        char ch = line.charAt(i);
        switch(state) {
            case STATE_GROUP_OR_PROPNAME:
                if (ch == ':') {
                    String propertyName = line.substring(nameIndex, i);
                    if (propertyName.equalsIgnoreCase(""END"")) {
                        mPreviousLine = line;
                        return null;
                    }
                    if (mBuilder != null) {
                        mBuilder.propertyName(propertyName);
                    }
                    propertyNameAndValue[0] = propertyName;
                    if (i < length - 1) {
                        propertyNameAndValue[1] = line.substring(i + 1);
                    } else {
                        propertyNameAndValue[1] = """";
                    }
                    return propertyNameAndValue;
                } else if (ch == '.') {
                    String groupName = line.substring(nameIndex, i);
                    if (mBuilder != null) {
                        mBuilder.propertyGroup(groupName);
                    }
                    nameIndex = i + 1;
                } else if (ch == ';') {
                    String propertyName = line.substring(nameIndex, i);
                    if (propertyName.equalsIgnoreCase(""END"")) {
                        mPreviousLine = line;
                        return null;
                    }
                    if (mBuilder != null) {
                        mBuilder.propertyName(propertyName);
                    }
                    propertyNameAndValue[0] = propertyName;
                    nameIndex = i + 1;
                    state = STATE_PARAMS;
                }
                break;
            case STATE_PARAMS:
                if (ch == '""') {
                    state = STATE_PARAMS_IN_DQUOTE;
                } else if (ch == ';') {
                    handleParams(line.substring(nameIndex, i));
                    nameIndex = i + 1;
                } else if (ch == ':') {
                    handleParams(line.substring(nameIndex, i));
                    if (i < length - 1) {
                        propertyNameAndValue[1] = line.substring(i + 1);
                    } else {
                        propertyNameAndValue[1] = """";
                    }
                    return propertyNameAndValue;
                }
                break;
            case STATE_PARAMS_IN_DQUOTE:
                if (ch == '""') {
                    state = STATE_PARAMS;
                }
                break;
        }
    }
    throw new VCardInvalidLineException(""Invalid line: \"""" + line + ""\"""");
}","{
    int state = STATE_GROUP_OR_PROPNAME;
    int nameIndex = 0;
    final String[] propertyNameAndValue = new String[2];
    final int length = line.length();
    if (length > 0 && line.charAt(0) == '#') {
        throw new VCardInvalidCommentLineException();
    }
    for (int i = 0; i < length; i++) {
        char ch = line.charAt(i);
        switch(state) {
            case STATE_GROUP_OR_PROPNAME:
                {
                    if (ch == ':') {
                        final String propertyName = line.substring(nameIndex, i);
                        if (propertyName.equalsIgnoreCase(""END"")) {
                            mPreviousLine = line;
                            return null;
                        }
                        if (mBuilder != null) {
                            mBuilder.propertyName(propertyName);
                        }
                        propertyNameAndValue[0] = propertyName;
                        if (i < length - 1) {
                            propertyNameAndValue[1] = line.substring(i + 1);
                        } else {
                            propertyNameAndValue[1] = """";
                        }
                        return propertyNameAndValue;
                    } else if (ch == '.') {
                        String groupName = line.substring(nameIndex, i);
                        if (mBuilder != null) {
                            mBuilder.propertyGroup(groupName);
                        }
                        nameIndex = i + 1;
                    } else if (ch == ';') {
                        String propertyName = line.substring(nameIndex, i);
                        if (propertyName.equalsIgnoreCase(""END"")) {
                            mPreviousLine = line;
                            return null;
                        }
                        if (mBuilder != null) {
                            mBuilder.propertyName(propertyName);
                        }
                        propertyNameAndValue[0] = propertyName;
                        nameIndex = i + 1;
                        state = STATE_PARAMS;
                    }
                    break;
                }
            case STATE_PARAMS:
                {
                    if (ch == '""') {
                        state = STATE_PARAMS_IN_DQUOTE;
                    } else if (ch == ';') {
                        handleParams(line.substring(nameIndex, i));
                        nameIndex = i + 1;
                    } else if (ch == ':') {
                        handleParams(line.substring(nameIndex, i));
                        if (i < length - 1) {
                            propertyNameAndValue[1] = line.substring(i + 1);
                        } else {
                            propertyNameAndValue[1] = """";
                        }
                        return propertyNameAndValue;
                    }
                    break;
                }
            case STATE_PARAMS_IN_DQUOTE:
                {
                    if (ch == '""') {
                        state = STATE_PARAMS;
                    }
                    break;
                }
        }
    }
    throw new VCardInvalidLineException(""Invalid line: \"""" + line + ""\"""");
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,4,0,"Only the format changes have been made, by switching the position of some variables and adding final keywords. So the code change type is 4.","There is no Compatibility Issue, as neither the return value nor the exceptions thrown have changed. So the CI type is 0."
551,<android.os.Environment: String getExternalStorageState()>,7,8,<android.os.Environment: String getExternalStorageState()>,<android.os.Environment: String getExternalStorageState()>,0,"{
    return SystemProperties.get(""EXTERNAL_STORAGE_STATE"", MEDIA_REMOVED);
}","{
    try {
        if (mMntSvc == null) {
            mMntSvc = IMountService.Stub.asInterface(ServiceManager.getService(""mount""));
        }
        return mMntSvc.getVolumeState(getExternalStorageDirectory().toString());
    } catch (Exception rex) {
        return Environment.MEDIA_REMOVED;
    }
}",1,"/**
 * Gets the current state of the external storage device.
 */
","/**
 * Gets the current state of the external storage device.
 * Note: This call should be deprecated as it doesn't support
 * multiple volumes.
 *
 * <p>See {@link #getExternalStorageDirectory()} for an example of its use.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,2,5","1,2","The return statement is changed, now the late version is returning value after calling the getVolumeState() method of IMountService. Also exception handling statement is introduced, so the change type is 1,2,5. ","The change in return statement and exception handling might lead to different behaviour when the late version API is invoked. So, CI situation falls under category 1,2. The getVolumeState() method could return a different value as compared to SystemProperties.get() and the API can throw a different exception because of the added try-catch block."
552,"<android.util.Log: int w(String,String,Throwable)>",7,8,"<android.util.Log: int w(String,String,Throwable)>","<android.util.Log: int w(String,String,Throwable)>",0,"{
    return println(WARN, tag, msg + '\n' + getStackTraceString(tr));
}","{
    return println_native(LOG_ID_MAIN, WARN, tag, msg + '\n' + getStackTraceString(tr));
}",1,"/**
 * Send a {@link #WARN} log message and log the exception.
 * @param tag Used to identify the source of a log message.  It usually identifies
 * the class or activity where the log call occurs.
 * @param msg The message you would like logged.
 * @param tr An exception to log
 */
","/**
 * Send a {@link #WARN} log message and log the exception.
 * @param tag Used to identify the source of a log message.  It usually identifies
 * the class or activity where the log call occurs.
 * @param msg The message you would like logged.
 * @param tr An exception to log
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The return statement changed the function from println to println_native. The dependent API that is invoked has changed, thus the change type is 1,5.",The change of the return statement and dependent API might lead to potentially different behaviors which cause the type 1 Compatibility Issue.
553,<android.provider.Browser: void truncateHistory(ContentResolver)>,7,8,<android.provider.Browser: void truncateHistory(ContentResolver)>,<android.provider.Browser: void truncateHistory(ContentResolver)>,0,"{
    try {
        // Select non-bookmark history, ordered by date
        Cursor c = cr.query(BOOKMARKS_URI, TRUNCATE_HISTORY_PROJECTION, ""bookmark = 0"", null, BookmarkColumns.DATE);
        // Log.v(LOGTAG, ""history count "" + c.count());
        if (c.moveToFirst() && c.getCount() >= MAX_HISTORY_COUNT) {
            /* eliminate oldest history items */
            for (int i = 0; i < TRUNCATE_N_OLDEST; i++) {
                // Log.v(LOGTAG, ""truncate history "" +
                // c.getInt(TRUNCATE_HISTORY_PROJECTION_ID_INDEX));
                deleteHistoryWhere(cr, ""_id = "" + c.getInt(TRUNCATE_HISTORY_PROJECTION_ID_INDEX));
                if (!c.moveToNext())
                    break;
            }
        }
        c.deactivate();
    } catch (IllegalStateException e) {
        Log.e(LOGTAG, ""truncateHistory"", e);
        return;
    }
}","{
    Cursor c = null;
    try {
        // Select non-bookmark history, ordered by date
        c = cr.query(BOOKMARKS_URI, TRUNCATE_HISTORY_PROJECTION, ""bookmark = 0"", null, BookmarkColumns.DATE);
        // Log.v(LOGTAG, ""history count "" + c.count());
        if (c.moveToFirst() && c.getCount() >= MAX_HISTORY_COUNT) {
            /* eliminate oldest history items */
            for (int i = 0; i < TRUNCATE_N_OLDEST; i++) {
                // Log.v(LOGTAG, ""truncate history "" +
                // c.getInt(TRUNCATE_HISTORY_PROJECTION_ID_INDEX));
                cr.delete(BOOKMARKS_URI, ""_id = "" + c.getInt(TRUNCATE_HISTORY_PROJECTION_ID_INDEX), null);
                if (!c.moveToNext())
                    break;
            }
        }
    } catch (IllegalStateException e) {
        Log.e(LOGTAG, ""truncateHistory"", e);
    } finally {
        if (c != null)
            c.close();
    }
}",1,"/**
 * If there are more than MAX_HISTORY_COUNT non-bookmark history
 * items in the bookmark/history table, delete TRUNCATE_N_OLDEST
 * of them.  This is used to keep our history table to a
 * reasonable size.  Note: it does not prune bookmarks.  If the
 * user wants 1000 bookmarks, the user gets 1000 bookmarks.
 * Requires {@link android.Manifest.permission#READ_HISTORY_BOOKMARKS}
 * Requires {@link android.Manifest.permission#WRITE_HISTORY_BOOKMARKS}
 *
 * @param cr The ContentResolver used to access the database.
 */
","/**
 * If there are more than MAX_HISTORY_COUNT non-bookmark history
 * items in the bookmark/history table, delete TRUNCATE_N_OLDEST
 * of them.  This is used to keep our history table to a
 * reasonable size.  Note: it does not prune bookmarks.  If the
 * user wants 1000 bookmarks, the user gets 1000 bookmarks.
 * Requires {@link android.Manifest.permission#READ_HISTORY_BOOKMARKS}
 * Requires {@link android.Manifest.permission#WRITE_HISTORY_BOOKMARKS}
 *
 * @param cr The ContentResolver used to access the database.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"The statement 'deleteHistoryWhere(cr, ""_id = "" + c.getInt(TRUNCATE_HISTORY_PROJECTION_ID_INDEX));' of the early implementation has changed to 'cr.delete(BOOKMARKS_URI, ""_id = "" + c.getInt(TRUNCATE_HISTORY_PROJECTION_ID_INDEX), null);' in the newer version, and an additional 'finally' block is introduced for handling the cursor closing mechanism. So the types of the change are 4 and 5. ",No Compatibility Issue exists since the above changes do not make the API return different values nor throw different exceptions. So the type of Compatibility Issue is 0.
554,"<android.accounts.AccountManager: void invalidateAuthToken(String,String)>",7,8,"<android.accounts.AccountManager: void invalidateAuthToken(String,String)>","<android.accounts.AccountManager: void invalidateAuthToken(String,String)>",0,"{
    try {
        mService.invalidateAuthToken(accountType, authToken);
    } catch (RemoteException e) {
        // won't ever happen
        throw new RuntimeException(e);
    }
}","{
    if (accountType == null)
        throw new IllegalArgumentException(""accountType is null"");
    try {
        if (authToken != null) {
            mService.invalidateAuthToken(accountType, authToken);
        }
    } catch (RemoteException e) {
        // won't ever happen
        throw new RuntimeException(e);
    }
}",1,"/**
 * Removes the given authtoken. If this authtoken does not exist for the given account type
 * then this call has no effect.
 * <p>
 * Requires that the caller has permission {@link android.Manifest.permission#MANAGE_ACCOUNTS}.
 * @param accountType the account type of the authtoken to invalidate
 * @param authToken the authtoken to invalidate
 */
","/**
 * Removes an auth token from the AccountManager's cache.  Does nothing if
 * the auth token is not currently in the cache.  Applications must call this
 * method when the auth token is found to have expired or otherwise become
 * invalid for authenticating requests.  The AccountManager does not validate
 * or expire cached auth tokens otherwise.
 *
 * <p>It is safe to call this method from the main thread.
 *
 * <p>This method requires the caller to hold the permission
 * {@link android.Manifest.permission#MANAGE_ACCOUNTS} or
 * {@link android.Manifest.permission#USE_CREDENTIALS}
 *
 * @param accountType The account type of the auth token to invalidate, must not be null
 * @param authToken The auth token to invalidate, may be null
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,3","1,2","A new conditional 'if' statement was added and a new exception statement 'IllegalArgumentException' was introduced. Therefore, the code change covers type 2 (exception handling statement changed) and type 3 (control dependency changed).","The conditional statement can potentially control the throw of 'IllegalArgumentException', resulting in a change in behavior. Also, the condition 'if (authToken != null)' potentially affects the execution of 'mService.invalidateAuthToken(accountType, authToken)', therefore, it may impact the methods return and exception handling. Therefore, this falls under both CI type 1 (Compatibility Issue caused by potential different return values or types) and CI type 2 (Compatibility Issue caused by potential different exception handlings)."
556,"<android.widget.AutoCompleteTextView: boolean onKeyDown(int,KeyEvent)>",7,8,"<android.widget.AutoCompleteTextView: boolean onKeyDown(int,KeyEvent)>","<android.widget.AutoCompleteTextView: boolean onKeyDown(int,KeyEvent)>",0,"{
    // when the drop down is shown, we drive it directly
    if (isPopupShowing()) {
        // to select one of its items
        if (keyCode != KeyEvent.KEYCODE_SPACE && (mDropDownList.getSelectedItemPosition() >= 0 || (keyCode != KeyEvent.KEYCODE_ENTER && keyCode != KeyEvent.KEYCODE_DPAD_CENTER))) {
            int curIndex = mDropDownList.getSelectedItemPosition();
            boolean consumed;
            final boolean below = !mPopup.isAboveAnchor();
            if ((below && keyCode == KeyEvent.KEYCODE_DPAD_UP && curIndex <= 0) || (!below && keyCode == KeyEvent.KEYCODE_DPAD_DOWN && curIndex >= mDropDownList.getAdapter().getCount() - 1)) {
                // When the selection is at the top, we block the key
                // event to prevent focus from moving.
                clearListSelection();
                mPopup.setInputMethodMode(PopupWindow.INPUT_METHOD_NEEDED);
                showDropDown();
                return true;
            } else {
                // WARNING: Please read the comment where mListSelectionHidden
                // is declared
                mDropDownList.mListSelectionHidden = false;
            }
            consumed = mDropDownList.onKeyDown(keyCode, event);
            if (DEBUG)
                Log.v(TAG, ""Key down: code="" + keyCode + "" list consumed="" + consumed);
            if (consumed) {
                // If it handled the key event, then the user is
                // navigating in the list, so we should put it in front.
                mPopup.setInputMethodMode(PopupWindow.INPUT_METHOD_NOT_NEEDED);
                // Here's a little trick we need to do to make sure that
                // the list view is actually showing its focus indicator,
                // by ensuring it has focus and getting its window out
                // of touch mode.
                mDropDownList.requestFocusFromTouch();
                showDropDown();
                switch(keyCode) {
                    // next component
                    case KeyEvent.KEYCODE_ENTER:
                    case KeyEvent.KEYCODE_DPAD_CENTER:
                    case KeyEvent.KEYCODE_DPAD_DOWN:
                    case KeyEvent.KEYCODE_DPAD_UP:
                        return true;
                }
            } else {
                if (below && keyCode == KeyEvent.KEYCODE_DPAD_DOWN) {
                    // when the selection is at the bottom, we block the
                    // event to avoid going to the next focusable widget
                    Adapter adapter = mDropDownList.getAdapter();
                    if (adapter != null && curIndex == adapter.getCount() - 1) {
                        return true;
                    }
                } else if (!below && keyCode == KeyEvent.KEYCODE_DPAD_UP && curIndex == 0) {
                    return true;
                }
            }
        }
    } else {
        switch(keyCode) {
            case KeyEvent.KEYCODE_DPAD_DOWN:
                performValidation();
        }
    }
    mLastKeyCode = keyCode;
    boolean handled = super.onKeyDown(keyCode, event);
    mLastKeyCode = KeyEvent.KEYCODE_UNKNOWN;
    if (handled && isPopupShowing() && mDropDownList != null) {
        clearListSelection();
    }
    return handled;
}","{
    // when the drop down is shown, we drive it directly
    if (isPopupShowing()) {
        // to select one of its items
        if (keyCode != KeyEvent.KEYCODE_SPACE && (mDropDownList.getSelectedItemPosition() >= 0 || (keyCode != KeyEvent.KEYCODE_ENTER && keyCode != KeyEvent.KEYCODE_DPAD_CENTER))) {
            int curIndex = mDropDownList.getSelectedItemPosition();
            boolean consumed;
            final boolean below = !mPopup.isAboveAnchor();
            final ListAdapter adapter = mAdapter;
            boolean allEnabled;
            int firstItem = Integer.MAX_VALUE;
            int lastItem = Integer.MIN_VALUE;
            if (adapter != null) {
                allEnabled = adapter.areAllItemsEnabled();
                firstItem = allEnabled ? 0 : mDropDownList.lookForSelectablePosition(0, true);
                lastItem = allEnabled ? adapter.getCount() - 1 : mDropDownList.lookForSelectablePosition(adapter.getCount() - 1, false);
            }
            if ((below && keyCode == KeyEvent.KEYCODE_DPAD_UP && curIndex <= firstItem) || (!below && keyCode == KeyEvent.KEYCODE_DPAD_DOWN && curIndex >= lastItem)) {
                // When the selection is at the top, we block the key
                // event to prevent focus from moving.
                clearListSelection();
                mPopup.setInputMethodMode(PopupWindow.INPUT_METHOD_NEEDED);
                showDropDown();
                return true;
            } else {
                // WARNING: Please read the comment where mListSelectionHidden
                // is declared
                mDropDownList.mListSelectionHidden = false;
            }
            consumed = mDropDownList.onKeyDown(keyCode, event);
            if (DEBUG)
                Log.v(TAG, ""Key down: code="" + keyCode + "" list consumed="" + consumed);
            if (consumed) {
                // If it handled the key event, then the user is
                // navigating in the list, so we should put it in front.
                mPopup.setInputMethodMode(PopupWindow.INPUT_METHOD_NOT_NEEDED);
                // Here's a little trick we need to do to make sure that
                // the list view is actually showing its focus indicator,
                // by ensuring it has focus and getting its window out
                // of touch mode.
                mDropDownList.requestFocusFromTouch();
                showDropDown();
                switch(keyCode) {
                    // next component
                    case KeyEvent.KEYCODE_ENTER:
                    case KeyEvent.KEYCODE_DPAD_CENTER:
                    case KeyEvent.KEYCODE_DPAD_DOWN:
                    case KeyEvent.KEYCODE_DPAD_UP:
                        return true;
                }
            } else {
                if (below && keyCode == KeyEvent.KEYCODE_DPAD_DOWN) {
                    // event to avoid going to the next focusable widget
                    if (curIndex == lastItem) {
                        return true;
                    }
                } else if (!below && keyCode == KeyEvent.KEYCODE_DPAD_UP && curIndex == firstItem) {
                    return true;
                }
            }
        }
    } else {
        switch(keyCode) {
            case KeyEvent.KEYCODE_DPAD_DOWN:
                performValidation();
        }
    }
    mLastKeyCode = keyCode;
    boolean handled = super.onKeyDown(keyCode, event);
    mLastKeyCode = KeyEvent.KEYCODE_UNKNOWN;
    if (handled && isPopupShowing() && mDropDownList != null) {
        clearListSelection();
    }
    return handled;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,4",1,"In the late version, the method now includes logic to handle when adapter is not null. This includes initializing allEnabled, firstItem and lastItem and changing some conditionals to use firstItem and lastItem instead of hardcoded values. Therefore, the change type is 3 (Control dependency changed) and 4 (Other statement changed).",These modifications can potentially change the return statements in the late version based on the different control flow path and thus introduce compatibility issue type 1 (Different return statements).
557,"<android.widget.LinearLayout: void measureVertical(int,int)>",7,8,"<android.widget.LinearLayout: void measureVertical(int,int)>","<android.widget.LinearLayout: void measureVertical(int,int)>",0,"{
    mTotalLength = 0;
    int maxWidth = 0;
    int alternativeMaxWidth = 0;
    int weightedMaxWidth = 0;
    boolean allFillParent = true;
    float totalWeight = 0;
    final int count = getVirtualChildCount();
    final int widthMode = MeasureSpec.getMode(widthMeasureSpec);
    final int heightMode = MeasureSpec.getMode(heightMeasureSpec);
    boolean matchWidth = false;
    final int baselineChildIndex = mBaselineAlignedChildIndex;
    // See how tall everyone is. Also remember max width.
    for (int i = 0; i < count; ++i) {
        final View child = getVirtualChildAt(i);
        if (child == null) {
            mTotalLength += measureNullChild(i);
            continue;
        }
        if (child.getVisibility() == View.GONE) {
            i += getChildrenSkipCount(child, i);
            continue;
        }
        LinearLayout.LayoutParams lp = (LinearLayout.LayoutParams) child.getLayoutParams();
        totalWeight += lp.weight;
        if (heightMode == MeasureSpec.EXACTLY && lp.height == 0 && lp.weight > 0) {
            // Optimization: don't bother measuring children who are going to use
            // leftover space. These views will get measured again down below if
            // there is any leftover space.
            mTotalLength += lp.topMargin + lp.bottomMargin;
        } else {
            int oldHeight = Integer.MIN_VALUE;
            if (lp.height == 0 && lp.weight > 0) {
                // heightMode is either UNSPECIFIED OR AT_MOST, and this child
                // wanted to stretch to fill available space. Translate that to
                // WRAP_CONTENT so that it does not end up with a height of 0
                oldHeight = 0;
                lp.height = LayoutParams.WRAP_CONTENT;
            }
            // Determine how big this child would like to.  If this or
            // previous children have given a weight, then we allow it to
            // use all available space (and we will shrink things later
            // if needed).
            measureChildBeforeLayout(child, i, widthMeasureSpec, 0, heightMeasureSpec, totalWeight == 0 ? mTotalLength : 0);
            if (oldHeight != Integer.MIN_VALUE) {
                lp.height = oldHeight;
            }
            mTotalLength += child.getMeasuredHeight() + lp.topMargin + lp.bottomMargin + getNextLocationOffset(child);
        }
        /**
         * If applicable, compute the additional offset to the child's baseline
         * we'll need later when asked {@link #getBaseline}.
         */
        if ((baselineChildIndex >= 0) && (baselineChildIndex == i + 1)) {
            mBaselineChildTop = mTotalLength;
        }
        // weight.  fail fast to aid the developer.
        if (i < baselineChildIndex && lp.weight > 0) {
            throw new RuntimeException(""A child of LinearLayout with index "" + ""less than mBaselineAlignedChildIndex has weight > 0, which "" + ""won't work.  Either remove the weight, or don't set "" + ""mBaselineAlignedChildIndex."");
        }
        boolean matchWidthLocally = false;
        if (widthMode != MeasureSpec.EXACTLY && lp.width == LayoutParams.FILL_PARENT) {
            // The width of the linear layout will scale, and at least one
            // child said it wanted to match our width. Set a flag
            // indicating that we need to remeasure at least that view when
            // we know our width.
            matchWidth = true;
            matchWidthLocally = true;
        }
        final int margin = lp.leftMargin + lp.rightMargin;
        final int measuredWidth = child.getMeasuredWidth() + margin;
        maxWidth = Math.max(maxWidth, measuredWidth);
        allFillParent = allFillParent && lp.width == LayoutParams.FILL_PARENT;
        if (lp.weight > 0) {
            /*
                 * Widths of weighted Views are bogus if we end up
                 * remeasuring, so keep them separate.
                 */
            weightedMaxWidth = Math.max(weightedMaxWidth, matchWidthLocally ? margin : measuredWidth);
        } else {
            alternativeMaxWidth = Math.max(alternativeMaxWidth, matchWidthLocally ? margin : measuredWidth);
        }
        i += getChildrenSkipCount(child, i);
    }
    // Add in our padding
    mTotalLength += mPaddingTop + mPaddingBottom;
    int heightSize = mTotalLength;
    // Check against our minimum height
    heightSize = Math.max(heightSize, getSuggestedMinimumHeight());
    // Reconcile our calculated size with the heightMeasureSpec
    heightSize = resolveSize(heightSize, heightMeasureSpec);
    // Either expand children with weight to take up available space or
    // shrink them if they extend beyond our current bounds
    int delta = heightSize - mTotalLength;
    if (delta != 0 && totalWeight > 0.0f) {
        float weightSum = mWeightSum > 0.0f ? mWeightSum : totalWeight;
        mTotalLength = 0;
        for (int i = 0; i < count; ++i) {
            final View child = getVirtualChildAt(i);
            if (child.getVisibility() == View.GONE) {
                continue;
            }
            LinearLayout.LayoutParams lp = (LinearLayout.LayoutParams) child.getLayoutParams();
            float childExtra = lp.weight;
            if (childExtra > 0) {
                // Child said it could absorb extra space -- give him his share
                int share = (int) (childExtra * delta / weightSum);
                weightSum -= childExtra;
                delta -= share;
                final int childWidthMeasureSpec = getChildMeasureSpec(widthMeasureSpec, mPaddingLeft + mPaddingRight + lp.leftMargin + lp.rightMargin, lp.width);
                // child has been previously measured
                if ((lp.height != 0) || (heightMode != MeasureSpec.EXACTLY)) {
                    // child was measured once already above...
                    // base new measurement on stored values
                    int childHeight = child.getMeasuredHeight() + share;
                    if (childHeight < 0) {
                        childHeight = 0;
                    }
                    child.measure(childWidthMeasureSpec, MeasureSpec.makeMeasureSpec(childHeight, MeasureSpec.EXACTLY));
                } else {
                    // child was skipped in the loop above.
                    // Measure for this first time here
                    child.measure(childWidthMeasureSpec, MeasureSpec.makeMeasureSpec(share > 0 ? share : 0, MeasureSpec.EXACTLY));
                }
            }
            final int margin = lp.leftMargin + lp.rightMargin;
            final int measuredWidth = child.getMeasuredWidth() + margin;
            maxWidth = Math.max(maxWidth, measuredWidth);
            boolean matchWidthLocally = widthMode != MeasureSpec.EXACTLY && lp.width == LayoutParams.FILL_PARENT;
            alternativeMaxWidth = Math.max(alternativeMaxWidth, matchWidthLocally ? margin : measuredWidth);
            allFillParent = allFillParent && lp.width == LayoutParams.FILL_PARENT;
            mTotalLength += child.getMeasuredHeight() + lp.topMargin + lp.bottomMargin + getNextLocationOffset(child);
        }
        // Add in our padding
        mTotalLength += mPaddingTop + mPaddingBottom;
    } else {
        alternativeMaxWidth = Math.max(alternativeMaxWidth, weightedMaxWidth);
    }
    if (!allFillParent && widthMode != MeasureSpec.EXACTLY) {
        maxWidth = alternativeMaxWidth;
    }
    maxWidth += mPaddingLeft + mPaddingRight;
    // Check against our minimum width
    maxWidth = Math.max(maxWidth, getSuggestedMinimumWidth());
    setMeasuredDimension(resolveSize(maxWidth, widthMeasureSpec), heightSize);
    if (matchWidth) {
        forceUniformWidth(count, heightMeasureSpec);
    }
}","{
    mTotalLength = 0;
    int maxWidth = 0;
    int alternativeMaxWidth = 0;
    int weightedMaxWidth = 0;
    boolean allFillParent = true;
    float totalWeight = 0;
    final int count = getVirtualChildCount();
    final int widthMode = MeasureSpec.getMode(widthMeasureSpec);
    final int heightMode = MeasureSpec.getMode(heightMeasureSpec);
    boolean matchWidth = false;
    final int baselineChildIndex = mBaselineAlignedChildIndex;
    final boolean useLargestChild = mUseLargestChild;
    int largestChildHeight = Integer.MIN_VALUE;
    // See how tall everyone is. Also remember max width.
    for (int i = 0; i < count; ++i) {
        final View child = getVirtualChildAt(i);
        if (child == null) {
            mTotalLength += measureNullChild(i);
            continue;
        }
        if (child.getVisibility() == View.GONE) {
            i += getChildrenSkipCount(child, i);
            continue;
        }
        LinearLayout.LayoutParams lp = (LinearLayout.LayoutParams) child.getLayoutParams();
        totalWeight += lp.weight;
        if (heightMode == MeasureSpec.EXACTLY && lp.height == 0 && lp.weight > 0) {
            // Optimization: don't bother measuring children who are going to use
            // leftover space. These views will get measured again down below if
            // there is any leftover space.
            final int totalLength = mTotalLength;
            mTotalLength = Math.max(totalLength, totalLength + lp.topMargin + lp.bottomMargin);
        } else {
            int oldHeight = Integer.MIN_VALUE;
            if (lp.height == 0 && lp.weight > 0) {
                // heightMode is either UNSPECIFIED or AT_MOST, and this
                // child wanted to stretch to fill available space.
                // Translate that to WRAP_CONTENT so that it does not end up
                // with a height of 0
                oldHeight = 0;
                lp.height = LayoutParams.WRAP_CONTENT;
            }
            // Determine how big this child would like to be. If this or
            // previous children have given a weight, then we allow it to
            // use all available space (and we will shrink things later
            // if needed).
            measureChildBeforeLayout(child, i, widthMeasureSpec, 0, heightMeasureSpec, totalWeight == 0 ? mTotalLength : 0);
            if (oldHeight != Integer.MIN_VALUE) {
                lp.height = oldHeight;
            }
            final int childHeight = child.getMeasuredHeight();
            final int totalLength = mTotalLength;
            mTotalLength = Math.max(totalLength, totalLength + childHeight + lp.topMargin + lp.bottomMargin + getNextLocationOffset(child));
            if (useLargestChild) {
                largestChildHeight = Math.max(childHeight, largestChildHeight);
            }
        }
        /**
         * If applicable, compute the additional offset to the child's baseline
         * we'll need later when asked {@link #getBaseline}.
         */
        if ((baselineChildIndex >= 0) && (baselineChildIndex == i + 1)) {
            mBaselineChildTop = mTotalLength;
        }
        // weight.  fail fast to aid the developer.
        if (i < baselineChildIndex && lp.weight > 0) {
            throw new RuntimeException(""A child of LinearLayout with index "" + ""less than mBaselineAlignedChildIndex has weight > 0, which "" + ""won't work.  Either remove the weight, or don't set "" + ""mBaselineAlignedChildIndex."");
        }
        boolean matchWidthLocally = false;
        if (widthMode != MeasureSpec.EXACTLY && lp.width == LayoutParams.MATCH_PARENT) {
            // The width of the linear layout will scale, and at least one
            // child said it wanted to match our width. Set a flag
            // indicating that we need to remeasure at least that view when
            // we know our width.
            matchWidth = true;
            matchWidthLocally = true;
        }
        final int margin = lp.leftMargin + lp.rightMargin;
        final int measuredWidth = child.getMeasuredWidth() + margin;
        maxWidth = Math.max(maxWidth, measuredWidth);
        allFillParent = allFillParent && lp.width == LayoutParams.MATCH_PARENT;
        if (lp.weight > 0) {
            /*
                 * Widths of weighted Views are bogus if we end up
                 * remeasuring, so keep them separate.
                 */
            weightedMaxWidth = Math.max(weightedMaxWidth, matchWidthLocally ? margin : measuredWidth);
        } else {
            alternativeMaxWidth = Math.max(alternativeMaxWidth, matchWidthLocally ? margin : measuredWidth);
        }
        i += getChildrenSkipCount(child, i);
    }
    if (useLargestChild && heightMode == MeasureSpec.AT_MOST) {
        mTotalLength = 0;
        for (int i = 0; i < count; ++i) {
            final View child = getVirtualChildAt(i);
            if (child == null) {
                mTotalLength += measureNullChild(i);
                continue;
            }
            if (child.getVisibility() == GONE) {
                i += getChildrenSkipCount(child, i);
                continue;
            }
            final LinearLayout.LayoutParams lp = (LinearLayout.LayoutParams) child.getLayoutParams();
            // Account for negative margins
            final int totalLength = mTotalLength;
            mTotalLength = Math.max(totalLength, totalLength + largestChildHeight + lp.topMargin + lp.bottomMargin + getNextLocationOffset(child));
        }
    }
    // Add in our padding
    mTotalLength += mPaddingTop + mPaddingBottom;
    int heightSize = mTotalLength;
    // Check against our minimum height
    heightSize = Math.max(heightSize, getSuggestedMinimumHeight());
    // Reconcile our calculated size with the heightMeasureSpec
    heightSize = resolveSize(heightSize, heightMeasureSpec);
    // Either expand children with weight to take up available space or
    // shrink them if they extend beyond our current bounds
    int delta = heightSize - mTotalLength;
    if (delta != 0 && totalWeight > 0.0f) {
        float weightSum = mWeightSum > 0.0f ? mWeightSum : totalWeight;
        mTotalLength = 0;
        for (int i = 0; i < count; ++i) {
            final View child = getVirtualChildAt(i);
            if (child.getVisibility() == View.GONE) {
                continue;
            }
            LinearLayout.LayoutParams lp = (LinearLayout.LayoutParams) child.getLayoutParams();
            float childExtra = lp.weight;
            if (childExtra > 0) {
                // Child said it could absorb extra space -- give him his share
                int share = (int) (childExtra * delta / weightSum);
                weightSum -= childExtra;
                delta -= share;
                final int childWidthMeasureSpec = getChildMeasureSpec(widthMeasureSpec, mPaddingLeft + mPaddingRight + lp.leftMargin + lp.rightMargin, lp.width);
                // child has been previously measured
                if ((lp.height != 0) || (heightMode != MeasureSpec.EXACTLY)) {
                    // child was measured once already above...
                    // base new measurement on stored values
                    int childHeight = child.getMeasuredHeight() + share;
                    if (childHeight < 0) {
                        childHeight = 0;
                    }
                    child.measure(childWidthMeasureSpec, MeasureSpec.makeMeasureSpec(childHeight, MeasureSpec.EXACTLY));
                } else {
                    // child was skipped in the loop above.
                    // Measure for this first time here
                    child.measure(childWidthMeasureSpec, MeasureSpec.makeMeasureSpec(share > 0 ? share : 0, MeasureSpec.EXACTLY));
                }
            }
            final int margin = lp.leftMargin + lp.rightMargin;
            final int measuredWidth = child.getMeasuredWidth() + margin;
            maxWidth = Math.max(maxWidth, measuredWidth);
            boolean matchWidthLocally = widthMode != MeasureSpec.EXACTLY && lp.width == LayoutParams.MATCH_PARENT;
            alternativeMaxWidth = Math.max(alternativeMaxWidth, matchWidthLocally ? margin : measuredWidth);
            allFillParent = allFillParent && lp.width == LayoutParams.MATCH_PARENT;
            final int totalLength = mTotalLength;
            mTotalLength = Math.max(totalLength, totalLength + child.getMeasuredHeight() + lp.topMargin + lp.bottomMargin + getNextLocationOffset(child));
        }
        // Add in our padding
        mTotalLength += mPaddingTop + mPaddingBottom;
    // TODO: Should we recompute the heightSpec based on the new total length?
    } else {
        alternativeMaxWidth = Math.max(alternativeMaxWidth, weightedMaxWidth);
    }
    if (!allFillParent && widthMode != MeasureSpec.EXACTLY) {
        maxWidth = alternativeMaxWidth;
    }
    maxWidth += mPaddingLeft + mPaddingRight;
    // Check against our minimum width
    maxWidth = Math.max(maxWidth, getSuggestedMinimumWidth());
    setMeasuredDimension(resolveSize(maxWidth, widthMeasureSpec), heightSize);
    if (matchWidth) {
        forceUniformWidth(count, heightMeasureSpec);
    }
}",1,"/**
 * Measures the children when the orientation of this LinearLayout is set
 * to {@link #VERTICAL}.
 *
 * @param widthMeasureSpec Horizontal space requirements as imposed by the parent.
 * @param heightMeasureSpec Vertical space requirements as imposed by the parent.
 *
 * @see #getOrientation()
 * @see #setOrientation(int)
 * @see #onMeasure(int, int)
 */
","/**
 * Measures the children when the orientation of this LinearLayout is set
 * to {@link #VERTICAL}.
 *
 * @param widthMeasureSpec Horizontal space requirements as imposed by the parent.
 * @param heightMeasureSpec Vertical space requirements as imposed by the parent.
 *
 * @see #getOrientation()
 * @see #setOrientation(int)
 * @see #onMeasure(int, int)
 */
",-1,,,-1,-1,-1,-1,-1,-1,,,,
558,"<android.widget.HeaderViewListAdapter: View getView(int,View,ViewGroup)>",7,8,"<android.widget.HeaderViewListAdapter: View getView(int,View,ViewGroup)>","<android.widget.HeaderViewListAdapter: View getView(int,View,ViewGroup)>",0,"{
    int numHeaders = getHeadersCount();
    if (mAdapter != null && position >= numHeaders) {
        int adjPosition = position - numHeaders;
        int adapterCount = mAdapter.getCount();
        if (adjPosition >= adapterCount) {
            if (mFooterViewInfos != null) {
                return mFooterViewInfos.get(adjPosition - adapterCount).view;
            }
        } else {
            return mAdapter.getView(adjPosition, convertView, parent);
        }
    } else if (position < numHeaders) {
        return mHeaderViewInfos.get(position).view;
    }
    return null;
}","{
    // Header (negative positions will throw an ArrayIndexOutOfBoundsException)
    int numHeaders = getHeadersCount();
    if (position < numHeaders) {
        return mHeaderViewInfos.get(position).view;
    }
    // Adapter
    final int adjPosition = position - numHeaders;
    int adapterCount = 0;
    if (mAdapter != null) {
        adapterCount = mAdapter.getCount();
        if (adjPosition < adapterCount) {
            return mAdapter.getView(adjPosition, convertView, parent);
        }
    }
    // Footer (off-limits positions will throw an ArrayIndexOutOfBoundsException)
    return mFooterViewInfos.get(adjPosition - adapterCount).view;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,3,1,"The control statement has been rearranged and their conditions have been changed under 'if' and 'else if'. The control dependency has been changed, so the code change type is 3.","Due to the condition changes under 'if' and 'else if', the processed path may be different leading the API to potentially return a different value, so the CI type is 1."
559,"<android.database.sqlite.SQLiteDatabase: long insert(String,String,ContentValues)>",7,8,"<android.database.sqlite.SQLiteDatabase: long insert(String,String,ContentValues)>","<android.database.sqlite.SQLiteDatabase: long insert(String,String,ContentValues)>",0,"{
    try {
        return insertWithOnConflict(table, nullColumnHack, values, null);
    } catch (SQLException e) {
        Log.e(TAG, ""Error inserting "" + values, e);
        return -1;
    }
}","{
    try {
        return insertWithOnConflict(table, nullColumnHack, values, CONFLICT_NONE);
    } catch (SQLException e) {
        Log.e(TAG, ""Error inserting "" + values, e);
        return -1;
    }
}",1,"/**
 * Convenience method for inserting a row into the database.
 *
 * @param table the table to insert the row into
 * @param nullColumnHack SQL doesn't allow inserting a completely empty row,
 * so if initialValues is empty this column will explicitly be
 * assigned a NULL value
 * @param values this map contains the initial column values for the
 * row. The keys should be the column names and the values the
 * column values
 * @return the row ID of the newly inserted row, or -1 if an error occurred
 */
","/**
 * Convenience method for inserting a row into the database.
 *
 * @param table the table to insert the row into
 * @param nullColumnHack SQL doesn't allow inserting a completely empty row,
 * so if initialValues is empty this column will explicitly be
 * assigned a NULL value
 * @param values this map contains the initial column values for the
 * row. The keys should be the column names and the values the
 * column values
 * @return the row ID of the newly inserted row, or -1 if an error occurred
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The method call in the return statement has been modified, where the parameter involved has changed from `null` to `CONFLICT_NONE` in the method `insertWithOnConflict()`. This change classifies as code change types 1 and 5.","Through code changes, a different parameter is passed to the method `insertWithOnConflict()`. Therefore, the API method `insert()` could potentially return a different value depending on the changed parameter. This suggests a compatibility issue of type 1 (Different return values or types)."
560,"<android.util.Log: int d(String,String,Throwable)>",7,8,"<android.util.Log: int d(String,String,Throwable)>","<android.util.Log: int d(String,String,Throwable)>",0,"{
    return println(DEBUG, tag, msg + '\n' + getStackTraceString(tr));
}","{
    return println_native(LOG_ID_MAIN, DEBUG, tag, msg + '\n' + getStackTraceString(tr));
}",1,"/**
 * Send a {@link #DEBUG} log message and log the exception.
 * @param tag Used to identify the source of a log message.  It usually identifies
 * the class or activity where the log call occurs.
 * @param msg The message you would like logged.
 * @param tr An exception to log
 */
","/**
 * Send a {@link #DEBUG} log message and log the exception.
 * @param tag Used to identify the source of a log message.  It usually identifies
 * the class or activity where the log call occurs.
 * @param msg The message you would like logged.
 * @param tr An exception to log
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The return statement has changed from println() to println_native(). Also, the type and number of parameters of this method changed due to the introduction of a new constant 'LOG_ID_MAIN'. Hence, the code change type is marked as 1,5.","Since the return statement has been altered, this change may potentially cause the method to return a different value or type. Consequently, a compatibility issue of type 1 exists."
561,<android.webkit.LoadListener: void loadSynchronousMessages()>,7,8,<android.webkit.LoadListener: void loadSynchronousMessages()>,<android.webkit.LoadListener: void loadSynchronousMessages()>,0,"{
    if (DebugFlags.LOAD_LISTENER && !mSynchronous) {
        throw new AssertionError();
    }
    // don't set it to null.
    for (int size = mMessageQueue.size(); size > 0; size--) {
        handleMessage(mMessageQueue.remove(0));
    }
}","{
    if (DebugFlags.LOAD_LISTENER && !mSynchronous) {
        throw new AssertionError();
    }
    // don't set it to null.
    while (!mMessageQueue.isEmpty()) {
        handleMessage(mMessageQueue.remove(0));
    }
}",1,"/* package */
","/* package */
",-1,,,-1,-1,-1,-1,-1,-1,3,0,"The 'for' loop is changed to 'while', the conditions are changed from checking the array's size to checking whether it's empty. So the code change type is 3.","Emptiness and size are both indicators of the presence of elements in an array, therefore it is very unlikely that these changes will lead to compatibility issues. All 'handleMessage' calls in the iterations should handle the same messages in both early and late versions. So there is no Compatibility Issue, the type is 0."
562,<android.content.res.Configuration: String toString()>,7,8,<android.content.res.Configuration: String toString()>,<android.content.res.Configuration: String toString()>,0,"{
    StringBuilder sb = new StringBuilder(128);
    sb.append(""{ scale="");
    sb.append(fontScale);
    sb.append("" imsi="");
    sb.append(mcc);
    sb.append(""/"");
    sb.append(mnc);
    sb.append("" loc="");
    sb.append(locale);
    sb.append("" touch="");
    sb.append(touchscreen);
    sb.append("" keys="");
    sb.append(keyboard);
    sb.append(""/"");
    sb.append(keyboardHidden);
    sb.append(""/"");
    sb.append(hardKeyboardHidden);
    sb.append("" nav="");
    sb.append(navigation);
    sb.append(""/"");
    sb.append(navigationHidden);
    sb.append("" orien="");
    sb.append(orientation);
    sb.append("" layout="");
    sb.append(screenLayout);
    sb.append('}');
    return sb.toString();
}","{
    StringBuilder sb = new StringBuilder(128);
    sb.append(""{ scale="");
    sb.append(fontScale);
    sb.append("" imsi="");
    sb.append(mcc);
    sb.append(""/"");
    sb.append(mnc);
    sb.append("" loc="");
    sb.append(locale);
    sb.append("" touch="");
    sb.append(touchscreen);
    sb.append("" keys="");
    sb.append(keyboard);
    sb.append(""/"");
    sb.append(keyboardHidden);
    sb.append(""/"");
    sb.append(hardKeyboardHidden);
    sb.append("" nav="");
    sb.append(navigation);
    sb.append(""/"");
    sb.append(navigationHidden);
    sb.append("" orien="");
    sb.append(orientation);
    sb.append("" layout="");
    sb.append(screenLayout);
    sb.append("" uiMode="");
    sb.append(uiMode);
    if (seq != 0) {
        sb.append("" seq="");
        sb.append(seq);
    }
    sb.append('}');
    return sb.toString();
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"1,3",1,"New lines of code have been added to the late version and a new condition statement 'if (seq != 0)' has been introduced, so the code change type is 1,3.","As new lines of code are added to the method in the late version, the returned string by the method could be different, thus the CI type is 1."
563,<android.webkit.WebSettings: boolean getPluginsEnabled()>,7,8,<android.webkit.WebSettings: boolean getPluginsEnabled()>,<android.webkit.WebSettings: boolean getPluginsEnabled()>,0,"{
    return mPluginsEnabled;
}","{
    return mPluginState == PluginState.ON;
}",1,"/**
 * Return true if plugins are enabled.
 * @return True if plugins are enabled.
 */
","/**
 * Return true if plugins are enabled.
 * @return True if plugins are enabled.
 * @deprecated This method has been replaced by {@link #getPluginState}
 */
",-1,,,-1,-1,-1,-1,-1,-1,1,1,"The method returned value has been changed from mPluginsEnabled to mPluginState == PluginState.ON, so the change type is 1.","Since the returned value is different between two versions, it's possible that the API behavior differs too, hence the compatibility issue of type 1."
564,"<android.provider.MediaStore.Images.Media: String insertImage(ContentResolver,Bitmap,String,String)>",7,8,"<android.provider.MediaStore.Images.Media: String insertImage(ContentResolver,Bitmap,String,String)>","<android.provider.MediaStore.Images.Media: String insertImage(ContentResolver,Bitmap,String,String)>",0,"{
    ContentValues values = new ContentValues();
    values.put(Images.Media.TITLE, title);
    values.put(Images.Media.DESCRIPTION, description);
    values.put(Images.Media.MIME_TYPE, ""image/jpeg"");
    Uri url = null;
    String stringUrl = null;
    try {
        url = cr.insert(EXTERNAL_CONTENT_URI, values);
        if (source != null) {
            OutputStream imageOut = cr.openOutputStream(url);
            try {
                source.compress(Bitmap.CompressFormat.JPEG, 50, imageOut);
            } finally {
                imageOut.close();
            }
            long id = ContentUris.parseId(url);
            Bitmap miniThumb = StoreThumbnail(cr, source, id, 320F, 240F, Images.Thumbnails.MINI_KIND);
            Bitmap microThumb = StoreThumbnail(cr, miniThumb, id, 50F, 50F, Images.Thumbnails.MICRO_KIND);
        } else {
            Log.e(TAG, ""Failed to create thumbnail, removing original"");
            cr.delete(url, null, null);
            url = null;
        }
    } catch (Exception e) {
        Log.e(TAG, ""Failed to insert image"", e);
        if (url != null) {
            cr.delete(url, null, null);
            url = null;
        }
    }
    if (url != null) {
        stringUrl = url.toString();
    }
    return stringUrl;
}","{
    ContentValues values = new ContentValues();
    values.put(Images.Media.TITLE, title);
    values.put(Images.Media.DESCRIPTION, description);
    values.put(Images.Media.MIME_TYPE, ""image/jpeg"");
    Uri url = null;
    String stringUrl = null;
    try {
        url = cr.insert(EXTERNAL_CONTENT_URI, values);
        if (source != null) {
            OutputStream imageOut = cr.openOutputStream(url);
            try {
                source.compress(Bitmap.CompressFormat.JPEG, 50, imageOut);
            } finally {
                imageOut.close();
            }
            long id = ContentUris.parseId(url);
            // Wait until MINI_KIND thumbnail is generated.
            Bitmap miniThumb = Images.Thumbnails.getThumbnail(cr, id, Images.Thumbnails.MINI_KIND, null);
            // This is for backward compatibility.
            Bitmap microThumb = StoreThumbnail(cr, miniThumb, id, 50F, 50F, Images.Thumbnails.MICRO_KIND);
        } else {
            Log.e(TAG, ""Failed to create thumbnail, removing original"");
            cr.delete(url, null, null);
            url = null;
        }
    } catch (Exception e) {
        Log.e(TAG, ""Failed to insert image"", e);
        if (url != null) {
            cr.delete(url, null, null);
            url = null;
        }
    }
    if (url != null) {
        stringUrl = url.toString();
    }
    return stringUrl;
}",1,"/**
 * Insert an image and create a thumbnail for it.
 *
 * @param cr The content resolver to use
 * @param source The stream to use for the image
 * @param title The name of the image
 * @param description The description of the image
 * @return The URL to the newly created image, or <code>null</code> if the image failed to be stored
 * for any reason.
 */
","/**
 * Insert an image and create a thumbnail for it.
 *
 * @param cr The content resolver to use
 * @param source The stream to use for the image
 * @param title The name of the image
 * @param description The description of the image
 * @return The URL to the newly created image, or <code>null</code> if the image failed to be stored
 * for any reason.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",1,"The line `Bitmap miniThumb = StoreThumbnail(cr, source, id, 320F, 240F, Images.Thumbnails.MINI_KIND);` is replaced by `Bitmap miniThumb = Images.Thumbnails.getThumbnail(cr, id, Images.Thumbnails.MINI_KIND, null);`, so the change type is 4,5.","The change of the method call StoreThumbnail to Images.Thumbnails.getThumbnail may cause the method to return a different value, so the CI type is 1."
565,<android.pim.vcard.VCardConfig: boolean isJapaneseDevice(int)>,7,8,<android.pim.vcard.VCardConfig: boolean isJapaneseDevice(int)>,<android.pim.vcard.VCardConfig: boolean isJapaneseDevice(int)>,0,"{
    return ((vcardType == VCARD_TYPE_V21_JAPANESE) || (vcardType == VCARD_TYPE_V21_JAPANESE_UTF8) || (vcardType == VCARD_TYPE_V30_JAPANESE) || (vcardType == VCARD_TYPE_V30_JAPANESE_UTF8) || (vcardType == VCARD_TYPE_DOCOMO));
}","{
    // e.g. VCARD_TYPE_V21_JAPANESE_SJIS | FLAG_APPEND_TYPE_PARAMS
    return sJapaneseMobileTypeSet.contains(vcardType);
}",1,"/**
 * @return true if the device is Japanese and some Japanese convension is
 * applied to creating ""formatted"" something like FORMATTED_ADDRESS.
 */
","/**
 * @return true if the device is Japanese and some Japanese convension is
 * applied to creating ""formatted"" something like FORMATTED_ADDRESS.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,4",1,"The return statement is changed from multiple conditions checking to checking whether the vcardType exists in a Set data structure. This modifies the behaviour of the function based on the contents of this set so the change class is 1 (Return statement changed), and 4 (Other statement changed) as the way we identify a Japanese device is changed.","The change of the return statement potentially makes the API return a different value, based on the contents of sJapaneseMobileTypeSet, which may lead to different behaviours compared to the early method version. Therefore, the class of CI is 1 (Compatibility Issue caused by potential different return values or types)."
566,<android.webkit.HTML5VideoViewProxy.VideoPlayer: void onPrepared()>,7,8,<android.webkit.HTML5VideoViewProxy.VideoPlayer: void onPrepared()>,<android.webkit.HTML5VideoViewProxy.VideoPlayer: void onPrepared()>,0,"{
    if (mProgressView == null || mLayout == null) {
        return;
    }
    mProgressView.setVisibility(View.GONE);
    mLayout.removeView(mProgressView);
    mProgressView = null;
}","{
    if (mProgressView == null || mLayout == null) {
        return;
    }
    mTimer.schedule(new TimeupdateTask(mCurrentProxy), TIMEUPDATE_PERIOD, TIMEUPDATE_PERIOD);
    mProgressView.setVisibility(View.GONE);
    mLayout.removeView(mProgressView);
    mProgressView = null;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"3,4",0,"The control dependency has changed as a conditionally executed block has been added inside the 'if' statement. Additionally, a new statement (""mTimer.schedule(new TimeupdateTask(mCurrentProxy), TIMEUPDATE_PERIOD, TIMEUPDATE_PERIOD);"") has been inserted, which cannot be classified as return, exception handling, or dependent API change, so the change type is 3,4.","The new statement added does not affect the return value or exception handling of the method. Even if the 'if' statement's condition is true, the method does not return any value nor throws exceptions both in early and late versions. Hence, no compatibility issue exists in this case."
567,"<android.content.res.AssetManager: XmlBlock openXmlBlockAsset(int,String)>",7,8,"<android.content.res.AssetManager: XmlBlock openXmlBlockAsset(int,String)>","<android.content.res.AssetManager: XmlBlock openXmlBlockAsset(int,String)>",0,"{
    synchronized (this) {
        if (!mOpen) {
            throw new RuntimeException(""Assetmanager has been closed"");
        }
        int xmlBlock = openXmlAssetNative(cookie, fileName);
        if (xmlBlock != 0) {
            mNumRefs++;
            return new XmlBlock(this, xmlBlock);
        }
    }
    throw new FileNotFoundException(""Asset XML file: "" + fileName);
}","{
    synchronized (this) {
        if (!mOpen) {
            throw new RuntimeException(""Assetmanager has been closed"");
        }
        int xmlBlock = openXmlAssetNative(cookie, fileName);
        if (xmlBlock != 0) {
            XmlBlock res = new XmlBlock(this, xmlBlock);
            incRefsLocked(res.hashCode());
            return res;
        }
    }
    throw new FileNotFoundException(""Asset XML file: "" + fileName);
}",1,"/*package*/
","/*package*/
",-1,,,-1,-1,-1,-1,-1,-1,"1,4",1,"The statement 'mNumRefs++' in the early version has been replaced with 'incRefsLocked(res.hashCode())' in the late version, and the way that the 'XmlBlock' object is initialized and returned after creation has changed. So, the code change type is 1 and 4.","Due to the different ways how 'XmlBlock' is returned after creation, the late version of API will potentially return different 'XmlBlock' objects than the early version. Thus, the CI type is 1."
568,<android.webkit.BrowserFrame: String getRawResFilename(int)>,7,8,<android.webkit.BrowserFrame: String getRawResFilename(int)>,<android.webkit.BrowserFrame: String getRawResFilename(int)>,0,"{
    int resid;
    switch(id) {
        case NODOMAIN:
            resid = com.android.internal.R.raw.nodomain;
            break;
        case LOADERROR:
            resid = com.android.internal.R.raw.loaderror;
            break;
        case DRAWABLEDIR:
            // use one known resource to find the drawable directory
            resid = com.android.internal.R.drawable.btn_check_off;
            break;
        default:
            Log.e(LOGTAG, ""getRawResFilename got incompatible resource ID"");
            return """";
    }
    TypedValue value = new TypedValue();
    mContext.getResources().getValue(resid, value, true);
    if (id == DRAWABLEDIR) {
        String path = value.string.toString();
        int index = path.lastIndexOf('/');
        if (index < 0) {
            Log.e(LOGTAG, ""Can't find drawable directory."");
            return """";
        }
        return path.substring(0, index + 1);
    }
    return value.string.toString();
}","{
    int resid;
    switch(id) {
        case NODOMAIN:
            resid = com.android.internal.R.raw.nodomain;
            break;
        case LOADERROR:
            resid = com.android.internal.R.raw.loaderror;
            break;
        case DRAWABLEDIR:
            // use one known resource to find the drawable directory
            resid = com.android.internal.R.drawable.btn_check_off;
            break;
        case FILE_UPLOAD_LABEL:
            return mContext.getResources().getString(com.android.internal.R.string.upload_file);
        case RESET_LABEL:
            return mContext.getResources().getString(com.android.internal.R.string.reset);
        case SUBMIT_LABEL:
            return mContext.getResources().getString(com.android.internal.R.string.submit);
        default:
            Log.e(LOGTAG, ""getRawResFilename got incompatible resource ID"");
            return """";
    }
    TypedValue value = new TypedValue();
    mContext.getResources().getValue(resid, value, true);
    if (id == DRAWABLEDIR) {
        String path = value.string.toString();
        int index = path.lastIndexOf('/');
        if (index < 0) {
            Log.e(LOGTAG, ""Can't find drawable directory."");
            return """";
        }
        return path.substring(0, index + 1);
    }
    return value.string.toString();
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"1,3",1,"New cases (FILE_UPLOAD_LABEL, RESET_LABEL, SUBMIT_LABEL) have been added in the switch-control statement, and for each new case, a new return statement has been introduced. Thus the code change is of type 1(return statement changed) and 3(control dependency changed).","Due to these additions of new return statements, these will potentially make the API return different values for the same set of input parameters, thus giving rise to Compatibility Issue of type 1(CI caused by potential different return values or types)."
569,<android.pim.vcard.VCardParser_V21: boolean readBeginVCard(boolean)>,7,8,<android.pim.vcard.VCardParser_V21: boolean readBeginVCard(boolean)>,<android.pim.vcard.VCardParser_V21: boolean readBeginVCard(boolean)>,0,"{
    String line;
    do {
        while (true) {
            line = getLine();
            if (line == null) {
                return false;
            } else if (line.trim().length() > 0) {
                break;
            }
        }
        String[] strArray = line.split("":"", 2);
        int length = strArray.length;
        // had explicitly allowed ""BEGIN:vCard"" though there's no example).
        if (length == 2 && strArray[0].trim().equalsIgnoreCase(""BEGIN"") && strArray[1].trim().equalsIgnoreCase(""VCARD"")) {
            return true;
        } else if (!allowGarbage) {
            if (mNestCount > 0) {
                mPreviousLine = line;
                return false;
            } else {
                throw new VCardException(""Expected String \""BEGIN:VCARD\"" did not come "" + ""(Instead, \"""" + line + ""\"" came)"");
            }
        }
    } while (allowGarbage);
    throw new VCardException(""Reached where must not be reached."");
}","{
    String line;
    do {
        while (true) {
            line = getLine();
            if (line == null) {
                return false;
            } else if (line.trim().length() > 0) {
                break;
            }
        }
        String[] strArray = line.split("":"", 2);
        int length = strArray.length;
        // e.g. BEGIN:vCard
        if (length == 2 && strArray[0].trim().equalsIgnoreCase(""BEGIN"") && strArray[1].trim().equalsIgnoreCase(""VCARD"")) {
            return true;
        } else if (!allowGarbage) {
            if (mNestCount > 0) {
                mPreviousLine = line;
                return false;
            } else {
                throw new VCardException(""Expected String \""BEGIN:VCARD\"" did not come "" + ""(Instead, \"""" + line + ""\"" came)"");
            }
        }
    } while (allowGarbage);
    throw new VCardException(""Reached where must not be reached."");
}",1,"/**
 * @return True when successful. False when reaching the end of line
 * @throws IOException
 * @throws VCardException
 */
","/**
 * @return True when successful. False when reaching the end of line
 * @throws IOException
 * @throws VCardException
 */
",-1,,,-1,-1,-1,-1,-1,-1,0,0,"The implementation of the API didn't change between the two versions, the only difference being a comment. Therefore, the code change type is 0. ","The behavior of the API remains the same because the changes in this update are only comments which have no impact on the execution. Therefore, no compatibility issue, type 0."
571,<android.appwidget.AppWidgetHostView: void updateAppWidget(RemoteViews)>,7,8,<android.appwidget.AppWidgetHostView: void updateAppWidget(RemoteViews)>,<android.appwidget.AppWidgetHostView: void updateAppWidget(RemoteViews)>,0,"{
    if (LOGD)
        Log.d(TAG, ""updateAppWidget called mOld="" + mOld);
    boolean recycled = false;
    View content = null;
    Exception exception = null;
    // Capture the old view into a bitmap so we can do the crossfade.
    if (CROSSFADE) {
        if (mFadeStartTime < 0) {
            if (mView != null) {
                final int width = mView.getWidth();
                final int height = mView.getHeight();
                try {
                    mOld = Bitmap.createBitmap(width, height, Bitmap.Config.ARGB_8888);
                } catch (OutOfMemoryError e) {
                    // we just won't do the fade
                    mOld = null;
                }
                if (mOld != null) {
                // mView.drawIntoBitmap(mOld);
                }
            }
        }
    }
    if (remoteViews == null) {
        if (mViewMode == VIEW_MODE_DEFAULT) {
            // We've already done this -- nothing to do.
            return;
        }
        content = getDefaultView();
        mLayoutId = -1;
        mViewMode = VIEW_MODE_DEFAULT;
    } else {
        // Prepare a local reference to the remote Context so we're ready to
        // inflate any requested LayoutParams.
        mRemoteContext = getRemoteContext(remoteViews);
        int layoutId = remoteViews.getLayoutId();
        // layout matches, try recycling it
        if (content == null && layoutId == mLayoutId) {
            try {
                remoteViews.reapply(mContext, mView);
                content = mView;
                recycled = true;
                if (LOGD)
                    Log.d(TAG, ""was able to recycled existing layout"");
            } catch (RuntimeException e) {
                exception = e;
            }
        }
        // Try normal RemoteView inflation
        if (content == null) {
            try {
                content = remoteViews.apply(mContext, this);
                if (LOGD)
                    Log.d(TAG, ""had to inflate new layout"");
            } catch (RuntimeException e) {
                exception = e;
            }
        }
        mLayoutId = layoutId;
        mViewMode = VIEW_MODE_CONTENT;
    }
    if (content == null) {
        if (mViewMode == VIEW_MODE_ERROR) {
            // We've already done this -- nothing to do.
            return;
        }
        Log.w(TAG, ""updateAppWidget couldn't find any view, using error view"", exception);
        content = getErrorView();
        mViewMode = VIEW_MODE_ERROR;
    }
    if (!recycled) {
        prepareView(content);
        addView(content);
    }
    if (mView != content) {
        removeView(mView);
        mView = content;
    }
    if (CROSSFADE) {
        if (mFadeStartTime < 0) {
            // if there is already an animation in progress, don't do anything --
            // the new view will pop in on top of the old one during the cross fade,
            // and that looks okay.
            mFadeStartTime = SystemClock.uptimeMillis();
            invalidate();
        }
    }
}","{
    updateAppWidget(remoteViews, 0);
}",1,"/**
 * Process a set of {@link RemoteViews} coming in as an update from the
 * AppWidget provider. Will animate into these new views as needed
 */
","/**
 * Process a set of {@link RemoteViews} coming in as an update from the
 * AppWidget provider. Will animate into these new views as needed
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The entire method implementation has been replaced with a different method called updateAppWidget(remoteViews, 0). Hence, the change_type is classified as 1,5.","Since the new method is entirely different, the returned values or behaviours when calling this method could potentially differ leading to compatibility issues. Hence, the CI_type is classified as 1."
572,<android.webkit.DateSorter: long getBoundary(int)>,7,8,<android.webkit.DateSorter: long getBoundary(int)>,<android.webkit.DateSorter: long getBoundary(int)>,0,"{
    return mBins[index];
}","{
    int lastDay = DAY_COUNT - 1;
    // Error case
    if (index < 0 || index > lastDay)
        index = 0;
    // in the given bin, provide the smallest value
    if (index == lastDay)
        return Long.MIN_VALUE;
    return mBins[index];
}",1,"/**
 * @param index date bin index as returned by getIndex()
 * @return date boundary at given index
 */
","/**
 * @param index date bin index as returned by getIndex()
 * @return date boundary at given index
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3,4",1,"In the new version, additional control statements were added, including conditions and different return values (Long.MIN_VALUE), and also some other new statements were added such as 'int lastDay = DAY_COUNT - 1;', which all contribute to our change types: 1,3,4.","The change in control dependency and additional return statements can cause different return values, which indicates a potential compatibility issue, so the CI type is 1."
573,<android.provider.Telephony.Mms: boolean isPhoneNumber(String)>,7,8,<android.provider.Telephony.Mms: boolean isPhoneNumber(String)>,<android.provider.Telephony.Mms: boolean isPhoneNumber(String)>,0,"{
    if (TextUtils.isEmpty(number)) {
        return false;
    }
    Matcher match = Regex.PHONE_PATTERN.matcher(number);
    return match.matches();
}","{
    if (TextUtils.isEmpty(number)) {
        return false;
    }
    Matcher match = Patterns.PHONE.matcher(number);
    return match.matches();
}",1,"/**
 * Returns true if the number is a Phone number
 *
 * @param number the input number to be tested
 * @return true if number is a Phone number
 */
","/**
 * Returns true if the number is a Phone number
 *
 * @param number the input number to be tested
 * @return true if number is a Phone number
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The return statement and the dependent APIs (Regex.PHONE_PATTERN -> patterns.PHONE) have changed, therefore, the code change type is 1,5.","The dependent API has changed which can potentially lead to different return values, thus the CI is of type 1."
574,"<android.net.SSLCertificateSocketFactory: Socket createSocket(String,int)>",7,8,"<android.net.SSLCertificateSocketFactory: Socket createSocket(String,int)>","<android.net.SSLCertificateSocketFactory: Socket createSocket(String,int)>",0,"{
    SSLSocket sslSock = (SSLSocket) mFactory.createSocket(s, i);
    if (mSocketReadTimeoutForSslHandshake >= 0) {
        sslSock.setSoTimeout(mSocketReadTimeoutForSslHandshake);
    }
    validateSocket(sslSock, s);
    sslSock.setSoTimeout(0);
    return sslSock;
}","{
    OpenSSLSocketImpl s = (OpenSSLSocketImpl) getDelegate().createSocket(host, port);
    s.setHandshakeTimeout(mHandshakeTimeoutMillis);
    return s;
}",1,,,-1,,[@Override],-1,-1,-1,-1,-1,-1,"1,4,5",1,The changes occur in several parts: ,"2) At the part of setting timeout, they change the value and set to different object (`sslSock` for early version and `s` for late version)."
575,<android.webkit.WebViewDatabase: CacheResult getCache(String)>,7,8,<android.webkit.WebViewDatabase: CacheResult getCache(String)>,<android.webkit.WebViewDatabase: CacheResult getCache(String)>,0,"{
    if (url == null || mCacheDatabase == null) {
        return null;
    }
    Cursor cursor = mCacheDatabase.rawQuery(""SELECT filepath, lastmodify, etag, expires, "" + ""expiresstring, mimetype, encoding, httpstatus, location, contentlength, "" + ""contentdisposition FROM cache WHERE url = ?"", new String[] { url });
    try {
        if (cursor.moveToFirst()) {
            CacheResult ret = new CacheResult();
            ret.localPath = cursor.getString(0);
            ret.lastModified = cursor.getString(1);
            ret.etag = cursor.getString(2);
            ret.expires = cursor.getLong(3);
            ret.expiresString = cursor.getString(4);
            ret.mimeType = cursor.getString(5);
            ret.encoding = cursor.getString(6);
            ret.httpStatusCode = cursor.getInt(7);
            ret.location = cursor.getString(8);
            ret.contentLength = cursor.getLong(9);
            ret.contentdisposition = cursor.getString(10);
            return ret;
        }
    } finally {
        if (cursor != null)
            cursor.close();
    }
    return null;
}","{
    if (url == null || mCacheDatabase == null) {
        return null;
    }
    Cursor cursor = null;
    final String query = ""SELECT filepath, lastmodify, etag, expires, "" + ""expiresstring, mimetype, encoding, httpstatus, location, contentlength, "" + ""contentdisposition, crossdomain FROM cache WHERE url = ?"";
    try {
        cursor = mCacheDatabase.rawQuery(query, new String[] { url });
        if (cursor.moveToFirst()) {
            CacheResult ret = new CacheResult();
            ret.localPath = cursor.getString(0);
            ret.lastModified = cursor.getString(1);
            ret.etag = cursor.getString(2);
            ret.expires = cursor.getLong(3);
            ret.expiresString = cursor.getString(4);
            ret.mimeType = cursor.getString(5);
            ret.encoding = cursor.getString(6);
            ret.httpStatusCode = cursor.getInt(7);
            ret.location = cursor.getString(8);
            ret.contentLength = cursor.getLong(9);
            ret.contentdisposition = cursor.getString(10);
            ret.crossDomain = cursor.getString(11);
            return ret;
        }
    } catch (IllegalStateException e) {
        Log.e(LOGTAG, ""getCache"", e);
    } finally {
        if (cursor != null)
            cursor.close();
    }
    return null;
}",1,"/**
 * Get a cache item.
 *
 * @param url The url
 * @return CacheResult The CacheManager.CacheResult
 */
","/**
 * Get a cache item.
 *
 * @param url The url
 * @return CacheResult The CacheManager.CacheResult
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,2,3","1,2","A new field 'crossDomain' is added into 'ret' object in the late version, which could be returned by this method. Also, an exception statement is introduced. And, the way of executing SQL query is changed. Hence, the change type is 1,2,3.","The change of return statement might lead this method return a different type of result, as the field 'crossDomain' is added into the object 'ret'. Also, the introduced exception statement could potentially throw a new exception. So, the CI type is 1,2."
576,"<android.database.sqlite.SQLiteProgram: void bindDouble(int,double)>",7,8,"<android.database.sqlite.SQLiteProgram: void bindDouble(int,double)>","<android.database.sqlite.SQLiteProgram: void bindDouble(int,double)>",0,"{
    acquireReference();
    try {
        native_bind_double(index, value);
    } finally {
        releaseReference();
    }
}","{
    if (!mDatabase.isOpen()) {
        throw new IllegalStateException(""database "" + mDatabase.getPath() + "" already closed"");
    }
    acquireReference();
    try {
        native_bind_double(index, value);
    } finally {
        releaseReference();
    }
}",1,"/**
 * Bind a double value to this statement. The value remains bound until
 * {@link #clearBindings} is called.
 *
 * @param index The 1-based index to the parameter to bind
 * @param value The value to bind
 */
","/**
 * Bind a double value to this statement. The value remains bound until
 * {@link #clearBindings} is called.
 *
 * @param index The 1-based index to the parameter to bind
 * @param value The value to bind
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,3","1,2","In the late version of the implementation, a condition 'if (!mDatabase.isOpen())' is added, consecutively a throw exception statement is also added within this condition. Thus, the change type is 2,3.","As the 'if' condition is added in the late version, the way how variables are assigned can change accordingly. Additionally, the code changes also introduced the possibility of throwing a new exception. Thus the CI type is 1,2."
577,"<android.gesture.GestureStore: void load(InputStream,boolean)>",7,8,"<android.gesture.GestureStore: void load(InputStream,boolean)>","<android.gesture.GestureStore: void load(InputStream,boolean)>",0,"{
    DataInputStream in = null;
    try {
        in = new DataInputStream((stream instanceof BufferedInputStream) ? stream : new BufferedInputStream(stream, GestureConstants.IO_BUFFER_SIZE));
        long start;
        if (PROFILE_LOADING_SAVING) {
            start = SystemClock.elapsedRealtime();
        }
        // Read file format version number
        final short versionNumber = in.readShort();
        switch(versionNumber) {
            case 1:
                readFormatV1(in);
                break;
        }
        if (PROFILE_LOADING_SAVING) {
            long end = SystemClock.elapsedRealtime();
            Log.d(LOG_TAG, ""Loading gestures library = "" + (end - start) + "" ms"");
        }
    } finally {
        if (closeStream)
            GestureUtilities.closeStream(in);
    }
}","{
    DataInputStream in = null;
    try {
        in = new DataInputStream((stream instanceof BufferedInputStream) ? stream : new BufferedInputStream(stream, GestureConstants.IO_BUFFER_SIZE));
        long start;
        if (PROFILE_LOADING_SAVING) {
            start = SystemClock.elapsedRealtime();
        }
        // Read file format version number
        final short versionNumber = in.readShort();
        switch(versionNumber) {
            case 1:
                readFormatV1(in);
                break;
        }
        if (PROFILE_LOADING_SAVING) {
            long end = SystemClock.elapsedRealtime();
            Log.d(LOG_TAG, ""Loading gestures library = "" + (end - start) + "" ms"");
        }
    } finally {
        if (closeStream)
            GestureUtils.closeStream(in);
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,4,0,The utility method GestureUtilities.closeStream(in) in the finally block is changed to the new method GestureUtils.closeStream(in). Hence the code change type is 4.,"The change doesn't cause the API to potentially return a different value nor to throw exception differently. Hence, no compatibility issue exists."
578,<android.database.sqlite.SQLiteCursor: void finalize()>,7,8,<android.database.sqlite.SQLiteCursor: void finalize()>,<android.database.sqlite.SQLiteCursor: void finalize()>,0,"{
    try {
        if (mWindow != null) {
            close();
            String message = ""Finalizing cursor "" + this + "" on "" + mEditTable + "" that has not been deactivated or closed"";
            if (SQLiteDebug.DEBUG_ACTIVE_CURSOR_FINALIZATION) {
                Log.d(TAG, message + ""\nThis cursor was created in:"");
                for (StackTraceElement ste : mStackTraceElements) {
                    Log.d(TAG, ""      "" + ste);
                }
            }
            SQLiteDebug.notifyActiveCursorFinalized();
            throw new IllegalStateException(message);
        } else {
            if (Config.LOGV) {
                Log.v(TAG, ""Finalizing cursor "" + this + "" on "" + mEditTable);
            }
        }
    } finally {
        super.finalize();
    }
}","{
    try {
        // if the cursor hasn't been closed yet, close it first
        if (mWindow != null) {
            int len = mQuery.mSql.length();
            Log.e(TAG, ""Finalizing a Cursor that has not been deactivated or closed. "" + ""database = "" + mDatabase.getPath() + "", table = "" + mEditTable + "", query = "" + mQuery.mSql.substring(0, (len > 100) ? 100 : len), mStackTrace);
            close();
            SQLiteDebug.notifyActiveCursorFinalized();
        } else {
            if (Config.LOGV) {
                Log.v(TAG, ""Finalizing cursor on database = "" + mDatabase.getPath() + "", table = "" + mEditTable + "", query = "" + mQuery.mSql);
            }
        }
    } finally {
        super.finalize();
    }
}",1,"/**
 * Release the native resources, if they haven't been released yet.
 */
","/**
 * Release the native resources, if they haven't been released yet.
 */
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"2,3,4",0,"In the later version, the exception 'IllegalStateException' is removed and the logging statements has changed. Hence, the change type is 2,3,4.","Despite the changes, they do not affect the outcome of the function as they are just logging changes and the removal of an exception that doesn't cause different behaviors of the function. Hence, no Compatbility Issue exists, so the CI type is 0."
580,<android.database.sqlite.SQLiteDatabase: void onCorruption()>,7,8,<android.database.sqlite.SQLiteDatabase: void onCorruption()>,<android.database.sqlite.SQLiteDatabase: void onCorruption()>,0,"{
    try {
        // Close the database (if we can), which will cause subsequent operations to fail.
        close();
    } finally {
        Log.e(TAG, ""Removing corrupt database: "" + mPath);
        EventLog.writeEvent(EVENT_DB_CORRUPT, mPath);
        // Delete the corrupt file.  Don't re-create it now -- that would just confuse people
        // -- but the next time someone tries to open it, they can set it up from scratch.
        new File(mPath).delete();
    }
}","{
    Log.e(TAG, ""Removing corrupt database: "" + mPath);
    EventLog.writeEvent(EVENT_DB_CORRUPT, mPath);
    try {
        // Close the database (if we can), which will cause subsequent operations to fail.
        close();
    } finally {
        // -- but the next time someone tries to open it, they can set it up from scratch.
        if (!mPath.equalsIgnoreCase("":memory"")) {
            // delete is only for non-memory database files
            new File(mPath).delete();
        }
    }
}",1,"/* package */
","/* package */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",0,"There are several changes in the code. Firstly, the try-finally block was moved down and an if-statement checking whether mPath is not equal to "":memory"" was introduced in the finally block before deletion of the file. Also, the logged error and event have been moved to the top of the function before the try-finally block. Thus, the change type is 3 and 4.","Even though there are changes in the control flow, the overall behavior of the method should remain the same. The method is still logging an error, writing to the event log, closing the database, and deleting the file (excluding the "":memory"" case in the late version). Hence, no compatibility issue is found, thus the CI type is 0."
581,"<android.webkit.HTML5VideoViewProxy.VideoPlayer: void play(String,int,HTML5VideoViewProxy,WebChromeClient)>",7,8,"<android.webkit.HTML5VideoViewProxy.VideoPlayer: void play(String,int,HTML5VideoViewProxy,WebChromeClient)>","<android.webkit.HTML5VideoViewProxy.VideoPlayer: void play(String,int,HTML5VideoViewProxy,WebChromeClient)>",0,"{
    if (mCurrentProxy != null) {
        // Some other video is already playing. Notify the caller that its playback ended.
        proxy.playbackEnded();
        return;
    }
    mCurrentProxy = proxy;
    // Create a FrameLayout that will contain the VideoView and the
    // progress view (if any).
    mLayout = new FrameLayout(proxy.getContext());
    FrameLayout.LayoutParams layoutParams = new FrameLayout.LayoutParams(ViewGroup.LayoutParams.WRAP_CONTENT, ViewGroup.LayoutParams.WRAP_CONTENT, Gravity.CENTER);
    mVideoView = new VideoView(proxy.getContext());
    mVideoView.setWillNotDraw(false);
    mVideoView.setMediaController(new MediaController(proxy.getContext()));
    mVideoView.setVideoURI(Uri.parse(url));
    mVideoView.setOnCompletionListener(proxy);
    mVideoView.setOnPreparedListener(proxy);
    mVideoView.setOnErrorListener(proxy);
    mVideoView.seekTo(time);
    mLayout.addView(mVideoView, layoutParams);
    mProgressView = client.getVideoLoadingProgressView();
    if (mProgressView != null) {
        mLayout.addView(mProgressView, layoutParams);
        mProgressView.setVisibility(View.VISIBLE);
    }
    mLayout.setVisibility(View.VISIBLE);
    mVideoView.start();
    client.onShowCustomView(mLayout, mCallback);
}","{
    if (mCurrentProxy == proxy) {
        if (!mVideoView.isPlaying()) {
            mVideoView.start();
        }
        return;
    }
    if (mCurrentProxy != null) {
        // Some other video is already playing. Notify the caller that its playback ended.
        proxy.dispatchOnEnded();
        return;
    }
    mCurrentProxy = proxy;
    // Create a FrameLayout that will contain the VideoView and the
    // progress view (if any).
    mLayout = new FrameLayout(proxy.getContext());
    FrameLayout.LayoutParams layoutParams = new FrameLayout.LayoutParams(ViewGroup.LayoutParams.WRAP_CONTENT, ViewGroup.LayoutParams.WRAP_CONTENT, Gravity.CENTER);
    mVideoView = new VideoView(proxy.getContext());
    mVideoView.setWillNotDraw(false);
    mVideoView.setMediaController(new MediaController(proxy.getContext()));
    String cookieValue = CookieManager.getInstance().getCookie(url);
    Map<String, String> headers = null;
    if (cookieValue != null) {
        headers = new HashMap<String, String>();
        headers.put(COOKIE, cookieValue);
    }
    mVideoView.setVideoURI(Uri.parse(url), headers);
    mVideoView.setOnCompletionListener(proxy);
    mVideoView.setOnPreparedListener(proxy);
    mVideoView.setOnErrorListener(proxy);
    mVideoView.seekTo(time);
    mLayout.addView(mVideoView, layoutParams);
    mProgressView = client.getVideoLoadingProgressView();
    if (mProgressView != null) {
        mLayout.addView(mProgressView, layoutParams);
        mProgressView.setVisibility(View.VISIBLE);
    }
    mLayout.setVisibility(View.VISIBLE);
    mTimer = new Timer();
    mVideoView.start();
    client.onShowCustomView(mLayout, mCallback);
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"3,4,5",0,"The change occurs in multiple sections of the code. A new condition is introduced in the 'if' control conditional statement, i.e., 'if (mCurrentProxy == proxy)', before the original 'if(mCurrentProxy != null)' condition. A CookieManager usage and the subsequent 'if' condition for creating a header for setVideoURI() were introduced, which are fall under the other statement change. Moreover, method name has been changed from 'playbackEnded()' to 'dispatchOnEnded()' and a new additional API, Timer(), is used. Therefore, the implementation comes under the changes 3,4,5.","Despite the changes within the API, it doesnt affect the probable exceptions that the method may throw nor does it modify the result type of the function. Thus, these code changes do not produce a compatibility issue. Therefore, the CI type is 0."
582,<android.app.Dialog: boolean onSearchRequested()>,7,8,<android.app.Dialog: boolean onSearchRequested()>,<android.app.Dialog: boolean onSearchRequested()>,0,"{
    final SearchManager searchManager = (SearchManager) mContext.getSystemService(Context.SEARCH_SERVICE);
    // can't start search without an associated activity (e.g a system dialog)
    if (!searchManager.hasIdent()) {
        return false;
    }
    // associate search with owner activity if possible (otherwise it will default to
    // global search).
    final ComponentName appName = getAssociatedActivity();
    final boolean globalSearch = (appName == null);
    searchManager.startSearch(null, false, appName, null, globalSearch);
    dismiss();
    return true;
}","{
    final SearchManager searchManager = (SearchManager) mContext.getSystemService(Context.SEARCH_SERVICE);
    // associate search with owner activity
    final ComponentName appName = getAssociatedActivity();
    if (appName != null) {
        searchManager.startSearch(null, false, appName, null, false);
        dismiss();
        return true;
    } else {
        return false;
    }
}",1,"/**
 * This hook is called when the user signals the desire to start a search.
 */
","/**
 * This hook is called when the user signals the desire to start a search.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3",1,"The condition of if statement has changed and a new return statement is introduced, so the code change type is 1,3.","The introduction of a new return statement will potentially cause API to return a different value, therefore the CI type is 1."
583,<android.app.ActivityThread.PackageInfo: ClassLoader getClassLoader()>,7,8,<android.app.ActivityThread.PackageInfo: ClassLoader getClassLoader()>,<android.app.ActivityThread.PackageInfo: ClassLoader getClassLoader()>,0,"{
    synchronized (this) {
        if (mClassLoader != null) {
            return mClassLoader;
        }
        if (mIncludeCode && !mPackageName.equals(""android"")) {
            String zip = mAppDir;
            /*
                     * The following is a bit of a hack to inject
                     * instrumentation into the system: If the app
                     * being started matches one of the instrumentation names,
                     * then we combine both the ""instrumentation"" and
                     * ""instrumented"" app into the path, along with the
                     * concatenation of both apps' shared library lists.
                     */
            String instrumentationAppDir = mActivityThread.mInstrumentationAppDir;
            String instrumentationAppPackage = mActivityThread.mInstrumentationAppPackage;
            String instrumentedAppDir = mActivityThread.mInstrumentedAppDir;
            String[] instrumentationLibs = null;
            if (mAppDir.equals(instrumentationAppDir) || mAppDir.equals(instrumentedAppDir)) {
                zip = instrumentationAppDir + "":"" + instrumentedAppDir;
                if (!instrumentedAppDir.equals(instrumentationAppDir)) {
                    instrumentationLibs = getLibrariesFor(instrumentationAppPackage);
                }
            }
            if ((mSharedLibraries != null) || (instrumentationLibs != null)) {
                zip = combineLibs(mSharedLibraries, instrumentationLibs) + ':' + zip;
            }
            if (localLOGV)
                Log.v(TAG, ""Class path: "" + zip);
            mClassLoader = ApplicationLoaders.getDefault().getClassLoader(zip, mDataDir, mBaseClassLoader);
        } else {
            if (mBaseClassLoader == null) {
                mClassLoader = ClassLoader.getSystemClassLoader();
            } else {
                mClassLoader = mBaseClassLoader;
            }
        }
        return mClassLoader;
    }
}","{
    synchronized (this) {
        if (mClassLoader != null) {
            return mClassLoader;
        }
        if (mIncludeCode && !mPackageName.equals(""android"")) {
            String zip = mAppDir;
            /*
                     * The following is a bit of a hack to inject
                     * instrumentation into the system: If the app
                     * being started matches one of the instrumentation names,
                     * then we combine both the ""instrumentation"" and
                     * ""instrumented"" app into the path, along with the
                     * concatenation of both apps' shared library lists.
                     */
            String instrumentationAppDir = mActivityThread.mInstrumentationAppDir;
            String instrumentationAppPackage = mActivityThread.mInstrumentationAppPackage;
            String instrumentedAppDir = mActivityThread.mInstrumentedAppDir;
            String[] instrumentationLibs = null;
            if (mAppDir.equals(instrumentationAppDir) || mAppDir.equals(instrumentedAppDir)) {
                zip = instrumentationAppDir + "":"" + instrumentedAppDir;
                if (!instrumentedAppDir.equals(instrumentationAppDir)) {
                    instrumentationLibs = getLibrariesFor(instrumentationAppPackage);
                }
            }
            if ((mSharedLibraries != null) || (instrumentationLibs != null)) {
                zip = combineLibs(mSharedLibraries, instrumentationLibs) + ':' + zip;
            }
            if (localLOGV)
                Slog.v(TAG, ""Class path: "" + zip);
            mClassLoader = ApplicationLoaders.getDefault().getClassLoader(zip, mDataDir, mBaseClassLoader);
            initializeJavaContextClassLoader();
        } else {
            if (mBaseClassLoader == null) {
                mClassLoader = ClassLoader.getSystemClassLoader();
            } else {
                mClassLoader = mBaseClassLoader;
            }
        }
        return mClassLoader;
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"1,4",1,"A new statement 'initializeJavaContextClassLoader();' is added and a Log.v function has been replaced with Slog.v function, so the code change type is 1,4.","The addition of the 'initializeJavaContextClassLoader();' may change the behaviour of majority part of the method which potentially leads to different return value of 'mClassLoader', so the CI type is 1."
586,<android.webkit.DateSorter: int getIndex(long)>,7,8,<android.webkit.DateSorter: int getIndex(long)>,<android.webkit.DateSorter: int getIndex(long)>,0,"{
    // Lame linear search
    for (int i = 0; i < DAY_COUNT; i++) {
        if (time > mBins[i])
            return i;
    }
    return DAY_COUNT - 1;
}","{
    int lastDay = DAY_COUNT - 1;
    for (int i = 0; i < lastDay; i++) {
        if (time > mBins[i])
            return i;
    }
    return lastDay;
}",1,"/**
 * @param time time since the Epoch in milliseconds, such as that
 * returned by Calendar.getTimeInMillis()
 * @return an index from 0 to (DAY_COUNT - 1) that identifies which
 * date bin this date belongs to
 */
","/**
 * @param time time since the Epoch in milliseconds, such as that
 * returned by Calendar.getTimeInMillis()
 * @return an index from 0 to (DAY_COUNT - 1) that identifies which
 * date bin this date belongs to
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,4",0,"The return statement in the code has been changed. Instead of returning 'DAY_COUNT - 1', it is now returning 'lastDay'. Also an extra variable 'lastDay' has been introduced. Therefore, the changes fall into categories 1 (Return statement changed) and 4 (Other statement changed).","While the return statement and the code structure has been changed, the end result does not modify the behavior of the method. So there is no Compatibility Issue (CI) for this API between the given versions."
587,<android.os.Parcel: Object readValue(ClassLoader)>,7,8,<android.os.Parcel: Object readValue(ClassLoader)>,<android.os.Parcel: Object readValue(ClassLoader)>,0,"{
    int type = readInt();
    switch(type) {
        case VAL_NULL:
            return null;
        case VAL_STRING:
            return readString();
        case VAL_INTEGER:
            return readInt();
        case VAL_MAP:
            return readHashMap(loader);
        case VAL_PARCELABLE:
            return readParcelable(loader);
        case VAL_SHORT:
            return (short) readInt();
        case VAL_LONG:
            return readLong();
        case VAL_FLOAT:
            return readFloat();
        case VAL_DOUBLE:
            return readDouble();
        case VAL_BOOLEAN:
            return readInt() == 1;
        case VAL_CHARSEQUENCE:
            return TextUtils.CHAR_SEQUENCE_CREATOR.createFromParcel(this);
        case VAL_LIST:
            return readArrayList(loader);
        case VAL_BOOLEANARRAY:
            return createBooleanArray();
        case VAL_BYTEARRAY:
            return createByteArray();
        case VAL_STRINGARRAY:
            return readStringArray();
        case VAL_IBINDER:
            return readStrongBinder();
        case VAL_OBJECTARRAY:
            return readArray(loader);
        case VAL_INTARRAY:
            return createIntArray();
        case VAL_LONGARRAY:
            return createLongArray();
        case VAL_BYTE:
            return readByte();
        case VAL_SERIALIZABLE:
            return readSerializable();
        case VAL_PARCELABLEARRAY:
            return readParcelableArray(loader);
        case VAL_SPARSEARRAY:
            return readSparseArray(loader);
        case VAL_SPARSEBOOLEANARRAY:
            return readSparseBooleanArray();
        case VAL_BUNDLE:
            // loading will be deferred
            return readBundle(loader);
        default:
            int off = dataPosition() - 4;
            throw new RuntimeException(""Parcel "" + this + "": Unmarshalling unknown type code "" + type + "" at offset "" + off);
    }
}","{
    int type = readInt();
    switch(type) {
        case VAL_NULL:
            return null;
        case VAL_STRING:
            return readString();
        case VAL_INTEGER:
            return readInt();
        case VAL_MAP:
            return readHashMap(loader);
        case VAL_PARCELABLE:
            return readParcelable(loader);
        case VAL_SHORT:
            return (short) readInt();
        case VAL_LONG:
            return readLong();
        case VAL_FLOAT:
            return readFloat();
        case VAL_DOUBLE:
            return readDouble();
        case VAL_BOOLEAN:
            return readInt() == 1;
        case VAL_CHARSEQUENCE:
            return readCharSequence();
        case VAL_LIST:
            return readArrayList(loader);
        case VAL_BOOLEANARRAY:
            return createBooleanArray();
        case VAL_BYTEARRAY:
            return createByteArray();
        case VAL_STRINGARRAY:
            return readStringArray();
        case VAL_CHARSEQUENCEARRAY:
            return readCharSequenceArray();
        case VAL_IBINDER:
            return readStrongBinder();
        case VAL_OBJECTARRAY:
            return readArray(loader);
        case VAL_INTARRAY:
            return createIntArray();
        case VAL_LONGARRAY:
            return createLongArray();
        case VAL_BYTE:
            return readByte();
        case VAL_SERIALIZABLE:
            return readSerializable();
        case VAL_PARCELABLEARRAY:
            return readParcelableArray(loader);
        case VAL_SPARSEARRAY:
            return readSparseArray(loader);
        case VAL_SPARSEBOOLEANARRAY:
            return readSparseBooleanArray();
        case VAL_BUNDLE:
            // loading will be deferred
            return readBundle(loader);
        default:
            int off = dataPosition() - 4;
            throw new RuntimeException(""Parcel "" + this + "": Unmarshalling unknown type code "" + type + "" at offset "" + off);
    }
}",1,"/**
 * Read a typed object from a parcel.  The given class loader will be
 * used to load any enclosed Parcelables.  If it is null, the default class
 * loader will be used.
 */
","/**
 * Read a typed object from a parcel.  The given class loader will be
 * used to load any enclosed Parcelables.  If it is null, the default class
 * loader will be used.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,The return statements under case VAL_CHARSEQUENCE and case VAL_CHARSEQUENCEARRAY are changed hence the change is classified as types 1 and 5 - Return statement and Dependent API change.,"Change of the return statement will cause the API to potentially return a different value, hence the Compatibility Issue type is 1."
588,<android.content.ContentValues: String getAsString(String)>,7,8,<android.content.ContentValues: String getAsString(String)>,<android.content.ContentValues: String getAsString(String)>,0,"{
    Object value = mValues.get(key);
    return value != null ? mValues.get(key).toString() : null;
}","{
    Object value = mValues.get(key);
    return value != null ? value.toString() : null;
}",1,"/**
 * Gets a value and converts it to a String.
 *
 * @param key the value to get
 * @return the String for the value
 */
","/**
 * Gets a value and converts it to a String.
 *
 * @param key the value to get
 * @return the String for the value
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The method of getting a value in the early version was calling `mValues.get(key).toString()`, but in the later version it was changed to `value.toString()`. It is optimizing the way of getting value and reducing the calling of method `mValues.get(key)`. So, the change type is 4 (Other statement changed).","This change does not alter the original intention of the method nor the possible outputs. It's basically an optimization of the code. Moreover, it doesn't throw different exceptions, hence there would not be a Compatibility Issue (CI) in this case. Therefore, the CI type is 0 (No Compatibility Issue exist)."
589,<android.pim.vcard.VCardParser_V21: boolean isValidPropertyName(String)>,7,8,<android.pim.vcard.VCardParser_V21: boolean isValidPropertyName(String)>,<android.pim.vcard.VCardParser_V21: boolean isValidPropertyName(String)>,0,"{
    if (!(sAvailablePropertyNameSetV21.contains(propertyName.toUpperCase()) || propertyName.startsWith(""X-"")) && !mWarningValueMap.contains(propertyName)) {
        mWarningValueMap.add(propertyName);
        Log.w(LOG_TAG, ""Property name unsupported by vCard 2.1: "" + propertyName);
    }
    return true;
}","{
    if (!(sAvailablePropertyNameSetV21.contains(propertyName.toUpperCase()) || propertyName.startsWith(""X-"")) && !mUnknownTypeMap.contains(propertyName)) {
        mUnknownTypeMap.add(propertyName);
        Log.w(LOG_TAG, ""Property name unsupported by vCard 2.1: "" + propertyName);
    }
    return true;
}",1,"/**
 * @return true when the propertyName is a valid property name.
 */
","/**
 * @return true when the propertyName is a valid property name.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The object name that methods .contains() and .add() call on has changed from 'mWarningValueMap' to 'mUnknownTypeMap', so the code change type is 4.","Although there were some changes in name of objects used in the method, these changes do not impact the return value or the exception handling. Therefore, there's no Compatibility Issue and the CI type is 0."
590,"<android.database.sqlite.SQLiteProgram: void bindLong(int,long)>",7,8,"<android.database.sqlite.SQLiteProgram: void bindLong(int,long)>","<android.database.sqlite.SQLiteProgram: void bindLong(int,long)>",0,"{
    acquireReference();
    try {
        native_bind_long(index, value);
    } finally {
        releaseReference();
    }
}","{
    if (!mDatabase.isOpen()) {
        throw new IllegalStateException(""database "" + mDatabase.getPath() + "" already closed"");
    }
    acquireReference();
    try {
        native_bind_long(index, value);
    } finally {
        releaseReference();
    }
}",1,"/**
 * Bind a long value to this statement. The value remains bound until
 * {@link #clearBindings} is called.
 *
 * @param index The 1-based index to the parameter to bind
 * @param value The value to bind
 */
","/**
 * Bind a long value to this statement. The value remains bound until
 * {@link #clearBindings} is called.
 *
 * @param index The 1-based index to the parameter to bind
 * @param value The value to bind
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,3","1,2","A new exception is thrown when mDatabase is not open. Simultaneously, a logic control flow dependency has been added. Thus, the code change type is 2,3. ","The introduction of a new exception throw may cause an exception to be thrown in the new version where no exception was thrown in the old version. Also, the new control flow means the method could have different execution paths which potentially leads to different return values. So, the Compatibility Issue type is both 1,2."
592,<android.webkit.WebView.PrivateHandler: void handleMessage(Message)>,7,8,<android.webkit.WebView.PrivateHandler: void handleMessage(Message)>,<android.webkit.WebView.PrivateHandler: void handleMessage(Message)>,0,"{
    if (DebugFlags.WEB_VIEW) {
        Log.v(LOGTAG, msg.what < REMEMBER_PASSWORD || msg.what > SHOW_RECT_MSG_ID ? Integer.toString(msg.what) : HandlerDebugString[msg.what - REMEMBER_PASSWORD]);
    }
    if (mWebViewCore == null) {
        // after WebView's destroy() is called, skip handling messages.
        return;
    }
    switch(msg.what) {
        case REMEMBER_PASSWORD:
            {
                mDatabase.setUsernamePassword(msg.getData().getString(""host""), msg.getData().getString(""username""), msg.getData().getString(""password""));
                ((Message) msg.obj).sendToTarget();
                break;
            }
        case NEVER_REMEMBER_PASSWORD:
            {
                mDatabase.setUsernamePassword(msg.getData().getString(""host""), null, null);
                ((Message) msg.obj).sendToTarget();
                break;
            }
        case SWITCH_TO_SHORTPRESS:
            {
                // it won't block panning the page.
                if (mPreventDrag == PREVENT_DRAG_MAYBE_YES) {
                    mPreventDrag = PREVENT_DRAG_NO;
                }
                if (mTouchMode == TOUCH_INIT_MODE) {
                    mTouchMode = TOUCH_SHORTPRESS_START_MODE;
                    updateSelection();
                } else if (mTouchMode == TOUCH_DOUBLE_TAP_MODE) {
                    mTouchMode = TOUCH_DONE_MODE;
                }
                break;
            }
        case SWITCH_TO_LONGPRESS:
            {
                if (mPreventDrag == PREVENT_DRAG_NO) {
                    mTouchMode = TOUCH_DONE_MODE;
                    performLongClick();
                    rebuildWebTextView();
                }
                break;
            }
        case RELEASE_SINGLE_TAP:
            {
                if (mPreventDrag == PREVENT_DRAG_NO) {
                    mTouchMode = TOUCH_DONE_MODE;
                    doShortPress();
                }
                break;
            }
        case SCROLL_BY_MSG_ID:
            setContentScrollBy(msg.arg1, msg.arg2, (Boolean) msg.obj);
            break;
        case SYNC_SCROLL_TO_MSG_ID:
            if (mUserScroll) {
                // if user has scrolled explicitly, don't sync the
                // scroll position any more
                mUserScroll = false;
                break;
            }
        // fall through
        case SCROLL_TO_MSG_ID:
            if (setContentScrollTo(msg.arg1, msg.arg2)) {
                // if we can't scroll to the exact position due to pin,
                // send a message to WebCore to re-scroll when we get a
                // new picture
                mUserScroll = false;
                mWebViewCore.sendMessage(EventHub.SYNC_SCROLL, msg.arg1, msg.arg2);
            }
            break;
        case SPAWN_SCROLL_TO_MSG_ID:
            spawnContentScrollTo(msg.arg1, msg.arg2);
            break;
        case UPDATE_ZOOM_RANGE:
            {
                WebViewCore.RestoreState restoreState = (WebViewCore.RestoreState) msg.obj;
                // mScrollX contains the new minPrefWidth
                updateZoomRange(restoreState, getViewWidth(), restoreState.mScrollX, false);
                break;
            }
        case NEW_PICTURE_MSG_ID:
            {
                WebSettings settings = mWebViewCore.getSettings();
                // called for new content
                final int viewWidth = getViewWidth();
                final WebViewCore.DrawData draw = (WebViewCore.DrawData) msg.obj;
                final Point viewSize = draw.mViewPoint;
                boolean useWideViewport = settings.getUseWideViewPort();
                WebViewCore.RestoreState restoreState = draw.mRestoreState;
                if (restoreState != null) {
                    mInZoomOverview = false;
                    updateZoomRange(restoreState, viewSize.x, draw.mMinPrefWidth, true);
                    if (mInitialScaleInPercent > 0) {
                        setNewZoomScale(mInitialScaleInPercent / 100.0f, mInitialScaleInPercent != mTextWrapScale * 100, false);
                    } else if (restoreState.mViewScale > 0) {
                        mTextWrapScale = restoreState.mTextWrapScale;
                        setNewZoomScale(restoreState.mViewScale, false, false);
                    } else {
                        mInZoomOverview = useWideViewport && settings.getLoadWithOverviewMode();
                        float scale;
                        if (mInZoomOverview) {
                            scale = (float) viewWidth / WebViewCore.DEFAULT_VIEWPORT_WIDTH;
                        } else {
                            scale = restoreState.mTextWrapScale;
                        }
                        setNewZoomScale(scale, Math.abs(scale - mTextWrapScale) >= 0.01f, false);
                    }
                    setContentScrollTo(restoreState.mScrollX, restoreState.mScrollY);
                    // As we are on a new page, remove the WebTextView. This
                    // is necessary for page loads driven by webkit, and in
                    // particular when the user was on a password field, so
                    // the WebTextView was visible.
                    clearTextEntry();
                }
                // We update the layout (i.e. request a layout from the
                // view system) if the last view size that we sent to
                // WebCore matches the view size of the picture we just
                // received in the fixed dimension.
                final boolean updateLayout = viewSize.x == mLastWidthSent && viewSize.y == mLastHeightSent;
                recordNewContentSize(draw.mWidthHeight.x, draw.mWidthHeight.y + (mFindIsUp ? mFindHeight : 0), updateLayout);
                if (DebugFlags.WEB_VIEW) {
                    Rect b = draw.mInvalRegion.getBounds();
                    Log.v(LOGTAG, ""NEW_PICTURE_MSG_ID {"" + b.left + "","" + b.top + "","" + b.right + "","" + b.bottom + ""}"");
                }
                invalidateContentRect(draw.mInvalRegion.getBounds());
                if (mPictureListener != null) {
                    mPictureListener.onNewPicture(WebView.this, capturePicture());
                }
                if (useWideViewport) {
                    mZoomOverviewWidth = Math.max((int) (viewWidth / mDefaultScale), Math.max(draw.mMinPrefWidth, draw.mViewPoint.x));
                }
                if (!mMinZoomScaleFixed) {
                    mMinZoomScale = (float) viewWidth / mZoomOverviewWidth;
                }
                if (!mDrawHistory && mInZoomOverview) {
                    // the rounding error case.
                    if (Math.abs((viewWidth * mInvActualScale) - mZoomOverviewWidth) > 1) {
                        setNewZoomScale((float) viewWidth / mZoomOverviewWidth, Math.abs(mActualScale - mTextWrapScale) < 0.01f, false);
                    }
                }
                break;
            }
        case WEBCORE_INITIALIZED_MSG_ID:
            // nativeCreate sets mNativeClass to a non-zero value
            nativeCreate(msg.arg1);
            break;
        case UPDATE_TEXTFIELD_TEXT_MSG_ID:
            // and representing the same node as the pointer.
            if (inEditingMode() && mWebTextView.isSameTextField(msg.arg1)) {
                if (msg.getData().getBoolean(""password"")) {
                    Spannable text = (Spannable) mWebTextView.getText();
                    int start = Selection.getSelectionStart(text);
                    int end = Selection.getSelectionEnd(text);
                    mWebTextView.setInPassword(true);
                    // Restore the selection, which may have been
                    // ruined by setInPassword.
                    Spannable pword = (Spannable) mWebTextView.getText();
                    Selection.setSelection(pword, start, end);
                // If the text entry has created more events, ignore
                // this one.
                } else if (msg.arg2 == mTextGeneration) {
                    mWebTextView.setTextAndKeepSelection((String) msg.obj);
                }
            }
            break;
        case UPDATE_TEXT_SELECTION_MSG_ID:
            if (inEditingMode() && mWebTextView.isSameTextField(msg.arg1) && msg.arg2 == mTextGeneration) {
                WebViewCore.TextSelectionData tData = (WebViewCore.TextSelectionData) msg.obj;
                mWebTextView.setSelectionFromWebKit(tData.mStart, tData.mEnd);
            }
            break;
        case MOVE_OUT_OF_PLUGIN:
            if (nativePluginEatsNavKey()) {
                navHandledKey(msg.arg1, 1, false, 0, true);
            }
            break;
        case UPDATE_TEXT_ENTRY_MSG_ID:
            // sure the text edit box is still on the  screen.
            if (inEditingMode() && nativeCursorIsTextInput()) {
                mWebTextView.bringIntoView();
                rebuildWebTextView();
            }
            break;
        case CLEAR_TEXT_ENTRY:
            clearTextEntry();
            break;
        case INVAL_RECT_MSG_ID:
            {
                Rect r = (Rect) msg.obj;
                if (r == null) {
                    invalidate();
                } else {
                    // we need to scale r from content into view coords,
                    // which viewInvalidate() does for us
                    viewInvalidate(r.left, r.top, r.right, r.bottom);
                }
                break;
            }
        case REQUEST_FORM_DATA:
            AutoCompleteAdapter adapter = (AutoCompleteAdapter) msg.obj;
            if (mWebTextView.isSameTextField(msg.arg1)) {
                mWebTextView.setAdapterCustom(adapter);
            }
            break;
        case UPDATE_CLIPBOARD:
            String str = (String) msg.obj;
            if (DebugFlags.WEB_VIEW) {
                Log.v(LOGTAG, ""UPDATE_CLIPBOARD "" + str);
            }
            try {
                IClipboard clip = IClipboard.Stub.asInterface(ServiceManager.getService(""clipboard""));
                clip.setClipboardText(str);
            } catch (android.os.RemoteException e) {
                Log.e(LOGTAG, ""Clipboard failed"", e);
            }
            break;
        case RESUME_WEBCORE_UPDATE:
            WebViewCore.resumeUpdate(mWebViewCore);
            break;
        case LONG_PRESS_CENTER:
            // as this is shared by keydown and trackballdown, reset all
            // the states
            mGotCenterDown = false;
            mTrackballDown = false;
            // do nothing.
            if (getParent() != null) {
                performLongClick();
            }
            break;
        case WEBCORE_NEED_TOUCH_EVENTS:
            mForwardTouchEvents = (msg.arg1 != 0);
            break;
        case PREVENT_TOUCH_ID:
            if (msg.arg1 == MotionEvent.ACTION_DOWN) {
                // to time out
                if (mPreventDrag == PREVENT_DRAG_MAYBE_YES) {
                    mPreventDrag = msg.arg2 == 1 ? PREVENT_DRAG_YES : PREVENT_DRAG_NO;
                    if (mPreventDrag == PREVENT_DRAG_YES) {
                        mTouchMode = TOUCH_DONE_MODE;
                    }
                }
            }
            break;
        case REQUEST_KEYBOARD:
            if (msg.arg1 == 0) {
                hideSoftKeyboard();
            } else {
                displaySoftKeyboard(false);
            }
            break;
        case SHOW_RECT_MSG_ID:
            WebViewCore.ShowRectData data = (WebViewCore.ShowRectData) msg.obj;
            int x = mScrollX;
            int left = contentToViewDimension(data.mLeft);
            int width = contentToViewDimension(data.mWidth);
            int maxWidth = contentToViewDimension(data.mContentWidth);
            int viewWidth = getViewWidth();
            if (width < viewWidth) {
                // center align
                x += left + width / 2 - mScrollX - viewWidth / 2;
            } else {
                x += (int) (left + data.mXPercentInDoc * width - mScrollX - data.mXPercentInView * viewWidth);
            }
            // use the passing content width to cap x as the current
            // mContentWidth may not be updated yet
            x = Math.max(0, (Math.min(maxWidth, x + viewWidth)) - viewWidth);
            int y = mScrollY;
            int top = contentToViewDimension(data.mTop);
            int height = contentToViewDimension(data.mHeight);
            int maxHeight = contentToViewDimension(data.mContentHeight);
            int viewHeight = getViewHeight();
            if (height < viewHeight) {
                // middle align
                y += top + height / 2 - mScrollY - viewHeight / 2;
            } else {
                y += (int) (top + data.mYPercentInDoc * height - mScrollY - data.mYPercentInView * viewHeight);
            }
            // use the passing content height to cap y as the current
            // mContentHeight may not be updated yet
            y = Math.max(0, (Math.min(maxHeight, y + viewHeight) - viewHeight));
            scrollTo(x, y);
            break;
        default:
            super.handleMessage(msg);
            break;
    }
}","{
    // exclude INVAL_RECT_MSG_ID since it is frequently output
    if (DebugFlags.WEB_VIEW && msg.what != INVAL_RECT_MSG_ID) {
        if (msg.what >= FIRST_PRIVATE_MSG_ID && msg.what <= LAST_PRIVATE_MSG_ID) {
            Log.v(LOGTAG, HandlerPrivateDebugString[msg.what - FIRST_PRIVATE_MSG_ID]);
        } else if (msg.what >= FIRST_PACKAGE_MSG_ID && msg.what <= LAST_PACKAGE_MSG_ID) {
            Log.v(LOGTAG, HandlerPackageDebugString[msg.what - FIRST_PACKAGE_MSG_ID]);
        } else {
            Log.v(LOGTAG, Integer.toString(msg.what));
        }
    }
    if (mWebViewCore == null) {
        // after WebView's destroy() is called, skip handling messages.
        return;
    }
    switch(msg.what) {
        case REMEMBER_PASSWORD:
            {
                mDatabase.setUsernamePassword(msg.getData().getString(""host""), msg.getData().getString(""username""), msg.getData().getString(""password""));
                ((Message) msg.obj).sendToTarget();
                break;
            }
        case NEVER_REMEMBER_PASSWORD:
            {
                mDatabase.setUsernamePassword(msg.getData().getString(""host""), null, null);
                ((Message) msg.obj).sendToTarget();
                break;
            }
        case PREVENT_DEFAULT_TIMEOUT:
            {
                // to continue handling touch events
                if ((msg.arg1 == MotionEvent.ACTION_DOWN && mPreventDefault == PREVENT_DEFAULT_MAYBE_YES) || (msg.arg1 == MotionEvent.ACTION_MOVE && mPreventDefault == PREVENT_DEFAULT_NO_FROM_TOUCH_DOWN)) {
                    cancelWebCoreTouchEvent(viewToContentX((int) mLastTouchX + mScrollX), viewToContentY((int) mLastTouchY + mScrollY), true);
                }
                break;
            }
        case SWITCH_TO_SHORTPRESS:
            {
                if (mTouchMode == TOUCH_INIT_MODE) {
                    if (mPreventDefault != PREVENT_DEFAULT_YES) {
                        mTouchMode = TOUCH_SHORTPRESS_START_MODE;
                        updateSelection();
                    } else {
                        // set to TOUCH_SHORTPRESS_MODE so that it won't
                        // trigger double tap any more
                        mTouchMode = TOUCH_SHORTPRESS_MODE;
                    }
                } else if (mTouchMode == TOUCH_DOUBLE_TAP_MODE) {
                    mTouchMode = TOUCH_DONE_MODE;
                }
                break;
            }
        case SWITCH_TO_LONGPRESS:
            {
                if (inFullScreenMode() || mDeferTouchProcess) {
                    TouchEventData ted = new TouchEventData();
                    ted.mAction = WebViewCore.ACTION_LONGPRESS;
                    ted.mX = viewToContentX((int) mLastTouchX + mScrollX);
                    ted.mY = viewToContentY((int) mLastTouchY + mScrollY);
                    // metaState for long press is tricky. Should it be the
                    // state when the press started or when the press was
                    // released? Or some intermediary key state? For
                    // simplicity for now, we don't set it.
                    ted.mMetaState = 0;
                    ted.mReprocess = mDeferTouchProcess;
                    if (mDeferTouchProcess) {
                        ted.mViewX = mLastTouchX;
                        ted.mViewY = mLastTouchY;
                    }
                    mWebViewCore.sendMessage(EventHub.TOUCH_EVENT, ted);
                } else if (mPreventDefault != PREVENT_DEFAULT_YES) {
                    mTouchMode = TOUCH_DONE_MODE;
                    performLongClick();
                    rebuildWebTextView();
                }
                break;
            }
        case RELEASE_SINGLE_TAP:
            {
                doShortPress();
                break;
            }
        case SCROLL_BY_MSG_ID:
            setContentScrollBy(msg.arg1, msg.arg2, (Boolean) msg.obj);
            break;
        case SYNC_SCROLL_TO_MSG_ID:
            if (mUserScroll) {
                // if user has scrolled explicitly, don't sync the
                // scroll position any more
                mUserScroll = false;
                break;
            }
        // fall through
        case SCROLL_TO_MSG_ID:
            if (setContentScrollTo(msg.arg1, msg.arg2)) {
                // if we can't scroll to the exact position due to pin,
                // send a message to WebCore to re-scroll when we get a
                // new picture
                mUserScroll = false;
                mWebViewCore.sendMessage(EventHub.SYNC_SCROLL, msg.arg1, msg.arg2);
            }
            break;
        case SPAWN_SCROLL_TO_MSG_ID:
            spawnContentScrollTo(msg.arg1, msg.arg2);
            break;
        case UPDATE_ZOOM_RANGE:
            {
                WebViewCore.RestoreState restoreState = (WebViewCore.RestoreState) msg.obj;
                // mScrollX contains the new minPrefWidth
                updateZoomRange(restoreState, getViewWidth(), restoreState.mScrollX, false);
                break;
            }
        case NEW_PICTURE_MSG_ID:
            {
                // layer, do it now.
                if (mDelayedDeleteRootLayer) {
                    mDelayedDeleteRootLayer = false;
                    nativeSetRootLayer(0);
                }
                WebSettings settings = mWebViewCore.getSettings();
                // called for new content
                final int viewWidth = getViewWidth();
                final WebViewCore.DrawData draw = (WebViewCore.DrawData) msg.obj;
                final Point viewSize = draw.mViewPoint;
                boolean useWideViewport = settings.getUseWideViewPort();
                WebViewCore.RestoreState restoreState = draw.mRestoreState;
                boolean hasRestoreState = restoreState != null;
                if (hasRestoreState) {
                    updateZoomRange(restoreState, viewSize.x, draw.mMinPrefWidth, true);
                    if (!mDrawHistory) {
                        mInZoomOverview = false;
                        if (mInitialScaleInPercent > 0) {
                            setNewZoomScale(mInitialScaleInPercent / 100.0f, mInitialScaleInPercent != mTextWrapScale * 100, false);
                        } else if (restoreState.mViewScale > 0) {
                            mTextWrapScale = restoreState.mTextWrapScale;
                            setNewZoomScale(restoreState.mViewScale, false, false);
                        } else {
                            mInZoomOverview = useWideViewport && settings.getLoadWithOverviewMode();
                            float scale;
                            if (mInZoomOverview) {
                                scale = (float) viewWidth / DEFAULT_VIEWPORT_WIDTH;
                            } else {
                                scale = restoreState.mTextWrapScale;
                            }
                            setNewZoomScale(scale, Math.abs(scale - mTextWrapScale) >= MINIMUM_SCALE_INCREMENT, false);
                        }
                        setContentScrollTo(restoreState.mScrollX, restoreState.mScrollY);
                        // As we are on a new page, remove the WebTextView. This
                        // is necessary for page loads driven by webkit, and in
                        // particular when the user was on a password field, so
                        // the WebTextView was visible.
                        clearTextEntry(false);
                        // update the zoom buttons as the scale can be changed
                        if (getSettings().getBuiltInZoomControls()) {
                            updateZoomButtonsEnabled();
                        }
                    }
                }
                // We update the layout (i.e. request a layout from the
                // view system) if the last view size that we sent to
                // WebCore matches the view size of the picture we just
                // received in the fixed dimension.
                final boolean updateLayout = viewSize.x == mLastWidthSent && viewSize.y == mLastHeightSent;
                recordNewContentSize(draw.mWidthHeight.x, draw.mWidthHeight.y + (mFindIsUp ? mFindHeight : 0), updateLayout);
                if (DebugFlags.WEB_VIEW) {
                    Rect b = draw.mInvalRegion.getBounds();
                    Log.v(LOGTAG, ""NEW_PICTURE_MSG_ID {"" + b.left + "","" + b.top + "","" + b.right + "","" + b.bottom + ""}"");
                }
                invalidateContentRect(draw.mInvalRegion.getBounds());
                if (mPictureListener != null) {
                    mPictureListener.onNewPicture(WebView.this, capturePicture());
                }
                if (useWideViewport) {
                    // limit mZoomOverviewWidth upper bound to
                    // sMaxViewportWidth so that if the page doesn't behave
                    // well, the WebView won't go insane. limit the lower
                    // bound to match the default scale for mobile sites.
                    mZoomOverviewWidth = Math.min(sMaxViewportWidth, Math.max((int) (viewWidth / mDefaultScale), Math.max(draw.mMinPrefWidth, draw.mViewPoint.x)));
                }
                if (!mMinZoomScaleFixed) {
                    mMinZoomScale = (float) viewWidth / mZoomOverviewWidth;
                }
                if (!mDrawHistory && mInZoomOverview) {
                    // the rounding error case.
                    if (Math.abs((viewWidth * mInvActualScale) - mZoomOverviewWidth) > 1) {
                        setNewZoomScale((float) viewWidth / mZoomOverviewWidth, Math.abs(mActualScale - mTextWrapScale) < MINIMUM_SCALE_INCREMENT, false);
                    }
                }
                if (draw.mFocusSizeChanged && inEditingMode()) {
                    mFocusSizeChanged = true;
                }
                if (hasRestoreState) {
                    mViewManager.postReadyToDrawAll();
                }
                break;
            }
        case WEBCORE_INITIALIZED_MSG_ID:
            // nativeCreate sets mNativeClass to a non-zero value
            nativeCreate(msg.arg1);
            break;
        case UPDATE_TEXTFIELD_TEXT_MSG_ID:
            // and representing the same node as the pointer.
            if (inEditingMode() && mWebTextView.isSameTextField(msg.arg1)) {
                if (msg.getData().getBoolean(""password"")) {
                    Spannable text = (Spannable) mWebTextView.getText();
                    int start = Selection.getSelectionStart(text);
                    int end = Selection.getSelectionEnd(text);
                    mWebTextView.setInPassword(true);
                    // Restore the selection, which may have been
                    // ruined by setInPassword.
                    Spannable pword = (Spannable) mWebTextView.getText();
                    Selection.setSelection(pword, start, end);
                // If the text entry has created more events, ignore
                // this one.
                } else if (msg.arg2 == mTextGeneration) {
                    mWebTextView.setTextAndKeepSelection((String) msg.obj);
                }
            }
            break;
        case REQUEST_KEYBOARD_WITH_SELECTION_MSG_ID:
            displaySoftKeyboard(true);
            updateTextSelectionFromMessage(msg.arg1, msg.arg2, (WebViewCore.TextSelectionData) msg.obj);
            break;
        case UPDATE_TEXT_SELECTION_MSG_ID:
            // If no textfield was in focus, and the user touched one,
            // causing it to send this message, then WebTextView has not
            // been set up yet.  Rebuild it so it can set its selection.
            rebuildWebTextView();
            updateTextSelectionFromMessage(msg.arg1, msg.arg2, (WebViewCore.TextSelectionData) msg.obj);
            break;
        case RETURN_LABEL:
            if (inEditingMode() && mWebTextView.isSameTextField(msg.arg1)) {
                mWebTextView.setHint((String) msg.obj);
                InputMethodManager imm = InputMethodManager.peekInstance();
                // active, restart it so that its hint text is updated.
                if (imm != null && imm.isActive(mWebTextView)) {
                    imm.restartInput(mWebTextView);
                }
            }
            break;
        case MOVE_OUT_OF_PLUGIN:
            navHandledKey(msg.arg1, 1, false, 0);
            break;
        case UPDATE_TEXT_ENTRY_MSG_ID:
            // sure the text edit box is still on the  screen.
            if (inEditingMode() && nativeCursorIsTextInput()) {
                mWebTextView.bringIntoView();
                rebuildWebTextView();
            }
            break;
        case CLEAR_TEXT_ENTRY:
            clearTextEntry(false);
            break;
        case INVAL_RECT_MSG_ID:
            {
                Rect r = (Rect) msg.obj;
                if (r == null) {
                    invalidate();
                } else {
                    // we need to scale r from content into view coords,
                    // which viewInvalidate() does for us
                    viewInvalidate(r.left, r.top, r.right, r.bottom);
                }
                break;
            }
        case IMMEDIATE_REPAINT_MSG_ID:
            {
                invalidate();
                break;
            }
        case SET_ROOT_LAYER_MSG_ID:
            {
                if (0 == msg.arg1) {
                    // Null indicates deleting the old layer, but
                    // don't actually do so until we've got the
                    // new page to display.
                    mDelayedDeleteRootLayer = true;
                } else {
                    mDelayedDeleteRootLayer = false;
                    nativeSetRootLayer(msg.arg1);
                    invalidate();
                }
                break;
            }
        case REQUEST_FORM_DATA:
            AutoCompleteAdapter adapter = (AutoCompleteAdapter) msg.obj;
            if (mWebTextView.isSameTextField(msg.arg1)) {
                mWebTextView.setAdapterCustom(adapter);
            }
            break;
        case RESUME_WEBCORE_PRIORITY:
            WebViewCore.resumePriority();
            WebViewCore.resumeUpdatePicture(mWebViewCore);
            break;
        case LONG_PRESS_CENTER:
            // as this is shared by keydown and trackballdown, reset all
            // the states
            mGotCenterDown = false;
            mTrackballDown = false;
            performLongClick();
            break;
        case WEBCORE_NEED_TOUCH_EVENTS:
            mForwardTouchEvents = (msg.arg1 != 0);
            break;
        case PREVENT_TOUCH_ID:
            if (inFullScreenMode()) {
                break;
            }
            if (msg.obj == null) {
                if (msg.arg1 == MotionEvent.ACTION_DOWN && mPreventDefault == PREVENT_DEFAULT_MAYBE_YES) {
                    // if prevent default is called from WebCore, UI
                    // will not handle the rest of the touch events any
                    // more.
                    mPreventDefault = msg.arg2 == 1 ? PREVENT_DEFAULT_YES : PREVENT_DEFAULT_NO_FROM_TOUCH_DOWN;
                } else if (msg.arg1 == MotionEvent.ACTION_MOVE && mPreventDefault == PREVENT_DEFAULT_NO_FROM_TOUCH_DOWN) {
                    // the return for the first ACTION_MOVE will decide
                    // whether UI will handle touch or not. Currently no
                    // support for alternating prevent default
                    mPreventDefault = msg.arg2 == 1 ? PREVENT_DEFAULT_YES : PREVENT_DEFAULT_NO;
                }
            } else if (msg.arg2 == 0) {
                // prevent default is not called in WebCore, so the
                // message needs to be reprocessed in UI
                TouchEventData ted = (TouchEventData) msg.obj;
                switch(ted.mAction) {
                    case MotionEvent.ACTION_DOWN:
                        mLastDeferTouchX = ted.mViewX;
                        mLastDeferTouchY = ted.mViewY;
                        mDeferTouchMode = TOUCH_INIT_MODE;
                        break;
                    case MotionEvent.ACTION_MOVE:
                        {
                            // no snapping in defer process
                            if (mDeferTouchMode != TOUCH_DRAG_MODE) {
                                mDeferTouchMode = TOUCH_DRAG_MODE;
                                mLastDeferTouchX = ted.mViewX;
                                mLastDeferTouchY = ted.mViewY;
                                startDrag();
                            }
                            int deltaX = pinLocX((int) (mScrollX + mLastDeferTouchX - ted.mViewX)) - mScrollX;
                            int deltaY = pinLocY((int) (mScrollY + mLastDeferTouchY - ted.mViewY)) - mScrollY;
                            doDrag(deltaX, deltaY);
                            if (deltaX != 0)
                                mLastDeferTouchX = ted.mViewX;
                            if (deltaY != 0)
                                mLastDeferTouchY = ted.mViewY;
                            break;
                        }
                    case MotionEvent.ACTION_UP:
                    case MotionEvent.ACTION_CANCEL:
                        if (mDeferTouchMode == TOUCH_DRAG_MODE) {
                            // no fling in defer process
                            WebViewCore.resumePriority();
                            WebViewCore.resumeUpdatePicture(mWebViewCore);
                        }
                        mDeferTouchMode = TOUCH_DONE_MODE;
                        break;
                    case WebViewCore.ACTION_DOUBLETAP:
                        // doDoubleTap() needs mLastTouchX/Y as anchor
                        mLastTouchX = ted.mViewX;
                        mLastTouchY = ted.mViewY;
                        doDoubleTap();
                        mDeferTouchMode = TOUCH_DONE_MODE;
                        break;
                    case WebViewCore.ACTION_LONGPRESS:
                        HitTestResult hitTest = getHitTestResult();
                        if (hitTest != null && hitTest.mType != HitTestResult.UNKNOWN_TYPE) {
                            performLongClick();
                            rebuildWebTextView();
                        }
                        mDeferTouchMode = TOUCH_DONE_MODE;
                        break;
                }
            }
            break;
        case REQUEST_KEYBOARD:
            if (msg.arg1 == 0) {
                hideSoftKeyboard();
            } else {
                displaySoftKeyboard(false);
            }
            break;
        case FIND_AGAIN:
            // Ignore if find has been dismissed.
            if (mFindIsUp) {
                findAll(mLastFind);
            }
            break;
        case DRAG_HELD_MOTIONLESS:
            mHeldMotionless = MOTIONLESS_TRUE;
            invalidate();
        case AWAKEN_SCROLL_BARS:
            if (mTouchMode == TOUCH_DRAG_MODE && mHeldMotionless == MOTIONLESS_TRUE) {
                awakenScrollBars(ViewConfiguration.getScrollDefaultDelay(), false);
                mPrivateHandler.sendMessageDelayed(mPrivateHandler.obtainMessage(AWAKEN_SCROLL_BARS), ViewConfiguration.getScrollDefaultDelay());
            }
            break;
        case DO_MOTION_UP:
            doMotionUp(msg.arg1, msg.arg2);
            break;
        case SHOW_FULLSCREEN:
            {
                View view = (View) msg.obj;
                int npp = msg.arg1;
                if (mFullScreenHolder != null) {
                    Log.w(LOGTAG, ""Should not have another full screen."");
                    mFullScreenHolder.dismiss();
                }
                mFullScreenHolder = new PluginFullScreenHolder(WebView.this, npp);
                mFullScreenHolder.setContentView(view);
                mFullScreenHolder.setCancelable(false);
                mFullScreenHolder.setCanceledOnTouchOutside(false);
                mFullScreenHolder.show();
                break;
            }
        case HIDE_FULLSCREEN:
            if (inFullScreenMode()) {
                mFullScreenHolder.dismiss();
                mFullScreenHolder = null;
            }
            break;
        case DOM_FOCUS_CHANGED:
            if (inEditingMode()) {
                nativeClearCursor();
                rebuildWebTextView();
            }
            break;
        case SHOW_RECT_MSG_ID:
            {
                WebViewCore.ShowRectData data = (WebViewCore.ShowRectData) msg.obj;
                int x = mScrollX;
                int left = contentToViewX(data.mLeft);
                int width = contentToViewDimension(data.mWidth);
                int maxWidth = contentToViewDimension(data.mContentWidth);
                int viewWidth = getViewWidth();
                if (width < viewWidth) {
                    // center align
                    x += left + width / 2 - mScrollX - viewWidth / 2;
                } else {
                    x += (int) (left + data.mXPercentInDoc * width - mScrollX - data.mXPercentInView * viewWidth);
                }
                if (DebugFlags.WEB_VIEW) {
                    Log.v(LOGTAG, ""showRectMsg=(left="" + left + "",width="" + width + "",maxWidth="" + maxWidth + "",viewWidth="" + viewWidth + "",x="" + x + "",xPercentInDoc="" + data.mXPercentInDoc + "",xPercentInView="" + data.mXPercentInView + "")"");
                }
                // use the passing content width to cap x as the current
                // mContentWidth may not be updated yet
                x = Math.max(0, (Math.min(maxWidth, x + viewWidth)) - viewWidth);
                int top = contentToViewY(data.mTop);
                int height = contentToViewDimension(data.mHeight);
                int maxHeight = contentToViewDimension(data.mContentHeight);
                int viewHeight = getViewHeight();
                int y = (int) (top + data.mYPercentInDoc * height - data.mYPercentInView * viewHeight);
                if (DebugFlags.WEB_VIEW) {
                    Log.v(LOGTAG, ""showRectMsg=(top="" + top + "",height="" + height + "",maxHeight="" + maxHeight + "",viewHeight="" + viewHeight + "",y="" + y + "",yPercentInDoc="" + data.mYPercentInDoc + "",yPercentInView="" + data.mYPercentInView + "")"");
                }
                // use the passing content height to cap y as the current
                // mContentHeight may not be updated yet
                y = Math.max(0, (Math.min(maxHeight, y + viewHeight) - viewHeight));
                // We need to take into account the visible title height
                // when scrolling since y is an absolute view position.
                y = Math.max(0, y - getVisibleTitleHeight());
                scrollTo(x, y);
            }
            break;
        case CENTER_FIT_RECT:
            Rect r = (Rect) msg.obj;
            mInZoomOverview = false;
            centerFitRect(r.left, r.top, r.width(), r.height());
            break;
        case SET_SCROLLBAR_MODES:
            mHorizontalScrollBarMode = msg.arg1;
            mVerticalScrollBarMode = msg.arg2;
            break;
        default:
            super.handleMessage(msg);
            break;
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,,,,
593,<android.text.Layout: int getParagraphLeft(int)>,7,8,<android.text.Layout: int getParagraphLeft(int)>,<android.text.Layout: int getParagraphLeft(int)>,0,"{
    int dir = getParagraphDirection(line);
    int left = 0;
    boolean par = false;
    int off = getLineStart(line);
    if (off == 0 || mText.charAt(off - 1) == '\n')
        par = true;
    if (dir == DIR_LEFT_TO_RIGHT) {
        if (mSpannedText) {
            Spanned sp = (Spanned) mText;
            LeadingMarginSpan[] spans = sp.getSpans(getLineStart(line), getLineEnd(line), LeadingMarginSpan.class);
            for (int i = 0; i < spans.length; i++) {
                left += spans[i].getLeadingMargin(par);
            }
        }
    }
    return left;
}","{
    int dir = getParagraphDirection(line);
    int left = 0;
    boolean par = false;
    int off = getLineStart(line);
    if (off == 0 || mText.charAt(off - 1) == '\n')
        par = true;
    if (dir == DIR_LEFT_TO_RIGHT) {
        if (mSpannedText) {
            Spanned sp = (Spanned) mText;
            LeadingMarginSpan[] spans = sp.getSpans(getLineStart(line), getLineEnd(line), LeadingMarginSpan.class);
            for (int i = 0; i < spans.length; i++) {
                boolean margin = par;
                LeadingMarginSpan span = spans[i];
                if (span instanceof LeadingMarginSpan.LeadingMarginSpan2) {
                    int count = ((LeadingMarginSpan.LeadingMarginSpan2) span).getLeadingMarginLineCount();
                    margin = count >= line;
                }
                left += span.getLeadingMargin(margin);
            }
        }
    }
    return left;
}",1,"/**
 * Get the left edge of the specified paragraph, inset by left margins.
 */
","/**
 * Get the left edge of the specified paragraph, inset by left margins.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,1,New algorithm implementation has been added in the for loop. This contributes to "Other statement changed" as the code change type is 4.,"Due to the addition of new algorithm implementation within the for loop, the final computed 'left' variable may produce a different outcome. As the return statement depends on this value, the late version implementation could potentially return a different result. Thus, the CI type is 1."
594,<android.database.sqlite.SQLiteDatabase: void endTransaction()>,7,8,<android.database.sqlite.SQLiteDatabase: void endTransaction()>,<android.database.sqlite.SQLiteDatabase: void endTransaction()>,0,"{
    if (!mLock.isHeldByCurrentThread()) {
        throw new IllegalStateException(""no transaction pending"");
    }
    try {
        if (mInnerTransactionIsSuccessful) {
            mInnerTransactionIsSuccessful = false;
        } else {
            mTransactionIsSuccessful = false;
        }
        if (mLock.getHoldCount() != 1) {
            return;
        }
        RuntimeException savedException = null;
        if (mTransactionListener != null) {
            try {
                if (mTransactionIsSuccessful) {
                    mTransactionListener.onCommit();
                } else {
                    mTransactionListener.onRollback();
                }
            } catch (RuntimeException e) {
                savedException = e;
                mTransactionIsSuccessful = false;
            }
        }
        if (mTransactionIsSuccessful) {
            execSQL(""COMMIT;"");
        } else {
            try {
                execSQL(""ROLLBACK;"");
                if (savedException != null) {
                    throw savedException;
                }
            } catch (SQLException e) {
                if (Config.LOGD) {
                    Log.d(TAG, ""exception during rollback, maybe the DB previously "" + ""performed an auto-rollback"");
                }
            }
        }
    } finally {
        mTransactionListener = null;
        unlockForced();
        if (Config.LOGV) {
            Log.v(TAG, ""unlocked "" + Thread.currentThread() + "", holdCount is "" + mLock.getHoldCount());
        }
    }
}","{
    if (!isOpen()) {
        throw new IllegalStateException(""database not open"");
    }
    if (!mLock.isHeldByCurrentThread()) {
        throw new IllegalStateException(""no transaction pending"");
    }
    try {
        if (mInnerTransactionIsSuccessful) {
            mInnerTransactionIsSuccessful = false;
        } else {
            mTransactionIsSuccessful = false;
        }
        if (mLock.getHoldCount() != 1) {
            return;
        }
        RuntimeException savedException = null;
        if (mTransactionListener != null) {
            try {
                if (mTransactionIsSuccessful) {
                    mTransactionListener.onCommit();
                } else {
                    mTransactionListener.onRollback();
                }
            } catch (RuntimeException e) {
                savedException = e;
                mTransactionIsSuccessful = false;
            }
        }
        if (mTransactionIsSuccessful) {
            execSQL(COMMIT_SQL);
        } else {
            try {
                execSQL(""ROLLBACK;"");
                if (savedException != null) {
                    throw savedException;
                }
            } catch (SQLException e) {
                if (Config.LOGD) {
                    Log.d(TAG, ""exception during rollback, maybe the DB previously "" + ""performed an auto-rollback"");
                }
            }
        }
    } finally {
        mTransactionListener = null;
        unlockForced();
        if (Config.LOGV) {
            Log.v(TAG, ""unlocked "" + Thread.currentThread() + "", holdCount is "" + mLock.getHoldCount());
        }
    }
}",1,"/**
 * End a transaction. See beginTransaction for notes about how to use this and when transactions
 * are committed and rolled back.
 */
","/**
 * End a transaction. See beginTransaction for notes about how to use this and when transactions
 * are committed and rolled back.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,3,4,5","1,2","There is a newly added Exception handling statement at the start of the method that checks if the database is open. There is also a change in control dependency due to this new exception handling statement. There is a change in another statement where 'execSQL(""COMMIT;"");' is replaced by 'execSQL(COMMIT_SQL);'. Also, the dependent API execSQL apparently changes its parameters, which should be classified as type 5.","The new exception handling statement might cause a different behavior as it throws a new exception ('database not open') which wasn't thrown before in the early version, which is type 2 of CI. Also, the change in the commit() method can lead to different return values, which is type 1 of CI."
595,<android.pim.vcard.VCardUtils: boolean containsOnlyNonCrLfPrintableAscii(String)>,7,8,<android.pim.vcard.VCardUtils: boolean containsOnlyNonCrLfPrintableAscii(String)>,<android.pim.vcard.VCardUtils: boolean containsOnlyNonCrLfPrintableAscii(String)>,0,"{
    if (TextUtils.isEmpty(str)) {
        return true;
    }
    final int length = str.length();
    final int asciiFirst = 0x20;
    final int asciiLast = 0x126;
    for (int i = 0; i < length; i = str.offsetByCodePoints(i, 1)) {
        int c = str.codePointAt(i);
        if (c < asciiFirst || asciiLast < c || c == '\n' || c == '\r') {
            return false;
        }
    }
    return true;
}","{
    if (values == null) {
        return true;
    }
    return containsOnlyNonCrLfPrintableAscii(Arrays.asList(values));
}",1,"/**
 * This is useful when checking the string should be encoded into quoted-printable
 * or not, which is required by vCard 2.1.
 * See the definition of ""7bit"" in vCard 2.1 spec for more information.
 */
","/**
 * This is useful when checking the string should be encoded into quoted-printable
 * or not, which is required by vCard 2.1.
 * See the definition of ""7bit"" in vCard 2.1 spec for more information.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,4",1,"The function has undergone several statement changes. Instead of checking a String input, it now checks whether an array named ""values"" is null and then immediately calls another function. This change can be classified as type 1 and 4)","Due to the major overhaul of the function, it is very likely that the return values will be different between the two versions of the API. The function used to return a Boolean based on whether a String contains all printable ASCII characters. Now, the function directly calls another function if ""values"" is not null. Thus, the Compatibility Issue type is 1, caused by potentially different return values."
599,"<android.accounts.AccountManager: AccountManagerFuture<Bundle> getAuthToken(Account,String,Bundle,Activity,AccountManagerCallback<Bundle>,Handler)>",7,8,"<android.accounts.AccountManager: AccountManagerFuture<Bundle> getAuthToken(Account,String,Bundle,Activity,AccountManagerCallback<Bundle>,Handler)>","<android.accounts.AccountManager: AccountManagerFuture<Bundle> getAuthToken(Account,String,Bundle,Activity,AccountManagerCallback<Bundle>,Handler)>",0,"{
    if (activity == null)
        throw new IllegalArgumentException(""activity is null"");
    if (authTokenType == null)
        throw new IllegalArgumentException(""authTokenType is null"");
    return new AmsTask(activity, handler, callback) {

        public void doWork() throws RemoteException {
            mService.getAuthToken(mResponse, account, authTokenType, false, /* notifyOnAuthFailure */
            true, /* expectActivityLaunch */
            options);
        }
    }.start();
}","{
    if (account == null)
        throw new IllegalArgumentException(""account is null"");
    if (authTokenType == null)
        throw new IllegalArgumentException(""authTokenType is null"");
    return new AmsTask(activity, handler, callback) {

        public void doWork() throws RemoteException {
            mService.getAuthToken(mResponse, account, authTokenType, false, /* notifyOnAuthFailure */
            true, /* expectActivityLaunch */
            options);
        }
    }.start();
}",1,"/**
 * Request that an authtoken of the specified type be returned for an account.
 * If the Account Manager has a cached authtoken of the requested type then it will
 * service the request itself. Otherwise it will pass the request on to the authenticator.
 * The authenticator can try to service this request with information it already has stored
 * in the AccountManager but may need to launch an activity to prompt the
 * user to enter credentials. If it is able to retrieve the authtoken it will be returned
 * in the result.
 * <p>
 * If the authenticator needs to prompt the user for credentials it will return an intent to
 * the activity that will do the prompting. If an activity is supplied then that activity
 * will be used to launch the intent and the result will come from it. Otherwise a result will
 * be returned that contains the intent.
 * <p>
 * This call returns immediately but runs asynchronously and the result is accessed via the
 * {@link AccountManagerFuture} that is returned. This future is also passed as the sole
 * parameter to the {@link AccountManagerCallback}. If the caller wished to use this
 * method asynchronously then they will generally pass in a callback object that will get
 * invoked with the {@link AccountManagerFuture}. If they wish to use it synchronously then
 * they will generally pass null for the callback and instead call
 * {@link android.accounts.AccountManagerFuture#getResult()} on this method's return value,
 * which will then block until the request completes.
 * <p>
 * Requires that the caller has permission {@link android.Manifest.permission#USE_CREDENTIALS}.
 *
 * @param account The account whose credentials are to be updated.
 * @param authTokenType the auth token to retrieve as part of updating the credentials.
 * May be null.
 * @param options authenticator specific options for the request
 * @param activity If the authenticator returns a {@link #KEY_INTENT} in the result then
 * the intent will be started with this activity. If activity is null then the result will
 * be returned as-is.
 * @param callback A callback to invoke when the request completes. If null then
 * no callback is invoked.
 * @param handler The {@link Handler} to use to invoke the callback. If null then the
 * main thread's {@link Handler} is used.
 * @return an {@link AccountManagerFuture} that represents the future result of the call.
 * The future result is a {@link Bundle} that contains:
 * <ul>
 * <li> {@link #KEY_ACCOUNT_NAME}, {@link #KEY_ACCOUNT_TYPE} and {@link #KEY_AUTHTOKEN}
 * </ul>
 * If the user presses ""back"" then the request will be canceled.
 */
","/**
 * Gets an auth token of the specified type for a particular account,
 * prompting the user for credentials if necessary.  This method is
 * intended for applications running in the foreground where it makes
 * sense to ask the user directly for a password.
 *
 * <p>If a previously generated auth token is cached for this account and
 * type, then it will be returned.  Otherwise, if we have a saved password
 * the server accepts, it will be used to generate a new auth token.
 * Otherwise, the user will be asked for a password, which will be sent to
 * the server to generate a new auth token.
 *
 * <p>The value of the auth token type depends on the authenticator.
 * Some services use different tokens to access different functionality --
 * for example, Google uses different auth tokens to access Gmail and
 * Google Calendar for the same account.
 *
 * <p>This method may be called from any thread, but the returned
 * {@link AccountManagerFuture} must not be used on the main thread.
 *
 * <p>This method requires the caller to hold the permission
 * {@link android.Manifest.permission#USE_CREDENTIALS}.
 *
 * @param account The account to fetch an auth token for
 * @param authTokenType The auth token type, an authenticator-dependent
 * string token, must not be null
 * @param options Authenticator-specific options for the request,
 * may be null or empty
 * @param activity The {@link Activity} context to use for launching a new
 * authenticator-defined sub-Activity to prompt the user for a password
 * if necessary; used only to call startActivity(); must not be null.
 * @param callback Callback to invoke when the request completes,
 * null for no callback
 * @param handler {@link Handler} identifying the callback thread,
 * null for the main thread
 * @return An {@link AccountManagerFuture} which resolves to a Bundle with
 * at least the following fields:
 * <ul>
 * <li> {@link #KEY_ACCOUNT_NAME} - the name of the account you supplied
 * <li> {@link #KEY_ACCOUNT_TYPE} - the type of the account
 * <li> {@link #KEY_AUTHTOKEN} - the auth token you wanted
 * </ul>
 *
 * (Other authenticator-specific values may be returned.)  If an auth token
 * could not be fetched, {@link AccountManagerFuture#getResult()} throws:
 * <ul>
 * <li> {@link AuthenticatorException} if the authenticator failed to respond
 * <li> {@link OperationCanceledException} if the operation is canceled for
 * any reason, incluidng the user canceling a credential request
 * <li> {@link IOException} if the authenticator experienced an I/O problem
 * creating a new auth token, usually because of network trouble
 * </ul>
 */
",-1,,,-1,-1,-1,-1,-1,-1,2,2,"In the early implementation version, the first `throw` statement tests for nullity on activity. This condition has changed in the late implementation to a check if account is null, leading to throwing a different exception, so the change type is 2.","The change in the exception handling can lead to potentially different exceptions being thrown, which would affect the behaviour of the API. Hence, the Compatibility Issue type is 2."
600,<android.view.ViewStub: void setVisibility(int)>,7,8,<android.view.ViewStub: void setVisibility(int)>,<android.view.ViewStub: void setVisibility(int)>,0,"{
    if (mInflatedViewRef != null) {
        View view = mInflatedViewRef.get();
        if (view != null) {
            view.setVisibility(visibility);
        } else {
            throw new IllegalStateException(""setVisibility called on un-referenced view"");
        }
    } else if (visibility == VISIBLE || visibility == INVISIBLE) {
        super.setVisibility(visibility);
        inflate();
    }
}","{
    if (mInflatedViewRef != null) {
        View view = mInflatedViewRef.get();
        if (view != null) {
            view.setVisibility(visibility);
        } else {
            throw new IllegalStateException(""setVisibility called on un-referenced view"");
        }
    } else {
        super.setVisibility(visibility);
        if (visibility == VISIBLE || visibility == INVISIBLE) {
            inflate();
        }
    }
}",1,"/**
 * When visibility is set to {@link #VISIBLE} or {@link #INVISIBLE},
 * {@link #inflate()} is invoked and this StubbedView is replaced in its parent
 * by the inflated layout resource.
 *
 * @param visibility One of {@link #VISIBLE}, {@link #INVISIBLE}, or {@link #GONE}.
 *
 * @see #inflate()
 */
","/**
 * When visibility is set to {@link #VISIBLE} or {@link #INVISIBLE},
 * {@link #inflate()} is invoked and this StubbedView is replaced in its parent
 * by the inflated layout resource.
 *
 * @param visibility One of {@link #VISIBLE}, {@link #INVISIBLE}, or {@link #GONE}.
 *
 * @see #inflate()
 */
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,3,1,"The change is in the control dependency where the 'if' condition (visibility == VISIBLE || visibility == INVISIBLE) is moved inside the 'else' clause. Therefore, the code change type is 3.","The change in the control flow could potentially lead to a different behaviour when ""setVisibility"" is called with a visibility value other than VISIBLE or INVISIBLE. Previously, it would always cause ""inflate()"" method to be called, whereas in the late version, ""inflate()"" isn't called unless visibility is VISIBLE or INVISIBLE. Therefore, the return action of this method could be different in this situation and hence, the CI type is 1."
601,"<android.view.View: void setFlags(int,int)>",7,8,"<android.view.View: void setFlags(int,int)>","<android.view.View: void setFlags(int,int)>",0,"{
    int old = mViewFlags;
    mViewFlags = (mViewFlags & ~mask) | (flags & mask);
    int changed = mViewFlags ^ old;
    if (changed == 0) {
        return;
    }
    int privateFlags = mPrivateFlags;
    /* Check if the FOCUSABLE bit has changed */
    if (((changed & FOCUSABLE_MASK) != 0) && ((privateFlags & HAS_BOUNDS) != 0)) {
        if (((old & FOCUSABLE_MASK) == FOCUSABLE) && ((privateFlags & FOCUSED) != 0)) {
            /* Give up focus if we are no longer focusable */
            clearFocus();
        } else if (((old & FOCUSABLE_MASK) == NOT_FOCUSABLE) && ((privateFlags & FOCUSED) == 0)) {
            /*
                 * Tell the view system that we are now available to take focus
                 * if no one else already has it.
                 */
            if (mParent != null)
                mParent.focusableViewAvailable(this);
        }
    }
    if ((flags & VISIBILITY_MASK) == VISIBLE) {
        if ((changed & VISIBILITY_MASK) != 0) {
            /*
                 * If this view is becoming visible, set the DRAWN flag so that
                 * the next invalidate() will not be skipped.
                 */
            mPrivateFlags |= DRAWN;
            needGlobalAttributesUpdate(true);
            // the root view try to give this focus if nothing else does.
            if ((mParent != null) && (mBottom > mTop) && (mRight > mLeft)) {
                mParent.focusableViewAvailable(this);
            }
        }
    }
    /* Check if the GONE bit has changed */
    if ((changed & GONE) != 0) {
        needGlobalAttributesUpdate(false);
        requestLayout();
        invalidate();
        if (((mViewFlags & VISIBILITY_MASK) == GONE)) {
            if (hasFocus())
                clearFocus();
            destroyDrawingCache();
        }
        if (mAttachInfo != null) {
            mAttachInfo.mViewVisibilityChanged = true;
        }
    }
    /* Check if the VISIBLE bit has changed */
    if ((changed & INVISIBLE) != 0) {
        needGlobalAttributesUpdate(false);
        invalidate();
        if (((mViewFlags & VISIBILITY_MASK) == INVISIBLE) && hasFocus()) {
            // root view becoming invisible shouldn't clear focus
            if (getRootView() != this) {
                clearFocus();
            }
        }
        if (mAttachInfo != null) {
            mAttachInfo.mViewVisibilityChanged = true;
        }
    }
    if ((changed & WILL_NOT_CACHE_DRAWING) != 0) {
        destroyDrawingCache();
    }
    if ((changed & DRAWING_CACHE_ENABLED) != 0) {
        destroyDrawingCache();
        mPrivateFlags &= ~DRAWING_CACHE_VALID;
    }
    if ((changed & DRAWING_CACHE_QUALITY_MASK) != 0) {
        destroyDrawingCache();
        mPrivateFlags &= ~DRAWING_CACHE_VALID;
    }
    if ((changed & DRAW_MASK) != 0) {
        if ((mViewFlags & WILL_NOT_DRAW) != 0) {
            if (mBGDrawable != null) {
                mPrivateFlags &= ~SKIP_DRAW;
                mPrivateFlags |= ONLY_DRAWS_BACKGROUND;
            } else {
                mPrivateFlags |= SKIP_DRAW;
            }
        } else {
            mPrivateFlags &= ~SKIP_DRAW;
        }
        requestLayout();
        invalidate();
    }
    if ((changed & KEEP_SCREEN_ON) != 0) {
        if (mParent != null) {
            mParent.recomputeViewAttributes(this);
        }
    }
}","{
    int old = mViewFlags;
    mViewFlags = (mViewFlags & ~mask) | (flags & mask);
    int changed = mViewFlags ^ old;
    if (changed == 0) {
        return;
    }
    int privateFlags = mPrivateFlags;
    /* Check if the FOCUSABLE bit has changed */
    if (((changed & FOCUSABLE_MASK) != 0) && ((privateFlags & HAS_BOUNDS) != 0)) {
        if (((old & FOCUSABLE_MASK) == FOCUSABLE) && ((privateFlags & FOCUSED) != 0)) {
            /* Give up focus if we are no longer focusable */
            clearFocus();
        } else if (((old & FOCUSABLE_MASK) == NOT_FOCUSABLE) && ((privateFlags & FOCUSED) == 0)) {
            /*
                 * Tell the view system that we are now available to take focus
                 * if no one else already has it.
                 */
            if (mParent != null)
                mParent.focusableViewAvailable(this);
        }
    }
    if ((flags & VISIBILITY_MASK) == VISIBLE) {
        if ((changed & VISIBILITY_MASK) != 0) {
            /*
                 * If this view is becoming visible, set the DRAWN flag so that
                 * the next invalidate() will not be skipped.
                 */
            mPrivateFlags |= DRAWN;
            needGlobalAttributesUpdate(true);
            // the root view try to give this focus if nothing else does.
            if ((mParent != null) && (mBottom > mTop) && (mRight > mLeft)) {
                mParent.focusableViewAvailable(this);
            }
        }
    }
    /* Check if the GONE bit has changed */
    if ((changed & GONE) != 0) {
        needGlobalAttributesUpdate(false);
        requestLayout();
        invalidate();
        if (((mViewFlags & VISIBILITY_MASK) == GONE)) {
            if (hasFocus())
                clearFocus();
            destroyDrawingCache();
        }
        if (mAttachInfo != null) {
            mAttachInfo.mViewVisibilityChanged = true;
        }
    }
    /* Check if the VISIBLE bit has changed */
    if ((changed & INVISIBLE) != 0) {
        needGlobalAttributesUpdate(false);
        invalidate();
        if (((mViewFlags & VISIBILITY_MASK) == INVISIBLE) && hasFocus()) {
            // root view becoming invisible shouldn't clear focus
            if (getRootView() != this) {
                clearFocus();
            }
        }
        if (mAttachInfo != null) {
            mAttachInfo.mViewVisibilityChanged = true;
        }
    }
    if ((changed & VISIBILITY_MASK) != 0) {
        dispatchVisibilityChanged(this, (flags & VISIBILITY_MASK));
    }
    if ((changed & WILL_NOT_CACHE_DRAWING) != 0) {
        destroyDrawingCache();
    }
    if ((changed & DRAWING_CACHE_ENABLED) != 0) {
        destroyDrawingCache();
        mPrivateFlags &= ~DRAWING_CACHE_VALID;
    }
    if ((changed & DRAWING_CACHE_QUALITY_MASK) != 0) {
        destroyDrawingCache();
        mPrivateFlags &= ~DRAWING_CACHE_VALID;
    }
    if ((changed & DRAW_MASK) != 0) {
        if ((mViewFlags & WILL_NOT_DRAW) != 0) {
            if (mBGDrawable != null) {
                mPrivateFlags &= ~SKIP_DRAW;
                mPrivateFlags |= ONLY_DRAWS_BACKGROUND;
            } else {
                mPrivateFlags |= SKIP_DRAW;
            }
        } else {
            mPrivateFlags &= ~SKIP_DRAW;
        }
        requestLayout();
        invalidate();
    }
    if ((changed & KEEP_SCREEN_ON) != 0) {
        if (mParent != null) {
            mParent.recomputeViewAttributes(this);
        }
    }
}",1,"/**
 * Set flags controlling behavior of this view.
 *
 * @param flags Constant indicating the value which should be set
 * @param mask Constant indicating the bit range that should be changed
 */
","/**
 * Set flags controlling behavior of this view.
 *
 * @param flags Constant indicating the value which should be set
 * @param mask Constant indicating the bit range that should be changed
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",0,"An additional condition check and function call (`dispatchVisibilityChanged(this, (flags & VISIBILITY_MASK))`) is inserted in the later version, which is considered as other statement change (4) and control dependency change (3).","This change shouldn't cause a compatibility issue because it doesn't change the return values or the exception behavior of the API. It merely adds a method call when the visibility changes, which should not affect the callers as the method implementation remains the same."
602,<android.database.sqlite.SQLiteQuery: void requery()>,7,8,<android.database.sqlite.SQLiteQuery: void requery()>,<android.database.sqlite.SQLiteQuery: void requery()>,0,"{
    if (mBindArgs != null) {
        int len = mBindArgs.length;
        try {
            for (int i = 0; i < len; i++) {
                super.bindString(i + 1, mBindArgs[i]);
            }
        } catch (SQLiteMisuseException e) {
            StringBuilder errMsg = new StringBuilder(""mQuery "" + mQuery);
            for (int i = 0; i < len; i++) {
                errMsg.append("" "");
                errMsg.append(mBindArgs[i]);
            }
            errMsg.append("" "");
            IllegalStateException leakProgram = new IllegalStateException(errMsg.toString(), e);
            throw leakProgram;
        }
    }
}","{
    if (mBindArgs != null) {
        int len = mBindArgs.length;
        try {
            for (int i = 0; i < len; i++) {
                super.bindString(i + 1, mBindArgs[i]);
            }
        } catch (SQLiteMisuseException e) {
            StringBuilder errMsg = new StringBuilder(""mSql "" + mSql);
            for (int i = 0; i < len; i++) {
                errMsg.append("" "");
                errMsg.append(mBindArgs[i]);
            }
            errMsg.append("" "");
            IllegalStateException leakProgram = new IllegalStateException(errMsg.toString(), e);
            throw leakProgram;
        }
    }
}",1,"/* package */
","/* package */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"There is a change in the string that is being constructed in the StringBuilder instance (from ""mQuery "" to ""mSql ""), which falls under other statement change. Therefore, the change type is 4.","The change is inside the exception handling block, the exception being thrown, and its message will not affect the behaviour of the API, so there are no Compatibility Issues (CI type is 0)."
604,<android.webkit.ContentLoader: boolean setupStreamAndSendStatus()>,7,8,<android.webkit.ContentLoader: boolean setupStreamAndSendStatus()>,<android.webkit.ContentLoader: boolean setupStreamAndSendStatus()>,0,"{
    Uri uri = Uri.parse(mUrl);
    if (uri == null) {
        mHandler.error(EventHandler.FILE_NOT_FOUND_ERROR, mContext.getString(com.android.internal.R.string.httpErrorBadUrl) + "" "" + mUrl);
        return false;
    }
    try {
        mDataStream = mContext.getContentResolver().openInputStream(uri);
        mHandler.status(1, 1, 0, ""OK"");
    } catch (java.io.FileNotFoundException ex) {
        mHandler.error(EventHandler.FILE_NOT_FOUND_ERROR, errString(ex));
        return false;
    } catch (java.io.IOException ex) {
        mHandler.error(EventHandler.FILE_ERROR, errString(ex));
        return false;
    } catch (RuntimeException ex) {
        // readExceptionWithFileNotFoundExceptionFromParcel in DatabaseUtils
        // can throw a serial of RuntimeException. Catch them all here.
        mHandler.error(EventHandler.FILE_ERROR, errString(ex));
        return false;
    }
    return true;
}","{
    Uri uri = Uri.parse(mUrl);
    if (uri == null) {
        mLoadListener.error(EventHandler.FILE_NOT_FOUND_ERROR, mContext.getString(com.android.internal.R.string.httpErrorBadUrl) + "" "" + mUrl);
        return false;
    }
    try {
        mDataStream = mContext.getContentResolver().openInputStream(uri);
        mLoadListener.status(1, 1, 200, ""OK"");
    } catch (java.io.FileNotFoundException ex) {
        mLoadListener.error(EventHandler.FILE_NOT_FOUND_ERROR, errString(ex));
        return false;
    } catch (RuntimeException ex) {
        // readExceptionWithFileNotFoundExceptionFromParcel in DatabaseUtils
        // can throw a serial of RuntimeException. Catch them all here.
        mLoadListener.error(EventHandler.FILE_ERROR, errString(ex));
        return false;
    }
    return true;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"4,5",1,"mHandler is replaced by mLoadListener in both invocation and variable changing statements, so the change type includes 4 and 5.","The change of dependent API from mHandler to mLoadListener and the corresponding changes in function invocation could potentially return different values or lead to different behaviors, so CI type is 1."
605,<android.net.SSLCertificateSocketFactory: String[] getDefaultCipherSuites()>,7,8,<android.net.SSLCertificateSocketFactory: String[] getDefaultCipherSuites()>,<android.net.SSLCertificateSocketFactory: String[] getDefaultCipherSuites()>,0,"{
    return mFactory.getSupportedCipherSuites();
}","{
    return getDelegate().getSupportedCipherSuites();
}",1,,,-1,,[@Override],-1,-1,-1,-1,-1,-1,"1,5",1,"The method call in the return statement changed from `mFactory.getSupportedCipherSuites()` to `getDelegate().getSupportedCipherSuites()`. Therefore, both the return statement and the dependent API have changed, hence the code change type is 1,5.","Since the return statement has changed, the API might return a different value, thus there is a potential compatibility issue caused by different return values or types, i.e., CI type is 1."
607,"<android.accounts.AccountManager: AccountManagerFuture<Bundle> addAccount(String,String,String[],Bundle,Activity,AccountManagerCallback<Bundle>,Handler)>",7,8,"<android.accounts.AccountManager: AccountManagerFuture<Bundle> addAccount(String,String,String[],Bundle,Activity,AccountManagerCallback<Bundle>,Handler)>","<android.accounts.AccountManager: AccountManagerFuture<Bundle> addAccount(String,String,String[],Bundle,Activity,AccountManagerCallback<Bundle>,Handler)>",0,"{
    return new AmsTask(activity, handler, callback) {

        public void doWork() throws RemoteException {
            if (accountType == null) {
                Log.e(TAG, ""the account must not be null"");
                // to unblock caller waiting on Future.get()
                set(new Bundle());
                return;
            }
            mService.addAcount(mResponse, accountType, authTokenType, requiredFeatures, activity != null, addAccountOptions);
        }
    }.start();
}","{
    if (accountType == null)
        throw new IllegalArgumentException(""accountType is null"");
    return new AmsTask(activity, handler, callback) {

        public void doWork() throws RemoteException {
            mService.addAcount(mResponse, accountType, authTokenType, requiredFeatures, activity != null, addAccountOptions);
        }
    }.start();
}",1,"/**
 * Request that an account be added with the given accountType. This request
 * is processed by the authenticator for the account type. If no authenticator is registered
 * in the system then {@link AuthenticatorException} is thrown.
 * <p>
 * This call returns immediately but runs asynchronously and the result is accessed via the
 * {@link AccountManagerFuture} that is returned. This future is also passed as the sole
 * parameter to the {@link AccountManagerCallback}. If the caller wished to use this
 * method asynchronously then they will generally pass in a callback object that will get
 * invoked with the {@link AccountManagerFuture}. If they wish to use it synchronously then
 * they will generally pass null for the callback and instead call
 * {@link android.accounts.AccountManagerFuture#getResult()} on this method's return value,
 * which will then block until the request completes.
 * <p>
 * Requires that the caller has permission {@link android.Manifest.permission#MANAGE_ACCOUNTS}.
 *
 * @param accountType The type of account to add. This must not be null.
 * @param authTokenType The account that is added should be able to service this auth token
 * type. This may be null.
 * @param requiredFeatures The account that is added should support these features.
 * This array may be null or empty.
 * @param addAccountOptions A bundle of authenticator-specific options that is passed on
 * to the authenticator. This may be null.
 * @param activity If the authenticator returns a {@link #KEY_INTENT} in the result then
 * the intent will be started with this activity. If activity is null then the result will
 * be returned as-is.
 * @param callback A callback to invoke when the request completes. If null then
 * no callback is invoked.
 * @param handler The {@link Handler} to use to invoke the callback. If null then the
 * main thread's {@link Handler} is used.
 * @return an {@link AccountManagerFuture} that represents the future result of the call.
 * The future result is a {@link Bundle} that contains either:
 * <ul>
 * <li> {@link #KEY_INTENT}, or
 * <li> {@link #KEY_ACCOUNT_NAME}, {@link #KEY_ACCOUNT_TYPE}
 * and {@link #KEY_AUTHTOKEN} (if an authTokenType was specified).
 * </ul>
 */
","/**
 * Asks the user to add an account of a specified type.  The authenticator
 * for this account type processes this request with the appropriate user
 * interface.  If the user does elect to create a new account, the account
 * name is returned.
 *
 * <p>This method may be called from any thread, but the returned
 * {@link AccountManagerFuture} must not be used on the main thread.
 *
 * <p>This method requires the caller to hold the permission
 * {@link android.Manifest.permission#MANAGE_ACCOUNTS}.
 *
 * @param accountType The type of account to add; must not be null
 * @param authTokenType The type of auth token (see {@link #getAuthToken})
 * this account will need to be able to generate, null for none
 * @param requiredFeatures The features (see {@link #hasFeatures}) this
 * account must have, null for none
 * @param addAccountOptions Authenticator-specific options for the request,
 * may be null or empty
 * @param activity The {@link Activity} context to use for launching a new
 * authenticator-defined sub-Activity to prompt the user to create an
 * account; used only to call startActivity(); if null, the prompt
 * will not be launched directly, but the necessary {@link Intent}
 * will be returned to the caller instead
 * @param callback Callback to invoke when the request completes,
 * null for no callback
 * @param handler {@link Handler} identifying the callback thread,
 * null for the main thread
 * @return An {@link AccountManagerFuture} which resolves to a Bundle with
 * these fields if activity was specified and an account was created:
 * <ul>
 * <li> {@link #KEY_ACCOUNT_NAME} - the name of the account created
 * <li> {@link #KEY_ACCOUNT_TYPE} - the type of the account
 * </ul>
 *
 * If no activity was specified, the returned Bundle contains only
 * {@link #KEY_INTENT} with the {@link Intent} needed to launch the
 * actual account creation process.
 *
 * <p>If an error occurred, {@link AccountManagerFuture#getResult()} throws:
 * <ul>
 * <li> {@link AuthenticatorException} if no authenticator was registered for
 * this account type or the authenticator failed to respond
 * <li> {@link OperationCanceledException} if the operation was canceled for
 * any reason, including the user canceling the creation process
 * <li> {@link IOException} if the authenticator experienced an I/O problem
 * creating a new account, usually because of network trouble
 * </ul>
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,3","1,2","In the early version, the implementation checks for null `accountType` and return a new `Bundle()` in this case, but in the latest version it throws an `IllegalArgumentException`. Thus, both exception and control dependency have changed. So the code change type is 2,3.","The change of exception handling and control statement will result in the function potentially throwing a new `IllegalArgumentException` or producing a different output, so the CI type is 1,2."
608,<android.widget.ListView: Parcelable onSaveInstanceState()>,7,8,<android.widget.ListView: Parcelable onSaveInstanceState()>,<android.widget.ListView: Parcelable onSaveInstanceState()>,0,"{
    Parcelable superState = super.onSaveInstanceState();
    return new SavedState(superState, mCheckStates);
}","{
    Parcelable superState = super.onSaveInstanceState();
    return new SavedState(superState, mCheckStates, mCheckedIdStates);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,5",1,"The returned object of the method changes (a new parameter, mCheckedIdStates, is added to SavedState constructor), the change type is 1,5.","The introduction of the new parameter, mCheckedIdStates, in the SavedState instance can potentially change the Parcelable returned by onSaveInstanceState() method. Therefore, CI type is 1."
609,"<android.database.sqlite.SQLiteDatabase: long replaceOrThrow(String,String,ContentValues)>",7,8,"<android.database.sqlite.SQLiteDatabase: long replaceOrThrow(String,String,ContentValues)>","<android.database.sqlite.SQLiteDatabase: long replaceOrThrow(String,String,ContentValues)>",0,"{
    return insertWithOnConflict(table, nullColumnHack, initialValues, ConflictAlgorithm.REPLACE);
}","{
    return insertWithOnConflict(table, nullColumnHack, initialValues, CONFLICT_REPLACE);
}",1,"/**
 * Convenience method for replacing a row in the database.
 *
 * @param table the table in which to replace the row
 * @param nullColumnHack SQL doesn't allow inserting a completely empty row,
 * so if initialValues is empty this row will explicitly be
 * assigned a NULL value
 * @param initialValues this map contains the initial column values for
 * the row. The key
 * @throws SQLException
 * @return the row ID of the newly inserted row, or -1 if an error occurred
 */
","/**
 * Convenience method for replacing a row in the database.
 *
 * @param table the table in which to replace the row
 * @param nullColumnHack SQL doesn't allow inserting a completely empty row,
 * so if initialValues is empty this row will explicitly be
 * assigned a NULL value
 * @param initialValues this map contains the initial column values for
 * the row. The key
 * @throws SQLException
 * @return the row ID of the newly inserted row, or -1 if an error occurred
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The return statement has changed from insertWithOnConflict(table, nullColumnHack, initialValues, ConflictAlgorithm.REPLACE) to insertWithOnConflict(table, nullColumnHack, initialValues, CONFLICT_REPLACE), and the parameter type of insertWithOnConflict() also changed, so the code change type is 1,5.","The change in the return statement has potentially caused a different return value, which leads to a compatibility issue of type 1."
610,<android.widget.Scroller: boolean computeScrollOffset()>,7,8,<android.widget.Scroller: boolean computeScrollOffset()>,<android.widget.Scroller: boolean computeScrollOffset()>,0,"{
    if (mFinished) {
        return false;
    }
    int timePassed = (int) (AnimationUtils.currentAnimationTimeMillis() - mStartTime);
    if (timePassed < mDuration) {
        switch(mMode) {
            case SCROLL_MODE:
                float x = (float) timePassed * mDurationReciprocal;
                if (mInterpolator == null)
                    x = viscousFluid(x);
                else
                    x = mInterpolator.getInterpolation(x);
                mCurrX = mStartX + Math.round(x * mDeltaX);
                mCurrY = mStartY + Math.round(x * mDeltaY);
                if ((mCurrX == mFinalX) && (mCurrY == mFinalY)) {
                    mFinished = true;
                }
                break;
            case FLING_MODE:
                float timePassedSeconds = timePassed / 1000.0f;
                float distance = (mVelocity * timePassedSeconds) - (mDeceleration * timePassedSeconds * timePassedSeconds / 2.0f);
                mCurrX = mStartX + Math.round(distance * mCoeffX);
                // Pin to mMinX <= mCurrX <= mMaxX
                mCurrX = Math.min(mCurrX, mMaxX);
                mCurrX = Math.max(mCurrX, mMinX);
                mCurrY = mStartY + Math.round(distance * mCoeffY);
                // Pin to mMinY <= mCurrY <= mMaxY
                mCurrY = Math.min(mCurrY, mMaxY);
                mCurrY = Math.max(mCurrY, mMinY);
                if (mCurrX == mFinalX && mCurrY == mFinalY) {
                    mFinished = true;
                }
                break;
        }
    } else {
        mCurrX = mFinalX;
        mCurrY = mFinalY;
        mFinished = true;
    }
    return true;
}","{
    if (mFinished) {
        return false;
    }
    int timePassed = (int) (AnimationUtils.currentAnimationTimeMillis() - mStartTime);
    if (timePassed < mDuration) {
        switch(mMode) {
            case SCROLL_MODE:
                float x = (float) timePassed * mDurationReciprocal;
                if (mInterpolator == null)
                    x = viscousFluid(x);
                else
                    x = mInterpolator.getInterpolation(x);
                mCurrX = mStartX + Math.round(x * mDeltaX);
                mCurrY = mStartY + Math.round(x * mDeltaY);
                break;
            case FLING_MODE:
                float timePassedSeconds = timePassed / 1000.0f;
                float distance = (mVelocity * timePassedSeconds) - (mDeceleration * timePassedSeconds * timePassedSeconds / 2.0f);
                mCurrX = mStartX + Math.round(distance * mCoeffX);
                // Pin to mMinX <= mCurrX <= mMaxX
                mCurrX = Math.min(mCurrX, mMaxX);
                mCurrX = Math.max(mCurrX, mMinX);
                mCurrY = mStartY + Math.round(distance * mCoeffY);
                // Pin to mMinY <= mCurrY <= mMaxY
                mCurrY = Math.min(mCurrY, mMaxY);
                mCurrY = Math.max(mCurrY, mMinY);
                break;
        }
    } else {
        mCurrX = mFinalX;
        mCurrY = mFinalY;
        mFinished = true;
    }
    return true;
}",1,"/**
 * Call this when you want to know the new location.  If it returns true,
 * the animation is not yet finished.  loc will be altered to provide the
 * new location.
 */
","/**
 * Call this when you want to know the new location.  If it returns true,
 * the animation is not yet finished.  loc will be altered to provide the
 * new location.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",1,"The if conditions within the two switch cases (mMode: SCROLL_MODE & FLING_MODE) in the early version were removed in the late implementation, which can be classified as control dependency change. Also, the statements within these conditions are other statements which were changed. Thus, the changes are classified as type 3 and 4.","The removal of these condition checks (if ((mCurrX == mFinalX) && (mCurrY == mFinalY))) within the cases leads to a change in the control flow of the function and could result in a different return value by not setting mFinished = true under certain conditions. Thus, it is a compatibility issue of type 1."
611,<android.pim.vcard.VCardUtils: boolean containsOnlyAlphaDigitHyphen(String)>,7,8,<android.pim.vcard.VCardUtils: boolean containsOnlyAlphaDigitHyphen(String)>,<android.pim.vcard.VCardUtils: boolean containsOnlyAlphaDigitHyphen(String)>,0,"{
    if (TextUtils.isEmpty(str)) {
        return true;
    }
    // included ('A')
    final int lowerAlphabetFirst = 0x41;
    // not included ('[')
    final int lowerAlphabetLast = 0x5b;
    // included ('a')
    final int upperAlphabetFirst = 0x61;
    // included ('{')
    final int upperAlphabetLast = 0x7b;
    // included ('0')
    final int digitFirst = 0x30;
    // included ('9')
    final int digitLast = 0x39;
    final int hyphen = '-';
    final int length = str.length();
    for (int i = 0; i < length; i = str.offsetByCodePoints(i, 1)) {
        int codepoint = str.codePointAt(i);
        if (!((lowerAlphabetFirst <= codepoint && codepoint < lowerAlphabetLast) || (upperAlphabetFirst <= codepoint && codepoint < upperAlphabetLast) || (digitFirst <= codepoint && codepoint < digitLast) || (codepoint == hyphen))) {
            return false;
        }
    }
    return true;
}","{
    if (values == null) {
        return true;
    }
    return containsOnlyAlphaDigitHyphen(Arrays.asList(values));
}",1,"/**
 * This is useful since vCard 3.0 often requires the (""X-"") properties and groups
 * should contain only alphabets, digits, and hyphen.
 *
 * Note: It is already known some devices (wrongly) outputs properties with characters
 * which should not be in the field. One example is ""X-GOOGLE TALK"". We accept
 * such kind of input but must never output it unless the target is very specific
 * to the device which is able to parse the malformed input.
 */
","/**
 * This is useful since vCard 3.0 often requires the (""X-"") properties and groups
 * should contain only alphabets, digits, and hyphen.
 *
 * Note: It is already known some devices (wrongly) outputs properties with characters
 * which should not be in the field. One example is ""X-GOOGLE TALK"". We accept
 * such kind of input but must never output it unless the target is very specific
 * to the device which is able to parse the malformed input.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The entire function body has been replaced, and the dependent API (arrays.asList) has been introduced. Thus, the change code type is 1,5.","Due to the entire function body replacement, the API now might return different results. Therefore, it is potentially causing a compatibility issue, and the CI type is 1."
612,<android.webkit.WebView: void loadUrl(String)>,7,8,<android.webkit.WebView: void loadUrl(String)>,<android.webkit.WebView: void loadUrl(String)>,0,"{
    if (url == null) {
        return;
    }
    switchOutDrawHistory();
    mWebViewCore.sendMessage(EventHub.LOAD_URL, url);
    clearTextEntry();
}","{
    if (url == null) {
        return;
    }
    loadUrl(url, null);
}",1,"/**
 * Load the given url.
 * @param url The url of the resource to load.
 */
","/**
 * Load the given url.
 * @param url The url of the resource to load.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The return statement is not changed but the sequence of method calls after return statement is changed from 'switchOutDrawHistory()', 'mWebViewCore.sendMessage(EventHub.LOAD_URL, url)' and 'clearTextEntry()' to a single method call 'loadUrl(url, null)', so the code change type is 1,5.","Considering the dependency API 'loadUrl' might return different value from previous sequence of method calls, potential return value change could be caused thus the CI type is 1."
615,"<android.webkit.CallbackProxy: void onTooManyRedirects(Message,Message)>",7,8,"<android.webkit.CallbackProxy: void onTooManyRedirects(Message,Message)>","<android.webkit.CallbackProxy: void onTooManyRedirects(Message,Message)>",0,"{
    // been set.
    if (mWebViewClient == null) {
        cancelMsg.sendToTarget();
        return;
    }
    Message msg = obtainMessage(TOO_MANY_REDIRECTS);
    Bundle bundle = msg.getData();
    bundle.putParcelable(""cancelMsg"", cancelMsg);
    bundle.putParcelable(""continueMsg"", continueMsg);
    sendMessage(msg);
}","{
// deprecated.
}",1,,"// party of the public classes, we cannot remove this method.
",-1,,,-1,-1,-1,-1,-1,-1,4,1,"The entire implementation of the method has been changed, so the change type is 4.","As the entire implementation of the method has been changed and nothing is returned in the late version, the return value will definitely be different, so the CI type is 1."
616,<android.ddm.DdmHandleProfiling: Chunk handleChunk(Chunk)>,7,8,<android.ddm.DdmHandleProfiling: Chunk handleChunk(Chunk)>,<android.ddm.DdmHandleProfiling: Chunk handleChunk(Chunk)>,0,"{
    if (Config.LOGV)
        Log.v(""ddm-heap"", ""Handling "" + name(request.type) + "" chunk"");
    int type = request.type;
    if (type == CHUNK_MPRS) {
        return handleMPRS(request);
    } else if (type == CHUNK_MPRE) {
        return handleMPRE(request);
    } else if (type == CHUNK_MPRQ) {
        return handleMPRQ(request);
    } else {
        throw new RuntimeException(""Unknown packet "" + ChunkHandler.name(type));
    }
}","{
    if (Config.LOGV)
        Log.v(""ddm-heap"", ""Handling "" + name(request.type) + "" chunk"");
    int type = request.type;
    if (type == CHUNK_MPRS) {
        return handleMPRS(request);
    } else if (type == CHUNK_MPRE) {
        return handleMPRE(request);
    } else if (type == CHUNK_MPSS) {
        return handleMPSS(request);
    } else if (type == CHUNK_MPSE) {
        return handleMPSE(request);
    } else if (type == CHUNK_MPRQ) {
        return handleMPRQ(request);
    } else {
        throw new RuntimeException(""Unknown packet "" + ChunkHandler.name(type));
    }
}",1,"/**
 * Handle a chunk of data.
 */
","/**
 * Handle a chunk of data.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3",1,"The two additional conditions CHUNK_MPSS and CHUNK_MPSE were added in late implementation. Also, the return statement has updated for CHUNK_MPSS and CHUNK_MPSE to return handleMPSS(request) and handleMPSE(request), respectively. Therefore, the change type is 1,3.","The new conditions will make the API to potentially return different values, hence, the Compatibility Issue type is 1."
617,<android.webkit.WebView: boolean zoomIn()>,7,8,<android.webkit.WebView: boolean zoomIn()>,<android.webkit.WebView: boolean zoomIn()>,0,"{
    // TODO: alternatively we can disallow this during draw history mode
    switchOutDrawHistory();
    mInZoomOverview = false;
    // Center zooming to the center of the screen.
    mZoomCenterX = getViewWidth() * .5f;
    mZoomCenterY = getViewHeight() * .5f;
    mAnchorX = viewToContentX((int) mZoomCenterX + mScrollX);
    mAnchorY = viewToContentY((int) mZoomCenterY + mScrollY);
    return zoomWithPreview(mActualScale * 1.25f);
}","{
    // TODO: alternatively we can disallow this during draw history mode
    switchOutDrawHistory();
    mInZoomOverview = false;
    // Center zooming to the center of the screen.
    mZoomCenterX = getViewWidth() * .5f;
    mZoomCenterY = getViewHeight() * .5f;
    mAnchorX = viewToContentX((int) mZoomCenterX + mScrollX);
    mAnchorY = viewToContentY((int) mZoomCenterY + mScrollY);
    return zoomWithPreview(mActualScale * 1.25f, true);
}",1,"/**
 * Perform zoom in in the webview
 * @return TRUE if zoom in succeeds. FALSE if no zoom changes.
 */
","/**
 * Perform zoom in in the webview
 * @return TRUE if zoom in succeeds. FALSE if no zoom changes.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The return statement zoomWithPreview(mActualScale * 1.25f) has been changed to zoomWithPreview(mActualScale * 1.25f, true) in the late implementation; this means that both the return statement and the dependent API (zoomWithPreview) have been altered, giving us a change type of 1,5.","The alteration in the return statement means the function zoomIn() may return different values between the two versions, leading to a compatibility issue of type 1 because the change involves different potential return values."
619,"<android.content.ContentProviderOperation: ContentProviderResult apply(ContentProvider,ContentProviderResult[],int)>",7,8,"<android.content.ContentProviderOperation: ContentProviderResult apply(ContentProvider,ContentProviderResult[],int)>","<android.content.ContentProviderOperation: ContentProviderResult apply(ContentProvider,ContentProviderResult[],int)>",0,"{
    ContentValues values = resolveValueBackReferences(backRefs, numBackRefs);
    String[] selectionArgs = resolveSelectionArgsBackReferences(backRefs, numBackRefs);
    if (mType == TYPE_INSERT) {
        Uri newUri = provider.insert(mUri, values);
        if (newUri == null) {
            throw new OperationApplicationException(""insert failed"");
        }
        return new ContentProviderResult(newUri);
    }
    int numRows;
    if (mType == TYPE_DELETE) {
        numRows = provider.delete(mUri, mSelection, selectionArgs);
    } else if (mType == TYPE_UPDATE) {
        numRows = provider.update(mUri, values, mSelection, selectionArgs);
    } else if (mType == TYPE_ASSERT) {
        // Assert that all rows match expected values
        String[] projection = null;
        if (values != null) {
            // Build projection map from expected values
            final ArrayList<String> projectionList = new ArrayList<String>();
            for (Map.Entry<String, Object> entry : values.valueSet()) {
                projectionList.add(entry.getKey());
            }
            projection = projectionList.toArray(new String[projectionList.size()]);
        }
        final Cursor cursor = provider.query(mUri, projection, mSelection, selectionArgs, null);
        try {
            numRows = cursor.getCount();
            if (projection != null) {
                while (cursor.moveToNext()) {
                    for (int i = 0; i < projection.length; i++) {
                        final String cursorValue = cursor.getString(i);
                        final String expectedValue = values.getAsString(projection[i]);
                        if (!TextUtils.equals(cursorValue, expectedValue)) {
                            // Throw exception when expected values don't match
                            throw new OperationApplicationException(""Found value "" + cursorValue + "" when expected "" + expectedValue + "" for column "" + projection[i]);
                        }
                    }
                }
            }
        } finally {
            cursor.close();
        }
    } else {
        throw new IllegalStateException(""bad type, "" + mType);
    }
    if (mExpectedCount != null && mExpectedCount != numRows) {
        throw new OperationApplicationException(""wrong number of rows: "" + numRows);
    }
    return new ContentProviderResult(numRows);
}","{
    ContentValues values = resolveValueBackReferences(backRefs, numBackRefs);
    String[] selectionArgs = resolveSelectionArgsBackReferences(backRefs, numBackRefs);
    if (mType == TYPE_INSERT) {
        Uri newUri = provider.insert(mUri, values);
        if (newUri == null) {
            throw new OperationApplicationException(""insert failed"");
        }
        return new ContentProviderResult(newUri);
    }
    int numRows;
    if (mType == TYPE_DELETE) {
        numRows = provider.delete(mUri, mSelection, selectionArgs);
    } else if (mType == TYPE_UPDATE) {
        numRows = provider.update(mUri, values, mSelection, selectionArgs);
    } else if (mType == TYPE_ASSERT) {
        // Assert that all rows match expected values
        String[] projection = null;
        if (values != null) {
            // Build projection map from expected values
            final ArrayList<String> projectionList = new ArrayList<String>();
            for (Map.Entry<String, Object> entry : values.valueSet()) {
                projectionList.add(entry.getKey());
            }
            projection = projectionList.toArray(new String[projectionList.size()]);
        }
        final Cursor cursor = provider.query(mUri, projection, mSelection, selectionArgs, null);
        try {
            numRows = cursor.getCount();
            if (projection != null) {
                while (cursor.moveToNext()) {
                    for (int i = 0; i < projection.length; i++) {
                        final String cursorValue = cursor.getString(i);
                        final String expectedValue = values.getAsString(projection[i]);
                        if (!TextUtils.equals(cursorValue, expectedValue)) {
                            // Throw exception when expected values don't match
                            Log.e(TAG, this.toString());
                            throw new OperationApplicationException(""Found value "" + cursorValue + "" when expected "" + expectedValue + "" for column "" + projection[i]);
                        }
                    }
                }
            }
        } finally {
            cursor.close();
        }
    } else {
        Log.e(TAG, this.toString());
        throw new IllegalStateException(""bad type, "" + mType);
    }
    if (mExpectedCount != null && mExpectedCount != numRows) {
        Log.e(TAG, this.toString());
        throw new OperationApplicationException(""wrong number of rows: "" + numRows);
    }
    return new ContentProviderResult(numRows);
}",1,"/**
 * Applies this operation using the given provider. The backRefs array is used to resolve any
 * back references that were requested using
 * {@link Builder#withValueBackReferences(ContentValues)} and
 * {@link Builder#withSelectionBackReference}.
 * @param provider the {@link ContentProvider} on which this batch is applied
 * @param backRefs a {@link ContentProviderResult} array that will be consulted
 * to resolve any requested back references.
 * @param numBackRefs the number of valid results on the backRefs array.
 * @return a {@link ContentProviderResult} that contains either the {@link Uri} of the inserted
 * row if this was an insert otherwise the number of rows affected.
 * @throws OperationApplicationException thrown if either the insert fails or
 * if the number of rows affected didn't match the expected count
 */
","/**
 * Applies this operation using the given provider. The backRefs array is used to resolve any
 * back references that were requested using
 * {@link Builder#withValueBackReferences(ContentValues)} and
 * {@link Builder#withSelectionBackReference}.
 * @param provider the {@link ContentProvider} on which this batch is applied
 * @param backRefs a {@link ContentProviderResult} array that will be consulted
 * to resolve any requested back references.
 * @param numBackRefs the number of valid results on the backRefs array.
 * @return a {@link ContentProviderResult} that contains either the {@link Uri} of the inserted
 * row if this was an insert otherwise the number of rows affected.
 * @throws OperationApplicationException thrown if either the insert fails or
 * if the number of rows affected didn't match the expected count
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"In the late version, additional logging statements `Log.e(TAG, this.toString());` are added before each `throw` statement, so the code change type is 4.","The additional logging statements do not affect the behaviour and return values of the API or cause it throw different exceptions, hence no compatibility issue (CI) exists. The CI type is 0."
621,"<android.provider.Calendar.Instances: Cursor query(ContentResolver,String[],long,long,String,String)>",7,8,"<android.provider.Calendar.Instances: Cursor query(ContentResolver,String[],long,long,String,String)>","<android.provider.Calendar.Instances: Cursor query(ContentResolver,String[],long,long,String,String)>",0,"{
    Uri.Builder builder = CONTENT_URI.buildUpon();
    ContentUris.appendId(builder, begin);
    ContentUris.appendId(builder, end);
    if (TextUtils.isEmpty(where)) {
        where = Calendars.SELECTED + ""=1"";
    } else {
        where = ""("" + where + "") AND "" + Calendars.SELECTED + ""=1"";
    }
    return cr.query(builder.build(), projection, where, null, orderBy == null ? DEFAULT_SORT_ORDER : orderBy);
}","{
    Uri.Builder builder = CONTENT_URI.buildUpon();
    ContentUris.appendId(builder, begin);
    ContentUris.appendId(builder, end);
    if (TextUtils.isEmpty(where)) {
        where = WHERE_CALENDARS_SELECTED;
    } else {
        where = ""("" + where + "") AND "" + WHERE_CALENDARS_SELECTED;
    }
    return cr.query(builder.build(), projection, where, null, orderBy == null ? DEFAULT_SORT_ORDER : orderBy);
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The main change in this method lies in the assignment of 'where' variable when 'where' is empty or not. Instead of being set as 'Calendars.SELECTED + ""=1""', 'where' is now set as 'WHERE_CALENDARS_SELECTED'. This means that the 'query' method could be called with different parameters, which falls under change types 1 and 5.","The change of 'where' variable directly affects the 'return cr.query(...)' statement, potentially causing the this method to return a different value between the two versions. This is a compatibility issue of type 1."
622,<android.widget.HeaderViewListAdapter: Object getItem(int)>,7,8,<android.widget.HeaderViewListAdapter: Object getItem(int)>,<android.widget.HeaderViewListAdapter: Object getItem(int)>,0,"{
    int numHeaders = getHeadersCount();
    if (mAdapter != null && position >= numHeaders) {
        int adjPosition = position - numHeaders;
        int adapterCount = mAdapter.getCount();
        if (adjPosition >= adapterCount && mFooterViewInfos != null) {
            return mFooterViewInfos.get(adjPosition - adapterCount).data;
        } else {
            return mAdapter.getItem(adjPosition);
        }
    } else if (position < numHeaders && mHeaderViewInfos != null) {
        return mHeaderViewInfos.get(position).data;
    }
    return null;
}","{
    // Header (negative positions will throw an ArrayIndexOutOfBoundsException)
    int numHeaders = getHeadersCount();
    if (position < numHeaders) {
        return mHeaderViewInfos.get(position).data;
    }
    // Adapter
    final int adjPosition = position - numHeaders;
    int adapterCount = 0;
    if (mAdapter != null) {
        adapterCount = mAdapter.getCount();
        if (adjPosition < adapterCount) {
            return mAdapter.getItem(adjPosition);
        }
    }
    // Footer (off-limits positions will throw an ArrayIndexOutOfBoundsException)
    return mFooterViewInfos.get(adjPosition - adapterCount).data;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"1,3",1,"The control flow and the return statement inside the conditions has been rearranged hence the change is of type 1,3. ","After rearrangement of the condition, the possible return variables can be different than the original, hence there might be a compatibility issue of type 1."
623,"<android.database.sqlite.SQLiteDatabase: long insertOrThrow(String,String,ContentValues)>",7,8,"<android.database.sqlite.SQLiteDatabase: long insertOrThrow(String,String,ContentValues)>","<android.database.sqlite.SQLiteDatabase: long insertOrThrow(String,String,ContentValues)>",0,"{
    return insertWithOnConflict(table, nullColumnHack, values, null);
}","{
    return insertWithOnConflict(table, nullColumnHack, values, CONFLICT_NONE);
}",1,"/**
 * Convenience method for inserting a row into the database.
 *
 * @param table the table to insert the row into
 * @param nullColumnHack SQL doesn't allow inserting a completely empty row,
 * so if initialValues is empty this column will explicitly be
 * assigned a NULL value
 * @param values this map contains the initial column values for the
 * row. The keys should be the column names and the values the
 * column values
 * @throws SQLException
 * @return the row ID of the newly inserted row, or -1 if an error occurred
 */
","/**
 * Convenience method for inserting a row into the database.
 *
 * @param table the table to insert the row into
 * @param nullColumnHack SQL doesn't allow inserting a completely empty row,
 * so if initialValues is empty this column will explicitly be
 * assigned a NULL value
 * @param values this map contains the initial column values for the
 * row. The keys should be the column names and the values the
 * column values
 * @throws SQLException
 * @return the row ID of the newly inserted row, or -1 if an error occurred
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The return statement has changed as the value passed to the insertWithOnConflict() method has been modified from null to CONFLICT_NONE. That indicates that the change types are Dependent API changed and Return statement changed (types 1,5).","The change in the parameter of method insertWithOnConflict() results in potentially different returned values or types, which represents a compatibility issue of type 1. Thus, the Compatibility Issue (CI) type is 1."
624,<android.database.sqlite.SQLiteDatabase: void beginTransactionWithListener(SQLiteTransactionListener)>,7,8,<android.database.sqlite.SQLiteDatabase: void beginTransactionWithListener(SQLiteTransactionListener)>,<android.database.sqlite.SQLiteDatabase: void beginTransactionWithListener(SQLiteTransactionListener)>,0,"{
    lockForced();
    boolean ok = false;
    try {
        // If this thread already had the lock then get out
        if (mLock.getHoldCount() > 1) {
            if (mInnerTransactionIsSuccessful) {
                String msg = ""Cannot call beginTransaction between "" + ""calling setTransactionSuccessful and endTransaction"";
                IllegalStateException e = new IllegalStateException(msg);
                Log.e(TAG, ""beginTransaction() failed"", e);
                throw e;
            }
            ok = true;
            return;
        }
        // This thread didn't already have the lock, so begin a database
        // transaction now.
        execSQL(""BEGIN EXCLUSIVE;"");
        mTransactionListener = transactionListener;
        mTransactionIsSuccessful = true;
        mInnerTransactionIsSuccessful = false;
        if (transactionListener != null) {
            try {
                transactionListener.onBegin();
            } catch (RuntimeException e) {
                execSQL(""ROLLBACK;"");
                throw e;
            }
        }
        ok = true;
    } finally {
        if (!ok) {
            // beginTransaction is called before the try block so we must release the lock in
            // the case of failure.
            unlockForced();
        }
    }
}","{
    lockForced();
    if (!isOpen()) {
        throw new IllegalStateException(""database not open"");
    }
    boolean ok = false;
    try {
        // If this thread already had the lock then get out
        if (mLock.getHoldCount() > 1) {
            if (mInnerTransactionIsSuccessful) {
                String msg = ""Cannot call beginTransaction between "" + ""calling setTransactionSuccessful and endTransaction"";
                IllegalStateException e = new IllegalStateException(msg);
                Log.e(TAG, ""beginTransaction() failed"", e);
                throw e;
            }
            ok = true;
            return;
        }
        // This thread didn't already have the lock, so begin a database
        // transaction now.
        execSQL(""BEGIN EXCLUSIVE;"");
        mTransactionListener = transactionListener;
        mTransactionIsSuccessful = true;
        mInnerTransactionIsSuccessful = false;
        if (transactionListener != null) {
            try {
                transactionListener.onBegin();
            } catch (RuntimeException e) {
                execSQL(""ROLLBACK;"");
                throw e;
            }
        }
        ok = true;
    } finally {
        if (!ok) {
            // beginTransaction is called before the try block so we must release the lock in
            // the case of failure.
            unlockForced();
        }
    }
}",1,"/**
 * Begins a transaction. Transactions can be nested. When the outer transaction is ended all of
 * the work done in that transaction and all of the nested transactions will be committed or
 * rolled back. The changes will be rolled back if any transaction is ended without being
 * marked as clean (by calling setTransactionSuccessful). Otherwise they will be committed.
 *
 * <p>Here is the standard idiom for transactions:
 *
 * <pre>
 * db.beginTransactionWithListener(listener);
 * try {
 * ...
 * db.setTransactionSuccessful();
 * } finally {
 * db.endTransaction();
 * }
 * </pre>
 * @param transactionListener listener that should be notified when the transaction begins,
 * commits, or is rolled back, either explicitly or by a call to
 * {@link #yieldIfContendedSafely}.
 */
","/**
 * Begins a transaction. Transactions can be nested. When the outer transaction is ended all of
 * the work done in that transaction and all of the nested transactions will be committed or
 * rolled back. The changes will be rolled back if any transaction is ended without being
 * marked as clean (by calling setTransactionSuccessful). Otherwise they will be committed.
 *
 * <p>Here is the standard idiom for transactions:
 *
 * <pre>
 * db.beginTransactionWithListener(listener);
 * try {
 * ...
 * db.setTransactionSuccessful();
 * } finally {
 * db.endTransaction();
 * }
 * </pre>
 * @param transactionListener listener that should be notified when the transaction begins,
 * commits, or is rolled back, either explicitly or by a call to
 * {@link #yieldIfContendedSafely}.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,3","1,2","In the late version implementation, a new ""if"" condition and an exception statement have been introduced, so the change type is 2,3.","The introduction of a new ""if"" condition and exception could lead the late version API to potentially throw a new exception (IllegalStateException). Additionally, due to the increased complexity as a result of the new ""if"" condition, the return value could also be affected. Therefore, the CI type is 1,2."
625,"<android.widget.ExpandableListView: ContextMenuInfo createContextMenuInfo(View,int,long)>",7,8,"<android.widget.ExpandableListView: ContextMenuInfo createContextMenuInfo(View,int,long)>","<android.widget.ExpandableListView: ContextMenuInfo createContextMenuInfo(View,int,long)>",0,"{
    // Adjust for and handle for header views
    final int adjustedPosition = flatListPosition - getHeaderViewsCount();
    if (adjustedPosition < 0) {
        // Return normal info for header view context menus
        return new AdapterContextMenuInfo(view, flatListPosition, id);
    }
    PositionMetadata pm = mConnector.getUnflattenedPos(adjustedPosition);
    ExpandableListPosition pos = pm.position;
    pm.recycle();
    id = getChildOrGroupId(pos);
    long packedPosition = pos.getPackedPosition();
    pos.recycle();
    return new ExpandableListContextMenuInfo(view, packedPosition, id);
}","{
    if (isHeaderOrFooterPosition(flatListPosition)) {
        // Return normal info for header/footer view context menus
        return new AdapterContextMenuInfo(view, flatListPosition, id);
    }
    final int adjustedPosition = getFlatPositionForConnector(flatListPosition);
    PositionMetadata pm = mConnector.getUnflattenedPos(adjustedPosition);
    ExpandableListPosition pos = pm.position;
    pm.recycle();
    id = getChildOrGroupId(pos);
    long packedPosition = pos.getPackedPosition();
    pos.recycle();
    return new ExpandableListContextMenuInfo(view, packedPosition, id);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,4",1,"In the late version, a new condition (`isHeaderOrFooterPosition(flatListPosition)`) has been introduced replacing the old one (`adjustedPosition < 0`), which counts as a control dependency change. Moreover, the calling method `getFlatPositionForConnector(flatListPosition)` replaced subtraction to compute the `adjustedPosition`, so the code change type is 3,4.","The change in the control condition and the method calling to compute the `adjustedPosition` can potentially affect the return values of the API (`new AdapterContextMenuInfo(view, flatListPosition, id)` or `new ExpandableListContextMenuInfo(view, packedPosition, id)`), hence counts as a compatibility issue of type 1."
626,"<android.accounts.AbstractAccountAuthenticator.Transport: void getAuthToken(IAccountAuthenticatorResponse,Account,String,Bundle)>",7,8,"<android.accounts.AbstractAccountAuthenticator.Transport: void getAuthToken(IAccountAuthenticatorResponse,Account,String,Bundle)>","<android.accounts.AbstractAccountAuthenticator.Transport: void getAuthToken(IAccountAuthenticatorResponse,Account,String,Bundle)>",0,"{
    checkBinderPermission();
    try {
        final Bundle result = AbstractAccountAuthenticator.this.getAuthToken(new AccountAuthenticatorResponse(response), account, authTokenType, loginOptions);
        if (result != null) {
            response.onResult(result);
        }
    } catch (UnsupportedOperationException e) {
        response.onError(AccountManager.ERROR_CODE_UNSUPPORTED_OPERATION, ""getAuthToken not supported"");
    } catch (NetworkErrorException e) {
        response.onError(AccountManager.ERROR_CODE_NETWORK_ERROR, e.getMessage());
    }
}","{
    if (Log.isLoggable(TAG, Log.VERBOSE)) {
        Log.v(TAG, ""getAuthToken: "" + account + "", authTokenType "" + authTokenType);
    }
    checkBinderPermission();
    try {
        final Bundle result = AbstractAccountAuthenticator.this.getAuthToken(new AccountAuthenticatorResponse(response), account, authTokenType, loginOptions);
        if (Log.isLoggable(TAG, Log.VERBOSE)) {
            // force it to be unparcelled
            result.keySet();
            Log.v(TAG, ""getAuthToken: result "" + AccountManager.sanitizeResult(result));
        }
        if (result != null) {
            response.onResult(result);
        }
    } catch (UnsupportedOperationException e) {
        if (Log.isLoggable(TAG, Log.VERBOSE)) {
            Log.v(TAG, ""getAuthToken"", e);
        }
        response.onError(AccountManager.ERROR_CODE_UNSUPPORTED_OPERATION, ""getAuthToken not supported"");
    } catch (NetworkErrorException e) {
        if (Log.isLoggable(TAG, Log.VERBOSE)) {
            Log.v(TAG, ""getAuthToken"", e);
        }
        response.onError(AccountManager.ERROR_CODE_NETWORK_ERROR, e.getMessage());
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,4,0,"The addition of logging statements in the late version is the only change which checks if verbose logging is enabled and if yes, logs specific method calls with the Log.v(). This falls under the category 4 (Other statement changed) as logging statements do not affect the functional behaviour of the method.","There is no Compatibility Issue caused by the change since the additional logging statements do not affect the expected behaviour of the method, the return values or exception handling."
630,"<android.accounts.AccountManager: AccountManagerFuture<Bundle> confirmCredentials(Account,Bundle,Activity,AccountManagerCallback<Bundle>,Handler)>",7,8,"<android.accounts.AccountManager: AccountManagerFuture<Bundle> confirmCredentials(Account,Bundle,Activity,AccountManagerCallback<Bundle>,Handler)>","<android.accounts.AccountManager: AccountManagerFuture<Bundle> confirmCredentials(Account,Bundle,Activity,AccountManagerCallback<Bundle>,Handler)>",0,"{
    return new AmsTask(activity, handler, callback) {

        public void doWork() throws RemoteException {
            mService.confirmCredentials(mResponse, account, options, activity != null);
        }
    }.start();
}","{
    if (account == null)
        throw new IllegalArgumentException(""account is null"");
    return new AmsTask(activity, handler, callback) {

        public void doWork() throws RemoteException {
            mService.confirmCredentials(mResponse, account, options, activity != null);
        }
    }.start();
}",1,"/**
 * Requests that the authenticator checks that the user knows the credentials for the account.
 * This is typically done by returning an intent to an activity that prompts the user to
 * enter the credentials. This request
 * is processed by the authenticator for the account. If no matching authenticator is
 * registered in the system then {@link AuthenticatorException} is thrown.
 * <p>
 * This call returns immediately but runs asynchronously and the result is accessed via the
 * {@link AccountManagerFuture} that is returned. This future is also passed as the sole
 * parameter to the {@link AccountManagerCallback}. If the caller wished to use this
 * method asynchronously then they will generally pass in a callback object that will get
 * invoked with the {@link AccountManagerFuture}. If they wish to use it synchronously then
 * they will generally pass null for the callback and instead call
 * {@link android.accounts.AccountManagerFuture#getResult()} on this method's return value,
 * which will then block until the request completes.
 * <p>
 * Requires that the caller has permission {@link android.Manifest.permission#MANAGE_ACCOUNTS}.
 *
 * @param account The account whose credentials are to be checked
 * @param options authenticator specific options for the request
 * @param activity If the authenticator returns a {@link #KEY_INTENT} in the result then
 * the intent will be started with this activity. If activity is null then the result will
 * be returned as-is.
 * @param callback A callback to invoke when the request completes. If null then
 * no callback is invoked.
 * @param handler The {@link Handler} to use to invoke the callback. If null then the
 * main thread's {@link Handler} is used.
 * @return an {@link AccountManagerFuture} that represents the future result of the call.
 * The future result is a {@link Bundle} that contains either:
 * <ul>
 * <li> {@link #KEY_INTENT}, which is to be used to prompt the user for the credentials
 * <li> {@link #KEY_ACCOUNT_NAME} and {@link #KEY_ACCOUNT_TYPE} if the user enters the correct
 * credentials
 * </ul>
 * If the user presses ""back"" then the request will be canceled.
 */
","/**
 * Confirms that the user knows the password for an account to make extra
 * sure they are the owner of the account.  The user-entered password can
 * be supplied directly, otherwise the authenticator for this account type
 * prompts the user with the appropriate interface.  This method is
 * intended for applications which want extra assurance; for example, the
 * phone lock screen uses this to let the user unlock the phone with an
 * account password if they forget the lock pattern.
 *
 * <p>If the user-entered password matches a saved password for this
 * account, the request is considered valid; otherwise the authenticator
 * verifies the password (usually by contacting the server).
 *
 * <p>This method may be called from any thread, but the returned
 * {@link AccountManagerFuture} must not be used on the main thread.
 *
 * <p>This method requires the caller to hold the permission
 * {@link android.Manifest.permission#MANAGE_ACCOUNTS}.
 *
 * @param account The account to confirm password knowledge for
 * @param options Authenticator-specific options for the request;
 * if the {@link #KEY_PASSWORD} string field is present, the
 * authenticator may use it directly rather than prompting the user;
 * may be null or empty
 * @param activity The {@link Activity} context to use for launching a new
 * authenticator-defined sub-Activity to prompt the user to enter a
 * password; used only to call startActivity(); if null, the prompt
 * will not be launched directly, but the necessary {@link Intent}
 * will be returned to the caller instead
 * @param callback Callback to invoke when the request completes,
 * null for no callback
 * @param handler {@link Handler} identifying the callback thread,
 * null for the main thread
 * @return An {@link AccountManagerFuture} which resolves to a Bundle
 * with these fields if activity or password was supplied and
 * the account was successfully verified:
 * <ul>
 * <li> {@link #KEY_ACCOUNT_NAME} - the name of the account created
 * <li> {@link #KEY_ACCOUNT_TYPE} - the type of the account
 * <li> {@link #KEY_BOOLEAN_RESULT} - true to indicate success
 * </ul>
 *
 * If no activity or password was specified, the returned Bundle contains
 * only {@link #KEY_INTENT} with the {@link Intent} needed to launch the
 * password prompt.
 *
 * <p>If an error occurred, {@link AccountManagerFuture#getResult()} throws:
 * <ul>
 * <li> {@link AuthenticatorException} if the authenticator failed to respond
 * <li> {@link OperationCanceledException} if the operation was canceled for
 * any reason, including the user canceling the password prompt
 * <li> {@link IOException} if the authenticator experienced an I/O problem
 * verifying the password, usually because of network trouble
 * </ul>
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,3","1,2","The early version does not have a null check for the account parameter, whereas the late version does. If the account is null, an IllegalArgumentException is thrown. So, the code change types are 2 and 3 (exception handling statement changed and control dependency changed).","This code change can potentially cause two types of compatibility issues. Firstly, a new exception ""IllegalArgumentException"" is introduced in the late version when account is null, which doesn't exist in the early version, leading to a different exception handling behavior (CI Type 2). "
631,"<android.provider.Calendar.CalendarAlerts: void rescheduleMissedAlarms(ContentResolver,Context,AlarmManager)>",7,8,"<android.provider.Calendar.CalendarAlerts: void rescheduleMissedAlarms(ContentResolver,Context,AlarmManager)>","<android.provider.Calendar.CalendarAlerts: void rescheduleMissedAlarms(ContentResolver,Context,AlarmManager)>",0,"{
    // Get all the alerts that have been scheduled but have not fired
    // and should have fired by now and are not too old.
    long now = System.currentTimeMillis();
    long ancient = now - 24 * DateUtils.HOUR_IN_MILLIS;
    String selection = CalendarAlerts.STATE + ""="" + CalendarAlerts.SCHEDULED + "" AND "" + CalendarAlerts.ALARM_TIME + ""<"" + now + "" AND "" + CalendarAlerts.ALARM_TIME + "">"" + ancient + "" AND "" + CalendarAlerts.END + "">="" + now;
    String[] projection = new String[] { _ID, BEGIN, END, ALARM_TIME };
    Cursor cursor = CalendarAlerts.query(cr, projection, selection, null);
    if (cursor == null) {
        return;
    }
    if (Log.isLoggable(TAG, Log.DEBUG)) {
        Log.d(TAG, ""missed alarms found: "" + cursor.getCount());
    }
    try {
        while (cursor.moveToNext()) {
            long id = cursor.getLong(0);
            long begin = cursor.getLong(1);
            long end = cursor.getLong(2);
            long alarmTime = cursor.getLong(3);
            Uri uri = ContentUris.withAppendedId(CONTENT_URI, id);
            Intent intent = new Intent(android.provider.Calendar.EVENT_REMINDER_ACTION);
            intent.setData(uri);
            intent.putExtra(android.provider.Calendar.EVENT_BEGIN_TIME, begin);
            intent.putExtra(android.provider.Calendar.EVENT_END_TIME, end);
            PendingIntent sender = PendingIntent.getBroadcast(context, 0, intent, PendingIntent.FLAG_CANCEL_CURRENT);
            Log.w(TAG, ""rescheduling missed alarm, id: "" + id + "" begin: "" + begin + "" end: "" + end + "" alarmTime: "" + alarmTime);
            manager.set(AlarmManager.RTC_WAKEUP, alarmTime, sender);
        }
    } finally {
        cursor.close();
    }
}","{
    // Get all the alerts that have been scheduled but have not fired
    // and should have fired by now and are not too old.
    long now = System.currentTimeMillis();
    long ancient = now - DateUtils.DAY_IN_MILLIS;
    String[] projection = new String[] { ALARM_TIME };
    // TODO: construct an explicit SQL query so that we can add
    // ""GROUPBY"" instead of doing a sort and de-dup
    Cursor cursor = CalendarAlerts.query(cr, projection, WHERE_RESCHEDULE_MISSED_ALARMS, new String[] { Long.toString(now), Long.toString(ancient), Long.toString(now) }, SORT_ORDER_ALARMTIME_ASC);
    if (cursor == null) {
        return;
    }
    if (DEBUG) {
        Log.d(TAG, ""missed alarms found: "" + cursor.getCount());
    }
    try {
        long alarmTime = -1;
        while (cursor.moveToNext()) {
            long newAlarmTime = cursor.getLong(0);
            if (alarmTime != newAlarmTime) {
                if (DEBUG) {
                    Log.w(TAG, ""rescheduling missed alarm. alarmTime: "" + newAlarmTime);
                }
                scheduleAlarm(context, manager, newAlarmTime);
                alarmTime = newAlarmTime;
            }
        }
    } finally {
        cursor.close();
    }
}",1,"/**
 * Searches the CalendarAlerts table for alarms that should have fired
 * but have not and then reschedules them.  This method can be called
 * at boot time to restore alarms that may have been lost due to a
 * phone reboot.
 *
 * @param cr the ContentResolver
 * @param context the Context
 * @param manager the AlarmManager
 */
","/**
 * Searches the CalendarAlerts table for alarms that should have fired
 * but have not and then reschedules them.  This method can be called
 * at boot time to restore alarms that may have been lost due to a
 * phone reboot.
 *
 * @param cr the ContentResolver
 * @param context the Context
 * @param manager the AlarmManager
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3,4",1,"The logic of the code and the method of calling the function scheduleAlarm has been changed. A new variable (alarmTime) is declared and used. So types are 1, 3, 4.","While the cursor is moving to next, it is not only trying to execute the next alarm, but also compare anew field. In the early version, the missed alarms are rescheduled, while in the late version, it is checking whether a new alarm is different from the old one. If it is different, then schedule it, otherwise, skip it. The behaviour leads to a different return which is classified into type 1 compatibility issue."
632,<android.content.pm.PackageParser.Service: String toString()>,7,8,<android.content.pm.PackageParser.Service: String toString()>,<android.content.pm.PackageParser.Service: String toString()>,0,"{
    return ""Service{"" + Integer.toHexString(System.identityHashCode(this)) + "" "" + component.flattenToString() + ""}"";
}","{
    return ""Service{"" + Integer.toHexString(System.identityHashCode(this)) + "" "" + getComponentShortName() + ""}"";
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The return statement of the function has changed from component.flattenToString() to getComponentShortName(). Since flattenToString() is replaced by getComponentShortName(), it indicates that a dependent API has been modified. Hence the change types are 1,5.","As a result of the change in the dependent API from flattenToString() to getComponentShortName(), the return value of the function may potentially change. As a result, the type of CI is 1."
633,<android.webkit.CacheManager: void trimCacheIfNeeded()>,7,8,<android.webkit.CacheManager: void trimCacheIfNeeded()>,<android.webkit.CacheManager: void trimCacheIfNeeded()>,0,"{
    if (mDataBase.getCacheTotalSize() > CACHE_THRESHOLD) {
        ArrayList<String> pathList = mDataBase.trimCache(CACHE_TRIM_AMOUNT);
        int size = pathList.size();
        for (int i = 0; i < size; i++) {
            File f = new File(mBaseDir, pathList.get(i));
            if (!f.delete()) {
                Log.e(LOGTAG, f.getPath() + "" delete failed."");
            }
        }
    }
}","{
    if (mDataBase.getCacheTotalSize() > CACHE_THRESHOLD) {
        List<String> pathList = mDataBase.trimCache(CACHE_TRIM_AMOUNT);
        int size = pathList.size();
        for (int i = 0; i < size; i++) {
            File f = new File(mBaseDir, pathList.get(i));
            if (!f.delete()) {
                Log.e(LOGTAG, f.getPath() + "" delete failed."");
            }
        }
        // remove the unreferenced files in the cache directory
        final List<String> fileList = mDataBase.getAllCacheFileNames();
        if (fileList == null)
            return;
        String[] toDelete = mBaseDir.list(new FilenameFilter() {

            public boolean accept(File dir, String filename) {
                if (fileList.contains(filename)) {
                    return false;
                } else {
                    return true;
                }
            }
        });
        if (toDelete == null)
            return;
        size = toDelete.length;
        for (int i = 0; i < size; i++) {
            File f = new File(mBaseDir, toDelete[i]);
            if (!f.delete()) {
                Log.e(LOGTAG, f.getPath() + "" delete failed."");
            }
        }
    }
}",1,"// only called from WebCore thread
",,-1,,,-1,-1,-1,-1,-1,-1,"1,3",0,"There is a new control dependency introduced in the later version to check for unreferenced cache files and delete them, therefore, the change type is 3. In addition, there is an addition of a new return statement in the late version if fileList == null or toDelete == null. So Return statement is changed as well, making the change type 1 in addition to 3.","Despite the changes, the purpose of this method is to handle cache management and not to return a value to end users or developers. As a result, the changes will not change the values returned by the API (since it doesn't return anything), nor the way it throws exceptions, so no compatibility issue exists. Therefore, the final classification is 0."
634,"<android.util.Log: int i(String,String)>",7,8,"<android.util.Log: int i(String,String)>","<android.util.Log: int i(String,String)>",0,"{
    return println(INFO, tag, msg);
}","{
    return println_native(LOG_ID_MAIN, INFO, tag, msg);
}",1,"/**
 * Send an {@link #INFO} log message.
 * @param tag Used to identify the source of a log message.  It usually identifies
 * the class or activity where the log call occurs.
 * @param msg The message you would like logged.
 */
","/**
 * Send an {@link #INFO} log message.
 * @param tag Used to identify the source of a log message.  It usually identifies
 * the class or activity where the log call occurs.
 * @param msg The message you would like logged.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The return statement of the function has changed from println(INFO, tag, msg) to println_native(LOG_ID_MAIN, INFO, tag, msg) and change from println() to println_native() indicates dependent API has changed. Therefore, the code change type is 1,5.","The modification of the return statement means that the API could potentially return a different value, so the CI type is 1."
635,<android.speech.tts.TextToSpeech: int setPitch(float)>,7,8,<android.speech.tts.TextToSpeech: int setPitch(float)>,<android.speech.tts.TextToSpeech: int setPitch(float)>,0,"{
    synchronized (mStartLock) {
        int result = ERROR;
        if (!mStarted) {
            return result;
        }
        try {
            if (pitch > 0) {
                result = mITts.setPitch(mPackageName, (int) (pitch * 100));
            }
        } catch (RemoteException e) {
            // TTS died; restart it.
            Log.e(""TextToSpeech.java - setPitch"", ""RemoteException"");
            e.printStackTrace();
            mStarted = false;
            initTts();
        } catch (NullPointerException e) {
            // TTS died; restart it.
            Log.e(""TextToSpeech.java - setPitch"", ""NullPointerException"");
            e.printStackTrace();
            mStarted = false;
            initTts();
        } catch (IllegalStateException e) {
            // TTS died; restart it.
            Log.e(""TextToSpeech.java - setPitch"", ""IllegalStateException"");
            e.printStackTrace();
            mStarted = false;
            initTts();
        } finally {
            return result;
        }
    }
}","{
    synchronized (mStartLock) {
        int result = ERROR;
        if (!mStarted) {
            return result;
        }
        try {
            // with all upcoming utterances.
            if (pitch > 0) {
                int p = (int) (pitch * 100);
                mCachedParams[Engine.PARAM_POSITION_PITCH + 1] = String.valueOf(p);
                result = SUCCESS;
            }
        } catch (NullPointerException e) {
            // TTS died; restart it.
            Log.e(""TextToSpeech.java - setPitch"", ""NullPointerException"");
            e.printStackTrace();
            mStarted = false;
            initTts();
        } catch (IllegalStateException e) {
            // TTS died; restart it.
            Log.e(""TextToSpeech.java - setPitch"", ""IllegalStateException"");
            e.printStackTrace();
            mStarted = false;
            initTts();
        } finally {
            return result;
        }
    }
}",1,"/**
 * Sets the speech pitch for the TextToSpeech engine.
 *
 * This has no effect on any pre-recorded speech.
 *
 * @param pitch
 * The pitch for the TextToSpeech engine. 1 is the normal pitch,
 * lower values lower the tone of the synthesized voice,
 * greater values increase it.
 *
 * @return Code indicating success or failure. See {@link #ERROR} and {@link #SUCCESS}.
 */
","/**
 * Sets the speech pitch for the TextToSpeech engine.
 *
 * This has no effect on any pre-recorded speech.
 *
 * @param pitch
 * The pitch for the TextToSpeech engine. 1 is the normal pitch,
 * lower values lower the tone of the synthesized voice,
 * greater values increase it.
 *
 * @return Code indicating success or failure. See {@link #ERROR} and {@link #SUCCESS}.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,4",1,"The return statement and the calculation related to parameter 'pitch' have changed, so the code change type is 1,4.","As the return value potentially changes due to the update in control statement and return statement. Therefore, the CI type is 1."
636,"<android.provider.Settings.NameValueCache: String getString(ContentResolver,String)>",7,8,"<android.provider.Settings.NameValueCache: String getString(ContentResolver,String)>","<android.provider.Settings.NameValueCache: String getString(ContentResolver,String)>",0,"{
    long newValuesVersion = SystemProperties.getLong(mVersionSystemProperty, 0);
    if (mValuesVersion != newValuesVersion) {
        mValues.clear();
        mValuesVersion = newValuesVersion;
    }
    if (!mValues.containsKey(name)) {
        String value = null;
        Cursor c = null;
        try {
            c = cr.query(mUri, new String[] { Settings.NameValueTable.VALUE }, Settings.NameValueTable.NAME + ""=?"", new String[] { name }, null);
            if (c != null && c.moveToNext())
                value = c.getString(0);
            mValues.put(name, value);
        } catch (SQLException e) {
            // SQL error: return null, but don't cache it.
            Log.w(TAG, ""Can't get key "" + name + "" from "" + mUri, e);
        } finally {
            if (c != null)
                c.close();
        }
        return value;
    } else {
        return mValues.get(name);
    }
}","{
    long newValuesVersion = SystemProperties.getLong(mVersionSystemProperty, 0);
    synchronized (this) {
        if (mValuesVersion != newValuesVersion) {
            if (LOCAL_LOGV) {
                Log.v(TAG, ""invalidate ["" + mUri.getLastPathSegment() + ""]: current "" + newValuesVersion + "" != cached "" + mValuesVersion);
            }
            mValues.clear();
            mValuesVersion = newValuesVersion;
        }
        if (mValues.containsKey(name)) {
            // Could be null, that's OK -- negative caching
            return mValues.get(name);
        }
    }
    IContentProvider cp = null;
    synchronized (this) {
        cp = mContentProvider;
        if (cp == null) {
            cp = mContentProvider = cr.acquireProvider(mUri.getAuthority());
        }
    }
    // interface.
    if (mCallCommand != null) {
        try {
            Bundle b = cp.call(mCallCommand, name, null);
            if (b != null) {
                String value = b.getPairValue();
                synchronized (this) {
                    mValues.put(name, value);
                }
                return value;
            }
        // If the response Bundle is null, we fall through
        // to the query interface below.
        } catch (RemoteException e) {
        // Not supported by the remote side?  Fall through
        // to query().
        }
    }
    Cursor c = null;
    try {
        c = cp.query(mUri, SELECT_VALUE, NAME_EQ_PLACEHOLDER, new String[] { name }, null);
        if (c == null) {
            Log.w(TAG, ""Can't get key "" + name + "" from "" + mUri);
            return null;
        }
        String value = c.moveToNext() ? c.getString(0) : null;
        synchronized (this) {
            mValues.put(name, value);
        }
        if (LOCAL_LOGV) {
            Log.v(TAG, ""cache miss ["" + mUri.getLastPathSegment() + ""]: "" + name + "" = "" + (value == null ? ""(null)"" : value));
        }
        return value;
    } catch (RemoteException e) {
        Log.w(TAG, ""Can't get key "" + name + "" from "" + mUri, e);
        // Return null, but don't cache it.
        return null;
    } finally {
        if (c != null)
            c.close();
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"1,2,3,4,5","1,2","The return statement has changed due to the change in conditional check (if (mValues.containsKey(name)) is inside synchronized block in Late_Implementation, the way exception is caught (the introduction of RemoteException), the introduction of the 'synchronized' keyword, 'cp' object and the new 'mCallCommand' object which has interacted with new method call 'cp.call()' thereby changing the control dependencies (condtitional checks and calls), and furthermore the dependent APIs (method names and types). So the code change type is 1,2,3,4 and 5.","The restructured conditional checks along with the introduction of new exception (RemoteException) may lead to the potential different returned values and exception handlings, which results in compatibility issue type 1 and 2."
637,<android.accounts.AccountManager.GetAuthTokenByTypeAndFeaturesTask: void run(AccountManagerFuture<Bundle>)>,7,8,<android.accounts.AccountManager.GetAuthTokenByTypeAndFeaturesTask: void run(AccountManagerFuture<Bundle>)>,<android.accounts.AccountManager.GetAuthTokenByTypeAndFeaturesTask: void run(AccountManagerFuture<Bundle>)>,0,"{
    try {
        set(future.getResult());
    } catch (OperationCanceledException e) {
        cancel(true);
    } catch (IOException e) {
        setException(e);
    } catch (AuthenticatorException e) {
        setException(e);
    }
}","{
    try {
        final Bundle result = future.getResult();
        if (mNumAccounts == 0) {
            final String accountName = result.getString(KEY_ACCOUNT_NAME);
            final String accountType = result.getString(KEY_ACCOUNT_TYPE);
            if (TextUtils.isEmpty(accountName) || TextUtils.isEmpty(accountType)) {
                setException(new AuthenticatorException(""account not in result""));
                return;
            }
            final Account account = new Account(accountName, accountType);
            mNumAccounts = 1;
            getAuthToken(account, mAuthTokenType, null, /* options */
            mActivity, mMyCallback, mHandler);
            return;
        }
        set(result);
    } catch (OperationCanceledException e) {
        cancel(true);
    } catch (IOException e) {
        setException(e);
    } catch (AuthenticatorException e) {
        setException(e);
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"1,3,4","1,2","The new version introduces a new 'if' conditional structure and corresponding new statements, which makes the control dependency change (Type 3). Additionally, a new variable 'result' is initialized and directly used in the new 'if' block which changes some statements (Type 4). Moreover, a new return statement is introduced under the new 'if' block, making the return statement change (Type 1).","Due to the new 'if' block and return statement, some exceptions may not be thrown (Type 2), and the return statement could potentially return different values (Type 1). Thus, the change could lead to compatibility issues."
638,"<android.text.Layout: void draw(Canvas,Path,Paint,int)>",7,8,"<android.text.Layout: void draw(Canvas,Path,Paint,int)>","<android.text.Layout: void draw(Canvas,Path,Paint,int)>",0,"{
    int dtop, dbottom;
    synchronized (sTempRect) {
        if (!c.getClipBounds(sTempRect)) {
            return;
        }
        dtop = sTempRect.top;
        dbottom = sTempRect.bottom;
    }
    TextPaint paint = mPaint;
    int top = 0;
    // getLineBottom(getLineCount() -1) just calls getLineTop(getLineCount)
    int bottom = getLineTop(getLineCount());
    if (dtop > top) {
        top = dtop;
    }
    if (dbottom < bottom) {
        bottom = dbottom;
    }
    int first = getLineForVertical(top);
    int last = getLineForVertical(bottom);
    int previousLineBottom = getLineTop(first);
    int previousLineEnd = getLineStart(first);
    CharSequence buf = mText;
    ParagraphStyle[] nospans = ArrayUtils.emptyArray(ParagraphStyle.class);
    ParagraphStyle[] spans = nospans;
    int spanend = 0;
    int textLength = 0;
    boolean spannedText = mSpannedText;
    if (spannedText) {
        spanend = 0;
        textLength = buf.length();
        for (int i = first; i <= last; i++) {
            int start = previousLineEnd;
            int end = getLineStart(i + 1);
            previousLineEnd = end;
            int ltop = previousLineBottom;
            int lbottom = getLineTop(i + 1);
            previousLineBottom = lbottom;
            int lbaseline = lbottom - getLineDescent(i);
            if (start >= spanend) {
                Spanned sp = (Spanned) buf;
                spanend = sp.nextSpanTransition(start, textLength, LineBackgroundSpan.class);
                spans = sp.getSpans(start, spanend, LineBackgroundSpan.class);
            }
            for (int n = 0; n < spans.length; n++) {
                LineBackgroundSpan back = (LineBackgroundSpan) spans[n];
                back.drawBackground(c, paint, 0, mWidth, ltop, lbaseline, lbottom, buf, start, end, i);
            }
        }
        // reset to their original values
        spanend = 0;
        previousLineBottom = getLineTop(first);
        previousLineEnd = getLineStart(first);
        spans = nospans;
    }
    // a non-spanned transformation of a spanned editing buffer.
    if (highlight != null) {
        if (cursorOffsetVertical != 0) {
            c.translate(0, cursorOffsetVertical);
        }
        c.drawPath(highlight, highlightpaint);
        if (cursorOffsetVertical != 0) {
            c.translate(0, -cursorOffsetVertical);
        }
    }
    Alignment align = mAlignment;
    for (int i = first; i <= last; i++) {
        int start = previousLineEnd;
        previousLineEnd = getLineStart(i + 1);
        int end = getLineVisibleEnd(i, start, previousLineEnd);
        int ltop = previousLineBottom;
        int lbottom = getLineTop(i + 1);
        previousLineBottom = lbottom;
        int lbaseline = lbottom - getLineDescent(i);
        boolean par = false;
        if (spannedText) {
            if (start == 0 || buf.charAt(start - 1) == '\n') {
                par = true;
            }
            if (start >= spanend) {
                Spanned sp = (Spanned) buf;
                spanend = sp.nextSpanTransition(start, textLength, ParagraphStyle.class);
                spans = sp.getSpans(start, spanend, ParagraphStyle.class);
                align = mAlignment;
                for (int n = spans.length - 1; n >= 0; n--) {
                    if (spans[n] instanceof AlignmentSpan) {
                        align = ((AlignmentSpan) spans[n]).getAlignment();
                        break;
                    }
                }
            }
        }
        int dir = getParagraphDirection(i);
        int left = 0;
        int right = mWidth;
        if (spannedText) {
            final int length = spans.length;
            for (int n = 0; n < length; n++) {
                if (spans[n] instanceof LeadingMarginSpan) {
                    LeadingMarginSpan margin = (LeadingMarginSpan) spans[n];
                    if (dir == DIR_RIGHT_TO_LEFT) {
                        margin.drawLeadingMargin(c, paint, right, dir, ltop, lbaseline, lbottom, buf, start, end, par, this);
                        right -= margin.getLeadingMargin(par);
                    } else {
                        margin.drawLeadingMargin(c, paint, left, dir, ltop, lbaseline, lbottom, buf, start, end, par, this);
                        left += margin.getLeadingMargin(par);
                    }
                }
            }
        }
        int x;
        if (align == Alignment.ALIGN_NORMAL) {
            if (dir == DIR_LEFT_TO_RIGHT) {
                x = left;
            } else {
                x = right;
            }
        } else {
            int max = (int) getLineMax(i, spans, false);
            if (align == Alignment.ALIGN_OPPOSITE) {
                if (dir == DIR_RIGHT_TO_LEFT) {
                    x = left + max;
                } else {
                    x = right - max;
                }
            } else {
                // Alignment.ALIGN_CENTER
                max = max & ~1;
                int half = (right - left - max) >> 1;
                if (dir == DIR_RIGHT_TO_LEFT) {
                    x = right - half;
                } else {
                    x = left + half;
                }
            }
        }
        Directions directions = getLineDirections(i);
        boolean hasTab = getLineContainsTab(i);
        if (directions == DIRS_ALL_LEFT_TO_RIGHT && !spannedText && !hasTab) {
            if (DEBUG) {
                Assert.assertTrue(dir == DIR_LEFT_TO_RIGHT);
                Assert.assertNotNull(c);
            }
            c.drawText(buf, start, end, x, lbaseline, paint);
        } else {
            drawText(c, buf, start, end, dir, directions, x, ltop, lbaseline, lbottom, paint, mWorkPaint, hasTab, spans);
        }
    }
}","{
    int dtop, dbottom;
    synchronized (sTempRect) {
        if (!c.getClipBounds(sTempRect)) {
            return;
        }
        dtop = sTempRect.top;
        dbottom = sTempRect.bottom;
    }
    int top = 0;
    int bottom = getLineTop(getLineCount());
    if (dtop > top) {
        top = dtop;
    }
    if (dbottom < bottom) {
        bottom = dbottom;
    }
    int first = getLineForVertical(top);
    int last = getLineForVertical(bottom);
    int previousLineBottom = getLineTop(first);
    int previousLineEnd = getLineStart(first);
    TextPaint paint = mPaint;
    CharSequence buf = mText;
    int width = mWidth;
    boolean spannedText = mSpannedText;
    ParagraphStyle[] spans = NO_PARA_SPANS;
    int spanend = 0;
    int textLength = 0;
    // the layout or line.  XXX: Should they?
    if (spannedText) {
        textLength = buf.length();
        for (int i = first; i <= last; i++) {
            int start = previousLineEnd;
            int end = getLineStart(i + 1);
            previousLineEnd = end;
            int ltop = previousLineBottom;
            int lbottom = getLineTop(i + 1);
            previousLineBottom = lbottom;
            int lbaseline = lbottom - getLineDescent(i);
            if (start >= spanend) {
                Spanned sp = (Spanned) buf;
                spanend = sp.nextSpanTransition(start, textLength, LineBackgroundSpan.class);
                spans = sp.getSpans(start, spanend, LineBackgroundSpan.class);
            }
            for (int n = 0; n < spans.length; n++) {
                LineBackgroundSpan back = (LineBackgroundSpan) spans[n];
                back.drawBackground(c, paint, 0, width, ltop, lbaseline, lbottom, buf, start, end, i);
            }
        }
        // reset to their original values
        spanend = 0;
        previousLineBottom = getLineTop(first);
        previousLineEnd = getLineStart(first);
        spans = NO_PARA_SPANS;
    }
    // a non-spanned transformation of a spanned editing buffer.
    if (highlight != null) {
        if (cursorOffsetVertical != 0) {
            c.translate(0, cursorOffsetVertical);
        }
        c.drawPath(highlight, highlightPaint);
        if (cursorOffsetVertical != 0) {
            c.translate(0, -cursorOffsetVertical);
        }
    }
    Alignment align = mAlignment;
    // line's descent.
    for (int i = first; i <= last; i++) {
        int start = previousLineEnd;
        previousLineEnd = getLineStart(i + 1);
        int end = getLineVisibleEnd(i, start, previousLineEnd);
        int ltop = previousLineBottom;
        int lbottom = getLineTop(i + 1);
        previousLineBottom = lbottom;
        int lbaseline = lbottom - getLineDescent(i);
        boolean isFirstParaLine = false;
        if (spannedText) {
            if (start == 0 || buf.charAt(start - 1) == '\n') {
                isFirstParaLine = true;
            }
            // Last alignment style wins.
            if (start >= spanend) {
                Spanned sp = (Spanned) buf;
                spanend = sp.nextSpanTransition(start, textLength, ParagraphStyle.class);
                spans = sp.getSpans(start, spanend, ParagraphStyle.class);
                align = mAlignment;
                for (int n = spans.length - 1; n >= 0; n--) {
                    if (spans[n] instanceof AlignmentSpan) {
                        align = ((AlignmentSpan) spans[n]).getAlignment();
                        break;
                    }
                }
            }
        }
        int dir = getParagraphDirection(i);
        int left = 0;
        int right = mWidth;
        // to the paragraph direction of the line.
        if (spannedText) {
            final int length = spans.length;
            for (int n = 0; n < length; n++) {
                if (spans[n] instanceof LeadingMarginSpan) {
                    LeadingMarginSpan margin = (LeadingMarginSpan) spans[n];
                    if (dir == DIR_RIGHT_TO_LEFT) {
                        margin.drawLeadingMargin(c, paint, right, dir, ltop, lbaseline, lbottom, buf, start, end, isFirstParaLine, this);
                        right -= margin.getLeadingMargin(isFirstParaLine);
                    } else {
                        margin.drawLeadingMargin(c, paint, left, dir, ltop, lbaseline, lbottom, buf, start, end, isFirstParaLine, this);
                        boolean useMargin = isFirstParaLine;
                        if (margin instanceof LeadingMarginSpan.LeadingMarginSpan2) {
                            int count = ((LeadingMarginSpan.LeadingMarginSpan2) margin).getLeadingMarginLineCount();
                            useMargin = count > i;
                        }
                        left += margin.getLeadingMargin(useMargin);
                    }
                }
            }
        }
        // Adjust the point at which to start rendering depending on the
        // alignment of the paragraph.
        int x;
        if (align == Alignment.ALIGN_NORMAL) {
            if (dir == DIR_LEFT_TO_RIGHT) {
                x = left;
            } else {
                x = right;
            }
        } else {
            int max = (int) getLineMax(i, spans, false);
            if (align == Alignment.ALIGN_OPPOSITE) {
                if (dir == DIR_RIGHT_TO_LEFT) {
                    x = left + max;
                } else {
                    x = right - max;
                }
            } else {
                // Alignment.ALIGN_CENTER
                max = max & ~1;
                int half = (right - left - max) >> 1;
                if (dir == DIR_RIGHT_TO_LEFT) {
                    x = right - half;
                } else {
                    x = left + half;
                }
            }
        }
        Directions directions = getLineDirections(i);
        boolean hasTab = getLineContainsTab(i);
        if (directions == DIRS_ALL_LEFT_TO_RIGHT && !spannedText && !hasTab) {
            if (DEBUG) {
                Assert.assertTrue(dir == DIR_LEFT_TO_RIGHT);
                Assert.assertNotNull(c);
            }
            // XXX: assumes there's nothing additional to be done
            c.drawText(buf, start, end, x, lbaseline, paint);
        } else {
            drawText(c, buf, start, end, dir, directions, x, ltop, lbaseline, lbottom, paint, mWorkPaint, hasTab, spans);
        }
    }
}",1,"/**
 * Draw the specified rectangle from this Layout on the specified Canvas,
 * with the specified path drawn between the background and the text.
 */
","/**
 * Draw this Layout on the specified canvas, with the highlight path drawn
 * between the background and the text.
 *
 * @param c the canvas
 * @param highlight the path of the highlight or cursor; can be null
 * @param highlightPaint the paint for the highlight
 * @param cursorOffsetVertical the amount to temporarily translate the
 * canvas while rendering the highlight
 */
",-1,,,-1,-1,-1,-1,-1,-1,,,,
639,<android.content.res.AssetManager: int createTheme()>,7,8,<android.content.res.AssetManager: int createTheme()>,<android.content.res.AssetManager: int createTheme()>,0,"{
    synchronized (this) {
        if (!mOpen) {
            throw new RuntimeException(""Assetmanager has been closed"");
        }
        mNumRefs++;
        return newTheme();
    }
}","{
    synchronized (this) {
        if (!mOpen) {
            throw new RuntimeException(""Assetmanager has been closed"");
        }
        int res = newTheme();
        incRefsLocked(res);
        return res;
    }
}",1,"/*package*/
","/*package*/
",-1,,,-1,-1,-1,-1,-1,-1,"1,4",1,"The statement 'mNumRefs++' changed to 'incRefsLocked(res)' and return statement has changed due to change in initialization of 'res', so the code change type is 1 and 4.","The change of return statement and 'incRefsLocked(res)' could lead to different behaviours when the API is invoked, so the CI type is 1."
640,"<android.server.BluetoothService: void dump(FileDescriptor,PrintWriter,String[])>",7,8,"<android.server.BluetoothService: void dump(FileDescriptor,PrintWriter,String[])>","<android.server.BluetoothService: void dump(FileDescriptor,PrintWriter,String[])>",0,"{
    switch(mBluetoothState) {
        case BluetoothAdapter.STATE_OFF:
            pw.println(""Bluetooth OFF\n"");
            return;
        case BluetoothAdapter.STATE_TURNING_ON:
            pw.println(""Bluetooth TURNING ON\n"");
            return;
        case BluetoothAdapter.STATE_TURNING_OFF:
            pw.println(""Bluetooth TURNING OFF\n"");
            return;
        case BluetoothAdapter.STATE_ON:
            pw.println(""Bluetooth ON\n"");
    }
    pw.println(""mIsAirplaneSensitive = "" + mIsAirplaneSensitive);
    pw.println(""Local address = "" + getAddress());
    pw.println(""Local name = "" + getName());
    pw.println(""isDiscovering() = "" + isDiscovering());
    BluetoothHeadset headset = new BluetoothHeadset(mContext, null);
    pw.println(""\n--Known devices--"");
    for (String address : mDeviceProperties.keySet()) {
        int bondState = mBondState.getBondState(address);
        pw.printf(""%s %10s (%d) %s\n"", address, toBondStateString(bondState), mBondState.getAttempt(address), getRemoteName(address));
        Map<ParcelUuid, Integer> uuidChannels = mDeviceServiceChannelCache.get(address);
        if (uuidChannels == null) {
            pw.println(""\tuuids = null"");
        } else {
            for (ParcelUuid uuid : uuidChannels.keySet()) {
                Integer channel = uuidChannels.get(uuid);
                if (channel == null) {
                    pw.println(""\t"" + uuid);
                } else {
                    pw.println(""\t"" + uuid + "" RFCOMM channel = "" + channel);
                }
            }
        }
        for (RemoteService service : mUuidCallbackTracker.keySet()) {
            if (service.address.equals(address)) {
                pw.println(""\tPENDING CALLBACK: "" + service.uuid);
            }
        }
    }
    String value = getProperty(""Devices"");
    String[] devicesObjectPath = null;
    if (value != null) {
        devicesObjectPath = value.split("","");
    }
    pw.println(""\n--ACL connected devices--"");
    if (devicesObjectPath != null) {
        for (String device : devicesObjectPath) {
            pw.println(getAddressFromObjectPath(device));
        }
    }
    // Rather not do this from here, but no-where else and I need this
    // dump
    pw.println(""\n--Headset Service--"");
    switch(headset.getState()) {
        case BluetoothHeadset.STATE_DISCONNECTED:
            pw.println(""getState() = STATE_DISCONNECTED"");
            break;
        case BluetoothHeadset.STATE_CONNECTING:
            pw.println(""getState() = STATE_CONNECTING"");
            break;
        case BluetoothHeadset.STATE_CONNECTED:
            pw.println(""getState() = STATE_CONNECTED"");
            break;
        case BluetoothHeadset.STATE_ERROR:
            pw.println(""getState() = STATE_ERROR"");
            break;
    }
    pw.println(""\ngetCurrentHeadset() = "" + headset.getCurrentHeadset());
    pw.println(""getBatteryUsageHint() = "" + headset.getBatteryUsageHint());
    headset.close();
    pw.println(""\n--Application Service Records--"");
    for (Integer handle : mServiceRecordToPid.keySet()) {
        Integer pid = mServiceRecordToPid.get(handle);
        pw.println(""\tpid "" + pid + "" handle "" + Integer.toHexString(handle));
    }
}","{
    switch(mBluetoothState) {
        case BluetoothAdapter.STATE_OFF:
            pw.println(""Bluetooth OFF\n"");
            return;
        case BluetoothAdapter.STATE_TURNING_ON:
            pw.println(""Bluetooth TURNING ON\n"");
            return;
        case BluetoothAdapter.STATE_TURNING_OFF:
            pw.println(""Bluetooth TURNING OFF\n"");
            return;
        case BluetoothAdapter.STATE_ON:
            pw.println(""Bluetooth ON\n"");
    }
    pw.println(""mIsAirplaneSensitive = "" + mIsAirplaneSensitive);
    pw.println(""mIsAirplaneToggleable = "" + mIsAirplaneToggleable);
    pw.println(""Local address = "" + getAddress());
    pw.println(""Local name = "" + getName());
    pw.println(""isDiscovering() = "" + isDiscovering());
    BluetoothHeadset headset = new BluetoothHeadset(mContext, null);
    pw.println(""\n--Known devices--"");
    for (String address : mDeviceProperties.keySet()) {
        int bondState = mBondState.getBondState(address);
        pw.printf(""%s %10s (%d) %s\n"", address, toBondStateString(bondState), mBondState.getAttempt(address), getRemoteName(address));
        Map<ParcelUuid, Integer> uuidChannels = mDeviceServiceChannelCache.get(address);
        if (uuidChannels == null) {
            pw.println(""\tuuids = null"");
        } else {
            for (ParcelUuid uuid : uuidChannels.keySet()) {
                Integer channel = uuidChannels.get(uuid);
                if (channel == null) {
                    pw.println(""\t"" + uuid);
                } else {
                    pw.println(""\t"" + uuid + "" RFCOMM channel = "" + channel);
                }
            }
        }
        for (RemoteService service : mUuidCallbackTracker.keySet()) {
            if (service.address.equals(address)) {
                pw.println(""\tPENDING CALLBACK: "" + service.uuid);
            }
        }
    }
    String value = getProperty(""Devices"");
    String[] devicesObjectPath = null;
    if (value != null) {
        devicesObjectPath = value.split("","");
    }
    pw.println(""\n--ACL connected devices--"");
    if (devicesObjectPath != null) {
        for (String device : devicesObjectPath) {
            pw.println(getAddressFromObjectPath(device));
        }
    }
    // Rather not do this from here, but no-where else and I need this
    // dump
    pw.println(""\n--Headset Service--"");
    switch(headset.getState()) {
        case BluetoothHeadset.STATE_DISCONNECTED:
            pw.println(""getState() = STATE_DISCONNECTED"");
            break;
        case BluetoothHeadset.STATE_CONNECTING:
            pw.println(""getState() = STATE_CONNECTING"");
            break;
        case BluetoothHeadset.STATE_CONNECTED:
            pw.println(""getState() = STATE_CONNECTED"");
            break;
        case BluetoothHeadset.STATE_ERROR:
            pw.println(""getState() = STATE_ERROR"");
            break;
    }
    pw.println(""\ngetCurrentHeadset() = "" + headset.getCurrentHeadset());
    pw.println(""getBatteryUsageHint() = "" + headset.getBatteryUsageHint());
    headset.close();
    pw.println(""\n--Application Service Records--"");
    for (Integer handle : mServiceRecordToPid.keySet()) {
        Integer pid = mServiceRecordToPid.get(handle);
        pw.println(""\tpid "" + pid + "" handle "" + Integer.toHexString(handle));
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"Only a new print statement has been introduced (pw.println(""mIsAirplaneToggleable = "" + mIsAirplaneToggleable);), so the change type is 4.","As the changes are only some print statements, which won't affect the return statement or exception handling, no compatibility issue arises out of these changes, thus the CI type is 0."
642,"<android.accounts.AbstractAccountAuthenticator.Transport: void addAccount(IAccountAuthenticatorResponse,String,String,String[],Bundle)>",7,8,"<android.accounts.AbstractAccountAuthenticator.Transport: void addAccount(IAccountAuthenticatorResponse,String,String,String[],Bundle)>","<android.accounts.AbstractAccountAuthenticator.Transport: void addAccount(IAccountAuthenticatorResponse,String,String,String[],Bundle)>",0,"{
    checkBinderPermission();
    try {
        final Bundle result = AbstractAccountAuthenticator.this.addAccount(new AccountAuthenticatorResponse(response), accountType, authTokenType, requiredFeatures, options);
        if (result != null) {
            response.onResult(result);
        }
    } catch (NetworkErrorException e) {
        response.onError(AccountManager.ERROR_CODE_NETWORK_ERROR, e.getMessage());
    } catch (UnsupportedOperationException e) {
        response.onError(AccountManager.ERROR_CODE_UNSUPPORTED_OPERATION, ""addAccount not supported"");
    }
}","{
    if (Log.isLoggable(TAG, Log.VERBOSE)) {
        Log.v(TAG, ""addAccount: accountType "" + accountType + "", authTokenType "" + authTokenType + "", features "" + (features == null ? ""[]"" : Arrays.toString(features)));
    }
    checkBinderPermission();
    try {
        final Bundle result = AbstractAccountAuthenticator.this.addAccount(new AccountAuthenticatorResponse(response), accountType, authTokenType, features, options);
        if (Log.isLoggable(TAG, Log.VERBOSE)) {
            // force it to be unparcelled
            result.keySet();
            Log.v(TAG, ""addAccount: result "" + AccountManager.sanitizeResult(result));
        }
        if (result != null) {
            response.onResult(result);
        }
    } catch (NetworkErrorException e) {
        if (Log.isLoggable(TAG, Log.VERBOSE)) {
            Log.v(TAG, ""addAccount"", e);
        }
        response.onError(AccountManager.ERROR_CODE_NETWORK_ERROR, e.getMessage());
    } catch (UnsupportedOperationException e) {
        if (Log.isLoggable(TAG, Log.VERBOSE)) {
            Log.v(TAG, ""addAccount"", e);
        }
        response.onError(AccountManager.ERROR_CODE_UNSUPPORTED_OPERATION, ""addAccount not supported"");
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,4,0,"Some logging statements have been added in the late version, but those do not modify the essential behavior of the function. However, it does change what the function does in essence, thus the change type is 4.","Although new statements have been added in the late version, these changes are only adding log statements that have no impact on the return value of the function or any exceptions it might throw, so no Compatibility Issue exists."
643,<android.webkit.WebViewCore: void contentDraw()>,7,8,<android.webkit.WebViewCore: void contentDraw()>,<android.webkit.WebViewCore: void contentDraw()>,0,"{
    // the first layout
    if (mCurrentViewWidth == 0 || !mBrowserFrame.firstLayoutDone()) {
        return;
    }
    // only fire an event if this is our first request
    synchronized (this) {
        if (mDrawIsPaused || mDrawIsScheduled) {
            return;
        }
        mDrawIsScheduled = true;
        mEventHub.sendMessage(Message.obtain(null, EventHub.WEBKIT_DRAW));
    }
}","{
    // the first layout
    if (mCurrentViewWidth == 0 || !mBrowserFrame.firstLayoutDone()) {
        return;
    }
    // only fire an event if this is our first request
    synchronized (this) {
        if (mDrawIsScheduled)
            return;
        mDrawIsScheduled = true;
        if (mDrawIsPaused)
            return;
        mEventHub.sendMessage(Message.obtain(null, EventHub.WEBKIT_DRAW));
    }
}",1,"/* package */
","/* package */
",-1,,,-1,-1,-1,-1,-1,-1,3,1,"The control condition ""mDrawIsPaused || mDrawIsScheduled"" has been split into two separate conditions ""mDrawIsScheduled"" and ""mDrawIsPaused"". This change type is 3, which is a change in control dependency.","Splitting the condition into two separate conditions alters the sequence of checks. This means that in the late version, even if 'mDrawIsScheduled'==true, the system will still check whether 'mDrawIsPaused'==true. This different return point makes the API potentially return at a different code branch, and the CI type is 1."
646,"<android.view.ViewGroup: int getChildMeasureSpec(int,int,int)>",7,8,"<android.view.ViewGroup: int getChildMeasureSpec(int,int,int)>","<android.view.ViewGroup: int getChildMeasureSpec(int,int,int)>",0,"{
    int specMode = MeasureSpec.getMode(spec);
    int specSize = MeasureSpec.getSize(spec);
    int size = Math.max(0, specSize - padding);
    int resultSize = 0;
    int resultMode = 0;
    switch(specMode) {
        // Parent has imposed an exact size on us
        case MeasureSpec.EXACTLY:
            if (childDimension >= 0) {
                resultSize = childDimension;
                resultMode = MeasureSpec.EXACTLY;
            } else if (childDimension == LayoutParams.FILL_PARENT) {
                // Child wants to be our size. So be it.
                resultSize = size;
                resultMode = MeasureSpec.EXACTLY;
            } else if (childDimension == LayoutParams.WRAP_CONTENT) {
                // Child wants to determine its own size. It can't be
                // bigger than us.
                resultSize = size;
                resultMode = MeasureSpec.AT_MOST;
            }
            break;
        // Parent has imposed a maximum size on us
        case MeasureSpec.AT_MOST:
            if (childDimension >= 0) {
                // Child wants a specific size... so be it
                resultSize = childDimension;
                resultMode = MeasureSpec.EXACTLY;
            } else if (childDimension == LayoutParams.FILL_PARENT) {
                // Child wants to be our size, but our size is not fixed.
                // Constrain child to not be bigger than us.
                resultSize = size;
                resultMode = MeasureSpec.AT_MOST;
            } else if (childDimension == LayoutParams.WRAP_CONTENT) {
                // Child wants to determine its own size. It can't be
                // bigger than us.
                resultSize = size;
                resultMode = MeasureSpec.AT_MOST;
            }
            break;
        // Parent asked to see how big we want to be
        case MeasureSpec.UNSPECIFIED:
            if (childDimension >= 0) {
                // Child wants a specific size... let him have it
                resultSize = childDimension;
                resultMode = MeasureSpec.EXACTLY;
            } else if (childDimension == LayoutParams.FILL_PARENT) {
                // Child wants to be our size... find out how big it should
                // be
                resultSize = 0;
                resultMode = MeasureSpec.UNSPECIFIED;
            } else if (childDimension == LayoutParams.WRAP_CONTENT) {
                // Child wants to determine its own size.... find out how
                // big it should be
                resultSize = 0;
                resultMode = MeasureSpec.UNSPECIFIED;
            }
            break;
    }
    return MeasureSpec.makeMeasureSpec(resultSize, resultMode);
}","{
    int specMode = MeasureSpec.getMode(spec);
    int specSize = MeasureSpec.getSize(spec);
    int size = Math.max(0, specSize - padding);
    int resultSize = 0;
    int resultMode = 0;
    switch(specMode) {
        // Parent has imposed an exact size on us
        case MeasureSpec.EXACTLY:
            if (childDimension >= 0) {
                resultSize = childDimension;
                resultMode = MeasureSpec.EXACTLY;
            } else if (childDimension == LayoutParams.MATCH_PARENT) {
                // Child wants to be our size. So be it.
                resultSize = size;
                resultMode = MeasureSpec.EXACTLY;
            } else if (childDimension == LayoutParams.WRAP_CONTENT) {
                // Child wants to determine its own size. It can't be
                // bigger than us.
                resultSize = size;
                resultMode = MeasureSpec.AT_MOST;
            }
            break;
        // Parent has imposed a maximum size on us
        case MeasureSpec.AT_MOST:
            if (childDimension >= 0) {
                // Child wants a specific size... so be it
                resultSize = childDimension;
                resultMode = MeasureSpec.EXACTLY;
            } else if (childDimension == LayoutParams.MATCH_PARENT) {
                // Child wants to be our size, but our size is not fixed.
                // Constrain child to not be bigger than us.
                resultSize = size;
                resultMode = MeasureSpec.AT_MOST;
            } else if (childDimension == LayoutParams.WRAP_CONTENT) {
                // Child wants to determine its own size. It can't be
                // bigger than us.
                resultSize = size;
                resultMode = MeasureSpec.AT_MOST;
            }
            break;
        // Parent asked to see how big we want to be
        case MeasureSpec.UNSPECIFIED:
            if (childDimension >= 0) {
                // Child wants a specific size... let him have it
                resultSize = childDimension;
                resultMode = MeasureSpec.EXACTLY;
            } else if (childDimension == LayoutParams.MATCH_PARENT) {
                // Child wants to be our size... find out how big it should
                // be
                resultSize = 0;
                resultMode = MeasureSpec.UNSPECIFIED;
            } else if (childDimension == LayoutParams.WRAP_CONTENT) {
                // Child wants to determine its own size.... find out how
                // big it should be
                resultSize = 0;
                resultMode = MeasureSpec.UNSPECIFIED;
            }
            break;
    }
    return MeasureSpec.makeMeasureSpec(resultSize, resultMode);
}",1,"/**
 * Does the hard part of measureChildren: figuring out the MeasureSpec to
 * pass to a particular child. This method figures out the right MeasureSpec
 * for one dimension (height or width) of one child view.
 *
 * The goal is to combine information from our MeasureSpec with the
 * LayoutParams of the child to get the best possible results. For example,
 * if the this view knows its size (because its MeasureSpec has a mode of
 * EXACTLY), and the child has indicated in its LayoutParams that it wants
 * to be the same size as the parent, the parent should ask the child to
 * layout given an exact size.
 *
 * @param spec The requirements for this view
 * @param padding The padding of this view for the current dimension and
 * margins, if applicable
 * @param childDimension How big the child wants to be in the current
 * dimension
 * @return a MeasureSpec integer for the child
 */
","/**
 * Does the hard part of measureChildren: figuring out the MeasureSpec to
 * pass to a particular child. This method figures out the right MeasureSpec
 * for one dimension (height or width) of one child view.
 *
 * The goal is to combine information from our MeasureSpec with the
 * LayoutParams of the child to get the best possible results. For example,
 * if the this view knows its size (because its MeasureSpec has a mode of
 * EXACTLY), and the child has indicated in its LayoutParams that it wants
 * to be the same size as the parent, the parent should ask the child to
 * layout given an exact size.
 *
 * @param spec The requirements for this view
 * @param padding The padding of this view for the current dimension and
 * margins, if applicable
 * @param childDimension How big the child wants to be in the current
 * dimension
 * @return a MeasureSpec integer for the child
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",1,"The values checking in the conditions inside the 'switch' statement have been modified, changing from 'LayoutParams.FILL_PARENT' to 'LayoutParams.MATCH_PARENT'. Therefore, the code change types are 3 (Control dependency changed) and 4 (Other statement changed). ","As the modified condition in the control flow could potentially lead to different assignments for 'resultSize' and 'resultMode', the API would return different values with the same input. Thus, the compatibility issue type is 1 (Compatibility Issue caused by potential different return values or types)."
647,"<android.database.sqlite.SQLiteProgram: void bindString(int,String)>",7,8,"<android.database.sqlite.SQLiteProgram: void bindString(int,String)>","<android.database.sqlite.SQLiteProgram: void bindString(int,String)>",0,"{
    if (value == null) {
        throw new IllegalArgumentException(""the bind value at index "" + index + "" is null"");
    }
    acquireReference();
    try {
        native_bind_string(index, value);
    } finally {
        releaseReference();
    }
}","{
    if (value == null) {
        throw new IllegalArgumentException(""the bind value at index "" + index + "" is null"");
    }
    if (!mDatabase.isOpen()) {
        throw new IllegalStateException(""database "" + mDatabase.getPath() + "" already closed"");
    }
    acquireReference();
    try {
        native_bind_string(index, value);
    } finally {
        releaseReference();
    }
}",1,"/**
 * Bind a String value to this statement. The value remains bound until
 * {@link #clearBindings} is called.
 *
 * @param index The 1-based index to the parameter to bind
 * @param value The value to bind
 */
","/**
 * Bind a String value to this statement. The value remains bound until
 * {@link #clearBindings} is called.
 *
 * @param index The 1-based index to the parameter to bind
 * @param value The value to bind
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,3",2,"In the later version, an extra check 'if (!mDatabase.isOpen()) {...}' along with a new thrown exception 'throw new IllegalStateException(""database "" + mDatabase.getPath() + "" already closed"")' is added. This indicates that both exception handling statement and a control dependency have changed, hence the change type is 2,3.","Due to the newly added throw statement, there is an additional scenario that this method can throw an IllegalStateException. So, the late version of the API could potentially throw a different exception. Therefore, the CI type is 2."
648,"<android.gesture.Gesture: void writeToParcel(Parcel,int)>",7,8,"<android.gesture.Gesture: void writeToParcel(Parcel,int)>","<android.gesture.Gesture: void writeToParcel(Parcel,int)>",0,"{
    out.writeLong(mGestureID);
    boolean result = false;
    final ByteArrayOutputStream byteStream = new ByteArrayOutputStream(GestureConstants.IO_BUFFER_SIZE);
    final DataOutputStream outStream = new DataOutputStream(byteStream);
    try {
        serialize(outStream);
        result = true;
    } catch (IOException e) {
        Log.e(GestureConstants.LOG_TAG, ""Error writing Gesture to parcel:"", e);
    } finally {
        GestureUtilities.closeStream(outStream);
        GestureUtilities.closeStream(byteStream);
    }
    if (result) {
        out.writeByteArray(byteStream.toByteArray());
    }
}","{
    out.writeLong(mGestureID);
    boolean result = false;
    final ByteArrayOutputStream byteStream = new ByteArrayOutputStream(GestureConstants.IO_BUFFER_SIZE);
    final DataOutputStream outStream = new DataOutputStream(byteStream);
    try {
        serialize(outStream);
        result = true;
    } catch (IOException e) {
        Log.e(GestureConstants.LOG_TAG, ""Error writing Gesture to parcel:"", e);
    } finally {
        GestureUtils.closeStream(outStream);
        GestureUtils.closeStream(byteStream);
    }
    if (result) {
        out.writeByteArray(byteStream.toByteArray());
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,5,0,"The method name of the dependent API function, which closes the streams, has been changed from GestureUtilities.closeStream() to GestureUtils.closeStream(). Therefore, the code change type is the 5th category, 'Dependent API changed'.","The changed dependency only affects the name of the utility method and not its functionality or the behaviour of the main API. Therefore, this should not result in any compatibility issues, and we classify it under the 0th type, 'No Compatibility Issue exists'. The returned data and exception handling remain the same in both versions."
650,<android.pim.vcard.VCardParser_V30: boolean isValidPropertyName(String)>,7,8,<android.pim.vcard.VCardParser_V30: boolean isValidPropertyName(String)>,<android.pim.vcard.VCardParser_V30: boolean isValidPropertyName(String)>,0,"{
    if (!(sAcceptablePropsWithParam.contains(propertyName) || acceptablePropsWithoutParam.contains(propertyName) || propertyName.startsWith(""X-"")) && !mWarningValueMap.contains(propertyName)) {
        mWarningValueMap.add(propertyName);
        Log.w(LOG_TAG, ""Property name unsupported by vCard 3.0: "" + propertyName);
    }
    return true;
}","{
    if (!(sAcceptablePropsWithParam.contains(propertyName) || acceptablePropsWithoutParam.contains(propertyName) || propertyName.startsWith(""X-"")) && !mUnknownTypeMap.contains(propertyName)) {
        mUnknownTypeMap.add(propertyName);
        Log.w(LOG_TAG, ""Property name unsupported by vCard 3.0: "" + propertyName);
    }
    return true;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"The map name used for storing unsupported propertyName has been changed from mWarningValueMap to mUnknownTypeMap. This is a statement change that does not affect the control dependency, return type/value, exception handling or dependent APIs. Hence, class 4 change is detected.","Even though the map storing unsupported propertyName has been modified, the return type/value, and the exception handling remain the same. Thus, there is no compatibility issue with this change. Hence, class 0 is detected."
651,<android.server.BluetoothService.BondState: boolean hasAutoPairingFailed(String)>,7,8,<android.server.BluetoothService.BondState: boolean hasAutoPairingFailed(String)>,<android.server.BluetoothService.BondState: boolean hasAutoPairingFailed(String)>,0,"{
    return mAutoPairingFailures.contains(address);
}","{
    if (mAutoPairingDynamicAddressBlacklist == null)
        return false;
    return mAutoPairingDynamicAddressBlacklist.contains(address);
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"1, 3",1,"The early version directly returns the result of a contains() method while in the late version, an if control dependency structure is added before the return, thus the code change type is 1, 3.","The new control dependency could potentially lead to different return value. For example, if mAutoPairingDynamicAddressBlacklist is null, the late version of implementation will return false. So the CI type is 1."
652,"<android.widget.SimpleCursorAdapter: void bindView(View,Context,Cursor)>",7,8,"<android.widget.SimpleCursorAdapter: void bindView(View,Context,Cursor)>","<android.widget.SimpleCursorAdapter: void bindView(View,Context,Cursor)>",0,"{
    final View[] holder = mHolders.get(view);
    final ViewBinder binder = mViewBinder;
    final int count = mTo.length;
    final int[] from = mFrom;
    for (int i = 0; i < count; i++) {
        final View v = holder[i];
        if (v != null) {
            boolean bound = false;
            if (binder != null) {
                bound = binder.setViewValue(v, cursor, from[i]);
            }
            if (!bound) {
                String text = cursor.getString(from[i]);
                if (text == null) {
                    text = """";
                }
                if (v instanceof TextView) {
                    setViewText((TextView) v, text);
                } else if (v instanceof ImageView) {
                    setViewImage((ImageView) v, text);
                } else {
                    throw new IllegalStateException(v.getClass().getName() + "" is not a "" + "" view that can be bounds by this SimpleCursorAdapter"");
                }
            }
        }
    }
}","{
    final ViewBinder binder = mViewBinder;
    final int count = mTo.length;
    final int[] from = mFrom;
    final int[] to = mTo;
    for (int i = 0; i < count; i++) {
        final View v = view.findViewById(to[i]);
        if (v != null) {
            boolean bound = false;
            if (binder != null) {
                bound = binder.setViewValue(v, cursor, from[i]);
            }
            if (!bound) {
                String text = cursor.getString(from[i]);
                if (text == null) {
                    text = """";
                }
                if (v instanceof TextView) {
                    setViewText((TextView) v, text);
                } else if (v instanceof ImageView) {
                    setViewImage((ImageView) v, text);
                } else {
                    throw new IllegalStateException(v.getClass().getName() + "" is not a "" + "" view that can be bounds by this SimpleCursorAdapter"");
                }
            }
        }
    }
}",1,"/**
 * Binds all of the field names passed into the ""to"" parameter of the
 * constructor with their corresponding cursor columns as specified in the
 * ""from"" parameter.
 *
 * Binding occurs in two phases. First, if a
 * {@link android.widget.SimpleCursorAdapter.ViewBinder} is available,
 * {@link ViewBinder#setViewValue(android.view.View, android.database.Cursor, int)}
 * is invoked. If the returned value is true, binding has occured. If the
 * returned value is false and the view to bind is a TextView,
 * {@link #setViewText(TextView, String)} is invoked. If the returned value is
 * false and the view to bind is an ImageView,
 * {@link #setViewImage(ImageView, String)} is invoked. If no appropriate
 * binding can be found, an {@link IllegalStateException} is thrown.
 *
 * @throws IllegalStateException if binding cannot occur
 *
 * @see android.widget.CursorAdapter#bindView(android.view.View,
 * android.content.Context, android.database.Cursor)
 * @see #getViewBinder()
 * @see #setViewBinder(android.widget.SimpleCursorAdapter.ViewBinder)
 * @see #setViewImage(ImageView, String)
 * @see #setViewText(TextView, String)
 */
","/**
 * Binds all of the field names passed into the ""to"" parameter of the
 * constructor with their corresponding cursor columns as specified in the
 * ""from"" parameter.
 *
 * Binding occurs in two phases. First, if a
 * {@link android.widget.SimpleCursorAdapter.ViewBinder} is available,
 * {@link ViewBinder#setViewValue(android.view.View, android.database.Cursor, int)}
 * is invoked. If the returned value is true, binding has occured. If the
 * returned value is false and the view to bind is a TextView,
 * {@link #setViewText(TextView, String)} is invoked. If the returned value is
 * false and the view to bind is an ImageView,
 * {@link #setViewImage(ImageView, String)} is invoked. If no appropriate
 * binding can be found, an {@link IllegalStateException} is thrown.
 *
 * @throws IllegalStateException if binding cannot occur
 *
 * @see android.widget.CursorAdapter#bindView(android.view.View,
 * android.content.Context, android.database.Cursor)
 * @see #getViewBinder()
 * @see #setViewBinder(android.widget.SimpleCursorAdapter.ViewBinder)
 * @see #setViewImage(ImageView, String)
 * @see #setViewText(TextView, String)
 */
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,4","1,2","The method of obtaining view 'v' has changed from 'final View v = holder[i];' to 'final View v = view.findViewById(to[i]);'. Also, the initialization statement 'final View[] holder = mHolders.get(view);' has been deleted in the late version. Thus, the code change type is 3,4.","Due to the change of how the variable 'v' is retrieved, the methods 'setViewImage', 'setViewText' and the exception handling could behave differently since they rely on the 'v'. So the CI type is 1,2."
653,<android.app.Dialog: boolean dispatchPopulateAccessibilityEvent(AccessibilityEvent)>,7,8,<android.app.Dialog: boolean dispatchPopulateAccessibilityEvent(AccessibilityEvent)>,<android.app.Dialog: boolean dispatchPopulateAccessibilityEvent(AccessibilityEvent)>,0,"{
    event.setClassName(getClass().getName());
    event.setPackageName(mContext.getPackageName());
    LayoutParams params = getWindow().getAttributes();
    boolean isFullScreen = (params.width == LayoutParams.FILL_PARENT) && (params.height == LayoutParams.FILL_PARENT);
    event.setFullScreen(isFullScreen);
    return false;
}","{
    event.setClassName(getClass().getName());
    event.setPackageName(mContext.getPackageName());
    LayoutParams params = getWindow().getAttributes();
    boolean isFullScreen = (params.width == LayoutParams.MATCH_PARENT) && (params.height == LayoutParams.MATCH_PARENT);
    event.setFullScreen(isFullScreen);
    return false;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,4,0,"Only the operands in the boolean expression have changed from FILL_PARENT to MATCH_PARENT, which represents Other statement changed, so the code change type is 4.","Although there is an operand change in the code, it doesn't affect the return type/value of the API or the exception it can potentially throw, so no Compatibility Issue exists, CI is 0."
654,"<android.speech.tts.TextToSpeech: int speak(String,int,HashMap<String, String>)>",7,8,"<android.speech.tts.TextToSpeech: int speak(String,int,HashMap<String, String>)>","<android.speech.tts.TextToSpeech: int speak(String,int,HashMap<String, String>)>",0,"{
    synchronized (mStartLock) {
        int result = ERROR;
        Log.i(""TTS received: "", text);
        if (!mStarted) {
            return result;
        }
        try {
            if ((params != null) && (!params.isEmpty())) {
                String extra = params.get(Engine.KEY_PARAM_STREAM);
                if (extra != null) {
                    mCachedParams[Engine.PARAM_POSITION_STREAM + 1] = extra;
                }
                extra = params.get(Engine.KEY_PARAM_UTTERANCE_ID);
                if (extra != null) {
                    mCachedParams[Engine.PARAM_POSITION_UTTERANCE_ID + 1] = extra;
                }
            }
            result = mITts.speak(mPackageName, text, queueMode, mCachedParams);
        } catch (RemoteException e) {
            // TTS died; restart it.
            Log.e(""TextToSpeech.java - speak"", ""RemoteException"");
            e.printStackTrace();
            mStarted = false;
            initTts();
        } catch (NullPointerException e) {
            // TTS died; restart it.
            Log.e(""TextToSpeech.java - speak"", ""NullPointerException"");
            e.printStackTrace();
            mStarted = false;
            initTts();
        } catch (IllegalStateException e) {
            // TTS died; restart it.
            Log.e(""TextToSpeech.java - speak"", ""IllegalStateException"");
            e.printStackTrace();
            mStarted = false;
            initTts();
        } finally {
            resetCachedParams();
            return result;
        }
    }
}","{
    synchronized (mStartLock) {
        int result = ERROR;
        Log.i(""TTS received: "", text);
        if (!mStarted) {
            return result;
        }
        try {
            if ((params != null) && (!params.isEmpty())) {
                String extra = params.get(Engine.KEY_PARAM_STREAM);
                if (extra != null) {
                    mCachedParams[Engine.PARAM_POSITION_STREAM + 1] = extra;
                }
                extra = params.get(Engine.KEY_PARAM_UTTERANCE_ID);
                if (extra != null) {
                    mCachedParams[Engine.PARAM_POSITION_UTTERANCE_ID + 1] = extra;
                }
                extra = params.get(Engine.KEY_PARAM_ENGINE);
                if (extra != null) {
                    mCachedParams[Engine.PARAM_POSITION_ENGINE + 1] = extra;
                }
            }
            result = mITts.speak(mPackageName, text, queueMode, mCachedParams);
        } catch (RemoteException e) {
            // TTS died; restart it.
            Log.e(""TextToSpeech.java - speak"", ""RemoteException"");
            e.printStackTrace();
            mStarted = false;
            initTts();
        } catch (NullPointerException e) {
            // TTS died; restart it.
            Log.e(""TextToSpeech.java - speak"", ""NullPointerException"");
            e.printStackTrace();
            mStarted = false;
            initTts();
        } catch (IllegalStateException e) {
            // TTS died; restart it.
            Log.e(""TextToSpeech.java - speak"", ""IllegalStateException"");
            e.printStackTrace();
            mStarted = false;
            initTts();
        } finally {
            resetCachedParams();
            return result;
        }
    }
}",1,"/**
 * Speaks the string using the specified queuing strategy and speech
 * parameters.
 *
 * @param text
 * The string of text to be spoken.
 * @param queueMode
 * The queuing strategy to use.
 * {@link #QUEUE_ADD} or {@link #QUEUE_FLUSH}.
 * @param params
 * The list of parameters to be used. Can be null if no parameters are given.
 * They are specified using a (key, value) pair, where the key can be
 * {@link Engine#KEY_PARAM_STREAM} or
 * {@link Engine#KEY_PARAM_UTTERANCE_ID}.
 *
 * @return Code indicating success or failure. See {@link #ERROR} and {@link #SUCCESS}.
 */
","/**
 * Speaks the string using the specified queuing strategy and speech
 * parameters.
 *
 * @param text
 * The string of text to be spoken.
 * @param queueMode
 * The queuing strategy to use.
 * {@link #QUEUE_ADD} or {@link #QUEUE_FLUSH}.
 * @param params
 * The list of parameters to be used. Can be null if no parameters are given.
 * They are specified using a (key, value) pair, where the key can be
 * {@link Engine#KEY_PARAM_STREAM} or
 * {@link Engine#KEY_PARAM_UTTERANCE_ID}.
 *
 * @return Code indicating success or failure. See {@link #ERROR} and {@link #SUCCESS}.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,1,"A block of code is added where it gets an extra parameter ""Engine.KEY_PARAM_ENGINE"" from the hashmap and stores it in mCachedParams array if it is not null. Therefore, the code change is type 4 - Other statement change.","This can cause a compatibility issue as now the dependent API mITts.speak() is called with a potentially different parameter mCachedParams containing a new field ""Engine.KEY_PARAM_ENGINE"". Therefore, it could potentially return different results leading to compatibility issue of type 1."
655,"<android.util.Log: int i(String,String,Throwable)>",7,8,"<android.util.Log: int i(String,String,Throwable)>","<android.util.Log: int i(String,String,Throwable)>",0,"{
    return println(INFO, tag, msg + '\n' + getStackTraceString(tr));
}","{
    return println_native(LOG_ID_MAIN, INFO, tag, msg + '\n' + getStackTraceString(tr));
}",1,"/**
 * Send a {@link #INFO} log message and log the exception.
 * @param tag Used to identify the source of a log message.  It usually identifies
 * the class or activity where the log call occurs.
 * @param msg The message you would like logged.
 * @param tr An exception to log
 */
","/**
 * Send a {@link #INFO} log message and log the exception.
 * @param tag Used to identify the source of a log message.  It usually identifies
 * the class or activity where the log call occurs.
 * @param msg The message you would like logged.
 * @param tr An exception to log
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The return statement has changed from println(INFO, tag, msg + '\n' + getStackTraceString(tr)) to println_native(LOG_ID_MAIN, INFO, tag, msg + '\n' + getStackTraceString(tr)), so the code change type is 1,5.","The change in the method that produces the return value may lead to different output, hence the CI type is 1."
656,<android.widget.TabWidget: void dispatchDraw(Canvas)>,7,8,<android.widget.TabWidget: void dispatchDraw(Canvas)>,<android.widget.TabWidget: void dispatchDraw(Canvas)>,0,"{
    super.dispatchDraw(canvas);
    // do not draw the bottom strips.
    if (!mDrawBottomStrips) {
        // Skip drawing the bottom strips.
        return;
    }
    View selectedChild = getChildTabViewAt(mSelectedTab);
    mBottomLeftStrip.setState(selectedChild.getDrawableState());
    mBottomRightStrip.setState(selectedChild.getDrawableState());
    if (mStripMoved) {
        // Bounds of the selected tab indicator
        Rect selBounds = new Rect();
        selBounds.left = selectedChild.getLeft();
        selBounds.right = selectedChild.getRight();
        final int myHeight = getHeight();
        mBottomLeftStrip.setBounds(Math.min(0, selBounds.left - mBottomLeftStrip.getIntrinsicWidth()), myHeight - mBottomLeftStrip.getIntrinsicHeight(), selBounds.left, getHeight());
        mBottomRightStrip.setBounds(selBounds.right, myHeight - mBottomRightStrip.getIntrinsicHeight(), Math.max(getWidth(), selBounds.right + mBottomRightStrip.getIntrinsicWidth()), myHeight);
        mStripMoved = false;
    }
    mBottomLeftStrip.draw(canvas);
    mBottomRightStrip.draw(canvas);
}","{
    super.dispatchDraw(canvas);
    // Do nothing if there are no tabs.
    if (getTabCount() == 0)
        return;
    // do not draw the bottom strips.
    if (!mDrawBottomStrips) {
        // Skip drawing the bottom strips.
        return;
    }
    final View selectedChild = getChildTabViewAt(mSelectedTab);
    final Drawable leftStrip = mLeftStrip;
    final Drawable rightStrip = mRightStrip;
    leftStrip.setState(selectedChild.getDrawableState());
    rightStrip.setState(selectedChild.getDrawableState());
    if (mStripMoved) {
        final Rect bounds = mBounds;
        bounds.left = selectedChild.getLeft();
        bounds.right = selectedChild.getRight();
        final int myHeight = getHeight();
        leftStrip.setBounds(Math.min(0, bounds.left - leftStrip.getIntrinsicWidth()), myHeight - leftStrip.getIntrinsicHeight(), bounds.left, myHeight);
        rightStrip.setBounds(bounds.right, myHeight - rightStrip.getIntrinsicHeight(), Math.max(getWidth(), bounds.right + rightStrip.getIntrinsicWidth()), myHeight);
        mStripMoved = false;
    }
    leftStrip.draw(canvas);
    rightStrip.draw(canvas);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,4",1,"There are new control statements introduced in late version `(if (getTabCount() == 0))` and some variable names have been changed in the late version, hence the code change type is 3,4.","The introduction of the new 'if' control statement will potentially leads to a difference in the execution of API. Moreover, the change in the variable names can also potentially cause the API to return a different type of 'Drawable'. Thus, the CI type is 1."
657,<android.view.View: void onRestoreInstanceState(Parcelable)>,7,8,<android.view.View: void onRestoreInstanceState(Parcelable)>,<android.view.View: void onRestoreInstanceState(Parcelable)>,0,"{
    mPrivateFlags |= SAVE_STATE_CALLED;
    if (state != BaseSavedState.EMPTY_STATE && state != null) {
        throw new IllegalArgumentException(""Wrong state class -- expecting View State"");
    }
}","{
    mPrivateFlags |= SAVE_STATE_CALLED;
    if (state != BaseSavedState.EMPTY_STATE && state != null) {
        throw new IllegalArgumentException(""Wrong state class, expecting View State but "" + ""received "" + state.getClass().toString() + "" instead. This usually happens "" + ""when two views of different type have the same id in the same hierarchy. "" + ""This view's id is "" + ViewDebug.resolveId(mContext, getId()) + "". Make sure "" + ""other views do not use the same id."");
    }
}",1,"/**
 * Hook allowing a view to re-apply a representation of its internal state that had previously
 * been generated by {@link #onSaveInstanceState}. This function will never be called with a
 * null state.
 *
 * @param state The frozen state that had previously been returned by
 * {@link #onSaveInstanceState}.
 *
 * @see #onSaveInstanceState
 * @see #restoreHierarchyState
 * @see #dispatchRestoreInstanceState
 */
","/**
 * Hook allowing a view to re-apply a representation of its internal state that had previously
 * been generated by {@link #onSaveInstanceState}. This function will never be called with a
 * null state.
 *
 * @param state The frozen state that had previously been returned by
 * {@link #onSaveInstanceState}.
 *
 * @see #onSaveInstanceState
 * @see #restoreHierarchyState
 * @see #dispatchRestoreInstanceState
 */
",-1,,,-1,-1,-1,-1,-1,-1,2,2,The content of the thrown exception has been changed which leads to a change type of 2.,"When the exception is thrown, the new implementation will provide a more detailed message. Therefore, these two versions may show different behaviours in exception handling, leading to a CI type of 2."
660,<android.content.pm.PackageItemInfo: CharSequence loadLabel(PackageManager)>,7,8,<android.content.pm.PackageItemInfo: CharSequence loadLabel(PackageManager)>,<android.content.pm.PackageItemInfo: CharSequence loadLabel(PackageManager)>,0,"{
    if (nonLocalizedLabel != null) {
        return nonLocalizedLabel;
    }
    if (labelRes != 0) {
        CharSequence label = pm.getText(packageName, labelRes, null);
        if (label != null) {
            return label;
        }
    }
    if (name != null) {
        return name;
    }
    return packageName;
}","{
    if (nonLocalizedLabel != null) {
        return nonLocalizedLabel;
    }
    if (labelRes != 0) {
        CharSequence label = pm.getText(packageName, labelRes, getApplicationInfo());
        if (label != null) {
            return label.toString().trim();
        }
    }
    if (name != null) {
        return name;
    }
    return packageName;
}",1,"/**
 * Retrieve the current textual label associated with this item.  This
 * will call back on the given PackageManager to load the label from
 * the application.
 *
 * @param pm A PackageManager from which the label can be loaded; usually
 * the PackageManager from which you originally retrieved this item.
 *
 * @return Returns a CharSequence containing the item's label.  If the
 * item does not have a label, its name is returned.
 */
","/**
 * Retrieve the current textual label associated with this item.  This
 * will call back on the given PackageManager to load the label from
 * the application.
 *
 * @param pm A PackageManager from which the label can be loaded; usually
 * the PackageManager from which you originally retrieved this item.
 *
 * @return Returns a CharSequence containing the item's label.  If the
 * item does not have a label, its name is returned.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,4,5",1,"The invocation of the pm.getText() method is changed due to the parameter change from 'null' to 'getApplicationInfo()', and the returned value has changed from 'label' to 'label.toString().trim()'. Therefore, the code change types are 1, 4, and 5.","The change in the invocation of the pm.getText() method and the modification of the returned value mean that the API could now return a different value, therefore, the CI type is 1."
