Number,Signature,Early_Version,Late_Version,Early_Signature,Late_Signature,Diff_Signature,Early_Implementation_AST_Node,Late_Implementation_AST_Node,Diff_Implementation,Early_Comment,Late_Comment,Diff_Comment,Early_Annotation,Late_Annotation,Diff_Annotation,Early_Callback,Late_Callback,Diff_Callback,GT_CI_ControlFlow,GT_Change_Type,GT_CI_Type,pred_change,pred_CI,change_description,CI_description
1,<android.os.StrictMode.ThreadPolicy.Builder: Builder permitUnbufferedIo()>,28,29,<android.os.StrictMode.ThreadPolicy.Builder: Builder permitUnbufferedIo()>,<android.os.StrictMode.ThreadPolicy.Builder: Builder permitUnbufferedIo()>,0,"MethodDeclaration(method_body, [Statement({, []), Statement(return disable(DETECT_UNBUFFERED_IO), []), Statement(}, [])])  Statement({, [])  Statement(return disable(DETECT_UNBUFFERED_IO), [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(return disable(DETECT_THREAD_UNBUFFERED_IO), []), Statement(}, [])])  Statement({, [])  Statement(return disable(DETECT_THREAD_UNBUFFERED_IO), [])  Statement(}, [])",1,"/**
 * Disable detection of unbuffered input/output operations.
 */","/**
 * Disable detection of unbuffered input/output operations.
 */",0,,[@NonNull],1,0,0,0,1,1,1,"1,5",1,"The return statement has changed from disable(DETECT_UNBUFFERED_IO) to disable(DETECT_THREAD_UNBUFFERED_IO) and the parameter type of disable() also changed, so the code change type is 1,5.","The change of return statement will make the API potentially return a different value, hence the CI type is 1."
2,<android.app.NotificationManager: int getCurrentInterruptionFilter()>,23,24,<android.app.NotificationManager: int getCurrentInterruptionFilter()>,<android.app.NotificationManager: int getCurrentInterruptionFilter()>,0,"MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(final INotificationManager service, []), Expression(getService(), [])]), Statement(try {, []), MethodCall(return zenModeToInterruptionFilter(service.getZenMode()), [VariableReference(return zenModeToInterruptionFilter(service, []), Expression(), [])]), Statement(} catch (RemoteException e) {, []), MethodCall(Log.e(TAG, ""Unable to talk to notification manager. Woe!"", e), [VariableReference(Log, []), Expression(TAG, []), Expression(""Unable to talk to notification manager. Woe!"", []), Expression(e, [])]), Statement(}, []), Statement(return INTERRUPTION_FILTER_UNKNOWN, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(final INotificationManager service, []), Expression(getService(), [])])    VariableReference(final INotificationManager service, [])    Expression(getService(), [])  Statement(try {, [])  MethodCall(return zenModeToInterruptionFilter(service.getZenMode()), [VariableReference(return zenModeToInterruptionFilter(service, []), Expression(), [])])    VariableReference(return zenModeToInterruptionFilter(service, [])    Expression(), [])  Statement(} catch (RemoteException e) {, [])  MethodCall(Log.e(TAG, ""Unable to talk to notification manager. Woe!"", e), [VariableReference(Log, []), Expression(TAG, []), Expression(""Unable to talk to notification manager. Woe!"", []), Expression(e, [])])    VariableReference(Log, [])    Expression(TAG, [])    Expression(""Unable to talk to notification manager. Woe!"", [])    Expression(e, [])  Statement(}, [])  Statement(return INTERRUPTION_FILTER_UNKNOWN, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(final INotificationManager service, []), Expression(getService(), [])]), Statement(try {, []), MethodCall(return zenModeToInterruptionFilter(service.getZenMode()), [VariableReference(return zenModeToInterruptionFilter(service, []), Expression(), [])]), Statement(} catch (RemoteException e) {, []), MethodCall(throw e.rethrowFromSystemServer(), [VariableReference(throw e, []), Expression(, [])]), Statement(}, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(final INotificationManager service, []), Expression(getService(), [])])    VariableReference(final INotificationManager service, [])    Expression(getService(), [])  Statement(try {, [])  MethodCall(return zenModeToInterruptionFilter(service.getZenMode()), [VariableReference(return zenModeToInterruptionFilter(service, []), Expression(), [])])    VariableReference(return zenModeToInterruptionFilter(service, [])    Expression(), [])  Statement(} catch (RemoteException e) {, [])  MethodCall(throw e.rethrowFromSystemServer(), [VariableReference(throw e, []), Expression(, [])])    VariableReference(throw e, [])    Expression(, [])  Statement(}, [])  Statement(}, [])",1,"/**
 * Gets the current notification interruption filter.
 *
 * <p>
 * The interruption filter defines which notifications are allowed to interrupt the user
 * (e.g. via sound &amp; vibration) and is applied globally.
 * @return One of the INTERRUPTION_FILTER_ constants, or INTERRUPTION_FILTER_UNKNOWN when
 * unavailable.
 *
 * <p>
 * Only available if policy access is granted to this package.
 * See {@link #isNotificationPolicyAccessGranted}.
 */","/**
 * Gets the current notification interruption filter.
 *
 * <p>
 * The interruption filter defines which notifications are allowed to interrupt the user
 * (e.g. via sound &amp; vibration) and is applied globally.
 * @return One of the INTERRUPTION_FILTER_ constants, or INTERRUPTION_FILTER_UNKNOWN when
 * unavailable.
 */",1,,[@InterruptionFilter],0,0,0,0,"1,2","1,2","1,2",2,2,"The exception handling statement has changed, previously the exception was logged via Log.e but in the late version, the exception is rethrown via e.rethrowFromSystemServer(). Thus the change type is 2.","With the change in the exception handling statement, in the scenario of an exception occurrence, the late version of the API may throw a different exception compared to the early version, making the CI type 2."
3,<android.app.NotificationManager: int getCurrentInterruptionFilter()>,25,26,<android.app.NotificationManager: int getCurrentInterruptionFilter()>,<android.app.NotificationManager: int getCurrentInterruptionFilter()>,0,"MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(final INotificationManager service, []), Expression(getService(), [])]), Statement(try {, []), MethodCall(return zenModeToInterruptionFilter(service.getZenMode()), [VariableReference(return zenModeToInterruptionFilter(service, []), Expression(), [])]), Statement(} catch (RemoteException e) {, []), MethodCall(throw e.rethrowFromSystemServer(), [VariableReference(throw e, []), Expression(, [])]), Statement(}, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(final INotificationManager service, []), Expression(getService(), [])])    VariableReference(final INotificationManager service, [])    Expression(getService(), [])  Statement(try {, [])  MethodCall(return zenModeToInterruptionFilter(service.getZenMode()), [VariableReference(return zenModeToInterruptionFilter(service, []), Expression(), [])])    VariableReference(return zenModeToInterruptionFilter(service, [])    Expression(), [])  Statement(} catch (RemoteException e) {, [])  MethodCall(throw e.rethrowFromSystemServer(), [VariableReference(throw e, []), Expression(, [])])    VariableReference(throw e, [])    Expression(, [])  Statement(}, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(final INotificationManager service, []), Expression(getService(), [])]), Statement(try {, []), MethodCall(return zenModeToInterruptionFilter(service.getZenMode()), [VariableReference(return zenModeToInterruptionFilter(service, []), Expression(), [])]), Statement(} catch (RemoteException e) {, []), MethodCall(throw e.rethrowFromSystemServer(), [VariableReference(throw e, []), Expression(, [])]), Statement(}, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(final INotificationManager service, []), Expression(getService(), [])])    VariableReference(final INotificationManager service, [])    Expression(getService(), [])  Statement(try {, [])  MethodCall(return zenModeToInterruptionFilter(service.getZenMode()), [VariableReference(return zenModeToInterruptionFilter(service, []), Expression(), [])])    VariableReference(return zenModeToInterruptionFilter(service, [])    Expression(), [])  Statement(} catch (RemoteException e) {, [])  MethodCall(throw e.rethrowFromSystemServer(), [VariableReference(throw e, []), Expression(, [])])    VariableReference(throw e, [])    Expression(, [])  Statement(}, [])  Statement(}, [])",0,"/**
 * Gets the current notification interruption filter.
 *
 * <p>
 * The interruption filter defines which notifications are allowed to interrupt the user
 * (e.g. via sound &amp; vibration) and is applied globally.
 * @return One of the INTERRUPTION_FILTER_ constants, or INTERRUPTION_FILTER_UNKNOWN when
 * unavailable.
 */","/**
 * Gets the current notification interruption filter.
 * <p>
 * The interruption filter defines which notifications are allowed to
 * interrupt the user (e.g. via sound &amp; vibration) and is applied
 * globally.
 */",1,[@InterruptionFilter],[@InterruptionFilter],0,0,0,0,0,0,0,0,0,"Based on the method implementation and annotations provided, there is no noticeable change between the two versions of the API.","As there is no change in the method behavior and its return type between two versions, no compatibility issue exists."
9,<android.os.Environment: boolean isExternalStorageEmulated()>,27,28,<android.os.Environment: boolean isExternalStorageEmulated()>,<android.os.Environment: boolean isExternalStorageEmulated()>,0,"MethodDeclaration(method_body, [Statement({, []), Statement(if (isStorageDisabled()), []), Statement(return false, []), AssignmentExpression(=, [VariableReference(final File externalDir, []), Expression(sCurrentUser.getExternalDirs()[0], [])]), Statement(return isExternalStorageEmulated(externalDir), []), Statement(}, [])])  Statement({, [])  Statement(if (isStorageDisabled()), [])  Statement(return false, [])  AssignmentExpression(=, [VariableReference(final File externalDir, []), Expression(sCurrentUser.getExternalDirs()[0], [])])    VariableReference(final File externalDir, [])    Expression(sCurrentUser.getExternalDirs()[0], [])  Statement(return isExternalStorageEmulated(externalDir), [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(final File externalDir, []), Expression(sCurrentUser.getExternalDirs()[0], [])]), Statement(return isExternalStorageEmulated(externalDir), []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(final File externalDir, []), Expression(sCurrentUser.getExternalDirs()[0], [])])    VariableReference(final File externalDir, [])    Expression(sCurrentUser.getExternalDirs()[0], [])  Statement(return isExternalStorageEmulated(externalDir), [])  Statement(}, [])",1,"/**
 * Returns whether the primary shared/external storage media is emulated.
 * <p>
 * The contents of emulated storage devices are backed by a private user
 * data partition, which means there is little benefit to apps storing data
 * here instead of the private directories returned by
 * {@link Context#getFilesDir()}, etc.
 * <p>
 * This returns true when emulated storage is backed by either internal
 * storage or an adopted storage device.
 *
 * @see DevicePolicyManager#setStorageEncryption(android.content.ComponentName,
 * boolean)
 */","/**
 * Returns whether the primary shared/external storage media is emulated.
 * <p>
 * The contents of emulated storage devices are backed by a private user
 * data partition, which means there is little benefit to apps storing data
 * here instead of the private directories returned by
 * {@link Context#getFilesDir()}, etc.
 * <p>
 * This returns true when emulated storage is backed by either internal
 * storage or an adopted storage device.
 *
 * @see DevicePolicyManager#setStorageEncryption(android.content.ComponentName,
 * boolean)
 */",0,,,0,0,0,0,1,"1,3",1,"1,3",1,"The condition check 'if (isStorageDisabled())' and the return statement 'return false' have been removed in the late version. Thus, the code change type is 1 for the removed return statement and 3 for the control dependency change.","The removed return statement 'return false' could potentially lead to the API returning different values in the late version when the storage is disabled, which constitutes a Compatibility Issue of Type 1."
10,"<android.app.usage.NetworkStatsManager: NetworkStats queryDetails(int,String,long,long)>",23,24,"<android.app.usage.NetworkStatsManager: NetworkStats queryDetails(int,String,long,long)>",android.app.usage.NetworkStatsManager.queryDetails,0,"MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(NetworkTemplate template, []), Expression(createTemplate(networkType, subscriberId), [])]), AssignmentExpression(=, [VariableReference(if (template, []), Expression(, [])]), Statement(return null, []), Statement(}, []), Statement(NetworkStats result, []), AssignmentExpression(=, [VariableReference(result, []), Expression(new NetworkStats(mContext, template, startTime, endTime), [])]), MethodCall(result.startUserUidEnumeration(), [VariableReference(result, []), Expression(, [])]), Statement(return result, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(NetworkTemplate template, []), Expression(createTemplate(networkType, subscriberId), [])])    VariableReference(NetworkTemplate template, [])    Expression(createTemplate(networkType, subscriberId), [])  AssignmentExpression(=, [VariableReference(if (template, []), Expression(, [])])    VariableReference(if (template, [])    Expression(, [])  Statement(return null, [])  Statement(}, [])  Statement(NetworkStats result, [])  AssignmentExpression(=, [VariableReference(result, []), Expression(new NetworkStats(mContext, template, startTime, endTime), [])])    VariableReference(result, [])    Expression(new NetworkStats(mContext, template, startTime, endTime), [])  MethodCall(result.startUserUidEnumeration(), [VariableReference(result, []), Expression(, [])])    VariableReference(result, [])    Expression(, [])  Statement(return result, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(NetworkTemplate template, []), Statement(try {, []), AssignmentExpression(=, [VariableReference(template, []), Expression(createTemplate(networkType, subscriberId), [])]), Statement(} catch (IllegalArgumentException e) {, []), Statement(if (DBG), []), MethodCall(Log.e(TAG, ""Cannot create template"", e), [VariableReference(Log, []), Expression(TAG, []), Expression(""Cannot create template"", []), Expression(e, [])]), Statement(return null, []), Statement(}, []), Statement(NetworkStats result, []), AssignmentExpression(=, [VariableReference(result, []), Expression(new NetworkStats(mContext, template, startTime, endTime), [])]), MethodCall(result.startUserUidEnumeration(), [VariableReference(result, []), Expression(, [])]), Statement(return result, []), Statement(}, [])])  Statement({, [])  Statement(NetworkTemplate template, [])  Statement(try {, [])  AssignmentExpression(=, [VariableReference(template, []), Expression(createTemplate(networkType, subscriberId), [])])    VariableReference(template, [])    Expression(createTemplate(networkType, subscriberId), [])  Statement(} catch (IllegalArgumentException e) {, [])  Statement(if (DBG), [])  MethodCall(Log.e(TAG, ""Cannot create template"", e), [VariableReference(Log, []), Expression(TAG, []), Expression(""Cannot create template"", []), Expression(e, [])])    VariableReference(Log, [])    Expression(TAG, [])    Expression(""Cannot create template"", [])    Expression(e, [])  Statement(return null, [])  Statement(}, [])  Statement(NetworkStats result, [])  AssignmentExpression(=, [VariableReference(result, []), Expression(new NetworkStats(mContext, template, startTime, endTime), [])])    VariableReference(result, [])    Expression(new NetworkStats(mContext, template, startTime, endTime), [])  MethodCall(result.startUserUidEnumeration(), [VariableReference(result, []), Expression(, [])])    VariableReference(result, [])    Expression(, [])  Statement(return result, [])  Statement(}, [])",1,"/**
 * Query network usage statistics details. Result filtered to include only uids belonging to
 * calling user. Result is aggregated over state but not aggregated over time or uid. This means
 * buckets' start and end timestamps are going to be between 'startTime' and 'endTime'
 * parameters, state is going to be {@link NetworkStats.Bucket#STATE_ALL} and uid will vary.
 * <p>Only includes buckets that atomically occur in the inclusive time range. Doesn't
 * interpolate across partial buckets. Since bucket length is in the order of hours, this
 * method cannot be used to measure data usage on a fine grained time scale.
 *
 * @param networkType As defined in {@link ConnectivityManager}, e.g.
 * {@link ConnectivityManager#TYPE_MOBILE}, {@link ConnectivityManager#TYPE_WIFI}
 * etc.
 * @param subscriberId If applicable, the subscriber id of the network interface.
 * @param startTime Start of period. Defined in terms of ""Unix time"", see
 * {@link java.lang.System#currentTimeMillis}.
 * @param endTime End of period. Defined in terms of ""Unix time"", see
 * {@link java.lang.System#currentTimeMillis}.
 * @return Statistics object or null if permissions are insufficient or error happened during
 * statistics collection.
 */","/**
 * Query network usage statistics details. Result filtered to include only uids belonging to
 * calling user. Result is aggregated over state but not aggregated over time or uid. This means
 * buckets' start and end timestamps are going to be between 'startTime' and 'endTime'
 * parameters. State is going to be {@link NetworkStats.Bucket#STATE_ALL}, uid will vary,
 * tag {@link NetworkStats.Bucket#TAG_NONE} and roaming is going to be
 * {@link NetworkStats.Bucket#ROAMING_ALL}.
 * <p>Only includes buckets that atomically occur in the inclusive time range. Doesn't
 * interpolate across partial buckets. Since bucket length is in the order of hours, this
 * method cannot be used to measure data usage on a fine grained time scale.
 *
 * @param networkType As defined in {@link ConnectivityManager}, e.g.
 * {@link ConnectivityManager#TYPE_MOBILE}, {@link ConnectivityManager#TYPE_WIFI}
 * etc.
 * @param subscriberId If applicable, the subscriber id of the network interface.
 * @param startTime Start of period. Defined in terms of ""Unix time"", see
 * {@link java.lang.System#currentTimeMillis}.
 * @param endTime End of period. Defined in terms of ""Unix time"", see
 * {@link java.lang.System#currentTimeMillis}.
 * @return Statistics object or null if permissions are insufficient or error happened during
 * statistics collection.
 */",1,,,0,0,0,0,1,"1,2,3","1,2","2,3","1,2","A try-catch block is added to handle IllegalArgumentException, which is a change to exception handling (change type 2). Meanwhile, the condition of generating a template (if (template..)) is removed, so control dependency has changed (change type 3).","The API potentially returns a null value due to the new catch block and change in control flow (if (template..) is removed) which may cause different behavior when an IllegalArgumentException occurs (CI type 1), and because of new catch block, it could throw a IllegalArgumentException (CI type 2)."
11,"<android.app.usage.NetworkStatsManager: NetworkStats queryDetails(int,String,long,long)>",25,26,"<android.app.usage.NetworkStatsManager: NetworkStats queryDetails(int,String,long,long)>","<android.app.usage.NetworkStatsManager: NetworkStats queryDetails(int,String,long,long)>",0,"MethodDeclaration(method_body, [Statement({, []), Statement(NetworkTemplate template, []), Statement(try {, []), AssignmentExpression(=, [VariableReference(template, []), Expression(createTemplate(networkType, subscriberId), [])]), Statement(} catch (IllegalArgumentException e) {, []), Statement(if (DBG), []), MethodCall(Log.e(TAG, ""Cannot create template"", e), [VariableReference(Log, []), Expression(TAG, []), Expression(""Cannot create template"", []), Expression(e, [])]), Statement(return null, []), Statement(}, []), Statement(NetworkStats result, []), AssignmentExpression(=, [VariableReference(result, []), Expression(new NetworkStats(mContext, template, startTime, endTime), [])]), MethodCall(result.startUserUidEnumeration(), [VariableReference(result, []), Expression(, [])]), Statement(return result, []), Statement(}, [])])  Statement({, [])  Statement(NetworkTemplate template, [])  Statement(try {, [])  AssignmentExpression(=, [VariableReference(template, []), Expression(createTemplate(networkType, subscriberId), [])])    VariableReference(template, [])    Expression(createTemplate(networkType, subscriberId), [])  Statement(} catch (IllegalArgumentException e) {, [])  Statement(if (DBG), [])  MethodCall(Log.e(TAG, ""Cannot create template"", e), [VariableReference(Log, []), Expression(TAG, []), Expression(""Cannot create template"", []), Expression(e, [])])    VariableReference(Log, [])    Expression(TAG, [])    Expression(""Cannot create template"", [])    Expression(e, [])  Statement(return null, [])  Statement(}, [])  Statement(NetworkStats result, [])  AssignmentExpression(=, [VariableReference(result, []), Expression(new NetworkStats(mContext, template, startTime, endTime), [])])    VariableReference(result, [])    Expression(new NetworkStats(mContext, template, startTime, endTime), [])  MethodCall(result.startUserUidEnumeration(), [VariableReference(result, []), Expression(, [])])    VariableReference(result, [])    Expression(, [])  Statement(return result, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(NetworkTemplate template, []), Statement(try {, []), AssignmentExpression(=, [VariableReference(template, []), Expression(createTemplate(networkType, subscriberId), [])]), Statement(} catch (IllegalArgumentException e) {, []), Statement(if (DBG), []), MethodCall(Log.e(TAG, ""Cannot create template"", e), [VariableReference(Log, []), Expression(TAG, []), Expression(""Cannot create template"", []), Expression(e, [])]), Statement(return null, []), Statement(}, []), Statement(NetworkStats result, []), AssignmentExpression(=, [VariableReference(result, []), Expression(new NetworkStats(mContext, template, startTime, endTime), [])]), MethodCall(result.startUserUidEnumeration(), [VariableReference(result, []), Expression(, [])]), Statement(return result, []), Statement(}, [])])  Statement({, [])  Statement(NetworkTemplate template, [])  Statement(try {, [])  AssignmentExpression(=, [VariableReference(template, []), Expression(createTemplate(networkType, subscriberId), [])])    VariableReference(template, [])    Expression(createTemplate(networkType, subscriberId), [])  Statement(} catch (IllegalArgumentException e) {, [])  Statement(if (DBG), [])  MethodCall(Log.e(TAG, ""Cannot create template"", e), [VariableReference(Log, []), Expression(TAG, []), Expression(""Cannot create template"", []), Expression(e, [])])    VariableReference(Log, [])    Expression(TAG, [])    Expression(""Cannot create template"", [])    Expression(e, [])  Statement(return null, [])  Statement(}, [])  Statement(NetworkStats result, [])  AssignmentExpression(=, [VariableReference(result, []), Expression(new NetworkStats(mContext, template, startTime, endTime), [])])    VariableReference(result, [])    Expression(new NetworkStats(mContext, template, startTime, endTime), [])  MethodCall(result.startUserUidEnumeration(), [VariableReference(result, []), Expression(, [])])    VariableReference(result, [])    Expression(, [])  Statement(return result, [])  Statement(}, [])",0,"/**
 * Query network usage statistics details. Result filtered to include only uids belonging to
 * calling user. Result is aggregated over state but not aggregated over time or uid. This means
 * buckets' start and end timestamps are going to be between 'startTime' and 'endTime'
 * parameters. State is going to be {@link NetworkStats.Bucket#STATE_ALL}, uid will vary,
 * tag {@link NetworkStats.Bucket#TAG_NONE} and roaming is going to be
 * {@link NetworkStats.Bucket#ROAMING_ALL}.
 * <p>Only includes buckets that atomically occur in the inclusive time range. Doesn't
 * interpolate across partial buckets. Since bucket length is in the order of hours, this
 * method cannot be used to measure data usage on a fine grained time scale.
 *
 * @param networkType As defined in {@link ConnectivityManager}, e.g.
 * {@link ConnectivityManager#TYPE_MOBILE}, {@link ConnectivityManager#TYPE_WIFI}
 * etc.
 * @param subscriberId If applicable, the subscriber id of the network interface.
 * @param startTime Start of period. Defined in terms of ""Unix time"", see
 * {@link java.lang.System#currentTimeMillis}.
 * @param endTime End of period. Defined in terms of ""Unix time"", see
 * {@link java.lang.System#currentTimeMillis}.
 * @return Statistics object or null if permissions are insufficient or error happened during
 * statistics collection.
 */","/**
 * Query network usage statistics details. Result filtered to include only uids belonging to
 * calling user. Result is aggregated over state but not aggregated over time, uid, tag,
 * metered, nor roaming. This means buckets' start and end timestamps are going to be between
 * 'startTime' and 'endTime' parameters. State is going to be
 * {@link NetworkStats.Bucket#STATE_ALL}, uid will vary,
 * tag {@link NetworkStats.Bucket#TAG_NONE}, metered is going to be
 * {@link NetworkStats.Bucket#METERED_ALL}, and roaming is going to be
 * {@link NetworkStats.Bucket#ROAMING_ALL}.
 * <p>Only includes buckets that atomically occur in the inclusive time range. Doesn't
 * interpolate across partial buckets. Since bucket length is in the order of hours, this
 * method cannot be used to measure data usage on a fine grained time scale.
 *
 * @param networkType As defined in {@link ConnectivityManager}, e.g.
 * {@link ConnectivityManager#TYPE_MOBILE}, {@link ConnectivityManager#TYPE_WIFI}
 * etc.
 * @param subscriberId If applicable, the subscriber id of the network interface.
 * @param startTime Start of period. Defined in terms of ""Unix time"", see
 * {@link java.lang.System#currentTimeMillis}.
 * @param endTime End of period. Defined in terms of ""Unix time"", see
 * {@link java.lang.System#currentTimeMillis}.
 * @return Statistics object or null if permissions are insufficient or error happened during
 * statistics collection.
 */",1,,,0,0,0,0,1,0,0,0,0,"There is no change in the implementation from the early to the late version, the change is only in the comment which is not affecting the functionality or output of the method.","Since there are no changes in the implementation, no compatibility issues arise between the two versions."
12,"<android.app.usage.NetworkStatsManager: NetworkStats queryDetails(int,String,long,long)>",26,27,"<android.app.usage.NetworkStatsManager: NetworkStats queryDetails(int,String,long,long)>","<android.app.usage.NetworkStatsManager: NetworkStats queryDetails(int,String,long,long)>",0,"MethodDeclaration(method_body, [Statement({, []), Statement(NetworkTemplate template, []), Statement(try {, []), AssignmentExpression(=, [VariableReference(template, []), Expression(createTemplate(networkType, subscriberId), [])]), Statement(} catch (IllegalArgumentException e) {, []), Statement(if (DBG), []), MethodCall(Log.e(TAG, ""Cannot create template"", e), [VariableReference(Log, []), Expression(TAG, []), Expression(""Cannot create template"", []), Expression(e, [])]), Statement(return null, []), Statement(}, []), Statement(NetworkStats result, []), AssignmentExpression(=, [VariableReference(result, []), Expression(new NetworkStats(mContext, template, startTime, endTime), [])]), MethodCall(result.startUserUidEnumeration(), [VariableReference(result, []), Expression(, [])]), Statement(return result, []), Statement(}, [])])  Statement({, [])  Statement(NetworkTemplate template, [])  Statement(try {, [])  AssignmentExpression(=, [VariableReference(template, []), Expression(createTemplate(networkType, subscriberId), [])])    VariableReference(template, [])    Expression(createTemplate(networkType, subscriberId), [])  Statement(} catch (IllegalArgumentException e) {, [])  Statement(if (DBG), [])  MethodCall(Log.e(TAG, ""Cannot create template"", e), [VariableReference(Log, []), Expression(TAG, []), Expression(""Cannot create template"", []), Expression(e, [])])    VariableReference(Log, [])    Expression(TAG, [])    Expression(""Cannot create template"", [])    Expression(e, [])  Statement(return null, [])  Statement(}, [])  Statement(NetworkStats result, [])  AssignmentExpression(=, [VariableReference(result, []), Expression(new NetworkStats(mContext, template, startTime, endTime), [])])    VariableReference(result, [])    Expression(new NetworkStats(mContext, template, startTime, endTime), [])  MethodCall(result.startUserUidEnumeration(), [VariableReference(result, []), Expression(, [])])    VariableReference(result, [])    Expression(, [])  Statement(return result, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(NetworkTemplate template, []), Statement(try {, []), AssignmentExpression(=, [VariableReference(template, []), Expression(createTemplate(networkType, subscriberId), [])]), Statement(} catch (IllegalArgumentException e) {, []), Statement(if (DBG), []), MethodCall(Log.e(TAG, ""Cannot create template"", e), [VariableReference(Log, []), Expression(TAG, []), Expression(""Cannot create template"", []), Expression(e, [])]), Statement(return null, []), Statement(}, []), Statement(NetworkStats result, []), AssignmentExpression(=, [VariableReference(result, []), Expression(new NetworkStats(mContext, template, mFlags, startTime, endTime), [])]), MethodCall(result.startUserUidEnumeration(), [VariableReference(result, []), Expression(, [])]), Statement(return result, []), Statement(}, [])])  Statement({, [])  Statement(NetworkTemplate template, [])  Statement(try {, [])  AssignmentExpression(=, [VariableReference(template, []), Expression(createTemplate(networkType, subscriberId), [])])    VariableReference(template, [])    Expression(createTemplate(networkType, subscriberId), [])  Statement(} catch (IllegalArgumentException e) {, [])  Statement(if (DBG), [])  MethodCall(Log.e(TAG, ""Cannot create template"", e), [VariableReference(Log, []), Expression(TAG, []), Expression(""Cannot create template"", []), Expression(e, [])])    VariableReference(Log, [])    Expression(TAG, [])    Expression(""Cannot create template"", [])    Expression(e, [])  Statement(return null, [])  Statement(}, [])  Statement(NetworkStats result, [])  AssignmentExpression(=, [VariableReference(result, []), Expression(new NetworkStats(mContext, template, mFlags, startTime, endTime), [])])    VariableReference(result, [])    Expression(new NetworkStats(mContext, template, mFlags, startTime, endTime), [])  MethodCall(result.startUserUidEnumeration(), [VariableReference(result, []), Expression(, [])])    VariableReference(result, [])    Expression(, [])  Statement(return result, [])  Statement(}, [])",1,"/**
 * Query network usage statistics details. Result filtered to include only uids belonging to
 * calling user. Result is aggregated over state but not aggregated over time, uid, tag,
 * metered, nor roaming. This means buckets' start and end timestamps are going to be between
 * 'startTime' and 'endTime' parameters. State is going to be
 * {@link NetworkStats.Bucket#STATE_ALL}, uid will vary,
 * tag {@link NetworkStats.Bucket#TAG_NONE}, metered is going to be
 * {@link NetworkStats.Bucket#METERED_ALL}, and roaming is going to be
 * {@link NetworkStats.Bucket#ROAMING_ALL}.
 * <p>Only includes buckets that atomically occur in the inclusive time range. Doesn't
 * interpolate across partial buckets. Since bucket length is in the order of hours, this
 * method cannot be used to measure data usage on a fine grained time scale.
 *
 * @param networkType As defined in {@link ConnectivityManager}, e.g.
 * {@link ConnectivityManager#TYPE_MOBILE}, {@link ConnectivityManager#TYPE_WIFI}
 * etc.
 * @param subscriberId If applicable, the subscriber id of the network interface.
 * @param startTime Start of period. Defined in terms of ""Unix time"", see
 * {@link java.lang.System#currentTimeMillis}.
 * @param endTime End of period. Defined in terms of ""Unix time"", see
 * {@link java.lang.System#currentTimeMillis}.
 * @return Statistics object or null if permissions are insufficient or error happened during
 * statistics collection.
 */","/**
 * Query network usage statistics details. Result filtered to include only uids belonging to
 * calling user. Result is aggregated over state but not aggregated over time, uid, tag,
 * metered, nor roaming. This means buckets' start and end timestamps are going to be between
 * 'startTime' and 'endTime' parameters. State is going to be
 * {@link NetworkStats.Bucket#STATE_ALL}, uid will vary,
 * tag {@link NetworkStats.Bucket#TAG_NONE}, metered is going to be
 * {@link NetworkStats.Bucket#METERED_ALL}, and roaming is going to be
 * {@link NetworkStats.Bucket#ROAMING_ALL}.
 * <p>Only includes buckets that atomically occur in the inclusive time range. Doesn't
 * interpolate across partial buckets. Since bucket length is in the order of hours, this
 * method cannot be used to measure data usage on a fine grained time scale.
 *
 * @param networkType As defined in {@link ConnectivityManager}, e.g.
 * {@link ConnectivityManager#TYPE_MOBILE}, {@link ConnectivityManager#TYPE_WIFI}
 * etc.
 * @param subscriberId If applicable, the subscriber id of the network interface.
 * @param startTime Start of period. Defined in terms of ""Unix time"", see
 * {@link java.lang.System#currentTimeMillis}.
 * @param endTime End of period. Defined in terms of ""Unix time"", see
 * {@link java.lang.System#currentTimeMillis}.
 * @return Statistics object or null if permissions are insufficient or error happened during
 * statistics collection.
 */",0,,,0,0,0,0,"1,2","1,5",1,"1,5",1,"The only difference in the method body is in the instantiation of `new NetworkStats(mContext, template, startTime, endTime)` in the early version versus `new NetworkStats(mContext, template, mFlags, startTime, endTime)` in the late version. Thus, a parameter to the `NetworkStats` constructor has been added, so the code changes are categorized as 1,5.","The change in the instantiation of the `NetworkStats` object causes the return object `result` to potentially be different between the two versions - introducing a different flag parameter to the constructor could alter the object's behavior, leading to the API potentially returning a different value. Therefore, this change could cause a Compatibility Issue of type 1."
13,"<android.app.usage.NetworkStatsManager: NetworkStats queryDetails(int,String,long,long)>",27,28,"<android.app.usage.NetworkStatsManager: NetworkStats queryDetails(int,String,long,long)>","<android.app.usage.NetworkStatsManager: NetworkStats queryDetails(int,String,long,long)>",0,"MethodDeclaration(method_body, [Statement({, []), Statement(NetworkTemplate template, []), Statement(try {, []), AssignmentExpression(=, [VariableReference(template, []), Expression(createTemplate(networkType, subscriberId), [])]), Statement(} catch (IllegalArgumentException e) {, []), Statement(if (DBG), []), MethodCall(Log.e(TAG, ""Cannot create template"", e), [VariableReference(Log, []), Expression(TAG, []), Expression(""Cannot create template"", []), Expression(e, [])]), Statement(return null, []), Statement(}, []), Statement(NetworkStats result, []), AssignmentExpression(=, [VariableReference(result, []), Expression(new NetworkStats(mContext, template, mFlags, startTime, endTime), [])]), MethodCall(result.startUserUidEnumeration(), [VariableReference(result, []), Expression(, [])]), Statement(return result, []), Statement(}, [])])  Statement({, [])  Statement(NetworkTemplate template, [])  Statement(try {, [])  AssignmentExpression(=, [VariableReference(template, []), Expression(createTemplate(networkType, subscriberId), [])])    VariableReference(template, [])    Expression(createTemplate(networkType, subscriberId), [])  Statement(} catch (IllegalArgumentException e) {, [])  Statement(if (DBG), [])  MethodCall(Log.e(TAG, ""Cannot create template"", e), [VariableReference(Log, []), Expression(TAG, []), Expression(""Cannot create template"", []), Expression(e, [])])    VariableReference(Log, [])    Expression(TAG, [])    Expression(""Cannot create template"", [])    Expression(e, [])  Statement(return null, [])  Statement(}, [])  Statement(NetworkStats result, [])  AssignmentExpression(=, [VariableReference(result, []), Expression(new NetworkStats(mContext, template, mFlags, startTime, endTime), [])])    VariableReference(result, [])    Expression(new NetworkStats(mContext, template, mFlags, startTime, endTime), [])  MethodCall(result.startUserUidEnumeration(), [VariableReference(result, []), Expression(, [])])    VariableReference(result, [])    Expression(, [])  Statement(return result, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(NetworkTemplate template, []), Statement(try {, []), AssignmentExpression(=, [VariableReference(template, []), Expression(createTemplate(networkType, subscriberId), [])]), Statement(} catch (IllegalArgumentException e) {, []), Statement(if (DBG), []), MethodCall(Log.e(TAG, ""Cannot create template"", e), [VariableReference(Log, []), Expression(TAG, []), Expression(""Cannot create template"", []), Expression(e, [])]), Statement(return null, []), Statement(}, []), Statement(NetworkStats result, []), AssignmentExpression(=, [VariableReference(result, []), Expression(new NetworkStats(mContext, template, mFlags, startTime, endTime, mService), [])]), MethodCall(result.startUserUidEnumeration(), [VariableReference(result, []), Expression(, [])]), Statement(return result, []), Statement(}, [])])  Statement({, [])  Statement(NetworkTemplate template, [])  Statement(try {, [])  AssignmentExpression(=, [VariableReference(template, []), Expression(createTemplate(networkType, subscriberId), [])])    VariableReference(template, [])    Expression(createTemplate(networkType, subscriberId), [])  Statement(} catch (IllegalArgumentException e) {, [])  Statement(if (DBG), [])  MethodCall(Log.e(TAG, ""Cannot create template"", e), [VariableReference(Log, []), Expression(TAG, []), Expression(""Cannot create template"", []), Expression(e, [])])    VariableReference(Log, [])    Expression(TAG, [])    Expression(""Cannot create template"", [])    Expression(e, [])  Statement(return null, [])  Statement(}, [])  Statement(NetworkStats result, [])  AssignmentExpression(=, [VariableReference(result, []), Expression(new NetworkStats(mContext, template, mFlags, startTime, endTime, mService), [])])    VariableReference(result, [])    Expression(new NetworkStats(mContext, template, mFlags, startTime, endTime, mService), [])  MethodCall(result.startUserUidEnumeration(), [VariableReference(result, []), Expression(, [])])    VariableReference(result, [])    Expression(, [])  Statement(return result, [])  Statement(}, [])",1,"/**
 * Query network usage statistics details. Result filtered to include only uids belonging to
 * calling user. Result is aggregated over state but not aggregated over time, uid, tag,
 * metered, nor roaming. This means buckets' start and end timestamps are going to be between
 * 'startTime' and 'endTime' parameters. State is going to be
 * {@link NetworkStats.Bucket#STATE_ALL}, uid will vary,
 * tag {@link NetworkStats.Bucket#TAG_NONE}, metered is going to be
 * {@link NetworkStats.Bucket#METERED_ALL}, and roaming is going to be
 * {@link NetworkStats.Bucket#ROAMING_ALL}.
 * <p>Only includes buckets that atomically occur in the inclusive time range. Doesn't
 * interpolate across partial buckets. Since bucket length is in the order of hours, this
 * method cannot be used to measure data usage on a fine grained time scale.
 *
 * @param networkType As defined in {@link ConnectivityManager}, e.g.
 * {@link ConnectivityManager#TYPE_MOBILE}, {@link ConnectivityManager#TYPE_WIFI}
 * etc.
 * @param subscriberId If applicable, the subscriber id of the network interface.
 * @param startTime Start of period. Defined in terms of ""Unix time"", see
 * {@link java.lang.System#currentTimeMillis}.
 * @param endTime End of period. Defined in terms of ""Unix time"", see
 * {@link java.lang.System#currentTimeMillis}.
 * @return Statistics object or null if permissions are insufficient or error happened during
 * statistics collection.
 */","/**
 * Query network usage statistics details. Result filtered to include only uids belonging to
 * calling user. Result is aggregated over state but not aggregated over time, uid, tag,
 * metered, nor roaming. This means buckets' start and end timestamps are going to be between
 * 'startTime' and 'endTime' parameters. State is going to be
 * {@link NetworkStats.Bucket#STATE_ALL}, uid will vary,
 * tag {@link NetworkStats.Bucket#TAG_NONE},
 * default network is going to be {@link NetworkStats.Bucket#DEFAULT_NETWORK_ALL},
 * metered is going to be {@link NetworkStats.Bucket#METERED_ALL},
 * and roaming is going to be {@link NetworkStats.Bucket#ROAMING_ALL}.
 * <p>Only includes buckets that atomically occur in the inclusive time range. Doesn't
 * interpolate across partial buckets. Since bucket length is in the order of hours, this
 * method cannot be used to measure data usage on a fine grained time scale.
 *
 * @param networkType As defined in {@link ConnectivityManager}, e.g.
 * {@link ConnectivityManager#TYPE_MOBILE}, {@link ConnectivityManager#TYPE_WIFI}
 * etc.
 * @param subscriberId If applicable, the subscriber id of the network interface.
 * @param startTime Start of period. Defined in terms of ""Unix time"", see
 * {@link java.lang.System#currentTimeMillis}.
 * @param endTime End of period. Defined in terms of ""Unix time"", see
 * {@link java.lang.System#currentTimeMillis}.
 * @return Statistics object or null if permissions are insufficient or error happened during
 * statistics collection.
 */",1,,,0,0,0,0,"1,2","1,5",1,"1,5",1,"The method call for creating a new NetworkStats object has changed by expanding its parameters (adding mService), and thus the code change types are 1 and 5.","The creation of a new NetworkStats object now includes an additional parameter 'mService' which will affect the return value of the method, thus there is a compatibility issue of type 1."
14,<android.animation.ValueAnimator: long getFrameDelay()>,23,24,<android.animation.ValueAnimator: long getFrameDelay()>,<android.animation.ValueAnimator: long getFrameDelay()>,0,"MethodDeclaration(method_body, [Statement({, []), MethodCall(return Choreographer.getFrameDelay(), [VariableReference(return Choreographer, []), Expression(, [])]), Statement(}, [])])  Statement({, [])  MethodCall(return Choreographer.getFrameDelay(), [VariableReference(return Choreographer, []), Expression(, [])])    VariableReference(return Choreographer, [])    Expression(, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), MethodCall(return AnimationHandler.getInstance().getFrameDelay(), [VariableReference(return AnimationHandler, []), Expression().getFrameDelay(, [])]), Statement(}, [])])  Statement({, [])  MethodCall(return AnimationHandler.getInstance().getFrameDelay(), [VariableReference(return AnimationHandler, []), Expression().getFrameDelay(, [])])    VariableReference(return AnimationHandler, [])    Expression().getFrameDelay(, [])  Statement(}, [])",1,"/**
 * The amount of time, in milliseconds, between each frame of the animation. This is a
 * requested time that the animation will attempt to honor, but the actual delay between
 * frames may be different, depending on system load and capabilities. This is a static
 * function because the same delay will be applied to all animations, since they are all
 * run off of a single timing loop.
 *
 * The frame delay may be ignored when the animation system uses an external timing
 * source, such as the display refresh rate (vsync), to govern animations.
 *
 * @return the requested time between frames, in milliseconds
 */","/**
 * The amount of time, in milliseconds, between each frame of the animation. This is a
 * requested time that the animation will attempt to honor, but the actual delay between
 * frames may be different, depending on system load and capabilities. This is a static
 * function because the same delay will be applied to all animations, since they are all
 * run off of a single timing loop.
 *
 * The frame delay may be ignored when the animation system uses an external timing
 * source, such as the display refresh rate (vsync), to govern animations.
 *
 * Note that this method should be called from the same thread that {@link #start()} is
 * called in order to check the frame delay for that animation. A runtime exception will be
 * thrown if the calling thread does not have a Looper.
 *
 * @return the requested time between frames, in milliseconds
 */",1,,,0,0,0,0,1,1,1,"1,5",1,"The method call in the return statement has changed from Choreographer.getFrameDelay() to AnimationHandler.getInstance().getFrameDelay(). Therefore, the class of change is 1; return statements changed, 5; dependent API changed.","Since the method called to get the frame delay has been changed, this change can potentially lead to different return values even when the same inputs are provided. Hence, CI type is 1; Compatibility Issue caused by potential different return values or types."
16,<android.provider.Settings: boolean canDrawOverlays(Context)>,23,24,<android.provider.Settings: boolean canDrawOverlays(Context)>,<android.provider.Settings: boolean canDrawOverlays(Context)>,0,"MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(int uid, []), Expression(Binder.getCallingUid(), [])]), MethodCall(return Settings.isCallingPackageAllowedToDrawOverlays(context, uid, Settings.getPackageNameForUid(context, uid), false), [VariableReference(return Settings, []), Expression(context, []), Expression(uid, []), Expression(Settings.getPackageNameForUid(context, []), Expression(uid), []), Expression(false, [])]), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(int uid, []), Expression(Binder.getCallingUid(), [])])    VariableReference(int uid, [])    Expression(Binder.getCallingUid(), [])  MethodCall(return Settings.isCallingPackageAllowedToDrawOverlays(context, uid, Settings.getPackageNameForUid(context, uid), false), [VariableReference(return Settings, []), Expression(context, []), Expression(uid, []), Expression(Settings.getPackageNameForUid(context, []), Expression(uid), []), Expression(false, [])])    VariableReference(return Settings, [])    Expression(context, [])    Expression(uid, [])    Expression(Settings.getPackageNameForUid(context, [])    Expression(uid), [])    Expression(false, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), MethodCall(return Settings.isCallingPackageAllowedToDrawOverlays(context, Process.myUid(), context.getOpPackageName(), false), [VariableReference(return Settings, []), Expression(context, []), Expression(Process.myUid(), []), Expression(context.getOpPackageName(), []), Expression(false, [])]), Statement(}, [])])  Statement({, [])  MethodCall(return Settings.isCallingPackageAllowedToDrawOverlays(context, Process.myUid(), context.getOpPackageName(), false), [VariableReference(return Settings, []), Expression(context, []), Expression(Process.myUid(), []), Expression(context.getOpPackageName(), []), Expression(false, [])])    VariableReference(return Settings, [])    Expression(context, [])    Expression(Process.myUid(), [])    Expression(context.getOpPackageName(), [])    Expression(false, [])  Statement(}, [])",1,"/**
 * An app can use this method to check if it is currently allowed to draw on top of other
 * apps. In order to be allowed to do so, an app must first declare the
 * {@link android.Manifest.permission#SYSTEM_ALERT_WINDOW} permission in its manifest. If it
 * is currently disallowed, it can prompt the user to grant it this capability through a
 * management UI by sending an Intent with action
 * {@link android.provider.Settings#ACTION_MANAGE_OVERLAY_PERMISSION}.
 *
 * @param context A context
 * @return true if the calling app can draw on top of other apps, false otherwise.
 */","/**
 * Checks if the specified context can draw on top of other apps. As of API
 * level 23, an app cannot draw on top of other apps unless it declares the
 * {@link android.Manifest.permission#SYSTEM_ALERT_WINDOW} permission in its
 * manifest, <em>and</em> the user specifically grants the app this
 * capability. To prompt the user to grant this approval, the app must send an
 * intent with the action
 * {@link android.provider.Settings#ACTION_MANAGE_OVERLAY_PERMISSION}, which
 * causes the system to display a permission management screen.
 *
 * @param context App context.
 * @return true if the specified context can draw on top of other apps, false otherwise
 */",1,,,0,0,0,0,"1,2","1,5",1,"1,4,5",1,"The API 'Binder.getCallingUid()' is changed to 'Process.myUid()' and 'Settings.getPackageNameForUid(context, uid)' is changed to 'context.getOpPackageName()'. That means the behavior of the method has changed due to the change in method calls which involve the way it gets UID and package name. Based on this information, the change type is 1,4,5.","These changes cause a possible change in the returned value which might lead to potential compatibility issues. When the method is invoked, it could potentially return a different boolean value due to the changes in dependent APIs call and returned value. So, the compatibility issue type is 1."
18,<android.app.NotificationManager.Policy: String toString()>,23,24,<android.app.NotificationManager.Policy: String toString()>,<android.app.NotificationManager.Policy: String toString()>,0,"MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(return ""NotificationManager.Policy["" + ""priorityCategories, []), Expression("" + priorityCategoriesToString(priorityCategories) + "",priorityCallSenders, [])]), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(return ""NotificationManager.Policy["" + ""priorityCategories, []), Expression("" + priorityCategoriesToString(priorityCategories) + "",priorityCallSenders, [])])    VariableReference(return ""NotificationManager.Policy["" + ""priorityCategories, [])    Expression("" + priorityCategoriesToString(priorityCategories) + "",priorityCallSenders, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(return ""NotificationManager.Policy["" + ""priorityCategories, []), Expression("" + priorityCategoriesToString(priorityCategories) + "",priorityCallSenders, [])]), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(return ""NotificationManager.Policy["" + ""priorityCategories, []), Expression("" + priorityCategoriesToString(priorityCategories) + "",priorityCallSenders, [])])    VariableReference(return ""NotificationManager.Policy["" + ""priorityCategories, [])    Expression("" + priorityCategoriesToString(priorityCategories) + "",priorityCallSenders, [])  Statement(}, [])",1,,,0,[@Override],[@Override],0,0,0,0,1,1,1,0,0,"There has no change in the code implementation between the two versions. Hence, the code change type is 0.","Because there are no changes in the implementation of this method. Therefore, there are no compatibility issues, so the compatibility issue type is 0."
19,<android.app.NotificationManager.Policy: String toString()>,27,28,<android.app.NotificationManager.Policy: String toString()>,<android.app.NotificationManager.Policy: String toString()>,0,"MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(return ""NotificationManager.Policy["" + ""priorityCategories, []), Expression("" + priorityCategoriesToString(priorityCategories) + "",priorityCallSenders, [])]), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(return ""NotificationManager.Policy["" + ""priorityCategories, []), Expression("" + priorityCategoriesToString(priorityCategories) + "",priorityCallSenders, [])])    VariableReference(return ""NotificationManager.Policy["" + ""priorityCategories, [])    Expression("" + priorityCategoriesToString(priorityCategories) + "",priorityCallSenders, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(return ""NotificationManager.Policy["" + ""priorityCategories, []), Expression("" + priorityCategoriesToString(priorityCategories) + "",priorityCallSenders, [])]), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(return ""NotificationManager.Policy["" + ""priorityCategories, []), Expression("" + priorityCategoriesToString(priorityCategories) + "",priorityCallSenders, [])])    VariableReference(return ""NotificationManager.Policy["" + ""priorityCategories, [])    Expression("" + priorityCategoriesToString(priorityCategories) + "",priorityCallSenders, [])  Statement(}, [])",1,,,0,[@Override],[@Override],0,0,0,0,1,1,1,0,0,"There has been no change in the implementation of the method between the early version and the late version. Therefore, the code change type is 0.","Since there has been no change in the early version from the late version, there is no possibility of compatibility issue. Thus, the CI type is 0."
23,<android.text.Html: String toHtml(Spanned)>,23,24,<android.text.Html: String toHtml(Spanned)>,<android.text.Html: String toHtml(Spanned)>,0,"MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(StringBuilder out, []), Expression(new StringBuilder(), [])]), Statement(withinHtml(out, text), []), MethodCall(return out.toString(), [VariableReference(return out, []), Expression(, [])]), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(StringBuilder out, []), Expression(new StringBuilder(), [])])    VariableReference(StringBuilder out, [])    Expression(new StringBuilder(), [])  Statement(withinHtml(out, text), [])  MethodCall(return out.toString(), [VariableReference(return out, []), Expression(, [])])    VariableReference(return out, [])    Expression(, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(return toHtml(text, TO_HTML_PARAGRAPH_LINES_CONSECUTIVE), []), Statement(}, [])])  Statement({, [])  Statement(return toHtml(text, TO_HTML_PARAGRAPH_LINES_CONSECUTIVE), [])  Statement(}, [])",1,"/**
 * Returns an HTML representation of the provided Spanned text. A best effort is
 * made to add HTML tags corresponding to spans. Also note that HTML metacharacters
 * (such as ""&lt;"" and ""&amp;"") within the input text are escaped.
 *
 * @param text input text to convert
 * @return string containing input converted to HTML
 */","/**
 * @deprecated use {@link #toHtml(Spanned, int)} instead.
 */",1,,[@Deprecated],1,0,0,0,1,"1,4,5",1,"1,5",1,"The implementation of the method has completely changed from a StringBuilder approach to calling a different method (toHtml(text, TO_HTML_PARAGRAPH_LINES_CONSECUTIVE)). This corresponds to change type 1 and 5.","Given that the implementation has been completely changed, this could potentially result in different behavior when the method is invoked, specifically the return value might be different, hence the CI type is 1."
27,<android.app.Activity: void stopLockTask()>,27,28,<android.app.Activity: void stopLockTask()>,<android.app.Activity: void stopLockTask()>,0,"MethodDeclaration(method_body, [Statement({, []), Statement(try {, []), MethodCall(ActivityManager.getService().stopLockTaskMode(), [VariableReference(ActivityManager, []), Expression().stopLockTaskMode(, [])]), Statement(} catch (RemoteException e) {, []), Statement(}, []), Statement(}, [])])  Statement({, [])  Statement(try {, [])  MethodCall(ActivityManager.getService().stopLockTaskMode(), [VariableReference(ActivityManager, []), Expression().stopLockTaskMode(, [])])    VariableReference(ActivityManager, [])    Expression().stopLockTaskMode(, [])  Statement(} catch (RemoteException e) {, [])  Statement(}, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(try {, []), MethodCall(ActivityManager.getService().stopLockTaskModeByToken(mToken), [VariableReference(ActivityManager, []), Expression().stopLockTaskModeByToken(mToken, [])]), Statement(} catch (RemoteException e) {, []), Statement(}, []), Statement(}, [])])  Statement({, [])  Statement(try {, [])  MethodCall(ActivityManager.getService().stopLockTaskModeByToken(mToken), [VariableReference(ActivityManager, []), Expression().stopLockTaskModeByToken(mToken, [])])    VariableReference(ActivityManager, [])    Expression().stopLockTaskModeByToken(mToken, [])  Statement(} catch (RemoteException e) {, [])  Statement(}, [])  Statement(}, [])",1,"/**
 * Allow the user to switch away from the current task.
 *
 * Called to end the mode started by {@link Activity#startLockTask}. This
 * can only be called by activities that have successfully called
 * startLockTask previously.
 *
 * This will allow the user to exit this app and move onto other activities.
 * <p>Note: This method should only be called when the activity is user-facing. That is,
 * between onResume() and onPause().
 * <p>Note: If there are other tasks below this one that are also locked then calling this
 * method will immediately finish this task and resume the previous locked one, remaining in
 * lockTask mode.
 *
 * @see android.R.attr#lockTaskMode
 * @see ActivityManager#getLockTaskModeState()
 */","/**
 * Stop the current task from being locked.
 *
 * <p>Called to end the LockTask or screen pinning mode started by {@link #startLockTask()}.
 * This can only be called by activities that have called {@link #startLockTask()} previously.
 *
 * <p><strong>Note:</strong> If the device is in LockTask mode that is not initially started
 * by this activity, then calling this method will not terminate the LockTask mode, but only
 * finish its own task. The device will remain in LockTask mode, until the activity which
 * started the LockTask mode calls this method, or until its whitelist authorization is revoked
 * by {@link DevicePolicyManager#setLockTaskPackages(ComponentName, String[])}.
 *
 * @see #startLockTask()
 * @see android.R.attr#lockTaskMode
 * @see ActivityManager#getLockTaskModeState()
 */",1,,,0,0,0,0,1,4,0,"1,5",1,"The method called in the try block has changed from 'stopLockTaskMode()' to 'stopLockTaskModeByToken(mToken)' and the parameter type of stopLockTaskModeByToken() has also changed. So, the code change type is 1,5.","The changed method call will lead to a different execution path, thus the API could have a different behavior, hence the CI type is 1."
28,<android.app.Activity: void stopLockTask()>,28,29,<android.app.Activity: void stopLockTask()>,<android.app.Activity: void stopLockTask()>,0,"MethodDeclaration(method_body, [Statement({, []), Statement(try {, []), MethodCall(ActivityManager.getService().stopLockTaskModeByToken(mToken), [VariableReference(ActivityManager, []), Expression().stopLockTaskModeByToken(mToken, [])]), Statement(} catch (RemoteException e) {, []), Statement(}, []), Statement(}, [])])  Statement({, [])  Statement(try {, [])  MethodCall(ActivityManager.getService().stopLockTaskModeByToken(mToken), [VariableReference(ActivityManager, []), Expression().stopLockTaskModeByToken(mToken, [])])    VariableReference(ActivityManager, [])    Expression().stopLockTaskModeByToken(mToken, [])  Statement(} catch (RemoteException e) {, [])  Statement(}, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(try {, []), MethodCall(ActivityTaskManager.getService().stopLockTaskModeByToken(mToken), [VariableReference(ActivityTaskManager, []), Expression().stopLockTaskModeByToken(mToken, [])]), Statement(} catch (RemoteException e) {, []), Statement(}, []), Statement(}, [])])  Statement({, [])  Statement(try {, [])  MethodCall(ActivityTaskManager.getService().stopLockTaskModeByToken(mToken), [VariableReference(ActivityTaskManager, []), Expression().stopLockTaskModeByToken(mToken, [])])    VariableReference(ActivityTaskManager, [])    Expression().stopLockTaskModeByToken(mToken, [])  Statement(} catch (RemoteException e) {, [])  Statement(}, [])  Statement(}, [])",1,"/**
 * Stop the current task from being locked.
 *
 * <p>Called to end the LockTask or screen pinning mode started by {@link #startLockTask()}.
 * This can only be called by activities that have called {@link #startLockTask()} previously.
 *
 * <p><strong>Note:</strong> If the device is in LockTask mode that is not initially started
 * by this activity, then calling this method will not terminate the LockTask mode, but only
 * finish its own task. The device will remain in LockTask mode, until the activity which
 * started the LockTask mode calls this method, or until its whitelist authorization is revoked
 * by {@link DevicePolicyManager#setLockTaskPackages(ComponentName, String[])}.
 *
 * @see #startLockTask()
 * @see android.R.attr#lockTaskMode
 * @see ActivityManager#getLockTaskModeState()
 */","/**
 * Stop the current task from being locked.
 *
 * <p>Called to end the LockTask or screen pinning mode started by {@link #startLockTask()}.
 * This can only be called by activities that have called {@link #startLockTask()} previously.
 *
 * <p><strong>Note:</strong> If the device is in LockTask mode that is not initially started
 * by this activity, then calling this method will not terminate the LockTask mode, but only
 * finish its own task. The device will remain in LockTask mode, until the activity which
 * started the LockTask mode calls this method, or until its whitelist authorization is revoked
 * by {@link DevicePolicyManager#setLockTaskPackages(ComponentName, String[])}.
 *
 * @see #startLockTask()
 * @see android.R.attr#lockTaskMode
 * @see ActivityManager#getLockTaskModeState()
 */",0,,,0,0,0,0,1,4,0,5,1,"The method has been changed from ActivityManager.getService().stopLockTaskModeByToken(mToken) to ActivityTaskManager.getService().stopLockTaskModeByToken(mToken). So the class which implementation the method have changed from ActivityManager to ActivityTaskManager, the code change type is 5.","As the dependent API has changed, this may cause a change in the behaviors of the ""stopLockTask()"" method. Thus, the Compatibility Issue (CI) type is 1."
29,<android.animation.ValueAnimator: void end()>,23,24,<android.animation.ValueAnimator: void end()>,<android.animation.ValueAnimator: void end()>,0,"MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(AnimationHandler handler, []), Expression(getOrCreateAnimationHandler(), [])]), Statement(// Special case if the animation has not yet started, []), Statement(get it ready for ending, []), AssignmentExpression(=, [VariableReference(mStartedDelay, []), Expression(false, [])]), Statement(startAnimation(handler), []), AssignmentExpression(=, [VariableReference(mStarted, []), Expression(true, [])]), Statement(} else if (!mInitialized) {, []), Statement(initAnimation(), []), Statement(}, []), Statement(animateValue(mPlayingBackwards ? 0f : 1f), []), Statement(endAnimation(handler), []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(AnimationHandler handler, []), Expression(getOrCreateAnimationHandler(), [])])    VariableReference(AnimationHandler handler, [])    Expression(getOrCreateAnimationHandler(), [])  Statement(// Special case if the animation has not yet started, [])  Statement(get it ready for ending, [])  AssignmentExpression(=, [VariableReference(mStartedDelay, []), Expression(false, [])])    VariableReference(mStartedDelay, [])    Expression(false, [])  Statement(startAnimation(handler), [])  AssignmentExpression(=, [VariableReference(mStarted, []), Expression(true, [])])    VariableReference(mStarted, [])    Expression(true, [])  Statement(} else if (!mInitialized) {, [])  Statement(initAnimation(), [])  Statement(}, [])  Statement(animateValue(mPlayingBackwards ? 0f : 1f), [])  Statement(endAnimation(handler), [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(if (Looper.myLooper(), []), Expression(, [])]), Statement(throw new AndroidRuntimeException(""Animators may only be run on Looper threads""), []), Statement(}, []), Statement(if (!mRunning) {, []), Statement(// Special case if the animation has not yet started, []), Statement(get it ready for ending, []), Statement(startAnimation(), []), AssignmentExpression(=, [VariableReference(mStarted, []), Expression(true, [])]), Statement(} else if (!mInitialized) {, []), Statement(initAnimation(), []), Statement(}, []), Statement(animateValue(shouldPlayBackward(mRepeatCount) ? 0f : 1f), []), Statement(endAnimation(), []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(if (Looper.myLooper(), []), Expression(, [])])    VariableReference(if (Looper.myLooper(), [])    Expression(, [])  Statement(throw new AndroidRuntimeException(""Animators may only be run on Looper threads""), [])  Statement(}, [])  Statement(if (!mRunning) {, [])  Statement(// Special case if the animation has not yet started, [])  Statement(get it ready for ending, [])  Statement(startAnimation(), [])  AssignmentExpression(=, [VariableReference(mStarted, []), Expression(true, [])])    VariableReference(mStarted, [])    Expression(true, [])  Statement(} else if (!mInitialized) {, [])  Statement(initAnimation(), [])  Statement(}, [])  Statement(animateValue(shouldPlayBackward(mRepeatCount) ? 0f : 1f), [])  Statement(endAnimation(), [])  Statement(}, [])",1,,,0,[@Override],[@Override],0,0,0,0,1,"2,3,4",2,"2,3,4","1,2","The exception handling statement has been added (throw new AndroidRuntimeException(""Animators may only be run on Looper threads"")) and the 'if' condition and some other statements/expressions inside it have changed, so the change type is 2,3,4.","The introduced exception handling statement could potentially throw a different type of exception, and the changes in 'if' condition and related expressions could potentially lead to the method returning different values or types, thus the CI type is 1,2."
31,"<android.content.res.Resources: Drawable loadDrawable(TypedValue,int,Theme)>",23,24,"<android.content.res.Resources: Drawable loadDrawable(TypedValue,int,Theme)>","<android.content.res.Resources: Drawable loadDrawable(TypedValue,int,Theme)>",0,"MethodDeclaration(method_body, [Statement({, []), Statement(if (TRACE_FOR_PRELOAD) {, []), Statement(// Log only framework resources, []), AssignmentExpression(=, [VariableReference(if ((id >>> 24), []), Expression(, [])]), AssignmentExpression(=, [VariableReference(final String name, []), Expression(getResourceName(id), [])]), AssignmentExpression(=, [VariableReference(if (name !, []), Expression(null) {, [])]), MethodCall(Log.d(""PreloadDrawable"", name), [VariableReference(Log, []), Expression(""PreloadDrawable"", []), Expression(name, [])]), Statement(}, []), Statement(}, []), Statement(}, []), Statement(final boolean isColorDrawable, []), Statement(final DrawableCache caches, []), Statement(final long key, []), AssignmentExpression(=, [VariableReference(if (value.type >, []), Expression(TypedValue.TYPE_FIRST_COLOR_INT && value.type <, [])]), AssignmentExpression(=, [VariableReference(isColorDrawable, []), Expression(true, [])]), AssignmentExpression(=, [VariableReference(caches, []), Expression(mColorDrawableCache, [])]), AssignmentExpression(=, [VariableReference(key, []), Expression(value.data, [])]), Statement(} else {, []), AssignmentExpression(=, [VariableReference(isColorDrawable, []), Expression(false, [])]), AssignmentExpression(=, [VariableReference(caches, []), Expression(mDrawableCache, [])]), AssignmentExpression(=, [VariableReference(key, []), Expression((((long) value.assetCookie) << 32) | value.data, [])]), Statement(}, []), Statement(// that was inflated against the specified theme., []), Statement(if (!mPreloading) {, []), AssignmentExpression(=, [VariableReference(final Drawable cachedDrawable, []), Expression(caches.getInstance(key, theme), [])]), AssignmentExpression(=, [VariableReference(if (cachedDrawable !, []), Expression(null) {, [])]), Statement(return cachedDrawable, []), Statement(}, []), Statement(}, []), Statement(// Next, check preloaded drawables. These may contain unresolved theme, []), Statement(// attributes., []), Statement(final ConstantState cs, []), Statement(if (isColorDrawable) {, []), AssignmentExpression(=, [VariableReference(cs, []), Expression(sPreloadedColorDrawables.get(key), [])]), Statement(} else {, []), AssignmentExpression(=, [VariableReference(cs, []), Expression(sPreloadedDrawables[mConfiguration.getLayoutDirection()].get(key), [])]), Statement(}, []), Statement(Drawable dr, []), AssignmentExpression(=, [VariableReference(if (cs !, []), Expression(null) {, [])]), AssignmentExpression(=, [VariableReference(dr, []), Expression(cs.newDrawable(this), [])]), Statement(} else if (isColorDrawable) {, []), AssignmentExpression(=, [VariableReference(dr, []), Expression(new ColorDrawable(value.data), [])]), Statement(} else {, []), AssignmentExpression(=, [VariableReference(dr, []), Expression(loadDrawableForCookie(value, id, null), [])]), Statement(}, []), Statement(// Determine if the drawable has unresolved theme attributes. If it, []), Statement(// does, we'll need to apply a theme and store it in a theme-specific, []), Statement(// cache., []), AssignmentExpression(=, [VariableReference(final boolean canApplyTheme, []), Expression(dr !, [])]), AssignmentExpression(=, [VariableReference(if (canApplyTheme && theme !, []), Expression(null) {, [])]), AssignmentExpression(=, [VariableReference(dr, []), Expression(dr.mutate(), [])]), MethodCall(dr.applyTheme(theme), [VariableReference(dr, []), Expression(theme, [])]), MethodCall(dr.clearMutated(), [VariableReference(dr, []), Expression(, [])]), Statement(}, []), Statement(// cache: preload, not themed, null theme, or theme-specific., []), AssignmentExpression(=, [VariableReference(if (dr !, []), Expression(null) {, [])]), MethodCall(dr.setChangingConfigurations(value.changingConfigurations), [VariableReference(dr, []), Expression(value.changingConfigurations, [])]), Statement(cacheDrawable(value, isColorDrawable, caches, theme, canApplyTheme, key, dr), []), Statement(}, []), Statement(return dr, []), Statement(}, [])])  Statement({, [])  Statement(if (TRACE_FOR_PRELOAD) {, [])  Statement(// Log only framework resources, [])  AssignmentExpression(=, [VariableReference(if ((id >>> 24), []), Expression(, [])])    VariableReference(if ((id >>> 24), [])    Expression(, [])  AssignmentExpression(=, [VariableReference(final String name, []), Expression(getResourceName(id), [])])    VariableReference(final String name, [])    Expression(getResourceName(id), [])  AssignmentExpression(=, [VariableReference(if (name !, []), Expression(null) {, [])])    VariableReference(if (name !, [])    Expression(null) {, [])  MethodCall(Log.d(""PreloadDrawable"", name), [VariableReference(Log, []), Expression(""PreloadDrawable"", []), Expression(name, [])])    VariableReference(Log, [])    Expression(""PreloadDrawable"", [])    Expression(name, [])  Statement(}, [])  Statement(}, [])  Statement(}, [])  Statement(final boolean isColorDrawable, [])  Statement(final DrawableCache caches, [])  Statement(final long key, [])  AssignmentExpression(=, [VariableReference(if (value.type >, []), Expression(TypedValue.TYPE_FIRST_COLOR_INT && value.type <, [])])    VariableReference(if (value.type >, [])    Expression(TypedValue.TYPE_FIRST_COLOR_INT && value.type <, [])  AssignmentExpression(=, [VariableReference(isColorDrawable, []), Expression(true, [])])    VariableReference(isColorDrawable, [])    Expression(true, [])  AssignmentExpression(=, [VariableReference(caches, []), Expression(mColorDrawableCache, [])])    VariableReference(caches, [])    Expression(mColorDrawableCache, [])  AssignmentExpression(=, [VariableReference(key, []), Expression(value.data, [])])    VariableReference(key, [])    Expression(value.data, [])  Statement(} else {, [])  AssignmentExpression(=, [VariableReference(isColorDrawable, []), Expression(false, [])])    VariableReference(isColorDrawable, [])    Expression(false, [])  AssignmentExpression(=, [VariableReference(caches, []), Expression(mDrawableCache, [])])    VariableReference(caches, [])    Expression(mDrawableCache, [])  AssignmentExpression(=, [VariableReference(key, []), Expression((((long) value.assetCookie) << 32) | value.data, [])])    VariableReference(key, [])    Expression((((long) value.assetCookie) << 32) | value.data, [])  Statement(}, [])  Statement(// that was inflated against the specified theme., [])  Statement(if (!mPreloading) {, [])  AssignmentExpression(=, [VariableReference(final Drawable cachedDrawable, []), Expression(caches.getInstance(key, theme), [])])    VariableReference(final Drawable cachedDrawable, [])    Expression(caches.getInstance(key, theme), [])  AssignmentExpression(=, [VariableReference(if (cachedDrawable !, []), Expression(null) {, [])])    VariableReference(if (cachedDrawable !, [])    Expression(null) {, [])  Statement(return cachedDrawable, [])  Statement(}, [])  Statement(}, [])  Statement(// Next, check preloaded drawables. These may contain unresolved theme, [])  Statement(// attributes., [])  Statement(final ConstantState cs, [])  Statement(if (isColorDrawable) {, [])  AssignmentExpression(=, [VariableReference(cs, []), Expression(sPreloadedColorDrawables.get(key), [])])    VariableReference(cs, [])    Expression(sPreloadedColorDrawables.get(key), [])  Statement(} else {, [])  AssignmentExpression(=, [VariableReference(cs, []), Expression(sPreloadedDrawables[mConfiguration.getLayoutDirection()].get(key), [])])    VariableReference(cs, [])    Expression(sPreloadedDrawables[mConfiguration.getLayoutDirection()].get(key), [])  Statement(}, [])  Statement(Drawable dr, [])  AssignmentExpression(=, [VariableReference(if (cs !, []), Expression(null) {, [])])    VariableReference(if (cs !, [])    Expression(null) {, [])  AssignmentExpression(=, [VariableReference(dr, []), Expression(cs.newDrawable(this), [])])    VariableReference(dr, [])    Expression(cs.newDrawable(this), [])  Statement(} else if (isColorDrawable) {, [])  AssignmentExpression(=, [VariableReference(dr, []), Expression(new ColorDrawable(value.data), [])])    VariableReference(dr, [])    Expression(new ColorDrawable(value.data), [])  Statement(} else {, [])  AssignmentExpression(=, [VariableReference(dr, []), Expression(loadDrawableForCookie(value, id, null), [])])    VariableReference(dr, [])    Expression(loadDrawableForCookie(value, id, null), [])  Statement(}, [])  Statement(// Determine if the drawable has unresolved theme attributes. If it, [])  Statement(// does, we'll need to apply a theme and store it in a theme-specific, [])  Statement(// cache., [])  AssignmentExpression(=, [VariableReference(final boolean canApplyTheme, []), Expression(dr !, [])])    VariableReference(final boolean canApplyTheme, [])    Expression(dr !, [])  AssignmentExpression(=, [VariableReference(if (canApplyTheme && theme !, []), Expression(null) {, [])])    VariableReference(if (canApplyTheme && theme !, [])    Expression(null) {, [])  AssignmentExpression(=, [VariableReference(dr, []), Expression(dr.mutate(), [])])    VariableReference(dr, [])    Expression(dr.mutate(), [])  MethodCall(dr.applyTheme(theme), [VariableReference(dr, []), Expression(theme, [])])    VariableReference(dr, [])    Expression(theme, [])  MethodCall(dr.clearMutated(), [VariableReference(dr, []), Expression(, [])])    VariableReference(dr, [])    Expression(, [])  Statement(}, [])  Statement(// cache: preload, not themed, null theme, or theme-specific., [])  AssignmentExpression(=, [VariableReference(if (dr !, []), Expression(null) {, [])])    VariableReference(if (dr !, [])    Expression(null) {, [])  MethodCall(dr.setChangingConfigurations(value.changingConfigurations), [VariableReference(dr, []), Expression(value.changingConfigurations, [])])    VariableReference(dr, [])    Expression(value.changingConfigurations, [])  Statement(cacheDrawable(value, isColorDrawable, caches, theme, canApplyTheme, key, dr), [])  Statement(}, [])  Statement(return dr, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), MethodCall(return mResourcesImpl.loadDrawable(this, value, id, theme, true), [VariableReference(return mResourcesImpl, []), Expression(this, []), Expression(value, []), Expression(id, []), Expression(theme, []), Expression(true, [])]), Statement(}, [])])  Statement({, [])  MethodCall(return mResourcesImpl.loadDrawable(this, value, id, theme, true), [VariableReference(return mResourcesImpl, []), Expression(this, []), Expression(value, []), Expression(id, []), Expression(theme, []), Expression(true, [])])    VariableReference(return mResourcesImpl, [])    Expression(this, [])    Expression(value, [])    Expression(id, [])    Expression(theme, [])    Expression(true, [])  Statement(}, [])",1,,,0,[@Nullable],[@NonNull],1,0,0,0,"1,2","1,3,4",1,"4,5",1,"The entire method implementation has been replaced from an extensive implementation including control and return statements to a single return statement (mResourcesImpl.loadDrawable(this, value, id, theme, true)), indicating a complex change which includes both Other statement changes and Dependent API changes (from using local logic to make a call to `mResourcesImpl.loadDrawable`), so the change type is 4,5.","The `loadDrawable` method's whole implementation change would affect the returned Drawable Object, either by its type or its associated value, making the API to potentially return a different value, so the CI type is 1."
32,<android.os.BatteryManager: boolean isCharging()>,23,24,<android.os.BatteryManager: boolean isCharging()>,<android.os.BatteryManager: boolean isCharging()>,0,"MethodDeclaration(method_body, [Statement({, []), Statement(try {, []), MethodCall(return mBatteryStats.isCharging(), [VariableReference(return mBatteryStats, []), Expression(, [])]), Statement(} catch (RemoteException e) {, []), Statement(return true, []), Statement(}, []), Statement(}, [])])  Statement({, [])  Statement(try {, [])  MethodCall(return mBatteryStats.isCharging(), [VariableReference(return mBatteryStats, []), Expression(, [])])    VariableReference(return mBatteryStats, [])    Expression(, [])  Statement(} catch (RemoteException e) {, [])  Statement(return true, [])  Statement(}, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(try {, []), MethodCall(return mBatteryStats.isCharging(), [VariableReference(return mBatteryStats, []), Expression(, [])]), Statement(} catch (RemoteException e) {, []), MethodCall(throw e.rethrowFromSystemServer(), [VariableReference(throw e, []), Expression(, [])]), Statement(}, []), Statement(}, [])])  Statement({, [])  Statement(try {, [])  MethodCall(return mBatteryStats.isCharging(), [VariableReference(return mBatteryStats, []), Expression(, [])])    VariableReference(return mBatteryStats, [])    Expression(, [])  Statement(} catch (RemoteException e) {, [])  MethodCall(throw e.rethrowFromSystemServer(), [VariableReference(throw e, []), Expression(, [])])    VariableReference(throw e, [])    Expression(, [])  Statement(}, [])  Statement(}, [])",1,"/**
 * Return true if the battery is currently considered to be charging.  This means that
 * the device is plugged in and is supplying sufficient power that the battery level is
 * going up (or the battery is fully charged).  Changes in this state are matched by
 * broadcasts of {@link #ACTION_CHARGING} and {@link #ACTION_DISCHARGING}.
 */
","/**
 * Return true if the battery is currently considered to be charging.  This means that
 * the device is plugged in and is supplying sufficient power that the battery level is
 * going up (or the battery is fully charged).  Changes in this state are matched by
 * broadcasts of {@link #ACTION_CHARGING} and {@link #ACTION_DISCHARGING}.
 */
",0,,,0,0,0,0,1,"1,2","1,2","1,2","1,2","The return statement 'return true' when exception happens in early version has been removed in late version, and has been replaced by 'throw e.rethrowFromSystemServer()'. Therefore, both the return statement and the exception handling statement have changed, and the code change type is 1,2.","As the exception handling and the return value when exception happens have changed, it can lead to different behaviours. The different return value results in CI type 1, and the different exception handling results in CI type 2. Therefore, the CI type is 1,2."
33,<android.app.ApplicationContext: Drawable peekWallpaper()>,4,5,<android.app.ApplicationContext: Drawable peekWallpaper()>,<android.app.ApplicationContext: Drawable peekWallpaper()>,0,"MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(if (mWallpaper !, []), Expression(null) {, [])]), Statement(return mWallpaper, []), Statement(}, []), AssignmentExpression(=, [VariableReference(mWallpaperCallback, []), Expression(new WallpaperCallback(this), [])]), AssignmentExpression(=, [VariableReference(mWallpaper, []), Expression(getCurrentWallpaperLocked(), [])]), Statement(return mWallpaper, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(if (mWallpaper !, []), Expression(null) {, [])])    VariableReference(if (mWallpaper !, [])    Expression(null) {, [])  Statement(return mWallpaper, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(mWallpaperCallback, []), Expression(new WallpaperCallback(this), [])])    VariableReference(mWallpaperCallback, [])    Expression(new WallpaperCallback(this), [])  AssignmentExpression(=, [VariableReference(mWallpaper, []), Expression(getCurrentWallpaperLocked(), [])])    VariableReference(mWallpaper, [])    Expression(getCurrentWallpaperLocked(), [])  Statement(return mWallpaper, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), MethodCall(return getWallpaperManager().peekDrawable(), [VariableReference(return getWallpaperManager(), []), Expression(, [])]), Statement(}, [])])  Statement({, [])  MethodCall(return getWallpaperManager().peekDrawable(), [VariableReference(return getWallpaperManager(), []), Expression(, [])])    VariableReference(return getWallpaperManager(), [])    Expression(, [])  Statement(}, [])",1,,,0,[@Override],[@Override],0,0,0,0,1,"1,3,4",1,"1,4",1,"The return statement has changed from 'return mWallpaper' and 'return getCurrentWallpaperLocked()' in the early version to 'return getWallpaperManager().peekDrawable()' in the late version. Besides, the conditional and assignment statements in the early version are deleted in the late version. Therefore, change type should be 1,4.","The change of return statement ensures that the API will return different values in the two versions. So it exists a Compatibility Issue caused by potential different return values, i.e., CI type 1."
34,"<android.content.res.Resources: Drawable loadDrawable(TypedValue,int)>",4,5,"<android.content.res.Resources: Drawable loadDrawable(TypedValue,int)>","<android.content.res.Resources: Drawable loadDrawable(TypedValue,int)>",0,"MethodDeclaration(method_body, [Statement({, []), Statement(if (TRACE_FOR_PRELOAD) {, []), Statement(// Log only framework resources, []), AssignmentExpression(=, [VariableReference(if ((id >>> 24), []), Expression(, [])]), AssignmentExpression(=, [VariableReference(final String name, []), Expression(getResourceName(id), [])]), AssignmentExpression(=, [VariableReference(if (name !, []), Expression(null), [])]), Statement(}, []), Statement(}, []), AssignmentExpression(=, [VariableReference(final long key, []), Expression((((long) value.assetCookie) << 32) | value.data, [])]), AssignmentExpression(=, [VariableReference(Drawable dr, []), Expression(getCachedDrawable(key), [])]), AssignmentExpression(=, [VariableReference(if (dr !, []), Expression(null) {, [])]), Statement(return dr, []), Statement(}, []), AssignmentExpression(=, [VariableReference(Drawable.ConstantState cs, []), Expression(mPreloadedDrawables.get(key), [])]), AssignmentExpression(=, [VariableReference(if (cs !, []), Expression(null) {, [])]), AssignmentExpression(=, [VariableReference(dr, []), Expression(cs.newDrawable(), [])]), Statement(} else {, []), AssignmentExpression(=, [VariableReference(if (value.type >, []), Expression(TypedValue.TYPE_FIRST_COLOR_INT && value.type <, [])]), AssignmentExpression(=, [VariableReference(dr, []), Expression(new ColorDrawable(value.data), [])]), Statement(}, []), AssignmentExpression(=, [VariableReference(if (dr, []), Expression(, [])]), AssignmentExpression(=, [VariableReference(if (value.string, []), Expression(, [])]), Statement(throw new NotFoundException(""Resource is not a Drawable (color or path): "" + value), []), Statement(}, []), AssignmentExpression(=, [VariableReference(String file, []), Expression(value.string.toString(), [])]), Statement(if (DEBUG_LOAD), []), MethodCall(Log.v(TAG, ""Loading drawable for cookie "" + value.assetCookie + "": "" + file), [VariableReference(Log, []), Expression(TAG, []), Expression(""Loading drawable for cookie "" + value.assetCookie + "": "" + file, [])]), MethodCall(if (file.endsWith("".xml"")), [VariableReference(if (file, []), Expression("".xml""), [])]), Statement(try {, []), AssignmentExpression(=, [VariableReference(XmlResourceParser rp, []), Expression(loadXmlResourceParser(file, id, value.assetCookie, ""drawable""), [])]), AssignmentExpression(=, [VariableReference(dr, []), Expression(Drawable.createFromXml(this, rp), [])]), MethodCall(rp.close(), [VariableReference(rp, []), Expression(, [])]), Statement(} catch (Exception e) {, []), AssignmentExpression(=, [VariableReference(NotFoundException rnf, []), Expression(new NotFoundException(""File "" + file + "" from drawable resource ID #0x"" + Integer.toHexString(id)), [])]), MethodCall(rnf.initCause(e), [VariableReference(rnf, []), Expression(e, [])]), Statement(throw rnf, []), Statement(}, []), Statement(} else {, []), Statement(try {, []), AssignmentExpression(=, [VariableReference(InputStream is, []), Expression(mAssets.openNonAsset(value.assetCookie, file, AssetManager.ACCESS_BUFFER), [])]), AssignmentExpression(=, [VariableReference(dr, []), Expression(Drawable.createFromResourceStream(this, value, is, file), [])]), MethodCall(is.close(), [VariableReference(is, []), Expression(, [])]), Statement(} catch (Exception e) {, []), AssignmentExpression(=, [VariableReference(NotFoundException rnf, []), Expression(new NotFoundException(""File "" + file + "" from drawable resource ID #0x"" + Integer.toHexString(id)), [])]), MethodCall(rnf.initCause(e), [VariableReference(rnf, []), Expression(e, [])]), Statement(throw rnf, []), Statement(}, []), Statement(}, []), Statement(}, []), Statement(}, []), AssignmentExpression(=, [VariableReference(if (dr !, []), Expression(null) {, [])]), MethodCall(dr.setChangingConfigurations(value.changingConfigurations), [VariableReference(dr, []), Expression(value.changingConfigurations, [])]), AssignmentExpression(=, [VariableReference(cs, []), Expression(dr.getConstantState(), [])]), AssignmentExpression(=, [VariableReference(if (cs !, []), Expression(null) {, [])]), Statement(if (mPreloading) {, []), MethodCall(sPreloadedDrawables.put(key, cs), [VariableReference(sPreloadedDrawables, []), Expression(key, []), Expression(cs, [])]), Statement(} else {, []), Statement(synchronized (mTmpValue) {, []), MethodCall(// Integer.toHexString(key.intValue()), [VariableReference(// Integer, []), Expression(key.intValue(), [])]), Statement(// + "" in "" + this + "": "" + cs), []), MethodCall(mDrawableCache.put(key, new WeakReference<Drawable.ConstantState>(cs)), [VariableReference(mDrawableCache, []), Expression(key, []), Expression(new WeakReference<Drawable.ConstantState>(cs), [])]), Statement(}, []), Statement(}, []), Statement(}, []), Statement(}, []), Statement(return dr, []), Statement(}, [])])  Statement({, [])  Statement(if (TRACE_FOR_PRELOAD) {, [])  Statement(// Log only framework resources, [])  AssignmentExpression(=, [VariableReference(if ((id >>> 24), []), Expression(, [])])    VariableReference(if ((id >>> 24), [])    Expression(, [])  AssignmentExpression(=, [VariableReference(final String name, []), Expression(getResourceName(id), [])])    VariableReference(final String name, [])    Expression(getResourceName(id), [])  AssignmentExpression(=, [VariableReference(if (name !, []), Expression(null), [])])    VariableReference(if (name !, [])    Expression(null), [])  Statement(}, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(final long key, []), Expression((((long) value.assetCookie) << 32) | value.data, [])])    VariableReference(final long key, [])    Expression((((long) value.assetCookie) << 32) | value.data, [])  AssignmentExpression(=, [VariableReference(Drawable dr, []), Expression(getCachedDrawable(key), [])])    VariableReference(Drawable dr, [])    Expression(getCachedDrawable(key), [])  AssignmentExpression(=, [VariableReference(if (dr !, []), Expression(null) {, [])])    VariableReference(if (dr !, [])    Expression(null) {, [])  Statement(return dr, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(Drawable.ConstantState cs, []), Expression(mPreloadedDrawables.get(key), [])])    VariableReference(Drawable.ConstantState cs, [])    Expression(mPreloadedDrawables.get(key), [])  AssignmentExpression(=, [VariableReference(if (cs !, []), Expression(null) {, [])])    VariableReference(if (cs !, [])    Expression(null) {, [])  AssignmentExpression(=, [VariableReference(dr, []), Expression(cs.newDrawable(), [])])    VariableReference(dr, [])    Expression(cs.newDrawable(), [])  Statement(} else {, [])  AssignmentExpression(=, [VariableReference(if (value.type >, []), Expression(TypedValue.TYPE_FIRST_COLOR_INT && value.type <, [])])    VariableReference(if (value.type >, [])    Expression(TypedValue.TYPE_FIRST_COLOR_INT && value.type <, [])  AssignmentExpression(=, [VariableReference(dr, []), Expression(new ColorDrawable(value.data), [])])    VariableReference(dr, [])    Expression(new ColorDrawable(value.data), [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(if (dr, []), Expression(, [])])    VariableReference(if (dr, [])    Expression(, [])  AssignmentExpression(=, [VariableReference(if (value.string, []), Expression(, [])])    VariableReference(if (value.string, [])    Expression(, [])  Statement(throw new NotFoundException(""Resource is not a Drawable (color or path): "" + value), [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(String file, []), Expression(value.string.toString(), [])])    VariableReference(String file, [])    Expression(value.string.toString(), [])  Statement(if (DEBUG_LOAD), [])  MethodCall(Log.v(TAG, ""Loading drawable for cookie "" + value.assetCookie + "": "" + file), [VariableReference(Log, []), Expression(TAG, []), Expression(""Loading drawable for cookie "" + value.assetCookie + "": "" + file, [])])    VariableReference(Log, [])    Expression(TAG, [])    Expression(""Loading drawable for cookie "" + value.assetCookie + "": "" + file, [])  MethodCall(if (file.endsWith("".xml"")), [VariableReference(if (file, []), Expression("".xml""), [])])    VariableReference(if (file, [])    Expression("".xml""), [])  Statement(try {, [])  AssignmentExpression(=, [VariableReference(XmlResourceParser rp, []), Expression(loadXmlResourceParser(file, id, value.assetCookie, ""drawable""), [])])    VariableReference(XmlResourceParser rp, [])    Expression(loadXmlResourceParser(file, id, value.assetCookie, ""drawable""), [])  AssignmentExpression(=, [VariableReference(dr, []), Expression(Drawable.createFromXml(this, rp), [])])    VariableReference(dr, [])    Expression(Drawable.createFromXml(this, rp), [])  MethodCall(rp.close(), [VariableReference(rp, []), Expression(, [])])    VariableReference(rp, [])    Expression(, [])  Statement(} catch (Exception e) {, [])  AssignmentExpression(=, [VariableReference(NotFoundException rnf, []), Expression(new NotFoundException(""File "" + file + "" from drawable resource ID #0x"" + Integer.toHexString(id)), [])])    VariableReference(NotFoundException rnf, [])    Expression(new NotFoundException(""File "" + file + "" from drawable resource ID #0x"" + Integer.toHexString(id)), [])  MethodCall(rnf.initCause(e), [VariableReference(rnf, []), Expression(e, [])])    VariableReference(rnf, [])    Expression(e, [])  Statement(throw rnf, [])  Statement(}, [])  Statement(} else {, [])  Statement(try {, [])  AssignmentExpression(=, [VariableReference(InputStream is, []), Expression(mAssets.openNonAsset(value.assetCookie, file, AssetManager.ACCESS_BUFFER), [])])    VariableReference(InputStream is, [])    Expression(mAssets.openNonAsset(value.assetCookie, file, AssetManager.ACCESS_BUFFER), [])  AssignmentExpression(=, [VariableReference(dr, []), Expression(Drawable.createFromResourceStream(this, value, is, file), [])])    VariableReference(dr, [])    Expression(Drawable.createFromResourceStream(this, value, is, file), [])  MethodCall(is.close(), [VariableReference(is, []), Expression(, [])])    VariableReference(is, [])    Expression(, [])  Statement(} catch (Exception e) {, [])  AssignmentExpression(=, [VariableReference(NotFoundException rnf, []), Expression(new NotFoundException(""File "" + file + "" from drawable resource ID #0x"" + Integer.toHexString(id)), [])])    VariableReference(NotFoundException rnf, [])    Expression(new NotFoundException(""File "" + file + "" from drawable resource ID #0x"" + Integer.toHexString(id)), [])  MethodCall(rnf.initCause(e), [VariableReference(rnf, []), Expression(e, [])])    VariableReference(rnf, [])    Expression(e, [])  Statement(throw rnf, [])  Statement(}, [])  Statement(}, [])  Statement(}, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(if (dr !, []), Expression(null) {, [])])    VariableReference(if (dr !, [])    Expression(null) {, [])  MethodCall(dr.setChangingConfigurations(value.changingConfigurations), [VariableReference(dr, []), Expression(value.changingConfigurations, [])])    VariableReference(dr, [])    Expression(value.changingConfigurations, [])  AssignmentExpression(=, [VariableReference(cs, []), Expression(dr.getConstantState(), [])])    VariableReference(cs, [])    Expression(dr.getConstantState(), [])  AssignmentExpression(=, [VariableReference(if (cs !, []), Expression(null) {, [])])    VariableReference(if (cs !, [])    Expression(null) {, [])  Statement(if (mPreloading) {, [])  MethodCall(sPreloadedDrawables.put(key, cs), [VariableReference(sPreloadedDrawables, []), Expression(key, []), Expression(cs, [])])    VariableReference(sPreloadedDrawables, [])    Expression(key, [])    Expression(cs, [])  Statement(} else {, [])  Statement(synchronized (mTmpValue) {, [])  MethodCall(// Integer.toHexString(key.intValue()), [VariableReference(// Integer, []), Expression(key.intValue(), [])])    VariableReference(// Integer, [])    Expression(key.intValue(), [])  Statement(// + "" in "" + this + "": "" + cs), [])  MethodCall(mDrawableCache.put(key, new WeakReference<Drawable.ConstantState>(cs)), [VariableReference(mDrawableCache, []), Expression(key, []), Expression(new WeakReference<Drawable.ConstantState>(cs), [])])    VariableReference(mDrawableCache, [])    Expression(key, [])    Expression(new WeakReference<Drawable.ConstantState>(cs), [])  Statement(}, [])  Statement(}, [])  Statement(}, [])  Statement(}, [])  Statement(return dr, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(if (TRACE_FOR_PRELOAD) {, []), Statement(// Log only framework resources, []), AssignmentExpression(=, [VariableReference(if ((id >>> 24), []), Expression(, [])]), AssignmentExpression(=, [VariableReference(final String name, []), Expression(getResourceName(id), [])]), AssignmentExpression(=, [VariableReference(if (name !, []), Expression(null), [])]), Statement(}, []), Statement(}, []), AssignmentExpression(=, [VariableReference(final long key, []), Expression((((long) value.assetCookie) << 32) | value.data, [])]), AssignmentExpression(=, [VariableReference(Drawable dr, []), Expression(getCachedDrawable(key), [])]), AssignmentExpression(=, [VariableReference(if (dr !, []), Expression(null) {, [])]), Statement(return dr, []), Statement(}, []), AssignmentExpression(=, [VariableReference(Drawable.ConstantState cs, []), Expression(sPreloadedDrawables.get(key), [])]), AssignmentExpression(=, [VariableReference(if (cs !, []), Expression(null) {, [])]), AssignmentExpression(=, [VariableReference(dr, []), Expression(cs.newDrawable(this), [])]), Statement(} else {, []), AssignmentExpression(=, [VariableReference(if (value.type >, []), Expression(TypedValue.TYPE_FIRST_COLOR_INT && value.type <, [])]), AssignmentExpression(=, [VariableReference(dr, []), Expression(new ColorDrawable(value.data), [])]), Statement(}, []), AssignmentExpression(=, [VariableReference(if (dr, []), Expression(, [])]), AssignmentExpression(=, [VariableReference(if (value.string, []), Expression(, [])]), Statement(throw new NotFoundException(""Resource is not a Drawable (color or path): "" + value), []), Statement(}, []), AssignmentExpression(=, [VariableReference(String file, []), Expression(value.string.toString(), [])]), Statement(if (DEBUG_LOAD), []), MethodCall(Log.v(TAG, ""Loading drawable for cookie "" + value.assetCookie + "": "" + file), [VariableReference(Log, []), Expression(TAG, []), Expression(""Loading drawable for cookie "" + value.assetCookie + "": "" + file, [])]), MethodCall(if (file.endsWith("".xml"")), [VariableReference(if (file, []), Expression("".xml""), [])]), Statement(try {, []), AssignmentExpression(=, [VariableReference(XmlResourceParser rp, []), Expression(loadXmlResourceParser(file, id, value.assetCookie, ""drawable""), [])]), AssignmentExpression(=, [VariableReference(dr, []), Expression(Drawable.createFromXml(this, rp), [])]), MethodCall(rp.close(), [VariableReference(rp, []), Expression(, [])]), Statement(} catch (Exception e) {, []), AssignmentExpression(=, [VariableReference(NotFoundException rnf, []), Expression(new NotFoundException(""File "" + file + "" from drawable resource ID #0x"" + Integer.toHexString(id)), [])]), MethodCall(rnf.initCause(e), [VariableReference(rnf, []), Expression(e, [])]), Statement(throw rnf, []), Statement(}, []), Statement(} else {, []), Statement(try {, []), AssignmentExpression(=, [VariableReference(InputStream is, []), Expression(mAssets.openNonAsset(value.assetCookie, file, AssetManager.ACCESS_STREAMING), [])]), AssignmentExpression(=, [VariableReference(dr, []), Expression(Drawable.createFromResourceStream(this, value, is, file, null), [])]), MethodCall(is.close(), [VariableReference(is, []), Expression(, [])]), Statement(} catch (Exception e) {, []), AssignmentExpression(=, [VariableReference(NotFoundException rnf, []), Expression(new NotFoundException(""File "" + file + "" from drawable resource ID #0x"" + Integer.toHexString(id)), [])]), MethodCall(rnf.initCause(e), [VariableReference(rnf, []), Expression(e, [])]), Statement(throw rnf, []), Statement(}, []), Statement(}, []), Statement(}, []), Statement(}, []), AssignmentExpression(=, [VariableReference(if (dr !, []), Expression(null) {, [])]), MethodCall(dr.setChangingConfigurations(value.changingConfigurations), [VariableReference(dr, []), Expression(value.changingConfigurations, [])]), AssignmentExpression(=, [VariableReference(cs, []), Expression(dr.getConstantState(), [])]), AssignmentExpression(=, [VariableReference(if (cs !, []), Expression(null) {, [])]), Statement(if (mPreloading) {, []), MethodCall(sPreloadedDrawables.put(key, cs), [VariableReference(sPreloadedDrawables, []), Expression(key, []), Expression(cs, [])]), Statement(} else {, []), Statement(synchronized (mTmpValue) {, []), MethodCall(// Integer.toHexString(key.intValue()), [VariableReference(// Integer, []), Expression(key.intValue(), [])]), Statement(// + "" in "" + this + "": "" + cs), []), MethodCall(mDrawableCache.put(key, new WeakReference<Drawable.ConstantState>(cs)), [VariableReference(mDrawableCache, []), Expression(key, []), Expression(new WeakReference<Drawable.ConstantState>(cs), [])]), Statement(}, []), Statement(}, []), Statement(}, []), Statement(}, []), Statement(return dr, []), Statement(}, [])])  Statement({, [])  Statement(if (TRACE_FOR_PRELOAD) {, [])  Statement(// Log only framework resources, [])  AssignmentExpression(=, [VariableReference(if ((id >>> 24), []), Expression(, [])])    VariableReference(if ((id >>> 24), [])    Expression(, [])  AssignmentExpression(=, [VariableReference(final String name, []), Expression(getResourceName(id), [])])    VariableReference(final String name, [])    Expression(getResourceName(id), [])  AssignmentExpression(=, [VariableReference(if (name !, []), Expression(null), [])])    VariableReference(if (name !, [])    Expression(null), [])  Statement(}, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(final long key, []), Expression((((long) value.assetCookie) << 32) | value.data, [])])    VariableReference(final long key, [])    Expression((((long) value.assetCookie) << 32) | value.data, [])  AssignmentExpression(=, [VariableReference(Drawable dr, []), Expression(getCachedDrawable(key), [])])    VariableReference(Drawable dr, [])    Expression(getCachedDrawable(key), [])  AssignmentExpression(=, [VariableReference(if (dr !, []), Expression(null) {, [])])    VariableReference(if (dr !, [])    Expression(null) {, [])  Statement(return dr, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(Drawable.ConstantState cs, []), Expression(sPreloadedDrawables.get(key), [])])    VariableReference(Drawable.ConstantState cs, [])    Expression(sPreloadedDrawables.get(key), [])  AssignmentExpression(=, [VariableReference(if (cs !, []), Expression(null) {, [])])    VariableReference(if (cs !, [])    Expression(null) {, [])  AssignmentExpression(=, [VariableReference(dr, []), Expression(cs.newDrawable(this), [])])    VariableReference(dr, [])    Expression(cs.newDrawable(this), [])  Statement(} else {, [])  AssignmentExpression(=, [VariableReference(if (value.type >, []), Expression(TypedValue.TYPE_FIRST_COLOR_INT && value.type <, [])])    VariableReference(if (value.type >, [])    Expression(TypedValue.TYPE_FIRST_COLOR_INT && value.type <, [])  AssignmentExpression(=, [VariableReference(dr, []), Expression(new ColorDrawable(value.data), [])])    VariableReference(dr, [])    Expression(new ColorDrawable(value.data), [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(if (dr, []), Expression(, [])])    VariableReference(if (dr, [])    Expression(, [])  AssignmentExpression(=, [VariableReference(if (value.string, []), Expression(, [])])    VariableReference(if (value.string, [])    Expression(, [])  Statement(throw new NotFoundException(""Resource is not a Drawable (color or path): "" + value), [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(String file, []), Expression(value.string.toString(), [])])    VariableReference(String file, [])    Expression(value.string.toString(), [])  Statement(if (DEBUG_LOAD), [])  MethodCall(Log.v(TAG, ""Loading drawable for cookie "" + value.assetCookie + "": "" + file), [VariableReference(Log, []), Expression(TAG, []), Expression(""Loading drawable for cookie "" + value.assetCookie + "": "" + file, [])])    VariableReference(Log, [])    Expression(TAG, [])    Expression(""Loading drawable for cookie "" + value.assetCookie + "": "" + file, [])  MethodCall(if (file.endsWith("".xml"")), [VariableReference(if (file, []), Expression("".xml""), [])])    VariableReference(if (file, [])    Expression("".xml""), [])  Statement(try {, [])  AssignmentExpression(=, [VariableReference(XmlResourceParser rp, []), Expression(loadXmlResourceParser(file, id, value.assetCookie, ""drawable""), [])])    VariableReference(XmlResourceParser rp, [])    Expression(loadXmlResourceParser(file, id, value.assetCookie, ""drawable""), [])  AssignmentExpression(=, [VariableReference(dr, []), Expression(Drawable.createFromXml(this, rp), [])])    VariableReference(dr, [])    Expression(Drawable.createFromXml(this, rp), [])  MethodCall(rp.close(), [VariableReference(rp, []), Expression(, [])])    VariableReference(rp, [])    Expression(, [])  Statement(} catch (Exception e) {, [])  AssignmentExpression(=, [VariableReference(NotFoundException rnf, []), Expression(new NotFoundException(""File "" + file + "" from drawable resource ID #0x"" + Integer.toHexString(id)), [])])    VariableReference(NotFoundException rnf, [])    Expression(new NotFoundException(""File "" + file + "" from drawable resource ID #0x"" + Integer.toHexString(id)), [])  MethodCall(rnf.initCause(e), [VariableReference(rnf, []), Expression(e, [])])    VariableReference(rnf, [])    Expression(e, [])  Statement(throw rnf, [])  Statement(}, [])  Statement(} else {, [])  Statement(try {, [])  AssignmentExpression(=, [VariableReference(InputStream is, []), Expression(mAssets.openNonAsset(value.assetCookie, file, AssetManager.ACCESS_STREAMING), [])])    VariableReference(InputStream is, [])    Expression(mAssets.openNonAsset(value.assetCookie, file, AssetManager.ACCESS_STREAMING), [])  AssignmentExpression(=, [VariableReference(dr, []), Expression(Drawable.createFromResourceStream(this, value, is, file, null), [])])    VariableReference(dr, [])    Expression(Drawable.createFromResourceStream(this, value, is, file, null), [])  MethodCall(is.close(), [VariableReference(is, []), Expression(, [])])    VariableReference(is, [])    Expression(, [])  Statement(} catch (Exception e) {, [])  AssignmentExpression(=, [VariableReference(NotFoundException rnf, []), Expression(new NotFoundException(""File "" + file + "" from drawable resource ID #0x"" + Integer.toHexString(id)), [])])    VariableReference(NotFoundException rnf, [])    Expression(new NotFoundException(""File "" + file + "" from drawable resource ID #0x"" + Integer.toHexString(id)), [])  MethodCall(rnf.initCause(e), [VariableReference(rnf, []), Expression(e, [])])    VariableReference(rnf, [])    Expression(e, [])  Statement(throw rnf, [])  Statement(}, [])  Statement(}, [])  Statement(}, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(if (dr !, []), Expression(null) {, [])])    VariableReference(if (dr !, [])    Expression(null) {, [])  MethodCall(dr.setChangingConfigurations(value.changingConfigurations), [VariableReference(dr, []), Expression(value.changingConfigurations, [])])    VariableReference(dr, [])    Expression(value.changingConfigurations, [])  AssignmentExpression(=, [VariableReference(cs, []), Expression(dr.getConstantState(), [])])    VariableReference(cs, [])    Expression(dr.getConstantState(), [])  AssignmentExpression(=, [VariableReference(if (cs !, []), Expression(null) {, [])])    VariableReference(if (cs !, [])    Expression(null) {, [])  Statement(if (mPreloading) {, [])  MethodCall(sPreloadedDrawables.put(key, cs), [VariableReference(sPreloadedDrawables, []), Expression(key, []), Expression(cs, [])])    VariableReference(sPreloadedDrawables, [])    Expression(key, [])    Expression(cs, [])  Statement(} else {, [])  Statement(synchronized (mTmpValue) {, [])  MethodCall(// Integer.toHexString(key.intValue()), [VariableReference(// Integer, []), Expression(key.intValue(), [])])    VariableReference(// Integer, [])    Expression(key.intValue(), [])  Statement(// + "" in "" + this + "": "" + cs), [])  MethodCall(mDrawableCache.put(key, new WeakReference<Drawable.ConstantState>(cs)), [VariableReference(mDrawableCache, []), Expression(key, []), Expression(new WeakReference<Drawable.ConstantState>(cs), [])])    VariableReference(mDrawableCache, [])    Expression(key, [])    Expression(new WeakReference<Drawable.ConstantState>(cs), [])  Statement(}, [])  Statement(}, [])  Statement(}, [])  Statement(}, [])  Statement(return dr, [])  Statement(}, [])",1,"/*package*/
","/*package*/
",0,,,0,0,0,0,"1,2","1,3,4,5",1,"2,3,4","1,2","Comparing the implementations in both versions, changes in exception handling, control dependency, and other statements can be seen. Hence, the change classification is 2,3,4.","The change in exception handling (from catch block) has a potential to throw different exceptions. Furthermore, the changes in control structures (such as while loop conditions etc. can lead to potentially returning different values or throwing different exceptions), therefore the compatibility issue (CI) classification is 1,2."
35,"<android.content.pm.ResolveInfo: void dump(Printer,String)>",4,5,"<android.content.pm.ResolveInfo: void dump(Printer,String)>","<android.content.pm.ResolveInfo: void dump(Printer,String)>",0,"MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(if (filter !, []), Expression(null) {, [])]), MethodCall(pw.println(prefix + ""Filter:""), [VariableReference(pw, []), Expression(prefix + ""Filter:"", [])]), MethodCall(filter.dump(pw, prefix + ""  ""), [VariableReference(filter, []), Expression(pw, []), Expression(prefix + ""  "", [])]), Statement(} else {, []), MethodCall(pw.println(prefix + ""Filter: null""), [VariableReference(pw, []), Expression(prefix + ""Filter: null"", [])]), Statement(}, []), AssignmentExpression(=, [VariableReference(pw.println(prefix + ""priority, []), Expression("" + priority + "" preferredOrder, [])]), AssignmentExpression(=, [VariableReference(pw.println(prefix + ""labelRes, []), Expression(0x"" + Integer.toHexString(labelRes) + "" nonLocalizedLabel, [])]), AssignmentExpression(=, [VariableReference(if (activityInfo !, []), Expression(null) {, [])]), MethodCall(pw.println(prefix + ""ActivityInfo:""), [VariableReference(pw, []), Expression(prefix + ""ActivityInfo:"", [])]), MethodCall(activityInfo.dump(pw, prefix + ""  ""), [VariableReference(activityInfo, []), Expression(pw, []), Expression(prefix + ""  "", [])]), AssignmentExpression(=, [VariableReference(} else if (serviceInfo !, []), Expression(null) {, [])]), MethodCall(pw.println(prefix + ""ServiceInfo:""), [VariableReference(pw, []), Expression(prefix + ""ServiceInfo:"", [])]), Statement(// TODO, []), MethodCall(// serviceInfo.dump(pw, prefix + ""  ""), [VariableReference(// serviceInfo, []), Expression(pw, []), Expression(prefix + ""  "", [])]), Statement(}, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(if (filter !, []), Expression(null) {, [])])    VariableReference(if (filter !, [])    Expression(null) {, [])  MethodCall(pw.println(prefix + ""Filter:""), [VariableReference(pw, []), Expression(prefix + ""Filter:"", [])])    VariableReference(pw, [])    Expression(prefix + ""Filter:"", [])  MethodCall(filter.dump(pw, prefix + ""  ""), [VariableReference(filter, []), Expression(pw, []), Expression(prefix + ""  "", [])])    VariableReference(filter, [])    Expression(pw, [])    Expression(prefix + ""  "", [])  Statement(} else {, [])  MethodCall(pw.println(prefix + ""Filter: null""), [VariableReference(pw, []), Expression(prefix + ""Filter: null"", [])])    VariableReference(pw, [])    Expression(prefix + ""Filter: null"", [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(pw.println(prefix + ""priority, []), Expression("" + priority + "" preferredOrder, [])])    VariableReference(pw.println(prefix + ""priority, [])    Expression("" + priority + "" preferredOrder, [])  AssignmentExpression(=, [VariableReference(pw.println(prefix + ""labelRes, []), Expression(0x"" + Integer.toHexString(labelRes) + "" nonLocalizedLabel, [])])    VariableReference(pw.println(prefix + ""labelRes, [])    Expression(0x"" + Integer.toHexString(labelRes) + "" nonLocalizedLabel, [])  AssignmentExpression(=, [VariableReference(if (activityInfo !, []), Expression(null) {, [])])    VariableReference(if (activityInfo !, [])    Expression(null) {, [])  MethodCall(pw.println(prefix + ""ActivityInfo:""), [VariableReference(pw, []), Expression(prefix + ""ActivityInfo:"", [])])    VariableReference(pw, [])    Expression(prefix + ""ActivityInfo:"", [])  MethodCall(activityInfo.dump(pw, prefix + ""  ""), [VariableReference(activityInfo, []), Expression(pw, []), Expression(prefix + ""  "", [])])    VariableReference(activityInfo, [])    Expression(pw, [])    Expression(prefix + ""  "", [])  AssignmentExpression(=, [VariableReference(} else if (serviceInfo !, []), Expression(null) {, [])])    VariableReference(} else if (serviceInfo !, [])    Expression(null) {, [])  MethodCall(pw.println(prefix + ""ServiceInfo:""), [VariableReference(pw, []), Expression(prefix + ""ServiceInfo:"", [])])    VariableReference(pw, [])    Expression(prefix + ""ServiceInfo:"", [])  Statement(// TODO, [])  MethodCall(// serviceInfo.dump(pw, prefix + ""  ""), [VariableReference(// serviceInfo, []), Expression(pw, []), Expression(prefix + ""  "", [])])    VariableReference(// serviceInfo, [])    Expression(pw, [])    Expression(prefix + ""  "", [])  Statement(}, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(if (filter !, []), Expression(null) {, [])]), MethodCall(pw.println(prefix + ""Filter:""), [VariableReference(pw, []), Expression(prefix + ""Filter:"", [])]), MethodCall(filter.dump(pw, prefix + ""  ""), [VariableReference(filter, []), Expression(pw, []), Expression(prefix + ""  "", [])]), Statement(}, []), AssignmentExpression(=, [VariableReference(pw.println(prefix + ""priority, []), Expression("" + priority + "" preferredOrder, [])]), AssignmentExpression(=, [VariableReference(if (resolvePackageName !, []), Expression(null) {, [])]), AssignmentExpression(=, [VariableReference(pw.println(prefix + ""resolvePackageName, []), Expression("" + resolvePackageName), [])]), Statement(}, []), AssignmentExpression(=, [VariableReference(if (labelRes !, []), Expression(0 || nonLocalizedLabel !, [])]), AssignmentExpression(=, [VariableReference(pw.println(prefix + ""labelRes, []), Expression(0x"" + Integer.toHexString(labelRes) + "" nonLocalizedLabel, [])]), Statement(}, []), AssignmentExpression(=, [VariableReference(if (activityInfo !, []), Expression(null) {, [])]), MethodCall(pw.println(prefix + ""ActivityInfo:""), [VariableReference(pw, []), Expression(prefix + ""ActivityInfo:"", [])]), MethodCall(activityInfo.dump(pw, prefix + ""  ""), [VariableReference(activityInfo, []), Expression(pw, []), Expression(prefix + ""  "", [])]), AssignmentExpression(=, [VariableReference(} else if (serviceInfo !, []), Expression(null) {, [])]), MethodCall(pw.println(prefix + ""ServiceInfo:""), [VariableReference(pw, []), Expression(prefix + ""ServiceInfo:"", [])]), MethodCall(serviceInfo.dump(pw, prefix + ""  ""), [VariableReference(serviceInfo, []), Expression(pw, []), Expression(prefix + ""  "", [])]), Statement(}, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(if (filter !, []), Expression(null) {, [])])    VariableReference(if (filter !, [])    Expression(null) {, [])  MethodCall(pw.println(prefix + ""Filter:""), [VariableReference(pw, []), Expression(prefix + ""Filter:"", [])])    VariableReference(pw, [])    Expression(prefix + ""Filter:"", [])  MethodCall(filter.dump(pw, prefix + ""  ""), [VariableReference(filter, []), Expression(pw, []), Expression(prefix + ""  "", [])])    VariableReference(filter, [])    Expression(pw, [])    Expression(prefix + ""  "", [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(pw.println(prefix + ""priority, []), Expression("" + priority + "" preferredOrder, [])])    VariableReference(pw.println(prefix + ""priority, [])    Expression("" + priority + "" preferredOrder, [])  AssignmentExpression(=, [VariableReference(if (resolvePackageName !, []), Expression(null) {, [])])    VariableReference(if (resolvePackageName !, [])    Expression(null) {, [])  AssignmentExpression(=, [VariableReference(pw.println(prefix + ""resolvePackageName, []), Expression("" + resolvePackageName), [])])    VariableReference(pw.println(prefix + ""resolvePackageName, [])    Expression("" + resolvePackageName), [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(if (labelRes !, []), Expression(0 || nonLocalizedLabel !, [])])    VariableReference(if (labelRes !, [])    Expression(0 || nonLocalizedLabel !, [])  AssignmentExpression(=, [VariableReference(pw.println(prefix + ""labelRes, []), Expression(0x"" + Integer.toHexString(labelRes) + "" nonLocalizedLabel, [])])    VariableReference(pw.println(prefix + ""labelRes, [])    Expression(0x"" + Integer.toHexString(labelRes) + "" nonLocalizedLabel, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(if (activityInfo !, []), Expression(null) {, [])])    VariableReference(if (activityInfo !, [])    Expression(null) {, [])  MethodCall(pw.println(prefix + ""ActivityInfo:""), [VariableReference(pw, []), Expression(prefix + ""ActivityInfo:"", [])])    VariableReference(pw, [])    Expression(prefix + ""ActivityInfo:"", [])  MethodCall(activityInfo.dump(pw, prefix + ""  ""), [VariableReference(activityInfo, []), Expression(pw, []), Expression(prefix + ""  "", [])])    VariableReference(activityInfo, [])    Expression(pw, [])    Expression(prefix + ""  "", [])  AssignmentExpression(=, [VariableReference(} else if (serviceInfo !, []), Expression(null) {, [])])    VariableReference(} else if (serviceInfo !, [])    Expression(null) {, [])  MethodCall(pw.println(prefix + ""ServiceInfo:""), [VariableReference(pw, []), Expression(prefix + ""ServiceInfo:"", [])])    VariableReference(pw, [])    Expression(prefix + ""ServiceInfo:"", [])  MethodCall(serviceInfo.dump(pw, prefix + ""  ""), [VariableReference(serviceInfo, []), Expression(pw, []), Expression(prefix + ""  "", [])])    VariableReference(serviceInfo, [])    Expression(pw, [])    Expression(prefix + ""  "", [])  Statement(}, [])  Statement(}, [])",1,,,0,,,0,0,0,0,1,"2,4",0,"1,3,4",1,"There are several changes between the early and late versions. Firstly, the early version has a `filter.dump` method, but there is no corresponding piece in the late version. Secondly, the late version introduces a new condition `if (resolvePackageName != null) {...}` and a new method `serviceInfo.dump(pw, prefix + ""  "")`. Besides, in the `if (labelRes != 0 || nonLocalizedLabel != null) {...}` block, the condition has been changed and an extra `if (activityInfo != null) {...}` block is added in the late version. Additionally, several print statements have been modified to include additional object information such as `resolvePakcageName` and `labelRes`. Thus, the code change type includes 1 (Return statement changed), 3 (Control dependency changed) and 4 (Other statements change).","Due to the difference in if-conditions and return statements in the early and late versions, the method can potentially return different results based on the versions used, hence, a compatibility issue (Type 1) may arise."
36,<android.webkit.WebView: void clearMatches()>,4,5,<android.webkit.WebView: void clearMatches()>,<android.webkit.WebView: void clearMatches()>,0,"MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(mFindIsUp, []), Expression(false, [])]), Statement(nativeSetFindIsDown(), []), Statement(// Now that the dialog has been removed, ensure that we scroll to a, []), Statement(// location that is not beyond the end of the page., []), Statement(pinScrollTo(mScrollX, mScrollY, false, 0), []), Statement(invalidate(), []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(mFindIsUp, []), Expression(false, [])])    VariableReference(mFindIsUp, [])    Expression(false, [])  Statement(nativeSetFindIsDown(), [])  Statement(// Now that the dialog has been removed, ensure that we scroll to a, [])  Statement(// location that is not beyond the end of the page., [])  Statement(pinScrollTo(mScrollX, mScrollY, false, 0), [])  Statement(invalidate(), [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(if (mFindIsUp) {, []), Statement(recordNewContentSize(mContentWidth, mContentHeight - mFindHeight, false), []), AssignmentExpression(=, [VariableReference(mFindIsUp, []), Expression(false, [])]), Statement(}, []), Statement(nativeSetFindIsDown(), []), Statement(// Now that the dialog has been removed, ensure that we scroll to a, []), Statement(// location that is not beyond the end of the page., []), Statement(pinScrollTo(mScrollX, mScrollY, false, 0), []), Statement(invalidate(), []), Statement(}, [])])  Statement({, [])  Statement(if (mFindIsUp) {, [])  Statement(recordNewContentSize(mContentWidth, mContentHeight - mFindHeight, false), [])  AssignmentExpression(=, [VariableReference(mFindIsUp, []), Expression(false, [])])    VariableReference(mFindIsUp, [])    Expression(false, [])  Statement(}, [])  Statement(nativeSetFindIsDown(), [])  Statement(// Now that the dialog has been removed, ensure that we scroll to a, [])  Statement(// location that is not beyond the end of the page., [])  Statement(pinScrollTo(mScrollX, mScrollY, false, 0), [])  Statement(invalidate(), [])  Statement(}, [])",1,"/*
     * Clear the highlighting surrounding text matches created by findAll.
     */
","/*
     * Clear the highlighting surrounding text matches created by findAll.
     */
",0,,,0,0,0,0,1,"2,4",0,"3,4",0,"The early version and late version implementation both clear the highlighting of text matches in WebView. However, the late version adds an 'if' condition to check if mFindIsUp is true before executing recordNewContentSize(), meanwhile, this part is not present in the early version. Hence, we have a control dependency change. Additionally, there's a change of the method being called, hence the type is 3,4.","Despite the changes in the implementations between the two versions of this method, the fundamental behavior of the API (which is to clear the text matches highlight) remains unchanged across versions. Thus, no compatibility issues were detected. This means a client program that calls this method from either API version will still achieve the intended function which is the clearing of highlights of text matches. Therefore, the CI type is 0."
37,<android.widget.VideoView: boolean isPlaying()>,4,5,<android.widget.VideoView: boolean isPlaying()>,<android.widget.VideoView: boolean isPlaying()>,0,"MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(if (mMediaPlayer !, []), Expression(null && mIsPrepared) {, [])]), MethodCall(return mMediaPlayer.isPlaying(), [VariableReference(return mMediaPlayer, []), Expression(, [])]), Statement(}, []), Statement(return false, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(if (mMediaPlayer !, []), Expression(null && mIsPrepared) {, [])])    VariableReference(if (mMediaPlayer !, [])    Expression(null && mIsPrepared) {, [])  MethodCall(return mMediaPlayer.isPlaying(), [VariableReference(return mMediaPlayer, []), Expression(, [])])    VariableReference(return mMediaPlayer, [])    Expression(, [])  Statement(}, [])  Statement(return false, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), MethodCall(return isInPlaybackState() && mMediaPlayer.isPlaying(), [VariableReference(return isInPlaybackState() && mMediaPlayer, []), Expression(, [])]), Statement(}, [])])  Statement({, [])  MethodCall(return isInPlaybackState() && mMediaPlayer.isPlaying(), [VariableReference(return isInPlaybackState() && mMediaPlayer, []), Expression(, [])])    VariableReference(return isInPlaybackState() && mMediaPlayer, [])    Expression(, [])  Statement(}, [])",1,,,0,,,0,0,0,0,1,"1,2",1,"1,3,5",1,"The return statement has changed from 'if (mMediaPlayer != null&& mIsPrepared) { \n return mMediaPlayer.isPlaying();\n } \n return false;' to 'return isInPlaybackState() && mMediaPlayer.isPlaying();'. The if statement block has been replaced by 'isInPlaybackState()' method call. Also, 'mIsPrepared' isn't used in the late implementation. These changes correspond to the code change types 1, 3 and 5.","The change in return statement and introduction of a new method call 'isInPlaybackState()' replacing the if block could potentially lead to the late version API returning a different value than the early version API. Therefore, the compatibility issue type is 1."
39,<android.view.Surface: String toString()>,4,5,<android.view.Surface: String toString()>,<android.view.Surface: String toString()>,0,"MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(return ""Surface(native-token, []), Expression("" + mSurface + "")"", [])]), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(return ""Surface(native-token, []), Expression("" + mSurface + "")"", [])])    VariableReference(return ""Surface(native-token, [])    Expression("" + mSurface + "")"", [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(return ""Surface(native-token, []), Expression("" + mSurfaceControl + "")"", [])]), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(return ""Surface(native-token, []), Expression("" + mSurfaceControl + "")"", [])])    VariableReference(return ""Surface(native-token, [])    Expression("" + mSurfaceControl + "")"", [])  Statement(}, [])",1,,,0,[@Override],[@Override],0,0,0,0,1,1,1,"1,5",1,"The return statement has changed from ""+ mSurface"" to ""+ mSurfaceControl"", and the dependent API mSurface changed to mSurfaceControl, so the code change type is 1,5.","The change of hte return statement will make the API potentially return a different String value, so the CI type is 1."
40,<android.webkit.BrowserFrame: void didFirstLayout()>,4,5,<android.webkit.BrowserFrame: void didFirstLayout()>,<android.webkit.BrowserFrame: void didFirstLayout()>,0,"MethodDeclaration(method_body, [Statement({, []), Statement(if (!mFirstLayoutDone) {, []), AssignmentExpression(=, [VariableReference(mFirstLayoutDone, []), Expression(true, [])]), Statement(// ensure {@link WebViewCore#webkitDraw} is called as we were, []), Statement(// blocking the update in {@link #loadStarted}, []), MethodCall(mWebViewCore.contentDraw(), [VariableReference(mWebViewCore, []), Expression(, [])]), Statement(}, []), AssignmentExpression(=, [VariableReference(mWebViewCore.mEndScaleZoom, []), Expression(true, [])]), Statement(}, [])])  Statement({, [])  Statement(if (!mFirstLayoutDone) {, [])  AssignmentExpression(=, [VariableReference(mFirstLayoutDone, []), Expression(true, [])])    VariableReference(mFirstLayoutDone, [])    Expression(true, [])  Statement(// ensure {@link WebViewCore#webkitDraw} is called as we were, [])  Statement(// blocking the update in {@link #loadStarted}, [])  MethodCall(mWebViewCore.contentDraw(), [VariableReference(mWebViewCore, []), Expression(, [])])    VariableReference(mWebViewCore, [])    Expression(, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(mWebViewCore.mEndScaleZoom, []), Expression(true, [])])    VariableReference(mWebViewCore.mEndScaleZoom, [])    Expression(true, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(if (!mFirstLayoutDone) {, []), AssignmentExpression(=, [VariableReference(mFirstLayoutDone, []), Expression(true, [])]), Statement(// ensure {@link WebViewCore#webkitDraw} is called as we were, []), Statement(// blocking the update in {@link #loadStarted}, []), MethodCall(mWebViewCore.contentDraw(), [VariableReference(mWebViewCore, []), Expression(, [])]), Statement(}, []), Statement(}, [])])  Statement({, [])  Statement(if (!mFirstLayoutDone) {, [])  AssignmentExpression(=, [VariableReference(mFirstLayoutDone, []), Expression(true, [])])    VariableReference(mFirstLayoutDone, [])    Expression(true, [])  Statement(// ensure {@link WebViewCore#webkitDraw} is called as we were, [])  Statement(// blocking the update in {@link #loadStarted}, [])  MethodCall(mWebViewCore.contentDraw(), [VariableReference(mWebViewCore, []), Expression(, [])])    VariableReference(mWebViewCore, [])    Expression(, [])  Statement(}, [])  Statement(}, [])",1,"/* package */
","/* package */
",0,,,0,0,0,0,1,"3,4",0,4,0,"The assignment statement 'mWebViewCore.mEndScaleZoom = true' has been removed in the late version, the code change type is 4.","The removal of this assignment statement will not affect the return result of the method nor throw a different exception, so no CI exists. The CI type is 0."
41,<android.hardware.Camera.Parameters: void setPictureFormat(int)>,4,5,<android.hardware.Camera.Parameters: void setPictureFormat(int)>,<android.hardware.Camera.Parameters: void setPictureFormat(int)>,0,"MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(String s, []), Expression(cameraFormatForPixelFormat(pixel_format), [])]), AssignmentExpression(=, [VariableReference(if (s, []), Expression(, [])]), Statement(throw new IllegalArgumentException(), []), Statement(}, []), Statement(set(""picture-format"", s), []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(String s, []), Expression(cameraFormatForPixelFormat(pixel_format), [])])    VariableReference(String s, [])    Expression(cameraFormatForPixelFormat(pixel_format), [])  AssignmentExpression(=, [VariableReference(if (s, []), Expression(, [])])    VariableReference(if (s, [])    Expression(, [])  Statement(throw new IllegalArgumentException(), [])  Statement(}, [])  Statement(set(""picture-format"", s), [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(String s, []), Expression(cameraFormatForPixelFormat(pixel_format), [])]), AssignmentExpression(=, [VariableReference(if (s, []), Expression(, [])]), AssignmentExpression(=, [VariableReference(throw new IllegalArgumentException(""Invalid pixel_format, []), Expression("" + pixel_format), [])]), Statement(}, []), Statement(set(KEY_PICTURE_FORMAT, s), []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(String s, []), Expression(cameraFormatForPixelFormat(pixel_format), [])])    VariableReference(String s, [])    Expression(cameraFormatForPixelFormat(pixel_format), [])  AssignmentExpression(=, [VariableReference(if (s, []), Expression(, [])])    VariableReference(if (s, [])    Expression(, [])  AssignmentExpression(=, [VariableReference(throw new IllegalArgumentException(""Invalid pixel_format, []), Expression("" + pixel_format), [])])    VariableReference(throw new IllegalArgumentException(""Invalid pixel_format, [])    Expression("" + pixel_format), [])  Statement(}, [])  Statement(set(KEY_PICTURE_FORMAT, s), [])  Statement(}, [])",1,"/**
 * Sets the image format for pictures.
 *
 * @param pixel_format the desired picture format
 * (<var>PixelFormat.YCbCr_420_SP</var>,
 * <var>PixelFormat.RGB_565</var>, or
 * <var>PixelFormat.JPEG</var>)
 * @see android.graphics.PixelFormat
 */
","/**
 * Sets the image format for pictures.
 *
 * @param pixel_format the desired picture format
 * (<var>PixelFormat.YCbCr_420_SP (NV21)</var>,
 * <var>PixelFormat.RGB_565</var>, or
 * <var>PixelFormat.JPEG</var>)
 * @see android.graphics.PixelFormat
 */
",1,,,0,0,0,0,"1,2","2,3,4,5",2,"1,2,4","1,2","In the implementation, the exception handling statement 'throw new IllegalArgumentException()' has been replaced with 'throw new IllegalArgumentException(""Invalid pixel_format"" + pixel_format)'. The same happened to 'set(""picture-format"", s)' - it was replaced with 'set(KEY_PICTURE_FORMAT, s?. The argument descriptions in both functions have also been modified. So the code change type is 1,2,4.","The change in exception handling means that the new version of the method may throw a differently identified exception (with a new message). Also, the change in argument of the set() method might make the API return a different value. Therefore, the CI type is 1,2."
42,<android.hardware.Camera.Parameters: Size getPictureSize()>,4,5,<android.hardware.Camera.Parameters: Size getPictureSize()>,<android.hardware.Camera.Parameters: Size getPictureSize()>,0,"MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(String pair, []), Expression(get(""picture-size""), [])]), AssignmentExpression(=, [VariableReference(if (pair, []), Expression(, [])]), Statement(return null, []), AssignmentExpression(=, [VariableReference(String[] dims, []), Expression(pair.split(""x""), [])]), AssignmentExpression(=, [VariableReference(if (dims.length !, []), Expression(2), [])]), Statement(return null, []), MethodCall(return new Size(Integer.parseInt(dims[0]), Integer.parseInt(dims[1])), [VariableReference(return new Size(Integer, []), Expression(dims[0]), []), Expression(Integer.parseInt(dims[1]), [])]), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(String pair, []), Expression(get(""picture-size""), [])])    VariableReference(String pair, [])    Expression(get(""picture-size""), [])  AssignmentExpression(=, [VariableReference(if (pair, []), Expression(, [])])    VariableReference(if (pair, [])    Expression(, [])  Statement(return null, [])  AssignmentExpression(=, [VariableReference(String[] dims, []), Expression(pair.split(""x""), [])])    VariableReference(String[] dims, [])    Expression(pair.split(""x""), [])  AssignmentExpression(=, [VariableReference(if (dims.length !, []), Expression(2), [])])    VariableReference(if (dims.length !, [])    Expression(2), [])  Statement(return null, [])  MethodCall(return new Size(Integer.parseInt(dims[0]), Integer.parseInt(dims[1])), [VariableReference(return new Size(Integer, []), Expression(dims[0]), []), Expression(Integer.parseInt(dims[1]), [])])    VariableReference(return new Size(Integer, [])    Expression(dims[0]), [])    Expression(Integer.parseInt(dims[1]), [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(String pair, []), Expression(get(KEY_PICTURE_SIZE), [])]), Statement(return strToSize(pair), []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(String pair, []), Expression(get(KEY_PICTURE_SIZE), [])])    VariableReference(String pair, [])    Expression(get(KEY_PICTURE_SIZE), [])  Statement(return strToSize(pair), [])  Statement(}, [])",1,"/**
 * Returns the dimension setting for pictures.
 *
 * @return a Size object with the height and width setting
 * for pictures
 */
","/**
 * Returns the dimension setting for pictures.
 *
 * @return a Size object with the height and width setting
 * for pictures
 */
",0,,,0,0,0,0,1,"1,3,4",1,"1,4,5",1,"The return statement has changed from a sizable block that manipulates a string to retrieve the desired Size object to a direct invocation of strToSize(pair). This includes the addition or removal of specific expressions and assignments which counts as other statement change. Moreover, the getter method also has a changed argument from a regular string to the KEY_PICTURE_SIZE constant which counts as a dependent API change. Therefore, the change types are 1, 4, 5.","The change in return statement can potentially lead to different behaviors of the Method, therefore CI type is 1."
43,<android.animation.ValueAnimator: void end()>,15,16,<android.animation.ValueAnimator: void end()>,<android.animation.ValueAnimator: void end()>,0,"MethodDeclaration(method_body, [Statement({, []), MethodCall(if (!sAnimations.get().contains(this) && !sPendingAnimations.get().contains(this)), [VariableReference(if (!sAnimations, []), Expression().contains(this) && !sPendingAnimations.get().contains(this), [])]), Statement(// Special case if the animation has not yet started, []), Statement(get it ready for ending, []), AssignmentExpression(=, [VariableReference(mStartedDelay, []), Expression(false, [])]), Statement(startAnimation(), []), Statement(} else if (!mInitialized) {, []), Statement(initAnimation(), []), Statement(}, []), Statement(// was supposed to repeat an odd number of times, []), AssignmentExpression(=, [VariableReference(if (mRepeatCount > 0 && (mRepeatCount & 0x01), []), Expression(, [])]), Statement(animateValue(0f), []), Statement(} else {, []), Statement(animateValue(1f), []), Statement(}, []), Statement(endAnimation(), []), Statement(}, [])])  Statement({, [])  MethodCall(if (!sAnimations.get().contains(this) && !sPendingAnimations.get().contains(this)), [VariableReference(if (!sAnimations, []), Expression().contains(this) && !sPendingAnimations.get().contains(this), [])])    VariableReference(if (!sAnimations, [])    Expression().contains(this) && !sPendingAnimations.get().contains(this), [])  Statement(// Special case if the animation has not yet started, [])  Statement(get it ready for ending, [])  AssignmentExpression(=, [VariableReference(mStartedDelay, []), Expression(false, [])])    VariableReference(mStartedDelay, [])    Expression(false, [])  Statement(startAnimation(), [])  Statement(} else if (!mInitialized) {, [])  Statement(initAnimation(), [])  Statement(}, [])  Statement(// was supposed to repeat an odd number of times, [])  AssignmentExpression(=, [VariableReference(if (mRepeatCount > 0 && (mRepeatCount & 0x01), []), Expression(, [])])    VariableReference(if (mRepeatCount > 0 && (mRepeatCount & 0x01), [])    Expression(, [])  Statement(animateValue(0f), [])  Statement(} else {, [])  Statement(animateValue(1f), [])  Statement(}, [])  Statement(endAnimation(), [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(AnimationHandler handler, []), Expression(getOrCreateAnimationHandler(), [])]), Statement(// Special case if the animation has not yet started, []), Statement(get it ready for ending, []), AssignmentExpression(=, [VariableReference(mStartedDelay, []), Expression(false, [])]), Statement(startAnimation(handler), []), AssignmentExpression(=, [VariableReference(mStarted, []), Expression(true, [])]), Statement(} else if (!mInitialized) {, []), Statement(initAnimation(), []), Statement(}, []), Statement(// was supposed to repeat an odd number of times, []), AssignmentExpression(=, [VariableReference(if (mRepeatCount > 0 && (mRepeatCount & 0x01), []), Expression(, [])]), Statement(animateValue(0f), []), Statement(} else {, []), Statement(animateValue(1f), []), Statement(}, []), Statement(endAnimation(handler), []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(AnimationHandler handler, []), Expression(getOrCreateAnimationHandler(), [])])    VariableReference(AnimationHandler handler, [])    Expression(getOrCreateAnimationHandler(), [])  Statement(// Special case if the animation has not yet started, [])  Statement(get it ready for ending, [])  AssignmentExpression(=, [VariableReference(mStartedDelay, []), Expression(false, [])])    VariableReference(mStartedDelay, [])    Expression(false, [])  Statement(startAnimation(handler), [])  AssignmentExpression(=, [VariableReference(mStarted, []), Expression(true, [])])    VariableReference(mStarted, [])    Expression(true, [])  Statement(} else if (!mInitialized) {, [])  Statement(initAnimation(), [])  Statement(}, [])  Statement(// was supposed to repeat an odd number of times, [])  AssignmentExpression(=, [VariableReference(if (mRepeatCount > 0 && (mRepeatCount & 0x01), []), Expression(, [])])    VariableReference(if (mRepeatCount > 0 && (mRepeatCount & 0x01), [])    Expression(, [])  Statement(animateValue(0f), [])  Statement(} else {, [])  Statement(animateValue(1f), [])  Statement(}, [])  Statement(endAnimation(handler), [])  Statement(}, [])",1,,,0,[@Override],[@Override],0,0,0,0,"1,2","3,4",0,"3,4",0,"The change occurs in the control dependency where a condition checking is removed in the later version (if (!sAnimations.get().contains(this) && !sPendingAnimations.get().contains(this))). There's also a newly introduced variable ""AnimationHandler handler = getOrCreateAnimationHandler();"" which is then passed as a parameter to the 'startAnimation()' and 'endAnimation()' methods. Hence, the code change types are 3,4.","Despite the changes, there is no difference in return types or values and exception handlings between the two versions, therefore no Compatibility Issue is detected."
44,<android.app.Activity: void onConfigurationChanged(Configuration)>,15,16,<android.app.Activity: void onConfigurationChanged(Configuration)>,<android.app.Activity: void onConfigurationChanged(Configuration)>,0,"MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(mCalled, []), Expression(true, [])]), MethodCall(mFragments.dispatchConfigurationChanged(newConfig), [VariableReference(mFragments, []), Expression(newConfig, [])]), AssignmentExpression(=, [VariableReference(if (mWindow !, []), Expression(null) {, [])]), Statement(// Pass the configuration changed event to the window, []), MethodCall(mWindow.onConfigurationChanged(newConfig), [VariableReference(mWindow, []), Expression(newConfig, [])]), Statement(}, []), AssignmentExpression(=, [VariableReference(if (mActionBar !, []), Expression(null) {, [])]), Statement(// Do this last, []), Statement(the action bar will need to access, []), Statement(// view changes from above., []), MethodCall(mActionBar.onConfigurationChanged(newConfig), [VariableReference(mActionBar, []), Expression(newConfig, [])]), Statement(}, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(mCalled, []), Expression(true, [])])    VariableReference(mCalled, [])    Expression(true, [])  MethodCall(mFragments.dispatchConfigurationChanged(newConfig), [VariableReference(mFragments, []), Expression(newConfig, [])])    VariableReference(mFragments, [])    Expression(newConfig, [])  AssignmentExpression(=, [VariableReference(if (mWindow !, []), Expression(null) {, [])])    VariableReference(if (mWindow !, [])    Expression(null) {, [])  Statement(// Pass the configuration changed event to the window, [])  MethodCall(mWindow.onConfigurationChanged(newConfig), [VariableReference(mWindow, []), Expression(newConfig, [])])    VariableReference(mWindow, [])    Expression(newConfig, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(if (mActionBar !, []), Expression(null) {, [])])    VariableReference(if (mActionBar !, [])    Expression(null) {, [])  Statement(// Do this last, [])  Statement(the action bar will need to access, [])  Statement(// view changes from above., [])  MethodCall(mActionBar.onConfigurationChanged(newConfig), [VariableReference(mActionBar, []), Expression(newConfig, [])])    VariableReference(mActionBar, [])    Expression(newConfig, [])  Statement(}, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(if (DEBUG_LIFECYCLE), []), MethodCall(Slog.v(TAG, ""onConfigurationChanged "" + this + "": "" + newConfig), [VariableReference(Slog, []), Expression(TAG, []), Expression(""onConfigurationChanged "" + this + "": "" + newConfig, [])]), AssignmentExpression(=, [VariableReference(mCalled, []), Expression(true, [])]), MethodCall(mFragments.dispatchConfigurationChanged(newConfig), [VariableReference(mFragments, []), Expression(newConfig, [])]), AssignmentExpression(=, [VariableReference(if (mWindow !, []), Expression(null) {, [])]), Statement(// Pass the configuration changed event to the window, []), MethodCall(mWindow.onConfigurationChanged(newConfig), [VariableReference(mWindow, []), Expression(newConfig, [])]), Statement(}, []), AssignmentExpression(=, [VariableReference(if (mActionBar !, []), Expression(null) {, [])]), Statement(// Do this last, []), Statement(the action bar will need to access, []), Statement(// view changes from above., []), MethodCall(mActionBar.onConfigurationChanged(newConfig), [VariableReference(mActionBar, []), Expression(newConfig, [])]), Statement(}, []), Statement(}, [])])  Statement({, [])  Statement(if (DEBUG_LIFECYCLE), [])  MethodCall(Slog.v(TAG, ""onConfigurationChanged "" + this + "": "" + newConfig), [VariableReference(Slog, []), Expression(TAG, []), Expression(""onConfigurationChanged "" + this + "": "" + newConfig, [])])    VariableReference(Slog, [])    Expression(TAG, [])    Expression(""onConfigurationChanged "" + this + "": "" + newConfig, [])  AssignmentExpression(=, [VariableReference(mCalled, []), Expression(true, [])])    VariableReference(mCalled, [])    Expression(true, [])  MethodCall(mFragments.dispatchConfigurationChanged(newConfig), [VariableReference(mFragments, []), Expression(newConfig, [])])    VariableReference(mFragments, [])    Expression(newConfig, [])  AssignmentExpression(=, [VariableReference(if (mWindow !, []), Expression(null) {, [])])    VariableReference(if (mWindow !, [])    Expression(null) {, [])  Statement(// Pass the configuration changed event to the window, [])  MethodCall(mWindow.onConfigurationChanged(newConfig), [VariableReference(mWindow, []), Expression(newConfig, [])])    VariableReference(mWindow, [])    Expression(newConfig, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(if (mActionBar !, []), Expression(null) {, [])])    VariableReference(if (mActionBar !, [])    Expression(null) {, [])  Statement(// Do this last, [])  Statement(the action bar will need to access, [])  Statement(// view changes from above., [])  MethodCall(mActionBar.onConfigurationChanged(newConfig), [VariableReference(mActionBar, []), Expression(newConfig, [])])    VariableReference(mActionBar, [])    Expression(newConfig, [])  Statement(}, [])  Statement(}, [])",1,"/**
 * Called by the system when the device configuration changes while your
 * activity is running.  Note that this will <em>only</em> be called if
 * you have selected configurations you would like to handle with the
 * {@link android.R.attr#configChanges} attribute in your manifest.  If
 * any configuration change occurs that is not selected to be reported
 * by that attribute, then instead of reporting it the system will stop
 * and restart the activity (to have it launched with the new
 * configuration).
 *
 * <p>At the time that this function has been called, your Resources
 * object will have been updated to return resource values matching the
 * new configuration.
 *
 * @param newConfig The new device configuration.
 */
","/**
 * Called by the system when the device configuration changes while your
 * activity is running.  Note that this will <em>only</em> be called if
 * you have selected configurations you would like to handle with the
 * {@link android.R.attr#configChanges} attribute in your manifest.  If
 * any configuration change occurs that is not selected to be reported
 * by that attribute, then instead of reporting it the system will stop
 * and restart the activity (to have it launched with the new
 * configuration).
 *
 * <p>At the time that this function has been called, your Resources
 * object will have been updated to return resource values matching the
 * new configuration.
 *
 * @param newConfig The new device configuration.
 */
",0,,,0,0,0,0,1,"3,4",0,4,0,"A new logging statement (Slog.v) has been added at the beginning of the late version's implementation. From the given AST, there is no other changes in terms of return or exception statements nor dependant APIs. Thus, we classify this as a type 4 change, i.e., 'Other statement changed'.","There won't be any Compatibility Issues caused by adding extra logging functionality, because this does not alter any return values, types or exception handlings. Thus, the CI type is 0."
45,<android.webkit.WebSettings: void setBuiltInZoomControls(boolean)>,15,16,<android.webkit.WebSettings: void setBuiltInZoomControls(boolean)>,<android.webkit.WebSettings: void setBuiltInZoomControls(boolean)>,0,"MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(mBuiltInZoomControls, []), Expression(enabled, [])]), MethodCall(mWebView.updateMultiTouchSupport(mContext), [VariableReference(mWebView, []), Expression(mContext, [])]), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(mBuiltInZoomControls, []), Expression(enabled, [])])    VariableReference(mBuiltInZoomControls, [])    Expression(enabled, [])  MethodCall(mWebView.updateMultiTouchSupport(mContext), [VariableReference(mWebView, []), Expression(mContext, [])])    VariableReference(mWebView, [])    Expression(mContext, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(throw new MustOverrideException(), []), Statement(}, [])])  Statement({, [])  Statement(throw new MustOverrideException(), [])  Statement(}, [])",1,"/**
 * Sets whether the zoom mechanism built into WebView is used.
 */
","// {@link WebView#getZoomControls}, which is now hidden.
",1,,,0,0,0,0,1,"2,4",2,"1,2","1,2","In the early implementation, a method is called and a variable is assigned. In the late version, it throws a new MustOverrideException which is not present in the early implementation. Hence the change can be classified as types 1 and 2.","Due to the changes, the method is now fundamentally different and will throw an exception rather than executing the method as before. This will result in different return values and different exception handlings. Hence, we can classify it as Compatibility Issues of type 1 and 2."
47,<android.view.MenuInflater.InflatedOnMenuItemClickListener: boolean onMenuItemClick(MenuItem)>,15,16,<android.view.MenuInflater.InflatedOnMenuItemClickListener: boolean onMenuItemClick(MenuItem)>,<android.view.MenuInflater.InflatedOnMenuItemClickListener: boolean onMenuItemClick(MenuItem)>,0,"MethodDeclaration(method_body, [Statement({, []), Statement(try {, []), AssignmentExpression(=, [VariableReference(if (mMethod.getReturnType(), []), Expression(, [])]), MethodCall(return (Boolean) mMethod.invoke(mContext, item), [VariableReference(return (Boolean) mMethod, []), Expression(mContext, []), Expression(item, [])]), Statement(} else {, []), MethodCall(mMethod.invoke(mContext, item), [VariableReference(mMethod, []), Expression(mContext, []), Expression(item, [])]), Statement(return true, []), Statement(}, []), Statement(} catch (Exception e) {, []), Statement(throw new RuntimeException(e), []), Statement(}, []), Statement(}, [])])  Statement({, [])  Statement(try {, [])  AssignmentExpression(=, [VariableReference(if (mMethod.getReturnType(), []), Expression(, [])])    VariableReference(if (mMethod.getReturnType(), [])    Expression(, [])  MethodCall(return (Boolean) mMethod.invoke(mContext, item), [VariableReference(return (Boolean) mMethod, []), Expression(mContext, []), Expression(item, [])])    VariableReference(return (Boolean) mMethod, [])    Expression(mContext, [])    Expression(item, [])  Statement(} else {, [])  MethodCall(mMethod.invoke(mContext, item), [VariableReference(mMethod, []), Expression(mContext, []), Expression(item, [])])    VariableReference(mMethod, [])    Expression(mContext, [])    Expression(item, [])  Statement(return true, [])  Statement(}, [])  Statement(} catch (Exception e) {, [])  Statement(throw new RuntimeException(e), [])  Statement(}, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(try {, []), AssignmentExpression(=, [VariableReference(if (mMethod.getReturnType(), []), Expression(, [])]), MethodCall(return (Boolean) mMethod.invoke(mRealOwner, item), [VariableReference(return (Boolean) mMethod, []), Expression(mRealOwner, []), Expression(item, [])]), Statement(} else {, []), MethodCall(mMethod.invoke(mRealOwner, item), [VariableReference(mMethod, []), Expression(mRealOwner, []), Expression(item, [])]), Statement(return true, []), Statement(}, []), Statement(} catch (Exception e) {, []), Statement(throw new RuntimeException(e), []), Statement(}, []), Statement(}, [])])  Statement({, [])  Statement(try {, [])  AssignmentExpression(=, [VariableReference(if (mMethod.getReturnType(), []), Expression(, [])])    VariableReference(if (mMethod.getReturnType(), [])    Expression(, [])  MethodCall(return (Boolean) mMethod.invoke(mRealOwner, item), [VariableReference(return (Boolean) mMethod, []), Expression(mRealOwner, []), Expression(item, [])])    VariableReference(return (Boolean) mMethod, [])    Expression(mRealOwner, [])    Expression(item, [])  Statement(} else {, [])  MethodCall(mMethod.invoke(mRealOwner, item), [VariableReference(mMethod, []), Expression(mRealOwner, []), Expression(item, [])])    VariableReference(mMethod, [])    Expression(mRealOwner, [])    Expression(item, [])  Statement(return true, [])  Statement(}, [])  Statement(} catch (Exception e) {, [])  Statement(throw new RuntimeException(e), [])  Statement(}, [])  Statement(}, [])",1,,,0,,,0,0,0,0,"1,2","1,5",1,4,1,"The reference 'mContext' is invoked in early version, which is changed to 'mRealOwner' at the same place in the late version. It falls under 'Other statement changed'.","Due to the change from 'mContext' to 'mRealOwner', the behavior of the method might be different, hence the method might return a different value, causing a potential compatibility issue of type 1."
49,"<android.content.ContentProviderClient: int update(Uri,ContentValues,String,String[])>",15,16,"<android.content.ContentProviderClient: int update(Uri,ContentValues,String,String[])>","<android.content.ContentProviderClient: int update(Uri,ContentValues,String,String[])>",0,"MethodDeclaration(method_body, [Statement({, []), MethodCall(return mContentProvider.update(url, values, selection, selectionArgs), [VariableReference(return mContentProvider, []), Expression(url, []), Expression(values, []), Expression(selection, []), Expression(selectionArgs, [])]), Statement(}, [])])  Statement({, [])  MethodCall(return mContentProvider.update(url, values, selection, selectionArgs), [VariableReference(return mContentProvider, []), Expression(url, []), Expression(values, []), Expression(selection, []), Expression(selectionArgs, [])])    VariableReference(return mContentProvider, [])    Expression(url, [])    Expression(values, [])    Expression(selection, [])    Expression(selectionArgs, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(try {, []), MethodCall(return mContentProvider.update(url, values, selection, selectionArgs), [VariableReference(return mContentProvider, []), Expression(url, []), Expression(values, []), Expression(selection, []), Expression(selectionArgs, [])]), Statement(} catch (DeadObjectException e) {, []), Statement(if (!mStable) {, []), MethodCall(mContentResolver.unstableProviderDied(mContentProvider), [VariableReference(mContentResolver, []), Expression(mContentProvider, [])]), Statement(}, []), Statement(throw e, []), Statement(}, []), Statement(}, [])])  Statement({, [])  Statement(try {, [])  MethodCall(return mContentProvider.update(url, values, selection, selectionArgs), [VariableReference(return mContentProvider, []), Expression(url, []), Expression(values, []), Expression(selection, []), Expression(selectionArgs, [])])    VariableReference(return mContentProvider, [])    Expression(url, [])    Expression(values, [])    Expression(selection, [])    Expression(selectionArgs, [])  Statement(} catch (DeadObjectException e) {, [])  Statement(if (!mStable) {, [])  MethodCall(mContentResolver.unstableProviderDied(mContentProvider), [VariableReference(mContentResolver, []), Expression(mContentProvider, [])])    VariableReference(mContentResolver, [])    Expression(mContentProvider, [])  Statement(}, [])  Statement(throw e, [])  Statement(}, [])  Statement(}, [])",1,"/**
 * See {@link ContentProvider#update ContentProvider.update}
 */
","/**
 * See {@link ContentProvider#update ContentProvider.update}
 */
",0,,,0,0,0,0,1,"1,2,3,4","1,2","2,3",2,"In the early version, there is no exception handling, but in the late version, it introduces a new 'try-catch' structure that catches a DeadObjectException. Also, an 'if' branch is added inside the catch block, calling the method 'mContentResolver.unstableProviderDied(mContentProvider)'. Therefore, the change type is 2,3.","In the late version, when a DeadObjectException occurs, it would throw the exception and potentially cause different behaviours compared to the early version. This constitutes a CI and the CI type is 2."
52,<android.widget.TextView: void onStartTemporaryDetach()>,15,16,<android.widget.TextView: void onStartTemporaryDetach()>,<android.widget.TextView: void onStartTemporaryDetach()>,0,"MethodDeclaration(method_body, [Statement({, []), MethodCall(super.onStartTemporaryDetach(), [VariableReference(super, []), Expression(, [])]), Statement(// usually because this instance is an editable field in a list, []), Statement(if (!mDispatchTemporaryDetach), []), AssignmentExpression(=, [VariableReference(mTemporaryDetach, []), Expression(true, [])]), Statement(// Because of View recycling in ListView, there is no easy way to know when a TextView with, []), Statement(// selection becomes visible again. Until a better solution is found, stop text selection, []), Statement(hideControllers(), []), Statement(}, [])])  Statement({, [])  MethodCall(super.onStartTemporaryDetach(), [VariableReference(super, []), Expression(, [])])    VariableReference(super, [])    Expression(, [])  Statement(// usually because this instance is an editable field in a list, [])  Statement(if (!mDispatchTemporaryDetach), [])  AssignmentExpression(=, [VariableReference(mTemporaryDetach, []), Expression(true, [])])    VariableReference(mTemporaryDetach, [])    Expression(true, [])  Statement(// Because of View recycling in ListView, there is no easy way to know when a TextView with, [])  Statement(// selection becomes visible again. Until a better solution is found, stop text selection, [])  Statement(hideControllers(), [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), MethodCall(super.onStartTemporaryDetach(), [VariableReference(super, []), Expression(, [])]), Statement(// usually because this instance is an editable field in a list, []), Statement(if (!mDispatchTemporaryDetach), []), AssignmentExpression(=, [VariableReference(mTemporaryDetach, []), Expression(true, [])]), Statement(// selection state as needed., []), AssignmentExpression(=, [VariableReference(if (mEditor !, []), Expression(null), [])]), AssignmentExpression(=, [VariableReference(mEditor.mTemporaryDetach, []), Expression(true, [])]), Statement(}, [])])  Statement({, [])  MethodCall(super.onStartTemporaryDetach(), [VariableReference(super, []), Expression(, [])])    VariableReference(super, [])    Expression(, [])  Statement(// usually because this instance is an editable field in a list, [])  Statement(if (!mDispatchTemporaryDetach), [])  AssignmentExpression(=, [VariableReference(mTemporaryDetach, []), Expression(true, [])])    VariableReference(mTemporaryDetach, [])    Expression(true, [])  Statement(// selection state as needed., [])  AssignmentExpression(=, [VariableReference(if (mEditor !, []), Expression(null), [])])    VariableReference(if (mEditor !, [])    Expression(null), [])  AssignmentExpression(=, [VariableReference(mEditor.mTemporaryDetach, []), Expression(true, [])])    VariableReference(mEditor.mTemporaryDetach, [])    Expression(true, [])  Statement(}, [])",1,,,0,[@Override],[@Override],0,0,0,0,1,"3,4",0,"1,3,4",0,"A call to the `hideControllers()` method is removed and new assignment statements (`if (mEditor !` and `mEditor.mTemporaryDetach`) are introduced in the Late version. A control dependency (if statement) was also introduced. Hence, the code change type is 1,3,4.","Although changes were made, none of these changes impact the behavior of the function in a way that could cause compatibility issues, as no changes were made in the type or value returned by the function, nor in the exceptions it throws. Hence, there is no compatibility issue (CI type 0)."
53,<android.widget.NumberPicker: void setEnabled(boolean)>,15,16,<android.widget.NumberPicker: void setEnabled(boolean)>,<android.widget.NumberPicker: void setEnabled(boolean)>,0,"MethodDeclaration(method_body, [Statement({, []), MethodCall(super.setEnabled(enabled), [VariableReference(super, []), Expression(enabled, [])]), MethodCall(mIncrementButton.setEnabled(enabled), [VariableReference(mIncrementButton, []), Expression(enabled, [])]), MethodCall(mDecrementButton.setEnabled(enabled), [VariableReference(mDecrementButton, []), Expression(enabled, [])]), MethodCall(mInputText.setEnabled(enabled), [VariableReference(mInputText, []), Expression(enabled, [])]), Statement(}, [])])  Statement({, [])  MethodCall(super.setEnabled(enabled), [VariableReference(super, []), Expression(enabled, [])])    VariableReference(super, [])    Expression(enabled, [])  MethodCall(mIncrementButton.setEnabled(enabled), [VariableReference(mIncrementButton, []), Expression(enabled, [])])    VariableReference(mIncrementButton, [])    Expression(enabled, [])  MethodCall(mDecrementButton.setEnabled(enabled), [VariableReference(mDecrementButton, []), Expression(enabled, [])])    VariableReference(mDecrementButton, [])    Expression(enabled, [])  MethodCall(mInputText.setEnabled(enabled), [VariableReference(mInputText, []), Expression(enabled, [])])    VariableReference(mInputText, [])    Expression(enabled, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), MethodCall(super.setEnabled(enabled), [VariableReference(super, []), Expression(enabled, [])]), Statement(if (!mHasSelectorWheel) {, []), MethodCall(mIncrementButton.setEnabled(enabled), [VariableReference(mIncrementButton, []), Expression(enabled, [])]), Statement(}, []), Statement(if (!mHasSelectorWheel) {, []), MethodCall(mDecrementButton.setEnabled(enabled), [VariableReference(mDecrementButton, []), Expression(enabled, [])]), Statement(}, []), MethodCall(mInputText.setEnabled(enabled), [VariableReference(mInputText, []), Expression(enabled, [])]), Statement(}, [])])  Statement({, [])  MethodCall(super.setEnabled(enabled), [VariableReference(super, []), Expression(enabled, [])])    VariableReference(super, [])    Expression(enabled, [])  Statement(if (!mHasSelectorWheel) {, [])  MethodCall(mIncrementButton.setEnabled(enabled), [VariableReference(mIncrementButton, []), Expression(enabled, [])])    VariableReference(mIncrementButton, [])    Expression(enabled, [])  Statement(}, [])  Statement(if (!mHasSelectorWheel) {, [])  MethodCall(mDecrementButton.setEnabled(enabled), [VariableReference(mDecrementButton, []), Expression(enabled, [])])    VariableReference(mDecrementButton, [])    Expression(enabled, [])  Statement(}, [])  MethodCall(mInputText.setEnabled(enabled), [VariableReference(mInputText, []), Expression(enabled, [])])    VariableReference(mInputText, [])    Expression(enabled, [])  Statement(}, [])",1,,,0,[@Override],[@Override],0,0,0,0,1,"3,4",0,3,0,New condition checks (if (!mHasSelectorWheel)) have been added before the invocations of mIncrementButton.setEnabled(enabled) and mDecrementButton.setEnabled(enabled) so the code change type is 3.,"The change of the condition check does not make the API return a different value or throw a different exception, so no CI exist. The compatibility issue type is 0."
56,<android.webkit.WebView: void onResume()>,15,16,<android.webkit.WebView: void onResume()>,<android.webkit.WebView: void onResume()>,0,"MethodDeclaration(method_body, [Statement({, []), Statement(checkThread(), []), Statement(if (mIsPaused) {, []), AssignmentExpression(=, [VariableReference(mIsPaused, []), Expression(false, [])]), MethodCall(mWebViewCore.sendMessage(EventHub.ON_RESUME), [VariableReference(mWebViewCore, []), Expression(EventHub.ON_RESUME, [])]), AssignmentExpression(=, [VariableReference(if (mNativeClass !, []), Expression(0) {, [])]), Statement(nativeSetPauseDrawing(mNativeClass, false), []), Statement(}, []), Statement(}, []), Statement(}, [])])  Statement({, [])  Statement(checkThread(), [])  Statement(if (mIsPaused) {, [])  AssignmentExpression(=, [VariableReference(mIsPaused, []), Expression(false, [])])    VariableReference(mIsPaused, [])    Expression(false, [])  MethodCall(mWebViewCore.sendMessage(EventHub.ON_RESUME), [VariableReference(mWebViewCore, []), Expression(EventHub.ON_RESUME, [])])    VariableReference(mWebViewCore, [])    Expression(EventHub.ON_RESUME, [])  AssignmentExpression(=, [VariableReference(if (mNativeClass !, []), Expression(0) {, [])])    VariableReference(if (mNativeClass !, [])    Expression(0) {, [])  Statement(nativeSetPauseDrawing(mNativeClass, false), [])  Statement(}, [])  Statement(}, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(checkThread(), []), MethodCall(mProvider.onResume(), [VariableReference(mProvider, []), Expression(, [])]), Statement(}, [])])  Statement({, [])  Statement(checkThread(), [])  MethodCall(mProvider.onResume(), [VariableReference(mProvider, []), Expression(, [])])    VariableReference(mProvider, [])    Expression(, [])  Statement(}, [])",1,"/**
 * Call this to resume a WebView after a previous call to onPause().
 */
","/**
 * Resumes a WebView after a previous call to onPause().
 */
",1,,,0,0,0,0,1,3,0,"1,4,5",1,"In the early version, the method included multiple statements including condition statements, assignment expressions and method calls. The late version has replaced all these individual statements with a call to mProvider.onResume(). This is a fundamental change in the method's implementation and dependent API, making the code change types 1,4,5.","The compatibility issue arises from the potential change in behavior due to the switch in method calls from several specific actions in the early version to a singular method call in the late version. This could feasibly result in different return outcomes, judging it to be CI type 1."
57,"<android.view.ViewGroup: void dispatchAttachedToWindow(AttachInfo,int)>",15,16,"<android.view.ViewGroup: void dispatchAttachedToWindow(AttachInfo,int)>","<android.view.ViewGroup: void dispatchAttachedToWindow(AttachInfo,int)>",0,"MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(mGroupFlags |, []), Expression(FLAG_PREVENT_DISPATCH_ATTACHED_TO_WINDOW, [])]), MethodCall(super.dispatchAttachedToWindow(info, visibility), [VariableReference(super, []), Expression(info, []), Expression(visibility, [])]), AssignmentExpression(=, [VariableReference(mGroupFlags &, []), Expression(~FLAG_PREVENT_DISPATCH_ATTACHED_TO_WINDOW, [])]), AssignmentExpression(=, [VariableReference(visibility |, []), Expression(mViewFlags & VISIBILITY_MASK, [])]), AssignmentExpression(=, [VariableReference(final int count, []), Expression(mChildrenCount, [])]), AssignmentExpression(=, [VariableReference(final View[] children, []), Expression(mChildren, [])]), AssignmentExpression(=, [VariableReference(for (int i, []), Expression(0, [])]), Statement(i < count, []), Statement(i++) {, []), MethodCall(children[i].dispatchAttachedToWindow(info, visibility), [VariableReference(children[i], []), Expression(info, []), Expression(visibility, [])]), Statement(}, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(mGroupFlags |, []), Expression(FLAG_PREVENT_DISPATCH_ATTACHED_TO_WINDOW, [])])    VariableReference(mGroupFlags |, [])    Expression(FLAG_PREVENT_DISPATCH_ATTACHED_TO_WINDOW, [])  MethodCall(super.dispatchAttachedToWindow(info, visibility), [VariableReference(super, []), Expression(info, []), Expression(visibility, [])])    VariableReference(super, [])    Expression(info, [])    Expression(visibility, [])  AssignmentExpression(=, [VariableReference(mGroupFlags &, []), Expression(~FLAG_PREVENT_DISPATCH_ATTACHED_TO_WINDOW, [])])    VariableReference(mGroupFlags &, [])    Expression(~FLAG_PREVENT_DISPATCH_ATTACHED_TO_WINDOW, [])  AssignmentExpression(=, [VariableReference(visibility |, []), Expression(mViewFlags & VISIBILITY_MASK, [])])    VariableReference(visibility |, [])    Expression(mViewFlags & VISIBILITY_MASK, [])  AssignmentExpression(=, [VariableReference(final int count, []), Expression(mChildrenCount, [])])    VariableReference(final int count, [])    Expression(mChildrenCount, [])  AssignmentExpression(=, [VariableReference(final View[] children, []), Expression(mChildren, [])])    VariableReference(final View[] children, [])    Expression(mChildren, [])  AssignmentExpression(=, [VariableReference(for (int i, []), Expression(0, [])])    VariableReference(for (int i, [])    Expression(0, [])  Statement(i < count, [])  Statement(i++) {, [])  MethodCall(children[i].dispatchAttachedToWindow(info, visibility), [VariableReference(children[i], []), Expression(info, []), Expression(visibility, [])])    VariableReference(children[i], [])    Expression(info, [])    Expression(visibility, [])  Statement(}, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(mGroupFlags |, []), Expression(FLAG_PREVENT_DISPATCH_ATTACHED_TO_WINDOW, [])]), MethodCall(super.dispatchAttachedToWindow(info, visibility), [VariableReference(super, []), Expression(info, []), Expression(visibility, [])]), AssignmentExpression(=, [VariableReference(mGroupFlags &, []), Expression(~FLAG_PREVENT_DISPATCH_ATTACHED_TO_WINDOW, [])]), AssignmentExpression(=, [VariableReference(final int count, []), Expression(mChildrenCount, [])]), AssignmentExpression(=, [VariableReference(final View[] children, []), Expression(mChildren, [])]), AssignmentExpression(=, [VariableReference(for (int i, []), Expression(0, [])]), Statement(i < count, []), Statement(i++) {, []), AssignmentExpression(=, [VariableReference(final View child, []), Expression(children[i], [])]), MethodCall(child.dispatchAttachedToWindow(info, visibility | (child.mViewFlags & VISIBILITY_MASK)), [VariableReference(child, []), Expression(info, []), Expression(visibility | (child.mViewFlags & VISIBILITY_MASK), [])]), Statement(}, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(mGroupFlags |, []), Expression(FLAG_PREVENT_DISPATCH_ATTACHED_TO_WINDOW, [])])    VariableReference(mGroupFlags |, [])    Expression(FLAG_PREVENT_DISPATCH_ATTACHED_TO_WINDOW, [])  MethodCall(super.dispatchAttachedToWindow(info, visibility), [VariableReference(super, []), Expression(info, []), Expression(visibility, [])])    VariableReference(super, [])    Expression(info, [])    Expression(visibility, [])  AssignmentExpression(=, [VariableReference(mGroupFlags &, []), Expression(~FLAG_PREVENT_DISPATCH_ATTACHED_TO_WINDOW, [])])    VariableReference(mGroupFlags &, [])    Expression(~FLAG_PREVENT_DISPATCH_ATTACHED_TO_WINDOW, [])  AssignmentExpression(=, [VariableReference(final int count, []), Expression(mChildrenCount, [])])    VariableReference(final int count, [])    Expression(mChildrenCount, [])  AssignmentExpression(=, [VariableReference(final View[] children, []), Expression(mChildren, [])])    VariableReference(final View[] children, [])    Expression(mChildren, [])  AssignmentExpression(=, [VariableReference(for (int i, []), Expression(0, [])])    VariableReference(for (int i, [])    Expression(0, [])  Statement(i < count, [])  Statement(i++) {, [])  AssignmentExpression(=, [VariableReference(final View child, []), Expression(children[i], [])])    VariableReference(final View child, [])    Expression(children[i], [])  MethodCall(child.dispatchAttachedToWindow(info, visibility | (child.mViewFlags & VISIBILITY_MASK)), [VariableReference(child, []), Expression(info, []), Expression(visibility | (child.mViewFlags & VISIBILITY_MASK), [])])    VariableReference(child, [])    Expression(info, [])    Expression(visibility | (child.mViewFlags & VISIBILITY_MASK), [])  Statement(}, [])  Statement(}, [])",1,"/**
 * {@inheritDoc}
 */
","/**
 * {@inheritDoc}
 */
",0,[@Override],[@Override],0,0,0,0,1,"3,4",0,"1,4",1,"The return statement in the method call 'child.dispatchAttachedToWindow(info, visibility | (child.mViewFlags & VISIBILITY_MASK))' changed between early and late implementation, indicating a Type 1 change. Also, a new assignment statement 'final View child = children[i];' has been introduced in the late version, indicating a Type 4 change.","The change in the return statement 'child.dispatchAttachedToWindow(info, visibility | (child.mViewFlags & VISIBILITY_MASK))' can potentially cause the API method to return a different value, indicating a Type 1 compatibility issue."
58,<android.webkit.WebSettings: void setJavaScriptCanOpenWindowsAutomatically(boolean)>,15,16,<android.webkit.WebSettings: void setJavaScriptCanOpenWindowsAutomatically(boolean)>,<android.webkit.WebSettings: void setJavaScriptCanOpenWindowsAutomatically(boolean)>,0,"MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(if (mJavaScriptCanOpenWindowsAutomatically !, []), Expression(flag) {, [])]), AssignmentExpression(=, [VariableReference(mJavaScriptCanOpenWindowsAutomatically, []), Expression(flag, [])]), Statement(postSync(), []), Statement(}, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(if (mJavaScriptCanOpenWindowsAutomatically !, []), Expression(flag) {, [])])    VariableReference(if (mJavaScriptCanOpenWindowsAutomatically !, [])    Expression(flag) {, [])  AssignmentExpression(=, [VariableReference(mJavaScriptCanOpenWindowsAutomatically, []), Expression(flag, [])])    VariableReference(mJavaScriptCanOpenWindowsAutomatically, [])    Expression(flag, [])  Statement(postSync(), [])  Statement(}, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(throw new MustOverrideException(), []), Statement(}, [])])  Statement({, [])  Statement(throw new MustOverrideException(), [])  Statement(}, [])",1,"/**
 * Tell javascript to open windows automatically. This applies to the
 * javascript function window.open().
 * @param flag True if javascript can open windows automatically.
 */
","/**
 * Tells JavaScript to open windows automatically. This applies to the
 * JavaScript function window.open(). The default is false.
 *
 * @param flag true if JavaScript can open windows automatically
 */
",1,,,0,0,0,0,1,"2,3",2,"2,4",2,"The old assignments and function call ""postSync()"" were removed and a new ""throw new MustOverrideException()"" statememt was introduced, so the code change type is 2,4.","As new exception handling statement, ""throw new MustOverrideException()"", is introduced in the API, it may potentially throw different exceptions. So, the CI type is 2."
60,<android.database.sqlite.SQLiteStatement: long simpleQueryForLong()>,15,16,<android.database.sqlite.SQLiteStatement: long simpleQueryForLong()>,<android.database.sqlite.SQLiteStatement: long simpleQueryForLong()>,0,"MethodDeclaration(method_body, [Statement({, []), Statement(try {, []), AssignmentExpression(=, [VariableReference(long timeStart, []), Expression(acquireAndLock(READ), [])]), AssignmentExpression(=, [VariableReference(long retValue, []), Expression(native_1x1_long(), [])]), MethodCall(mDatabase.logTimeStat(mSql, timeStart), [VariableReference(mDatabase, []), Expression(mSql, []), Expression(timeStart, [])]), Statement(return retValue, []), Statement(} catch (SQLiteDoneException e) {, []), Statement(} finally {, []), Statement(releaseAndUnlock(), []), Statement(}, []), Statement(}, [])])  Statement({, [])  Statement(try {, [])  AssignmentExpression(=, [VariableReference(long timeStart, []), Expression(acquireAndLock(READ), [])])    VariableReference(long timeStart, [])    Expression(acquireAndLock(READ), [])  AssignmentExpression(=, [VariableReference(long retValue, []), Expression(native_1x1_long(), [])])    VariableReference(long retValue, [])    Expression(native_1x1_long(), [])  MethodCall(mDatabase.logTimeStat(mSql, timeStart), [VariableReference(mDatabase, []), Expression(mSql, []), Expression(timeStart, [])])    VariableReference(mDatabase, [])    Expression(mSql, [])    Expression(timeStart, [])  Statement(return retValue, [])  Statement(} catch (SQLiteDoneException e) {, [])  Statement(} finally {, [])  Statement(releaseAndUnlock(), [])  Statement(}, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(acquireReference(), []), Statement(try {, []), MethodCall(return getSession().executeForLong(getSql(), getBindArgs(), getConnectionFlags(), null), [VariableReference(return getSession(), []), Expression(getSql(), []), Expression(getBindArgs(), []), Expression(getConnectionFlags(), []), Expression(null, [])]), Statement(} catch (SQLiteDatabaseCorruptException ex) {, []), Statement(onCorruption(), []), Statement(throw ex, []), Statement(} finally {, []), Statement(releaseReference(), []), Statement(}, []), Statement(}, [])])  Statement({, [])  Statement(acquireReference(), [])  Statement(try {, [])  MethodCall(return getSession().executeForLong(getSql(), getBindArgs(), getConnectionFlags(), null), [VariableReference(return getSession(), []), Expression(getSql(), []), Expression(getBindArgs(), []), Expression(getConnectionFlags(), []), Expression(null, [])])    VariableReference(return getSession(), [])    Expression(getSql(), [])    Expression(getBindArgs(), [])    Expression(getConnectionFlags(), [])    Expression(null, [])  Statement(} catch (SQLiteDatabaseCorruptException ex) {, [])  Statement(onCorruption(), [])  Statement(throw ex, [])  Statement(} finally {, [])  Statement(releaseReference(), [])  Statement(}, [])  Statement(}, [])",1,"/**
 * Execute a statement that returns a 1 by 1 table with a numeric value.
 * For example, SELECT COUNT(*) FROM table;
 *
 * @return The result of the query.
 *
 * @throws android.database.sqlite.SQLiteDoneException if the query returns zero rows
 */
","/**
 * Execute a statement that returns a 1 by 1 table with a numeric value.
 * For example, SELECT COUNT(*) FROM table;
 *
 * @return The result of the query.
 *
 * @throws android.database.sqlite.SQLiteDoneException if the query returns zero rows
 */
",0,,,0,0,0,0,1,"1,2,4","1,2","1,2,4,5","1,2","In the early version, the implementation is related to 'acquireAndLock(READ)', 'native_1x1_long()' and 'releaseAndUnlock()', but these are removed in the late version. In replacement, 'acquireReference()', 'getSession().executeForLong(getSql(), getBindArgs(), getConnectionFlags(), null)' and 'releaseReference()' are introduced, and these latter methods are neither present nor substituted in the early version. Also, the exception handling ('catch' statement) is different between the two versions. Therefore, the change type should be 1,2,4,5.","In the early version, the implementation has a 'return' statement inside a 'try' block, and the exception caught is 'SQLiteDoneException'. In the late version, however, the 'return' statement is placed outside the 'try' block and the exception caught is 'SQLiteDatabaseCorruptException'. Thus, not only does the return statement possibly return different values (type 1 CI), it also can throw a different exception (type 2 CI). Hence, the CI type is 1,2."
61,<android.view.InputDevice: int[] getDeviceIds()>,15,16,<android.view.InputDevice: int[] getDeviceIds()>,<android.view.InputDevice: int[] getDeviceIds()>,0,"MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(IWindowManager wm, []), Expression(Display.getWindowManager(), [])]), Statement(try {, []), MethodCall(return wm.getInputDeviceIds(), [VariableReference(return wm, []), Expression(, [])]), Statement(} catch (RemoteException ex) {, []), Statement(}, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(IWindowManager wm, []), Expression(Display.getWindowManager(), [])])    VariableReference(IWindowManager wm, [])    Expression(Display.getWindowManager(), [])  Statement(try {, [])  MethodCall(return wm.getInputDeviceIds(), [VariableReference(return wm, []), Expression(, [])])    VariableReference(return wm, [])    Expression(, [])  Statement(} catch (RemoteException ex) {, [])  Statement(}, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), MethodCall(return InputManager.getInstance().getInputDeviceIds(), [VariableReference(return InputManager, []), Expression().getInputDeviceIds(, [])]), Statement(}, [])])  Statement({, [])  MethodCall(return InputManager.getInstance().getInputDeviceIds(), [VariableReference(return InputManager, []), Expression().getInputDeviceIds(, [])])    VariableReference(return InputManager, [])    Expression().getInputDeviceIds(, [])  Statement(}, [])",1,"/**
 * Gets the ids of all input devices in the system.
 * @return The input device ids.
 */
","/**
 * Gets the ids of all input devices in the system.
 * @return The input device ids.
 */
",0,,,0,0,0,0,1,"1,2,4","1,2","1,5",1,"The return statement has changed from 'return wm.getInputDeviceIds()' to 'return InputManager.getInstance().getInputDeviceIds()'. In the early version, the API uses another method to get the input device IDs, while in the late version it directly uses the method from InputManager class. So, the change type is 1,5.","The change in the return statement can potentially lead the API to return different values. Hence, the CI type is 1."
63,<android.database.ContentObservable: void notifyChange(boolean)>,15,16,<android.database.ContentObservable: void notifyChange(boolean)>,<android.database.ContentObservable: void notifyChange(boolean)>,0,"MethodDeclaration(method_body, [Statement({, []), Statement(synchronized (mObservers) {, []), Statement(for (ContentObserver observer : mObservers) {, []), MethodCall(observer.onChange(selfChange), [VariableReference(observer, []), Expression(selfChange, [])]), Statement(}, []), Statement(}, []), Statement(}, [])])  Statement({, [])  Statement(synchronized (mObservers) {, [])  Statement(for (ContentObserver observer : mObservers) {, [])  MethodCall(observer.onChange(selfChange), [VariableReference(observer, []), Expression(selfChange, [])])    VariableReference(observer, [])    Expression(selfChange, [])  Statement(}, [])  Statement(}, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(synchronized (mObservers) {, []), Statement(for (ContentObserver observer : mObservers) {, []), MethodCall(observer.onChange(selfChange, null), [VariableReference(observer, []), Expression(selfChange, []), Expression(null, [])]), Statement(}, []), Statement(}, []), Statement(}, [])])  Statement({, [])  Statement(synchronized (mObservers) {, [])  Statement(for (ContentObserver observer : mObservers) {, [])  MethodCall(observer.onChange(selfChange, null), [VariableReference(observer, []), Expression(selfChange, []), Expression(null, [])])    VariableReference(observer, [])    Expression(selfChange, [])    Expression(null, [])  Statement(}, [])  Statement(}, [])  Statement(}, [])",1,"/**
 * invokes onChange on each observer
 * @param selfChange
 */
","/**
 * Invokes {@link ContentObserver#onChange} on each observer.
 *
 * @param selfChange True if this is a self-change notification.
 *
 * @deprecated Use {@link #dispatchChange} instead.
 */
",1,,[@Deprecated],1,0,0,0,2,5,0,"1,4,5",1,"The parameter of observer.onChange method is changed from 'selfChange' to 'selfChange, null', which is a code change type of 1. The addition of the null parameter is considered as ""other statements changed"", which is a code change type of 4. Lastly, the functional behaviour of the code implementation has not changed, but the API has been marked as deprecated in the late version, suggesting to use dispatchChange instead, which signifies a ""Dependent API change"", thus a code change type of 5.","The change of parameters can potentially change the return results of the observer.onChange method, thus the return type will be different, which is a Compatibility Issue caused by the potential different return values, so the CI type is 1."
64,<android.webkit.WebSettings: int getTextZoom()>,15,16,<android.webkit.WebSettings: int getTextZoom()>,<android.webkit.WebSettings: int getTextZoom()>,0,"MethodDeclaration(method_body, [Statement({, []), Statement(return mTextSize, []), Statement(}, [])])  Statement({, [])  Statement(return mTextSize, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(throw new MustOverrideException(), []), Statement(}, [])])  Statement({, [])  Statement(throw new MustOverrideException(), [])  Statement(}, [])",1,"/**
 * Get the text zoom of the page in percent.
 * @return A percent value describing the text zoom.
 * @see setTextSizeZoom
 */
","/**
 * Gets the text zoom of the page in percent.
 *
 * @return a percent value describing the text zoom
 * @see #setTextSizeZoom
 */
",1,,,0,0,0,0,1,"1,2","1,2","1,2","1,2","The return statement has been replaced by throwing an exception. The replacement operation is a significant change and could affect the execution of the API, hence it falls under category 1(return statement change) and 2(exception handling statement change).","The original version returns a text zoom value, while the late version throws a new exception, which will cause the API to behave differently between the two versions. This change can potentially cause both different return values and different exception handling, thus the CI type is 1 and 2."
65,<android.webkit.WebView: void freeMemory()>,15,16,<android.webkit.WebView: void freeMemory()>,<android.webkit.WebView: void freeMemory()>,0,"MethodDeclaration(method_body, [Statement({, []), Statement(checkThread(), []), MethodCall(mWebViewCore.sendMessage(EventHub.FREE_MEMORY), [VariableReference(mWebViewCore, []), Expression(EventHub.FREE_MEMORY, [])]), Statement(}, [])])  Statement({, [])  Statement(checkThread(), [])  MethodCall(mWebViewCore.sendMessage(EventHub.FREE_MEMORY), [VariableReference(mWebViewCore, []), Expression(EventHub.FREE_MEMORY, [])])    VariableReference(mWebViewCore, [])    Expression(EventHub.FREE_MEMORY, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(checkThread(), []), MethodCall(mProvider.freeMemory(), [VariableReference(mProvider, []), Expression(, [])]), Statement(}, [])])  Statement({, [])  Statement(checkThread(), [])  MethodCall(mProvider.freeMemory(), [VariableReference(mProvider, []), Expression(, [])])    VariableReference(mProvider, [])    Expression(, [])  Statement(}, [])",1,"/**
 * Call this to inform the view that memory is low so that it can
 * free any available memory.
 */
","/**
 * Informs this WebView that memory is low so that it can free any available
 * memory.
 */
",1,,,0,0,0,0,1,4,0,"4,5",0,"The implementation uses a different method to free memory, this changes from mWebViewCore.sendMessage(EventHub.FREE_MEMORY) to mProvider.freeMemory(). Because the method used to perform an action and the source of that action (the dependent APIs) have changed, but there's no control statement or return value changing, thus it falls under categories 4 and 5.","Despite the change in the dependent API's implementation, the behavior of the code is expected to remain the same. Because the main function of this API (free memory) did not encounter any changes, and there's no change indicates a different return value or exception, thus it's considered to have no compatibility issues."
67,"<android.database.DatabaseUtils: ParcelFileDescriptor blobFileDescriptorForQuery(SQLiteStatement,String[])>",15,16,"<android.database.DatabaseUtils: ParcelFileDescriptor blobFileDescriptorForQuery(SQLiteStatement,String[])>","<android.database.DatabaseUtils: ParcelFileDescriptor blobFileDescriptorForQuery(SQLiteDatabase,String,String[])>",0,"MethodDeclaration(method_body, [Statement({, []), MethodCall(prog.bindAllArgsAsStrings(selectionArgs), [VariableReference(prog, []), Expression(selectionArgs, [])]), MethodCall(return prog.simpleQueryForBlobFileDescriptor(), [VariableReference(return prog, []), Expression(, [])]), Statement(}, [])])  Statement({, [])  MethodCall(prog.bindAllArgsAsStrings(selectionArgs), [VariableReference(prog, []), Expression(selectionArgs, [])])    VariableReference(prog, [])    Expression(selectionArgs, [])  MethodCall(return prog.simpleQueryForBlobFileDescriptor(), [VariableReference(return prog, []), Expression(, [])])    VariableReference(return prog, [])    Expression(, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(SQLiteStatement prog, []), Expression(db.compileStatement(query), [])]), Statement(try {, []), Statement(return blobFileDescriptorForQuery(prog, selectionArgs), []), Statement(} finally {, []), MethodCall(prog.close(), [VariableReference(prog, []), Expression(, [])]), Statement(}, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(SQLiteStatement prog, []), Expression(db.compileStatement(query), [])])    VariableReference(SQLiteStatement prog, [])    Expression(db.compileStatement(query), [])  Statement(try {, [])  Statement(return blobFileDescriptorForQuery(prog, selectionArgs), [])  Statement(} finally {, [])  MethodCall(prog.close(), [VariableReference(prog, []), Expression(, [])])    VariableReference(prog, [])    Expression(, [])  Statement(}, [])  Statement(}, [])",1,"/**
 * Utility method to run the pre-compiled query and return the blob value in the
 * first column of the first row.
 *
 * @return A read-only file descriptor for a copy of the blob value.
 */
","/**
 * Utility method to run the query on the db and return the blob value in the
 * first column of the first row.
 *
 * @return A read-only file descriptor for a copy of the blob value.
 */
",0,,,0,0,0,0,1,"1,2,4",1,"1,4",1,"The return statement has changed from 'return prog.simpleQueryForBlobFileDescriptor()' in early version to 'return blobFileDescriptorForQuery(prog, selectionArgs)' in late version. Also, the method 'db.compileStatement(query)' and 'prog.close()' were introduced in the late version, but they are not conditional or exception statements, therefore, the pred_change is 1,4.","The change of return statement will cause the API potentially return a different value, so the CI type is 1."
68,<android.webkit.WebSettings: void setDefaultFixedFontSize(int)>,15,16,<android.webkit.WebSettings: void setDefaultFixedFontSize(int)>,<android.webkit.WebSettings: void setDefaultFixedFontSize(int)>,0,"MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(size, []), Expression(pin(size), [])]), AssignmentExpression(=, [VariableReference(if (mDefaultFixedFontSize !, []), Expression(size) {, [])]), AssignmentExpression(=, [VariableReference(mDefaultFixedFontSize, []), Expression(size, [])]), Statement(postSync(), []), Statement(}, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(size, []), Expression(pin(size), [])])    VariableReference(size, [])    Expression(pin(size), [])  AssignmentExpression(=, [VariableReference(if (mDefaultFixedFontSize !, []), Expression(size) {, [])])    VariableReference(if (mDefaultFixedFontSize !, [])    Expression(size) {, [])  AssignmentExpression(=, [VariableReference(mDefaultFixedFontSize, []), Expression(size, [])])    VariableReference(mDefaultFixedFontSize, [])    Expression(size, [])  Statement(postSync(), [])  Statement(}, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(throw new MustOverrideException(), []), Statement(}, [])])  Statement({, [])  Statement(throw new MustOverrideException(), [])  Statement(}, [])",1,"/**
 * Set the default fixed font size.
 * @param size A non-negative integer between 1 and 72.
 * Any number outside the specified range will be pinned.
 */
","/**
 * Sets the default fixed font size. The default is 16.
 *
 * @param size a non-negative integer between 1 and 72. Any number outside
 * the specified range will be pinned.
 */
",1,,,0,0,0,0,1,"2,3,4",2,"1,2","1,2","The early implementation of this method had several assignments and statements, but in the late version, it throws a MustOverrideException. This API implementation is completely rewritten and the entire functioning is altered. Therefore, the change type is 1,2.","Considering that the method implementation has fully changed from executing different assignments to throwing an exception, it can cause both different values returned from the function (more specifically it doesn't return any values anymore, just throws an exception), and different exception handlings, the CI type is 1,2."
69,<android.webkit.WebView: void setHorizontalScrollbarOverlay(boolean)>,15,16,<android.webkit.WebView: void setHorizontalScrollbarOverlay(boolean)>,<android.webkit.WebView: void setHorizontalScrollbarOverlay(boolean)>,0,"MethodDeclaration(method_body, [Statement({, []), Statement(checkThread(), []), AssignmentExpression(=, [VariableReference(mOverlayHorizontalScrollbar, []), Expression(overlay, [])]), Statement(}, [])])  Statement({, [])  Statement(checkThread(), [])  AssignmentExpression(=, [VariableReference(mOverlayHorizontalScrollbar, []), Expression(overlay, [])])    VariableReference(mOverlayHorizontalScrollbar, [])    Expression(overlay, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(checkThread(), []), MethodCall(mProvider.setHorizontalScrollbarOverlay(overlay), [VariableReference(mProvider, []), Expression(overlay, [])]), Statement(}, [])])  Statement({, [])  Statement(checkThread(), [])  MethodCall(mProvider.setHorizontalScrollbarOverlay(overlay), [VariableReference(mProvider, []), Expression(overlay, [])])    VariableReference(mProvider, [])    Expression(overlay, [])  Statement(}, [])",1,"/**
 * Specify whether the horizontal scrollbar has overlay style.
 * @param overlay TRUE if horizontal scrollbar should have overlay style.
 */
","/**
 * Specifies whether the horizontal scrollbar has overlay style.
 *
 * @param overlay true if horizontal scrollbar should have overlay style
 */
",0,,,0,0,0,0,1,4,0,"4,5",0,"The main change is in the assignment statement, where the variable mOverlayHorizontalScrollbar is replaced with a method call mProvider.setHorizontalScrollbarOverlay(overlay). As this change involves neither return statements nor exception handling, we classify it as ""other statement changes"" (Type 4). Also, since ""mProvider.setHorizontalScrollbarOverlay()"" may imply a dependency to a new method, we also classify it as ""Dependent API changed"" (Type 5).","Despite the changes, the behavior of the method remains consistent across versions: it sets the horizontal scrollbar to have an overlay style according to the given boolean value. Thus, there's no Compatibility Issue (Type 0) for this method."
70,<android.database.sqlite.SQLiteDatabase: boolean isOpen()>,15,16,<android.database.sqlite.SQLiteDatabase: boolean isOpen()>,<android.database.sqlite.SQLiteDatabase: boolean isOpen()>,0,"MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(return mNativeHandle !, []), Expression(0, [])]), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(return mNativeHandle !, []), Expression(0, [])])    VariableReference(return mNativeHandle !, [])    Expression(0, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(synchronized (mLock) {, []), AssignmentExpression(=, [VariableReference(return mConnectionPoolLocked !, []), Expression(null, [])]), Statement(}, []), Statement(}, [])])  Statement({, [])  Statement(synchronized (mLock) {, [])  AssignmentExpression(=, [VariableReference(return mConnectionPoolLocked !, []), Expression(null, [])])    VariableReference(return mConnectionPoolLocked !, [])    Expression(null, [])  Statement(}, [])  Statement(}, [])",1,"/**
 * @return true if the DB is currently open (has not been closed)
 */
","/**
 * Returns true if the database is currently open.
 *
 * @return True if the database is currently open (has not been closed).
 */
",1,,,0,0,0,0,1,"1,4",1,"1,3,4",1,"The code has changed from 'return mNativeHandle != 0' to 'synchronized (mLock) {return mConnectionPoolLocked != null}', so the return statement is changed, and the control dependency (synchronized statement) is introduced and other statement such as 'mLock' is introduced as well. Hence, the change type is 1,3,4.","As the return statement has changed, the behaviour of the method also changes, which means the method may potentially return a different value in the late version. Therefore, the type of Compatibility Issue is 1."
72,"<android.app.FragmentManagerImpl: void attachFragment(Fragment,int,int)>",15,16,"<android.app.FragmentManagerImpl: void attachFragment(Fragment,int,int)>","<android.app.FragmentManagerImpl: void attachFragment(Fragment,int,int)>",0,"MethodDeclaration(method_body, [Statement({, []), Statement(if (DEBUG), []), MethodCall(Log.v(TAG, ""attach: "" + fragment), [VariableReference(Log, []), Expression(TAG, []), Expression(""attach: "" + fragment, [])]), AssignmentExpression(=, [VariableReference(fragment.mDetached, []), Expression(false, [])]), MethodCall(mAdded.add(fragment), [VariableReference(mAdded, []), Expression(fragment, [])]), AssignmentExpression(=, [VariableReference(fragment.mAdded, []), Expression(true, [])]), AssignmentExpression(=, [VariableReference(mNeedMenuInvalidate, []), Expression(true, [])]), Statement(}, []), Statement(moveToState(fragment, mCurState, transition, transitionStyle), []), Statement(}, []), Statement(}, []), Statement(}, [])])  Statement({, [])  Statement(if (DEBUG), [])  MethodCall(Log.v(TAG, ""attach: "" + fragment), [VariableReference(Log, []), Expression(TAG, []), Expression(""attach: "" + fragment, [])])    VariableReference(Log, [])    Expression(TAG, [])    Expression(""attach: "" + fragment, [])  AssignmentExpression(=, [VariableReference(fragment.mDetached, []), Expression(false, [])])    VariableReference(fragment.mDetached, [])    Expression(false, [])  MethodCall(mAdded.add(fragment), [VariableReference(mAdded, []), Expression(fragment, [])])    VariableReference(mAdded, [])    Expression(fragment, [])  AssignmentExpression(=, [VariableReference(fragment.mAdded, []), Expression(true, [])])    VariableReference(fragment.mAdded, [])    Expression(true, [])  AssignmentExpression(=, [VariableReference(mNeedMenuInvalidate, []), Expression(true, [])])    VariableReference(mNeedMenuInvalidate, [])    Expression(true, [])  Statement(}, [])  Statement(moveToState(fragment, mCurState, transition, transitionStyle), [])  Statement(}, [])  Statement(}, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(if (DEBUG), []), MethodCall(Log.v(TAG, ""attach: "" + fragment), [VariableReference(Log, []), Expression(TAG, []), Expression(""attach: "" + fragment, [])]), AssignmentExpression(=, [VariableReference(fragment.mDetached, []), Expression(false, [])]), AssignmentExpression(=, [VariableReference(if (mAdded, []), Expression(, [])]), AssignmentExpression(=, [VariableReference(mAdded, []), Expression(new ArrayList<Fragment>(), [])]), Statement(}, []), MethodCall(mAdded.add(fragment), [VariableReference(mAdded, []), Expression(fragment, [])]), AssignmentExpression(=, [VariableReference(fragment.mAdded, []), Expression(true, [])]), AssignmentExpression(=, [VariableReference(mNeedMenuInvalidate, []), Expression(true, [])]), Statement(}, []), Statement(moveToState(fragment, mCurState, transition, transitionStyle, false), []), Statement(}, []), Statement(}, []), Statement(}, [])])  Statement({, [])  Statement(if (DEBUG), [])  MethodCall(Log.v(TAG, ""attach: "" + fragment), [VariableReference(Log, []), Expression(TAG, []), Expression(""attach: "" + fragment, [])])    VariableReference(Log, [])    Expression(TAG, [])    Expression(""attach: "" + fragment, [])  AssignmentExpression(=, [VariableReference(fragment.mDetached, []), Expression(false, [])])    VariableReference(fragment.mDetached, [])    Expression(false, [])  AssignmentExpression(=, [VariableReference(if (mAdded, []), Expression(, [])])    VariableReference(if (mAdded, [])    Expression(, [])  AssignmentExpression(=, [VariableReference(mAdded, []), Expression(new ArrayList<Fragment>(), [])])    VariableReference(mAdded, [])    Expression(new ArrayList<Fragment>(), [])  Statement(}, [])  MethodCall(mAdded.add(fragment), [VariableReference(mAdded, []), Expression(fragment, [])])    VariableReference(mAdded, [])    Expression(fragment, [])  AssignmentExpression(=, [VariableReference(fragment.mAdded, []), Expression(true, [])])    VariableReference(fragment.mAdded, [])    Expression(true, [])  AssignmentExpression(=, [VariableReference(mNeedMenuInvalidate, []), Expression(true, [])])    VariableReference(mNeedMenuInvalidate, [])    Expression(true, [])  Statement(}, [])  Statement(moveToState(fragment, mCurState, transition, transitionStyle, false), [])  Statement(}, [])  Statement(}, [])  Statement(}, [])",1,,,0,,,0,0,0,0,"1,2","3,4,5",0,"1,3,5",1,"The assignment statement `mAdded = new ArrayList<Fragment>()` has been added; the method method call `moveToState(fragment, mCurState, transition, transitionStyle, false)` is added to the late version which introduces a new parameter; and the 'mAdded.add(fragment)' has been moved. All these changes fall into categories 1 (Return statement changed), 3 (Control dependency change), and 5 (Dependent API changed).","Due to the new assignment and method calls, the method could potentially return different values, falls into type 1 compatibility issue."
74,<android.view.View: void getLocationInWindow(int[])>,15,16,<android.view.View: void getLocationInWindow(int[])>,<android.view.View: void getLocationInWindow(int[])>,0,"MethodDeclaration(method_body, [Statement({, []), Statement(// When the view is not attached to a window, this method does not make sense, []), AssignmentExpression(=, [VariableReference(if (mAttachInfo, []), Expression(, [])]), Statement(return, []), AssignmentExpression(=, [VariableReference(if (location, []), Expression(, [])]), Statement(throw new IllegalArgumentException(""location must be an array of two integers""), []), Statement(}, []), AssignmentExpression(=, [VariableReference(float[] position, []), Expression(mAttachInfo.mTmpTransformLocation, [])]), AssignmentExpression(=, [VariableReference(position[0], []), Expression(position[1], [])]), Statement(if (!hasIdentityMatrix()) {, []), MethodCall(getMatrix().mapPoints(position), [VariableReference(getMatrix(), []), Expression(position, [])]), Statement(}, []), AssignmentExpression(=, [VariableReference(position[0] +, []), Expression(mLeft, [])]), AssignmentExpression(=, [VariableReference(position[1] +, []), Expression(mTop, [])]), AssignmentExpression(=, [VariableReference(ViewParent viewParent, []), Expression(mParent, [])]), Statement(while (viewParent instanceof View) {, []), AssignmentExpression(=, [VariableReference(final View view, []), Expression((View) viewParent, [])]), AssignmentExpression(=, [VariableReference(position[0] -, []), Expression(view.mScrollX, [])]), AssignmentExpression(=, [VariableReference(position[1] -, []), Expression(view.mScrollY, [])]), MethodCall(if (!view.hasIdentityMatrix()), [VariableReference(if (!view, []), Expression(), [])]), MethodCall(view.getMatrix().mapPoints(position), [VariableReference(view, []), Expression().mapPoints(position, [])]), Statement(}, []), AssignmentExpression(=, [VariableReference(position[0] +, []), Expression(view.mLeft, [])]), AssignmentExpression(=, [VariableReference(position[1] +, []), Expression(view.mTop, [])]), AssignmentExpression(=, [VariableReference(viewParent, []), Expression(view.mParent, [])]), Statement(}, []), Statement(if (viewParent instanceof ViewRootImpl) {, []), Statement(// *cough*, []), AssignmentExpression(=, [VariableReference(final ViewRootImpl vr, []), Expression((ViewRootImpl) viewParent, [])]), AssignmentExpression(=, [VariableReference(position[1] -, []), Expression(vr.mCurScrollY, [])]), Statement(}, []), AssignmentExpression(=, [VariableReference(location[0], []), Expression((int) (position[0] + 0.5f), [])]), AssignmentExpression(=, [VariableReference(location[1], []), Expression((int) (position[1] + 0.5f), [])]), Statement(}, [])])  Statement({, [])  Statement(// When the view is not attached to a window, this method does not make sense, [])  AssignmentExpression(=, [VariableReference(if (mAttachInfo, []), Expression(, [])])    VariableReference(if (mAttachInfo, [])    Expression(, [])  Statement(return, [])  AssignmentExpression(=, [VariableReference(if (location, []), Expression(, [])])    VariableReference(if (location, [])    Expression(, [])  Statement(throw new IllegalArgumentException(""location must be an array of two integers""), [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(float[] position, []), Expression(mAttachInfo.mTmpTransformLocation, [])])    VariableReference(float[] position, [])    Expression(mAttachInfo.mTmpTransformLocation, [])  AssignmentExpression(=, [VariableReference(position[0], []), Expression(position[1], [])])    VariableReference(position[0], [])    Expression(position[1], [])  Statement(if (!hasIdentityMatrix()) {, [])  MethodCall(getMatrix().mapPoints(position), [VariableReference(getMatrix(), []), Expression(position, [])])    VariableReference(getMatrix(), [])    Expression(position, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(position[0] +, []), Expression(mLeft, [])])    VariableReference(position[0] +, [])    Expression(mLeft, [])  AssignmentExpression(=, [VariableReference(position[1] +, []), Expression(mTop, [])])    VariableReference(position[1] +, [])    Expression(mTop, [])  AssignmentExpression(=, [VariableReference(ViewParent viewParent, []), Expression(mParent, [])])    VariableReference(ViewParent viewParent, [])    Expression(mParent, [])  Statement(while (viewParent instanceof View) {, [])  AssignmentExpression(=, [VariableReference(final View view, []), Expression((View) viewParent, [])])    VariableReference(final View view, [])    Expression((View) viewParent, [])  AssignmentExpression(=, [VariableReference(position[0] -, []), Expression(view.mScrollX, [])])    VariableReference(position[0] -, [])    Expression(view.mScrollX, [])  AssignmentExpression(=, [VariableReference(position[1] -, []), Expression(view.mScrollY, [])])    VariableReference(position[1] -, [])    Expression(view.mScrollY, [])  MethodCall(if (!view.hasIdentityMatrix()), [VariableReference(if (!view, []), Expression(), [])])    VariableReference(if (!view, [])    Expression(), [])  MethodCall(view.getMatrix().mapPoints(position), [VariableReference(view, []), Expression().mapPoints(position, [])])    VariableReference(view, [])    Expression().mapPoints(position, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(position[0] +, []), Expression(view.mLeft, [])])    VariableReference(position[0] +, [])    Expression(view.mLeft, [])  AssignmentExpression(=, [VariableReference(position[1] +, []), Expression(view.mTop, [])])    VariableReference(position[1] +, [])    Expression(view.mTop, [])  AssignmentExpression(=, [VariableReference(viewParent, []), Expression(view.mParent, [])])    VariableReference(viewParent, [])    Expression(view.mParent, [])  Statement(}, [])  Statement(if (viewParent instanceof ViewRootImpl) {, [])  Statement(// *cough*, [])  AssignmentExpression(=, [VariableReference(final ViewRootImpl vr, []), Expression((ViewRootImpl) viewParent, [])])    VariableReference(final ViewRootImpl vr, [])    Expression((ViewRootImpl) viewParent, [])  AssignmentExpression(=, [VariableReference(position[1] -, []), Expression(vr.mCurScrollY, [])])    VariableReference(position[1] -, [])    Expression(vr.mCurScrollY, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(location[0], []), Expression((int) (position[0] + 0.5f), [])])    VariableReference(location[0], [])    Expression((int) (position[0] + 0.5f), [])  AssignmentExpression(=, [VariableReference(location[1], []), Expression((int) (position[1] + 0.5f), [])])    VariableReference(location[1], [])    Expression((int) (position[1] + 0.5f), [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(if (location, []), Expression(, [])]), Statement(throw new IllegalArgumentException(""location must be an array of two integers""), []), Statement(}, []), AssignmentExpression(=, [VariableReference(if (mAttachInfo, []), Expression(, [])]), Statement(// When the view is not attached to a window, this method does not make sense, []), AssignmentExpression(=, [VariableReference(location[0], []), Expression(location[1], [])]), Statement(return, []), Statement(}, []), AssignmentExpression(=, [VariableReference(float[] position, []), Expression(mAttachInfo.mTmpTransformLocation, [])]), AssignmentExpression(=, [VariableReference(position[0], []), Expression(position[1], [])]), Statement(if (!hasIdentityMatrix()) {, []), MethodCall(getMatrix().mapPoints(position), [VariableReference(getMatrix(), []), Expression(position, [])]), Statement(}, []), AssignmentExpression(=, [VariableReference(position[0] +, []), Expression(mLeft, [])]), AssignmentExpression(=, [VariableReference(position[1] +, []), Expression(mTop, [])]), AssignmentExpression(=, [VariableReference(ViewParent viewParent, []), Expression(mParent, [])]), Statement(while (viewParent instanceof View) {, []), AssignmentExpression(=, [VariableReference(final View view, []), Expression((View) viewParent, [])]), AssignmentExpression(=, [VariableReference(position[0] -, []), Expression(view.mScrollX, [])]), AssignmentExpression(=, [VariableReference(position[1] -, []), Expression(view.mScrollY, [])]), MethodCall(if (!view.hasIdentityMatrix()), [VariableReference(if (!view, []), Expression(), [])]), MethodCall(view.getMatrix().mapPoints(position), [VariableReference(view, []), Expression().mapPoints(position, [])]), Statement(}, []), AssignmentExpression(=, [VariableReference(position[0] +, []), Expression(view.mLeft, [])]), AssignmentExpression(=, [VariableReference(position[1] +, []), Expression(view.mTop, [])]), AssignmentExpression(=, [VariableReference(viewParent, []), Expression(view.mParent, [])]), Statement(}, []), Statement(if (viewParent instanceof ViewRootImpl) {, []), Statement(// *cough*, []), AssignmentExpression(=, [VariableReference(final ViewRootImpl vr, []), Expression((ViewRootImpl) viewParent, [])]), AssignmentExpression(=, [VariableReference(position[1] -, []), Expression(vr.mCurScrollY, [])]), Statement(}, []), AssignmentExpression(=, [VariableReference(location[0], []), Expression((int) (position[0] + 0.5f), [])]), AssignmentExpression(=, [VariableReference(location[1], []), Expression((int) (position[1] + 0.5f), [])]), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(if (location, []), Expression(, [])])    VariableReference(if (location, [])    Expression(, [])  Statement(throw new IllegalArgumentException(""location must be an array of two integers""), [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(if (mAttachInfo, []), Expression(, [])])    VariableReference(if (mAttachInfo, [])    Expression(, [])  Statement(// When the view is not attached to a window, this method does not make sense, [])  AssignmentExpression(=, [VariableReference(location[0], []), Expression(location[1], [])])    VariableReference(location[0], [])    Expression(location[1], [])  Statement(return, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(float[] position, []), Expression(mAttachInfo.mTmpTransformLocation, [])])    VariableReference(float[] position, [])    Expression(mAttachInfo.mTmpTransformLocation, [])  AssignmentExpression(=, [VariableReference(position[0], []), Expression(position[1], [])])    VariableReference(position[0], [])    Expression(position[1], [])  Statement(if (!hasIdentityMatrix()) {, [])  MethodCall(getMatrix().mapPoints(position), [VariableReference(getMatrix(), []), Expression(position, [])])    VariableReference(getMatrix(), [])    Expression(position, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(position[0] +, []), Expression(mLeft, [])])    VariableReference(position[0] +, [])    Expression(mLeft, [])  AssignmentExpression(=, [VariableReference(position[1] +, []), Expression(mTop, [])])    VariableReference(position[1] +, [])    Expression(mTop, [])  AssignmentExpression(=, [VariableReference(ViewParent viewParent, []), Expression(mParent, [])])    VariableReference(ViewParent viewParent, [])    Expression(mParent, [])  Statement(while (viewParent instanceof View) {, [])  AssignmentExpression(=, [VariableReference(final View view, []), Expression((View) viewParent, [])])    VariableReference(final View view, [])    Expression((View) viewParent, [])  AssignmentExpression(=, [VariableReference(position[0] -, []), Expression(view.mScrollX, [])])    VariableReference(position[0] -, [])    Expression(view.mScrollX, [])  AssignmentExpression(=, [VariableReference(position[1] -, []), Expression(view.mScrollY, [])])    VariableReference(position[1] -, [])    Expression(view.mScrollY, [])  MethodCall(if (!view.hasIdentityMatrix()), [VariableReference(if (!view, []), Expression(), [])])    VariableReference(if (!view, [])    Expression(), [])  MethodCall(view.getMatrix().mapPoints(position), [VariableReference(view, []), Expression().mapPoints(position, [])])    VariableReference(view, [])    Expression().mapPoints(position, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(position[0] +, []), Expression(view.mLeft, [])])    VariableReference(position[0] +, [])    Expression(view.mLeft, [])  AssignmentExpression(=, [VariableReference(position[1] +, []), Expression(view.mTop, [])])    VariableReference(position[1] +, [])    Expression(view.mTop, [])  AssignmentExpression(=, [VariableReference(viewParent, []), Expression(view.mParent, [])])    VariableReference(viewParent, [])    Expression(view.mParent, [])  Statement(}, [])  Statement(if (viewParent instanceof ViewRootImpl) {, [])  Statement(// *cough*, [])  AssignmentExpression(=, [VariableReference(final ViewRootImpl vr, []), Expression((ViewRootImpl) viewParent, [])])    VariableReference(final ViewRootImpl vr, [])    Expression((ViewRootImpl) viewParent, [])  AssignmentExpression(=, [VariableReference(position[1] -, []), Expression(vr.mCurScrollY, [])])    VariableReference(position[1] -, [])    Expression(vr.mCurScrollY, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(location[0], []), Expression((int) (position[0] + 0.5f), [])])    VariableReference(location[0], [])    Expression((int) (position[0] + 0.5f), [])  AssignmentExpression(=, [VariableReference(location[1], []), Expression((int) (position[1] + 0.5f), [])])    VariableReference(location[1], [])    Expression((int) (position[1] + 0.5f), [])  Statement(}, [])",1,"/**
 * <p>Computes the coordinates of this view in its window. The argument
 * must be an array of two integers. After the method returns, the array
 * contains the x and y location in that order.</p>
 *
 * @param location an array of two integers in which to hold the coordinates
 */
","/**
 * <p>Computes the coordinates of this view in its window. The argument
 * must be an array of two integers. After the method returns, the array
 * contains the x and y location in that order.</p>
 *
 * @param location an array of two integers in which to hold the coordinates
 */
",0,,,0,0,0,0,1,"1,3",1,3,1,"The if (mAttachInfo == null) return; statement is removed in the late version, which makes it a control dependency change.","Since the early version returns early when the condition mAttachInfo == null is true, removing this condition check makes the method potentially return different results under the same condition, causing a compatibility issue."
76,"<android.widget.ExpandableListView: ContextMenuInfo createContextMenuInfo(View,int,long)>",15,16,"<android.widget.ExpandableListView: ContextMenuInfo createContextMenuInfo(View,int,long)>","<android.widget.ExpandableListView: ContextMenuInfo createContextMenuInfo(View,int,long)>",0,"MethodDeclaration(method_body, [Statement({, []), Statement(if (isHeaderOrFooterPosition(flatListPosition)) {, []), Statement(// Return normal info for header/footer view context menus, []), Statement(return new AdapterContextMenuInfo(view, flatListPosition, id), []), Statement(}, []), AssignmentExpression(=, [VariableReference(final int adjustedPosition, []), Expression(getFlatPositionForConnector(flatListPosition), [])]), AssignmentExpression(=, [VariableReference(PositionMetadata pm, []), Expression(mConnector.getUnflattenedPos(adjustedPosition), [])]), AssignmentExpression(=, [VariableReference(ExpandableListPosition pos, []), Expression(pm.position, [])]), MethodCall(pm.recycle(), [VariableReference(pm, []), Expression(, [])]), AssignmentExpression(=, [VariableReference(id, []), Expression(getChildOrGroupId(pos), [])]), AssignmentExpression(=, [VariableReference(long packedPosition, []), Expression(pos.getPackedPosition(), [])]), MethodCall(pos.recycle(), [VariableReference(pos, []), Expression(, [])]), Statement(return new ExpandableListContextMenuInfo(view, packedPosition, id), []), Statement(}, [])])  Statement({, [])  Statement(if (isHeaderOrFooterPosition(flatListPosition)) {, [])  Statement(// Return normal info for header/footer view context menus, [])  Statement(return new AdapterContextMenuInfo(view, flatListPosition, id), [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(final int adjustedPosition, []), Expression(getFlatPositionForConnector(flatListPosition), [])])    VariableReference(final int adjustedPosition, [])    Expression(getFlatPositionForConnector(flatListPosition), [])  AssignmentExpression(=, [VariableReference(PositionMetadata pm, []), Expression(mConnector.getUnflattenedPos(adjustedPosition), [])])    VariableReference(PositionMetadata pm, [])    Expression(mConnector.getUnflattenedPos(adjustedPosition), [])  AssignmentExpression(=, [VariableReference(ExpandableListPosition pos, []), Expression(pm.position, [])])    VariableReference(ExpandableListPosition pos, [])    Expression(pm.position, [])  MethodCall(pm.recycle(), [VariableReference(pm, []), Expression(, [])])    VariableReference(pm, [])    Expression(, [])  AssignmentExpression(=, [VariableReference(id, []), Expression(getChildOrGroupId(pos), [])])    VariableReference(id, [])    Expression(getChildOrGroupId(pos), [])  AssignmentExpression(=, [VariableReference(long packedPosition, []), Expression(pos.getPackedPosition(), [])])    VariableReference(long packedPosition, [])    Expression(pos.getPackedPosition(), [])  MethodCall(pos.recycle(), [VariableReference(pos, []), Expression(, [])])    VariableReference(pos, [])    Expression(, [])  Statement(return new ExpandableListContextMenuInfo(view, packedPosition, id), [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(if (isHeaderOrFooterPosition(flatListPosition)) {, []), Statement(// Return normal info for header/footer view context menus, []), Statement(return new AdapterContextMenuInfo(view, flatListPosition, id), []), Statement(}, []), AssignmentExpression(=, [VariableReference(final int adjustedPosition, []), Expression(getFlatPositionForConnector(flatListPosition), [])]), AssignmentExpression(=, [VariableReference(PositionMetadata pm, []), Expression(mConnector.getUnflattenedPos(adjustedPosition), [])]), AssignmentExpression(=, [VariableReference(ExpandableListPosition pos, []), Expression(pm.position, [])]), AssignmentExpression(=, [VariableReference(id, []), Expression(getChildOrGroupId(pos), [])]), AssignmentExpression(=, [VariableReference(long packedPosition, []), Expression(pos.getPackedPosition(), [])]), MethodCall(pm.recycle(), [VariableReference(pm, []), Expression(, [])]), Statement(return new ExpandableListContextMenuInfo(view, packedPosition, id), []), Statement(}, [])])  Statement({, [])  Statement(if (isHeaderOrFooterPosition(flatListPosition)) {, [])  Statement(// Return normal info for header/footer view context menus, [])  Statement(return new AdapterContextMenuInfo(view, flatListPosition, id), [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(final int adjustedPosition, []), Expression(getFlatPositionForConnector(flatListPosition), [])])    VariableReference(final int adjustedPosition, [])    Expression(getFlatPositionForConnector(flatListPosition), [])  AssignmentExpression(=, [VariableReference(PositionMetadata pm, []), Expression(mConnector.getUnflattenedPos(adjustedPosition), [])])    VariableReference(PositionMetadata pm, [])    Expression(mConnector.getUnflattenedPos(adjustedPosition), [])  AssignmentExpression(=, [VariableReference(ExpandableListPosition pos, []), Expression(pm.position, [])])    VariableReference(ExpandableListPosition pos, [])    Expression(pm.position, [])  AssignmentExpression(=, [VariableReference(id, []), Expression(getChildOrGroupId(pos), [])])    VariableReference(id, [])    Expression(getChildOrGroupId(pos), [])  AssignmentExpression(=, [VariableReference(long packedPosition, []), Expression(pos.getPackedPosition(), [])])    VariableReference(long packedPosition, [])    Expression(pos.getPackedPosition(), [])  MethodCall(pm.recycle(), [VariableReference(pm, []), Expression(, [])])    VariableReference(pm, [])    Expression(, [])  Statement(return new ExpandableListContextMenuInfo(view, packedPosition, id), [])  Statement(}, [])",1,,,0,[@Override],[@Override],0,0,0,0,1,4,0,0,0,No changes were detected between the early and late version implementations of the API.,No compatibility issues were found as no changes were made between the two versions.
78,<android.animation.KeyframeSet: KeyframeSet ofFloat(float)>,17,18,<android.animation.KeyframeSet: KeyframeSet ofFloat(float)>,<android.animation.KeyframeSet: KeyframeSet ofFloat(float)>,0,"MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(int numKeyframes, []), Expression(values.length, [])]), AssignmentExpression(=, [VariableReference(FloatKeyframe[] keyframes, []), Expression(new FloatKeyframe[Math.max(numKeyframes, 2)], [])]), AssignmentExpression(=, [VariableReference(if (numKeyframes, []), Expression(, [])]), AssignmentExpression(=, [VariableReference(keyframes[0], []), Expression((FloatKeyframe) Keyframe.ofFloat(0f), [])]), AssignmentExpression(=, [VariableReference(keyframes[1], []), Expression((FloatKeyframe) Keyframe.ofFloat(1f, values[0]), [])]), Statement(} else {, []), AssignmentExpression(=, [VariableReference(keyframes[0], []), Expression((FloatKeyframe) Keyframe.ofFloat(0f, values[0]), [])]), AssignmentExpression(=, [VariableReference(for (int i, []), Expression(1, [])]), Statement(i < numKeyframes, []), Statement(++i) {, []), AssignmentExpression(=, [VariableReference(keyframes[i], []), Expression((FloatKeyframe) Keyframe.ofFloat((float) i / (numKeyframes - 1), values[i]), [])]), Statement(}, []), Statement(}, []), Statement(return new FloatKeyframeSet(keyframes), []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(int numKeyframes, []), Expression(values.length, [])])    VariableReference(int numKeyframes, [])    Expression(values.length, [])  AssignmentExpression(=, [VariableReference(FloatKeyframe[] keyframes, []), Expression(new FloatKeyframe[Math.max(numKeyframes, 2)], [])])    VariableReference(FloatKeyframe[] keyframes, [])    Expression(new FloatKeyframe[Math.max(numKeyframes, 2)], [])  AssignmentExpression(=, [VariableReference(if (numKeyframes, []), Expression(, [])])    VariableReference(if (numKeyframes, [])    Expression(, [])  AssignmentExpression(=, [VariableReference(keyframes[0], []), Expression((FloatKeyframe) Keyframe.ofFloat(0f), [])])    VariableReference(keyframes[0], [])    Expression((FloatKeyframe) Keyframe.ofFloat(0f), [])  AssignmentExpression(=, [VariableReference(keyframes[1], []), Expression((FloatKeyframe) Keyframe.ofFloat(1f, values[0]), [])])    VariableReference(keyframes[1], [])    Expression((FloatKeyframe) Keyframe.ofFloat(1f, values[0]), [])  Statement(} else {, [])  AssignmentExpression(=, [VariableReference(keyframes[0], []), Expression((FloatKeyframe) Keyframe.ofFloat(0f, values[0]), [])])    VariableReference(keyframes[0], [])    Expression((FloatKeyframe) Keyframe.ofFloat(0f, values[0]), [])  AssignmentExpression(=, [VariableReference(for (int i, []), Expression(1, [])])    VariableReference(for (int i, [])    Expression(1, [])  Statement(i < numKeyframes, [])  Statement(++i) {, [])  AssignmentExpression(=, [VariableReference(keyframes[i], []), Expression((FloatKeyframe) Keyframe.ofFloat((float) i / (numKeyframes - 1), values[i]), [])])    VariableReference(keyframes[i], [])    Expression((FloatKeyframe) Keyframe.ofFloat((float) i / (numKeyframes - 1), values[i]), [])  Statement(}, [])  Statement(}, [])  Statement(return new FloatKeyframeSet(keyframes), [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(boolean badValue, []), Expression(false, [])]), AssignmentExpression(=, [VariableReference(int numKeyframes, []), Expression(values.length, [])]), AssignmentExpression(=, [VariableReference(FloatKeyframe[] keyframes, []), Expression(new FloatKeyframe[Math.max(numKeyframes, 2)], [])]), AssignmentExpression(=, [VariableReference(if (numKeyframes, []), Expression(, [])]), AssignmentExpression(=, [VariableReference(keyframes[0], []), Expression((FloatKeyframe) Keyframe.ofFloat(0f), [])]), AssignmentExpression(=, [VariableReference(keyframes[1], []), Expression((FloatKeyframe) Keyframe.ofFloat(1f, values[0]), [])]), MethodCall(if (Float.isNaN(values[0])), [VariableReference(if (Float, []), Expression(values[0]), [])]), AssignmentExpression(=, [VariableReference(badValue, []), Expression(true, [])]), Statement(}, []), Statement(} else {, []), AssignmentExpression(=, [VariableReference(keyframes[0], []), Expression((FloatKeyframe) Keyframe.ofFloat(0f, values[0]), [])]), AssignmentExpression(=, [VariableReference(for (int i, []), Expression(1, [])]), Statement(i < numKeyframes, []), Statement(++i) {, []), AssignmentExpression(=, [VariableReference(keyframes[i], []), Expression((FloatKeyframe) Keyframe.ofFloat((float) i / (numKeyframes - 1), values[i]), [])]), MethodCall(if (Float.isNaN(values[i])), [VariableReference(if (Float, []), Expression(values[i]), [])]), AssignmentExpression(=, [VariableReference(badValue, []), Expression(true, [])]), Statement(}, []), Statement(}, []), Statement(}, []), Statement(if (badValue) {, []), MethodCall(Log.w(""Animator"", ""Bad value (NaN) in float animator""), [VariableReference(Log, []), Expression(""Animator"", []), Expression(""Bad value (NaN) in float animator"", [])]), Statement(}, []), Statement(return new FloatKeyframeSet(keyframes), []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(boolean badValue, []), Expression(false, [])])    VariableReference(boolean badValue, [])    Expression(false, [])  AssignmentExpression(=, [VariableReference(int numKeyframes, []), Expression(values.length, [])])    VariableReference(int numKeyframes, [])    Expression(values.length, [])  AssignmentExpression(=, [VariableReference(FloatKeyframe[] keyframes, []), Expression(new FloatKeyframe[Math.max(numKeyframes, 2)], [])])    VariableReference(FloatKeyframe[] keyframes, [])    Expression(new FloatKeyframe[Math.max(numKeyframes, 2)], [])  AssignmentExpression(=, [VariableReference(if (numKeyframes, []), Expression(, [])])    VariableReference(if (numKeyframes, [])    Expression(, [])  AssignmentExpression(=, [VariableReference(keyframes[0], []), Expression((FloatKeyframe) Keyframe.ofFloat(0f), [])])    VariableReference(keyframes[0], [])    Expression((FloatKeyframe) Keyframe.ofFloat(0f), [])  AssignmentExpression(=, [VariableReference(keyframes[1], []), Expression((FloatKeyframe) Keyframe.ofFloat(1f, values[0]), [])])    VariableReference(keyframes[1], [])    Expression((FloatKeyframe) Keyframe.ofFloat(1f, values[0]), [])  MethodCall(if (Float.isNaN(values[0])), [VariableReference(if (Float, []), Expression(values[0]), [])])    VariableReference(if (Float, [])    Expression(values[0]), [])  AssignmentExpression(=, [VariableReference(badValue, []), Expression(true, [])])    VariableReference(badValue, [])    Expression(true, [])  Statement(}, [])  Statement(} else {, [])  AssignmentExpression(=, [VariableReference(keyframes[0], []), Expression((FloatKeyframe) Keyframe.ofFloat(0f, values[0]), [])])    VariableReference(keyframes[0], [])    Expression((FloatKeyframe) Keyframe.ofFloat(0f, values[0]), [])  AssignmentExpression(=, [VariableReference(for (int i, []), Expression(1, [])])    VariableReference(for (int i, [])    Expression(1, [])  Statement(i < numKeyframes, [])  Statement(++i) {, [])  AssignmentExpression(=, [VariableReference(keyframes[i], []), Expression((FloatKeyframe) Keyframe.ofFloat((float) i / (numKeyframes - 1), values[i]), [])])    VariableReference(keyframes[i], [])    Expression((FloatKeyframe) Keyframe.ofFloat((float) i / (numKeyframes - 1), values[i]), [])  MethodCall(if (Float.isNaN(values[i])), [VariableReference(if (Float, []), Expression(values[i]), [])])    VariableReference(if (Float, [])    Expression(values[i]), [])  AssignmentExpression(=, [VariableReference(badValue, []), Expression(true, [])])    VariableReference(badValue, [])    Expression(true, [])  Statement(}, [])  Statement(}, [])  Statement(}, [])  Statement(if (badValue) {, [])  MethodCall(Log.w(""Animator"", ""Bad value (NaN) in float animator""), [VariableReference(Log, []), Expression(""Animator"", []), Expression(""Bad value (NaN) in float animator"", [])])    VariableReference(Log, [])    Expression(""Animator"", [])    Expression(""Bad value (NaN) in float animator"", [])  Statement(}, [])  Statement(return new FloatKeyframeSet(keyframes), [])  Statement(}, [])",1,,,0,,,0,0,0,0,1,"3,4",0,"2,3,4",2,"In the late version, a new boolean variable called 'badValue' was introduced and used in the exception handling statements to check if the values are NaN. Some new conditional control structures if(Float.isNaN(values[i])) has also been introduced within the for loop. These changes contribute to the change types 2, 3, and 4.","The late version API could throw different exceptions than the early version due to the introduction of more detailed exception handling code. Even if the early version doesn't throw an exception, newly introduced exception handling code can lead to different behaviours. Hence, the CI type is 2."
79,<android.view.ViewGroup.MarginLayoutParams: void resolveLayoutDirection(int)>,17,18,<android.view.ViewGroup.MarginLayoutParams: void resolveLayoutDirection(int)>,<android.view.ViewGroup.MarginLayoutParams: void resolveLayoutDirection(int)>,0,"MethodDeclaration(method_body, [Statement({, []), Statement(setLayoutDirection(layoutDirection), []), Statement(if (!isMarginRelative()), []), Statement(return, []), Statement(switch(layoutDirection) {, []), Statement(case View.LAYOUT_DIRECTION_RTL:, []), AssignmentExpression(=, [VariableReference(leftMargin, []), Expression((endMargin > DEFAULT_RELATIVE) ? endMargin : initialLeftMargin, [])]), AssignmentExpression(=, [VariableReference(rightMargin, []), Expression((startMargin > DEFAULT_RELATIVE) ? startMargin : initialRightMargin, [])]), Statement(break, []), Statement(case View.LAYOUT_DIRECTION_LTR:, []), Statement(default:, []), AssignmentExpression(=, [VariableReference(leftMargin, []), Expression((startMargin > DEFAULT_RELATIVE) ? startMargin : initialLeftMargin, [])]), AssignmentExpression(=, [VariableReference(rightMargin, []), Expression((endMargin > DEFAULT_RELATIVE) ? endMargin : initialRightMargin, [])]), Statement(break, []), Statement(}, []), Statement(}, [])])  Statement({, [])  Statement(setLayoutDirection(layoutDirection), [])  Statement(if (!isMarginRelative()), [])  Statement(return, [])  Statement(switch(layoutDirection) {, [])  Statement(case View.LAYOUT_DIRECTION_RTL:, [])  AssignmentExpression(=, [VariableReference(leftMargin, []), Expression((endMargin > DEFAULT_RELATIVE) ? endMargin : initialLeftMargin, [])])    VariableReference(leftMargin, [])    Expression((endMargin > DEFAULT_RELATIVE) ? endMargin : initialLeftMargin, [])  AssignmentExpression(=, [VariableReference(rightMargin, []), Expression((startMargin > DEFAULT_RELATIVE) ? startMargin : initialRightMargin, [])])    VariableReference(rightMargin, [])    Expression((startMargin > DEFAULT_RELATIVE) ? startMargin : initialRightMargin, [])  Statement(break, [])  Statement(case View.LAYOUT_DIRECTION_LTR:, [])  Statement(default:, [])  AssignmentExpression(=, [VariableReference(leftMargin, []), Expression((startMargin > DEFAULT_RELATIVE) ? startMargin : initialLeftMargin, [])])    VariableReference(leftMargin, [])    Expression((startMargin > DEFAULT_RELATIVE) ? startMargin : initialLeftMargin, [])  AssignmentExpression(=, [VariableReference(rightMargin, []), Expression((endMargin > DEFAULT_RELATIVE) ? endMargin : initialRightMargin, [])])    VariableReference(rightMargin, [])    Expression((endMargin > DEFAULT_RELATIVE) ? endMargin : initialRightMargin, [])  Statement(break, [])  Statement(}, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(setLayoutDirection(layoutDirection), []), Statement(// Will use the left and right margins if no relative margin is defined., []), AssignmentExpression(=, [VariableReference(if (!isMarginRelative() || (mMarginFlags & NEED_RESOLUTION_MASK) !, []), Expression(NEED_RESOLUTION_MASK), [])]), Statement(return, []), Statement(// Proceed with resolution, []), Statement(doResolveMargins(), []), Statement(}, [])])  Statement({, [])  Statement(setLayoutDirection(layoutDirection), [])  Statement(// Will use the left and right margins if no relative margin is defined., [])  AssignmentExpression(=, [VariableReference(if (!isMarginRelative() || (mMarginFlags & NEED_RESOLUTION_MASK) !, []), Expression(NEED_RESOLUTION_MASK), [])])    VariableReference(if (!isMarginRelative() || (mMarginFlags & NEED_RESOLUTION_MASK) !, [])    Expression(NEED_RESOLUTION_MASK), [])  Statement(return, [])  Statement(// Proceed with resolution, [])  Statement(doResolveMargins(), [])  Statement(}, [])",1,"/**
 * This will be called by {@link android.view.View#requestLayout()}. Left and Right margins
 * may be overridden depending on layout direction.
 */
","/**
 * This will be called by {@link android.view.View#requestLayout()}. Left and Right margins
 * may be overridden depending on layout direction.
 */
",0,[@Override],[@Override],0,0,0,0,1,"1,3",1,"1,3,4",1,"The entire method has been revised. The 'switch' statement and the assignment expressions under it have been removed, the 'if' condition has been revised and it's no more a single condition, instead it has become complex with 'or' condition. A new method 'doResolveMargins()' has been called at the end of the method, so the change type is 1,3,4.","As control flow and return statement changed, the method may return different value depending on the new 'if' condition and the new 'doResolveMargins()' method call, so the CI type is 1."
81,"<android.appwidget.AppWidgetHost: AppWidgetHostView createView(Context,int,AppWidgetProviderInfo)>",17,18,"<android.appwidget.AppWidgetHost: AppWidgetHostView createView(Context,int,AppWidgetProviderInfo)>","<android.appwidget.AppWidgetHost: AppWidgetHostView createView(Context,int,AppWidgetProviderInfo)>",0,"MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(AppWidgetHostView view, []), Expression(onCreateView(context, appWidgetId, appWidget), [])]), MethodCall(view.setOnClickHandler(mOnClickHandler), [VariableReference(view, []), Expression(mOnClickHandler, [])]), MethodCall(view.setAppWidget(appWidgetId, appWidget), [VariableReference(view, []), Expression(appWidgetId, []), Expression(appWidget, [])]), Statement(synchronized (mViews) {, []), MethodCall(mViews.put(appWidgetId, view), [VariableReference(mViews, []), Expression(appWidgetId, []), Expression(view, [])]), Statement(}, []), Statement(RemoteViews views, []), Statement(try {, []), AssignmentExpression(=, [VariableReference(views, []), Expression(sService.getAppWidgetViews(appWidgetId), [])]), Statement(} catch (RemoteException e) {, []), Statement(throw new RuntimeException(""system server dead?"", e), []), Statement(}, []), MethodCall(view.updateAppWidget(views), [VariableReference(view, []), Expression(views, [])]), Statement(return view, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(AppWidgetHostView view, []), Expression(onCreateView(context, appWidgetId, appWidget), [])])    VariableReference(AppWidgetHostView view, [])    Expression(onCreateView(context, appWidgetId, appWidget), [])  MethodCall(view.setOnClickHandler(mOnClickHandler), [VariableReference(view, []), Expression(mOnClickHandler, [])])    VariableReference(view, [])    Expression(mOnClickHandler, [])  MethodCall(view.setAppWidget(appWidgetId, appWidget), [VariableReference(view, []), Expression(appWidgetId, []), Expression(appWidget, [])])    VariableReference(view, [])    Expression(appWidgetId, [])    Expression(appWidget, [])  Statement(synchronized (mViews) {, [])  MethodCall(mViews.put(appWidgetId, view), [VariableReference(mViews, []), Expression(appWidgetId, []), Expression(view, [])])    VariableReference(mViews, [])    Expression(appWidgetId, [])    Expression(view, [])  Statement(}, [])  Statement(RemoteViews views, [])  Statement(try {, [])  AssignmentExpression(=, [VariableReference(views, []), Expression(sService.getAppWidgetViews(appWidgetId), [])])    VariableReference(views, [])    Expression(sService.getAppWidgetViews(appWidgetId), [])  Statement(} catch (RemoteException e) {, [])  Statement(throw new RuntimeException(""system server dead?"", e), [])  Statement(}, [])  MethodCall(view.updateAppWidget(views), [VariableReference(view, []), Expression(views, [])])    VariableReference(view, [])    Expression(views, [])  Statement(return view, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(final int userId, []), Expression(mContext.getUserId(), [])]), AssignmentExpression(=, [VariableReference(AppWidgetHostView view, []), Expression(onCreateView(mContext, appWidgetId, appWidget), [])]), MethodCall(view.setUserId(userId), [VariableReference(view, []), Expression(userId, [])]), MethodCall(view.setOnClickHandler(mOnClickHandler), [VariableReference(view, []), Expression(mOnClickHandler, [])]), MethodCall(view.setAppWidget(appWidgetId, appWidget), [VariableReference(view, []), Expression(appWidgetId, []), Expression(appWidget, [])]), Statement(synchronized (mViews) {, []), MethodCall(mViews.put(appWidgetId, view), [VariableReference(mViews, []), Expression(appWidgetId, []), Expression(view, [])]), Statement(}, []), Statement(RemoteViews views, []), Statement(try {, []), AssignmentExpression(=, [VariableReference(views, []), Expression(sService.getAppWidgetViews(appWidgetId, userId), [])]), AssignmentExpression(=, [VariableReference(if (views !, []), Expression(null) {, [])]), MethodCall(views.setUser(new UserHandle(mContext.getUserId())), [VariableReference(views, []), Expression(new UserHandle(mContext.getUserId()), [])]), Statement(}, []), Statement(} catch (RemoteException e) {, []), Statement(throw new RuntimeException(""system server dead?"", e), []), Statement(}, []), MethodCall(view.updateAppWidget(views), [VariableReference(view, []), Expression(views, [])]), Statement(return view, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(final int userId, []), Expression(mContext.getUserId(), [])])    VariableReference(final int userId, [])    Expression(mContext.getUserId(), [])  AssignmentExpression(=, [VariableReference(AppWidgetHostView view, []), Expression(onCreateView(mContext, appWidgetId, appWidget), [])])    VariableReference(AppWidgetHostView view, [])    Expression(onCreateView(mContext, appWidgetId, appWidget), [])  MethodCall(view.setUserId(userId), [VariableReference(view, []), Expression(userId, [])])    VariableReference(view, [])    Expression(userId, [])  MethodCall(view.setOnClickHandler(mOnClickHandler), [VariableReference(view, []), Expression(mOnClickHandler, [])])    VariableReference(view, [])    Expression(mOnClickHandler, [])  MethodCall(view.setAppWidget(appWidgetId, appWidget), [VariableReference(view, []), Expression(appWidgetId, []), Expression(appWidget, [])])    VariableReference(view, [])    Expression(appWidgetId, [])    Expression(appWidget, [])  Statement(synchronized (mViews) {, [])  MethodCall(mViews.put(appWidgetId, view), [VariableReference(mViews, []), Expression(appWidgetId, []), Expression(view, [])])    VariableReference(mViews, [])    Expression(appWidgetId, [])    Expression(view, [])  Statement(}, [])  Statement(RemoteViews views, [])  Statement(try {, [])  AssignmentExpression(=, [VariableReference(views, []), Expression(sService.getAppWidgetViews(appWidgetId, userId), [])])    VariableReference(views, [])    Expression(sService.getAppWidgetViews(appWidgetId, userId), [])  AssignmentExpression(=, [VariableReference(if (views !, []), Expression(null) {, [])])    VariableReference(if (views !, [])    Expression(null) {, [])  MethodCall(views.setUser(new UserHandle(mContext.getUserId())), [VariableReference(views, []), Expression(new UserHandle(mContext.getUserId()), [])])    VariableReference(views, [])    Expression(new UserHandle(mContext.getUserId()), [])  Statement(}, [])  Statement(} catch (RemoteException e) {, [])  Statement(throw new RuntimeException(""system server dead?"", e), [])  Statement(}, [])  MethodCall(view.updateAppWidget(views), [VariableReference(view, []), Expression(views, [])])    VariableReference(view, [])    Expression(views, [])  Statement(return view, [])  Statement(}, [])",1,"/**
 * Create the AppWidgetHostView for the given widget.
 * The AppWidgetHost retains a pointer to the newly-created View.
 */
","/**
 * Create the AppWidgetHostView for the given widget.
 * The AppWidgetHost retains a pointer to the newly-created View.
 */
",0,,,0,0,0,0,1|2,"1,3,4,5",1,"1,3,4,5",1,"There are several changes between the early and late version of method. First, a new variable `final int userId` is introduced and it is assigned the value from `mContext.getUserId()`. Second, the call to `onCreateView` method has changed to accept `mContext` instead of `context`. Third, the method call `view.setUserId(userId)` has been added. Fourth, inside the try block, the call to `sService.getAppWidgetViews` method now accepts `userId` as an additional parameter. Lastly, a new check for `views` not being null, and `views.setUser(new UserHandle(mContext.getUserId()))` method call is added. Therefore, the change type is 1,3,4,5.","As there are multiple changes such as introduction of a new variable, changing of method parameters, newly added method calls and control structure (if statement) which affect the return statement `return view`. These changes can lead to potentially different behavior and thus, the CI type is 1."
82,<android.view.accessibility.AccessibilityNodeInfo: void setFocused(boolean)>,17,18,<android.view.accessibility.AccessibilityNodeInfo: void setFocused(boolean)>,<android.view.accessibility.AccessibilityNodeInfo: void setFocused(boolean)>,0,"MethodDeclaration(method_body, [Statement({, []), Statement(setBooleanProperty(PROPERTY_FOCUSED, focused), []), Statement(}, [])])  Statement({, [])  Statement(setBooleanProperty(PROPERTY_FOCUSED, focused), [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(setBooleanProperty(BOOLEAN_PROPERTY_FOCUSED, focused), []), Statement(}, [])])  Statement({, [])  Statement(setBooleanProperty(BOOLEAN_PROPERTY_FOCUSED, focused), [])  Statement(}, [])",1,"/**
 * Sets whether this node is focused.
 * <p>
 * <strong>Note:</strong> Cannot be called from an
 * {@link android.accessibilityservice.AccessibilityService}.
 * This class is made immutable before being delivered to an AccessibilityService.
 * </p>
 *
 * @param focused True if the node is focused.
 *
 * @throws IllegalStateException If called from an AccessibilityService.
 */
","/**
 * Sets whether this node is focused.
 * <p>
 * <strong>Note:</strong> Cannot be called from an
 * {@link android.accessibilityservice.AccessibilityService}.
 * This class is made immutable before being delivered to an AccessibilityService.
 * </p>
 *
 * @param focused True if the node is focused.
 *
 * @throws IllegalStateException If called from an AccessibilityService.
 */
",0,,,0,0,0,0,2,5,0,"1,5",1,"The parameter in the function setBooleanProperty() has changed from PROPERTY_FOCUSED to BOOLEAN_PROPERTY_FOCUSED, so the code change type is 1,5.","The setFocused method could return a different value due to the change in the setBooleanProperty() function parameter leading to different behavior of the API, so the CI type is 1."
83,<android.os.Looper: void quit()>,17,18,<android.os.Looper: void quit()>,<android.os.Looper: void quit()>,0,"MethodDeclaration(method_body, [Statement({, []), MethodCall(mQueue.quit(), [VariableReference(mQueue, []), Expression(, [])]), Statement(}, [])])  Statement({, [])  MethodCall(mQueue.quit(), [VariableReference(mQueue, []), Expression(, [])])    VariableReference(mQueue, [])    Expression(, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), MethodCall(mQueue.quit(false), [VariableReference(mQueue, []), Expression(false, [])]), Statement(}, [])])  Statement({, [])  MethodCall(mQueue.quit(false), [VariableReference(mQueue, []), Expression(false, [])])    VariableReference(mQueue, [])    Expression(false, [])  Statement(}, [])",1,"/**
 * Quits the looper.
 *
 * Causes the {@link #loop} method to terminate as soon as possible.
 */
","/**
 * Quits the looper.
 * <p>
 * Causes the {@link #loop} method to terminate without processing any
 * more messages in the message queue.
 * </p><p>
 * Any attempt to post messages to the queue after the looper is asked to quit will fail.
 * For example, the {@link Handler#sendMessage(Message)} method will return false.
 * </p><p class=""note"">
 * Using this method may be unsafe because some messages may not be delivered
 * before the looper terminates.  Consider using {@link #quitSafely} instead to ensure
 * that all pending work is completed in an orderly manner.
 * </p>
 *
 * @see #quitSafely
 */
",1,,,0,0,0,0,2,5,0,"1,5",1,"The method call mQueue.quit() in the early version changed to mQueue.quit(false) in the late version. This means both the method dependant API and return statement was changed. Hence, the change type is 1,5.","The change in a method parameter of mQueue.quit() to mQueue.quit(false) may alter the return type or value, implying a potential compatibility issue. Therefore, the CI type is 1."
84,<android.os.Parcel: T readParcelable(ClassLoader)>,17,18,<android.os.Parcel: T readParcelable(ClassLoader)>,<android.os.Parcel: T readParcelable(ClassLoader)>,0,"MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(String name, []), Expression(readString(), [])]), AssignmentExpression(=, [VariableReference(if (name, []), Expression(, [])]), Statement(return null, []), Statement(}, []), Statement(Parcelable.Creator<T> creator, []), Statement(synchronized (mCreators) {, []), AssignmentExpression(=, [VariableReference(HashMap<String, Parcelable.Creator> map, []), Expression(mCreators.get(loader), [])]), AssignmentExpression(=, [VariableReference(if (map, []), Expression(, [])]), AssignmentExpression(=, [VariableReference(map, []), Expression(new HashMap<String, Parcelable.Creator>(), [])]), MethodCall(mCreators.put(loader, map), [VariableReference(mCreators, []), Expression(loader, []), Expression(map, [])]), Statement(}, []), AssignmentExpression(=, [VariableReference(creator, []), Expression(map.get(name), [])]), AssignmentExpression(=, [VariableReference(if (creator, []), Expression(, [])]), Statement(try {, []), AssignmentExpression(=, [VariableReference(Class c, []), Expression(loader, [])]), AssignmentExpression(=, [VariableReference(Field f, []), Expression(c.getField(""CREATOR""), [])]), AssignmentExpression(=, [VariableReference(creator, []), Expression((Parcelable.Creator) f.get(null), [])]), Statement(} catch (IllegalAccessException e) {, []), MethodCall(Log.e(TAG, ""Class not found when unmarshalling: "" + name + "", e: "" + e), [VariableReference(Log, []), Expression(TAG, []), Expression(""Class not found when unmarshalling: "" + name + "", []), Expression(e: "" + e, [])]), Statement(throw new BadParcelableException(""IllegalAccessException when unmarshalling: "" + name), []), Statement(} catch (ClassNotFoundException e) {, []), MethodCall(Log.e(TAG, ""Class not found when unmarshalling: "" + name + "", e: "" + e), [VariableReference(Log, []), Expression(TAG, []), Expression(""Class not found when unmarshalling: "" + name + "", []), Expression(e: "" + e, [])]), Statement(throw new BadParcelableException(""ClassNotFoundException when unmarshalling: "" + name), []), Statement(} catch (ClassCastException e) {, []), Statement(} catch (NoSuchFieldException e) {, []), Statement(}, []), AssignmentExpression(=, [VariableReference(if (creator, []), Expression(, [])]), Statement(}, []), MethodCall(map.put(name, creator), [VariableReference(map, []), Expression(name, []), Expression(creator, [])]), Statement(}, []), Statement(}, []), Statement(}, []), MethodCall(return creator.createFromParcel(this), [VariableReference(return creator, []), Expression(this, [])]), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(String name, []), Expression(readString(), [])])    VariableReference(String name, [])    Expression(readString(), [])  AssignmentExpression(=, [VariableReference(if (name, []), Expression(, [])])    VariableReference(if (name, [])    Expression(, [])  Statement(return null, [])  Statement(}, [])  Statement(Parcelable.Creator<T> creator, [])  Statement(synchronized (mCreators) {, [])  AssignmentExpression(=, [VariableReference(HashMap<String, Parcelable.Creator> map, []), Expression(mCreators.get(loader), [])])    VariableReference(HashMap<String, Parcelable.Creator> map, [])    Expression(mCreators.get(loader), [])  AssignmentExpression(=, [VariableReference(if (map, []), Expression(, [])])    VariableReference(if (map, [])    Expression(, [])  AssignmentExpression(=, [VariableReference(map, []), Expression(new HashMap<String, Parcelable.Creator>(), [])])    VariableReference(map, [])    Expression(new HashMap<String, Parcelable.Creator>(), [])  MethodCall(mCreators.put(loader, map), [VariableReference(mCreators, []), Expression(loader, []), Expression(map, [])])    VariableReference(mCreators, [])    Expression(loader, [])    Expression(map, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(creator, []), Expression(map.get(name), [])])    VariableReference(creator, [])    Expression(map.get(name), [])  AssignmentExpression(=, [VariableReference(if (creator, []), Expression(, [])])    VariableReference(if (creator, [])    Expression(, [])  Statement(try {, [])  AssignmentExpression(=, [VariableReference(Class c, []), Expression(loader, [])])    VariableReference(Class c, [])    Expression(loader, [])  AssignmentExpression(=, [VariableReference(Field f, []), Expression(c.getField(""CREATOR""), [])])    VariableReference(Field f, [])    Expression(c.getField(""CREATOR""), [])  AssignmentExpression(=, [VariableReference(creator, []), Expression((Parcelable.Creator) f.get(null), [])])    VariableReference(creator, [])    Expression((Parcelable.Creator) f.get(null), [])  Statement(} catch (IllegalAccessException e) {, [])  MethodCall(Log.e(TAG, ""Class not found when unmarshalling: "" + name + "", e: "" + e), [VariableReference(Log, []), Expression(TAG, []), Expression(""Class not found when unmarshalling: "" + name + "", []), Expression(e: "" + e, [])])    VariableReference(Log, [])    Expression(TAG, [])    Expression(""Class not found when unmarshalling: "" + name + "", [])    Expression(e: "" + e, [])  Statement(throw new BadParcelableException(""IllegalAccessException when unmarshalling: "" + name), [])  Statement(} catch (ClassNotFoundException e) {, [])  MethodCall(Log.e(TAG, ""Class not found when unmarshalling: "" + name + "", e: "" + e), [VariableReference(Log, []), Expression(TAG, []), Expression(""Class not found when unmarshalling: "" + name + "", []), Expression(e: "" + e, [])])    VariableReference(Log, [])    Expression(TAG, [])    Expression(""Class not found when unmarshalling: "" + name + "", [])    Expression(e: "" + e, [])  Statement(throw new BadParcelableException(""ClassNotFoundException when unmarshalling: "" + name), [])  Statement(} catch (ClassCastException e) {, [])  Statement(} catch (NoSuchFieldException e) {, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(if (creator, []), Expression(, [])])    VariableReference(if (creator, [])    Expression(, [])  Statement(}, [])  MethodCall(map.put(name, creator), [VariableReference(map, []), Expression(name, []), Expression(creator, [])])    VariableReference(map, [])    Expression(name, [])    Expression(creator, [])  Statement(}, [])  Statement(}, [])  Statement(}, [])  MethodCall(return creator.createFromParcel(this), [VariableReference(return creator, []), Expression(this, [])])    VariableReference(return creator, [])    Expression(this, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(Parcelable.Creator<T> creator, []), Expression(readParcelableCreator(loader), [])]), AssignmentExpression(=, [VariableReference(if (creator, []), Expression(, [])]), Statement(return null, []), Statement(}, []), Statement(}, []), MethodCall(return creator.createFromParcel(this), [VariableReference(return creator, []), Expression(this, [])]), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(Parcelable.Creator<T> creator, []), Expression(readParcelableCreator(loader), [])])    VariableReference(Parcelable.Creator<T> creator, [])    Expression(readParcelableCreator(loader), [])  AssignmentExpression(=, [VariableReference(if (creator, []), Expression(, [])])    VariableReference(if (creator, [])    Expression(, [])  Statement(return null, [])  Statement(}, [])  Statement(}, [])  MethodCall(return creator.createFromParcel(this), [VariableReference(return creator, []), Expression(this, [])])    VariableReference(return creator, [])    Expression(this, [])  Statement(}, [])",1,"/**
 * Read and return a new Parcelable from the parcel.  The given class loader
 * will be used to load any enclosed Parcelables.  If it is null, the default
 * class loader will be used.
 * @param loader A ClassLoader from which to instantiate the Parcelable
 * object, or null for the default class loader.
 * @return Returns the newly created Parcelable, or null if a null
 * object has been written.
 * @throws BadParcelableException Throws BadParcelableException if there
 * was an error trying to instantiate the Parcelable.
 */
","/**
 * Read and return a new Parcelable from the parcel.  The given class loader
 * will be used to load any enclosed Parcelables.  If it is null, the default
 * class loader will be used.
 * @param loader A ClassLoader from which to instantiate the Parcelable
 * object, or null for the default class loader.
 * @return Returns the newly created Parcelable, or null if a null
 * object has been written.
 * @throws BadParcelableException Throws BadParcelableException if there
 * was an error trying to instantiate the Parcelable.
 */
",0,,,0,0,0,0,1,"2,3,4",2,"4,5",1,"There are major changes in the method implementations between the early and late version. In the late version, the previous statements (related to map handling, exception handlings, etc.) have all been replaced by call of another method readParcelableCreator(loader), so the code change type is 4,5.",The return statement partially relies on the logic within the called internal method readParcelableCreator(). This change could cause the potential returned value to be different. Therefore the CI type is 1.
89,<android.widget.TextView: void onRtlPropertiesChanged(int)>,19,20,<android.widget.TextView: void onRtlPropertiesChanged(int)>,<android.widget.TextView: void onRtlPropertiesChanged(int)>,0,"MethodDeclaration(method_body, [Statement({, []), MethodCall(super.onRtlPropertiesChanged(layoutDirection), [VariableReference(super, []), Expression(layoutDirection, [])]), AssignmentExpression(=, [VariableReference(mTextDir, []), Expression(getTextDirectionHeuristic(), [])]), Statement(}, [])])  Statement({, [])  MethodCall(super.onRtlPropertiesChanged(layoutDirection), [VariableReference(super, []), Expression(layoutDirection, [])])    VariableReference(super, [])    Expression(layoutDirection, [])  AssignmentExpression(=, [VariableReference(mTextDir, []), Expression(getTextDirectionHeuristic(), [])])    VariableReference(mTextDir, [])    Expression(getTextDirectionHeuristic(), [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), MethodCall(super.onRtlPropertiesChanged(layoutDirection), [VariableReference(super, []), Expression(layoutDirection, [])]), AssignmentExpression(=, [VariableReference(mTextDir, []), Expression(getTextDirectionHeuristic(), [])]), AssignmentExpression(=, [VariableReference(if (mLayout !, []), Expression(null) {, [])]), Statement(checkForRelayout(), []), Statement(}, []), Statement(}, [])])  Statement({, [])  MethodCall(super.onRtlPropertiesChanged(layoutDirection), [VariableReference(super, []), Expression(layoutDirection, [])])    VariableReference(super, [])    Expression(layoutDirection, [])  AssignmentExpression(=, [VariableReference(mTextDir, []), Expression(getTextDirectionHeuristic(), [])])    VariableReference(mTextDir, [])    Expression(getTextDirectionHeuristic(), [])  AssignmentExpression(=, [VariableReference(if (mLayout !, []), Expression(null) {, [])])    VariableReference(if (mLayout !, [])    Expression(null) {, [])  Statement(checkForRelayout(), [])  Statement(}, [])  Statement(}, [])",1,,,-1,[@Override],[@Override],0,0,0,0,1,3,0,4,1,"There are two additional statements in the late version which are 'if (mLayout != null) {' and 'checkForRelayout()', so the code change type is 4.","The introduction of additional 'if (mLayout != null) {' and 'checkForRelayout()' statements may change the execution flow of the method potentially leading to different behavior of the API. Therefore, the type of CI is 1."
97,"<android.app.AlertDialog: void setButton3(CharSequence,Message)>",19,20,"<android.app.AlertDialog: void setButton3(CharSequence,Message)>","<android.app.AlertDialog: void setButton3(CharSequence,OnClickListener)>",0,"MethodDeclaration(method_body, [Statement({, []), Statement(setButton(BUTTON_NEUTRAL, text, msg), []), Statement(}, [])])  Statement({, [])  Statement(setButton(BUTTON_NEUTRAL, text, msg), [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(setButton(BUTTON_NEUTRAL, text, listener), []), Statement(}, [])])  Statement({, [])  Statement(setButton(BUTTON_NEUTRAL, text, listener), [])  Statement(}, [])",1,"/**
 * @deprecated Use {@link #setButton(int, CharSequence, Message)} with
 * {@link DialogInterface#BUTTON_NEUTRAL}.
 */
","/**
 * Set a listener to be invoked when button 3 of the dialog is pressed.
 * @param text The text to display in button 3.
 * @param listener The {@link DialogInterface.OnClickListener} to use.
 * @deprecated Use
 * {@link #setButton(int, CharSequence, android.content.DialogInterface.OnClickListener)}
 * with {@link DialogInterface#BUTTON_POSITIVE}
 */
",1,[@Deprecated],[@Deprecated],0,0,0,0,1,5,0,"1,5",1,"The parameter of the method setButton() has changed from 'msg' to 'listener', so the code change type is 1,5 (Return statement changed & Dependent API changed).","As the invocation setButton() has changed to a new function, it potentially creates Compatibility Issues for those programs that depend on the original version by returning different results or triggering different side effects. Thus, the CI type is 1 (Compatibility Issue caused by potential different return values or types)."
98,<android.speech.tts.TextToSpeech: Set<String> getFeatures(Locale)>,19,20,<android.speech.tts.TextToSpeech: Set<String> getFeatures(Locale)>,<android.speech.tts.TextToSpeech: Set<String> getFeatures(Locale)>,0,"MethodDeclaration(method_body, [Statement({, []), Statement(return runAction(new Action<Set<String>>() {, []), Statement(@Override, []), Statement(public Set<String> run(ITextToSpeechService service) throws RemoteException {, []), AssignmentExpression(=, [VariableReference(String[] features, []), Expression(service.getFeaturesForLanguage(locale.getISO3Language(), locale.getISO3Country(), locale.getVariant()), [])]), AssignmentExpression(=, [VariableReference(if (features !, []), Expression(null) {, [])]), AssignmentExpression(=, [VariableReference(final Set<String> featureSet, []), Expression(new HashSet<String>(), [])]), MethodCall(Collections.addAll(featureSet, features), [VariableReference(Collections, []), Expression(featureSet, []), Expression(features, [])]), Statement(return featureSet, []), Statement(}, []), Statement(return null, []), Statement(}, []), Statement(}, null, ""getFeatures""), []), Statement(}, [])])  Statement({, [])  Statement(return runAction(new Action<Set<String>>() {, [])  Statement(@Override, [])  Statement(public Set<String> run(ITextToSpeechService service) throws RemoteException {, [])  AssignmentExpression(=, [VariableReference(String[] features, []), Expression(service.getFeaturesForLanguage(locale.getISO3Language(), locale.getISO3Country(), locale.getVariant()), [])])    VariableReference(String[] features, [])    Expression(service.getFeaturesForLanguage(locale.getISO3Language(), locale.getISO3Country(), locale.getVariant()), [])  AssignmentExpression(=, [VariableReference(if (features !, []), Expression(null) {, [])])    VariableReference(if (features !, [])    Expression(null) {, [])  AssignmentExpression(=, [VariableReference(final Set<String> featureSet, []), Expression(new HashSet<String>(), [])])    VariableReference(final Set<String> featureSet, [])    Expression(new HashSet<String>(), [])  MethodCall(Collections.addAll(featureSet, features), [VariableReference(Collections, []), Expression(featureSet, []), Expression(features, [])])    VariableReference(Collections, [])    Expression(featureSet, [])    Expression(features, [])  Statement(return featureSet, [])  Statement(}, [])  Statement(return null, [])  Statement(}, [])  Statement(}, null, ""getFeatures""), [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(return runAction(new Action<Set<String>>() {, []), Statement(@Override, []), Statement(public Set<String> run(ITextToSpeechService service) throws RemoteException {, []), AssignmentExpression(=, [VariableReference(String[] features, []), Expression(null, [])]), Statement(try {, []), AssignmentExpression(=, [VariableReference(features, []), Expression(service.getFeaturesForLanguage(locale.getISO3Language(), locale.getISO3Country(), locale.getVariant()), [])]), Statement(} catch (MissingResourceException e) {, []), MethodCall(Log.w(TAG, ""Couldn't retrieve 3 letter ISO 639-2/T language and/or ISO 3166 "" + ""country code for locale: "" + locale, e), [VariableReference(Log, []), Expression(TAG, []), Expression(""Couldn't retrieve 3 letter ISO 639-2/T language and/or ISO 3166 "" + ""country code for locale: "" + locale, []), Expression(e, [])]), Statement(return null, []), Statement(}, []), AssignmentExpression(=, [VariableReference(if (features !, []), Expression(null) {, [])]), AssignmentExpression(=, [VariableReference(final Set<String> featureSet, []), Expression(new HashSet<String>(), [])]), MethodCall(Collections.addAll(featureSet, features), [VariableReference(Collections, []), Expression(featureSet, []), Expression(features, [])]), Statement(return featureSet, []), Statement(}, []), Statement(return null, []), Statement(}, []), Statement(}, null, ""getFeatures""), []), Statement(}, [])])  Statement({, [])  Statement(return runAction(new Action<Set<String>>() {, [])  Statement(@Override, [])  Statement(public Set<String> run(ITextToSpeechService service) throws RemoteException {, [])  AssignmentExpression(=, [VariableReference(String[] features, []), Expression(null, [])])    VariableReference(String[] features, [])    Expression(null, [])  Statement(try {, [])  AssignmentExpression(=, [VariableReference(features, []), Expression(service.getFeaturesForLanguage(locale.getISO3Language(), locale.getISO3Country(), locale.getVariant()), [])])    VariableReference(features, [])    Expression(service.getFeaturesForLanguage(locale.getISO3Language(), locale.getISO3Country(), locale.getVariant()), [])  Statement(} catch (MissingResourceException e) {, [])  MethodCall(Log.w(TAG, ""Couldn't retrieve 3 letter ISO 639-2/T language and/or ISO 3166 "" + ""country code for locale: "" + locale, e), [VariableReference(Log, []), Expression(TAG, []), Expression(""Couldn't retrieve 3 letter ISO 639-2/T language and/or ISO 3166 "" + ""country code for locale: "" + locale, []), Expression(e, [])])    VariableReference(Log, [])    Expression(TAG, [])    Expression(""Couldn't retrieve 3 letter ISO 639-2/T language and/or ISO 3166 "" + ""country code for locale: "" + locale, [])    Expression(e, [])  Statement(return null, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(if (features !, []), Expression(null) {, [])])    VariableReference(if (features !, [])    Expression(null) {, [])  AssignmentExpression(=, [VariableReference(final Set<String> featureSet, []), Expression(new HashSet<String>(), [])])    VariableReference(final Set<String> featureSet, [])    Expression(new HashSet<String>(), [])  MethodCall(Collections.addAll(featureSet, features), [VariableReference(Collections, []), Expression(featureSet, []), Expression(features, [])])    VariableReference(Collections, [])    Expression(featureSet, [])    Expression(features, [])  Statement(return featureSet, [])  Statement(}, [])  Statement(return null, [])  Statement(}, [])  Statement(}, null, ""getFeatures""), [])  Statement(}, [])",1,"/**
 * Queries the engine for the set of features it supports for a given locale.
 * Features can either be framework defined, e.g.
 * {@link TextToSpeech.Engine#KEY_FEATURE_NETWORK_SYNTHESIS} or engine specific.
 * Engine specific keys must be prefixed by the name of the engine they
 * are intended for. These keys can be used as parameters to
 * {@link TextToSpeech#speak(String, int, java.util.HashMap)} and
 * {@link TextToSpeech#synthesizeToFile(String, java.util.HashMap, String)}.
 *
 * Features are boolean flags, and their values in the synthesis parameters
 * must be behave as per {@link Boolean#parseBoolean(String)}.
 *
 * @param locale The locale to query features for.
 */
","/**
 * Queries the engine for the set of features it supports for a given locale.
 * Features can either be framework defined, e.g.
 * {@link TextToSpeech.Engine#KEY_FEATURE_NETWORK_SYNTHESIS} or engine specific.
 * Engine specific keys must be prefixed by the name of the engine they
 * are intended for. These keys can be used as parameters to
 * {@link TextToSpeech#speak(String, int, java.util.HashMap)} and
 * {@link TextToSpeech#synthesizeToFile(String, java.util.HashMap, String)}.
 *
 * Features are boolean flags, and their values in the synthesis parameters
 * must be behave as per {@link Boolean#parseBoolean(String)}.
 *
 * @param locale The locale to query features for.
 */
",1,,,0,0,0,0,1,"1,2,4","1,2","2,3","1,2","Exception handling has been introduced (catching MissingResourceException) and the return statement inside exception block. Also, the assignment of 'features' which was previously direct assignation from service.getFeaturesForLanguage() is now wrapped inside a try-catch block. That makes the change type to be 2,3.","The introduced exception statement will make the API potentially throw a new exception. Also, due to the exception handling addition, the API possibly now returns a different value ('null' in case of an exception) which wasn't considered in the previous version. Hence, the CI type is 1,2."
100,"<android.app.ActivityThread.ApplicationThread: void dumpProvider(FileDescriptor,IBinder,String[])>",19,20,"<android.app.ActivityThread.ApplicationThread: void dumpProvider(FileDescriptor,IBinder,String[])>","<android.app.ActivityThread.ApplicationThread: void dumpProvider(FileDescriptor,IBinder,String[])>",0,"MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(DumpComponentInfo data, []), Expression(new DumpComponentInfo(), [])]), Statement(try {, []), AssignmentExpression(=, [VariableReference(data.fd, []), Expression(ParcelFileDescriptor.dup(fd), [])]), AssignmentExpression(=, [VariableReference(data.token, []), Expression(providertoken, [])]), AssignmentExpression(=, [VariableReference(data.args, []), Expression(args, [])]), Statement(} catch (IOException e) {, []), MethodCall(Slog.w(TAG, ""dumpProvider failed"", e), [VariableReference(Slog, []), Expression(TAG, []), Expression(""dumpProvider failed"", []), Expression(e, [])]), Statement(}, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(DumpComponentInfo data, []), Expression(new DumpComponentInfo(), [])])    VariableReference(DumpComponentInfo data, [])    Expression(new DumpComponentInfo(), [])  Statement(try {, [])  AssignmentExpression(=, [VariableReference(data.fd, []), Expression(ParcelFileDescriptor.dup(fd), [])])    VariableReference(data.fd, [])    Expression(ParcelFileDescriptor.dup(fd), [])  AssignmentExpression(=, [VariableReference(data.token, []), Expression(providertoken, [])])    VariableReference(data.token, [])    Expression(providertoken, [])  AssignmentExpression(=, [VariableReference(data.args, []), Expression(args, [])])    VariableReference(data.args, [])    Expression(args, [])  Statement(} catch (IOException e) {, [])  MethodCall(Slog.w(TAG, ""dumpProvider failed"", e), [VariableReference(Slog, []), Expression(TAG, []), Expression(""dumpProvider failed"", []), Expression(e, [])])    VariableReference(Slog, [])    Expression(TAG, [])    Expression(""dumpProvider failed"", [])    Expression(e, [])  Statement(}, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(DumpComponentInfo data, []), Expression(new DumpComponentInfo(), [])]), Statement(try {, []), AssignmentExpression(=, [VariableReference(data.fd, []), Expression(ParcelFileDescriptor.dup(fd), [])]), AssignmentExpression(=, [VariableReference(data.token, []), Expression(providertoken, [])]), AssignmentExpression(=, [VariableReference(data.args, []), Expression(args, [])]), Statement(} catch (IOException e) {, []), MethodCall(Slog.w(TAG, ""dumpProvider failed"", e), [VariableReference(Slog, []), Expression(TAG, []), Expression(""dumpProvider failed"", []), Expression(e, [])]), Statement(}, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(DumpComponentInfo data, []), Expression(new DumpComponentInfo(), [])])    VariableReference(DumpComponentInfo data, [])    Expression(new DumpComponentInfo(), [])  Statement(try {, [])  AssignmentExpression(=, [VariableReference(data.fd, []), Expression(ParcelFileDescriptor.dup(fd), [])])    VariableReference(data.fd, [])    Expression(ParcelFileDescriptor.dup(fd), [])  AssignmentExpression(=, [VariableReference(data.token, []), Expression(providertoken, [])])    VariableReference(data.token, [])    Expression(providertoken, [])  AssignmentExpression(=, [VariableReference(data.args, []), Expression(args, [])])    VariableReference(data.args, [])    Expression(args, [])  Statement(} catch (IOException e) {, [])  MethodCall(Slog.w(TAG, ""dumpProvider failed"", e), [VariableReference(Slog, []), Expression(TAG, []), Expression(""dumpProvider failed"", []), Expression(e, [])])    VariableReference(Slog, [])    Expression(TAG, [])    Expression(""dumpProvider failed"", [])    Expression(e, [])  Statement(}, [])  Statement(}, [])",1,,,0,,,0,0,0,0,1,4,0,0,0,No changes have been made to the code between the early version and the late version.,"Since no changes have been made, there is no Compatibility Issue in this API."
101,<android.widget.PopupWindow.PopupDecorView: void requestEnterTransition(Transition)>,23,24,<android.widget.PopupWindow.PopupDecorView: void requestEnterTransition(Transition)>,<android.widget.PopupWindow.PopupDecorView: void requestEnterTransition(Transition)>,0,"MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(final ViewTreeObserver observer, []), Expression(getViewTreeObserver(), [])]), AssignmentExpression(=, [VariableReference(if (observer !, []), Expression(null && transition !, [])]), AssignmentExpression(=, [VariableReference(final Transition enterTransition, []), Expression(transition.clone(), [])]), Statement(// Postpone the enter transition after the first layout pass., []), MethodCall(observer.addOnGlobalLayoutListener(new OnGlobalLayoutListener(), [VariableReference(observer, []), Expression(new OnGlobalLayoutListener(, [])]), Statement(@Override, []), Statement(public void onGlobalLayout() {, []), AssignmentExpression(=, [VariableReference(final ViewTreeObserver observer, []), Expression(getViewTreeObserver(), [])]), AssignmentExpression(=, [VariableReference(if (observer !, []), Expression(null) {, [])]), MethodCall(observer.removeOnGlobalLayoutListener(this), [VariableReference(observer, []), Expression(this, [])]), Statement(}, []), AssignmentExpression(=, [VariableReference(final Rect epicenter, []), Expression(getRelativeAnchorBounds(), [])]), MethodCall(enterTransition.setEpicenterCallback(new EpicenterCallback(), [VariableReference(enterTransition, []), Expression(new EpicenterCallback(, [])]), Statement(@Override, []), Statement(public Rect onGetEpicenter(Transition transition) {, []), Statement(return epicenter, []), Statement(}, []), Statement(}), []), Statement(startEnterTransition(enterTransition), []), Statement(}, []), Statement(}), []), Statement(}, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(final ViewTreeObserver observer, []), Expression(getViewTreeObserver(), [])])    VariableReference(final ViewTreeObserver observer, [])    Expression(getViewTreeObserver(), [])  AssignmentExpression(=, [VariableReference(if (observer !, []), Expression(null && transition !, [])])    VariableReference(if (observer !, [])    Expression(null && transition !, [])  AssignmentExpression(=, [VariableReference(final Transition enterTransition, []), Expression(transition.clone(), [])])    VariableReference(final Transition enterTransition, [])    Expression(transition.clone(), [])  Statement(// Postpone the enter transition after the first layout pass., [])  MethodCall(observer.addOnGlobalLayoutListener(new OnGlobalLayoutListener(), [VariableReference(observer, []), Expression(new OnGlobalLayoutListener(, [])])    VariableReference(observer, [])    Expression(new OnGlobalLayoutListener(, [])  Statement(@Override, [])  Statement(public void onGlobalLayout() {, [])  AssignmentExpression(=, [VariableReference(final ViewTreeObserver observer, []), Expression(getViewTreeObserver(), [])])    VariableReference(final ViewTreeObserver observer, [])    Expression(getViewTreeObserver(), [])  AssignmentExpression(=, [VariableReference(if (observer !, []), Expression(null) {, [])])    VariableReference(if (observer !, [])    Expression(null) {, [])  MethodCall(observer.removeOnGlobalLayoutListener(this), [VariableReference(observer, []), Expression(this, [])])    VariableReference(observer, [])    Expression(this, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(final Rect epicenter, []), Expression(getRelativeAnchorBounds(), [])])    VariableReference(final Rect epicenter, [])    Expression(getRelativeAnchorBounds(), [])  MethodCall(enterTransition.setEpicenterCallback(new EpicenterCallback(), [VariableReference(enterTransition, []), Expression(new EpicenterCallback(, [])])    VariableReference(enterTransition, [])    Expression(new EpicenterCallback(, [])  Statement(@Override, [])  Statement(public Rect onGetEpicenter(Transition transition) {, [])  Statement(return epicenter, [])  Statement(}, [])  Statement(}), [])  Statement(startEnterTransition(enterTransition), [])  Statement(}, [])  Statement(}), [])  Statement(}, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(final ViewTreeObserver observer, []), Expression(getViewTreeObserver(), [])]), AssignmentExpression(=, [VariableReference(if (observer !, []), Expression(null && transition !, [])]), AssignmentExpression(=, [VariableReference(final Transition enterTransition, []), Expression(transition.clone(), [])]), Statement(// Postpone the enter transition after the first layout pass., []), MethodCall(observer.addOnGlobalLayoutListener(new OnGlobalLayoutListener(), [VariableReference(observer, []), Expression(new OnGlobalLayoutListener(, [])]), Statement(@Override, []), Statement(public void onGlobalLayout() {, []), AssignmentExpression(=, [VariableReference(final ViewTreeObserver observer, []), Expression(getViewTreeObserver(), [])]), AssignmentExpression(=, [VariableReference(if (observer !, []), Expression(null) {, [])]), MethodCall(observer.removeOnGlobalLayoutListener(this), [VariableReference(observer, []), Expression(this, [])]), Statement(}, []), AssignmentExpression(=, [VariableReference(final Rect epicenter, []), Expression(getTransitionEpicenter(), [])]), MethodCall(enterTransition.setEpicenterCallback(new EpicenterCallback(), [VariableReference(enterTransition, []), Expression(new EpicenterCallback(, [])]), Statement(@Override, []), Statement(public Rect onGetEpicenter(Transition transition) {, []), Statement(return epicenter, []), Statement(}, []), Statement(}), []), Statement(startEnterTransition(enterTransition), []), Statement(}, []), Statement(}), []), Statement(}, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(final ViewTreeObserver observer, []), Expression(getViewTreeObserver(), [])])    VariableReference(final ViewTreeObserver observer, [])    Expression(getViewTreeObserver(), [])  AssignmentExpression(=, [VariableReference(if (observer !, []), Expression(null && transition !, [])])    VariableReference(if (observer !, [])    Expression(null && transition !, [])  AssignmentExpression(=, [VariableReference(final Transition enterTransition, []), Expression(transition.clone(), [])])    VariableReference(final Transition enterTransition, [])    Expression(transition.clone(), [])  Statement(// Postpone the enter transition after the first layout pass., [])  MethodCall(observer.addOnGlobalLayoutListener(new OnGlobalLayoutListener(), [VariableReference(observer, []), Expression(new OnGlobalLayoutListener(, [])])    VariableReference(observer, [])    Expression(new OnGlobalLayoutListener(, [])  Statement(@Override, [])  Statement(public void onGlobalLayout() {, [])  AssignmentExpression(=, [VariableReference(final ViewTreeObserver observer, []), Expression(getViewTreeObserver(), [])])    VariableReference(final ViewTreeObserver observer, [])    Expression(getViewTreeObserver(), [])  AssignmentExpression(=, [VariableReference(if (observer !, []), Expression(null) {, [])])    VariableReference(if (observer !, [])    Expression(null) {, [])  MethodCall(observer.removeOnGlobalLayoutListener(this), [VariableReference(observer, []), Expression(this, [])])    VariableReference(observer, [])    Expression(this, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(final Rect epicenter, []), Expression(getTransitionEpicenter(), [])])    VariableReference(final Rect epicenter, [])    Expression(getTransitionEpicenter(), [])  MethodCall(enterTransition.setEpicenterCallback(new EpicenterCallback(), [VariableReference(enterTransition, []), Expression(new EpicenterCallback(, [])])    VariableReference(enterTransition, [])    Expression(new EpicenterCallback(, [])  Statement(@Override, [])  Statement(public Rect onGetEpicenter(Transition transition) {, [])  Statement(return epicenter, [])  Statement(}, [])  Statement(}), [])  Statement(startEnterTransition(enterTransition), [])  Statement(}, [])  Statement(}), [])  Statement(}, [])  Statement(}, [])",1,"/**
 * Requests that an enter transition run after the next layout pass.
 */","/**
 * Requests that an enter transition run after the next layout pass.
 */",0,,,0,,,,1,4,0,"1,5",1,"The expression in an assignment statement `getRelativeAnchorBounds()` is replaced by `getTransitionEpicenter()`, and the method used in the late implementation is different from the early version. This matches changes type 1,5.","Since the assignment statement in the API has changed, the transition epicenter might also change. This could end up causing different behavior when executing the API, thus leading to the potential return of different variables. Thus, the CI classification is 1."
102,<android.view.ViewRootImpl.ImeInputStage: int onProcess(QueuedInputEvent)>,23,24,<android.view.ViewRootImpl.ImeInputStage: int onProcess(QueuedInputEvent)>,<android.view.ViewRootImpl.ImeInputStage: int onProcess(QueuedInputEvent)>,0,"MethodDeclaration(method_body, [Statement({, []), Statement(if (mLastWasImTarget && !isInLocalFocusMode()) {, []), AssignmentExpression(=, [VariableReference(InputMethodManager imm, []), Expression(InputMethodManager.peekInstance(), [])]), AssignmentExpression(=, [VariableReference(if (imm !, []), Expression(null) {, [])]), AssignmentExpression(=, [VariableReference(final InputEvent event, []), Expression(q.mEvent, [])]), Statement(if (DEBUG_IMF), []), MethodCall(Log.v(TAG, ""Sending input event to IME: "" + event), [VariableReference(Log, []), Expression(TAG, []), Expression(""Sending input event to IME: "" + event, [])]), AssignmentExpression(=, [VariableReference(int result, []), Expression(imm.dispatchInputEvent(event, q, this, mHandler), [])]), AssignmentExpression(=, [VariableReference(if (result, []), Expression(, [])]), Statement(return FINISH_HANDLED, []), AssignmentExpression(=, [VariableReference(} else if (result, []), Expression(, [])]), Statement(// The IME could not handle it, so skip along to the next InputStage, []), Statement(return FORWARD, []), Statement(} else {, []), Statement(// callback will be invoked later, []), Statement(return DEFER, []), Statement(}, []), Statement(}, []), Statement(}, []), Statement(return FORWARD, []), Statement(}, [])])  Statement({, [])  Statement(if (mLastWasImTarget && !isInLocalFocusMode()) {, [])  AssignmentExpression(=, [VariableReference(InputMethodManager imm, []), Expression(InputMethodManager.peekInstance(), [])])    VariableReference(InputMethodManager imm, [])    Expression(InputMethodManager.peekInstance(), [])  AssignmentExpression(=, [VariableReference(if (imm !, []), Expression(null) {, [])])    VariableReference(if (imm !, [])    Expression(null) {, [])  AssignmentExpression(=, [VariableReference(final InputEvent event, []), Expression(q.mEvent, [])])    VariableReference(final InputEvent event, [])    Expression(q.mEvent, [])  Statement(if (DEBUG_IMF), [])  MethodCall(Log.v(TAG, ""Sending input event to IME: "" + event), [VariableReference(Log, []), Expression(TAG, []), Expression(""Sending input event to IME: "" + event, [])])    VariableReference(Log, [])    Expression(TAG, [])    Expression(""Sending input event to IME: "" + event, [])  AssignmentExpression(=, [VariableReference(int result, []), Expression(imm.dispatchInputEvent(event, q, this, mHandler), [])])    VariableReference(int result, [])    Expression(imm.dispatchInputEvent(event, q, this, mHandler), [])  AssignmentExpression(=, [VariableReference(if (result, []), Expression(, [])])    VariableReference(if (result, [])    Expression(, [])  Statement(return FINISH_HANDLED, [])  AssignmentExpression(=, [VariableReference(} else if (result, []), Expression(, [])])    VariableReference(} else if (result, [])    Expression(, [])  Statement(// The IME could not handle it, so skip along to the next InputStage, [])  Statement(return FORWARD, [])  Statement(} else {, [])  Statement(// callback will be invoked later, [])  Statement(return DEFER, [])  Statement(}, [])  Statement(}, [])  Statement(}, [])  Statement(return FORWARD, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(if (mLastWasImTarget && !isInLocalFocusMode()) {, []), AssignmentExpression(=, [VariableReference(InputMethodManager imm, []), Expression(InputMethodManager.peekInstance(), [])]), AssignmentExpression(=, [VariableReference(if (imm !, []), Expression(null) {, [])]), AssignmentExpression(=, [VariableReference(final InputEvent event, []), Expression(q.mEvent, [])]), Statement(if (DEBUG_IMF), []), MethodCall(Log.v(mTag, ""Sending input event to IME: "" + event), [VariableReference(Log, []), Expression(mTag, []), Expression(""Sending input event to IME: "" + event, [])]), AssignmentExpression(=, [VariableReference(int result, []), Expression(imm.dispatchInputEvent(event, q, this, mHandler), [])]), AssignmentExpression(=, [VariableReference(if (result, []), Expression(, [])]), Statement(return FINISH_HANDLED, []), AssignmentExpression(=, [VariableReference(} else if (result, []), Expression(, [])]), Statement(// The IME could not handle it, so skip along to the next InputStage, []), Statement(return FORWARD, []), Statement(} else {, []), Statement(// callback will be invoked later, []), Statement(return DEFER, []), Statement(}, []), Statement(}, []), Statement(}, []), Statement(return FORWARD, []), Statement(}, [])])  Statement({, [])  Statement(if (mLastWasImTarget && !isInLocalFocusMode()) {, [])  AssignmentExpression(=, [VariableReference(InputMethodManager imm, []), Expression(InputMethodManager.peekInstance(), [])])    VariableReference(InputMethodManager imm, [])    Expression(InputMethodManager.peekInstance(), [])  AssignmentExpression(=, [VariableReference(if (imm !, []), Expression(null) {, [])])    VariableReference(if (imm !, [])    Expression(null) {, [])  AssignmentExpression(=, [VariableReference(final InputEvent event, []), Expression(q.mEvent, [])])    VariableReference(final InputEvent event, [])    Expression(q.mEvent, [])  Statement(if (DEBUG_IMF), [])  MethodCall(Log.v(mTag, ""Sending input event to IME: "" + event), [VariableReference(Log, []), Expression(mTag, []), Expression(""Sending input event to IME: "" + event, [])])    VariableReference(Log, [])    Expression(mTag, [])    Expression(""Sending input event to IME: "" + event, [])  AssignmentExpression(=, [VariableReference(int result, []), Expression(imm.dispatchInputEvent(event, q, this, mHandler), [])])    VariableReference(int result, [])    Expression(imm.dispatchInputEvent(event, q, this, mHandler), [])  AssignmentExpression(=, [VariableReference(if (result, []), Expression(, [])])    VariableReference(if (result, [])    Expression(, [])  Statement(return FINISH_HANDLED, [])  AssignmentExpression(=, [VariableReference(} else if (result, []), Expression(, [])])    VariableReference(} else if (result, [])    Expression(, [])  Statement(// The IME could not handle it, so skip along to the next InputStage, [])  Statement(return FORWARD, [])  Statement(} else {, [])  Statement(// callback will be invoked later, [])  Statement(return DEFER, [])  Statement(}, [])  Statement(}, [])  Statement(}, [])  Statement(return FORWARD, [])  Statement(}, [])",1,,,0,[@Override],[@Override],0,,,,1,4,0,4,0,"Only the argument of Log.v() method has changed from TAG to mTag, so this is categorized as type 4 (other statement changed).","This change in the logging statement does not affect the method's behavior in terms of return types/values or exception handling. Therefore, there is no compatibility issue in this context. Hence, the CI type is 0."
104,"<android.view.View: void scheduleDrawable(Drawable,Runnable,long)>",23,24,"<android.view.View: void scheduleDrawable(Drawable,Runnable,long)>","<android.view.View: void scheduleDrawable(Drawable,Runnable,long)>",0,"MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(if (verifyDrawable(who) && what !, []), Expression(null) {, [])]), AssignmentExpression(=, [VariableReference(final long delay, []), Expression(when - SystemClock.uptimeMillis(), [])]), AssignmentExpression(=, [VariableReference(if (mAttachInfo !, []), Expression(null) {, [])]), Statement(} else {, []), MethodCall(ViewRootImpl.getRunQueue().postDelayed(what, delay), [VariableReference(ViewRootImpl, []), Expression().postDelayed(what, []), Expression(delay, [])]), Statement(}, []), Statement(}, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(if (verifyDrawable(who) && what !, []), Expression(null) {, [])])    VariableReference(if (verifyDrawable(who) && what !, [])    Expression(null) {, [])  AssignmentExpression(=, [VariableReference(final long delay, []), Expression(when - SystemClock.uptimeMillis(), [])])    VariableReference(final long delay, [])    Expression(when - SystemClock.uptimeMillis(), [])  AssignmentExpression(=, [VariableReference(if (mAttachInfo !, []), Expression(null) {, [])])    VariableReference(if (mAttachInfo !, [])    Expression(null) {, [])  Statement(} else {, [])  MethodCall(ViewRootImpl.getRunQueue().postDelayed(what, delay), [VariableReference(ViewRootImpl, []), Expression().postDelayed(what, []), Expression(delay, [])])    VariableReference(ViewRootImpl, [])    Expression().postDelayed(what, [])    Expression(delay, [])  Statement(}, [])  Statement(}, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(if (verifyDrawable(who) && what !, []), Expression(null) {, [])]), AssignmentExpression(=, [VariableReference(final long delay, []), Expression(when - SystemClock.uptimeMillis(), [])]), AssignmentExpression(=, [VariableReference(if (mAttachInfo !, []), Expression(null) {, [])]), Statement(} else {, []), Statement(// Postpone the runnable until we know, []), Statement(// on which thread it needs to run., []), MethodCall(getRunQueue().postDelayed(what, delay), [VariableReference(getRunQueue(), []), Expression(what, []), Expression(delay, [])]), Statement(}, []), Statement(}, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(if (verifyDrawable(who) && what !, []), Expression(null) {, [])])    VariableReference(if (verifyDrawable(who) && what !, [])    Expression(null) {, [])  AssignmentExpression(=, [VariableReference(final long delay, []), Expression(when - SystemClock.uptimeMillis(), [])])    VariableReference(final long delay, [])    Expression(when - SystemClock.uptimeMillis(), [])  AssignmentExpression(=, [VariableReference(if (mAttachInfo !, []), Expression(null) {, [])])    VariableReference(if (mAttachInfo !, [])    Expression(null) {, [])  Statement(} else {, [])  Statement(// Postpone the runnable until we know, [])  Statement(// on which thread it needs to run., [])  MethodCall(getRunQueue().postDelayed(what, delay), [VariableReference(getRunQueue(), []), Expression(what, []), Expression(delay, [])])    VariableReference(getRunQueue(), [])    Expression(what, [])    Expression(delay, [])  Statement(}, [])  Statement(}, [])  Statement(}, [])",1,"/**
 * Schedules an action on a drawable to occur at a specified time.
 *
 * @param who the recipient of the action
 * @param what the action to run on the drawable
 * @param when the time at which the action must occur. Uses the
 * {@link SystemClock#uptimeMillis} timebase.
 */","/**
 * Schedules an action on a drawable to occur at a specified time.
 *
 * @param who the recipient of the action
 * @param what the action to run on the drawable
 * @param when the time at which the action must occur. Uses the
 * {@link SystemClock#uptimeMillis} timebase.
 */",0,[@Override],[@Override],0,,,,1,3,0,"4,5",2,"The method call has changed from ""ViewRootImpl.getRunQueue().postDelayed(what, delay)"" to ""getRunQueue().postDelayed(what, delay)"", so the code change type is 4,5.","The method ""getRunQueue().postDelayed(what, delay)"" might be implemented differently and could potentially throw a different exception, so the CI type is 2."
105,"<android.widget.RemoteViewsAdapter.RemoteViewsFrameLayout: void onRemoteViewsLoaded(RemoteViews,OnClickHandler)>",23,24,"<android.widget.RemoteViewsAdapter.RemoteViewsFrameLayout: void onRemoteViewsLoaded(RemoteViews,OnClickHandler)>","<android.widget.RemoteViewsAdapter.RemoteViewsFrameLayout: void onRemoteViewsLoaded(RemoteViews,OnClickHandler)>",0,"MethodDeclaration(method_body, [Statement({, []), Statement(try {, []), Statement(// Remove all the children of this layout first, []), Statement(removeAllViews(), []), MethodCall(addView(view.apply(getContext(), this, handler)), [VariableReference(addView(view, []), Expression(getContext(), []), Expression(this, []), Expression(handler), [])]), Statement(} catch (Exception e) {, []), MethodCall(Log.e(TAG, ""Failed to apply RemoteViews.""), [VariableReference(Log, []), Expression(TAG, []), Expression(""Failed to apply RemoteViews."", [])]), Statement(}, []), Statement(}, [])])  Statement({, [])  Statement(try {, [])  Statement(// Remove all the children of this layout first, [])  Statement(removeAllViews(), [])  MethodCall(addView(view.apply(getContext(), this, handler)), [VariableReference(addView(view, []), Expression(getContext(), []), Expression(this, []), Expression(handler), [])])    VariableReference(addView(view, [])    Expression(getContext(), [])    Expression(this, [])    Expression(handler), [])  Statement(} catch (Exception e) {, [])  MethodCall(Log.e(TAG, ""Failed to apply RemoteViews.""), [VariableReference(Log, []), Expression(TAG, []), Expression(""Failed to apply RemoteViews."", [])])    VariableReference(Log, [])    Expression(TAG, [])    Expression(""Failed to apply RemoteViews."", [])  Statement(}, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(setOnClickHandler(handler), []), Statement(applyRemoteViews(view), []), Statement(}, [])])  Statement({, [])  Statement(setOnClickHandler(handler), [])  Statement(applyRemoteViews(view), [])  Statement(}, [])",1,"/**
 * Updates this RemoteViewsFrameLayout depending on the view that was loaded.
 * @param view the RemoteViews that was loaded. If null, the RemoteViews was not loaded
 * successfully.
 */","/**
 * Updates this RemoteViewsFrameLayout depending on the view that was loaded.
 * @param view the RemoteViews that was loaded. If null, the RemoteViews was not loaded
 * successfully.
 */",0,,,0,,,,1,"2,4",2,"1,3,4",1,"The early version removes all views and then adds a new one while the late version sets the onClickHandler and applies RemoteViews without any exception handling. A new method, setOnClickHandler(handler), is introduced and the addView(view.apply(getContext(), this, handler)) method call in the early version has been replaced by applyRemoteViews(view) in the late version. The control statement with a try-catch block was removed as well. Therefore, the change type is 1,3 and 4.","The behavior change due to the different method calls in the implementation and the absence of exception handling in the late version could potentially lead to the method returning different results. Hence, the CI type is 1."
107,<android.text.style.TtsSpan.DecimalBuilder: DecimalBuilder setIntegerPart(String)>,23,24,<android.text.style.TtsSpan.DecimalBuilder: DecimalBuilder setIntegerPart(String)>,<android.text.style.TtsSpan.DecimalBuilder: DecimalBuilder setIntegerPart(String)>,0,"MethodDeclaration(method_body, [Statement({, []), Statement(}, [])])  Statement({, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), MethodCall(return setIntegerPart(String.valueOf(integerPart)), [VariableReference(return setIntegerPart(String, []), Expression(integerPart), [])]), Statement(}, [])])  Statement({, [])  MethodCall(return setIntegerPart(String.valueOf(integerPart)), [VariableReference(return setIntegerPart(String, []), Expression(integerPart), [])])    VariableReference(return setIntegerPart(String, [])    Expression(integerPart), [])  Statement(}, [])",1,"/**
 * Sets the {@link #ARG_INTEGER_PART} argument.
 * @param integerPart A non-empty string of digits with an optional
 * leading + or -.
 * @return This instance.
 */","/**
 * Convenience method that converts the number to a String and sets it
 * to the value for {@link #ARG_INTEGER_PART}.
 * @param integerPart The integer part of the decimal.
 * @return This instance.
 */",1,,,0,,,,1,1,1,"1,4",1,"The early version method body is empty while the late version introduces a new method call return setIntegerPart(String.valueOf(integerPart)). This modification is categorized as a Return statement change and Other statement change, hence the code change type is 1,4.","The introduced statement in the late version potentially changes the return value of the method which would cause different behaviors when the API is invoked. Therefore, the Compatibility Issue (CI) type is 1."
109,"<android.accounts.AccountManager: void setAuthToken(Account,String,String)>",23,24,"<android.accounts.AccountManager: void setAuthToken(Account,String,String)>","<android.accounts.AccountManager: void setAuthToken(Account,String,String)>",0,"MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(if (account, []), Expression(, [])]), Statement(throw new IllegalArgumentException(""account is null""), []), AssignmentExpression(=, [VariableReference(if (authTokenType, []), Expression(, [])]), Statement(throw new IllegalArgumentException(""authTokenType is null""), []), Statement(try {, []), MethodCall(mService.setAuthToken(account, authTokenType, authToken), [VariableReference(mService, []), Expression(account, []), Expression(authTokenType, []), Expression(authToken, [])]), Statement(} catch (RemoteException e) {, []), Statement(// won't ever happen, []), Statement(throw new RuntimeException(e), []), Statement(}, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(if (account, []), Expression(, [])])    VariableReference(if (account, [])    Expression(, [])  Statement(throw new IllegalArgumentException(""account is null""), [])  AssignmentExpression(=, [VariableReference(if (authTokenType, []), Expression(, [])])    VariableReference(if (authTokenType, [])    Expression(, [])  Statement(throw new IllegalArgumentException(""authTokenType is null""), [])  Statement(try {, [])  MethodCall(mService.setAuthToken(account, authTokenType, authToken), [VariableReference(mService, []), Expression(account, []), Expression(authTokenType, []), Expression(authToken, [])])    VariableReference(mService, [])    Expression(account, [])    Expression(authTokenType, [])    Expression(authToken, [])  Statement(} catch (RemoteException e) {, [])  Statement(// won't ever happen, [])  Statement(throw new RuntimeException(e), [])  Statement(}, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(if (account, []), Expression(, [])]), Statement(throw new IllegalArgumentException(""account is null""), []), AssignmentExpression(=, [VariableReference(if (authTokenType, []), Expression(, [])]), Statement(throw new IllegalArgumentException(""authTokenType is null""), []), Statement(try {, []), MethodCall(mService.setAuthToken(account, authTokenType, authToken), [VariableReference(mService, []), Expression(account, []), Expression(authTokenType, []), Expression(authToken, [])]), Statement(} catch (RemoteException e) {, []), MethodCall(throw e.rethrowFromSystemServer(), [VariableReference(throw e, []), Expression(, [])]), Statement(}, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(if (account, []), Expression(, [])])    VariableReference(if (account, [])    Expression(, [])  Statement(throw new IllegalArgumentException(""account is null""), [])  AssignmentExpression(=, [VariableReference(if (authTokenType, []), Expression(, [])])    VariableReference(if (authTokenType, [])    Expression(, [])  Statement(throw new IllegalArgumentException(""authTokenType is null""), [])  Statement(try {, [])  MethodCall(mService.setAuthToken(account, authTokenType, authToken), [VariableReference(mService, []), Expression(account, []), Expression(authTokenType, []), Expression(authToken, [])])    VariableReference(mService, [])    Expression(account, [])    Expression(authTokenType, [])    Expression(authToken, [])  Statement(} catch (RemoteException e) {, [])  MethodCall(throw e.rethrowFromSystemServer(), [VariableReference(throw e, []), Expression(, [])])    VariableReference(throw e, [])    Expression(, [])  Statement(}, [])  Statement(}, [])",1,"/**
 * Adds an auth token to the AccountManager cache for an account.
 * If the account does not exist then this call has no effect.
 * Replaces any previous auth token for this account and auth token type.
 * Intended for use by the authenticator, not directly by applications.
 *
 * <p>It is safe to call this method from the main thread.
 *
 * <p>This method requires the caller to have a signature match with the
 * authenticator that manages the specified account.
 *
 * <p><b>NOTE:</b> If targeting your app to work on API level 22 and before,
 * AUTHENTICATE_ACCOUNTS permission and same UID as account's authenticator
 * is needed for those platforms. See docs for this function in API level 22.
 *
 * @param account The account to set an auth token for
 * @param authTokenType The type of the auth token, see {#getAuthToken}
 * @param authToken The auth token to add to the cache
 */","/**
 * Adds an auth token to the AccountManager cache for an account.
 * If the account does not exist then this call has no effect.
 * Replaces any previous auth token for this account and auth token type.
 * Intended for use by the authenticator, not directly by applications.
 *
 * <p>It is safe to call this method from the main thread.
 *
 * <p>This method requires the caller to have a signature match with the
 * authenticator that manages the specified account.
 *
 * <p><b>NOTE:</b> If targeting your app to work on API level 22 and before,
 * AUTHENTICATE_ACCOUNTS permission and same UID as account's authenticator
 * is needed for those platforms. See docs for this function in API level 22.
 *
 * @param account The account to set an auth token for
 * @param authTokenType The type of the auth token, see {#getAuthToken}
 * @param authToken The auth token to add to the cache
 */",0,,,0,,,,1,2,2,2,2,"The exception handling statement has changed from 'throw new RuntimeException(e)' to 'throw e.rethrowFromSystemServer()', so the code change type is 2.","Due to the change of exception handling statement, the API could potentially throw a different type of exception in the late version, so the CI type is 2."
115,<android.hardware.camera2.impl.CameraCaptureSessionImpl: void close()>,24,25,<android.hardware.camera2.impl.CameraCaptureSessionImpl: void close()>,<android.hardware.camera2.impl.CameraCaptureSessionImpl: void close()>,0,"MethodDeclaration(method_body, [Statement({, []), Statement(if (mClosed) {, []), Statement(if (DEBUG), []), MethodCall(Log.v(TAG, mIdString + ""close - reentering""), [VariableReference(Log, []), Expression(TAG, []), Expression(mIdString + ""close - reentering"", [])]), Statement(return, []), Statement(}, []), Statement(if (DEBUG), []), MethodCall(Log.v(TAG, mIdString + ""close - first time""), [VariableReference(Log, []), Expression(TAG, []), Expression(mIdString + ""close - first time"", [])]), AssignmentExpression(=, [VariableReference(mClosed, []), Expression(true, [])]), Statement(/*, []), Statement(* Flush out any repeating request. Since camera is closed, no new requests, []), Statement(* can be queued, and eventually the entire request queue will be drained., []), Statement(*, []), Statement(* If the camera device was already closed, short circuit and do nothing, []), Statement(since, []), Statement(* no more internal device callbacks will fire anyway., []), Statement(*, []), Statement(* Otherwise, once stopRepeating is done, wait for camera to idle, then unconfigure the, []), Statement(* camera. Once that's done, fire #onClosed., []), Statement(*/, []), Statement(try {, []), MethodCall(mDeviceImpl.stopRepeating(), [VariableReference(mDeviceImpl, []), Expression(, [])]), Statement(} catch (IllegalStateException e) {, []), Statement(// OK: Camera device may already be closed, nothing else to do, []), Statement(// TODO: Fire onClosed anytime we get the device onClosed or the ISE?, []), Statement(// or just suppress the ISE only and rely onClosed., []), Statement(// Also skip any of the draining work if this is already closed., []), Statement(// Short-circuit, []), Statement(queue callback immediately and return, []), MethodCall(mStateCallback.onClosed(this), [VariableReference(mStateCallback, []), Expression(this, [])]), Statement(return, []), Statement(} catch (CameraAccessException e) {, []), Statement(// OK: close does not throw checked exceptions., []), MethodCall(Log.e(TAG, mIdString + ""Exception while stopping repeating: "", e), [VariableReference(Log, []), Expression(TAG, []), Expression(mIdString + ""Exception while stopping repeating: "", []), Expression(e, [])]), Statement(// TODO: call onError instead of onClosed if this happens, []), Statement(}, []), Statement(// If no sequences are pending, fire #onClosed immediately, []), MethodCall(mSequenceDrainer.beginDrain(), [VariableReference(mSequenceDrainer, []), Expression(, [])]), Statement(}, [])])  Statement({, [])  Statement(if (mClosed) {, [])  Statement(if (DEBUG), [])  MethodCall(Log.v(TAG, mIdString + ""close - reentering""), [VariableReference(Log, []), Expression(TAG, []), Expression(mIdString + ""close - reentering"", [])])    VariableReference(Log, [])    Expression(TAG, [])    Expression(mIdString + ""close - reentering"", [])  Statement(return, [])  Statement(}, [])  Statement(if (DEBUG), [])  MethodCall(Log.v(TAG, mIdString + ""close - first time""), [VariableReference(Log, []), Expression(TAG, []), Expression(mIdString + ""close - first time"", [])])    VariableReference(Log, [])    Expression(TAG, [])    Expression(mIdString + ""close - first time"", [])  AssignmentExpression(=, [VariableReference(mClosed, []), Expression(true, [])])    VariableReference(mClosed, [])    Expression(true, [])  Statement(/*, [])  Statement(* Flush out any repeating request. Since camera is closed, no new requests, [])  Statement(* can be queued, and eventually the entire request queue will be drained., [])  Statement(*, [])  Statement(* If the camera device was already closed, short circuit and do nothing, [])  Statement(since, [])  Statement(* no more internal device callbacks will fire anyway., [])  Statement(*, [])  Statement(* Otherwise, once stopRepeating is done, wait for camera to idle, then unconfigure the, [])  Statement(* camera. Once that's done, fire #onClosed., [])  Statement(*/, [])  Statement(try {, [])  MethodCall(mDeviceImpl.stopRepeating(), [VariableReference(mDeviceImpl, []), Expression(, [])])    VariableReference(mDeviceImpl, [])    Expression(, [])  Statement(} catch (IllegalStateException e) {, [])  Statement(// OK: Camera device may already be closed, nothing else to do, [])  Statement(// TODO: Fire onClosed anytime we get the device onClosed or the ISE?, [])  Statement(// or just suppress the ISE only and rely onClosed., [])  Statement(// Also skip any of the draining work if this is already closed., [])  Statement(// Short-circuit, [])  Statement(queue callback immediately and return, [])  MethodCall(mStateCallback.onClosed(this), [VariableReference(mStateCallback, []), Expression(this, [])])    VariableReference(mStateCallback, [])    Expression(this, [])  Statement(return, [])  Statement(} catch (CameraAccessException e) {, [])  Statement(// OK: close does not throw checked exceptions., [])  MethodCall(Log.e(TAG, mIdString + ""Exception while stopping repeating: "", e), [VariableReference(Log, []), Expression(TAG, []), Expression(mIdString + ""Exception while stopping repeating: "", []), Expression(e, [])])    VariableReference(Log, [])    Expression(TAG, [])    Expression(mIdString + ""Exception while stopping repeating: "", [])    Expression(e, [])  Statement(// TODO: call onError instead of onClosed if this happens, [])  Statement(}, [])  Statement(// If no sequences are pending, fire #onClosed immediately, [])  MethodCall(mSequenceDrainer.beginDrain(), [VariableReference(mSequenceDrainer, []), Expression(, [])])    VariableReference(mSequenceDrainer, [])    Expression(, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(synchronized (this) {, []), Statement(if (mClosed) {, []), Statement(if (DEBUG), []), MethodCall(Log.v(TAG, mIdString + ""close - reentering""), [VariableReference(Log, []), Expression(TAG, []), Expression(mIdString + ""close - reentering"", [])]), Statement(return, []), Statement(}, []), Statement(if (DEBUG), []), MethodCall(Log.v(TAG, mIdString + ""close - first time""), [VariableReference(Log, []), Expression(TAG, []), Expression(mIdString + ""close - first time"", [])]), AssignmentExpression(=, [VariableReference(mClosed, []), Expression(true, [])]), Statement(}, []), Statement(synchronized (this) {, []), Statement(/*, []), Statement(* Flush out any repeating request. Since camera is closed, no new requests, []), Statement(* can be queued, and eventually the entire request queue will be drained., []), Statement(*, []), Statement(* If the camera device was already closed, short circuit and do nothing, []), Statement(since, []), Statement(* no more internal device callbacks will fire anyway., []), Statement(*, []), Statement(* Otherwise, once stopRepeating is done, wait for camera to idle, then unconfigure, []), Statement(* the camera. Once that's done, fire #onClosed., []), Statement(*/, []), Statement(try {, []), MethodCall(mDeviceImpl.stopRepeating(), [VariableReference(mDeviceImpl, []), Expression(, [])]), Statement(} catch (IllegalStateException e) {, []), Statement(// OK: Camera device may already be closed, nothing else to do, []), Statement(// TODO: Fire onClosed anytime we get the device onClosed or the ISE?, []), Statement(// or just suppress the ISE only and rely onClosed., []), Statement(// Also skip any of the draining work if this is already closed., []), Statement(// Short-circuit, []), Statement(queue callback immediately and return, []), MethodCall(mStateCallback.onClosed(this), [VariableReference(mStateCallback, []), Expression(this, [])]), Statement(return, []), Statement(} catch (CameraAccessException e) {, []), Statement(// OK: close does not throw checked exceptions., []), MethodCall(Log.e(TAG, mIdString + ""Exception while stopping repeating: "", e), [VariableReference(Log, []), Expression(TAG, []), Expression(mIdString + ""Exception while stopping repeating: "", []), Expression(e, [])]), Statement(// TODO: call onError instead of onClosed if this happens, []), Statement(}, []), Statement(}, []), Statement(}, []), Statement(synchronized (this) {, []), Statement(// If no sequences are pending, fire #onClosed immediately, []), MethodCall(mSequenceDrainer.beginDrain(), [VariableReference(mSequenceDrainer, []), Expression(, [])]), Statement(}, []), Statement(}, [])])  Statement({, [])  Statement(synchronized (this) {, [])  Statement(if (mClosed) {, [])  Statement(if (DEBUG), [])  MethodCall(Log.v(TAG, mIdString + ""close - reentering""), [VariableReference(Log, []), Expression(TAG, []), Expression(mIdString + ""close - reentering"", [])])    VariableReference(Log, [])    Expression(TAG, [])    Expression(mIdString + ""close - reentering"", [])  Statement(return, [])  Statement(}, [])  Statement(if (DEBUG), [])  MethodCall(Log.v(TAG, mIdString + ""close - first time""), [VariableReference(Log, []), Expression(TAG, []), Expression(mIdString + ""close - first time"", [])])    VariableReference(Log, [])    Expression(TAG, [])    Expression(mIdString + ""close - first time"", [])  AssignmentExpression(=, [VariableReference(mClosed, []), Expression(true, [])])    VariableReference(mClosed, [])    Expression(true, [])  Statement(}, [])  Statement(synchronized (this) {, [])  Statement(/*, [])  Statement(* Flush out any repeating request. Since camera is closed, no new requests, [])  Statement(* can be queued, and eventually the entire request queue will be drained., [])  Statement(*, [])  Statement(* If the camera device was already closed, short circuit and do nothing, [])  Statement(since, [])  Statement(* no more internal device callbacks will fire anyway., [])  Statement(*, [])  Statement(* Otherwise, once stopRepeating is done, wait for camera to idle, then unconfigure, [])  Statement(* the camera. Once that's done, fire #onClosed., [])  Statement(*/, [])  Statement(try {, [])  MethodCall(mDeviceImpl.stopRepeating(), [VariableReference(mDeviceImpl, []), Expression(, [])])    VariableReference(mDeviceImpl, [])    Expression(, [])  Statement(} catch (IllegalStateException e) {, [])  Statement(// OK: Camera device may already be closed, nothing else to do, [])  Statement(// TODO: Fire onClosed anytime we get the device onClosed or the ISE?, [])  Statement(// or just suppress the ISE only and rely onClosed., [])  Statement(// Also skip any of the draining work if this is already closed., [])  Statement(// Short-circuit, [])  Statement(queue callback immediately and return, [])  MethodCall(mStateCallback.onClosed(this), [VariableReference(mStateCallback, []), Expression(this, [])])    VariableReference(mStateCallback, [])    Expression(this, [])  Statement(return, [])  Statement(} catch (CameraAccessException e) {, [])  Statement(// OK: close does not throw checked exceptions., [])  MethodCall(Log.e(TAG, mIdString + ""Exception while stopping repeating: "", e), [VariableReference(Log, []), Expression(TAG, []), Expression(mIdString + ""Exception while stopping repeating: "", []), Expression(e, [])])    VariableReference(Log, [])    Expression(TAG, [])    Expression(mIdString + ""Exception while stopping repeating: "", [])    Expression(e, [])  Statement(// TODO: call onError instead of onClosed if this happens, [])  Statement(}, [])  Statement(}, [])  Statement(}, [])  Statement(synchronized (this) {, [])  Statement(// If no sequences are pending, fire #onClosed immediately, [])  MethodCall(mSequenceDrainer.beginDrain(), [VariableReference(mSequenceDrainer, []), Expression(, [])])    VariableReference(mSequenceDrainer, [])    Expression(, [])  Statement(}, [])  Statement(}, [])",1,,,0,[@Override],[@Override],0,,,,1,"1,3,4",1,3,0,"The change between versions is the addition of the 'synchronized' keyword to control flow statements. Hence, the change could be categorized as Control dependency changed (3).","However, the addition of 'synchronized' keyword is intended for thread safety rather than changing the behavior of the API. The return results and exceptions thrown are not changed due to this modification. Therefore, no Compatibility Issue (CI) exists here."
120,<android.app.usage.NetworkStats: void finalize()>,25,26,<android.app.usage.NetworkStats: void finalize()>,<android.app.usage.NetworkStats: void finalize()>,0,"MethodDeclaration(method_body, [Statement({, []), Statement(try {, []), AssignmentExpression(=, [VariableReference(if (mCloseGuard !, []), Expression(null) {, [])]), MethodCall(mCloseGuard.warnIfOpen(), [VariableReference(mCloseGuard, []), Expression(, [])]), Statement(}, []), Statement(close(), []), Statement(} finally {, []), MethodCall(super.finalize(), [VariableReference(super, []), Expression(, [])]), Statement(}, []), Statement(}, [])])  Statement({, [])  Statement(try {, [])  AssignmentExpression(=, [VariableReference(if (mCloseGuard !, []), Expression(null) {, [])])    VariableReference(if (mCloseGuard !, [])    Expression(null) {, [])  MethodCall(mCloseGuard.warnIfOpen(), [VariableReference(mCloseGuard, []), Expression(, [])])    VariableReference(mCloseGuard, [])    Expression(, [])  Statement(}, [])  Statement(close(), [])  Statement(} finally {, [])  MethodCall(super.finalize(), [VariableReference(super, []), Expression(, [])])    VariableReference(super, [])    Expression(, [])  Statement(}, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(try {, []), AssignmentExpression(=, [VariableReference(if (mCloseGuard !, []), Expression(null) {, [])]), MethodCall(mCloseGuard.warnIfOpen(), [VariableReference(mCloseGuard, []), Expression(, [])]), Statement(}, []), Statement(close(), []), Statement(} finally {, []), MethodCall(super.finalize(), [VariableReference(super, []), Expression(, [])]), Statement(}, []), Statement(}, [])])  Statement({, [])  Statement(try {, [])  AssignmentExpression(=, [VariableReference(if (mCloseGuard !, []), Expression(null) {, [])])    VariableReference(if (mCloseGuard !, [])    Expression(null) {, [])  MethodCall(mCloseGuard.warnIfOpen(), [VariableReference(mCloseGuard, []), Expression(, [])])    VariableReference(mCloseGuard, [])    Expression(, [])  Statement(}, [])  Statement(close(), [])  Statement(} finally {, [])  MethodCall(super.finalize(), [VariableReference(super, []), Expression(, [])])    VariableReference(super, [])    Expression(, [])  Statement(}, [])  Statement(}, [])",0,,,0,[@Override],[@Override],0,,,,0,0,0,0,0,No changes in the API implementation have been detected from the early version to the late version.,"No Compatibility Issues exist, as there are no changes in the API implementation between the two versions."
122,<android.widget.DatePickerCalendarDelegate: void onLocaleChanged(Locale)>,25,26,<android.widget.DatePickerCalendarDelegate: void onLocaleChanged(Locale)>,<android.widget.DatePickerCalendarDelegate: void onLocaleChanged(Locale)>,0,"MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(final TextView headerYear, []), Expression(mHeaderYear, [])]), AssignmentExpression(=, [VariableReference(if (headerYear, []), Expression(, [])]), Statement(// again later after everything has been set up., []), Statement(return, []), Statement(}, []), Statement(// Update the date formatter., []), AssignmentExpression(=, [VariableReference(final String datePattern, []), Expression(DateFormat.getBestDateTimePattern(locale, ""EMMMd""), [])]), AssignmentExpression(=, [VariableReference(mMonthDayFormat, []), Expression(new SimpleDateFormat(datePattern, locale), [])]), MethodCall(mMonthDayFormat.setContext(DisplayContext.CAPITALIZATION_FOR_STANDALONE), [VariableReference(mMonthDayFormat, []), Expression(DisplayContext.CAPITALIZATION_FOR_STANDALONE, [])]), AssignmentExpression(=, [VariableReference(mYearFormat, []), Expression(new SimpleDateFormat(""y"", locale), [])]), Statement(// Clear out the lazily-initialized accessibility event formatter., []), AssignmentExpression(=, [VariableReference(mAccessibilityEventFormat, []), Expression(null, [])]), Statement(// Update the header text., []), Statement(onCurrentDateChanged(false), []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(final TextView headerYear, []), Expression(mHeaderYear, [])])    VariableReference(final TextView headerYear, [])    Expression(mHeaderYear, [])  AssignmentExpression(=, [VariableReference(if (headerYear, []), Expression(, [])])    VariableReference(if (headerYear, [])    Expression(, [])  Statement(// again later after everything has been set up., [])  Statement(return, [])  Statement(}, [])  Statement(// Update the date formatter., [])  AssignmentExpression(=, [VariableReference(final String datePattern, []), Expression(DateFormat.getBestDateTimePattern(locale, ""EMMMd""), [])])    VariableReference(final String datePattern, [])    Expression(DateFormat.getBestDateTimePattern(locale, ""EMMMd""), [])  AssignmentExpression(=, [VariableReference(mMonthDayFormat, []), Expression(new SimpleDateFormat(datePattern, locale), [])])    VariableReference(mMonthDayFormat, [])    Expression(new SimpleDateFormat(datePattern, locale), [])  MethodCall(mMonthDayFormat.setContext(DisplayContext.CAPITALIZATION_FOR_STANDALONE), [VariableReference(mMonthDayFormat, []), Expression(DisplayContext.CAPITALIZATION_FOR_STANDALONE, [])])    VariableReference(mMonthDayFormat, [])    Expression(DisplayContext.CAPITALIZATION_FOR_STANDALONE, [])  AssignmentExpression(=, [VariableReference(mYearFormat, []), Expression(new SimpleDateFormat(""y"", locale), [])])    VariableReference(mYearFormat, [])    Expression(new SimpleDateFormat(""y"", locale), [])  Statement(// Clear out the lazily-initialized accessibility event formatter., [])  AssignmentExpression(=, [VariableReference(mAccessibilityEventFormat, []), Expression(null, [])])    VariableReference(mAccessibilityEventFormat, [])    Expression(null, [])  Statement(// Update the header text., [])  Statement(onCurrentDateChanged(false), [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(final TextView headerYear, []), Expression(mHeaderYear, [])]), AssignmentExpression(=, [VariableReference(if (headerYear, []), Expression(, [])]), Statement(// again later after everything has been set up., []), Statement(return, []), Statement(}, []), Statement(// Update the date formatter., []), AssignmentExpression(=, [VariableReference(final String datePattern, []), Expression(DateFormat.getBestDateTimePattern(locale, ""EMMMd""), [])]), AssignmentExpression(=, [VariableReference(mMonthDayFormat, []), Expression(new SimpleDateFormat(datePattern, locale), [])]), MethodCall(mMonthDayFormat.setContext(DisplayContext.CAPITALIZATION_FOR_STANDALONE), [VariableReference(mMonthDayFormat, []), Expression(DisplayContext.CAPITALIZATION_FOR_STANDALONE, [])]), AssignmentExpression(=, [VariableReference(mYearFormat, []), Expression(new SimpleDateFormat(""y"", locale), [])]), Statement(// Update the header text., []), Statement(onCurrentDateChanged(false), []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(final TextView headerYear, []), Expression(mHeaderYear, [])])    VariableReference(final TextView headerYear, [])    Expression(mHeaderYear, [])  AssignmentExpression(=, [VariableReference(if (headerYear, []), Expression(, [])])    VariableReference(if (headerYear, [])    Expression(, [])  Statement(// again later after everything has been set up., [])  Statement(return, [])  Statement(}, [])  Statement(// Update the date formatter., [])  AssignmentExpression(=, [VariableReference(final String datePattern, []), Expression(DateFormat.getBestDateTimePattern(locale, ""EMMMd""), [])])    VariableReference(final String datePattern, [])    Expression(DateFormat.getBestDateTimePattern(locale, ""EMMMd""), [])  AssignmentExpression(=, [VariableReference(mMonthDayFormat, []), Expression(new SimpleDateFormat(datePattern, locale), [])])    VariableReference(mMonthDayFormat, [])    Expression(new SimpleDateFormat(datePattern, locale), [])  MethodCall(mMonthDayFormat.setContext(DisplayContext.CAPITALIZATION_FOR_STANDALONE), [VariableReference(mMonthDayFormat, []), Expression(DisplayContext.CAPITALIZATION_FOR_STANDALONE, [])])    VariableReference(mMonthDayFormat, [])    Expression(DisplayContext.CAPITALIZATION_FOR_STANDALONE, [])  AssignmentExpression(=, [VariableReference(mYearFormat, []), Expression(new SimpleDateFormat(""y"", locale), [])])    VariableReference(mYearFormat, [])    Expression(new SimpleDateFormat(""y"", locale), [])  Statement(// Update the header text., [])  Statement(onCurrentDateChanged(false), [])  Statement(}, [])",1,,,0,[@Override],[@Override],0,,,,1,4,0,0,0,There is no change in implementation from the early version to the late version.,"Since there's no change in the code, there's no compatibility issue."
123,<android.view.ContextThemeWrapper: Theme getTheme()>,25,26,<android.view.ContextThemeWrapper: Theme getTheme()>,<android.view.ContextThemeWrapper: Theme getTheme()>,0,"MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(if (mTheme !, []), Expression(null) {, [])]), Statement(return mTheme, []), Statement(}, []), AssignmentExpression(=, [VariableReference(mThemeResource, []), Expression(Resources.selectDefaultTheme(mThemeResource, getApplicationInfo().targetSdkVersion), [])]), Statement(initializeTheme(), []), Statement(return mTheme, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(if (mTheme !, []), Expression(null) {, [])])    VariableReference(if (mTheme !, [])    Expression(null) {, [])  Statement(return mTheme, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(mThemeResource, []), Expression(Resources.selectDefaultTheme(mThemeResource, getApplicationInfo().targetSdkVersion), [])])    VariableReference(mThemeResource, [])    Expression(Resources.selectDefaultTheme(mThemeResource, getApplicationInfo().targetSdkVersion), [])  Statement(initializeTheme(), [])  Statement(return mTheme, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(if (mTheme !, []), Expression(null) {, [])]), Statement(return mTheme, []), Statement(}, []), AssignmentExpression(=, [VariableReference(mThemeResource, []), Expression(Resources.selectDefaultTheme(mThemeResource, getApplicationInfo().targetSdkVersion), [])]), Statement(initializeTheme(), []), Statement(return mTheme, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(if (mTheme !, []), Expression(null) {, [])])    VariableReference(if (mTheme !, [])    Expression(null) {, [])  Statement(return mTheme, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(mThemeResource, []), Expression(Resources.selectDefaultTheme(mThemeResource, getApplicationInfo().targetSdkVersion), [])])    VariableReference(mThemeResource, [])    Expression(Resources.selectDefaultTheme(mThemeResource, getApplicationInfo().targetSdkVersion), [])  Statement(initializeTheme(), [])  Statement(return mTheme, [])  Statement(}, [])",0,,,0,[@Override],[@Override],0,,,,0,0,0,0,0,"Considering both the early and the late implementation, there is no code change detected hence the code change type is 0.","Since there were no changes in the codebase, there are no compatibility issues thus the CI type is 0."
130,"<android.net.ConnectivityManager: void requestNetwork(NetworkRequest,PendingIntent)>",26,27,"<android.net.ConnectivityManager: void requestNetwork(NetworkRequest,PendingIntent)>","<android.net.ConnectivityManager: void requestNetwork(NetworkRequest,PendingIntent)>",0,"MethodDeclaration(method_body, [Statement({, []), Statement(checkPendingIntent(operation), []), Statement(try {, []), MethodCall(mService.pendingRequestForNetwork(request.networkCapabilities, operation), [VariableReference(mService, []), Expression(request.networkCapabilities, []), Expression(operation, [])]), Statement(} catch (RemoteException e) {, []), MethodCall(throw e.rethrowFromSystemServer(), [VariableReference(throw e, []), Expression(, [])]), Statement(}, []), Statement(}, [])])  Statement({, [])  Statement(checkPendingIntent(operation), [])  Statement(try {, [])  MethodCall(mService.pendingRequestForNetwork(request.networkCapabilities, operation), [VariableReference(mService, []), Expression(request.networkCapabilities, []), Expression(operation, [])])    VariableReference(mService, [])    Expression(request.networkCapabilities, [])    Expression(operation, [])  Statement(} catch (RemoteException e) {, [])  MethodCall(throw e.rethrowFromSystemServer(), [VariableReference(throw e, []), Expression(, [])])    VariableReference(throw e, [])    Expression(, [])  Statement(}, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(checkPendingIntentNotNull(operation), []), Statement(try {, []), MethodCall(mService.pendingRequestForNetwork(request.networkCapabilities, operation), [VariableReference(mService, []), Expression(request.networkCapabilities, []), Expression(operation, [])]), Statement(} catch (RemoteException e) {, []), MethodCall(throw e.rethrowFromSystemServer(), [VariableReference(throw e, []), Expression(, [])]), Statement(} catch (ServiceSpecificException e) {, []), Statement(throw convertServiceException(e), []), Statement(}, []), Statement(}, [])])  Statement({, [])  Statement(checkPendingIntentNotNull(operation), [])  Statement(try {, [])  MethodCall(mService.pendingRequestForNetwork(request.networkCapabilities, operation), [VariableReference(mService, []), Expression(request.networkCapabilities, []), Expression(operation, [])])    VariableReference(mService, [])    Expression(request.networkCapabilities, [])    Expression(operation, [])  Statement(} catch (RemoteException e) {, [])  MethodCall(throw e.rethrowFromSystemServer(), [VariableReference(throw e, []), Expression(, [])])    VariableReference(throw e, [])    Expression(, [])  Statement(} catch (ServiceSpecificException e) {, [])  Statement(throw convertServiceException(e), [])  Statement(}, [])  Statement(}, [])",1,"/**
 * Request a network to satisfy a set of {@link android.net.NetworkCapabilities}.
 *
 * This function behaves identically to the version that takes a NetworkCallback, but instead
 * of {@link NetworkCallback} a {@link PendingIntent} is used.  This means
 * the request may outlive the calling application and get called back when a suitable
 * network is found.
 * <p>
 * The operation is an Intent broadcast that goes to a broadcast receiver that
 * you registered with {@link Context#registerReceiver} or through the
 * &lt;receiver&gt; tag in an AndroidManifest.xml file
 * <p>
 * The operation Intent is delivered with two extras, a {@link Network} typed
 * extra called {@link #EXTRA_NETWORK} and a {@link NetworkRequest}
 * typed extra called {@link #EXTRA_NETWORK_REQUEST} containing
 * the original requests parameters.  It is important to create a new,
 * {@link NetworkCallback} based request before completing the processing of the
 * Intent to reserve the network or it will be released shortly after the Intent
 * is processed.
 * <p>
 * If there is already a request for this Intent registered (with the equality of
 * two Intents defined by {@link Intent#filterEquals}), then it will be removed and
 * replaced by this one, effectively releasing the previous {@link NetworkRequest}.
 * <p>
 * The request may be released normally by calling
 * {@link #releaseNetworkRequest(android.app.PendingIntent)}.
 * <p>It is presently unsupported to request a network with either
 * {@link NetworkCapabilities#NET_CAPABILITY_VALIDATED} or
 * {@link NetworkCapabilities#NET_CAPABILITY_CAPTIVE_PORTAL}
 * as these {@code NetworkCapabilities} represent states that a particular
 * network may never attain, and whether a network will attain these states
 * is unknown prior to bringing up the network so the framework does not
 * know how to go about satisfing a request with these capabilities.
 *
 * <p>This method requires the caller to hold either the
 * {@link android.Manifest.permission#CHANGE_NETWORK_STATE} permission
 * or the ability to modify system settings as determined by
 * {@link android.provider.Settings.System#canWrite}.</p>
 *
 * @param request {@link NetworkRequest} describing this request.
 * @param operation Action to perform when the network is available (corresponds
 * to the {@link NetworkCallback#onAvailable} call.  Typically
 * comes from {@link PendingIntent#getBroadcast}. Cannot be null.
 * @throws IllegalArgumentException if {@code request} contains either
 * {@link NetworkCapabilities#NET_CAPABILITY_VALIDATED} or
 * {@link NetworkCapabilities#NET_CAPABILITY_CAPTIVE_PORTAL}.
 */","/**
 * Request a network to satisfy a set of {@link android.net.NetworkCapabilities}.
 *
 * This function behaves identically to the version that takes a NetworkCallback, but instead
 * of {@link NetworkCallback} a {@link PendingIntent} is used.  This means
 * the request may outlive the calling application and get called back when a suitable
 * network is found.
 * <p>
 * The operation is an Intent broadcast that goes to a broadcast receiver that
 * you registered with {@link Context#registerReceiver} or through the
 * &lt;receiver&gt; tag in an AndroidManifest.xml file
 * <p>
 * The operation Intent is delivered with two extras, a {@link Network} typed
 * extra called {@link #EXTRA_NETWORK} and a {@link NetworkRequest}
 * typed extra called {@link #EXTRA_NETWORK_REQUEST} containing
 * the original requests parameters.  It is important to create a new,
 * {@link NetworkCallback} based request before completing the processing of the
 * Intent to reserve the network or it will be released shortly after the Intent
 * is processed.
 * <p>
 * If there is already a request for this Intent registered (with the equality of
 * two Intents defined by {@link Intent#filterEquals}), then it will be removed and
 * replaced by this one, effectively releasing the previous {@link NetworkRequest}.
 * <p>
 * The request may be released normally by calling
 * {@link #releaseNetworkRequest(android.app.PendingIntent)}.
 * <p>It is presently unsupported to request a network with either
 * {@link NetworkCapabilities#NET_CAPABILITY_VALIDATED} or
 * {@link NetworkCapabilities#NET_CAPABILITY_CAPTIVE_PORTAL}
 * as these {@code NetworkCapabilities} represent states that a particular
 * network may never attain, and whether a network will attain these states
 * is unknown prior to bringing up the network so the framework does not
 * know how to go about satisfing a request with these capabilities.
 *
 * <p>This method requires the caller to hold either the
 * {@link android.Manifest.permission#CHANGE_NETWORK_STATE} permission
 * or the ability to modify system settings as determined by
 * {@link android.provider.Settings.System#canWrite}.</p>
 *
 * @param request {@link NetworkRequest} describing this request.
 * @param operation Action to perform when the network is available (corresponds
 * to the {@link NetworkCallback#onAvailable} call.  Typically
 * comes from {@link PendingIntent#getBroadcast}. Cannot be null.
 * @throws IllegalArgumentException if {@code request} contains either
 * {@link NetworkCapabilities#NET_CAPABILITY_VALIDATED} or
 * {@link NetworkCapabilities#NET_CAPABILITY_CAPTIVE_PORTAL}.
 */",0,,,0,,,,1,2,2,"2,3,4","1,2","In the early implementation, there is a call to 'checkPendingIntent(operation)', whereas in the late implementation, it has been changed to 'checkPendingIntentNotNull(operation)'. Also, a new exception handling statement has been introduced in the late version: '} catch (ServiceSpecificException e) {', so the change type is 2,3,4.","The exception handling modification and the change in function call could potentially lead to different behaviours in terms of returned values or thrown exceptions. Thus, the compatibility issue type is 1,2."
131,"<android.app.FragmentManagerImpl: void dispatchOnFragmentActivityCreated(Fragment,Bundle,boolean)>",26,27,"<android.app.FragmentManagerImpl: void dispatchOnFragmentActivityCreated(Fragment,Bundle,boolean)>","<android.app.FragmentManagerImpl: void dispatchOnFragmentActivityCreated(Fragment,Bundle,boolean)>",0,"MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(if (mParent !, []), Expression(null) {, [])]), AssignmentExpression(=, [VariableReference(FragmentManager parentManager, []), Expression(mParent.getFragmentManager(), [])]), Statement(if (parentManager instanceof FragmentManagerImpl) {, []), MethodCall(((FragmentManagerImpl) parentManager).dispatchOnFragmentActivityCreated(f, savedInstanceState, true), [VariableReference(((FragmentManagerImpl) parentManager), []), Expression(f, []), Expression(savedInstanceState, []), Expression(true, [])]), Statement(}, []), Statement(}, []), AssignmentExpression(=, [VariableReference(if (mLifecycleCallbacks, []), Expression(, [])]), Statement(return, []), Statement(}, []), Statement(for (Pair<FragmentLifecycleCallbacks, Boolean> p : mLifecycleCallbacks) {, []), Statement(}, []), Statement(}, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(if (mParent !, []), Expression(null) {, [])])    VariableReference(if (mParent !, [])    Expression(null) {, [])  AssignmentExpression(=, [VariableReference(FragmentManager parentManager, []), Expression(mParent.getFragmentManager(), [])])    VariableReference(FragmentManager parentManager, [])    Expression(mParent.getFragmentManager(), [])  Statement(if (parentManager instanceof FragmentManagerImpl) {, [])  MethodCall(((FragmentManagerImpl) parentManager).dispatchOnFragmentActivityCreated(f, savedInstanceState, true), [VariableReference(((FragmentManagerImpl) parentManager), []), Expression(f, []), Expression(savedInstanceState, []), Expression(true, [])])    VariableReference(((FragmentManagerImpl) parentManager), [])    Expression(f, [])    Expression(savedInstanceState, [])    Expression(true, [])  Statement(}, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(if (mLifecycleCallbacks, []), Expression(, [])])    VariableReference(if (mLifecycleCallbacks, [])    Expression(, [])  Statement(return, [])  Statement(}, [])  Statement(for (Pair<FragmentLifecycleCallbacks, Boolean> p : mLifecycleCallbacks) {, [])  Statement(}, [])  Statement(}, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(if (mParent !, []), Expression(null) {, [])]), AssignmentExpression(=, [VariableReference(FragmentManager parentManager, []), Expression(mParent.getFragmentManager(), [])]), Statement(if (parentManager instanceof FragmentManagerImpl) {, []), MethodCall(((FragmentManagerImpl) parentManager).dispatchOnFragmentActivityCreated(f, savedInstanceState, true), [VariableReference(((FragmentManagerImpl) parentManager), []), Expression(f, []), Expression(savedInstanceState, []), Expression(true, [])]), Statement(}, []), Statement(}, []), Statement(for (Pair<FragmentLifecycleCallbacks, Boolean> p : mLifecycleCallbacks) {, []), Statement(}, []), Statement(}, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(if (mParent !, []), Expression(null) {, [])])    VariableReference(if (mParent !, [])    Expression(null) {, [])  AssignmentExpression(=, [VariableReference(FragmentManager parentManager, []), Expression(mParent.getFragmentManager(), [])])    VariableReference(FragmentManager parentManager, [])    Expression(mParent.getFragmentManager(), [])  Statement(if (parentManager instanceof FragmentManagerImpl) {, [])  MethodCall(((FragmentManagerImpl) parentManager).dispatchOnFragmentActivityCreated(f, savedInstanceState, true), [VariableReference(((FragmentManagerImpl) parentManager), []), Expression(f, []), Expression(savedInstanceState, []), Expression(true, [])])    VariableReference(((FragmentManagerImpl) parentManager), [])    Expression(f, [])    Expression(savedInstanceState, [])    Expression(true, [])  Statement(}, [])  Statement(}, [])  Statement(for (Pair<FragmentLifecycleCallbacks, Boolean> p : mLifecycleCallbacks) {, [])  Statement(}, [])  Statement(}, [])  Statement(}, [])",1,,,0,,,0,,,,1,"1,3",1,0,0,"There is no code change between the early version and the late version for this method according to the provided ASTs, which means the method has not been modified.","Since there are no changes in the method's implementation, no compatibility issues will arise between these versions."
132,<android.service.autofill.SaveInfo.Builder: Builder setDescription(CharSequence)>,26,27,<android.service.autofill.SaveInfo.Builder: Builder setDescription(CharSequence)>,<android.service.autofill.SaveInfo.Builder: Builder setDescription(CharSequence)>,0,"MethodDeclaration(method_body, [Statement({, []), Statement(throwIfDestroyed(), []), AssignmentExpression(=, [VariableReference(mDescription, []), Expression(description, [])]), Statement(return this, []), Statement(}, [])])  Statement({, [])  Statement(throwIfDestroyed(), [])  AssignmentExpression(=, [VariableReference(mDescription, []), Expression(description, [])])    VariableReference(mDescription, [])    Expression(description, [])  Statement(return this, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(throwIfDestroyed(), []), AssignmentExpression(=, [VariableReference(Preconditions.checkState(mCustomDescription, []), Expression(, [])]), AssignmentExpression(=, [VariableReference(mDescription, []), Expression(description, [])]), Statement(return this, []), Statement(}, [])])  Statement({, [])  Statement(throwIfDestroyed(), [])  AssignmentExpression(=, [VariableReference(Preconditions.checkState(mCustomDescription, []), Expression(, [])])    VariableReference(Preconditions.checkState(mCustomDescription, [])    Expression(, [])  AssignmentExpression(=, [VariableReference(mDescription, []), Expression(description, [])])    VariableReference(mDescription, [])    Expression(description, [])  Statement(return this, [])  Statement(}, [])",1,"/**
 * Sets an optional description to be shown in the UI when the user is asked to save.
 *
 * <p>Typically, it describes how the data will be stored by the service, so it can help
 * users to decide whether they can trust the service to save their data.
 *
 * @param description a succint description.
 * @return This Builder.
 */","/**
 * Sets an optional description to be shown in the UI when the user is asked to save.
 *
 * <p>Typically, it describes how the data will be stored by the service, so it can help
 * users to decide whether they can trust the service to save their data.
 *
 * @param description a succint description.
 * @return This Builder.
 *
 * @throws IllegalStateException if this call was made after calling
 * {@link #setCustomDescription(CustomDescription)}.
 */",1,[@NonNull],[@NonNull],0,,,,1,4,0,"1,2,3,5","1,2","In the new implementation, Preconditions.checkState(mCustomDescription, []) has been added, and the javadoc comment has added a new exception IllegalStateException. These changes indicate changes in the assignment statements, exception handling, control dependency (from the method Preconditions.checkState()), and dependent API.","The changes to the return and exception handling could lead to different responses from the API, thus there is a potential compatibility issue caused by return values/types (class 1) and exception handlings (class 2)."
137,<android.view.textclassifier.TextSelection.Builder: TextSelection build()>,26,27,<android.view.textclassifier.TextSelection.Builder: TextSelection build()>,<android.view.textclassifier.TextSelection.Builder: TextSelection build()>,0,"MethodDeclaration(method_body, [Statement({, []), Statement(return new TextSelection(mStartIndex, mEndIndex, mEntityConfidence, mLogSource), []), Statement(}, [])])  Statement({, [])  Statement(return new TextSelection(mStartIndex, mEndIndex, mEntityConfidence, mLogSource), [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(return new TextSelection(mStartIndex, mEndIndex, mEntityConfidence, mLogSource, mVersionInfo), []), Statement(}, [])])  Statement({, [])  Statement(return new TextSelection(mStartIndex, mEndIndex, mEntityConfidence, mLogSource, mVersionInfo), [])  Statement(}, [])",1,"/**
 * Builds and returns {@link TextSelection} object.
 */","/**
 * Builds and returns {@link TextSelection} object.
 */",0,,,0,,,,"1,2","1,5",1,"1,5",1,"The late version passed a new parameter 'mVersionInfo' to the TextSelection object in the return statement, so the change type is a combination of 1,5.","As the return statement with different parameters will make the API potentially return a different object, the CI type is 1."
138,"<android.app.Notification.BigTextStyle: void applyBigTextContentView(Builder,RemoteViews,CharSequence)>",26,27,"<android.app.Notification.BigTextStyle: void applyBigTextContentView(Builder,RemoteViews,CharSequence)>","<android.app.Notification.BigTextStyle: void applyBigTextContentView(Builder,RemoteViews,CharSequence)>",0,"MethodDeclaration(method_body, [Statement({, []), MethodCall(contentView.setTextViewText(R.id.big_text, bigTextText), [VariableReference(contentView, []), Expression(R.id.big_text, []), Expression(bigTextText, [])]), MethodCall(builder.setTextViewColorSecondary(contentView, R.id.big_text), [VariableReference(builder, []), Expression(contentView, []), Expression(R.id.big_text, [])]), MethodCall(contentView.setViewVisibility(R.id.big_text, TextUtils.isEmpty(bigTextText) ? View.GONE : View.VISIBLE), [VariableReference(contentView, []), Expression(R.id.big_text, []), Expression(TextUtils.isEmpty(bigTextText) ? View.GONE : View.VISIBLE, [])]), MethodCall(contentView.setBoolean(R.id.big_text, ""setHasImage"", builder.mN.hasLargeIcon()), [VariableReference(contentView, []), Expression(R.id.big_text, []), Expression(""setHasImage"", []), Expression(builder.mN.hasLargeIcon(), [])]), Statement(}, [])])  Statement({, [])  MethodCall(contentView.setTextViewText(R.id.big_text, bigTextText), [VariableReference(contentView, []), Expression(R.id.big_text, []), Expression(bigTextText, [])])    VariableReference(contentView, [])    Expression(R.id.big_text, [])    Expression(bigTextText, [])  MethodCall(builder.setTextViewColorSecondary(contentView, R.id.big_text), [VariableReference(builder, []), Expression(contentView, []), Expression(R.id.big_text, [])])    VariableReference(builder, [])    Expression(contentView, [])    Expression(R.id.big_text, [])  MethodCall(contentView.setViewVisibility(R.id.big_text, TextUtils.isEmpty(bigTextText) ? View.GONE : View.VISIBLE), [VariableReference(contentView, []), Expression(R.id.big_text, []), Expression(TextUtils.isEmpty(bigTextText) ? View.GONE : View.VISIBLE, [])])    VariableReference(contentView, [])    Expression(R.id.big_text, [])    Expression(TextUtils.isEmpty(bigTextText) ? View.GONE : View.VISIBLE, [])  MethodCall(contentView.setBoolean(R.id.big_text, ""setHasImage"", builder.mN.hasLargeIcon()), [VariableReference(contentView, []), Expression(R.id.big_text, []), Expression(""setHasImage"", []), Expression(builder.mN.hasLargeIcon(), [])])    VariableReference(contentView, [])    Expression(R.id.big_text, [])    Expression(""setHasImage"", [])    Expression(builder.mN.hasLargeIcon(), [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), MethodCall(contentView.setTextViewText(R.id.big_text, builder.processTextSpans(bigTextText)), [VariableReference(contentView, []), Expression(R.id.big_text, []), Expression(builder.processTextSpans(bigTextText), [])]), MethodCall(builder.setTextViewColorSecondary(contentView, R.id.big_text), [VariableReference(builder, []), Expression(contentView, []), Expression(R.id.big_text, [])]), MethodCall(contentView.setViewVisibility(R.id.big_text, TextUtils.isEmpty(bigTextText) ? View.GONE : View.VISIBLE), [VariableReference(contentView, []), Expression(R.id.big_text, []), Expression(TextUtils.isEmpty(bigTextText) ? View.GONE : View.VISIBLE, [])]), MethodCall(contentView.setBoolean(R.id.big_text, ""setHasImage"", builder.mN.hasLargeIcon()), [VariableReference(contentView, []), Expression(R.id.big_text, []), Expression(""setHasImage"", []), Expression(builder.mN.hasLargeIcon(), [])]), Statement(}, [])])  Statement({, [])  MethodCall(contentView.setTextViewText(R.id.big_text, builder.processTextSpans(bigTextText)), [VariableReference(contentView, []), Expression(R.id.big_text, []), Expression(builder.processTextSpans(bigTextText), [])])    VariableReference(contentView, [])    Expression(R.id.big_text, [])    Expression(builder.processTextSpans(bigTextText), [])  MethodCall(builder.setTextViewColorSecondary(contentView, R.id.big_text), [VariableReference(builder, []), Expression(contentView, []), Expression(R.id.big_text, [])])    VariableReference(builder, [])    Expression(contentView, [])    Expression(R.id.big_text, [])  MethodCall(contentView.setViewVisibility(R.id.big_text, TextUtils.isEmpty(bigTextText) ? View.GONE : View.VISIBLE), [VariableReference(contentView, []), Expression(R.id.big_text, []), Expression(TextUtils.isEmpty(bigTextText) ? View.GONE : View.VISIBLE, [])])    VariableReference(contentView, [])    Expression(R.id.big_text, [])    Expression(TextUtils.isEmpty(bigTextText) ? View.GONE : View.VISIBLE, [])  MethodCall(contentView.setBoolean(R.id.big_text, ""setHasImage"", builder.mN.hasLargeIcon()), [VariableReference(contentView, []), Expression(R.id.big_text, []), Expression(""setHasImage"", []), Expression(builder.mN.hasLargeIcon(), [])])    VariableReference(contentView, [])    Expression(R.id.big_text, [])    Expression(""setHasImage"", [])    Expression(builder.mN.hasLargeIcon(), [])  Statement(}, [])",1,,,0,,,0,,,,"1,2",5,0,"1,5",1,"The method call has been changed from 'contentView.setTextViewText(R.id.big_text, bigTextText)' to 'contentView.setTextViewText(R.id.big_text, builder.processTextSpans(bigTextText))', which involves an additional API call 'builder.processTextSpans(bigTextText)', hence the change type is 1 and 5 as both the return statement and a dependent API has been changed.","The change in method call and additional usage of a dependent API 'builder.processTextSpans(bigTextText)' can potentially lead to different return value or behavior, hence CI with type 1 is detected."
139,<android.widget.Editor.HandleView: void show()>,26,27,<android.widget.Editor.HandleView: void show()>,<android.widget.Editor.HandleView: void show()>,0,"MethodDeclaration(method_body, [Statement({, []), Statement(if (isShowing()), []), Statement(return, []), MethodCall(getPositionListener().addSubscriber(this, true), [VariableReference(getPositionListener(), []), Expression(this, []), Expression(true, [])]), Statement(// Make sure the offset is always considered new, even when focusing at same position, []), AssignmentExpression(=, [VariableReference(mPreviousOffset, []), Expression(-1, [])]), Statement(positionAtCursorOffset(getCurrentCursorOffset(), false), []), Statement(}, [])])  Statement({, [])  Statement(if (isShowing()), [])  Statement(return, [])  MethodCall(getPositionListener().addSubscriber(this, true), [VariableReference(getPositionListener(), []), Expression(this, []), Expression(true, [])])    VariableReference(getPositionListener(), [])    Expression(this, [])    Expression(true, [])  Statement(// Make sure the offset is always considered new, even when focusing at same position, [])  AssignmentExpression(=, [VariableReference(mPreviousOffset, []), Expression(-1, [])])    VariableReference(mPreviousOffset, [])    Expression(-1, [])  Statement(positionAtCursorOffset(getCurrentCursorOffset(), false), [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(if (isShowing()), []), Statement(return, []), MethodCall(getPositionListener().addSubscriber(this, true), [VariableReference(getPositionListener(), []), Expression(this, []), Expression(true, [])]), Statement(// Make sure the offset is always considered new, even when focusing at same position, []), AssignmentExpression(=, [VariableReference(mPreviousOffset, []), Expression(-1, [])]), Statement(positionAtCursorOffset(getCurrentCursorOffset(), false, false), []), Statement(}, [])])  Statement({, [])  Statement(if (isShowing()), [])  Statement(return, [])  MethodCall(getPositionListener().addSubscriber(this, true), [VariableReference(getPositionListener(), []), Expression(this, []), Expression(true, [])])    VariableReference(getPositionListener(), [])    Expression(this, [])    Expression(true, [])  Statement(// Make sure the offset is always considered new, even when focusing at same position, [])  AssignmentExpression(=, [VariableReference(mPreviousOffset, []), Expression(-1, [])])    VariableReference(mPreviousOffset, [])    Expression(-1, [])  Statement(positionAtCursorOffset(getCurrentCursorOffset(), false, false), [])  Statement(}, [])",1,,,0,,,0,,,,2,5,0,"4,5 ",1,"The method positionAtCursorOffset() has an additional parameter in the later version. This indicates that the type and/or the number of parameters of a method that this API depends on has changed. Hence, the change type is 4, 5.","The method invoked is different due to an extra parameter in the later version. This could potentially lead to a different behavior and hence different return values when this updated API is invoked. Thus, the Compatibility Issue type is 1."
140,<android.os.WorkSource: void clear()>,27,28,<android.os.WorkSource: void clear()>,<android.os.WorkSource: void clear()>,0,"MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(mNum, []), Expression(0, [])]), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(mNum, []), Expression(0, [])])    VariableReference(mNum, [])    Expression(0, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(mNum, []), Expression(0, [])]), AssignmentExpression(=, [VariableReference(if (mChains !, []), Expression(null) {, [])]), MethodCall(mChains.clear(), [VariableReference(mChains, []), Expression(, [])]), Statement(}, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(mNum, []), Expression(0, [])])    VariableReference(mNum, [])    Expression(0, [])  AssignmentExpression(=, [VariableReference(if (mChains !, []), Expression(null) {, [])])    VariableReference(if (mChains !, [])    Expression(null) {, [])  MethodCall(mChains.clear(), [VariableReference(mChains, []), Expression(, [])])    VariableReference(mChains, [])    Expression(, [])  Statement(}, [])  Statement(}, [])",1,"/**
 * Clear this WorkSource to be empty.
 */","/**
 * Clear this WorkSource to be empty.
 */",0,,,0,,,,1,3,0,"1,4",0,"In the later version, assignment and method call statements are added in order to clear the content of 'mChains'. The codes of mNum=0 remains unchanged. So, the code changes are categorized under classes 1 (return statement changed) and 4 (other statement changed).","Despite the changes, the basic functionality of the method 'clear' remains the same, that is to clear the WorkSource object. It doesn't affect the potential return values or types and also doesn't cause an exception to be thrown differently between the two versions. So, there are no compatibility issues caused by the changes. Thus, it's identified as class 0 (No Compatibility Issue exist)."
141,<android.app.Notification.Action.Builder: Action build()>,27,28,<android.app.Notification.Action.Builder: Action build()>,<android.app.Notification.Action.Builder: Action build()>,0,"MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(ArrayList<RemoteInput> dataOnlyInputs, []), Expression(new ArrayList<>(), [])]), AssignmentExpression(=, [VariableReference(RemoteInput[] previousDataInputs, []), Expression((RemoteInput[]) mExtras.getParcelableArray(EXTRA_DATA_ONLY_INPUTS), [])]), AssignmentExpression(=, [VariableReference(if (previousDataInputs !, []), Expression(null) {, [])]), Statement(for (RemoteInput input : previousDataInputs) {, []), MethodCall(dataOnlyInputs.add(input), [VariableReference(dataOnlyInputs, []), Expression(input, [])]), Statement(}, []), Statement(}, []), AssignmentExpression(=, [VariableReference(List<RemoteInput> textInputs, []), Expression(new ArrayList<>(), [])]), AssignmentExpression(=, [VariableReference(if (mRemoteInputs !, []), Expression(null) {, [])]), Statement(for (RemoteInput input : mRemoteInputs) {, []), MethodCall(if (input.isDataOnly()), [VariableReference(if (input, []), Expression(), [])]), MethodCall(dataOnlyInputs.add(input), [VariableReference(dataOnlyInputs, []), Expression(input, [])]), Statement(} else {, []), MethodCall(textInputs.add(input), [VariableReference(textInputs, []), Expression(input, [])]), Statement(}, []), Statement(}, []), Statement(}, []), MethodCall(if (!dataOnlyInputs.isEmpty()), [VariableReference(if (!dataOnlyInputs, []), Expression(), [])]), AssignmentExpression(=, [VariableReference(RemoteInput[] dataInputsArr, []), Expression(dataOnlyInputs.toArray(new RemoteInput[dataOnlyInputs.size()]), [])]), MethodCall(mExtras.putParcelableArray(EXTRA_DATA_ONLY_INPUTS, dataInputsArr), [VariableReference(mExtras, []), Expression(EXTRA_DATA_ONLY_INPUTS, []), Expression(dataInputsArr, [])]), Statement(}, []), AssignmentExpression(=, [VariableReference(RemoteInput[] textInputsArr, []), Expression(textInputs.isEmpty() ? null : textInputs.toArray(new RemoteInput[textInputs.size()]), [])]), Statement(return new Action(mIcon, mTitle, mIntent, mExtras, textInputsArr, mAllowGeneratedReplies), []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(ArrayList<RemoteInput> dataOnlyInputs, []), Expression(new ArrayList<>(), [])])    VariableReference(ArrayList<RemoteInput> dataOnlyInputs, [])    Expression(new ArrayList<>(), [])  AssignmentExpression(=, [VariableReference(RemoteInput[] previousDataInputs, []), Expression((RemoteInput[]) mExtras.getParcelableArray(EXTRA_DATA_ONLY_INPUTS), [])])    VariableReference(RemoteInput[] previousDataInputs, [])    Expression((RemoteInput[]) mExtras.getParcelableArray(EXTRA_DATA_ONLY_INPUTS), [])  AssignmentExpression(=, [VariableReference(if (previousDataInputs !, []), Expression(null) {, [])])    VariableReference(if (previousDataInputs !, [])    Expression(null) {, [])  Statement(for (RemoteInput input : previousDataInputs) {, [])  MethodCall(dataOnlyInputs.add(input), [VariableReference(dataOnlyInputs, []), Expression(input, [])])    VariableReference(dataOnlyInputs, [])    Expression(input, [])  Statement(}, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(List<RemoteInput> textInputs, []), Expression(new ArrayList<>(), [])])    VariableReference(List<RemoteInput> textInputs, [])    Expression(new ArrayList<>(), [])  AssignmentExpression(=, [VariableReference(if (mRemoteInputs !, []), Expression(null) {, [])])    VariableReference(if (mRemoteInputs !, [])    Expression(null) {, [])  Statement(for (RemoteInput input : mRemoteInputs) {, [])  MethodCall(if (input.isDataOnly()), [VariableReference(if (input, []), Expression(), [])])    VariableReference(if (input, [])    Expression(), [])  MethodCall(dataOnlyInputs.add(input), [VariableReference(dataOnlyInputs, []), Expression(input, [])])    VariableReference(dataOnlyInputs, [])    Expression(input, [])  Statement(} else {, [])  MethodCall(textInputs.add(input), [VariableReference(textInputs, []), Expression(input, [])])    VariableReference(textInputs, [])    Expression(input, [])  Statement(}, [])  Statement(}, [])  Statement(}, [])  MethodCall(if (!dataOnlyInputs.isEmpty()), [VariableReference(if (!dataOnlyInputs, []), Expression(), [])])    VariableReference(if (!dataOnlyInputs, [])    Expression(), [])  AssignmentExpression(=, [VariableReference(RemoteInput[] dataInputsArr, []), Expression(dataOnlyInputs.toArray(new RemoteInput[dataOnlyInputs.size()]), [])])    VariableReference(RemoteInput[] dataInputsArr, [])    Expression(dataOnlyInputs.toArray(new RemoteInput[dataOnlyInputs.size()]), [])  MethodCall(mExtras.putParcelableArray(EXTRA_DATA_ONLY_INPUTS, dataInputsArr), [VariableReference(mExtras, []), Expression(EXTRA_DATA_ONLY_INPUTS, []), Expression(dataInputsArr, [])])    VariableReference(mExtras, [])    Expression(EXTRA_DATA_ONLY_INPUTS, [])    Expression(dataInputsArr, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(RemoteInput[] textInputsArr, []), Expression(textInputs.isEmpty() ? null : textInputs.toArray(new RemoteInput[textInputs.size()]), [])])    VariableReference(RemoteInput[] textInputsArr, [])    Expression(textInputs.isEmpty() ? null : textInputs.toArray(new RemoteInput[textInputs.size()]), [])  Statement(return new Action(mIcon, mTitle, mIntent, mExtras, textInputsArr, mAllowGeneratedReplies), [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(ArrayList<RemoteInput> dataOnlyInputs, []), Expression(new ArrayList<>(), [])]), AssignmentExpression(=, [VariableReference(RemoteInput[] previousDataInputs, []), Expression((RemoteInput[]) mExtras.getParcelableArray(EXTRA_DATA_ONLY_INPUTS), [])]), AssignmentExpression(=, [VariableReference(if (previousDataInputs !, []), Expression(null) {, [])]), Statement(for (RemoteInput input : previousDataInputs) {, []), MethodCall(dataOnlyInputs.add(input), [VariableReference(dataOnlyInputs, []), Expression(input, [])]), Statement(}, []), Statement(}, []), AssignmentExpression(=, [VariableReference(List<RemoteInput> textInputs, []), Expression(new ArrayList<>(), [])]), AssignmentExpression(=, [VariableReference(if (mRemoteInputs !, []), Expression(null) {, [])]), Statement(for (RemoteInput input : mRemoteInputs) {, []), MethodCall(if (input.isDataOnly()), [VariableReference(if (input, []), Expression(), [])]), MethodCall(dataOnlyInputs.add(input), [VariableReference(dataOnlyInputs, []), Expression(input, [])]), Statement(} else {, []), MethodCall(textInputs.add(input), [VariableReference(textInputs, []), Expression(input, [])]), Statement(}, []), Statement(}, []), Statement(}, []), MethodCall(if (!dataOnlyInputs.isEmpty()), [VariableReference(if (!dataOnlyInputs, []), Expression(), [])]), AssignmentExpression(=, [VariableReference(RemoteInput[] dataInputsArr, []), Expression(dataOnlyInputs.toArray(new RemoteInput[dataOnlyInputs.size()]), [])]), MethodCall(mExtras.putParcelableArray(EXTRA_DATA_ONLY_INPUTS, dataInputsArr), [VariableReference(mExtras, []), Expression(EXTRA_DATA_ONLY_INPUTS, []), Expression(dataInputsArr, [])]), Statement(}, []), AssignmentExpression(=, [VariableReference(RemoteInput[] textInputsArr, []), Expression(textInputs.isEmpty() ? null : textInputs.toArray(new RemoteInput[textInputs.size()]), [])]), Statement(return new Action(mIcon, mTitle, mIntent, mExtras, textInputsArr, mAllowGeneratedReplies, mSemanticAction), []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(ArrayList<RemoteInput> dataOnlyInputs, []), Expression(new ArrayList<>(), [])])    VariableReference(ArrayList<RemoteInput> dataOnlyInputs, [])    Expression(new ArrayList<>(), [])  AssignmentExpression(=, [VariableReference(RemoteInput[] previousDataInputs, []), Expression((RemoteInput[]) mExtras.getParcelableArray(EXTRA_DATA_ONLY_INPUTS), [])])    VariableReference(RemoteInput[] previousDataInputs, [])    Expression((RemoteInput[]) mExtras.getParcelableArray(EXTRA_DATA_ONLY_INPUTS), [])  AssignmentExpression(=, [VariableReference(if (previousDataInputs !, []), Expression(null) {, [])])    VariableReference(if (previousDataInputs !, [])    Expression(null) {, [])  Statement(for (RemoteInput input : previousDataInputs) {, [])  MethodCall(dataOnlyInputs.add(input), [VariableReference(dataOnlyInputs, []), Expression(input, [])])    VariableReference(dataOnlyInputs, [])    Expression(input, [])  Statement(}, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(List<RemoteInput> textInputs, []), Expression(new ArrayList<>(), [])])    VariableReference(List<RemoteInput> textInputs, [])    Expression(new ArrayList<>(), [])  AssignmentExpression(=, [VariableReference(if (mRemoteInputs !, []), Expression(null) {, [])])    VariableReference(if (mRemoteInputs !, [])    Expression(null) {, [])  Statement(for (RemoteInput input : mRemoteInputs) {, [])  MethodCall(if (input.isDataOnly()), [VariableReference(if (input, []), Expression(), [])])    VariableReference(if (input, [])    Expression(), [])  MethodCall(dataOnlyInputs.add(input), [VariableReference(dataOnlyInputs, []), Expression(input, [])])    VariableReference(dataOnlyInputs, [])    Expression(input, [])  Statement(} else {, [])  MethodCall(textInputs.add(input), [VariableReference(textInputs, []), Expression(input, [])])    VariableReference(textInputs, [])    Expression(input, [])  Statement(}, [])  Statement(}, [])  Statement(}, [])  MethodCall(if (!dataOnlyInputs.isEmpty()), [VariableReference(if (!dataOnlyInputs, []), Expression(), [])])    VariableReference(if (!dataOnlyInputs, [])    Expression(), [])  AssignmentExpression(=, [VariableReference(RemoteInput[] dataInputsArr, []), Expression(dataOnlyInputs.toArray(new RemoteInput[dataOnlyInputs.size()]), [])])    VariableReference(RemoteInput[] dataInputsArr, [])    Expression(dataOnlyInputs.toArray(new RemoteInput[dataOnlyInputs.size()]), [])  MethodCall(mExtras.putParcelableArray(EXTRA_DATA_ONLY_INPUTS, dataInputsArr), [VariableReference(mExtras, []), Expression(EXTRA_DATA_ONLY_INPUTS, []), Expression(dataInputsArr, [])])    VariableReference(mExtras, [])    Expression(EXTRA_DATA_ONLY_INPUTS, [])    Expression(dataInputsArr, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(RemoteInput[] textInputsArr, []), Expression(textInputs.isEmpty() ? null : textInputs.toArray(new RemoteInput[textInputs.size()]), [])])    VariableReference(RemoteInput[] textInputsArr, [])    Expression(textInputs.isEmpty() ? null : textInputs.toArray(new RemoteInput[textInputs.size()]), [])  Statement(return new Action(mIcon, mTitle, mIntent, mExtras, textInputsArr, mAllowGeneratedReplies, mSemanticAction), [])  Statement(}, [])",1,"/**
 * Combine all of the options that have been set and return a new {@link Action}
 * object.
 * @return the built action
 */","/**
 * Combine all of the options that have been set and return a new {@link Action}
 * object.
 * @return the built action
 */",0,,,0,,,,2,"1,5",1,1,1,"The return statement has changed from return new Action(mIcon, mTitle, mIntent, mExtras, textInputsArr, mAllowGeneratedReplies) to return new Action(mIcon, mTitle, mIntent, mExtras, textInputsArr, mAllowGeneratedReplies, mSemanticAction). An additional variable 'mSemanticAction' is added in the return statement of the late version.","Due to the addition of a new variable 'mSemanticAction' in the late version, the return type of this method has potentialy changed. As such, this could lead to a Compatibility Issue as clients calling this method might receive different results between the two versions. This qualifies as a compatibility issue of type 1."
142,"<android.net.NetworkCapabilities: void writeToParcel(Parcel,int)>",27,28,"<android.net.NetworkCapabilities: void writeToParcel(Parcel,int)>","<android.net.NetworkCapabilities: void writeToParcel(Parcel,int)>",0,"MethodDeclaration(method_body, [Statement({, []), MethodCall(dest.writeLong(mNetworkCapabilities), [VariableReference(dest, []), Expression(mNetworkCapabilities, [])]), MethodCall(dest.writeLong(mTransportTypes), [VariableReference(dest, []), Expression(mTransportTypes, [])]), MethodCall(dest.writeInt(mLinkUpBandwidthKbps), [VariableReference(dest, []), Expression(mLinkUpBandwidthKbps, [])]), MethodCall(dest.writeInt(mLinkDownBandwidthKbps), [VariableReference(dest, []), Expression(mLinkDownBandwidthKbps, [])]), MethodCall(dest.writeParcelable((Parcelable) mNetworkSpecifier, flags), [VariableReference(dest, []), Expression((Parcelable) mNetworkSpecifier, []), Expression(flags, [])]), MethodCall(dest.writeInt(mSignalStrength), [VariableReference(dest, []), Expression(mSignalStrength, [])]), Statement(}, [])])  Statement({, [])  MethodCall(dest.writeLong(mNetworkCapabilities), [VariableReference(dest, []), Expression(mNetworkCapabilities, [])])    VariableReference(dest, [])    Expression(mNetworkCapabilities, [])  MethodCall(dest.writeLong(mTransportTypes), [VariableReference(dest, []), Expression(mTransportTypes, [])])    VariableReference(dest, [])    Expression(mTransportTypes, [])  MethodCall(dest.writeInt(mLinkUpBandwidthKbps), [VariableReference(dest, []), Expression(mLinkUpBandwidthKbps, [])])    VariableReference(dest, [])    Expression(mLinkUpBandwidthKbps, [])  MethodCall(dest.writeInt(mLinkDownBandwidthKbps), [VariableReference(dest, []), Expression(mLinkDownBandwidthKbps, [])])    VariableReference(dest, [])    Expression(mLinkDownBandwidthKbps, [])  MethodCall(dest.writeParcelable((Parcelable) mNetworkSpecifier, flags), [VariableReference(dest, []), Expression((Parcelable) mNetworkSpecifier, []), Expression(flags, [])])    VariableReference(dest, [])    Expression((Parcelable) mNetworkSpecifier, [])    Expression(flags, [])  MethodCall(dest.writeInt(mSignalStrength), [VariableReference(dest, []), Expression(mSignalStrength, [])])    VariableReference(dest, [])    Expression(mSignalStrength, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), MethodCall(dest.writeLong(mNetworkCapabilities), [VariableReference(dest, []), Expression(mNetworkCapabilities, [])]), MethodCall(dest.writeLong(mUnwantedNetworkCapabilities), [VariableReference(dest, []), Expression(mUnwantedNetworkCapabilities, [])]), MethodCall(dest.writeLong(mTransportTypes), [VariableReference(dest, []), Expression(mTransportTypes, [])]), MethodCall(dest.writeInt(mLinkUpBandwidthKbps), [VariableReference(dest, []), Expression(mLinkUpBandwidthKbps, [])]), MethodCall(dest.writeInt(mLinkDownBandwidthKbps), [VariableReference(dest, []), Expression(mLinkDownBandwidthKbps, [])]), MethodCall(dest.writeParcelable((Parcelable) mNetworkSpecifier, flags), [VariableReference(dest, []), Expression((Parcelable) mNetworkSpecifier, []), Expression(flags, [])]), MethodCall(dest.writeInt(mSignalStrength), [VariableReference(dest, []), Expression(mSignalStrength, [])]), MethodCall(dest.writeArraySet(mUids), [VariableReference(dest, []), Expression(mUids, [])]), MethodCall(dest.writeString(mSSID), [VariableReference(dest, []), Expression(mSSID, [])]), Statement(}, [])])  Statement({, [])  MethodCall(dest.writeLong(mNetworkCapabilities), [VariableReference(dest, []), Expression(mNetworkCapabilities, [])])    VariableReference(dest, [])    Expression(mNetworkCapabilities, [])  MethodCall(dest.writeLong(mUnwantedNetworkCapabilities), [VariableReference(dest, []), Expression(mUnwantedNetworkCapabilities, [])])    VariableReference(dest, [])    Expression(mUnwantedNetworkCapabilities, [])  MethodCall(dest.writeLong(mTransportTypes), [VariableReference(dest, []), Expression(mTransportTypes, [])])    VariableReference(dest, [])    Expression(mTransportTypes, [])  MethodCall(dest.writeInt(mLinkUpBandwidthKbps), [VariableReference(dest, []), Expression(mLinkUpBandwidthKbps, [])])    VariableReference(dest, [])    Expression(mLinkUpBandwidthKbps, [])  MethodCall(dest.writeInt(mLinkDownBandwidthKbps), [VariableReference(dest, []), Expression(mLinkDownBandwidthKbps, [])])    VariableReference(dest, [])    Expression(mLinkDownBandwidthKbps, [])  MethodCall(dest.writeParcelable((Parcelable) mNetworkSpecifier, flags), [VariableReference(dest, []), Expression((Parcelable) mNetworkSpecifier, []), Expression(flags, [])])    VariableReference(dest, [])    Expression((Parcelable) mNetworkSpecifier, [])    Expression(flags, [])  MethodCall(dest.writeInt(mSignalStrength), [VariableReference(dest, []), Expression(mSignalStrength, [])])    VariableReference(dest, [])    Expression(mSignalStrength, [])  MethodCall(dest.writeArraySet(mUids), [VariableReference(dest, []), Expression(mUids, [])])    VariableReference(dest, [])    Expression(mUids, [])  MethodCall(dest.writeString(mSSID), [VariableReference(dest, []), Expression(mSSID, [])])    VariableReference(dest, [])    Expression(mSSID, [])  Statement(}, [])",1,,,0,[@Override],[@Override],0,,,,1,4,0,"1,4",1,"New method calls dest.writeLong(mUnwantedNetworkCapabilities), dest.writeArraySet(mUids), and dest.writeString(mSSID) are added to the implementation. Thus, the change types are 1 (for return statement changed) and 4 (for other statements changed).","The added method calls changes the writing to the 'dest' Parcel object, which means the function now potentially returns a different value. This leads to type 1 Compatibility Issue (CI caused by potential different return values or types)."
143,<android.view.textclassifier.TextClassification: String toString()>,27,28,<android.view.textclassifier.TextClassification: String toString()>,<android.view.textclassifier.TextClassification: String toString()>,0,"MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(return String.format(""TextClassification {"" + ""text, []), Expression(%s, entities, [])]), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(return String.format(""TextClassification {"" + ""text, []), Expression(%s, entities, [])])    VariableReference(return String.format(""TextClassification {"" + ""text, [])    Expression(%s, entities, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(return String.format(Locale.US, ""TextClassification {text, []), Expression(%s, entities, [])]), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(return String.format(Locale.US, ""TextClassification {text, []), Expression(%s, entities, [])])    VariableReference(return String.format(Locale.US, ""TextClassification {text, [])    Expression(%s, entities, [])  Statement(}, [])",1,,,0,[@Override],[@Override],0,,,,"1,2","1,5",1,"1,5",1,"In the return statement, a new parameter ""Locale.US"" was added to the method call String.format, the change type is 1,5.","The input of String.format has been changed and thus the return statement could possibly return different string in varied locale setting, therefore, this code change could potentially cause compatibility issues of type 1."
145,"<android.util.proto.ProtoOutputStream: void writeRepeatedObject(long,byte[])>",27,28,"<android.util.proto.ProtoOutputStream: void writeRepeatedObject(long,byte[])>","<android.util.proto.ProtoOutputStream: void writeRepeatedObject(long,byte[])>",0,"MethodDeclaration(method_body, [Statement({, []), Statement(assertNotCompacted(), []), AssignmentExpression(=, [VariableReference(final int id, []), Expression(checkFieldId(fieldId, FIELD_COUNT_REPEATED | FIELD_TYPE_OBJECT), [])]), Statement(writeRepeatedObjectImpl(id, value), []), Statement(}, [])])  Statement({, [])  Statement(assertNotCompacted(), [])  AssignmentExpression(=, [VariableReference(final int id, []), Expression(checkFieldId(fieldId, FIELD_COUNT_REPEATED | FIELD_TYPE_OBJECT), [])])    VariableReference(final int id, [])    Expression(checkFieldId(fieldId, FIELD_COUNT_REPEATED | FIELD_TYPE_OBJECT), [])  Statement(writeRepeatedObjectImpl(id, value), [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(assertNotCompacted(), []), AssignmentExpression(=, [VariableReference(final int id, []), Expression(checkFieldId(fieldId, FIELD_COUNT_REPEATED | FIELD_TYPE_MESSAGE), [])]), Statement(writeRepeatedObjectImpl(id, value), []), Statement(}, [])])  Statement({, [])  Statement(assertNotCompacted(), [])  AssignmentExpression(=, [VariableReference(final int id, []), Expression(checkFieldId(fieldId, FIELD_COUNT_REPEATED | FIELD_TYPE_MESSAGE), [])])    VariableReference(final int id, [])    Expression(checkFieldId(fieldId, FIELD_COUNT_REPEATED | FIELD_TYPE_MESSAGE), [])  Statement(writeRepeatedObjectImpl(id, value), [])  Statement(}, [])",1,"/**
 * Write an object that has already been flattend.
 *
 * @deprecated Use #write instead.
 */","/**
 * Write an object that has already been flattend.
 *
 * @deprecated Use #write instead.
 */",0,[@Deprecated],[@Deprecated],0,,,,2,5,0,"1,5",1,"In the late version, FIELD_TYPE_OBJECT in the checkFieldId() method has updated to FIELD_TYPE_MESSAGE. Therefore, this is a change in return statement and the version of a dependent API, which marks the change types as 1,5.","The change in FIELD_TYPE_OBJECT to FIELD_TYPE_MESSAGE could potentially lead to return a different value when calling the writeRepeatedObject() method. Therefore, the CI type is 1."
146,<android.view.textclassifier.TextClassification: int getEntityCount()>,27,28,<android.view.textclassifier.TextClassification: int getEntityCount()>,<android.view.textclassifier.TextClassification: int getEntityCount()>,0,"MethodDeclaration(method_body, [Statement({, []), MethodCall(return mEntities.size(), [VariableReference(return mEntities, []), Expression(, [])]), Statement(}, [])])  Statement({, [])  MethodCall(return mEntities.size(), [VariableReference(return mEntities, []), Expression(, [])])    VariableReference(return mEntities, [])    Expression(, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), MethodCall(return mEntityConfidence.getEntities().size(), [VariableReference(return mEntityConfidence, []), Expression().size(, [])]), Statement(}, [])])  Statement({, [])  MethodCall(return mEntityConfidence.getEntities().size(), [VariableReference(return mEntityConfidence, []), Expression().size(, [])])    VariableReference(return mEntityConfidence, [])    Expression().size(, [])  Statement(}, [])",1,"/**
 * Returns the number of entities found in the classified text.
 */","/**
 * Returns the number of entities found in the classified text.
 */",1,[@IntRange(from = 0)],[@IntRange(from = 0)],0,,,,1.2,"1,5",1,"1,5",1,"The return statement has changed from 'return mEntities.size()' to 'return mEntityConfidence.getEntities().size()', and the referenced variable and method used in the return statement have changed as well. Therefore, the code change type is 1,5.","Because the return statement has changed to use a different method and object, it can potentially make the API return a different value. Therefore, the CI type is 1."
147,<android.view.accessibility.AccessibilityWindowInfo: boolean isInPictureInPictureMode()>,27,28,<android.view.accessibility.AccessibilityWindowInfo: boolean isInPictureInPictureMode()>,<android.view.accessibility.AccessibilityWindowInfo: boolean isInPictureInPictureMode()>,0,"MethodDeclaration(method_body, [Statement({, []), Statement(return mInPictureInPicture, []), Statement(}, [])])  Statement({, [])  Statement(return mInPictureInPicture, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(return getBooleanProperty(BOOLEAN_PROPERTY_PICTURE_IN_PICTURE), []), Statement(}, [])])  Statement({, [])  Statement(return getBooleanProperty(BOOLEAN_PROPERTY_PICTURE_IN_PICTURE), [])  Statement(}, [])",1,"/**
 * Check if the window is in picture-in-picture mode.
 *
 * @return {@code true} if the window is in picture-in-picture mode, {@code false} otherwise.
 */","/**
 * Check if the window is in picture-in-picture mode.
 *
 * @return {@code true} if the window is in picture-in-picture mode, {@code false} otherwise.
 */",0,,,0,,,,1,1,1,"1,5",1,"The return statement has changed from 'return mInPictureInPicture' to 'return getBooleanProperty(BOOLEAN_PROPERTY_PICTURE_IN_PICTURE)', and dependent API 'getBooleanProperty()' has been introduced in late version. So, the code change type is 1,5.","The change of return statement means the API may return a different value in the late version from the early version, which potentially leads to a compatibility issue. So, the CI type is 1."
149,<android.companion.CompanionDeviceManager.CallbackProxy: void onSuccess(PendingIntent)>,27,28,<android.companion.CompanionDeviceManager.CallbackProxy: void onSuccess(PendingIntent)>,<android.companion.CompanionDeviceManager.CallbackProxy: void onSuccess(PendingIntent)>,0,"MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(Handler handler, []), Expression(mHandler, [])]), AssignmentExpression(=, [VariableReference(if (handler, []), Expression(, [])]), Statement(return, []), MethodCall(handler.post((), [VariableReference(handler, []), Expression((, [])]), AssignmentExpression(=, [VariableReference(Callback callback, []), Expression(mCallback, [])]), AssignmentExpression(=, [VariableReference(if (callback, []), Expression(, [])]), Statement(return, []), MethodCall(callback.onDeviceFound(launcher.getIntentSender()), [VariableReference(callback, []), Expression(launcher.getIntentSender(), [])]), Statement(}), []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(Handler handler, []), Expression(mHandler, [])])    VariableReference(Handler handler, [])    Expression(mHandler, [])  AssignmentExpression(=, [VariableReference(if (handler, []), Expression(, [])])    VariableReference(if (handler, [])    Expression(, [])  Statement(return, [])  MethodCall(handler.post((), [VariableReference(handler, []), Expression((, [])])    VariableReference(handler, [])    Expression((, [])  AssignmentExpression(=, [VariableReference(Callback callback, []), Expression(mCallback, [])])    VariableReference(Callback callback, [])    Expression(mCallback, [])  AssignmentExpression(=, [VariableReference(if (callback, []), Expression(, [])])    VariableReference(if (callback, [])    Expression(, [])  Statement(return, [])  MethodCall(callback.onDeviceFound(launcher.getIntentSender()), [VariableReference(callback, []), Expression(launcher.getIntentSender(), [])])    VariableReference(callback, [])    Expression(launcher.getIntentSender(), [])  Statement(}), [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), MethodCall(lockAndPost(Callback::onDeviceFound, launcher.getIntentSender()), [VariableReference(lockAndPost(Callback::onDeviceFound, launcher, []), Expression(), [])]), Statement(}, [])])  Statement({, [])  MethodCall(lockAndPost(Callback::onDeviceFound, launcher.getIntentSender()), [VariableReference(lockAndPost(Callback::onDeviceFound, launcher, []), Expression(), [])])    VariableReference(lockAndPost(Callback::onDeviceFound, launcher, [])    Expression(), [])  Statement(}, [])",1,,,0,[@Override],[@Override],0,,,,1,"1,3,4",1,"4,5",1,"The function statements in the early version has been replaced by ""lockAndPost(Callback::onDeviceFound, launcher.getIntentSender())"" in the later version, and the dependent API ""handler.post()"" has been replaced by a new one ""lockAndPost(Callback::onDeviceFound, launcher.getIntentSender())"", so the code change type is 4,5.","The introduced new function ""lockAndPost(Callback::onDeviceFound, launcher.getIntentSender())"" will likely change the previous behavior and thus might return a different output, therefore, the CI type is 1."
158,"<android.service.notification.ZenModeConfig.ZenRule: void writeToParcel(Parcel,int)>",28,29,"<android.service.notification.ZenModeConfig.ZenRule: void writeToParcel(Parcel,int)>","<android.service.notification.ZenModeConfig.ZenRule: void writeToParcel(Parcel,int)>",0,"MethodDeclaration(method_body, [Statement({, []), MethodCall(dest.writeInt(enabled ? 1 : 0), [VariableReference(dest, []), Expression(enabled ? 1 : 0, [])]), MethodCall(dest.writeInt(snoozing ? 1 : 0), [VariableReference(dest, []), Expression(snoozing ? 1 : 0, [])]), AssignmentExpression(=, [VariableReference(if (name !, []), Expression(null) {, [])]), MethodCall(dest.writeInt(1), [VariableReference(dest, []), Expression(1, [])]), MethodCall(dest.writeString(name), [VariableReference(dest, []), Expression(name, [])]), Statement(} else {, []), MethodCall(dest.writeInt(0), [VariableReference(dest, []), Expression(0, [])]), Statement(}, []), MethodCall(dest.writeInt(zenMode), [VariableReference(dest, []), Expression(zenMode, [])]), MethodCall(dest.writeParcelable(conditionId, 0), [VariableReference(dest, []), Expression(conditionId, []), Expression(0, [])]), MethodCall(dest.writeParcelable(condition, 0), [VariableReference(dest, []), Expression(condition, []), Expression(0, [])]), MethodCall(dest.writeParcelable(component, 0), [VariableReference(dest, []), Expression(component, []), Expression(0, [])]), AssignmentExpression(=, [VariableReference(if (id !, []), Expression(null) {, [])]), MethodCall(dest.writeInt(1), [VariableReference(dest, []), Expression(1, [])]), MethodCall(dest.writeString(id), [VariableReference(dest, []), Expression(id, [])]), Statement(} else {, []), MethodCall(dest.writeInt(0), [VariableReference(dest, []), Expression(0, [])]), Statement(}, []), MethodCall(dest.writeLong(creationTime), [VariableReference(dest, []), Expression(creationTime, [])]), AssignmentExpression(=, [VariableReference(if (enabler !, []), Expression(null) {, [])]), MethodCall(dest.writeInt(1), [VariableReference(dest, []), Expression(1, [])]), MethodCall(dest.writeString(enabler), [VariableReference(dest, []), Expression(enabler, [])]), Statement(} else {, []), MethodCall(dest.writeInt(0), [VariableReference(dest, []), Expression(0, [])]), Statement(}, []), Statement(}, [])])  Statement({, [])  MethodCall(dest.writeInt(enabled ? 1 : 0), [VariableReference(dest, []), Expression(enabled ? 1 : 0, [])])    VariableReference(dest, [])    Expression(enabled ? 1 : 0, [])  MethodCall(dest.writeInt(snoozing ? 1 : 0), [VariableReference(dest, []), Expression(snoozing ? 1 : 0, [])])    VariableReference(dest, [])    Expression(snoozing ? 1 : 0, [])  AssignmentExpression(=, [VariableReference(if (name !, []), Expression(null) {, [])])    VariableReference(if (name !, [])    Expression(null) {, [])  MethodCall(dest.writeInt(1), [VariableReference(dest, []), Expression(1, [])])    VariableReference(dest, [])    Expression(1, [])  MethodCall(dest.writeString(name), [VariableReference(dest, []), Expression(name, [])])    VariableReference(dest, [])    Expression(name, [])  Statement(} else {, [])  MethodCall(dest.writeInt(0), [VariableReference(dest, []), Expression(0, [])])    VariableReference(dest, [])    Expression(0, [])  Statement(}, [])  MethodCall(dest.writeInt(zenMode), [VariableReference(dest, []), Expression(zenMode, [])])    VariableReference(dest, [])    Expression(zenMode, [])  MethodCall(dest.writeParcelable(conditionId, 0), [VariableReference(dest, []), Expression(conditionId, []), Expression(0, [])])    VariableReference(dest, [])    Expression(conditionId, [])    Expression(0, [])  MethodCall(dest.writeParcelable(condition, 0), [VariableReference(dest, []), Expression(condition, []), Expression(0, [])])    VariableReference(dest, [])    Expression(condition, [])    Expression(0, [])  MethodCall(dest.writeParcelable(component, 0), [VariableReference(dest, []), Expression(component, []), Expression(0, [])])    VariableReference(dest, [])    Expression(component, [])    Expression(0, [])  AssignmentExpression(=, [VariableReference(if (id !, []), Expression(null) {, [])])    VariableReference(if (id !, [])    Expression(null) {, [])  MethodCall(dest.writeInt(1), [VariableReference(dest, []), Expression(1, [])])    VariableReference(dest, [])    Expression(1, [])  MethodCall(dest.writeString(id), [VariableReference(dest, []), Expression(id, [])])    VariableReference(dest, [])    Expression(id, [])  Statement(} else {, [])  MethodCall(dest.writeInt(0), [VariableReference(dest, []), Expression(0, [])])    VariableReference(dest, [])    Expression(0, [])  Statement(}, [])  MethodCall(dest.writeLong(creationTime), [VariableReference(dest, []), Expression(creationTime, [])])    VariableReference(dest, [])    Expression(creationTime, [])  AssignmentExpression(=, [VariableReference(if (enabler !, []), Expression(null) {, [])])    VariableReference(if (enabler !, [])    Expression(null) {, [])  MethodCall(dest.writeInt(1), [VariableReference(dest, []), Expression(1, [])])    VariableReference(dest, [])    Expression(1, [])  MethodCall(dest.writeString(enabler), [VariableReference(dest, []), Expression(enabler, [])])    VariableReference(dest, [])    Expression(enabler, [])  Statement(} else {, [])  MethodCall(dest.writeInt(0), [VariableReference(dest, []), Expression(0, [])])    VariableReference(dest, [])    Expression(0, [])  Statement(}, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), MethodCall(dest.writeInt(enabled ? 1 : 0), [VariableReference(dest, []), Expression(enabled ? 1 : 0, [])]), MethodCall(dest.writeInt(snoozing ? 1 : 0), [VariableReference(dest, []), Expression(snoozing ? 1 : 0, [])]), AssignmentExpression(=, [VariableReference(if (name !, []), Expression(null) {, [])]), MethodCall(dest.writeInt(1), [VariableReference(dest, []), Expression(1, [])]), MethodCall(dest.writeString(name), [VariableReference(dest, []), Expression(name, [])]), Statement(} else {, []), MethodCall(dest.writeInt(0), [VariableReference(dest, []), Expression(0, [])]), Statement(}, []), MethodCall(dest.writeInt(zenMode), [VariableReference(dest, []), Expression(zenMode, [])]), MethodCall(dest.writeParcelable(conditionId, 0), [VariableReference(dest, []), Expression(conditionId, []), Expression(0, [])]), MethodCall(dest.writeParcelable(condition, 0), [VariableReference(dest, []), Expression(condition, []), Expression(0, [])]), MethodCall(dest.writeParcelable(component, 0), [VariableReference(dest, []), Expression(component, []), Expression(0, [])]), MethodCall(dest.writeParcelable(configurationActivity, 0), [VariableReference(dest, []), Expression(configurationActivity, []), Expression(0, [])]), AssignmentExpression(=, [VariableReference(if (id !, []), Expression(null) {, [])]), MethodCall(dest.writeInt(1), [VariableReference(dest, []), Expression(1, [])]), MethodCall(dest.writeString(id), [VariableReference(dest, []), Expression(id, [])]), Statement(} else {, []), MethodCall(dest.writeInt(0), [VariableReference(dest, []), Expression(0, [])]), Statement(}, []), MethodCall(dest.writeLong(creationTime), [VariableReference(dest, []), Expression(creationTime, [])]), AssignmentExpression(=, [VariableReference(if (enabler !, []), Expression(null) {, [])]), MethodCall(dest.writeInt(1), [VariableReference(dest, []), Expression(1, [])]), MethodCall(dest.writeString(enabler), [VariableReference(dest, []), Expression(enabler, [])]), Statement(} else {, []), MethodCall(dest.writeInt(0), [VariableReference(dest, []), Expression(0, [])]), Statement(}, []), MethodCall(dest.writeParcelable(zenPolicy, 0), [VariableReference(dest, []), Expression(zenPolicy, []), Expression(0, [])]), MethodCall(dest.writeInt(modified ? 1 : 0), [VariableReference(dest, []), Expression(modified ? 1 : 0, [])]), MethodCall(dest.writeString(pkg), [VariableReference(dest, []), Expression(pkg, [])]), Statement(}, [])])  Statement({, [])  MethodCall(dest.writeInt(enabled ? 1 : 0), [VariableReference(dest, []), Expression(enabled ? 1 : 0, [])])    VariableReference(dest, [])    Expression(enabled ? 1 : 0, [])  MethodCall(dest.writeInt(snoozing ? 1 : 0), [VariableReference(dest, []), Expression(snoozing ? 1 : 0, [])])    VariableReference(dest, [])    Expression(snoozing ? 1 : 0, [])  AssignmentExpression(=, [VariableReference(if (name !, []), Expression(null) {, [])])    VariableReference(if (name !, [])    Expression(null) {, [])  MethodCall(dest.writeInt(1), [VariableReference(dest, []), Expression(1, [])])    VariableReference(dest, [])    Expression(1, [])  MethodCall(dest.writeString(name), [VariableReference(dest, []), Expression(name, [])])    VariableReference(dest, [])    Expression(name, [])  Statement(} else {, [])  MethodCall(dest.writeInt(0), [VariableReference(dest, []), Expression(0, [])])    VariableReference(dest, [])    Expression(0, [])  Statement(}, [])  MethodCall(dest.writeInt(zenMode), [VariableReference(dest, []), Expression(zenMode, [])])    VariableReference(dest, [])    Expression(zenMode, [])  MethodCall(dest.writeParcelable(conditionId, 0), [VariableReference(dest, []), Expression(conditionId, []), Expression(0, [])])    VariableReference(dest, [])    Expression(conditionId, [])    Expression(0, [])  MethodCall(dest.writeParcelable(condition, 0), [VariableReference(dest, []), Expression(condition, []), Expression(0, [])])    VariableReference(dest, [])    Expression(condition, [])    Expression(0, [])  MethodCall(dest.writeParcelable(component, 0), [VariableReference(dest, []), Expression(component, []), Expression(0, [])])    VariableReference(dest, [])    Expression(component, [])    Expression(0, [])  MethodCall(dest.writeParcelable(configurationActivity, 0), [VariableReference(dest, []), Expression(configurationActivity, []), Expression(0, [])])    VariableReference(dest, [])    Expression(configurationActivity, [])    Expression(0, [])  AssignmentExpression(=, [VariableReference(if (id !, []), Expression(null) {, [])])    VariableReference(if (id !, [])    Expression(null) {, [])  MethodCall(dest.writeInt(1), [VariableReference(dest, []), Expression(1, [])])    VariableReference(dest, [])    Expression(1, [])  MethodCall(dest.writeString(id), [VariableReference(dest, []), Expression(id, [])])    VariableReference(dest, [])    Expression(id, [])  Statement(} else {, [])  MethodCall(dest.writeInt(0), [VariableReference(dest, []), Expression(0, [])])    VariableReference(dest, [])    Expression(0, [])  Statement(}, [])  MethodCall(dest.writeLong(creationTime), [VariableReference(dest, []), Expression(creationTime, [])])    VariableReference(dest, [])    Expression(creationTime, [])  AssignmentExpression(=, [VariableReference(if (enabler !, []), Expression(null) {, [])])    VariableReference(if (enabler !, [])    Expression(null) {, [])  MethodCall(dest.writeInt(1), [VariableReference(dest, []), Expression(1, [])])    VariableReference(dest, [])    Expression(1, [])  MethodCall(dest.writeString(enabler), [VariableReference(dest, []), Expression(enabler, [])])    VariableReference(dest, [])    Expression(enabler, [])  Statement(} else {, [])  MethodCall(dest.writeInt(0), [VariableReference(dest, []), Expression(0, [])])    VariableReference(dest, [])    Expression(0, [])  Statement(}, [])  MethodCall(dest.writeParcelable(zenPolicy, 0), [VariableReference(dest, []), Expression(zenPolicy, []), Expression(0, [])])    VariableReference(dest, [])    Expression(zenPolicy, [])    Expression(0, [])  MethodCall(dest.writeInt(modified ? 1 : 0), [VariableReference(dest, []), Expression(modified ? 1 : 0, [])])    VariableReference(dest, [])    Expression(modified ? 1 : 0, [])  MethodCall(dest.writeString(pkg), [VariableReference(dest, []), Expression(pkg, [])])    VariableReference(dest, [])    Expression(pkg, [])  Statement(}, [])",1,,,0,[@Override],[@Override],0,,,,1,4,0,1,1,"In the late version of the method implementation, there are additional statements: 'dest.writeParcelable(configurationActivity, 0)','dest.writeParcelable(zenPolicy, 0)','dest.writeInt(modified ? 1 : 0)', and 'dest.writeString(pkg)'. These are added write operations to the Parcel object. ","The added statements modify the content of 'Parcel dest' which is the method's return object. This results in the method potentially returning different values in the late version compared to the early version, causing a compatibility issue of type 1."
159,<android.view.View: void setAutofillId(AutofillId)>,28,29,<android.view.View: void setAutofillId(AutofillId)>,<android.view.View: void setAutofillId(AutofillId)>,0,"MethodDeclaration(method_body, [Statement({, []), Statement(// TODO(b/37566627): add unit / CTS test for all possible combinations below, []), MethodCall(Log.v(VIEW_LOG_TAG, ""setAutofill(): from "" + mAutofillId + "" to "" + id), [VariableReference(Log, []), Expression(VIEW_LOG_TAG, []), Expression(""setAutofill(): from "" + mAutofillId + "" to "" + id, [])]), Statement(}, []), Statement(if (isAttachedToWindow()) {, []), Statement(throw new IllegalStateException(""Cannot set autofill id when view is attached""), []), Statement(}, []), AssignmentExpression(=, [VariableReference(if (id !, []), Expression(null && id.isVirtual()) {, [])]), Statement(throw new IllegalStateException(""Cannot set autofill id assigned to virtual views""), []), Statement(}, []), AssignmentExpression(=, [VariableReference(if (id, []), Expression(, [])]), Statement(// Ignore reset because it was never explicitly set before., []), Statement(return, []), Statement(}, []), AssignmentExpression(=, [VariableReference(mAutofillId, []), Expression(id, [])]), AssignmentExpression(=, [VariableReference(if (id !, []), Expression(null) {, [])]), AssignmentExpression(=, [VariableReference(mAutofillViewId, []), Expression(id.getViewId(), [])]), AssignmentExpression(=, [VariableReference(mPrivateFlags3 |, []), Expression(PFLAG3_AUTOFILLID_EXPLICITLY_SET, [])]), Statement(} else {, []), AssignmentExpression(=, [VariableReference(mAutofillViewId, []), Expression(NO_ID, [])]), AssignmentExpression(=, [VariableReference(mPrivateFlags3 &, []), Expression(~PFLAG3_AUTOFILLID_EXPLICITLY_SET, [])]), Statement(}, []), Statement(}, [])])  Statement({, [])  Statement(// TODO(b/37566627): add unit / CTS test for all possible combinations below, [])  MethodCall(Log.v(VIEW_LOG_TAG, ""setAutofill(): from "" + mAutofillId + "" to "" + id), [VariableReference(Log, []), Expression(VIEW_LOG_TAG, []), Expression(""setAutofill(): from "" + mAutofillId + "" to "" + id, [])])    VariableReference(Log, [])    Expression(VIEW_LOG_TAG, [])    Expression(""setAutofill(): from "" + mAutofillId + "" to "" + id, [])  Statement(}, [])  Statement(if (isAttachedToWindow()) {, [])  Statement(throw new IllegalStateException(""Cannot set autofill id when view is attached""), [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(if (id !, []), Expression(null && id.isVirtual()) {, [])])    VariableReference(if (id !, [])    Expression(null && id.isVirtual()) {, [])  Statement(throw new IllegalStateException(""Cannot set autofill id assigned to virtual views""), [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(if (id, []), Expression(, [])])    VariableReference(if (id, [])    Expression(, [])  Statement(// Ignore reset because it was never explicitly set before., [])  Statement(return, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(mAutofillId, []), Expression(id, [])])    VariableReference(mAutofillId, [])    Expression(id, [])  AssignmentExpression(=, [VariableReference(if (id !, []), Expression(null) {, [])])    VariableReference(if (id !, [])    Expression(null) {, [])  AssignmentExpression(=, [VariableReference(mAutofillViewId, []), Expression(id.getViewId(), [])])    VariableReference(mAutofillViewId, [])    Expression(id.getViewId(), [])  AssignmentExpression(=, [VariableReference(mPrivateFlags3 |, []), Expression(PFLAG3_AUTOFILLID_EXPLICITLY_SET, [])])    VariableReference(mPrivateFlags3 |, [])    Expression(PFLAG3_AUTOFILLID_EXPLICITLY_SET, [])  Statement(} else {, [])  AssignmentExpression(=, [VariableReference(mAutofillViewId, []), Expression(NO_ID, [])])    VariableReference(mAutofillViewId, [])    Expression(NO_ID, [])  AssignmentExpression(=, [VariableReference(mPrivateFlags3 &, []), Expression(~PFLAG3_AUTOFILLID_EXPLICITLY_SET, [])])    VariableReference(mPrivateFlags3 &, [])    Expression(~PFLAG3_AUTOFILLID_EXPLICITLY_SET, [])  Statement(}, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(// TODO(b/37566627): add unit / CTS test for all possible combinations below, []), MethodCall(if (Log.isLoggable(AUTOFILL_LOG_TAG, Log.VERBOSE)), [VariableReference(if (Log, []), Expression(AUTOFILL_LOG_TAG, []), Expression(Log.VERBOSE), [])]), MethodCall(Log.v(AUTOFILL_LOG_TAG, ""setAutofill(): from "" + mAutofillId + "" to "" + id), [VariableReference(Log, []), Expression(AUTOFILL_LOG_TAG, []), Expression(""setAutofill(): from "" + mAutofillId + "" to "" + id, [])]), Statement(}, []), Statement(if (isAttachedToWindow()) {, []), Statement(throw new IllegalStateException(""Cannot set autofill id when view is attached""), []), Statement(}, []), AssignmentExpression(=, [VariableReference(if (id !, []), Expression(null && !id.isNonVirtual()) {, [])]), Statement(throw new IllegalStateException(""Cannot set autofill id assigned to virtual views""), []), Statement(}, []), AssignmentExpression(=, [VariableReference(if (id, []), Expression(, [])]), Statement(// Ignore reset because it was never explicitly set before., []), Statement(return, []), Statement(}, []), AssignmentExpression(=, [VariableReference(mAutofillId, []), Expression(id, [])]), AssignmentExpression(=, [VariableReference(if (id !, []), Expression(null) {, [])]), AssignmentExpression(=, [VariableReference(mAutofillViewId, []), Expression(id.getViewId(), [])]), AssignmentExpression(=, [VariableReference(mPrivateFlags3 |, []), Expression(PFLAG3_AUTOFILLID_EXPLICITLY_SET, [])]), Statement(} else {, []), AssignmentExpression(=, [VariableReference(mAutofillViewId, []), Expression(NO_ID, [])]), AssignmentExpression(=, [VariableReference(mPrivateFlags3 &, []), Expression(~PFLAG3_AUTOFILLID_EXPLICITLY_SET, [])]), Statement(}, []), Statement(}, [])])  Statement({, [])  Statement(// TODO(b/37566627): add unit / CTS test for all possible combinations below, [])  MethodCall(if (Log.isLoggable(AUTOFILL_LOG_TAG, Log.VERBOSE)), [VariableReference(if (Log, []), Expression(AUTOFILL_LOG_TAG, []), Expression(Log.VERBOSE), [])])    VariableReference(if (Log, [])    Expression(AUTOFILL_LOG_TAG, [])    Expression(Log.VERBOSE), [])  MethodCall(Log.v(AUTOFILL_LOG_TAG, ""setAutofill(): from "" + mAutofillId + "" to "" + id), [VariableReference(Log, []), Expression(AUTOFILL_LOG_TAG, []), Expression(""setAutofill(): from "" + mAutofillId + "" to "" + id, [])])    VariableReference(Log, [])    Expression(AUTOFILL_LOG_TAG, [])    Expression(""setAutofill(): from "" + mAutofillId + "" to "" + id, [])  Statement(}, [])  Statement(if (isAttachedToWindow()) {, [])  Statement(throw new IllegalStateException(""Cannot set autofill id when view is attached""), [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(if (id !, []), Expression(null && !id.isNonVirtual()) {, [])])    VariableReference(if (id !, [])    Expression(null && !id.isNonVirtual()) {, [])  Statement(throw new IllegalStateException(""Cannot set autofill id assigned to virtual views""), [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(if (id, []), Expression(, [])])    VariableReference(if (id, [])    Expression(, [])  Statement(// Ignore reset because it was never explicitly set before., [])  Statement(return, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(mAutofillId, []), Expression(id, [])])    VariableReference(mAutofillId, [])    Expression(id, [])  AssignmentExpression(=, [VariableReference(if (id !, []), Expression(null) {, [])])    VariableReference(if (id !, [])    Expression(null) {, [])  AssignmentExpression(=, [VariableReference(mAutofillViewId, []), Expression(id.getViewId(), [])])    VariableReference(mAutofillViewId, [])    Expression(id.getViewId(), [])  AssignmentExpression(=, [VariableReference(mPrivateFlags3 |, []), Expression(PFLAG3_AUTOFILLID_EXPLICITLY_SET, [])])    VariableReference(mPrivateFlags3 |, [])    Expression(PFLAG3_AUTOFILLID_EXPLICITLY_SET, [])  Statement(} else {, [])  AssignmentExpression(=, [VariableReference(mAutofillViewId, []), Expression(NO_ID, [])])    VariableReference(mAutofillViewId, [])    Expression(NO_ID, [])  AssignmentExpression(=, [VariableReference(mPrivateFlags3 &, []), Expression(~PFLAG3_AUTOFILLID_EXPLICITLY_SET, [])])    VariableReference(mPrivateFlags3 &, [])    Expression(~PFLAG3_AUTOFILLID_EXPLICITLY_SET, [])  Statement(}, [])  Statement(}, [])",1,"/**
 * Sets the unique, logical identifier of this view in the activity, for autofill purposes.
 *
 * <p>The autofill id is created on demand, and this method should only be called when a view is
 * reused after {@link #dispatchProvideAutofillStructure(ViewStructure, int)} is called, as
 * that method creates a snapshot of the view that is passed along to the autofill service.
 *
 * <p>This method is typically used when view subtrees are recycled to represent different
 * content* &mdash;in this case, the autofill id can be saved before the view content is swapped
 * out, and restored later when it's swapped back in. For example:
 *
 * <pre>
 * EditText reusableView = ...;
 * ViewGroup parentView = ...;
 * AutofillManager afm = ...;
 *
 * // Swap out the view and change its contents
 * AutofillId oldId = reusableView.getAutofillId();
 * CharSequence oldText = reusableView.getText();
 * parentView.removeView(reusableView);
 * AutofillId newId = afm.getNextAutofillId();
 * reusableView.setText(""New I am"");
 * reusableView.setAutofillId(newId);
 * parentView.addView(reusableView);
 *
 * // Later, swap the old content back in
 * parentView.removeView(reusableView);
 * reusableView.setAutofillId(oldId);
 * reusableView.setText(oldText);
 * parentView.addView(reusableView);
 * </pre>
 *
 * @param id an autofill ID that is unique in the {@link android.app.Activity} hosting the view,
 * or {@code null} to reset it. Usually it's an id previously allocated to another view (and
 * obtained through {@link #getAutofillId()}), or a new value obtained through
 * {@link AutofillManager#getNextAutofillId()}.
 *
 * @throws IllegalStateException if the view is already {@link #isAttachedToWindow() attached to
 * a window}.
 *
 * @throws IllegalArgumentException if the id is an autofill id associated with a virtual view.
 */","/**
 * Sets the unique, logical identifier of this view in the activity, for autofill purposes.
 *
 * <p>The autofill id is created on demand, and this method should only be called when a view is
 * reused after {@link #dispatchProvideAutofillStructure(ViewStructure, int)} is called, as
 * that method creates a snapshot of the view that is passed along to the autofill service.
 *
 * <p>This method is typically used when view subtrees are recycled to represent different
 * content* &mdash;in this case, the autofill id can be saved before the view content is swapped
 * out, and restored later when it's swapped back in. For example:
 *
 * <pre>
 * EditText reusableView = ...;
 * ViewGroup parentView = ...;
 * AutofillManager afm = ...;
 *
 * // Swap out the view and change its contents
 * AutofillId oldId = reusableView.getAutofillId();
 * CharSequence oldText = reusableView.getText();
 * parentView.removeView(reusableView);
 * AutofillId newId = afm.getNextAutofillId();
 * reusableView.setText(""New I am"");
 * reusableView.setAutofillId(newId);
 * parentView.addView(reusableView);
 *
 * // Later, swap the old content back in
 * parentView.removeView(reusableView);
 * reusableView.setAutofillId(oldId);
 * reusableView.setText(oldText);
 * parentView.addView(reusableView);
 * </pre>
 *
 * @param id an autofill ID that is unique in the {@link android.app.Activity} hosting the view,
 * or {@code null} to reset it. Usually it's an id previously allocated to another view (and
 * obtained through {@link #getAutofillId()}), or a new value obtained through
 * {@link AutofillManager#getNextAutofillId()}.
 *
 * @throws IllegalStateException if the view is already {@link #isAttachedToWindow() attached to
 * a window}.
 *
 * @throws IllegalArgumentException if the id is an autofill id associated with a virtual view.
 */",0,,,0,,,,1,3,2,"4,5",1,"There are modifications in log information, variable usage and condition statements (for example, id.isNonVirtual() in the late version replaces id.isVirtual() in the early version), so the change type is 4. Additionally, the functions such as isLoggable, isNonVirtual, etc, might have been updated leading to a change type 5.","The change in the condition statement and Log function might lead to the difference in the variable 'id' and potentially different return behaviours of this API. So, the CI type is 1."
160,<android.companion.WifiDeviceFilter.Builder: WifiDeviceFilter build()>,29,30,<android.companion.WifiDeviceFilter.Builder: WifiDeviceFilter build()>,<android.companion.WifiDeviceFilter.Builder: WifiDeviceFilter build()>,0,"MethodDeclaration(method_body, [Statement({, []), Statement(markUsed(), []), Statement(return new WifiDeviceFilter(mNamePattern), []), Statement(}, [])])  Statement({, [])  Statement(markUsed(), [])  Statement(return new WifiDeviceFilter(mNamePattern), [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(checkNotUsed(), []), Statement(// Mark builder used, []), AssignmentExpression(=, [VariableReference(mBuilderFieldsSet |, []), Expression(0x8, [])]), AssignmentExpression(=, [VariableReference(if ((mBuilderFieldsSet & 0x1), []), Expression(, [])]), AssignmentExpression(=, [VariableReference(mNamePattern, []), Expression(null, [])]), Statement(}, []), AssignmentExpression(=, [VariableReference(if ((mBuilderFieldsSet & 0x2), []), Expression(, [])]), AssignmentExpression(=, [VariableReference(mBssid, []), Expression(null, [])]), Statement(}, []), AssignmentExpression(=, [VariableReference(if ((mBuilderFieldsSet & 0x4), []), Expression(, [])]), AssignmentExpression(=, [VariableReference(mBssidMask, []), Expression(MacAddress.BROADCAST_ADDRESS, [])]), Statement(}, []), AssignmentExpression(=, [VariableReference(WifiDeviceFilter o, []), Expression(new WifiDeviceFilter(mNamePattern, mBssid, mBssidMask), [])]), Statement(return o, []), Statement(}, [])])  Statement({, [])  Statement(checkNotUsed(), [])  Statement(// Mark builder used, [])  AssignmentExpression(=, [VariableReference(mBuilderFieldsSet |, []), Expression(0x8, [])])    VariableReference(mBuilderFieldsSet |, [])    Expression(0x8, [])  AssignmentExpression(=, [VariableReference(if ((mBuilderFieldsSet & 0x1), []), Expression(, [])])    VariableReference(if ((mBuilderFieldsSet & 0x1), [])    Expression(, [])  AssignmentExpression(=, [VariableReference(mNamePattern, []), Expression(null, [])])    VariableReference(mNamePattern, [])    Expression(null, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(if ((mBuilderFieldsSet & 0x2), []), Expression(, [])])    VariableReference(if ((mBuilderFieldsSet & 0x2), [])    Expression(, [])  AssignmentExpression(=, [VariableReference(mBssid, []), Expression(null, [])])    VariableReference(mBssid, [])    Expression(null, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(if ((mBuilderFieldsSet & 0x4), []), Expression(, [])])    VariableReference(if ((mBuilderFieldsSet & 0x4), [])    Expression(, [])  AssignmentExpression(=, [VariableReference(mBssidMask, []), Expression(MacAddress.BROADCAST_ADDRESS, [])])    VariableReference(mBssidMask, [])    Expression(MacAddress.BROADCAST_ADDRESS, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(WifiDeviceFilter o, []), Expression(new WifiDeviceFilter(mNamePattern, mBssid, mBssidMask), [])])    VariableReference(WifiDeviceFilter o, [])    Expression(new WifiDeviceFilter(mNamePattern, mBssid, mBssidMask), [])  Statement(return o, [])  Statement(}, [])",1,"/**
 * @inheritDoc
 */","/**
 * Builds the instance. This builder should not be touched after calling this!
 */",1,"[@Override, @NonNull]",[@NonNull],1,,,,"1,2","1,3,4,5",1,"1,3,4",1,"Comparing early implementation with late implementation, many changes have been introduced, including the return statement change from returning 'new WifiDeviceFilter(mNamePattern)' to 'new WifiDeviceFilter(mNamePattern, mBssid, mBssidMask)'. Also a series of assignments have been added, like 'mBuilderFieldsSet |= 0x8', 'mNamePattern = null', 'mBssid = null', and 'mBssidMask= MacAddress.BROADCAST_ADDRESS', and 'WifiDeviceFilter o = new WifiDeviceFilter(mNamePattern, mBssid, mBssidMask)'. These are categorized as change type 1,3,4.","Because of the return statement change and control dependency statement change, the API could potentially give different return values in two versions and thus the CI type is 1."
161,<android.hardware.camera2.impl.CameraDeviceImpl: void tearDown(Surface)>,29,30,<android.hardware.camera2.impl.CameraDeviceImpl: void tearDown(Surface)>,<android.hardware.camera2.impl.CameraDeviceImpl: void tearDown(Surface)>,0,"MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(if (surface, []), Expression(, [])]), Statement(throw new IllegalArgumentException(""Surface is null""), []), Statement(synchronized (mInterfaceLock) {, []), AssignmentExpression(=, [VariableReference(int streamId, []), Expression(-1, [])]), AssignmentExpression(=, [VariableReference(for (int i, []), Expression(0, [])]), MethodCall(i < mConfiguredOutputs.size(), [VariableReference(i < mConfiguredOutputs, []), Expression(, [])]), Statement(i++) {, []), AssignmentExpression(=, [VariableReference(if (surface, []), Expression(, [])]), AssignmentExpression(=, [VariableReference(streamId, []), Expression(mConfiguredOutputs.keyAt(i), [])]), Statement(break, []), Statement(}, []), Statement(}, []), AssignmentExpression(=, [VariableReference(if (streamId, []), Expression(, [])]), Statement(throw new IllegalArgumentException(""Surface is not part of this session""), []), Statement(}, []), MethodCall(mRemoteDevice.tearDown(streamId), [VariableReference(mRemoteDevice, []), Expression(streamId, [])]), Statement(}, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(if (surface, []), Expression(, [])])    VariableReference(if (surface, [])    Expression(, [])  Statement(throw new IllegalArgumentException(""Surface is null""), [])  Statement(synchronized (mInterfaceLock) {, [])  AssignmentExpression(=, [VariableReference(int streamId, []), Expression(-1, [])])    VariableReference(int streamId, [])    Expression(-1, [])  AssignmentExpression(=, [VariableReference(for (int i, []), Expression(0, [])])    VariableReference(for (int i, [])    Expression(0, [])  MethodCall(i < mConfiguredOutputs.size(), [VariableReference(i < mConfiguredOutputs, []), Expression(, [])])    VariableReference(i < mConfiguredOutputs, [])    Expression(, [])  Statement(i++) {, [])  AssignmentExpression(=, [VariableReference(if (surface, []), Expression(, [])])    VariableReference(if (surface, [])    Expression(, [])  AssignmentExpression(=, [VariableReference(streamId, []), Expression(mConfiguredOutputs.keyAt(i), [])])    VariableReference(streamId, [])    Expression(mConfiguredOutputs.keyAt(i), [])  Statement(break, [])  Statement(}, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(if (streamId, []), Expression(, [])])    VariableReference(if (streamId, [])    Expression(, [])  Statement(throw new IllegalArgumentException(""Surface is not part of this session""), [])  Statement(}, [])  MethodCall(mRemoteDevice.tearDown(streamId), [VariableReference(mRemoteDevice, []), Expression(streamId, [])])    VariableReference(mRemoteDevice, [])    Expression(streamId, [])  Statement(}, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(if (surface, []), Expression(, [])]), Statement(throw new IllegalArgumentException(""Surface is null""), []), Statement(synchronized (mInterfaceLock) {, []), Statement(checkIfCameraClosedOrInError(), []), AssignmentExpression(=, [VariableReference(int streamId, []), Expression(-1, [])]), AssignmentExpression(=, [VariableReference(for (int i, []), Expression(0, [])]), MethodCall(i < mConfiguredOutputs.size(), [VariableReference(i < mConfiguredOutputs, []), Expression(, [])]), Statement(i++) {, []), AssignmentExpression(=, [VariableReference(if (surface, []), Expression(, [])]), AssignmentExpression(=, [VariableReference(streamId, []), Expression(mConfiguredOutputs.keyAt(i), [])]), Statement(break, []), Statement(}, []), Statement(}, []), AssignmentExpression(=, [VariableReference(if (streamId, []), Expression(, [])]), Statement(throw new IllegalArgumentException(""Surface is not part of this session""), []), Statement(}, []), MethodCall(mRemoteDevice.tearDown(streamId), [VariableReference(mRemoteDevice, []), Expression(streamId, [])]), Statement(}, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(if (surface, []), Expression(, [])])    VariableReference(if (surface, [])    Expression(, [])  Statement(throw new IllegalArgumentException(""Surface is null""), [])  Statement(synchronized (mInterfaceLock) {, [])  Statement(checkIfCameraClosedOrInError(), [])  AssignmentExpression(=, [VariableReference(int streamId, []), Expression(-1, [])])    VariableReference(int streamId, [])    Expression(-1, [])  AssignmentExpression(=, [VariableReference(for (int i, []), Expression(0, [])])    VariableReference(for (int i, [])    Expression(0, [])  MethodCall(i < mConfiguredOutputs.size(), [VariableReference(i < mConfiguredOutputs, []), Expression(, [])])    VariableReference(i < mConfiguredOutputs, [])    Expression(, [])  Statement(i++) {, [])  AssignmentExpression(=, [VariableReference(if (surface, []), Expression(, [])])    VariableReference(if (surface, [])    Expression(, [])  AssignmentExpression(=, [VariableReference(streamId, []), Expression(mConfiguredOutputs.keyAt(i), [])])    VariableReference(streamId, [])    Expression(mConfiguredOutputs.keyAt(i), [])  Statement(break, [])  Statement(}, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(if (streamId, []), Expression(, [])])    VariableReference(if (streamId, [])    Expression(, [])  Statement(throw new IllegalArgumentException(""Surface is not part of this session""), [])  Statement(}, [])  MethodCall(mRemoteDevice.tearDown(streamId), [VariableReference(mRemoteDevice, []), Expression(streamId, [])])    VariableReference(mRemoteDevice, [])    Expression(streamId, [])  Statement(}, [])  Statement(}, [])",1,,,0,,,0,,,,1,4,0,4,1,"The method call ""checkIfCameraClosedOrInError()"" is added into the late version, so the code change type is 4.","The call of ""checkIfCameraClosedOrInError()"" in the late version leads to a new potential behavior of the method, and it might cause the method to return a different output, so the CI type is 1."
163,<android.view.DisplayCutout: boolean equals(Object)>,29,30,<android.view.DisplayCutout: boolean equals(Object)>,<android.view.DisplayCutout: boolean equals(Object)>,0,"MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(if (o, []), Expression(, [])]), Statement(return true, []), Statement(}, []), Statement(if (o instanceof DisplayCutout) {, []), AssignmentExpression(=, [VariableReference(DisplayCutout c, []), Expression((DisplayCutout) o, [])]), MethodCall(return mSafeInsets.equals(c.mSafeInsets) && mBounds.equals(c.mBounds), [VariableReference(return mSafeInsets, []), Expression(c.mSafeInsets) && mBounds.equals(c.mBounds, [])]), Statement(}, []), Statement(return false, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(if (o, []), Expression(, [])])    VariableReference(if (o, [])    Expression(, [])  Statement(return true, [])  Statement(}, [])  Statement(if (o instanceof DisplayCutout) {, [])  AssignmentExpression(=, [VariableReference(DisplayCutout c, []), Expression((DisplayCutout) o, [])])    VariableReference(DisplayCutout c, [])    Expression((DisplayCutout) o, [])  MethodCall(return mSafeInsets.equals(c.mSafeInsets) && mBounds.equals(c.mBounds), [VariableReference(return mSafeInsets, []), Expression(c.mSafeInsets) && mBounds.equals(c.mBounds, [])])    VariableReference(return mSafeInsets, [])    Expression(c.mSafeInsets) && mBounds.equals(c.mBounds, [])  Statement(}, [])  Statement(return false, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(if (o, []), Expression(, [])]), Statement(return true, []), Statement(}, []), Statement(if (o instanceof DisplayCutout) {, []), AssignmentExpression(=, [VariableReference(DisplayCutout c, []), Expression((DisplayCutout) o, [])]), MethodCall(return mSafeInsets.equals(c.mSafeInsets) && mBounds.equals(c.mBounds) && mWaterfallInsets.equals(c.mWaterfallInsets), [VariableReference(return mSafeInsets, []), Expression(c.mSafeInsets) && mBounds.equals(c.mBounds) && mWaterfallInsets.equals(c.mWaterfallInsets, [])]), Statement(}, []), Statement(return false, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(if (o, []), Expression(, [])])    VariableReference(if (o, [])    Expression(, [])  Statement(return true, [])  Statement(}, [])  Statement(if (o instanceof DisplayCutout) {, [])  AssignmentExpression(=, [VariableReference(DisplayCutout c, []), Expression((DisplayCutout) o, [])])    VariableReference(DisplayCutout c, [])    Expression((DisplayCutout) o, [])  MethodCall(return mSafeInsets.equals(c.mSafeInsets) && mBounds.equals(c.mBounds) && mWaterfallInsets.equals(c.mWaterfallInsets), [VariableReference(return mSafeInsets, []), Expression(c.mSafeInsets) && mBounds.equals(c.mBounds) && mWaterfallInsets.equals(c.mWaterfallInsets, [])])    VariableReference(return mSafeInsets, [])    Expression(c.mSafeInsets) && mBounds.equals(c.mBounds) && mWaterfallInsets.equals(c.mWaterfallInsets, [])  Statement(}, [])  Statement(return false, [])  Statement(}, [])",1,,,0,[@Override],[@Override],0,,,,1,1,1,1,1,"In the method's return statement, a condition (mWaterfallInsets.equals(c.mWaterfallInsets)) is added, so the code change type is 1.","As the added condition in the return statement will potentially lead to this function returning a different value, the CI type is 1."
165,<android.net.TrafficStats: long getUidTxPackets(int)>,29,30,<android.net.TrafficStats: long getUidTxPackets(int)>,<android.net.TrafficStats: long getUidTxPackets(int)>,0,"MethodDeclaration(method_body, [Statement({, []), Statement(// This isn't actually enforcing any security, []), Statement(it just returns the, []), Statement(// unsupported value. The real filtering is done at the kernel level., []), AssignmentExpression(=, [VariableReference(final int callingUid, []), Expression(android.os.Process.myUid(), [])]), AssignmentExpression(=, [VariableReference(if (callingUid, []), Expression(, [])]), Statement(try {, []), MethodCall(return getStatsService().getUidStats(uid, TYPE_TX_PACKETS), [VariableReference(return getStatsService(), []), Expression(uid, []), Expression(TYPE_TX_PACKETS, [])]), Statement(} catch (RemoteException e) {, []), MethodCall(throw e.rethrowFromSystemServer(), [VariableReference(throw e, []), Expression(, [])]), Statement(}, []), Statement(} else {, []), Statement(return UNSUPPORTED, []), Statement(}, []), Statement(}, [])])  Statement({, [])  Statement(// This isn't actually enforcing any security, [])  Statement(it just returns the, [])  Statement(// unsupported value. The real filtering is done at the kernel level., [])  AssignmentExpression(=, [VariableReference(final int callingUid, []), Expression(android.os.Process.myUid(), [])])    VariableReference(final int callingUid, [])    Expression(android.os.Process.myUid(), [])  AssignmentExpression(=, [VariableReference(if (callingUid, []), Expression(, [])])    VariableReference(if (callingUid, [])    Expression(, [])  Statement(try {, [])  MethodCall(return getStatsService().getUidStats(uid, TYPE_TX_PACKETS), [VariableReference(return getStatsService(), []), Expression(uid, []), Expression(TYPE_TX_PACKETS, [])])    VariableReference(return getStatsService(), [])    Expression(uid, [])    Expression(TYPE_TX_PACKETS, [])  Statement(} catch (RemoteException e) {, [])  MethodCall(throw e.rethrowFromSystemServer(), [VariableReference(throw e, []), Expression(, [])])    VariableReference(throw e, [])    Expression(, [])  Statement(}, [])  Statement(} else {, [])  Statement(return UNSUPPORTED, [])  Statement(}, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(try {, []), MethodCall(return getStatsService().getUidStats(uid, TYPE_TX_PACKETS), [VariableReference(return getStatsService(), []), Expression(uid, []), Expression(TYPE_TX_PACKETS, [])]), Statement(} catch (RemoteException e) {, []), MethodCall(throw e.rethrowFromSystemServer(), [VariableReference(throw e, []), Expression(, [])]), Statement(}, []), Statement(}, [])])  Statement({, [])  Statement(try {, [])  MethodCall(return getStatsService().getUidStats(uid, TYPE_TX_PACKETS), [VariableReference(return getStatsService(), []), Expression(uid, []), Expression(TYPE_TX_PACKETS, [])])    VariableReference(return getStatsService(), [])    Expression(uid, [])    Expression(TYPE_TX_PACKETS, [])  Statement(} catch (RemoteException e) {, [])  MethodCall(throw e.rethrowFromSystemServer(), [VariableReference(throw e, []), Expression(, [])])    VariableReference(throw e, [])    Expression(, [])  Statement(}, [])  Statement(}, [])",1,"/**
 * Return number of packets transmitted by the given UID since device boot.
 * Counts packets across all network interfaces, and always increases
 * monotonically since device boot. Statistics are measured at the network
 * layer, so they include both TCP and UDP usage.
 * <p>
 * Before {@link android.os.Build.VERSION_CODES#JELLY_BEAN_MR2}, this may return
 * {@link #UNSUPPORTED} on devices where statistics aren't available.
 * <p>
 * Starting in {@link android.os.Build.VERSION_CODES#N} this will only
 * report traffic statistics for the calling UID. It will return
 * {@link #UNSUPPORTED} for all other UIDs for privacy reasons. To access
 * historical network statistics belonging to other UIDs, use
 * {@link NetworkStatsManager}.
 *
 * @see android.os.Process#myUid()
 * @see android.content.pm.ApplicationInfo#uid
 */","/**
 * Return number of packets transmitted by the given UID since device boot.
 * Counts packets across all network interfaces, and always increases
 * monotonically since device boot. Statistics are measured at the network
 * layer, so they include both TCP and UDP usage.
 * <p>
 * Before {@link android.os.Build.VERSION_CODES#JELLY_BEAN_MR2}, this may return
 * {@link #UNSUPPORTED} on devices where statistics aren't available.
 * <p>
 * Starting in {@link android.os.Build.VERSION_CODES#N} this will only
 * report traffic statistics for the calling UID. It will return
 * {@link #UNSUPPORTED} for all other UIDs for privacy reasons. To access
 * historical network statistics belonging to other UIDs, use
 * {@link NetworkStatsManager}.
 *
 * @see android.os.Process#myUid()
 * @see android.content.pm.ApplicationInfo#uid
 */",0,,,0,,,,"1,2","1,2,3,4","1,2","1,3,4",1,"The control dependency (if statement) and some statements in the method body are deleted while the return statement is kept same, so the code change type is 1,3,4.","Since the control flow was removed, it changes when and under which circumstances the return statement is executed which potentially leads to different return values. Thus, the CI type is 1."
166,<android.security.keystore.recovery.KeyChainProtectionParams.Builder: KeyChainProtectionParams build()>,29,30,<android.security.keystore.recovery.KeyChainProtectionParams.Builder: KeyChainProtectionParams build()>,<android.security.keystore.recovery.KeyChainProtectionParams.Builder: KeyChainProtectionParams build()>,0,"MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(if (mInstance.mUserSecretType, []), Expression(, [])]), AssignmentExpression(=, [VariableReference(mInstance.mUserSecretType, []), Expression(TYPE_LOCKSCREEN, [])]), Statement(}, []), MethodCall(Preconditions.checkNotNull(mInstance.mLockScreenUiFormat), [VariableReference(Preconditions, []), Expression(mInstance.mLockScreenUiFormat, [])]), MethodCall(Preconditions.checkNotNull(mInstance.mKeyDerivationParams), [VariableReference(Preconditions, []), Expression(mInstance.mKeyDerivationParams, [])]), AssignmentExpression(=, [VariableReference(if (mInstance.mSecret, []), Expression(, [])]), AssignmentExpression(=, [VariableReference(mInstance.mSecret, []), Expression(new byte[] {}, [])]), Statement(}, []), Statement(return mInstance, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(if (mInstance.mUserSecretType, []), Expression(, [])])    VariableReference(if (mInstance.mUserSecretType, [])    Expression(, [])  AssignmentExpression(=, [VariableReference(mInstance.mUserSecretType, []), Expression(TYPE_LOCKSCREEN, [])])    VariableReference(mInstance.mUserSecretType, [])    Expression(TYPE_LOCKSCREEN, [])  Statement(}, [])  MethodCall(Preconditions.checkNotNull(mInstance.mLockScreenUiFormat), [VariableReference(Preconditions, []), Expression(mInstance.mLockScreenUiFormat, [])])    VariableReference(Preconditions, [])    Expression(mInstance.mLockScreenUiFormat, [])  MethodCall(Preconditions.checkNotNull(mInstance.mKeyDerivationParams), [VariableReference(Preconditions, []), Expression(mInstance.mKeyDerivationParams, [])])    VariableReference(Preconditions, [])    Expression(mInstance.mKeyDerivationParams, [])  AssignmentExpression(=, [VariableReference(if (mInstance.mSecret, []), Expression(, [])])    VariableReference(if (mInstance.mSecret, [])    Expression(, [])  AssignmentExpression(=, [VariableReference(mInstance.mSecret, []), Expression(new byte[] {}, [])])    VariableReference(mInstance.mSecret, [])    Expression(new byte[] {}, [])  Statement(}, [])  Statement(return mInstance, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(if (mInstance.mUserSecretType, []), Expression(, [])]), AssignmentExpression(=, [VariableReference(mInstance.mUserSecretType, []), Expression(TYPE_LOCKSCREEN, [])]), Statement(}, []), MethodCall(Objects.requireNonNull(mInstance.mLockScreenUiFormat), [VariableReference(Objects, []), Expression(mInstance.mLockScreenUiFormat, [])]), MethodCall(Objects.requireNonNull(mInstance.mKeyDerivationParams), [VariableReference(Objects, []), Expression(mInstance.mKeyDerivationParams, [])]), AssignmentExpression(=, [VariableReference(if (mInstance.mSecret, []), Expression(, [])]), AssignmentExpression(=, [VariableReference(mInstance.mSecret, []), Expression(new byte[] {}, [])]), Statement(}, []), Statement(return mInstance, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(if (mInstance.mUserSecretType, []), Expression(, [])])    VariableReference(if (mInstance.mUserSecretType, [])    Expression(, [])  AssignmentExpression(=, [VariableReference(mInstance.mUserSecretType, []), Expression(TYPE_LOCKSCREEN, [])])    VariableReference(mInstance.mUserSecretType, [])    Expression(TYPE_LOCKSCREEN, [])  Statement(}, [])  MethodCall(Objects.requireNonNull(mInstance.mLockScreenUiFormat), [VariableReference(Objects, []), Expression(mInstance.mLockScreenUiFormat, [])])    VariableReference(Objects, [])    Expression(mInstance.mLockScreenUiFormat, [])  MethodCall(Objects.requireNonNull(mInstance.mKeyDerivationParams), [VariableReference(Objects, []), Expression(mInstance.mKeyDerivationParams, [])])    VariableReference(Objects, [])    Expression(mInstance.mKeyDerivationParams, [])  AssignmentExpression(=, [VariableReference(if (mInstance.mSecret, []), Expression(, [])])    VariableReference(if (mInstance.mSecret, [])    Expression(, [])  AssignmentExpression(=, [VariableReference(mInstance.mSecret, []), Expression(new byte[] {}, [])])    VariableReference(mInstance.mSecret, [])    Expression(new byte[] {}, [])  Statement(}, [])  Statement(return mInstance, [])  Statement(}, [])",1,"/**
 * Creates a new {@link KeyChainProtectionParams} instance.
 * The instance will include default values, if {@link #setSecret}
 * or {@link #setUserSecretType} were not called.
 *
 * @return new instance
 * @throws NullPointerException if some required fields were not set.
 */
","/**
 * Creates a new {@link KeyChainProtectionParams} instance.
 * The instance will include default values, if {@link #setSecret}
 * or {@link #setUserSecretType} were not called.
 *
 * @return new instance
 * @throws NullPointerException if some required fields were not set.
 */
",0,[@NonNull],[@NonNull],0,,,,1,5,0,5,0,"The dependent APIs 'Preconditions.checkNotNull' has been replaced with 'Objects.requireNonNull', indicating the change belongs to type 5.",There is no Compatibility Issue as both dependent APIs perform the same operation and there's no change in the potential return value of the function or exception handling.
167,<android.app.ContextImpl: Context createContextForSplit(String)>,29,30,<android.app.ContextImpl: Context createContextForSplit(String)>,<android.app.ContextImpl: Context createContextForSplit(String)>,0,"MethodDeclaration(method_body, [Statement({, []), MethodCall(if (!mPackageInfo.getApplicationInfo().requestsIsolatedSplitLoading()), [VariableReference(if (!mPackageInfo, []), Expression().requestsIsolatedSplitLoading(), [])]), Statement(// All Splits are always loaded., []), Statement(return this, []), Statement(}, []), AssignmentExpression(=, [VariableReference(final ClassLoader classLoader, []), Expression(mPackageInfo.getSplitClassLoader(splitName), [])]), AssignmentExpression(=, [VariableReference(final String[] paths, []), Expression(mPackageInfo.getSplitPaths(splitName), [])]), AssignmentExpression(=, [VariableReference(final ContextImpl context, []), Expression(new ContextImpl(this, mMainThread, mPackageInfo, splitName, mActivityToken, mUser, mFlags, classLoader, null), [])]), AssignmentExpression(=, [VariableReference(final int displayId, []), Expression(getDisplayId(), [])]), MethodCall(context.setResources(ResourcesManager.getInstance().getResources(mActivityToken, mPackageInfo.getResDir(), paths, mPackageInfo.getOverlayDirs(), mPackageInfo.getApplicationInfo().sharedLibraryFiles, displayId, null, mPackageInfo.getCompatibilityInfo(), classLoader)), [VariableReference(context, []), Expression(ResourcesManager.getInstance().getResources(mActivityToken, []), Expression(mPackageInfo.getResDir(), []), Expression(paths, []), Expression(mPackageInfo.getOverlayDirs(), []), Expression(mPackageInfo.getApplicationInfo().sharedLibraryFiles, []), Expression(displayId, []), Expression(null, []), Expression(mPackageInfo.getCompatibilityInfo(), []), Expression(classLoader), [])]), Statement(return context, []), Statement(}, [])])  Statement({, [])  MethodCall(if (!mPackageInfo.getApplicationInfo().requestsIsolatedSplitLoading()), [VariableReference(if (!mPackageInfo, []), Expression().requestsIsolatedSplitLoading(), [])])    VariableReference(if (!mPackageInfo, [])    Expression().requestsIsolatedSplitLoading(), [])  Statement(// All Splits are always loaded., [])  Statement(return this, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(final ClassLoader classLoader, []), Expression(mPackageInfo.getSplitClassLoader(splitName), [])])    VariableReference(final ClassLoader classLoader, [])    Expression(mPackageInfo.getSplitClassLoader(splitName), [])  AssignmentExpression(=, [VariableReference(final String[] paths, []), Expression(mPackageInfo.getSplitPaths(splitName), [])])    VariableReference(final String[] paths, [])    Expression(mPackageInfo.getSplitPaths(splitName), [])  AssignmentExpression(=, [VariableReference(final ContextImpl context, []), Expression(new ContextImpl(this, mMainThread, mPackageInfo, splitName, mActivityToken, mUser, mFlags, classLoader, null), [])])    VariableReference(final ContextImpl context, [])    Expression(new ContextImpl(this, mMainThread, mPackageInfo, splitName, mActivityToken, mUser, mFlags, classLoader, null), [])  AssignmentExpression(=, [VariableReference(final int displayId, []), Expression(getDisplayId(), [])])    VariableReference(final int displayId, [])    Expression(getDisplayId(), [])  MethodCall(context.setResources(ResourcesManager.getInstance().getResources(mActivityToken, mPackageInfo.getResDir(), paths, mPackageInfo.getOverlayDirs(), mPackageInfo.getApplicationInfo().sharedLibraryFiles, displayId, null, mPackageInfo.getCompatibilityInfo(), classLoader)), [VariableReference(context, []), Expression(ResourcesManager.getInstance().getResources(mActivityToken, []), Expression(mPackageInfo.getResDir(), []), Expression(paths, []), Expression(mPackageInfo.getOverlayDirs(), []), Expression(mPackageInfo.getApplicationInfo().sharedLibraryFiles, []), Expression(displayId, []), Expression(null, []), Expression(mPackageInfo.getCompatibilityInfo(), []), Expression(classLoader), [])])    VariableReference(context, [])    Expression(ResourcesManager.getInstance().getResources(mActivityToken, [])    Expression(mPackageInfo.getResDir(), [])    Expression(paths, [])    Expression(mPackageInfo.getOverlayDirs(), [])    Expression(mPackageInfo.getApplicationInfo().sharedLibraryFiles, [])    Expression(displayId, [])    Expression(null, [])    Expression(mPackageInfo.getCompatibilityInfo(), [])    Expression(classLoader), [])  Statement(return context, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), MethodCall(if (!mPackageInfo.getApplicationInfo().requestsIsolatedSplitLoading()), [VariableReference(if (!mPackageInfo, []), Expression().requestsIsolatedSplitLoading(), [])]), Statement(// All Splits are always loaded., []), Statement(return this, []), Statement(}, []), AssignmentExpression(=, [VariableReference(final ClassLoader classLoader, []), Expression(mPackageInfo.getSplitClassLoader(splitName), [])]), AssignmentExpression(=, [VariableReference(final String[] paths, []), Expression(mPackageInfo.getSplitPaths(splitName), [])]), AssignmentExpression(=, [VariableReference(final ContextImpl context, []), Expression(new ContextImpl(this, mMainThread, mPackageInfo, mAttributionTag, splitName, mToken, mUser, mFlags, classLoader, null), [])]), AssignmentExpression(=, [VariableReference(final int displayId, []), Expression(getDisplayId(), [])]), MethodCall(context.setResources(ResourcesManager.getInstance().getResources(mToken, mPackageInfo.getResDir(), paths, mPackageInfo.getOverlayDirs(), mPackageInfo.getApplicationInfo().sharedLibraryFiles, displayId, null, mPackageInfo.getCompatibilityInfo(), classLoader, mResources.getLoaders())), [VariableReference(context, []), Expression(ResourcesManager.getInstance().getResources(mToken, []), Expression(mPackageInfo.getResDir(), []), Expression(paths, []), Expression(mPackageInfo.getOverlayDirs(), []), Expression(mPackageInfo.getApplicationInfo().sharedLibraryFiles, []), Expression(displayId, []), Expression(null, []), Expression(mPackageInfo.getCompatibilityInfo(), []), Expression(classLoader, []), Expression(mResources.getLoaders()), [])]), Statement(return context, []), Statement(}, [])])  Statement({, [])  MethodCall(if (!mPackageInfo.getApplicationInfo().requestsIsolatedSplitLoading()), [VariableReference(if (!mPackageInfo, []), Expression().requestsIsolatedSplitLoading(), [])])    VariableReference(if (!mPackageInfo, [])    Expression().requestsIsolatedSplitLoading(), [])  Statement(// All Splits are always loaded., [])  Statement(return this, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(final ClassLoader classLoader, []), Expression(mPackageInfo.getSplitClassLoader(splitName), [])])    VariableReference(final ClassLoader classLoader, [])    Expression(mPackageInfo.getSplitClassLoader(splitName), [])  AssignmentExpression(=, [VariableReference(final String[] paths, []), Expression(mPackageInfo.getSplitPaths(splitName), [])])    VariableReference(final String[] paths, [])    Expression(mPackageInfo.getSplitPaths(splitName), [])  AssignmentExpression(=, [VariableReference(final ContextImpl context, []), Expression(new ContextImpl(this, mMainThread, mPackageInfo, mAttributionTag, splitName, mToken, mUser, mFlags, classLoader, null), [])])    VariableReference(final ContextImpl context, [])    Expression(new ContextImpl(this, mMainThread, mPackageInfo, mAttributionTag, splitName, mToken, mUser, mFlags, classLoader, null), [])  AssignmentExpression(=, [VariableReference(final int displayId, []), Expression(getDisplayId(), [])])    VariableReference(final int displayId, [])    Expression(getDisplayId(), [])  MethodCall(context.setResources(ResourcesManager.getInstance().getResources(mToken, mPackageInfo.getResDir(), paths, mPackageInfo.getOverlayDirs(), mPackageInfo.getApplicationInfo().sharedLibraryFiles, displayId, null, mPackageInfo.getCompatibilityInfo(), classLoader, mResources.getLoaders())), [VariableReference(context, []), Expression(ResourcesManager.getInstance().getResources(mToken, []), Expression(mPackageInfo.getResDir(), []), Expression(paths, []), Expression(mPackageInfo.getOverlayDirs(), []), Expression(mPackageInfo.getApplicationInfo().sharedLibraryFiles, []), Expression(displayId, []), Expression(null, []), Expression(mPackageInfo.getCompatibilityInfo(), []), Expression(classLoader, []), Expression(mResources.getLoaders()), [])])    VariableReference(context, [])    Expression(ResourcesManager.getInstance().getResources(mToken, [])    Expression(mPackageInfo.getResDir(), [])    Expression(paths, [])    Expression(mPackageInfo.getOverlayDirs(), [])    Expression(mPackageInfo.getApplicationInfo().sharedLibraryFiles, [])    Expression(displayId, [])    Expression(null, [])    Expression(mPackageInfo.getCompatibilityInfo(), [])    Expression(classLoader, [])    Expression(mResources.getLoaders()), [])  Statement(return context, [])  Statement(}, [])",1,,,0,[@Override],[@Override],0,,,,"1,2",4,1,"1,4",1,"In the late version, a new parameter (mAttributionTag) has been added to the function ""ContextImpl()"", and a later method call ""context.setResources()"" includes the addition of the function ""mResources.getLoaders()"". Hence, the changes belong to categories 1 and 4.","The newly added parameter and function can potentially change the return value of the method, causing the API to behave differently. Hence, this is a Compatibility Issue of type 1."
168,"<android.content.ContentResolver: boolean refresh(Uri,Bundle,CancellationSignal)>",29,30,"<android.content.ContentResolver: boolean refresh(Uri,Bundle,CancellationSignal)>","<android.content.ContentResolver: boolean refresh(Uri,Bundle,CancellationSignal)>",0,"MethodDeclaration(method_body, [Statement({, []), MethodCall(Preconditions.checkNotNull(url, ""url""), [VariableReference(Preconditions, []), Expression(url, []), Expression(""url"", [])]), Statement(try {, []), AssignmentExpression(=, [VariableReference(if (mWrapped !, []), Expression(null), [])]), MethodCall(return mWrapped.refresh(url, args, cancellationSignal), [VariableReference(return mWrapped, []), Expression(url, []), Expression(args, []), Expression(cancellationSignal, [])]), Statement(} catch (RemoteException e) {, []), Statement(return false, []), Statement(}, []), AssignmentExpression(=, [VariableReference(IContentProvider provider, []), Expression(acquireProvider(url), [])]), AssignmentExpression(=, [VariableReference(if (provider, []), Expression(, [])]), Statement(return false, []), Statement(}, []), Statement(try {, []), AssignmentExpression(=, [VariableReference(ICancellationSignal remoteCancellationSignal, []), Expression(null, [])]), AssignmentExpression(=, [VariableReference(if (cancellationSignal !, []), Expression(null) {, [])]), MethodCall(cancellationSignal.throwIfCanceled(), [VariableReference(cancellationSignal, []), Expression(, [])]), AssignmentExpression(=, [VariableReference(remoteCancellationSignal, []), Expression(provider.createCancellationSignal(), [])]), MethodCall(cancellationSignal.setRemote(remoteCancellationSignal), [VariableReference(cancellationSignal, []), Expression(remoteCancellationSignal, [])]), Statement(}, []), MethodCall(return provider.refresh(mPackageName, url, args, remoteCancellationSignal), [VariableReference(return provider, []), Expression(mPackageName, []), Expression(url, []), Expression(args, []), Expression(remoteCancellationSignal, [])]), Statement(} catch (RemoteException e) {, []), Statement(// Manager will kill this process shortly anyway., []), Statement(return false, []), Statement(} finally {, []), Statement(releaseProvider(provider), []), Statement(}, []), Statement(}, [])])  Statement({, [])  MethodCall(Preconditions.checkNotNull(url, ""url""), [VariableReference(Preconditions, []), Expression(url, []), Expression(""url"", [])])    VariableReference(Preconditions, [])    Expression(url, [])    Expression(""url"", [])  Statement(try {, [])  AssignmentExpression(=, [VariableReference(if (mWrapped !, []), Expression(null), [])])    VariableReference(if (mWrapped !, [])    Expression(null), [])  MethodCall(return mWrapped.refresh(url, args, cancellationSignal), [VariableReference(return mWrapped, []), Expression(url, []), Expression(args, []), Expression(cancellationSignal, [])])    VariableReference(return mWrapped, [])    Expression(url, [])    Expression(args, [])    Expression(cancellationSignal, [])  Statement(} catch (RemoteException e) {, [])  Statement(return false, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(IContentProvider provider, []), Expression(acquireProvider(url), [])])    VariableReference(IContentProvider provider, [])    Expression(acquireProvider(url), [])  AssignmentExpression(=, [VariableReference(if (provider, []), Expression(, [])])    VariableReference(if (provider, [])    Expression(, [])  Statement(return false, [])  Statement(}, [])  Statement(try {, [])  AssignmentExpression(=, [VariableReference(ICancellationSignal remoteCancellationSignal, []), Expression(null, [])])    VariableReference(ICancellationSignal remoteCancellationSignal, [])    Expression(null, [])  AssignmentExpression(=, [VariableReference(if (cancellationSignal !, []), Expression(null) {, [])])    VariableReference(if (cancellationSignal !, [])    Expression(null) {, [])  MethodCall(cancellationSignal.throwIfCanceled(), [VariableReference(cancellationSignal, []), Expression(, [])])    VariableReference(cancellationSignal, [])    Expression(, [])  AssignmentExpression(=, [VariableReference(remoteCancellationSignal, []), Expression(provider.createCancellationSignal(), [])])    VariableReference(remoteCancellationSignal, [])    Expression(provider.createCancellationSignal(), [])  MethodCall(cancellationSignal.setRemote(remoteCancellationSignal), [VariableReference(cancellationSignal, []), Expression(remoteCancellationSignal, [])])    VariableReference(cancellationSignal, [])    Expression(remoteCancellationSignal, [])  Statement(}, [])  MethodCall(return provider.refresh(mPackageName, url, args, remoteCancellationSignal), [VariableReference(return provider, []), Expression(mPackageName, []), Expression(url, []), Expression(args, []), Expression(remoteCancellationSignal, [])])    VariableReference(return provider, [])    Expression(mPackageName, [])    Expression(url, [])    Expression(args, [])    Expression(remoteCancellationSignal, [])  Statement(} catch (RemoteException e) {, [])  Statement(// Manager will kill this process shortly anyway., [])  Statement(return false, [])  Statement(} finally {, [])  Statement(releaseProvider(provider), [])  Statement(}, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), MethodCall(Objects.requireNonNull(url, ""url""), [VariableReference(Objects, []), Expression(url, []), Expression(""url"", [])]), Statement(try {, []), AssignmentExpression(=, [VariableReference(if (mWrapped !, []), Expression(null), [])]), MethodCall(return mWrapped.refresh(url, extras, cancellationSignal), [VariableReference(return mWrapped, []), Expression(url, []), Expression(extras, []), Expression(cancellationSignal, [])]), Statement(} catch (RemoteException e) {, []), Statement(return false, []), Statement(}, []), AssignmentExpression(=, [VariableReference(IContentProvider provider, []), Expression(acquireProvider(url), [])]), AssignmentExpression(=, [VariableReference(if (provider, []), Expression(, [])]), Statement(return false, []), Statement(}, []), Statement(try {, []), AssignmentExpression(=, [VariableReference(ICancellationSignal remoteCancellationSignal, []), Expression(null, [])]), AssignmentExpression(=, [VariableReference(if (cancellationSignal !, []), Expression(null) {, [])]), MethodCall(cancellationSignal.throwIfCanceled(), [VariableReference(cancellationSignal, []), Expression(, [])]), AssignmentExpression(=, [VariableReference(remoteCancellationSignal, []), Expression(provider.createCancellationSignal(), [])]), MethodCall(cancellationSignal.setRemote(remoteCancellationSignal), [VariableReference(cancellationSignal, []), Expression(remoteCancellationSignal, [])]), Statement(}, []), MethodCall(return provider.refresh(mPackageName, mAttributionTag, url, extras, remoteCancellationSignal), [VariableReference(return provider, []), Expression(mPackageName, []), Expression(mAttributionTag, []), Expression(url, []), Expression(extras, []), Expression(remoteCancellationSignal, [])]), Statement(} catch (RemoteException e) {, []), Statement(// Manager will kill this process shortly anyway., []), Statement(return false, []), Statement(} finally {, []), Statement(releaseProvider(provider), []), Statement(}, []), Statement(}, [])])  Statement({, [])  MethodCall(Objects.requireNonNull(url, ""url""), [VariableReference(Objects, []), Expression(url, []), Expression(""url"", [])])    VariableReference(Objects, [])    Expression(url, [])    Expression(""url"", [])  Statement(try {, [])  AssignmentExpression(=, [VariableReference(if (mWrapped !, []), Expression(null), [])])    VariableReference(if (mWrapped !, [])    Expression(null), [])  MethodCall(return mWrapped.refresh(url, extras, cancellationSignal), [VariableReference(return mWrapped, []), Expression(url, []), Expression(extras, []), Expression(cancellationSignal, [])])    VariableReference(return mWrapped, [])    Expression(url, [])    Expression(extras, [])    Expression(cancellationSignal, [])  Statement(} catch (RemoteException e) {, [])  Statement(return false, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(IContentProvider provider, []), Expression(acquireProvider(url), [])])    VariableReference(IContentProvider provider, [])    Expression(acquireProvider(url), [])  AssignmentExpression(=, [VariableReference(if (provider, []), Expression(, [])])    VariableReference(if (provider, [])    Expression(, [])  Statement(return false, [])  Statement(}, [])  Statement(try {, [])  AssignmentExpression(=, [VariableReference(ICancellationSignal remoteCancellationSignal, []), Expression(null, [])])    VariableReference(ICancellationSignal remoteCancellationSignal, [])    Expression(null, [])  AssignmentExpression(=, [VariableReference(if (cancellationSignal !, []), Expression(null) {, [])])    VariableReference(if (cancellationSignal !, [])    Expression(null) {, [])  MethodCall(cancellationSignal.throwIfCanceled(), [VariableReference(cancellationSignal, []), Expression(, [])])    VariableReference(cancellationSignal, [])    Expression(, [])  AssignmentExpression(=, [VariableReference(remoteCancellationSignal, []), Expression(provider.createCancellationSignal(), [])])    VariableReference(remoteCancellationSignal, [])    Expression(provider.createCancellationSignal(), [])  MethodCall(cancellationSignal.setRemote(remoteCancellationSignal), [VariableReference(cancellationSignal, []), Expression(remoteCancellationSignal, [])])    VariableReference(cancellationSignal, [])    Expression(remoteCancellationSignal, [])  Statement(}, [])  MethodCall(return provider.refresh(mPackageName, mAttributionTag, url, extras, remoteCancellationSignal), [VariableReference(return provider, []), Expression(mPackageName, []), Expression(mAttributionTag, []), Expression(url, []), Expression(extras, []), Expression(remoteCancellationSignal, [])])    VariableReference(return provider, [])    Expression(mPackageName, [])    Expression(mAttributionTag, [])    Expression(url, [])    Expression(extras, [])    Expression(remoteCancellationSignal, [])  Statement(} catch (RemoteException e) {, [])  Statement(// Manager will kill this process shortly anyway., [])  Statement(return false, [])  Statement(} finally {, [])  Statement(releaseProvider(provider), [])  Statement(}, [])  Statement(}, [])",1,"/**
 * This allows clients to request an explicit refresh of content identified by {@code uri}.
 * <p>
 * Client code should only invoke this method when there is a strong indication (such as a user
 * initiated pull to refresh gesture) that the content is stale.
 * <p>
 *
 * @param url The Uri identifying the data to refresh.
 * @param args Additional options from the client. The definitions of these are specific to the
 * content provider being called.
 * @param cancellationSignal A signal to cancel the operation in progress, or {@code null} if
 * none. For example, if you called refresh on a particular uri, you should call
 * {@link CancellationSignal#throwIfCanceled()} to check whether the client has
 * canceled the refresh request.
 * @return true if the provider actually tried refreshing.
 */
","/**
 * This allows clients to request an explicit refresh of content identified
 * by {@code uri}.
 * <p>
 * Client code should only invoke this method when there is a strong
 * indication (such as a user initiated pull to refresh gesture) that the
 * content is stale.
 * <p>
 *
 * @param url The Uri identifying the data to refresh.
 * @param extras Additional options from the client. The definitions of
 * these are specific to the content provider being called.
 * @param cancellationSignal A signal to cancel the operation in progress,
 * or {@code null} if none. For example, if you called refresh on
 * a particular uri, you should call
 * {@link CancellationSignal#throwIfCanceled()} to check whether
 * the client has canceled the refresh request.
 * @return true if the provider actually tried refreshing.
 */
",1,[@Override],[@Override],0,,,,"1,2","1,4,5",1,"1,5",1,"The return statement in the method implementation has been modified where the method call mWrapped.refresh(url, args, cancellationSignal) is changed to mWrapped.refresh(url, extras, cancellationSignal) in the first try catch block and provider.refresh(mPackageName, url, args, remoteCancellationSignal) is modified to provider.refresh(mPackageName, mAttributionTag, url, extras, remoteCancellationSignal) in the second try catch block which indicates a change in arguments passed to the method indicating a change in dependency, so the code change type is 1, 5.","The change in the return statement and dependent API modification might lead the API to return a different value, so the CI type is 1."
170,<android.database.sqlite.SQLiteQueryBuilder: boolean isStrict()>,29,30,<android.database.sqlite.SQLiteQueryBuilder: boolean isStrict()>,<android.database.sqlite.SQLiteQueryBuilder: boolean isStrict()>,0,"MethodDeclaration(method_body, [Statement({, []), Statement(return mStrict, []), Statement(}, [])])  Statement({, [])  Statement(return mStrict, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(return (mStrictFlags & STRICT_PARENTHESES) !, []), Expression(0, [])]), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(return (mStrictFlags & STRICT_PARENTHESES) !, []), Expression(0, [])])    VariableReference(return (mStrictFlags & STRICT_PARENTHESES) !, [])    Expression(0, [])  Statement(}, [])",1,"/**
 * Get if the query is marked as strict, as last configured by
 * {@link #setStrict(boolean)}.
 */
","/**
 * Get if the query is marked as strict, as last configured by
 * {@link #setStrict(boolean)}.
 */
",0,,,0,,,,1,1,1,1,1,The change occurs in the return statement from simply returning a property (mStrict) to returning a more complicated expression involving bitwise operations on a possibly different property (mStrictFlags). So the code change type is 1.,"This change can potentially cause the method to return a different value, thus creating a compatibility issue of type 1."
171,<android.view.View: View getRootView()>,31,32,<android.view.View: View getRootView()>,<android.view.View: View getRootView()>,0,"MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(if (mAttachInfo !, []), Expression(null) {, [])]), AssignmentExpression(=, [VariableReference(final View v, []), Expression(mAttachInfo.mRootView, [])]), AssignmentExpression(=, [VariableReference(if (v !, []), Expression(null) {, [])]), Statement(return v, []), Statement(}, []), Statement(}, []), AssignmentExpression(=, [VariableReference(View parent, []), Expression(this, [])]), AssignmentExpression(=, [VariableReference(while (parent.mParent !, []), Expression(null && parent.mParent instanceof View) {, [])]), AssignmentExpression(=, [VariableReference(parent, []), Expression((View) parent.mParent, [])]), Statement(}, []), Statement(return parent, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(if (mAttachInfo !, []), Expression(null) {, [])])    VariableReference(if (mAttachInfo !, [])    Expression(null) {, [])  AssignmentExpression(=, [VariableReference(final View v, []), Expression(mAttachInfo.mRootView, [])])    VariableReference(final View v, [])    Expression(mAttachInfo.mRootView, [])  AssignmentExpression(=, [VariableReference(if (v !, []), Expression(null) {, [])])    VariableReference(if (v !, [])    Expression(null) {, [])  Statement(return v, [])  Statement(}, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(View parent, []), Expression(this, [])])    VariableReference(View parent, [])    Expression(this, [])  AssignmentExpression(=, [VariableReference(while (parent.mParent !, []), Expression(null && parent.mParent instanceof View) {, [])])    VariableReference(while (parent.mParent !, [])    Expression(null && parent.mParent instanceof View) {, [])  AssignmentExpression(=, [VariableReference(parent, []), Expression((View) parent.mParent, [])])    VariableReference(parent, [])    Expression((View) parent.mParent, [])  Statement(}, [])  Statement(return parent, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(if (mAttachInfo !, []), Expression(null) {, [])]), AssignmentExpression(=, [VariableReference(final View v, []), Expression(mAttachInfo.mRootView, [])]), AssignmentExpression(=, [VariableReference(if (v !, []), Expression(null) {, [])]), Statement(return v, []), Statement(}, []), Statement(}, []), AssignmentExpression(=, [VariableReference(View parent, []), Expression(this, [])]), AssignmentExpression(=, [VariableReference(parent, []), Expression((View) parent.mParent, [])]), Statement(}, []), Statement(return parent, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(if (mAttachInfo !, []), Expression(null) {, [])])    VariableReference(if (mAttachInfo !, [])    Expression(null) {, [])  AssignmentExpression(=, [VariableReference(final View v, []), Expression(mAttachInfo.mRootView, [])])    VariableReference(final View v, [])    Expression(mAttachInfo.mRootView, [])  AssignmentExpression(=, [VariableReference(if (v !, []), Expression(null) {, [])])    VariableReference(if (v !, [])    Expression(null) {, [])  Statement(return v, [])  Statement(}, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(View parent, []), Expression(this, [])])    VariableReference(View parent, [])    Expression(this, [])  AssignmentExpression(=, [VariableReference(parent, []), Expression((View) parent.mParent, [])])    VariableReference(parent, [])    Expression((View) parent.mParent, [])  Statement(}, [])  Statement(return parent, [])  Statement(}, [])",1,"/**
 * <p>Finds the topmost view in the current view hierarchy.</p>
 *
 * @return the topmost view containing this view
 */
","/**
 * <p>Finds the topmost view in the current view hierarchy.</p>
 *
 * @return the topmost view containing this view
 */
",0,,,0,,,,1,3,1,3,1,"The control dependency has been changed as the null check condition for parent.mParent has been removed. Thus, the code change type is 3.","The change in control dependency might result in the loop executing one extra time in certain conditions, potentially changing the value of 'parent'. Consequently, this change might cause the method to return a different view, causing a compatibility issue. The CI type is 1."
172,<android.window.TaskSnapshot.Builder: TaskSnapshot build()>,31,32,<android.window.TaskSnapshot.Builder: TaskSnapshot build()>,<android.window.TaskSnapshot.Builder: TaskSnapshot build()>,0,"MethodDeclaration(method_body, [Statement({, []), Statement(false, /* isLowResolution */, []), Statement(mIsRealSnapshot, mWindowingMode, mAppearance, mIsTranslucent, mHasImeSurface), []), Statement(}, [])])  Statement({, [])  Statement(false, /* isLowResolution */, [])  Statement(mIsRealSnapshot, mWindowingMode, mAppearance, mIsTranslucent, mHasImeSurface), [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(false, /* isLowResolution */, []), Statement(mIsRealSnapshot, mWindowingMode, mAppearance, mIsTranslucent, mHasImeSurface), []), Statement(}, [])])  Statement({, [])  Statement(false, /* isLowResolution */, [])  Statement(mIsRealSnapshot, mWindowingMode, mAppearance, mIsTranslucent, mHasImeSurface), [])  Statement(}, [])",1,,,0,,,0,,,,2,"1,5",1,0,0,There is no change between the early version and the late version.,"Since there is no change in the code, there is no Compatibility Issue."
173,<android.companion.CompanionDeviceManager: List<String> getAssociations()>,32,33,<android.companion.CompanionDeviceManager: List<String> getAssociations()>,<android.companion.CompanionDeviceManager: List<String> getAssociations()>,0,"MethodDeclaration(method_body, [Statement({, []), Statement(if (!checkFeaturePresent()) {, []), MethodCall(return Collections.emptyList(), [VariableReference(return Collections, []), Expression(, [])]), Statement(}, []), Statement(try {, []), MethodCall(return mService.getAssociations(getCallingPackage(), mContext.getUserId()), [VariableReference(return mService, []), Expression(getCallingPackage(), []), Expression(mContext.getUserId(), [])]), Statement(} catch (RemoteException e) {, []), MethodCall(throw e.rethrowFromSystemServer(), [VariableReference(throw e, []), Expression(, [])]), Statement(}, []), Statement(}, [])])  Statement({, [])  Statement(if (!checkFeaturePresent()) {, [])  MethodCall(return Collections.emptyList(), [VariableReference(return Collections, []), Expression(, [])])    VariableReference(return Collections, [])    Expression(, [])  Statement(}, [])  Statement(try {, [])  MethodCall(return mService.getAssociations(getCallingPackage(), mContext.getUserId()), [VariableReference(return mService, []), Expression(getCallingPackage(), []), Expression(mContext.getUserId(), [])])    VariableReference(return mService, [])    Expression(getCallingPackage(), [])    Expression(mContext.getUserId(), [])  Statement(} catch (RemoteException e) {, [])  MethodCall(throw e.rethrowFromSystemServer(), [VariableReference(throw e, []), Expression(, [])])    VariableReference(throw e, [])    Expression(, [])  Statement(}, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), MethodCall(return CollectionUtils.mapNotNull(getMyAssociations(), a -> a.isSelfManaged() ? null : a.getDeviceMacAddressAsString()), [VariableReference(return CollectionUtils, []), Expression(getMyAssociations(), []), Expression(a -> a.isSelfManaged() ? null : a.getDeviceMacAddressAsString(), [])]), Statement(}, [])])  Statement({, [])  MethodCall(return CollectionUtils.mapNotNull(getMyAssociations(), a -> a.isSelfManaged() ? null : a.getDeviceMacAddressAsString()), [VariableReference(return CollectionUtils, []), Expression(getMyAssociations(), []), Expression(a -> a.isSelfManaged() ? null : a.getDeviceMacAddressAsString(), [])])    VariableReference(return CollectionUtils, [])    Expression(getMyAssociations(), [])    Expression(a -> a.isSelfManaged() ? null : a.getDeviceMacAddressAsString(), [])  Statement(}, [])",1,"/**
 * <p>Calling this API requires a uses-feature
 * {@link PackageManager#FEATURE_COMPANION_DEVICE_SETUP} declaration in the manifest</p>
 *
 * @return a list of MAC addresses of devices that have been previously associated with the
 * current app. You can use these with {@link #disassociate}
 */
","/**
 * <p>Calling this API requires a uses-feature
 * {@link PackageManager#FEATURE_COMPANION_DEVICE_SETUP} declaration in the manifest</p>
 *
 * @return a list of MAC addresses of devices that have been previously associated with the
 * current app are managed by CompanionDeviceManager (ie. does not include devices managed by
 * application itself even if they have a MAC address).
 *
 * @deprecated use {@link #getMyAssociations()}
 */
",0,[@NonNull],"[@Deprecated, @UserHandleAware, @NonNull]",1,,,,1,"1,2,3","1,2","1,4",1,"The return statement was changed entirely, and also the checkFeaturePresent condition was removed. So the code change types are 1,4.","The return statement's change could make the API potentially return different values, which would lead to a compatibility issue of type 1."
174,android.hardware.camera2.CameraCharacteristics.get,31,32,<android.hardware.camera2.CameraCharacteristics: T get(Key<T>)>,<android.hardware.camera2.CameraCharacteristics: T get(Key<T>)>,0,"MethodDeclaration(method_body, [Statement({, []), MethodCall(return mProperties.get(key), [VariableReference(return mProperties, []), Expression(key, [])]), Statement(}, [])])  Statement({, [])  MethodCall(return mProperties.get(key), [VariableReference(return mProperties, []), Expression(key, [])])    VariableReference(return mProperties, [])    Expression(key, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(T propertyOverride, []), Expression(overrideProperty(key), [])]), AssignmentExpression(=, [VariableReference(return (propertyOverride !, []), Expression(null) ? propertyOverride : mProperties.get(key), [])]), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(T propertyOverride, []), Expression(overrideProperty(key), [])])    VariableReference(T propertyOverride, [])    Expression(overrideProperty(key), [])  AssignmentExpression(=, [VariableReference(return (propertyOverride !, []), Expression(null) ? propertyOverride : mProperties.get(key), [])])    VariableReference(return (propertyOverride !, [])    Expression(null) ? propertyOverride : mProperties.get(key), [])  Statement(}, [])",1,"/**
 * Get a camera characteristics field value.
 *
 * <p>The field definitions can be
 * found in {@link CameraCharacteristics}.</p>
 *
 * <p>Querying the value for the same key more than once will return a value
 * which is equal to the previous queried value.</p>
 *
 * @throws IllegalArgumentException if the key was not valid
 *
 * @param key The characteristics field to read.
 * @return The value of that key, or {@code null} if the field is not set.
 */
","/**
 * Get a camera characteristics field value.
 *
 * <p>The field definitions can be
 * found in {@link CameraCharacteristics}.</p>
 *
 * <p>Querying the value for the same key more than once will return a value
 * which is equal to the previous queried value.</p>
 *
 * @throws IllegalArgumentException if the key was not valid
 *
 * @param key The characteristics field to read.
 * @return The value of that key, or {@code null} if the field is not set.
 */
",0,[@Nullable],[@Nullable],0,,,,1,"1,4",1,"1,3",1,"In the late version, the code introduces a new method call 'overrideProperty(key)' and a new condition to determine the return values in the return statement, so the categories of the code change are 1,3.","As the return value in the late version is not only dependent on 'mProperties.get(key)' but also on 'overrideProperty(key)', which is a new behavior that is potentially different from the early version. Thus, the CI type is 1."
175,android.accessibilityservice.AccessibilityService.createDisplayContext,31,32,<android.accessibilityservice.AccessibilityService: Context createDisplayContext(Display)>,<android.accessibilityservice.AccessibilityService: Context createDisplayContext(Display)>,0,"MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(final Context context, []), Expression(super.createDisplayContext(display), [])]), AssignmentExpression(=, [VariableReference(final int displayId, []), Expression(display.getDisplayId(), [])]), Statement(setDefaultTokenInternal(context, displayId), []), Statement(return context, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(final Context context, []), Expression(super.createDisplayContext(display), [])])    VariableReference(final Context context, [])    Expression(super.createDisplayContext(display), [])  AssignmentExpression(=, [VariableReference(final int displayId, []), Expression(display.getDisplayId(), [])])    VariableReference(final int displayId, [])    Expression(display.getDisplayId(), [])  Statement(setDefaultTokenInternal(context, displayId), [])  Statement(return context, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), MethodCall(return new AccessibilityContext(super.createDisplayContext(display), mConnectionId), [VariableReference(return new AccessibilityContext(super, []), Expression(display), []), Expression(mConnectionId, [])]), Statement(}, [])])  Statement({, [])  MethodCall(return new AccessibilityContext(super.createDisplayContext(display), mConnectionId), [VariableReference(return new AccessibilityContext(super, []), Expression(display), []), Expression(mConnectionId, [])])    VariableReference(return new AccessibilityContext(super, [])    Expression(display), [])    Expression(mConnectionId, [])  Statement(}, [])",1,,,0,[@Override],"[@NonNull, @Override]",1,,,,1,"1,4",1,1,1,"The return statement has changed from 'return context' to 'return new AccessibilityContext(super.createDisplayContext(display), mConnectionId)'","The function used to return 'context' but now returns a 'new AccessibilityContext' instance using 'super.createDisplayContext(display), mConnectionId' as parameters. So the return value is different and could cause a compatibility issue. CI type is 1."
176,android.app.ActivityThread.ProviderKey.hashCode,31,32,<android.app.ActivityThread.ProviderKey: int hashCode()>,<android.app.ActivityThread.ProviderKey: int hashCode()>,0,"MethodDeclaration(method_body, [Statement({, []), Statement(return hashCode(authority, userId), []), Statement(}, [])])  Statement({, [])  Statement(return hashCode(authority, userId), [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(return ((authority !, []), Expression(null) ? authority.hashCode() : 0) ^ userId, [])]), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(return ((authority !, []), Expression(null) ? authority.hashCode() : 0) ^ userId, [])])    VariableReference(return ((authority !, [])    Expression(null) ? authority.hashCode() : 0) ^ userId, [])  Statement(}, [])",1,,,0,[@Override],[@Override],0,,,,1,"1,5",1,1,1,"The return statement has changed from `hashCode(authority, userId)` to `return ((authority != null) ? authority.hashCode() : 0) ^ userId`, so the code change type is 1.","The change in the return statement will make the API potentially return a different value, so the CI type is 1."
177,android.view.MotionEvent.PointerCoords.clear,31,32,<android.view.MotionEvent.PointerCoords: void clear()>,<android.view.MotionEvent.PointerCoords: void clear()>,0,"MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(mPackedAxisBits, []), Expression(0, [])]), AssignmentExpression(=, [VariableReference(x, []), Expression(0, [])]), AssignmentExpression(=, [VariableReference(y, []), Expression(0, [])]), AssignmentExpression(=, [VariableReference(pressure, []), Expression(0, [])]), AssignmentExpression(=, [VariableReference(size, []), Expression(0, [])]), AssignmentExpression(=, [VariableReference(touchMajor, []), Expression(0, [])]), AssignmentExpression(=, [VariableReference(touchMinor, []), Expression(0, [])]), AssignmentExpression(=, [VariableReference(toolMajor, []), Expression(0, [])]), AssignmentExpression(=, [VariableReference(toolMinor, []), Expression(0, [])]), AssignmentExpression(=, [VariableReference(orientation, []), Expression(0, [])]), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(mPackedAxisBits, []), Expression(0, [])])    VariableReference(mPackedAxisBits, [])    Expression(0, [])  AssignmentExpression(=, [VariableReference(x, []), Expression(0, [])])    VariableReference(x, [])    Expression(0, [])  AssignmentExpression(=, [VariableReference(y, []), Expression(0, [])])    VariableReference(y, [])    Expression(0, [])  AssignmentExpression(=, [VariableReference(pressure, []), Expression(0, [])])    VariableReference(pressure, [])    Expression(0, [])  AssignmentExpression(=, [VariableReference(size, []), Expression(0, [])])    VariableReference(size, [])    Expression(0, [])  AssignmentExpression(=, [VariableReference(touchMajor, []), Expression(0, [])])    VariableReference(touchMajor, [])    Expression(0, [])  AssignmentExpression(=, [VariableReference(touchMinor, []), Expression(0, [])])    VariableReference(touchMinor, [])    Expression(0, [])  AssignmentExpression(=, [VariableReference(toolMajor, []), Expression(0, [])])    VariableReference(toolMajor, [])    Expression(0, [])  AssignmentExpression(=, [VariableReference(toolMinor, []), Expression(0, [])])    VariableReference(toolMinor, [])    Expression(0, [])  AssignmentExpression(=, [VariableReference(orientation, []), Expression(0, [])])    VariableReference(orientation, [])    Expression(0, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(mPackedAxisBits, []), Expression(0, [])]), AssignmentExpression(=, [VariableReference(x, []), Expression(0, [])]), AssignmentExpression(=, [VariableReference(y, []), Expression(0, [])]), AssignmentExpression(=, [VariableReference(pressure, []), Expression(0, [])]), AssignmentExpression(=, [VariableReference(size, []), Expression(0, [])]), AssignmentExpression(=, [VariableReference(touchMajor, []), Expression(0, [])]), AssignmentExpression(=, [VariableReference(touchMinor, []), Expression(0, [])]), AssignmentExpression(=, [VariableReference(toolMajor, []), Expression(0, [])]), AssignmentExpression(=, [VariableReference(toolMinor, []), Expression(0, [])]), AssignmentExpression(=, [VariableReference(orientation, []), Expression(0, [])]), AssignmentExpression(=, [VariableReference(relativeX, []), Expression(0, [])]), AssignmentExpression(=, [VariableReference(relativeY, []), Expression(0, [])]), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(mPackedAxisBits, []), Expression(0, [])])    VariableReference(mPackedAxisBits, [])    Expression(0, [])  AssignmentExpression(=, [VariableReference(x, []), Expression(0, [])])    VariableReference(x, [])    Expression(0, [])  AssignmentExpression(=, [VariableReference(y, []), Expression(0, [])])    VariableReference(y, [])    Expression(0, [])  AssignmentExpression(=, [VariableReference(pressure, []), Expression(0, [])])    VariableReference(pressure, [])    Expression(0, [])  AssignmentExpression(=, [VariableReference(size, []), Expression(0, [])])    VariableReference(size, [])    Expression(0, [])  AssignmentExpression(=, [VariableReference(touchMajor, []), Expression(0, [])])    VariableReference(touchMajor, [])    Expression(0, [])  AssignmentExpression(=, [VariableReference(touchMinor, []), Expression(0, [])])    VariableReference(touchMinor, [])    Expression(0, [])  AssignmentExpression(=, [VariableReference(toolMajor, []), Expression(0, [])])    VariableReference(toolMajor, [])    Expression(0, [])  AssignmentExpression(=, [VariableReference(toolMinor, []), Expression(0, [])])    VariableReference(toolMinor, [])    Expression(0, [])  AssignmentExpression(=, [VariableReference(orientation, []), Expression(0, [])])    VariableReference(orientation, [])    Expression(0, [])  AssignmentExpression(=, [VariableReference(relativeX, []), Expression(0, [])])    VariableReference(relativeX, [])    Expression(0, [])  AssignmentExpression(=, [VariableReference(relativeY, []), Expression(0, [])])    VariableReference(relativeY, [])    Expression(0, [])  Statement(}, [])",1,"/**
 * Clears the contents of this object.
 * Resets all axes to zero.
 */
","/**
 * Clears the contents of this object.
 * Resets all axes to zero.
 */
",0,,,0,,,,1,4,0,4,1,"Two new assignment expressions are added in the late version (AssignmentExpression(=, [VariableReference(relativeX, []), Expression(0, [])]), AssignmentExpression(=, [VariableReference(relativeY, []), Expression(0, [])])), so the code change type is 4.","The newly added assignment changes can make the API return a different internal state when invoked, so the CI type is 1."
1,<android.widget.TextView: void setInputType(int)>,30,31,,,,"MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(final boolean wasPassword, []), Expression(isPasswordInputType(getInputType()), [])]), AssignmentExpression(=, [VariableReference(final boolean wasVisiblePassword, []), Expression(isVisiblePasswordInputType(getInputType()), [])]), Statement(setInputType(type, false), []), AssignmentExpression(=, [VariableReference(final boolean isPassword, []), Expression(isPasswordInputType(type), [])]), AssignmentExpression(=, [VariableReference(final boolean isVisiblePassword, []), Expression(isVisiblePasswordInputType(type), [])]), AssignmentExpression(=, [VariableReference(boolean forceUpdate, []), Expression(false, [])]), Statement(if (isPassword) {, []), MethodCall(setTransformationMethod(PasswordTransformationMethod.getInstance()), [VariableReference(setTransformationMethod(PasswordTransformationMethod, []), Expression(), [])]), Statement(setTypefaceFromAttrs(null, /* fontTypeface */, []), Statement(null, /* fontFamily */, []), Statement(MONOSPACE, Typeface.NORMAL, -1), []), Statement(} else if (isVisiblePassword) {, []), AssignmentExpression(=, [VariableReference(if (mTransformation, []), Expression(, [])]), AssignmentExpression(=, [VariableReference(forceUpdate, []), Expression(true, [])]), Statement(}, []), Statement(setTypefaceFromAttrs(null, /* fontTypeface */, []), Statement(null, /* fontFamily */, []), Statement(MONOSPACE, Typeface.NORMAL, -1), []), Statement(} else if (wasPassword || wasVisiblePassword) {, []), Statement(// not in password mode, clean up typeface and transformation, []), Statement(setTypefaceFromAttrs(null, /* fontTypeface */, []), Statement(null, /* fontFamily */, []), Statement(DEFAULT_TYPEFACE, /* typeface index */, []), Statement(Typeface.NORMAL, -1), []), AssignmentExpression(=, [VariableReference(if (mTransformation, []), Expression(, [])]), AssignmentExpression(=, [VariableReference(forceUpdate, []), Expression(true, [])]), Statement(}, []), Statement(}, []), AssignmentExpression(=, [VariableReference(boolean singleLine, []), Expression(!isMultilineInputType(type), [])]), Statement(// were previously in password mode., []), AssignmentExpression(=, [VariableReference(if (mSingleLine !, []), Expression(singleLine || forceUpdate) {, [])]), Statement(// Change single line mode, but only change the transformation if, []), Statement(// we are not in password mode., []), Statement(applySingleLine(singleLine, !isPassword, true), []), Statement(}, []), Statement(if (!isSuggestionsEnabled()) {, []), Statement(setTextInternal(removeSuggestionSpans(mText)), []), Statement(}, []), AssignmentExpression(=, [VariableReference(InputMethodManager imm, []), Expression(getInputMethodManager(), [])]), AssignmentExpression(=, [VariableReference(if (imm !, []), Expression(null), [])]), MethodCall(imm.restartInput(this), [VariableReference(imm, []), Expression(this, [])]), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(final boolean wasPassword, []), Expression(isPasswordInputType(getInputType()), [])])    VariableReference(final boolean wasPassword, [])    Expression(isPasswordInputType(getInputType()), [])  AssignmentExpression(=, [VariableReference(final boolean wasVisiblePassword, []), Expression(isVisiblePasswordInputType(getInputType()), [])])    VariableReference(final boolean wasVisiblePassword, [])    Expression(isVisiblePasswordInputType(getInputType()), [])  Statement(setInputType(type, false), [])  AssignmentExpression(=, [VariableReference(final boolean isPassword, []), Expression(isPasswordInputType(type), [])])    VariableReference(final boolean isPassword, [])    Expression(isPasswordInputType(type), [])  AssignmentExpression(=, [VariableReference(final boolean isVisiblePassword, []), Expression(isVisiblePasswordInputType(type), [])])    VariableReference(final boolean isVisiblePassword, [])    Expression(isVisiblePasswordInputType(type), [])  AssignmentExpression(=, [VariableReference(boolean forceUpdate, []), Expression(false, [])])    VariableReference(boolean forceUpdate, [])    Expression(false, [])  Statement(if (isPassword) {, [])  MethodCall(setTransformationMethod(PasswordTransformationMethod.getInstance()), [VariableReference(setTransformationMethod(PasswordTransformationMethod, []), Expression(), [])])    VariableReference(setTransformationMethod(PasswordTransformationMethod, [])    Expression(), [])  Statement(setTypefaceFromAttrs(null, /* fontTypeface */, [])  Statement(null, /* fontFamily */, [])  Statement(MONOSPACE, Typeface.NORMAL, -1), [])  Statement(} else if (isVisiblePassword) {, [])  AssignmentExpression(=, [VariableReference(if (mTransformation, []), Expression(, [])])    VariableReference(if (mTransformation, [])    Expression(, [])  AssignmentExpression(=, [VariableReference(forceUpdate, []), Expression(true, [])])    VariableReference(forceUpdate, [])    Expression(true, [])  Statement(}, [])  Statement(setTypefaceFromAttrs(null, /* fontTypeface */, [])  Statement(null, /* fontFamily */, [])  Statement(MONOSPACE, Typeface.NORMAL, -1), [])  Statement(} else if (wasPassword || wasVisiblePassword) {, [])  Statement(// not in password mode, clean up typeface and transformation, [])  Statement(setTypefaceFromAttrs(null, /* fontTypeface */, [])  Statement(null, /* fontFamily */, [])  Statement(DEFAULT_TYPEFACE, /* typeface index */, [])  Statement(Typeface.NORMAL, -1), [])  AssignmentExpression(=, [VariableReference(if (mTransformation, []), Expression(, [])])    VariableReference(if (mTransformation, [])    Expression(, [])  AssignmentExpression(=, [VariableReference(forceUpdate, []), Expression(true, [])])    VariableReference(forceUpdate, [])    Expression(true, [])  Statement(}, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(boolean singleLine, []), Expression(!isMultilineInputType(type), [])])    VariableReference(boolean singleLine, [])    Expression(!isMultilineInputType(type), [])  Statement(// were previously in password mode., [])  AssignmentExpression(=, [VariableReference(if (mSingleLine !, []), Expression(singleLine || forceUpdate) {, [])])    VariableReference(if (mSingleLine !, [])    Expression(singleLine || forceUpdate) {, [])  Statement(// Change single line mode, but only change the transformation if, [])  Statement(// we are not in password mode., [])  Statement(applySingleLine(singleLine, !isPassword, true), [])  Statement(}, [])  Statement(if (!isSuggestionsEnabled()) {, [])  Statement(setTextInternal(removeSuggestionSpans(mText)), [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(InputMethodManager imm, []), Expression(getInputMethodManager(), [])])    VariableReference(InputMethodManager imm, [])    Expression(getInputMethodManager(), [])  AssignmentExpression(=, [VariableReference(if (imm !, []), Expression(null), [])])    VariableReference(if (imm !, [])    Expression(null), [])  MethodCall(imm.restartInput(this), [VariableReference(imm, []), Expression(this, [])])    VariableReference(imm, [])    Expression(this, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(final boolean wasPassword, []), Expression(isPasswordInputType(getInputType()), [])]), AssignmentExpression(=, [VariableReference(final boolean wasVisiblePassword, []), Expression(isVisiblePasswordInputType(getInputType()), [])]), Statement(setInputType(type, false), []), AssignmentExpression(=, [VariableReference(final boolean isPassword, []), Expression(isPasswordInputType(type), [])]), AssignmentExpression(=, [VariableReference(final boolean isVisiblePassword, []), Expression(isVisiblePasswordInputType(type), [])]), AssignmentExpression(=, [VariableReference(boolean forceUpdate, []), Expression(false, [])]), Statement(if (isPassword) {, []), MethodCall(setTransformationMethod(PasswordTransformationMethod.getInstance()), [VariableReference(setTransformationMethod(PasswordTransformationMethod, []), Expression(), [])]), Statement(setTypefaceFromAttrs(null, /* fontTypeface */, []), Statement(null, /* fontFamily */, []), Statement(MONOSPACE, Typeface.NORMAL, -1), []), Statement(} else if (isVisiblePassword) {, []), AssignmentExpression(=, [VariableReference(if (mTransformation, []), Expression(, [])]), AssignmentExpression(=, [VariableReference(forceUpdate, []), Expression(true, [])]), Statement(}, []), Statement(setTypefaceFromAttrs(null, /* fontTypeface */, []), Statement(null, /* fontFamily */, []), Statement(MONOSPACE, Typeface.NORMAL, -1), []), Statement(} else if (wasPassword || wasVisiblePassword) {, []), Statement(// not in password mode, clean up typeface and transformation, []), Statement(setTypefaceFromAttrs(null, /* fontTypeface */, []), Statement(null, /* fontFamily */, []), Statement(DEFAULT_TYPEFACE, /* typeface index */, []), Statement(Typeface.NORMAL, -1), []), AssignmentExpression(=, [VariableReference(if (mTransformation, []), Expression(, [])]), AssignmentExpression(=, [VariableReference(forceUpdate, []), Expression(true, [])]), Statement(}, []), Statement(}, []), AssignmentExpression(=, [VariableReference(boolean singleLine, []), Expression(!isMultilineInputType(type), [])]), Statement(// were previously in password mode., []), AssignmentExpression(=, [VariableReference(if (mSingleLine !, []), Expression(singleLine || forceUpdate) {, [])]), Statement(// Change single line mode, but only change the transformation if, []), Statement(// we are not in password mode., []), Statement(applySingleLine(singleLine, !isPassword, true, true), []), Statement(}, []), Statement(if (!isSuggestionsEnabled()) {, []), Statement(setTextInternal(removeSuggestionSpans(mText)), []), Statement(}, []), AssignmentExpression(=, [VariableReference(InputMethodManager imm, []), Expression(getInputMethodManager(), [])]), AssignmentExpression(=, [VariableReference(if (imm !, []), Expression(null), [])]), MethodCall(imm.restartInput(this), [VariableReference(imm, []), Expression(this, [])]), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(final boolean wasPassword, []), Expression(isPasswordInputType(getInputType()), [])])    VariableReference(final boolean wasPassword, [])    Expression(isPasswordInputType(getInputType()), [])  AssignmentExpression(=, [VariableReference(final boolean wasVisiblePassword, []), Expression(isVisiblePasswordInputType(getInputType()), [])])    VariableReference(final boolean wasVisiblePassword, [])    Expression(isVisiblePasswordInputType(getInputType()), [])  Statement(setInputType(type, false), [])  AssignmentExpression(=, [VariableReference(final boolean isPassword, []), Expression(isPasswordInputType(type), [])])    VariableReference(final boolean isPassword, [])    Expression(isPasswordInputType(type), [])  AssignmentExpression(=, [VariableReference(final boolean isVisiblePassword, []), Expression(isVisiblePasswordInputType(type), [])])    VariableReference(final boolean isVisiblePassword, [])    Expression(isVisiblePasswordInputType(type), [])  AssignmentExpression(=, [VariableReference(boolean forceUpdate, []), Expression(false, [])])    VariableReference(boolean forceUpdate, [])    Expression(false, [])  Statement(if (isPassword) {, [])  MethodCall(setTransformationMethod(PasswordTransformationMethod.getInstance()), [VariableReference(setTransformationMethod(PasswordTransformationMethod, []), Expression(), [])])    VariableReference(setTransformationMethod(PasswordTransformationMethod, [])    Expression(), [])  Statement(setTypefaceFromAttrs(null, /* fontTypeface */, [])  Statement(null, /* fontFamily */, [])  Statement(MONOSPACE, Typeface.NORMAL, -1), [])  Statement(} else if (isVisiblePassword) {, [])  AssignmentExpression(=, [VariableReference(if (mTransformation, []), Expression(, [])])    VariableReference(if (mTransformation, [])    Expression(, [])  AssignmentExpression(=, [VariableReference(forceUpdate, []), Expression(true, [])])    VariableReference(forceUpdate, [])    Expression(true, [])  Statement(}, [])  Statement(setTypefaceFromAttrs(null, /* fontTypeface */, [])  Statement(null, /* fontFamily */, [])  Statement(MONOSPACE, Typeface.NORMAL, -1), [])  Statement(} else if (wasPassword || wasVisiblePassword) {, [])  Statement(// not in password mode, clean up typeface and transformation, [])  Statement(setTypefaceFromAttrs(null, /* fontTypeface */, [])  Statement(null, /* fontFamily */, [])  Statement(DEFAULT_TYPEFACE, /* typeface index */, [])  Statement(Typeface.NORMAL, -1), [])  AssignmentExpression(=, [VariableReference(if (mTransformation, []), Expression(, [])])    VariableReference(if (mTransformation, [])    Expression(, [])  AssignmentExpression(=, [VariableReference(forceUpdate, []), Expression(true, [])])    VariableReference(forceUpdate, [])    Expression(true, [])  Statement(}, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(boolean singleLine, []), Expression(!isMultilineInputType(type), [])])    VariableReference(boolean singleLine, [])    Expression(!isMultilineInputType(type), [])  Statement(// were previously in password mode., [])  AssignmentExpression(=, [VariableReference(if (mSingleLine !, []), Expression(singleLine || forceUpdate) {, [])])    VariableReference(if (mSingleLine !, [])    Expression(singleLine || forceUpdate) {, [])  Statement(// Change single line mode, but only change the transformation if, [])  Statement(// we are not in password mode., [])  Statement(applySingleLine(singleLine, !isPassword, true, true), [])  Statement(}, [])  Statement(if (!isSuggestionsEnabled()) {, [])  Statement(setTextInternal(removeSuggestionSpans(mText)), [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(InputMethodManager imm, []), Expression(getInputMethodManager(), [])])    VariableReference(InputMethodManager imm, [])    Expression(getInputMethodManager(), [])  AssignmentExpression(=, [VariableReference(if (imm !, []), Expression(null), [])])    VariableReference(if (imm !, [])    Expression(null), [])  MethodCall(imm.restartInput(this), [VariableReference(imm, []), Expression(this, [])])    VariableReference(imm, [])    Expression(this, [])  Statement(}, [])",1,"/**
 * Set the type of the content with a constant as defined for {@link EditorInfo#inputType}. This
 * will take care of changing the key listener, by calling {@link #setKeyListener(KeyListener)},
 * to match the given content type.  If the given content type is {@link EditorInfo#TYPE_NULL}
 * then a soft keyboard will not be displayed for this text view.
 *
 * Note that the maximum number of displayed lines (see {@link #setMaxLines(int)}) will be
 * modified if you change the {@link EditorInfo#TYPE_TEXT_FLAG_MULTI_LINE} flag of the input
 * type.
 *
 * @see #getInputType()
 * @see #setRawInputType(int)
 * @see android.text.InputType
 * @attr ref android.R.styleable#TextView_inputType
 */
","/**
 * Set the type of the content with a constant as defined for {@link EditorInfo#inputType}. This
 * will take care of changing the key listener, by calling {@link #setKeyListener(KeyListener)},
 * to match the given content type.  If the given content type is {@link EditorInfo#TYPE_NULL}
 * then a soft keyboard will not be displayed for this text view.
 *
 * Note that the maximum number of displayed lines (see {@link #setMaxLines(int)}) will be
 * modified if you change the {@link EditorInfo#TYPE_TEXT_FLAG_MULTI_LINE} flag of the input
 * type.
 *
 * @see #getInputType()
 * @see #setRawInputType(int)
 * @see android.text.InputType
 * @attr ref android.R.styleable#TextView_inputType
 */
",0,,,0,,,,2,5,0,3,1,"Only one method call applySingleLine() has an extra parameter in the late version than the early version, so the code change type is 3.","As the method call applySingleLine() has changed, which may lead the API getRootView to potentially return different value in both versions, the Compatibility Issue type is 1."
2,<android.os.UserManager: boolean isUserUnlocked(UserHandle)>,30,31,,,,"MethodDeclaration(method_body, [Statement({, []), MethodCall(return isUserUnlocked(user.getIdentifier()), [VariableReference(return isUserUnlocked(user, []), Expression(), [])]), Statement(}, [])])  Statement({, [])  MethodCall(return isUserUnlocked(user.getIdentifier()), [VariableReference(return isUserUnlocked(user, []), Expression(), [])])    VariableReference(return isUserUnlocked(user, [])    Expression(), [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), MethodCall(return isUserUnlocked(user.getIdentifier()), [VariableReference(return isUserUnlocked(user, []), Expression(), [])]), Statement(}, [])])  Statement({, [])  MethodCall(return isUserUnlocked(user.getIdentifier()), [VariableReference(return isUserUnlocked(user, []), Expression(), [])])    VariableReference(return isUserUnlocked(user, [])    Expression(), [])  Statement(}, [])",0,"/**
 * Return whether the given user is running in an ""unlocked"" state.
 * <p>
 * On devices with direct boot, a user is unlocked only after they've
 * entered their credentials (such as a lock pattern or PIN). On devices
 * without direct boot, a user is unlocked as soon as it starts.
 * <p>
 * When a user is locked, only device-protected data storage is available.
 * When a user is unlocked, both device-protected and credential-protected
 * private app data storage is available.
 * <p>Requires {@code android.permission.MANAGE_USERS} or
 * {@code android.permission.INTERACT_ACROSS_USERS}, otherwise specified {@link UserHandle user}
 * must be the calling user or a managed profile associated with it.
 *
 * @param user to retrieve the unlocked state for.
 * @see Intent#ACTION_USER_UNLOCKED
 * @see Context#createDeviceProtectedStorageContext()
 */
","/**
 * Return whether the given user is running in an ""unlocked"" state.
 * <p>
 * On devices with direct boot, a user is unlocked only after they've
 * entered their credentials (such as a lock pattern or PIN). On devices
 * without direct boot, a user is unlocked as soon as it starts.
 * <p>
 * When a user is locked, only device-protected data storage is available.
 * When a user is unlocked, both device-protected and credential-protected
 * private app data storage is available.
 * <p>Requires {@code android.permission.MANAGE_USERS} or
 * {@code android.permission.INTERACT_ACROSS_USERS}, otherwise specified {@link UserHandle user}
 * must be the calling user or a profile associated with it.
 *
 * @param user to retrieve the unlocked state for.
 * @see Intent#ACTION_USER_UNLOCKED
 * @see Context#createDeviceProtectedStorageContext()
 */
",1,"[@RequiresPermission(anyOf = { Manifest.permission.MANAGE_USERS, Manifest.permission.INTERACT_ACROSS_USERS }, conditional = true)]","[@RequiresPermission(anyOf = { Manifest.permission.MANAGE_USERS, Manifest.permission.INTERACT_ACROSS_USERS }, conditional = true)]",0,,,,0,0,0,0,0,No code changes observed between the early version and the late version of the API.,"As no code changes observed, no compatibility issue should exist for the API."
3,<android.widget.HorizontalScrollView: boolean onTouchEvent(MotionEvent)>,30,31,,,,"MethodDeclaration(method_body, [Statement({, []), Statement(initVelocityTrackerIfNotExists(), []), MethodCall(mVelocityTracker.addMovement(ev), [VariableReference(mVelocityTracker, []), Expression(ev, [])]), AssignmentExpression(=, [VariableReference(final int action, []), Expression(ev.getAction(), [])]), Statement(case MotionEvent.ACTION_DOWN:, []), Statement({, []), AssignmentExpression(=, [VariableReference(if (getChildCount(), []), Expression(, [])]), Statement(return false, []), Statement(}, []), AssignmentExpression(=, [VariableReference(if ((mIsBeingDragged, []), Expression(!mScroller.isFinished())) {, [])]), AssignmentExpression(=, [VariableReference(final ViewParent parent, []), Expression(getParent(), [])]), AssignmentExpression(=, [VariableReference(if (parent !, []), Expression(null) {, [])]), MethodCall(parent.requestDisallowInterceptTouchEvent(true), [VariableReference(parent, []), Expression(true, [])]), Statement(}, []), Statement(}, []), Statement(/*, []), Statement(* If being flinged and user touches, stop the fling. isFinished, []), Statement(* will be false if being flinged., []), Statement(*/, []), MethodCall(if (!mScroller.isFinished()), [VariableReference(if (!mScroller, []), Expression(), [])]), MethodCall(mScroller.abortAnimation(), [VariableReference(mScroller, []), Expression(, [])]), Statement(}, []), Statement(// Remember where the motion event started, []), AssignmentExpression(=, [VariableReference(mLastMotionX, []), Expression((int) ev.getX(), [])]), AssignmentExpression(=, [VariableReference(mActivePointerId, []), Expression(ev.getPointerId(0), [])]), Statement(break, []), Statement(}, []), Statement(case MotionEvent.ACTION_MOVE:, []), AssignmentExpression(=, [VariableReference(final int activePointerIndex, []), Expression(ev.findPointerIndex(mActivePointerId), [])]), AssignmentExpression(=, [VariableReference(if (activePointerIndex, []), Expression(, [])]), AssignmentExpression(=, [VariableReference(Log.e(TAG, ""Invalid pointerId, []), Expression("" + mActivePointerId + "" in onTouchEvent""), [])]), Statement(break, []), Statement(}, []), AssignmentExpression(=, [VariableReference(final int x, []), Expression((int) ev.getX(activePointerIndex), [])]), AssignmentExpression(=, [VariableReference(int deltaX, []), Expression(mLastMotionX - x, [])]), MethodCall(if (!mIsBeingDragged && Math.abs(deltaX) > mTouchSlop), [VariableReference(if (!mIsBeingDragged && Math, []), Expression(deltaX) > mTouchSlop, [])]), AssignmentExpression(=, [VariableReference(final ViewParent parent, []), Expression(getParent(), [])]), AssignmentExpression(=, [VariableReference(if (parent !, []), Expression(null) {, [])]), MethodCall(parent.requestDisallowInterceptTouchEvent(true), [VariableReference(parent, []), Expression(true, [])]), Statement(}, []), AssignmentExpression(=, [VariableReference(mIsBeingDragged, []), Expression(true, [])]), Statement(if (deltaX > 0) {, []), AssignmentExpression(=, [VariableReference(deltaX -, []), Expression(mTouchSlop, [])]), Statement(} else {, []), AssignmentExpression(=, [VariableReference(deltaX +, []), Expression(mTouchSlop, [])]), Statement(}, []), Statement(}, []), Statement(if (mIsBeingDragged) {, []), Statement(// Scroll to follow the motion event, []), AssignmentExpression(=, [VariableReference(mLastMotionX, []), Expression(x, [])]), AssignmentExpression(=, [VariableReference(final int oldX, []), Expression(mScrollX, [])]), AssignmentExpression(=, [VariableReference(final int oldY, []), Expression(mScrollY, [])]), AssignmentExpression(=, [VariableReference(final int range, []), Expression(getScrollRange(), [])]), AssignmentExpression(=, [VariableReference(final int overscrollMode, []), Expression(getOverScrollMode(), [])]), AssignmentExpression(=, [VariableReference(final boolean canOverscroll, []), Expression(overscrollMode, [])]), Statement(// calls onScrollChanged if applicable., []), Statement(if (overScrollBy(deltaX, 0, mScrollX, 0, range, 0, mOverscrollDistance, 0, true)) {, []), Statement(// Break our velocity if we hit a scroll barrier., []), MethodCall(mVelocityTracker.clear(), [VariableReference(mVelocityTracker, []), Expression(, [])]), Statement(}, []), Statement(if (canOverscroll) {, []), AssignmentExpression(=, [VariableReference(final int pulledToX, []), Expression(oldX + deltaX, [])]), Statement(if (pulledToX < 0) {, []), MethodCall(mEdgeGlowLeft.onPull((float) deltaX / getWidth(), 1.f - ev.getY(activePointerIndex) / getHeight()), [VariableReference(mEdgeGlowLeft, []), Expression((float) deltaX / getWidth(), []), Expression(1.f - ev.getY(activePointerIndex) / getHeight(), [])]), MethodCall(if (!mEdgeGlowRight.isFinished()), [VariableReference(if (!mEdgeGlowRight, []), Expression(), [])]), MethodCall(mEdgeGlowRight.onRelease(), [VariableReference(mEdgeGlowRight, []), Expression(, [])]), Statement(}, []), Statement(} else if (pulledToX > range) {, []), MethodCall(mEdgeGlowRight.onPull((float) deltaX / getWidth(), ev.getY(activePointerIndex) / getHeight()), [VariableReference(mEdgeGlowRight, []), Expression((float) deltaX / getWidth(), []), Expression(ev.getY(activePointerIndex) / getHeight(), [])]), MethodCall(if (!mEdgeGlowLeft.isFinished()), [VariableReference(if (!mEdgeGlowLeft, []), Expression(), [])]), MethodCall(mEdgeGlowLeft.onRelease(), [VariableReference(mEdgeGlowLeft, []), Expression(, [])]), Statement(}, []), Statement(}, []), MethodCall(if (shouldDisplayEdgeEffects() && (!mEdgeGlowLeft.isFinished() || !mEdgeGlowRight.isFinished())), [VariableReference(if (shouldDisplayEdgeEffects() && (!mEdgeGlowLeft, []), Expression() || !mEdgeGlowRight.isFinished()), [])]), Statement(postInvalidateOnAnimation(), []), Statement(}, []), Statement(}, []), Statement(}, []), Statement(break, []), Statement(case MotionEvent.ACTION_UP:, []), Statement(if (mIsBeingDragged) {, []), AssignmentExpression(=, [VariableReference(final VelocityTracker velocityTracker, []), Expression(mVelocityTracker, [])]), MethodCall(velocityTracker.computeCurrentVelocity(1000, mMaximumVelocity), [VariableReference(velocityTracker, []), Expression(1000, []), Expression(mMaximumVelocity, [])]), AssignmentExpression(=, [VariableReference(int initialVelocity, []), Expression((int) velocityTracker.getXVelocity(mActivePointerId), [])]), Statement(if (getChildCount() > 0) {, []), MethodCall(if ((Math.abs(initialVelocity) > mMinimumVelocity)), [VariableReference(if ((Math, []), Expression(initialVelocity) > mMinimumVelocity), [])]), Statement(fling(-initialVelocity), []), Statement(} else {, []), MethodCall(if (mScroller.springBack(mScrollX, mScrollY, 0, getScrollRange(), 0, 0)), [VariableReference(if (mScroller, []), Expression(mScrollX, []), Expression(mScrollY, []), Expression(0, []), Expression(getScrollRange(), []), Expression(0, []), Expression(0), [])]), Statement(postInvalidateOnAnimation(), []), Statement(}, []), Statement(}, []), Statement(}, []), AssignmentExpression(=, [VariableReference(mActivePointerId, []), Expression(INVALID_POINTER, [])]), AssignmentExpression(=, [VariableReference(mIsBeingDragged, []), Expression(false, [])]), Statement(recycleVelocityTracker(), []), Statement(if (shouldDisplayEdgeEffects()) {, []), MethodCall(mEdgeGlowLeft.onRelease(), [VariableReference(mEdgeGlowLeft, []), Expression(, [])]), MethodCall(mEdgeGlowRight.onRelease(), [VariableReference(mEdgeGlowRight, []), Expression(, [])]), Statement(}, []), Statement(}, []), Statement(break, []), Statement(case MotionEvent.ACTION_CANCEL:, []), Statement(if (mIsBeingDragged && getChildCount() > 0) {, []), MethodCall(if (mScroller.springBack(mScrollX, mScrollY, 0, getScrollRange(), 0, 0)), [VariableReference(if (mScroller, []), Expression(mScrollX, []), Expression(mScrollY, []), Expression(0, []), Expression(getScrollRange(), []), Expression(0, []), Expression(0), [])]), Statement(postInvalidateOnAnimation(), []), Statement(}, []), AssignmentExpression(=, [VariableReference(mActivePointerId, []), Expression(INVALID_POINTER, [])]), AssignmentExpression(=, [VariableReference(mIsBeingDragged, []), Expression(false, [])]), Statement(recycleVelocityTracker(), []), Statement(if (shouldDisplayEdgeEffects()) {, []), MethodCall(mEdgeGlowLeft.onRelease(), [VariableReference(mEdgeGlowLeft, []), Expression(, [])]), MethodCall(mEdgeGlowRight.onRelease(), [VariableReference(mEdgeGlowRight, []), Expression(, [])]), Statement(}, []), Statement(}, []), Statement(break, []), Statement(case MotionEvent.ACTION_POINTER_UP:, []), Statement(onSecondaryPointerUp(ev), []), Statement(break, []), Statement(}, []), Statement(return true, []), Statement(}, [])])  Statement({, [])  Statement(initVelocityTrackerIfNotExists(), [])  MethodCall(mVelocityTracker.addMovement(ev), [VariableReference(mVelocityTracker, []), Expression(ev, [])])    VariableReference(mVelocityTracker, [])    Expression(ev, [])  AssignmentExpression(=, [VariableReference(final int action, []), Expression(ev.getAction(), [])])    VariableReference(final int action, [])    Expression(ev.getAction(), [])  Statement(case MotionEvent.ACTION_DOWN:, [])  Statement({, [])  AssignmentExpression(=, [VariableReference(if (getChildCount(), []), Expression(, [])])    VariableReference(if (getChildCount(), [])    Expression(, [])  Statement(return false, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(if ((mIsBeingDragged, []), Expression(!mScroller.isFinished())) {, [])])    VariableReference(if ((mIsBeingDragged, [])    Expression(!mScroller.isFinished())) {, [])  AssignmentExpression(=, [VariableReference(final ViewParent parent, []), Expression(getParent(), [])])    VariableReference(final ViewParent parent, [])    Expression(getParent(), [])  AssignmentExpression(=, [VariableReference(if (parent !, []), Expression(null) {, [])])    VariableReference(if (parent !, [])    Expression(null) {, [])  MethodCall(parent.requestDisallowInterceptTouchEvent(true), [VariableReference(parent, []), Expression(true, [])])    VariableReference(parent, [])    Expression(true, [])  Statement(}, [])  Statement(}, [])  Statement(/*, [])  Statement(* If being flinged and user touches, stop the fling. isFinished, [])  Statement(* will be false if being flinged., [])  Statement(*/, [])  MethodCall(if (!mScroller.isFinished()), [VariableReference(if (!mScroller, []), Expression(), [])])    VariableReference(if (!mScroller, [])    Expression(), [])  MethodCall(mScroller.abortAnimation(), [VariableReference(mScroller, []), Expression(, [])])    VariableReference(mScroller, [])    Expression(, [])  Statement(}, [])  Statement(// Remember where the motion event started, [])  AssignmentExpression(=, [VariableReference(mLastMotionX, []), Expression((int) ev.getX(), [])])    VariableReference(mLastMotionX, [])    Expression((int) ev.getX(), [])  AssignmentExpression(=, [VariableReference(mActivePointerId, []), Expression(ev.getPointerId(0), [])])    VariableReference(mActivePointerId, [])    Expression(ev.getPointerId(0), [])  Statement(break, [])  Statement(}, [])  Statement(case MotionEvent.ACTION_MOVE:, [])  AssignmentExpression(=, [VariableReference(final int activePointerIndex, []), Expression(ev.findPointerIndex(mActivePointerId), [])])    VariableReference(final int activePointerIndex, [])    Expression(ev.findPointerIndex(mActivePointerId), [])  AssignmentExpression(=, [VariableReference(if (activePointerIndex, []), Expression(, [])])    VariableReference(if (activePointerIndex, [])    Expression(, [])  AssignmentExpression(=, [VariableReference(Log.e(TAG, ""Invalid pointerId, []), Expression("" + mActivePointerId + "" in onTouchEvent""), [])])    VariableReference(Log.e(TAG, ""Invalid pointerId, [])    Expression("" + mActivePointerId + "" in onTouchEvent""), [])  Statement(break, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(final int x, []), Expression((int) ev.getX(activePointerIndex), [])])    VariableReference(final int x, [])    Expression((int) ev.getX(activePointerIndex), [])  AssignmentExpression(=, [VariableReference(int deltaX, []), Expression(mLastMotionX - x, [])])    VariableReference(int deltaX, [])    Expression(mLastMotionX - x, [])  MethodCall(if (!mIsBeingDragged && Math.abs(deltaX) > mTouchSlop), [VariableReference(if (!mIsBeingDragged && Math, []), Expression(deltaX) > mTouchSlop, [])])    VariableReference(if (!mIsBeingDragged && Math, [])    Expression(deltaX) > mTouchSlop, [])  AssignmentExpression(=, [VariableReference(final ViewParent parent, []), Expression(getParent(), [])])    VariableReference(final ViewParent parent, [])    Expression(getParent(), [])  AssignmentExpression(=, [VariableReference(if (parent !, []), Expression(null) {, [])])    VariableReference(if (parent !, [])    Expression(null) {, [])  MethodCall(parent.requestDisallowInterceptTouchEvent(true), [VariableReference(parent, []), Expression(true, [])])    VariableReference(parent, [])    Expression(true, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(mIsBeingDragged, []), Expression(true, [])])    VariableReference(mIsBeingDragged, [])    Expression(true, [])  Statement(if (deltaX > 0) {, [])  AssignmentExpression(=, [VariableReference(deltaX -, []), Expression(mTouchSlop, [])])    VariableReference(deltaX -, [])    Expression(mTouchSlop, [])  Statement(} else {, [])  AssignmentExpression(=, [VariableReference(deltaX +, []), Expression(mTouchSlop, [])])    VariableReference(deltaX +, [])    Expression(mTouchSlop, [])  Statement(}, [])  Statement(}, [])  Statement(if (mIsBeingDragged) {, [])  Statement(// Scroll to follow the motion event, [])  AssignmentExpression(=, [VariableReference(mLastMotionX, []), Expression(x, [])])    VariableReference(mLastMotionX, [])    Expression(x, [])  AssignmentExpression(=, [VariableReference(final int oldX, []), Expression(mScrollX, [])])    VariableReference(final int oldX, [])    Expression(mScrollX, [])  AssignmentExpression(=, [VariableReference(final int oldY, []), Expression(mScrollY, [])])    VariableReference(final int oldY, [])    Expression(mScrollY, [])  AssignmentExpression(=, [VariableReference(final int range, []), Expression(getScrollRange(), [])])    VariableReference(final int range, [])    Expression(getScrollRange(), [])  AssignmentExpression(=, [VariableReference(final int overscrollMode, []), Expression(getOverScrollMode(), [])])    VariableReference(final int overscrollMode, [])    Expression(getOverScrollMode(), [])  AssignmentExpression(=, [VariableReference(final boolean canOverscroll, []), Expression(overscrollMode, [])])    VariableReference(final boolean canOverscroll, [])    Expression(overscrollMode, [])  Statement(// calls onScrollChanged if applicable., [])  Statement(if (overScrollBy(deltaX, 0, mScrollX, 0, range, 0, mOverscrollDistance, 0, true)) {, [])  Statement(// Break our velocity if we hit a scroll barrier., [])  MethodCall(mVelocityTracker.clear(), [VariableReference(mVelocityTracker, []), Expression(, [])])    VariableReference(mVelocityTracker, [])    Expression(, [])  Statement(}, [])  Statement(if (canOverscroll) {, [])  AssignmentExpression(=, [VariableReference(final int pulledToX, []), Expression(oldX + deltaX, [])])    VariableReference(final int pulledToX, [])    Expression(oldX + deltaX, [])  Statement(if (pulledToX < 0) {, [])  MethodCall(mEdgeGlowLeft.onPull((float) deltaX / getWidth(), 1.f - ev.getY(activePointerIndex) / getHeight()), [VariableReference(mEdgeGlowLeft, []), Expression((float) deltaX / getWidth(), []), Expression(1.f - ev.getY(activePointerIndex) / getHeight(), [])])    VariableReference(mEdgeGlowLeft, [])    Expression((float) deltaX / getWidth(), [])    Expression(1.f - ev.getY(activePointerIndex) / getHeight(), [])  MethodCall(if (!mEdgeGlowRight.isFinished()), [VariableReference(if (!mEdgeGlowRight, []), Expression(), [])])    VariableReference(if (!mEdgeGlowRight, [])    Expression(), [])  MethodCall(mEdgeGlowRight.onRelease(), [VariableReference(mEdgeGlowRight, []), Expression(, [])])    VariableReference(mEdgeGlowRight, [])    Expression(, [])  Statement(}, [])  Statement(} else if (pulledToX > range) {, [])  MethodCall(mEdgeGlowRight.onPull((float) deltaX / getWidth(), ev.getY(activePointerIndex) / getHeight()), [VariableReference(mEdgeGlowRight, []), Expression((float) deltaX / getWidth(), []), Expression(ev.getY(activePointerIndex) / getHeight(), [])])    VariableReference(mEdgeGlowRight, [])    Expression((float) deltaX / getWidth(), [])    Expression(ev.getY(activePointerIndex) / getHeight(), [])  MethodCall(if (!mEdgeGlowLeft.isFinished()), [VariableReference(if (!mEdgeGlowLeft, []), Expression(), [])])    VariableReference(if (!mEdgeGlowLeft, [])    Expression(), [])  MethodCall(mEdgeGlowLeft.onRelease(), [VariableReference(mEdgeGlowLeft, []), Expression(, [])])    VariableReference(mEdgeGlowLeft, [])    Expression(, [])  Statement(}, [])  Statement(}, [])  MethodCall(if (shouldDisplayEdgeEffects() && (!mEdgeGlowLeft.isFinished() || !mEdgeGlowRight.isFinished())), [VariableReference(if (shouldDisplayEdgeEffects() && (!mEdgeGlowLeft, []), Expression() || !mEdgeGlowRight.isFinished()), [])])    VariableReference(if (shouldDisplayEdgeEffects() && (!mEdgeGlowLeft, [])    Expression() || !mEdgeGlowRight.isFinished()), [])  Statement(postInvalidateOnAnimation(), [])  Statement(}, [])  Statement(}, [])  Statement(}, [])  Statement(break, [])  Statement(case MotionEvent.ACTION_UP:, [])  Statement(if (mIsBeingDragged) {, [])  AssignmentExpression(=, [VariableReference(final VelocityTracker velocityTracker, []), Expression(mVelocityTracker, [])])    VariableReference(final VelocityTracker velocityTracker, [])    Expression(mVelocityTracker, [])  MethodCall(velocityTracker.computeCurrentVelocity(1000, mMaximumVelocity), [VariableReference(velocityTracker, []), Expression(1000, []), Expression(mMaximumVelocity, [])])    VariableReference(velocityTracker, [])    Expression(1000, [])    Expression(mMaximumVelocity, [])  AssignmentExpression(=, [VariableReference(int initialVelocity, []), Expression((int) velocityTracker.getXVelocity(mActivePointerId), [])])    VariableReference(int initialVelocity, [])    Expression((int) velocityTracker.getXVelocity(mActivePointerId), [])  Statement(if (getChildCount() > 0) {, [])  MethodCall(if ((Math.abs(initialVelocity) > mMinimumVelocity)), [VariableReference(if ((Math, []), Expression(initialVelocity) > mMinimumVelocity), [])])    VariableReference(if ((Math, [])    Expression(initialVelocity) > mMinimumVelocity), [])  Statement(fling(-initialVelocity), [])  Statement(} else {, [])  MethodCall(if (mScroller.springBack(mScrollX, mScrollY, 0, getScrollRange(), 0, 0)), [VariableReference(if (mScroller, []), Expression(mScrollX, []), Expression(mScrollY, []), Expression(0, []), Expression(getScrollRange(), []), Expression(0, []), Expression(0), [])])    VariableReference(if (mScroller, [])    Expression(mScrollX, [])    Expression(mScrollY, [])    Expression(0, [])    Expression(getScrollRange(), [])    Expression(0, [])    Expression(0), [])  Statement(postInvalidateOnAnimation(), [])  Statement(}, [])  Statement(}, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(mActivePointerId, []), Expression(INVALID_POINTER, [])])    VariableReference(mActivePointerId, [])    Expression(INVALID_POINTER, [])  AssignmentExpression(=, [VariableReference(mIsBeingDragged, []), Expression(false, [])])    VariableReference(mIsBeingDragged, [])    Expression(false, [])  Statement(recycleVelocityTracker(), [])  Statement(if (shouldDisplayEdgeEffects()) {, [])  MethodCall(mEdgeGlowLeft.onRelease(), [VariableReference(mEdgeGlowLeft, []), Expression(, [])])    VariableReference(mEdgeGlowLeft, [])    Expression(, [])  MethodCall(mEdgeGlowRight.onRelease(), [VariableReference(mEdgeGlowRight, []), Expression(, [])])    VariableReference(mEdgeGlowRight, [])    Expression(, [])  Statement(}, [])  Statement(}, [])  Statement(break, [])  Statement(case MotionEvent.ACTION_CANCEL:, [])  Statement(if (mIsBeingDragged && getChildCount() > 0) {, [])  MethodCall(if (mScroller.springBack(mScrollX, mScrollY, 0, getScrollRange(), 0, 0)), [VariableReference(if (mScroller, []), Expression(mScrollX, []), Expression(mScrollY, []), Expression(0, []), Expression(getScrollRange(), []), Expression(0, []), Expression(0), [])])    VariableReference(if (mScroller, [])    Expression(mScrollX, [])    Expression(mScrollY, [])    Expression(0, [])    Expression(getScrollRange(), [])    Expression(0, [])    Expression(0), [])  Statement(postInvalidateOnAnimation(), [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(mActivePointerId, []), Expression(INVALID_POINTER, [])])    VariableReference(mActivePointerId, [])    Expression(INVALID_POINTER, [])  AssignmentExpression(=, [VariableReference(mIsBeingDragged, []), Expression(false, [])])    VariableReference(mIsBeingDragged, [])    Expression(false, [])  Statement(recycleVelocityTracker(), [])  Statement(if (shouldDisplayEdgeEffects()) {, [])  MethodCall(mEdgeGlowLeft.onRelease(), [VariableReference(mEdgeGlowLeft, []), Expression(, [])])    VariableReference(mEdgeGlowLeft, [])    Expression(, [])  MethodCall(mEdgeGlowRight.onRelease(), [VariableReference(mEdgeGlowRight, []), Expression(, [])])    VariableReference(mEdgeGlowRight, [])    Expression(, [])  Statement(}, [])  Statement(}, [])  Statement(break, [])  Statement(case MotionEvent.ACTION_POINTER_UP:, [])  Statement(onSecondaryPointerUp(ev), [])  Statement(break, [])  Statement(}, [])  Statement(return true, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(initVelocityTrackerIfNotExists(), []), MethodCall(mVelocityTracker.addMovement(ev), [VariableReference(mVelocityTracker, []), Expression(ev, [])]), AssignmentExpression(=, [VariableReference(final int action, []), Expression(ev.getAction(), [])]), Statement(case MotionEvent.ACTION_DOWN:, []), Statement({, []), AssignmentExpression(=, [VariableReference(if (getChildCount(), []), Expression(, [])]), Statement(return false, []), Statement(}, []), MethodCall(if (!mScroller.isFinished()), [VariableReference(if (!mScroller, []), Expression(), [])]), AssignmentExpression(=, [VariableReference(final ViewParent parent, []), Expression(getParent(), [])]), AssignmentExpression(=, [VariableReference(if (parent !, []), Expression(null) {, [])]), MethodCall(parent.requestDisallowInterceptTouchEvent(true), [VariableReference(parent, []), Expression(true, [])]), Statement(}, []), Statement(}, []), Statement(/*, []), Statement(* If being flinged and user touches, stop the fling. isFinished, []), Statement(* will be false if being flinged., []), Statement(*/, []), MethodCall(if (!mScroller.isFinished()), [VariableReference(if (!mScroller, []), Expression(), [])]), MethodCall(mScroller.abortAnimation(), [VariableReference(mScroller, []), Expression(, [])]), Statement(}, []), Statement(// Remember where the motion event started, []), AssignmentExpression(=, [VariableReference(mLastMotionX, []), Expression((int) ev.getX(), [])]), AssignmentExpression(=, [VariableReference(mActivePointerId, []), Expression(ev.getPointerId(0), [])]), Statement(break, []), Statement(}, []), Statement(case MotionEvent.ACTION_MOVE:, []), AssignmentExpression(=, [VariableReference(final int activePointerIndex, []), Expression(ev.findPointerIndex(mActivePointerId), [])]), AssignmentExpression(=, [VariableReference(if (activePointerIndex, []), Expression(, [])]), AssignmentExpression(=, [VariableReference(Log.e(TAG, ""Invalid pointerId, []), Expression("" + mActivePointerId + "" in onTouchEvent""), [])]), Statement(break, []), Statement(}, []), AssignmentExpression(=, [VariableReference(final int x, []), Expression((int) ev.getX(activePointerIndex), [])]), AssignmentExpression(=, [VariableReference(int deltaX, []), Expression(mLastMotionX - x, [])]), MethodCall(if (!mIsBeingDragged && Math.abs(deltaX) > mTouchSlop), [VariableReference(if (!mIsBeingDragged && Math, []), Expression(deltaX) > mTouchSlop, [])]), AssignmentExpression(=, [VariableReference(final ViewParent parent, []), Expression(getParent(), [])]), AssignmentExpression(=, [VariableReference(if (parent !, []), Expression(null) {, [])]), MethodCall(parent.requestDisallowInterceptTouchEvent(true), [VariableReference(parent, []), Expression(true, [])]), Statement(}, []), AssignmentExpression(=, [VariableReference(mIsBeingDragged, []), Expression(true, [])]), Statement(if (deltaX > 0) {, []), AssignmentExpression(=, [VariableReference(deltaX -, []), Expression(mTouchSlop, [])]), Statement(} else {, []), AssignmentExpression(=, [VariableReference(deltaX +, []), Expression(mTouchSlop, [])]), Statement(}, []), Statement(}, []), Statement(if (mIsBeingDragged) {, []), Statement(// Scroll to follow the motion event, []), AssignmentExpression(=, [VariableReference(mLastMotionX, []), Expression(x, [])]), AssignmentExpression(=, [VariableReference(final int oldX, []), Expression(mScrollX, [])]), AssignmentExpression(=, [VariableReference(final int range, []), Expression(getScrollRange(), [])]), AssignmentExpression(=, [VariableReference(final int overscrollMode, []), Expression(getOverScrollMode(), [])]), AssignmentExpression(=, [VariableReference(final boolean canOverscroll, []), Expression(overscrollMode, [])]), AssignmentExpression(=, [VariableReference(final float displacement, []), Expression(ev.getY(activePointerIndex) / getHeight(), [])]), Statement(if (canOverscroll) {, []), AssignmentExpression(=, [VariableReference(int consumed, []), Expression(0, [])]), AssignmentExpression(=, [VariableReference(if (deltaX < 0 && mEdgeGlowRight.getDistance() !, []), Expression(0f) {, [])]), AssignmentExpression(=, [VariableReference(consumed, []), Expression(Math.round(getWidth() * mEdgeGlowRight.onPullDistance((float) deltaX / getWidth(), displacement)), [])]), AssignmentExpression(=, [VariableReference(} else if (deltaX > 0 && mEdgeGlowLeft.getDistance() !, []), Expression(0f) {, [])]), AssignmentExpression(=, [VariableReference(consumed, []), Expression(Math.round(-getWidth() * mEdgeGlowLeft.onPullDistance((float) -deltaX / getWidth(), 1 - displacement)), [])]), Statement(}, []), AssignmentExpression(=, [VariableReference(deltaX -, []), Expression(consumed, [])]), Statement(}, []), Statement(// Calling overScrollBy will call onOverScrolled, which, []), Statement(// calls onScrollChanged if applicable., []), Statement(overScrollBy(deltaX, 0, mScrollX, 0, range, 0, mOverscrollDistance, 0, true), []), AssignmentExpression(=, [VariableReference(if (canOverscroll && deltaX !, []), Expression(0f) {, [])]), AssignmentExpression(=, [VariableReference(final int pulledToX, []), Expression(oldX + deltaX, [])]), Statement(if (pulledToX < 0) {, []), MethodCall(mEdgeGlowLeft.onPullDistance((float) -deltaX / getWidth(), 1.f - displacement), [VariableReference(mEdgeGlowLeft, []), Expression((float) -deltaX / getWidth(), []), Expression(1.f - displacement, [])]), MethodCall(if (!mEdgeGlowRight.isFinished()), [VariableReference(if (!mEdgeGlowRight, []), Expression(), [])]), MethodCall(mEdgeGlowRight.onRelease(), [VariableReference(mEdgeGlowRight, []), Expression(, [])]), Statement(}, []), Statement(} else if (pulledToX > range) {, []), MethodCall(mEdgeGlowRight.onPullDistance((float) deltaX / getWidth(), displacement), [VariableReference(mEdgeGlowRight, []), Expression((float) deltaX / getWidth(), []), Expression(displacement, [])]), MethodCall(if (!mEdgeGlowLeft.isFinished()), [VariableReference(if (!mEdgeGlowLeft, []), Expression(), [])]), MethodCall(mEdgeGlowLeft.onRelease(), [VariableReference(mEdgeGlowLeft, []), Expression(, [])]), Statement(}, []), Statement(}, []), MethodCall(if (shouldDisplayEdgeEffects() && (!mEdgeGlowLeft.isFinished() || !mEdgeGlowRight.isFinished())), [VariableReference(if (shouldDisplayEdgeEffects() && (!mEdgeGlowLeft, []), Expression() || !mEdgeGlowRight.isFinished()), [])]), Statement(postInvalidateOnAnimation(), []), Statement(}, []), Statement(}, []), Statement(}, []), Statement(break, []), Statement(case MotionEvent.ACTION_UP:, []), Statement(if (mIsBeingDragged) {, []), AssignmentExpression(=, [VariableReference(final VelocityTracker velocityTracker, []), Expression(mVelocityTracker, [])]), MethodCall(velocityTracker.computeCurrentVelocity(1000, mMaximumVelocity), [VariableReference(velocityTracker, []), Expression(1000, []), Expression(mMaximumVelocity, [])]), AssignmentExpression(=, [VariableReference(int initialVelocity, []), Expression((int) velocityTracker.getXVelocity(mActivePointerId), [])]), Statement(if (getChildCount() > 0) {, []), MethodCall(if ((Math.abs(initialVelocity) > mMinimumVelocity)), [VariableReference(if ((Math, []), Expression(initialVelocity) > mMinimumVelocity), [])]), Statement(fling(-initialVelocity), []), Statement(} else {, []), MethodCall(if (mScroller.springBack(mScrollX, mScrollY, 0, getScrollRange(), 0, 0)), [VariableReference(if (mScroller, []), Expression(mScrollX, []), Expression(mScrollY, []), Expression(0, []), Expression(getScrollRange(), []), Expression(0, []), Expression(0), [])]), Statement(postInvalidateOnAnimation(), []), Statement(}, []), Statement(}, []), Statement(}, []), AssignmentExpression(=, [VariableReference(mActivePointerId, []), Expression(INVALID_POINTER, [])]), AssignmentExpression(=, [VariableReference(mIsBeingDragged, []), Expression(false, [])]), Statement(recycleVelocityTracker(), []), Statement(if (shouldDisplayEdgeEffects()) {, []), MethodCall(mEdgeGlowLeft.onRelease(), [VariableReference(mEdgeGlowLeft, []), Expression(, [])]), MethodCall(mEdgeGlowRight.onRelease(), [VariableReference(mEdgeGlowRight, []), Expression(, [])]), Statement(}, []), Statement(}, []), Statement(break, []), Statement(case MotionEvent.ACTION_CANCEL:, []), Statement(if (mIsBeingDragged && getChildCount() > 0) {, []), MethodCall(if (mScroller.springBack(mScrollX, mScrollY, 0, getScrollRange(), 0, 0)), [VariableReference(if (mScroller, []), Expression(mScrollX, []), Expression(mScrollY, []), Expression(0, []), Expression(getScrollRange(), []), Expression(0, []), Expression(0), [])]), Statement(postInvalidateOnAnimation(), []), Statement(}, []), AssignmentExpression(=, [VariableReference(mActivePointerId, []), Expression(INVALID_POINTER, [])]), AssignmentExpression(=, [VariableReference(mIsBeingDragged, []), Expression(false, [])]), Statement(recycleVelocityTracker(), []), Statement(if (shouldDisplayEdgeEffects()) {, []), MethodCall(mEdgeGlowLeft.onRelease(), [VariableReference(mEdgeGlowLeft, []), Expression(, [])]), MethodCall(mEdgeGlowRight.onRelease(), [VariableReference(mEdgeGlowRight, []), Expression(, [])]), Statement(}, []), Statement(}, []), Statement(break, []), Statement(case MotionEvent.ACTION_POINTER_UP:, []), Statement(onSecondaryPointerUp(ev), []), Statement(break, []), Statement(}, []), Statement(return true, []), Statement(}, [])])  Statement({, [])  Statement(initVelocityTrackerIfNotExists(), [])  MethodCall(mVelocityTracker.addMovement(ev), [VariableReference(mVelocityTracker, []), Expression(ev, [])])    VariableReference(mVelocityTracker, [])    Expression(ev, [])  AssignmentExpression(=, [VariableReference(final int action, []), Expression(ev.getAction(), [])])    VariableReference(final int action, [])    Expression(ev.getAction(), [])  Statement(case MotionEvent.ACTION_DOWN:, [])  Statement({, [])  AssignmentExpression(=, [VariableReference(if (getChildCount(), []), Expression(, [])])    VariableReference(if (getChildCount(), [])    Expression(, [])  Statement(return false, [])  Statement(}, [])  MethodCall(if (!mScroller.isFinished()), [VariableReference(if (!mScroller, []), Expression(), [])])    VariableReference(if (!mScroller, [])    Expression(), [])  AssignmentExpression(=, [VariableReference(final ViewParent parent, []), Expression(getParent(), [])])    VariableReference(final ViewParent parent, [])    Expression(getParent(), [])  AssignmentExpression(=, [VariableReference(if (parent !, []), Expression(null) {, [])])    VariableReference(if (parent !, [])    Expression(null) {, [])  MethodCall(parent.requestDisallowInterceptTouchEvent(true), [VariableReference(parent, []), Expression(true, [])])    VariableReference(parent, [])    Expression(true, [])  Statement(}, [])  Statement(}, [])  Statement(/*, [])  Statement(* If being flinged and user touches, stop the fling. isFinished, [])  Statement(* will be false if being flinged., [])  Statement(*/, [])  MethodCall(if (!mScroller.isFinished()), [VariableReference(if (!mScroller, []), Expression(), [])])    VariableReference(if (!mScroller, [])    Expression(), [])  MethodCall(mScroller.abortAnimation(), [VariableReference(mScroller, []), Expression(, [])])    VariableReference(mScroller, [])    Expression(, [])  Statement(}, [])  Statement(// Remember where the motion event started, [])  AssignmentExpression(=, [VariableReference(mLastMotionX, []), Expression((int) ev.getX(), [])])    VariableReference(mLastMotionX, [])    Expression((int) ev.getX(), [])  AssignmentExpression(=, [VariableReference(mActivePointerId, []), Expression(ev.getPointerId(0), [])])    VariableReference(mActivePointerId, [])    Expression(ev.getPointerId(0), [])  Statement(break, [])  Statement(}, [])  Statement(case MotionEvent.ACTION_MOVE:, [])  AssignmentExpression(=, [VariableReference(final int activePointerIndex, []), Expression(ev.findPointerIndex(mActivePointerId), [])])    VariableReference(final int activePointerIndex, [])    Expression(ev.findPointerIndex(mActivePointerId), [])  AssignmentExpression(=, [VariableReference(if (activePointerIndex, []), Expression(, [])])    VariableReference(if (activePointerIndex, [])    Expression(, [])  AssignmentExpression(=, [VariableReference(Log.e(TAG, ""Invalid pointerId, []), Expression("" + mActivePointerId + "" in onTouchEvent""), [])])    VariableReference(Log.e(TAG, ""Invalid pointerId, [])    Expression("" + mActivePointerId + "" in onTouchEvent""), [])  Statement(break, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(final int x, []), Expression((int) ev.getX(activePointerIndex), [])])    VariableReference(final int x, [])    Expression((int) ev.getX(activePointerIndex), [])  AssignmentExpression(=, [VariableReference(int deltaX, []), Expression(mLastMotionX - x, [])])    VariableReference(int deltaX, [])    Expression(mLastMotionX - x, [])  MethodCall(if (!mIsBeingDragged && Math.abs(deltaX) > mTouchSlop), [VariableReference(if (!mIsBeingDragged && Math, []), Expression(deltaX) > mTouchSlop, [])])    VariableReference(if (!mIsBeingDragged && Math, [])    Expression(deltaX) > mTouchSlop, [])  AssignmentExpression(=, [VariableReference(final ViewParent parent, []), Expression(getParent(), [])])    VariableReference(final ViewParent parent, [])    Expression(getParent(), [])  AssignmentExpression(=, [VariableReference(if (parent !, []), Expression(null) {, [])])    VariableReference(if (parent !, [])    Expression(null) {, [])  MethodCall(parent.requestDisallowInterceptTouchEvent(true), [VariableReference(parent, []), Expression(true, [])])    VariableReference(parent, [])    Expression(true, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(mIsBeingDragged, []), Expression(true, [])])    VariableReference(mIsBeingDragged, [])    Expression(true, [])  Statement(if (deltaX > 0) {, [])  AssignmentExpression(=, [VariableReference(deltaX -, []), Expression(mTouchSlop, [])])    VariableReference(deltaX -, [])    Expression(mTouchSlop, [])  Statement(} else {, [])  AssignmentExpression(=, [VariableReference(deltaX +, []), Expression(mTouchSlop, [])])    VariableReference(deltaX +, [])    Expression(mTouchSlop, [])  Statement(}, [])  Statement(}, [])  Statement(if (mIsBeingDragged) {, [])  Statement(// Scroll to follow the motion event, [])  AssignmentExpression(=, [VariableReference(mLastMotionX, []), Expression(x, [])])    VariableReference(mLastMotionX, [])    Expression(x, [])  AssignmentExpression(=, [VariableReference(final int oldX, []), Expression(mScrollX, [])])    VariableReference(final int oldX, [])    Expression(mScrollX, [])  AssignmentExpression(=, [VariableReference(final int range, []), Expression(getScrollRange(), [])])    VariableReference(final int range, [])    Expression(getScrollRange(), [])  AssignmentExpression(=, [VariableReference(final int overscrollMode, []), Expression(getOverScrollMode(), [])])    VariableReference(final int overscrollMode, [])    Expression(getOverScrollMode(), [])  AssignmentExpression(=, [VariableReference(final boolean canOverscroll, []), Expression(overscrollMode, [])])    VariableReference(final boolean canOverscroll, [])    Expression(overscrollMode, [])  AssignmentExpression(=, [VariableReference(final float displacement, []), Expression(ev.getY(activePointerIndex) / getHeight(), [])])    VariableReference(final float displacement, [])    Expression(ev.getY(activePointerIndex) / getHeight(), [])  Statement(if (canOverscroll) {, [])  AssignmentExpression(=, [VariableReference(int consumed, []), Expression(0, [])])    VariableReference(int consumed, [])    Expression(0, [])  AssignmentExpression(=, [VariableReference(if (deltaX < 0 && mEdgeGlowRight.getDistance() !, []), Expression(0f) {, [])])    VariableReference(if (deltaX < 0 && mEdgeGlowRight.getDistance() !, [])    Expression(0f) {, [])  AssignmentExpression(=, [VariableReference(consumed, []), Expression(Math.round(getWidth() * mEdgeGlowRight.onPullDistance((float) deltaX / getWidth(), displacement)), [])])    VariableReference(consumed, [])    Expression(Math.round(getWidth() * mEdgeGlowRight.onPullDistance((float) deltaX / getWidth(), displacement)), [])  AssignmentExpression(=, [VariableReference(} else if (deltaX > 0 && mEdgeGlowLeft.getDistance() !, []), Expression(0f) {, [])])    VariableReference(} else if (deltaX > 0 && mEdgeGlowLeft.getDistance() !, [])    Expression(0f) {, [])  AssignmentExpression(=, [VariableReference(consumed, []), Expression(Math.round(-getWidth() * mEdgeGlowLeft.onPullDistance((float) -deltaX / getWidth(), 1 - displacement)), [])])    VariableReference(consumed, [])    Expression(Math.round(-getWidth() * mEdgeGlowLeft.onPullDistance((float) -deltaX / getWidth(), 1 - displacement)), [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(deltaX -, []), Expression(consumed, [])])    VariableReference(deltaX -, [])    Expression(consumed, [])  Statement(}, [])  Statement(// Calling overScrollBy will call onOverScrolled, which, [])  Statement(// calls onScrollChanged if applicable., [])  Statement(overScrollBy(deltaX, 0, mScrollX, 0, range, 0, mOverscrollDistance, 0, true), [])  AssignmentExpression(=, [VariableReference(if (canOverscroll && deltaX !, []), Expression(0f) {, [])])    VariableReference(if (canOverscroll && deltaX !, [])    Expression(0f) {, [])  AssignmentExpression(=, [VariableReference(final int pulledToX, []), Expression(oldX + deltaX, [])])    VariableReference(final int pulledToX, [])    Expression(oldX + deltaX, [])  Statement(if (pulledToX < 0) {, [])  MethodCall(mEdgeGlowLeft.onPullDistance((float) -deltaX / getWidth(), 1.f - displacement), [VariableReference(mEdgeGlowLeft, []), Expression((float) -deltaX / getWidth(), []), Expression(1.f - displacement, [])])    VariableReference(mEdgeGlowLeft, [])    Expression((float) -deltaX / getWidth(), [])    Expression(1.f - displacement, [])  MethodCall(if (!mEdgeGlowRight.isFinished()), [VariableReference(if (!mEdgeGlowRight, []), Expression(), [])])    VariableReference(if (!mEdgeGlowRight, [])    Expression(), [])  MethodCall(mEdgeGlowRight.onRelease(), [VariableReference(mEdgeGlowRight, []), Expression(, [])])    VariableReference(mEdgeGlowRight, [])    Expression(, [])  Statement(}, [])  Statement(} else if (pulledToX > range) {, [])  MethodCall(mEdgeGlowRight.onPullDistance((float) deltaX / getWidth(), displacement), [VariableReference(mEdgeGlowRight, []), Expression((float) deltaX / getWidth(), []), Expression(displacement, [])])    VariableReference(mEdgeGlowRight, [])    Expression((float) deltaX / getWidth(), [])    Expression(displacement, [])  MethodCall(if (!mEdgeGlowLeft.isFinished()), [VariableReference(if (!mEdgeGlowLeft, []), Expression(), [])])    VariableReference(if (!mEdgeGlowLeft, [])    Expression(), [])  MethodCall(mEdgeGlowLeft.onRelease(), [VariableReference(mEdgeGlowLeft, []), Expression(, [])])    VariableReference(mEdgeGlowLeft, [])    Expression(, [])  Statement(}, [])  Statement(}, [])  MethodCall(if (shouldDisplayEdgeEffects() && (!mEdgeGlowLeft.isFinished() || !mEdgeGlowRight.isFinished())), [VariableReference(if (shouldDisplayEdgeEffects() && (!mEdgeGlowLeft, []), Expression() || !mEdgeGlowRight.isFinished()), [])])    VariableReference(if (shouldDisplayEdgeEffects() && (!mEdgeGlowLeft, [])    Expression() || !mEdgeGlowRight.isFinished()), [])  Statement(postInvalidateOnAnimation(), [])  Statement(}, [])  Statement(}, [])  Statement(}, [])  Statement(break, [])  Statement(case MotionEvent.ACTION_UP:, [])  Statement(if (mIsBeingDragged) {, [])  AssignmentExpression(=, [VariableReference(final VelocityTracker velocityTracker, []), Expression(mVelocityTracker, [])])    VariableReference(final VelocityTracker velocityTracker, [])    Expression(mVelocityTracker, [])  MethodCall(velocityTracker.computeCurrentVelocity(1000, mMaximumVelocity), [VariableReference(velocityTracker, []), Expression(1000, []), Expression(mMaximumVelocity, [])])    VariableReference(velocityTracker, [])    Expression(1000, [])    Expression(mMaximumVelocity, [])  AssignmentExpression(=, [VariableReference(int initialVelocity, []), Expression((int) velocityTracker.getXVelocity(mActivePointerId), [])])    VariableReference(int initialVelocity, [])    Expression((int) velocityTracker.getXVelocity(mActivePointerId), [])  Statement(if (getChildCount() > 0) {, [])  MethodCall(if ((Math.abs(initialVelocity) > mMinimumVelocity)), [VariableReference(if ((Math, []), Expression(initialVelocity) > mMinimumVelocity), [])])    VariableReference(if ((Math, [])    Expression(initialVelocity) > mMinimumVelocity), [])  Statement(fling(-initialVelocity), [])  Statement(} else {, [])  MethodCall(if (mScroller.springBack(mScrollX, mScrollY, 0, getScrollRange(), 0, 0)), [VariableReference(if (mScroller, []), Expression(mScrollX, []), Expression(mScrollY, []), Expression(0, []), Expression(getScrollRange(), []), Expression(0, []), Expression(0), [])])    VariableReference(if (mScroller, [])    Expression(mScrollX, [])    Expression(mScrollY, [])    Expression(0, [])    Expression(getScrollRange(), [])    Expression(0, [])    Expression(0), [])  Statement(postInvalidateOnAnimation(), [])  Statement(}, [])  Statement(}, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(mActivePointerId, []), Expression(INVALID_POINTER, [])])    VariableReference(mActivePointerId, [])    Expression(INVALID_POINTER, [])  AssignmentExpression(=, [VariableReference(mIsBeingDragged, []), Expression(false, [])])    VariableReference(mIsBeingDragged, [])    Expression(false, [])  Statement(recycleVelocityTracker(), [])  Statement(if (shouldDisplayEdgeEffects()) {, [])  MethodCall(mEdgeGlowLeft.onRelease(), [VariableReference(mEdgeGlowLeft, []), Expression(, [])])    VariableReference(mEdgeGlowLeft, [])    Expression(, [])  MethodCall(mEdgeGlowRight.onRelease(), [VariableReference(mEdgeGlowRight, []), Expression(, [])])    VariableReference(mEdgeGlowRight, [])    Expression(, [])  Statement(}, [])  Statement(}, [])  Statement(break, [])  Statement(case MotionEvent.ACTION_CANCEL:, [])  Statement(if (mIsBeingDragged && getChildCount() > 0) {, [])  MethodCall(if (mScroller.springBack(mScrollX, mScrollY, 0, getScrollRange(), 0, 0)), [VariableReference(if (mScroller, []), Expression(mScrollX, []), Expression(mScrollY, []), Expression(0, []), Expression(getScrollRange(), []), Expression(0, []), Expression(0), [])])    VariableReference(if (mScroller, [])    Expression(mScrollX, [])    Expression(mScrollY, [])    Expression(0, [])    Expression(getScrollRange(), [])    Expression(0, [])    Expression(0), [])  Statement(postInvalidateOnAnimation(), [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(mActivePointerId, []), Expression(INVALID_POINTER, [])])    VariableReference(mActivePointerId, [])    Expression(INVALID_POINTER, [])  AssignmentExpression(=, [VariableReference(mIsBeingDragged, []), Expression(false, [])])    VariableReference(mIsBeingDragged, [])    Expression(false, [])  Statement(recycleVelocityTracker(), [])  Statement(if (shouldDisplayEdgeEffects()) {, [])  MethodCall(mEdgeGlowLeft.onRelease(), [VariableReference(mEdgeGlowLeft, []), Expression(, [])])    VariableReference(mEdgeGlowLeft, [])    Expression(, [])  MethodCall(mEdgeGlowRight.onRelease(), [VariableReference(mEdgeGlowRight, []), Expression(, [])])    VariableReference(mEdgeGlowRight, [])    Expression(, [])  Statement(}, [])  Statement(}, [])  Statement(break, [])  Statement(case MotionEvent.ACTION_POINTER_UP:, [])  Statement(onSecondaryPointerUp(ev), [])  Statement(break, [])  Statement(}, [])  Statement(return true, [])  Statement(}, [])",1,,,0,[@Override],[@Override],0,,,,"1,2","3,4,5",0,3,0,"The control dependency of a conditional statement in the while loop has been changed slightly, as noted by the differences in condition verification.","The introduced change does not affect the return values or exception handling of the method. Therefore, no Compatibility Issue is foreseen."
4,<android.view.textclassifier.TextClassificationSession: TextLanguage detectLanguage(Request)>,30,31,,,,"MethodDeclaration(method_body, [Statement({, []), Statement(checkDestroyed(), []), MethodCall(return mDelegate.detectLanguage(request), [VariableReference(return mDelegate, []), Expression(request, [])]), Statement(}, [])])  Statement({, [])  Statement(checkDestroyed(), [])  MethodCall(return mDelegate.detectLanguage(request), [VariableReference(return mDelegate, []), Expression(request, [])])    VariableReference(return mDelegate, [])    Expression(request, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), MethodCall(return checkDestroyedAndRun(() -> mDelegate.detectLanguage(request)), [VariableReference(return checkDestroyedAndRun(() -> mDelegate, []), Expression(request), [])]), Statement(}, [])])  Statement({, [])  MethodCall(return checkDestroyedAndRun(() -> mDelegate.detectLanguage(request)), [VariableReference(return checkDestroyedAndRun(() -> mDelegate, []), Expression(request), [])])    VariableReference(return checkDestroyedAndRun(() -> mDelegate, [])    Expression(request), [])  Statement(}, [])",1,,,0,[@Override],[@Override],0,,,,2,"1,5",1,"3,5",0,"The control dependency of calling `checkDestroyed()` separately has been changed to integrate it into the `checkDestroyedAndRun` method call. Besides, it modifies how the `detectLanguage` method is invoked but still results in the same call to `mDelegate.detectLanguage(request)`. Thus, the change can be categorized as 3,5.","Despite the control dependency and dependent API change, the behavior produced by this revamped implementation doesn't seemingly alter the return value or the exception handling of the `detectLanguage` method in a way that could lead to compatibility issues. Therefore, the CI type is 0."
5,<android.inputmethodservice.InputMethodService: void requestShowSelf(int)>,30,31,,,,"MethodDeclaration(method_body, [Statement({, []), MethodCall(mPrivOps.showMySoftInput(flags), [VariableReference(mPrivOps, []), Expression(flags, [])]), Statement(}, [])])  Statement({, [])  MethodCall(mPrivOps.showMySoftInput(flags), [VariableReference(mPrivOps, []), Expression(flags, [])])    VariableReference(mPrivOps, [])    Expression(flags, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), MethodCall(ImeTracing.getInstance().triggerServiceDump(""InputMethodService#requestShowSelf"", this, null), [VariableReference(ImeTracing, []), Expression().triggerServiceDump(""InputMethodService#requestShowSelf"", []), Expression(this, []), Expression(null, [])]), MethodCall(mPrivOps.showMySoftInput(flags), [VariableReference(mPrivOps, []), Expression(flags, [])]), Statement(}, [])])  Statement({, [])  MethodCall(ImeTracing.getInstance().triggerServiceDump(""InputMethodService#requestShowSelf"", this, null), [VariableReference(ImeTracing, []), Expression().triggerServiceDump(""InputMethodService#requestShowSelf"", []), Expression(this, []), Expression(null, [])])    VariableReference(ImeTracing, [])    Expression().triggerServiceDump(""InputMethodService#requestShowSelf"", [])    Expression(this, [])    Expression(null, [])  MethodCall(mPrivOps.showMySoftInput(flags), [VariableReference(mPrivOps, []), Expression(flags, [])])    VariableReference(mPrivOps, [])    Expression(flags, [])  Statement(}, [])",1,"/**
 * Show the input method's soft input area, so the user sees the input method window and can
 * interact with it.
 *
 * @see InputMethodManager#SHOW_IMPLICIT
 * @see InputMethodManager#SHOW_FORCED
 * @param flags Provides additional operating flags.
 */
","/**
 * Show the input method's soft input area, so the user sees the input method window and can
 * interact with it.
 *
 * @see InputMethodManager#SHOW_IMPLICIT
 * @see InputMethodManager#SHOW_FORCED
 * @param flags Provides additional operating flags.
 */
",0,,,0,,,,"1,2",4,0,4,0,"A new statement (`ImeTracing.getInstance().triggerServiceDump(""InputMethodService#requestShowSelf"", this, null)`) has been introduced before the existing method call (`mPrivOps.showMySoftInput(flags)`). This change does not affect the return value or exception handling directly. Therefore, the code change type is 4.","Since the new statement added does not modify the return value or the exception handling behavior of the method, no compatibility issue exists. The CI type is 0."
6,<android.app.LoadedApk.ReceiverDispatcher.Args: Runnable getRunnable()>,30,31,,,,"MethodDeclaration(method_body, [Statement({, []), Statement(return () -> {, []), AssignmentExpression(=, [VariableReference(final BroadcastReceiver receiver, []), Expression(mReceiver, [])]), AssignmentExpression(=, [VariableReference(final boolean ordered, []), Expression(mOrdered, [])]), AssignmentExpression(=, [VariableReference(int seq, []), Expression(mCurIntent.getIntExtra(""seq"", -1), [])]), AssignmentExpression(=, [VariableReference(Slog.i(ActivityThread.TAG, ""Dispatching broadcast "" + mCurIntent.getAction() + "" seq, []), Expression("" + seq + "" to "" + mReceiver), [])]), AssignmentExpression(=, [VariableReference(Slog.i(ActivityThread.TAG, ""  mRegistered, []), Expression("" + mRegistered + "" mOrderedHint, [])]), Statement(}, []), AssignmentExpression(=, [VariableReference(final IActivityManager mgr, []), Expression(ActivityManager.getService(), [])]), AssignmentExpression(=, [VariableReference(final Intent intent, []), Expression(mCurIntent, [])]), AssignmentExpression(=, [VariableReference(if (intent, []), Expression(, [])]), AssignmentExpression(=, [VariableReference(Log.wtf(TAG, ""Null intent being dispatched, mDispatched, []), Expression("" + mDispatched + (mRunCalled ? "", run() has already been called"" : """")), [])]), Statement(}, []), AssignmentExpression(=, [VariableReference(mCurIntent, []), Expression(null, [])]), AssignmentExpression(=, [VariableReference(mDispatched, []), Expression(true, [])]), AssignmentExpression(=, [VariableReference(mRunCalled, []), Expression(true, [])]), AssignmentExpression(=, [VariableReference(if (receiver, []), Expression(, [])]), Statement(if (mRegistered && ordered) {, []), MethodCall(Slog.i(ActivityThread.TAG, ""Finishing null broadcast to "" + mReceiver), [VariableReference(Slog, []), Expression(ActivityThread.TAG, []), Expression(""Finishing null broadcast to "" + mReceiver, [])]), Statement(sendFinished(mgr), []), Statement(}, []), Statement(return, []), Statement(}, []), MethodCall(Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""broadcastReceiveReg""), [VariableReference(Trace, []), Expression(Trace.TRACE_TAG_ACTIVITY_MANAGER, []), Expression(""broadcastReceiveReg"", [])]), Statement(try {, []), AssignmentExpression(=, [VariableReference(ClassLoader cl, []), Expression(mReceiver.getClass().getClassLoader(), [])]), MethodCall(intent.setExtrasClassLoader(cl), [VariableReference(intent, []), Expression(cl, [])]), MethodCall(intent.prepareToEnterProcess(), [VariableReference(intent, []), Expression(, [])]), Statement(setExtrasClassLoader(cl), []), MethodCall(receiver.setPendingResult(this), [VariableReference(receiver, []), Expression(this, [])]), MethodCall(receiver.onReceive(mContext, intent), [VariableReference(receiver, []), Expression(mContext, []), Expression(intent, [])]), Statement(} catch (Exception e) {, []), Statement(if (mRegistered && ordered) {, []), MethodCall(Slog.i(ActivityThread.TAG, ""Finishing failed broadcast to "" + mReceiver), [VariableReference(Slog, []), Expression(ActivityThread.TAG, []), Expression(""Finishing failed broadcast to "" + mReceiver, [])]), Statement(sendFinished(mgr), []), Statement(}, []), AssignmentExpression(=, [VariableReference(if (mInstrumentation, []), Expression(, [])]), MethodCall(Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER), [VariableReference(Trace, []), Expression(Trace.TRACE_TAG_ACTIVITY_MANAGER, [])]), Statement(throw new RuntimeException(""Error receiving broadcast "" + intent + "" in "" + mReceiver, e), []), Statement(}, []), Statement(}, []), AssignmentExpression(=, [VariableReference(if (receiver.getPendingResult() !, []), Expression(null) {, [])]), Statement(finish(), []), Statement(}, []), MethodCall(Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER), [VariableReference(Trace, []), Expression(Trace.TRACE_TAG_ACTIVITY_MANAGER, [])]), Statement(}, []), Statement(}, [])])  Statement({, [])  Statement(return () -> {, [])  AssignmentExpression(=, [VariableReference(final BroadcastReceiver receiver, []), Expression(mReceiver, [])])    VariableReference(final BroadcastReceiver receiver, [])    Expression(mReceiver, [])  AssignmentExpression(=, [VariableReference(final boolean ordered, []), Expression(mOrdered, [])])    VariableReference(final boolean ordered, [])    Expression(mOrdered, [])  AssignmentExpression(=, [VariableReference(int seq, []), Expression(mCurIntent.getIntExtra(""seq"", -1), [])])    VariableReference(int seq, [])    Expression(mCurIntent.getIntExtra(""seq"", -1), [])  AssignmentExpression(=, [VariableReference(Slog.i(ActivityThread.TAG, ""Dispatching broadcast "" + mCurIntent.getAction() + "" seq, []), Expression("" + seq + "" to "" + mReceiver), [])])    VariableReference(Slog.i(ActivityThread.TAG, ""Dispatching broadcast "" + mCurIntent.getAction() + "" seq, [])    Expression("" + seq + "" to "" + mReceiver), [])  AssignmentExpression(=, [VariableReference(Slog.i(ActivityThread.TAG, ""  mRegistered, []), Expression("" + mRegistered + "" mOrderedHint, [])])    VariableReference(Slog.i(ActivityThread.TAG, ""  mRegistered, [])    Expression("" + mRegistered + "" mOrderedHint, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(final IActivityManager mgr, []), Expression(ActivityManager.getService(), [])])    VariableReference(final IActivityManager mgr, [])    Expression(ActivityManager.getService(), [])  AssignmentExpression(=, [VariableReference(final Intent intent, []), Expression(mCurIntent, [])])    VariableReference(final Intent intent, [])    Expression(mCurIntent, [])  AssignmentExpression(=, [VariableReference(if (intent, []), Expression(, [])])    VariableReference(if (intent, [])    Expression(, [])  AssignmentExpression(=, [VariableReference(Log.wtf(TAG, ""Null intent being dispatched, mDispatched, []), Expression("" + mDispatched + (mRunCalled ? "", run() has already been called"" : """")), [])])    VariableReference(Log.wtf(TAG, ""Null intent being dispatched, mDispatched, [])    Expression("" + mDispatched + (mRunCalled ? "", run() has already been called"" : """")), [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(mCurIntent, []), Expression(null, [])])    VariableReference(mCurIntent, [])    Expression(null, [])  AssignmentExpression(=, [VariableReference(mDispatched, []), Expression(true, [])])    VariableReference(mDispatched, [])    Expression(true, [])  AssignmentExpression(=, [VariableReference(mRunCalled, []), Expression(true, [])])    VariableReference(mRunCalled, [])    Expression(true, [])  AssignmentExpression(=, [VariableReference(if (receiver, []), Expression(, [])])    VariableReference(if (receiver, [])    Expression(, [])  Statement(if (mRegistered && ordered) {, [])  MethodCall(Slog.i(ActivityThread.TAG, ""Finishing null broadcast to "" + mReceiver), [VariableReference(Slog, []), Expression(ActivityThread.TAG, []), Expression(""Finishing null broadcast to "" + mReceiver, [])])    VariableReference(Slog, [])    Expression(ActivityThread.TAG, [])    Expression(""Finishing null broadcast to "" + mReceiver, [])  Statement(sendFinished(mgr), [])  Statement(}, [])  Statement(return, [])  Statement(}, [])  MethodCall(Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""broadcastReceiveReg""), [VariableReference(Trace, []), Expression(Trace.TRACE_TAG_ACTIVITY_MANAGER, []), Expression(""broadcastReceiveReg"", [])])    VariableReference(Trace, [])    Expression(Trace.TRACE_TAG_ACTIVITY_MANAGER, [])    Expression(""broadcastReceiveReg"", [])  Statement(try {, [])  AssignmentExpression(=, [VariableReference(ClassLoader cl, []), Expression(mReceiver.getClass().getClassLoader(), [])])    VariableReference(ClassLoader cl, [])    Expression(mReceiver.getClass().getClassLoader(), [])  MethodCall(intent.setExtrasClassLoader(cl), [VariableReference(intent, []), Expression(cl, [])])    VariableReference(intent, [])    Expression(cl, [])  MethodCall(intent.prepareToEnterProcess(), [VariableReference(intent, []), Expression(, [])])    VariableReference(intent, [])    Expression(, [])  Statement(setExtrasClassLoader(cl), [])  MethodCall(receiver.setPendingResult(this), [VariableReference(receiver, []), Expression(this, [])])    VariableReference(receiver, [])    Expression(this, [])  MethodCall(receiver.onReceive(mContext, intent), [VariableReference(receiver, []), Expression(mContext, []), Expression(intent, [])])    VariableReference(receiver, [])    Expression(mContext, [])    Expression(intent, [])  Statement(} catch (Exception e) {, [])  Statement(if (mRegistered && ordered) {, [])  MethodCall(Slog.i(ActivityThread.TAG, ""Finishing failed broadcast to "" + mReceiver), [VariableReference(Slog, []), Expression(ActivityThread.TAG, []), Expression(""Finishing failed broadcast to "" + mReceiver, [])])    VariableReference(Slog, [])    Expression(ActivityThread.TAG, [])    Expression(""Finishing failed broadcast to "" + mReceiver, [])  Statement(sendFinished(mgr), [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(if (mInstrumentation, []), Expression(, [])])    VariableReference(if (mInstrumentation, [])    Expression(, [])  MethodCall(Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER), [VariableReference(Trace, []), Expression(Trace.TRACE_TAG_ACTIVITY_MANAGER, [])])    VariableReference(Trace, [])    Expression(Trace.TRACE_TAG_ACTIVITY_MANAGER, [])  Statement(throw new RuntimeException(""Error receiving broadcast "" + intent + "" in "" + mReceiver, e), [])  Statement(}, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(if (receiver.getPendingResult() !, []), Expression(null) {, [])])    VariableReference(if (receiver.getPendingResult() !, [])    Expression(null) {, [])  Statement(finish(), [])  Statement(}, [])  MethodCall(Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER), [VariableReference(Trace, []), Expression(Trace.TRACE_TAG_ACTIVITY_MANAGER, [])])    VariableReference(Trace, [])    Expression(Trace.TRACE_TAG_ACTIVITY_MANAGER, [])  Statement(}, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(return () -> {, []), AssignmentExpression(=, [VariableReference(final BroadcastReceiver receiver, []), Expression(mReceiver, [])]), AssignmentExpression(=, [VariableReference(final boolean ordered, []), Expression(mOrdered, [])]), AssignmentExpression(=, [VariableReference(int seq, []), Expression(mCurIntent.getIntExtra(""seq"", -1), [])]), AssignmentExpression(=, [VariableReference(Slog.i(ActivityThread.TAG, ""Dispatching broadcast "" + mCurIntent.getAction() + "" seq, []), Expression("" + seq + "" to "" + mReceiver), [])]), AssignmentExpression(=, [VariableReference(Slog.i(ActivityThread.TAG, ""  mRegistered, []), Expression("" + mRegistered + "" mOrderedHint, [])]), Statement(}, []), AssignmentExpression(=, [VariableReference(final IActivityManager mgr, []), Expression(ActivityManager.getService(), [])]), AssignmentExpression(=, [VariableReference(final Intent intent, []), Expression(mCurIntent, [])]), AssignmentExpression(=, [VariableReference(if (intent, []), Expression(, [])]), AssignmentExpression(=, [VariableReference(Log.wtf(TAG, ""Null intent being dispatched, mDispatched, []), Expression("" + mDispatched + (mRunCalled ? "", run() has already been called"" : """")), [])]), Statement(}, []), AssignmentExpression(=, [VariableReference(mCurIntent, []), Expression(null, [])]), AssignmentExpression(=, [VariableReference(mDispatched, []), Expression(true, [])]), AssignmentExpression(=, [VariableReference(mRunCalled, []), Expression(true, [])]), AssignmentExpression(=, [VariableReference(if (receiver, []), Expression(, [])]), Statement(if (mRegistered && ordered) {, []), MethodCall(Slog.i(ActivityThread.TAG, ""Finishing null broadcast to "" + mReceiver), [VariableReference(Slog, []), Expression(ActivityThread.TAG, []), Expression(""Finishing null broadcast to "" + mReceiver, [])]), Statement(sendFinished(mgr), []), Statement(}, []), Statement(return, []), Statement(}, []), MethodCall(Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""broadcastReceiveReg""), [VariableReference(Trace, []), Expression(Trace.TRACE_TAG_ACTIVITY_MANAGER, []), Expression(""broadcastReceiveReg"", [])]), Statement(try {, []), AssignmentExpression(=, [VariableReference(ClassLoader cl, []), Expression(mReceiver.getClass().getClassLoader(), [])]), MethodCall(intent.setExtrasClassLoader(cl), [VariableReference(intent, []), Expression(cl, [])]), Statement(// TODO: determine at registration time if caller is, []), Statement(// protecting themselves with signature permission, []), MethodCall(intent.prepareToEnterProcess(ActivityThread.isProtectedBroadcast(intent), mContext.getAttributionSource()), [VariableReference(intent, []), Expression(ActivityThread.isProtectedBroadcast(intent), []), Expression(mContext.getAttributionSource(), [])]), Statement(setExtrasClassLoader(cl), []), MethodCall(receiver.setPendingResult(this), [VariableReference(receiver, []), Expression(this, [])]), MethodCall(receiver.onReceive(mContext, intent), [VariableReference(receiver, []), Expression(mContext, []), Expression(intent, [])]), Statement(} catch (Exception e) {, []), Statement(if (mRegistered && ordered) {, []), MethodCall(Slog.i(ActivityThread.TAG, ""Finishing failed broadcast to "" + mReceiver), [VariableReference(Slog, []), Expression(ActivityThread.TAG, []), Expression(""Finishing failed broadcast to "" + mReceiver, [])]), Statement(sendFinished(mgr), []), Statement(}, []), AssignmentExpression(=, [VariableReference(if (mInstrumentation, []), Expression(, [])]), MethodCall(Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER), [VariableReference(Trace, []), Expression(Trace.TRACE_TAG_ACTIVITY_MANAGER, [])]), Statement(throw new RuntimeException(""Error receiving broadcast "" + intent + "" in "" + mReceiver, e), []), Statement(}, []), Statement(}, []), AssignmentExpression(=, [VariableReference(if (receiver.getPendingResult() !, []), Expression(null) {, [])]), Statement(finish(), []), Statement(}, []), MethodCall(Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER), [VariableReference(Trace, []), Expression(Trace.TRACE_TAG_ACTIVITY_MANAGER, [])]), Statement(}, []), Statement(}, [])])  Statement({, [])  Statement(return () -> {, [])  AssignmentExpression(=, [VariableReference(final BroadcastReceiver receiver, []), Expression(mReceiver, [])])    VariableReference(final BroadcastReceiver receiver, [])    Expression(mReceiver, [])  AssignmentExpression(=, [VariableReference(final boolean ordered, []), Expression(mOrdered, [])])    VariableReference(final boolean ordered, [])    Expression(mOrdered, [])  AssignmentExpression(=, [VariableReference(int seq, []), Expression(mCurIntent.getIntExtra(""seq"", -1), [])])    VariableReference(int seq, [])    Expression(mCurIntent.getIntExtra(""seq"", -1), [])  AssignmentExpression(=, [VariableReference(Slog.i(ActivityThread.TAG, ""Dispatching broadcast "" + mCurIntent.getAction() + "" seq, []), Expression("" + seq + "" to "" + mReceiver), [])])    VariableReference(Slog.i(ActivityThread.TAG, ""Dispatching broadcast "" + mCurIntent.getAction() + "" seq, [])    Expression("" + seq + "" to "" + mReceiver), [])  AssignmentExpression(=, [VariableReference(Slog.i(ActivityThread.TAG, ""  mRegistered, []), Expression("" + mRegistered + "" mOrderedHint, [])])    VariableReference(Slog.i(ActivityThread.TAG, ""  mRegistered, [])    Expression("" + mRegistered + "" mOrderedHint, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(final IActivityManager mgr, []), Expression(ActivityManager.getService(), [])])    VariableReference(final IActivityManager mgr, [])    Expression(ActivityManager.getService(), [])  AssignmentExpression(=, [VariableReference(final Intent intent, []), Expression(mCurIntent, [])])    VariableReference(final Intent intent, [])    Expression(mCurIntent, [])  AssignmentExpression(=, [VariableReference(if (intent, []), Expression(, [])])    VariableReference(if (intent, [])    Expression(, [])  AssignmentExpression(=, [VariableReference(Log.wtf(TAG, ""Null intent being dispatched, mDispatched, []), Expression("" + mDispatched + (mRunCalled ? "", run() has already been called"" : """")), [])])    VariableReference(Log.wtf(TAG, ""Null intent being dispatched, mDispatched, [])    Expression("" + mDispatched + (mRunCalled ? "", run() has already been called"" : """")), [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(mCurIntent, []), Expression(null, [])])    VariableReference(mCurIntent, [])    Expression(null, [])  AssignmentExpression(=, [VariableReference(mDispatched, []), Expression(true, [])])    VariableReference(mDispatched, [])    Expression(true, [])  AssignmentExpression(=, [VariableReference(mRunCalled, []), Expression(true, [])])    VariableReference(mRunCalled, [])    Expression(true, [])  AssignmentExpression(=, [VariableReference(if (receiver, []), Expression(, [])])    VariableReference(if (receiver, [])    Expression(, [])  Statement(if (mRegistered && ordered) {, [])  MethodCall(Slog.i(ActivityThread.TAG, ""Finishing null broadcast to "" + mReceiver), [VariableReference(Slog, []), Expression(ActivityThread.TAG, []), Expression(""Finishing null broadcast to "" + mReceiver, [])])    VariableReference(Slog, [])    Expression(ActivityThread.TAG, [])    Expression(""Finishing null broadcast to "" + mReceiver, [])  Statement(sendFinished(mgr), [])  Statement(}, [])  Statement(return, [])  Statement(}, [])  MethodCall(Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""broadcastReceiveReg""), [VariableReference(Trace, []), Expression(Trace.TRACE_TAG_ACTIVITY_MANAGER, []), Expression(""broadcastReceiveReg"", [])])    VariableReference(Trace, [])    Expression(Trace.TRACE_TAG_ACTIVITY_MANAGER, [])    Expression(""broadcastReceiveReg"", [])  Statement(try {, [])  AssignmentExpression(=, [VariableReference(ClassLoader cl, []), Expression(mReceiver.getClass().getClassLoader(), [])])    VariableReference(ClassLoader cl, [])    Expression(mReceiver.getClass().getClassLoader(), [])  MethodCall(intent.setExtrasClassLoader(cl), [VariableReference(intent, []), Expression(cl, [])])    VariableReference(intent, [])    Expression(cl, [])  Statement(// TODO: determine at registration time if caller is, [])  Statement(// protecting themselves with signature permission, [])  MethodCall(intent.prepareToEnterProcess(ActivityThread.isProtectedBroadcast(intent), mContext.getAttributionSource()), [VariableReference(intent, []), Expression(ActivityThread.isProtectedBroadcast(intent), []), Expression(mContext.getAttributionSource(), [])])    VariableReference(intent, [])    Expression(ActivityThread.isProtectedBroadcast(intent), [])    Expression(mContext.getAttributionSource(), [])  Statement(setExtrasClassLoader(cl), [])  MethodCall(receiver.setPendingResult(this), [VariableReference(receiver, []), Expression(this, [])])    VariableReference(receiver, [])    Expression(this, [])  MethodCall(receiver.onReceive(mContext, intent), [VariableReference(receiver, []), Expression(mContext, []), Expression(intent, [])])    VariableReference(receiver, [])    Expression(mContext, [])    Expression(intent, [])  Statement(} catch (Exception e) {, [])  Statement(if (mRegistered && ordered) {, [])  MethodCall(Slog.i(ActivityThread.TAG, ""Finishing failed broadcast to "" + mReceiver), [VariableReference(Slog, []), Expression(ActivityThread.TAG, []), Expression(""Finishing failed broadcast to "" + mReceiver, [])])    VariableReference(Slog, [])    Expression(ActivityThread.TAG, [])    Expression(""Finishing failed broadcast to "" + mReceiver, [])  Statement(sendFinished(mgr), [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(if (mInstrumentation, []), Expression(, [])])    VariableReference(if (mInstrumentation, [])    Expression(, [])  MethodCall(Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER), [VariableReference(Trace, []), Expression(Trace.TRACE_TAG_ACTIVITY_MANAGER, [])])    VariableReference(Trace, [])    Expression(Trace.TRACE_TAG_ACTIVITY_MANAGER, [])  Statement(throw new RuntimeException(""Error receiving broadcast "" + intent + "" in "" + mReceiver, e), [])  Statement(}, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(if (receiver.getPendingResult() !, []), Expression(null) {, [])])    VariableReference(if (receiver.getPendingResult() !, [])    Expression(null) {, [])  Statement(finish(), [])  Statement(}, [])  MethodCall(Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER), [VariableReference(Trace, []), Expression(Trace.TRACE_TAG_ACTIVITY_MANAGER, [])])    VariableReference(Trace, [])    Expression(Trace.TRACE_TAG_ACTIVITY_MANAGER, [])  Statement(}, [])  Statement(}, [])",1,,,0,,,0,,,,2,5,0,"4,5",0,"The main functional difference is the additional statements in the late version, which includes calls to intent.prepareToEnterProcess(ActivityThread.isProtectedBroadcast(intent), mContext.getAttributionSource()). This falls under category 4, Other statement changed. Additionally, there are API calls to ActivityThread.isProtectedBroadcast(intent) and mContext.getAttributionSource(), indicating changes due to a dependent API, hence also category 5.","There are additional processing steps in the late version, but these do not affect the return value or exception handling of the method. Therefore, no compatibility issue exists, and the CI type is 0."
7,<android.app.admin.DevicePolicyManager: DevicePolicyManager getParentProfileInstance(ComponentName)>,30,31,,,,"MethodDeclaration(method_body, [Statement({, []), Statement(throwIfParentInstance(""getParentProfileInstance""), []), Statement(try {, []), MethodCall(if (!mService.isManagedProfile(admin)), [VariableReference(if (!mService, []), Expression(admin), [])]), Statement(}, []), Statement(return new DevicePolicyManager(mContext, mService, true), []), Statement(} catch (RemoteException e) {, []), MethodCall(throw e.rethrowFromSystemServer(), [VariableReference(throw e, []), Expression(, [])]), Statement(}, []), Statement(}, [])])  Statement({, [])  Statement(throwIfParentInstance(""getParentProfileInstance""), [])  Statement(try {, [])  MethodCall(if (!mService.isManagedProfile(admin)), [VariableReference(if (!mService, []), Expression(admin), [])])    VariableReference(if (!mService, [])    Expression(admin), [])  Statement(}, [])  Statement(return new DevicePolicyManager(mContext, mService, true), [])  Statement(} catch (RemoteException e) {, [])  MethodCall(throw e.rethrowFromSystemServer(), [VariableReference(throw e, []), Expression(, [])])    VariableReference(throw e, [])    Expression(, [])  Statement(}, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(throwIfParentInstance(""getParentProfileInstance""), []), Statement(try {, []), MethodCall(if (!mService.isManagedProfile(admin)), [VariableReference(if (!mService, []), Expression(admin), [])]), Statement(}, []), Statement(return new DevicePolicyManager(mContext, mService, true), []), Statement(} catch (RemoteException e) {, []), MethodCall(throw e.rethrowFromSystemServer(), [VariableReference(throw e, []), Expression(, [])]), Statement(}, []), Statement(}, [])])  Statement({, [])  Statement(throwIfParentInstance(""getParentProfileInstance""), [])  Statement(try {, [])  MethodCall(if (!mService.isManagedProfile(admin)), [VariableReference(if (!mService, []), Expression(admin), [])])    VariableReference(if (!mService, [])    Expression(admin), [])  Statement(}, [])  Statement(return new DevicePolicyManager(mContext, mService, true), [])  Statement(} catch (RemoteException e) {, [])  MethodCall(throw e.rethrowFromSystemServer(), [VariableReference(throw e, []), Expression(, [])])    VariableReference(throw e, [])    Expression(, [])  Statement(}, [])  Statement(}, [])",0,"/**
 * Called by the profile owner of a managed profile to obtain a {@link DevicePolicyManager}
 * whose calls act on the parent profile.
 *
 * <p>The following methods are supported for the parent instance, all other methods will
 * throw a SecurityException when called on the parent instance:
 * <ul>
 * <li>{@link #getPasswordQuality}</li>
 * <li>{@link #setPasswordQuality}</li>
 * <li>{@link #getPasswordMinimumLength}</li>
 * <li>{@link #setPasswordMinimumLength}</li>
 * <li>{@link #getPasswordMinimumUpperCase}</li>
 * <li>{@link #setPasswordMinimumUpperCase}</li>
 * <li>{@link #getPasswordMinimumLowerCase}</li>
 * <li>{@link #setPasswordMinimumLowerCase}</li>
 * <li>{@link #getPasswordMinimumLetters}</li>
 * <li>{@link #setPasswordMinimumLetters}</li>
 * <li>{@link #getPasswordMinimumNumeric}</li>
 * <li>{@link #setPasswordMinimumNumeric}</li>
 * <li>{@link #getPasswordMinimumSymbols}</li>
 * <li>{@link #setPasswordMinimumSymbols}</li>
 * <li>{@link #getPasswordMinimumNonLetter}</li>
 * <li>{@link #setPasswordMinimumNonLetter}</li>
 * <li>{@link #getPasswordHistoryLength}</li>
 * <li>{@link #setPasswordHistoryLength}</li>
 * <li>{@link #getPasswordExpirationTimeout}</li>
 * <li>{@link #setPasswordExpirationTimeout}</li>
 * <li>{@link #getPasswordExpiration}</li>
 * <li>{@link #getPasswordMaximumLength}</li>
 * <li>{@link #isActivePasswordSufficient}</li>
 * <li>{@link #getCurrentFailedPasswordAttempts}</li>
 * <li>{@link #getMaximumFailedPasswordsForWipe}</li>
 * <li>{@link #setMaximumFailedPasswordsForWipe}</li>
 * <li>{@link #getMaximumTimeToLock}</li>
 * <li>{@link #setMaximumTimeToLock}</li>
 * <li>{@link #lockNow}</li>
 * <li>{@link #getKeyguardDisabledFeatures}</li>
 * <li>{@link #setKeyguardDisabledFeatures}</li>
 * <li>{@link #getTrustAgentConfiguration}</li>
 * <li>{@link #setTrustAgentConfiguration}</li>
 * <li>{@link #getRequiredStrongAuthTimeout}</li>
 * <li>{@link #setRequiredStrongAuthTimeout}</li>
 * <li>{@link #getAccountTypesWithManagementDisabled}</li>
 * </ul>
 * <p>
 * The following methods are supported for the parent instance but can only be called by the
 * profile owner of a managed profile that was created during the device provisioning flow:
 * <ul>
 * <li>{@link #getPasswordComplexity}</li>
 * <li>{@link #setCameraDisabled}</li>
 * <li>{@link #getCameraDisabled}</li>
 * <li>{@link #setAccountManagementDisabled(ComponentName, String, boolean)}</li>
 * </ul>
 *
 * <p>The following methods can be called by the profile owner of a managed profile
 * on an organization-owned device:
 * <ul>
 * <li>{@link #wipeData}</li>
 * </ul>
 *
 * @return a new instance of {@link DevicePolicyManager} that acts on the parent profile.
 * @throws SecurityException if {@code admin} is not a profile owner.
 */
","/**
 * Called by the profile owner of a managed profile to obtain a {@link DevicePolicyManager}
 * whose calls act on the parent profile.
 *
 * <p>The following methods are supported for the parent instance, all other methods will
 * throw a SecurityException when called on the parent instance:
 * <ul>
 * <li>{@link #getPasswordQuality}</li>
 * <li>{@link #setPasswordQuality}</li>
 * <li>{@link #getPasswordMinimumLength}</li>
 * <li>{@link #setPasswordMinimumLength}</li>
 * <li>{@link #getPasswordMinimumUpperCase}</li>
 * <li>{@link #setPasswordMinimumUpperCase}</li>
 * <li>{@link #getPasswordMinimumLowerCase}</li>
 * <li>{@link #setPasswordMinimumLowerCase}</li>
 * <li>{@link #getPasswordMinimumLetters}</li>
 * <li>{@link #setPasswordMinimumLetters}</li>
 * <li>{@link #getPasswordMinimumNumeric}</li>
 * <li>{@link #setPasswordMinimumNumeric}</li>
 * <li>{@link #getPasswordMinimumSymbols}</li>
 * <li>{@link #setPasswordMinimumSymbols}</li>
 * <li>{@link #getPasswordMinimumNonLetter}</li>
 * <li>{@link #setPasswordMinimumNonLetter}</li>
 * <li>{@link #getPasswordHistoryLength}</li>
 * <li>{@link #setPasswordHistoryLength}</li>
 * <li>{@link #getPasswordExpirationTimeout}</li>
 * <li>{@link #setPasswordExpirationTimeout}</li>
 * <li>{@link #getPasswordExpiration}</li>
 * <li>{@link #getPasswordMaximumLength}</li>
 * <li>{@link #isActivePasswordSufficient}</li>
 * <li>{@link #getCurrentFailedPasswordAttempts}</li>
 * <li>{@link #getMaximumFailedPasswordsForWipe}</li>
 * <li>{@link #setMaximumFailedPasswordsForWipe}</li>
 * <li>{@link #getMaximumTimeToLock}</li>
 * <li>{@link #setMaximumTimeToLock}</li>
 * <li>{@link #lockNow}</li>
 * <li>{@link #getKeyguardDisabledFeatures}</li>
 * <li>{@link #setKeyguardDisabledFeatures}</li>
 * <li>{@link #getTrustAgentConfiguration}</li>
 * <li>{@link #setTrustAgentConfiguration}</li>
 * <li>{@link #getRequiredStrongAuthTimeout}</li>
 * <li>{@link #setRequiredStrongAuthTimeout}</li>
 * <li>{@link #getAccountTypesWithManagementDisabled}</li>
 * <li>{@link #setRequiredPasswordComplexity(int)} </li>
 * <li>{@link #getRequiredPasswordComplexity()}</li>
 * </ul>
 * <p>
 * The following methods are supported for the parent instance but can only be called by the
 * profile owner of a managed profile that was created during the device provisioning flow:
 * <ul>
 * <li>{@link #getPasswordComplexity}</li>
 * <li>{@link #setCameraDisabled}</li>
 * <li>{@link #getCameraDisabled}</li>
 * <li>{@link #setAccountManagementDisabled(ComponentName, String, boolean)}</li>
 * <li>{@link #setPermittedInputMethods}</li>
 * <li>{@link #getPermittedInputMethods}</li>
 * </ul>
 *
 * <p>The following methods can be called by the profile owner of a managed profile
 * on an organization-owned device:
 * <ul>
 * <li>{@link #wipeData}</li>
 * </ul>
 *
 * @return a new instance of {@link DevicePolicyManager} that acts on the parent profile.
 * @throws SecurityException if {@code admin} is not a profile owner.
 */
",1,[@NonNull],[@NonNull],0,,,,0,0,0,0,0,"There is no change in the method body, comments, or annotations between the early and late versions, hence the change type is 0.","Since there are no changes between the early and late versions, no compatibility issues exist, hence the CI type is 0."
8,"<android.app.backup.BackupAgent.BackupServiceBinder: void doFullBackup(ParcelFileDescriptor,long,int,IBackupManager,int)>",30,31,,,,"MethodDeclaration(method_body, [Statement({, []), Statement(// Ensure that we're running with the app's normal permission level, []), AssignmentExpression(=, [VariableReference(long ident, []), Expression(Binder.clearCallingIdentity(), [])]), Statement(if (DEBUG), []), MethodCall(Log.v(TAG, ""doFullBackup() invoked""), [VariableReference(Log, []), Expression(TAG, []), Expression(""doFullBackup() invoked"", [])]), Statement(// Ensure that any SharedPreferences writes have landed *before*, []), Statement(// we potentially try to back up the underlying files directly., []), Statement(waitForSharedPrefs(), []), Statement(try {, []), Statement(} catch (IOException ex) {, []), MethodCall(Log.d(TAG, ""onFullBackup ("" + BackupAgent.this.getClass().getName() + "") threw"", ex), [VariableReference(Log, []), Expression(TAG, []), Expression(""onFullBackup ("" + BackupAgent.this.getClass().getName() + "") threw"", []), Expression(ex, [])]), Statement(throw new RuntimeException(ex), []), Statement(} catch (RuntimeException ex) {, []), MethodCall(Log.d(TAG, ""onFullBackup ("" + BackupAgent.this.getClass().getName() + "") threw"", ex), [VariableReference(Log, []), Expression(TAG, []), Expression(""onFullBackup ("" + BackupAgent.this.getClass().getName() + "") threw"", []), Expression(ex, [])]), Statement(throw ex, []), Statement(} finally {, []), Statement(waitForSharedPrefs(), []), Statement(// forthcoming from this agent., []), Statement(try {, []), AssignmentExpression(=, [VariableReference(FileOutputStream out, []), Expression(new FileOutputStream(data.getFileDescriptor()), [])]), AssignmentExpression(=, [VariableReference(byte[] buf, []), Expression(new byte[4], [])]), MethodCall(out.write(buf), [VariableReference(out, []), Expression(buf, [])]), Statement(} catch (IOException e) {, []), MethodCall(Log.e(TAG, ""Unable to finalize backup stream!""), [VariableReference(Log, []), Expression(TAG, []), Expression(""Unable to finalize backup stream!"", [])]), Statement(}, []), MethodCall(Binder.restoreCallingIdentity(ident), [VariableReference(Binder, []), Expression(ident, [])]), Statement(try {, []), MethodCall(callbackBinder.opCompleteForUser(getBackupUserId(), token, 0), [VariableReference(callbackBinder, []), Expression(getBackupUserId(), []), Expression(token, []), Expression(0, [])]), Statement(} catch (RemoteException e) {, []), Statement(// we'll time out anyway, so we're safe, []), Statement(}, []), AssignmentExpression(=, [VariableReference(if (Binder.getCallingPid() !, []), Expression(Process.myPid()) {, [])]), MethodCall(IoUtils.closeQuietly(data), [VariableReference(IoUtils, []), Expression(data, [])]), Statement(}, []), Statement(}, []), Statement(}, [])])  Statement({, [])  Statement(// Ensure that we're running with the app's normal permission level, [])  AssignmentExpression(=, [VariableReference(long ident, []), Expression(Binder.clearCallingIdentity(), [])])    VariableReference(long ident, [])    Expression(Binder.clearCallingIdentity(), [])  Statement(if (DEBUG), [])  MethodCall(Log.v(TAG, ""doFullBackup() invoked""), [VariableReference(Log, []), Expression(TAG, []), Expression(""doFullBackup() invoked"", [])])    VariableReference(Log, [])    Expression(TAG, [])    Expression(""doFullBackup() invoked"", [])  Statement(// Ensure that any SharedPreferences writes have landed *before*, [])  Statement(// we potentially try to back up the underlying files directly., [])  Statement(waitForSharedPrefs(), [])  Statement(try {, [])  Statement(} catch (IOException ex) {, [])  MethodCall(Log.d(TAG, ""onFullBackup ("" + BackupAgent.this.getClass().getName() + "") threw"", ex), [VariableReference(Log, []), Expression(TAG, []), Expression(""onFullBackup ("" + BackupAgent.this.getClass().getName() + "") threw"", []), Expression(ex, [])])    VariableReference(Log, [])    Expression(TAG, [])    Expression(""onFullBackup ("" + BackupAgent.this.getClass().getName() + "") threw"", [])    Expression(ex, [])  Statement(throw new RuntimeException(ex), [])  Statement(} catch (RuntimeException ex) {, [])  MethodCall(Log.d(TAG, ""onFullBackup ("" + BackupAgent.this.getClass().getName() + "") threw"", ex), [VariableReference(Log, []), Expression(TAG, []), Expression(""onFullBackup ("" + BackupAgent.this.getClass().getName() + "") threw"", []), Expression(ex, [])])    VariableReference(Log, [])    Expression(TAG, [])    Expression(""onFullBackup ("" + BackupAgent.this.getClass().getName() + "") threw"", [])    Expression(ex, [])  Statement(throw ex, [])  Statement(} finally {, [])  Statement(waitForSharedPrefs(), [])  Statement(// forthcoming from this agent., [])  Statement(try {, [])  AssignmentExpression(=, [VariableReference(FileOutputStream out, []), Expression(new FileOutputStream(data.getFileDescriptor()), [])])    VariableReference(FileOutputStream out, [])    Expression(new FileOutputStream(data.getFileDescriptor()), [])  AssignmentExpression(=, [VariableReference(byte[] buf, []), Expression(new byte[4], [])])    VariableReference(byte[] buf, [])    Expression(new byte[4], [])  MethodCall(out.write(buf), [VariableReference(out, []), Expression(buf, [])])    VariableReference(out, [])    Expression(buf, [])  Statement(} catch (IOException e) {, [])  MethodCall(Log.e(TAG, ""Unable to finalize backup stream!""), [VariableReference(Log, []), Expression(TAG, []), Expression(""Unable to finalize backup stream!"", [])])    VariableReference(Log, [])    Expression(TAG, [])    Expression(""Unable to finalize backup stream!"", [])  Statement(}, [])  MethodCall(Binder.restoreCallingIdentity(ident), [VariableReference(Binder, []), Expression(ident, [])])    VariableReference(Binder, [])    Expression(ident, [])  Statement(try {, [])  MethodCall(callbackBinder.opCompleteForUser(getBackupUserId(), token, 0), [VariableReference(callbackBinder, []), Expression(getBackupUserId(), []), Expression(token, []), Expression(0, [])])    VariableReference(callbackBinder, [])    Expression(getBackupUserId(), [])    Expression(token, [])    Expression(0, [])  Statement(} catch (RemoteException e) {, [])  Statement(// we'll time out anyway, so we're safe, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(if (Binder.getCallingPid() !, []), Expression(Process.myPid()) {, [])])    VariableReference(if (Binder.getCallingPid() !, [])    Expression(Process.myPid()) {, [])  MethodCall(IoUtils.closeQuietly(data), [VariableReference(IoUtils, []), Expression(data, [])])    VariableReference(IoUtils, [])    Expression(data, [])  Statement(}, [])  Statement(}, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(if (DEBUG), []), MethodCall(Log.v(TAG, ""doFullBackup() invoked""), [VariableReference(Log, []), Expression(TAG, []), Expression(""doFullBackup() invoked"", [])]), Statement(// Ensure that any SharedPreferences writes have landed *before*, []), Statement(// we potentially try to back up the underlying files directly., []), Statement(waitForSharedPrefs(), []), Statement(// Ensure that we're running with the app's normal permission level, []), AssignmentExpression(=, [VariableReference(final long ident, []), Expression(Binder.clearCallingIdentity(), [])]), Statement(try {, []), Statement(} catch (IOException ex) {, []), MethodCall(Log.d(TAG, ""onFullBackup ("" + BackupAgent.this.getClass().getName() + "") threw"", ex), [VariableReference(Log, []), Expression(TAG, []), Expression(""onFullBackup ("" + BackupAgent.this.getClass().getName() + "") threw"", []), Expression(ex, [])]), Statement(throw new RuntimeException(ex), []), Statement(} catch (RuntimeException ex) {, []), MethodCall(Log.d(TAG, ""onFullBackup ("" + BackupAgent.this.getClass().getName() + "") threw"", ex), [VariableReference(Log, []), Expression(TAG, []), Expression(""onFullBackup ("" + BackupAgent.this.getClass().getName() + "") threw"", []), Expression(ex, [])]), Statement(throw ex, []), Statement(} finally {, []), Statement(waitForSharedPrefs(), []), Statement(// forthcoming from this agent., []), Statement(try {, []), AssignmentExpression(=, [VariableReference(FileOutputStream out, []), Expression(new FileOutputStream(data.getFileDescriptor()), [])]), AssignmentExpression(=, [VariableReference(byte[] buf, []), Expression(new byte[4], [])]), MethodCall(out.write(buf), [VariableReference(out, []), Expression(buf, [])]), Statement(} catch (IOException e) {, []), MethodCall(Log.e(TAG, ""Unable to finalize backup stream!""), [VariableReference(Log, []), Expression(TAG, []), Expression(""Unable to finalize backup stream!"", [])]), Statement(}, []), MethodCall(Binder.restoreCallingIdentity(ident), [VariableReference(Binder, []), Expression(ident, [])]), Statement(try {, []), MethodCall(callbackBinder.opCompleteForUser(getBackupUserId(), token, 0), [VariableReference(callbackBinder, []), Expression(getBackupUserId(), []), Expression(token, []), Expression(0, [])]), Statement(} catch (RemoteException e) {, []), Statement(// we'll time out anyway, so we're safe, []), Statement(}, []), AssignmentExpression(=, [VariableReference(if (Binder.getCallingPid() !, []), Expression(Process.myPid()) {, [])]), MethodCall(IoUtils.closeQuietly(data), [VariableReference(IoUtils, []), Expression(data, [])]), Statement(}, []), Statement(}, []), Statement(}, [])])  Statement({, [])  Statement(if (DEBUG), [])  MethodCall(Log.v(TAG, ""doFullBackup() invoked""), [VariableReference(Log, []), Expression(TAG, []), Expression(""doFullBackup() invoked"", [])])    VariableReference(Log, [])    Expression(TAG, [])    Expression(""doFullBackup() invoked"", [])  Statement(// Ensure that any SharedPreferences writes have landed *before*, [])  Statement(// we potentially try to back up the underlying files directly., [])  Statement(waitForSharedPrefs(), [])  Statement(// Ensure that we're running with the app's normal permission level, [])  AssignmentExpression(=, [VariableReference(final long ident, []), Expression(Binder.clearCallingIdentity(), [])])    VariableReference(final long ident, [])    Expression(Binder.clearCallingIdentity(), [])  Statement(try {, [])  Statement(} catch (IOException ex) {, [])  MethodCall(Log.d(TAG, ""onFullBackup ("" + BackupAgent.this.getClass().getName() + "") threw"", ex), [VariableReference(Log, []), Expression(TAG, []), Expression(""onFullBackup ("" + BackupAgent.this.getClass().getName() + "") threw"", []), Expression(ex, [])])    VariableReference(Log, [])    Expression(TAG, [])    Expression(""onFullBackup ("" + BackupAgent.this.getClass().getName() + "") threw"", [])    Expression(ex, [])  Statement(throw new RuntimeException(ex), [])  Statement(} catch (RuntimeException ex) {, [])  MethodCall(Log.d(TAG, ""onFullBackup ("" + BackupAgent.this.getClass().getName() + "") threw"", ex), [VariableReference(Log, []), Expression(TAG, []), Expression(""onFullBackup ("" + BackupAgent.this.getClass().getName() + "") threw"", []), Expression(ex, [])])    VariableReference(Log, [])    Expression(TAG, [])    Expression(""onFullBackup ("" + BackupAgent.this.getClass().getName() + "") threw"", [])    Expression(ex, [])  Statement(throw ex, [])  Statement(} finally {, [])  Statement(waitForSharedPrefs(), [])  Statement(// forthcoming from this agent., [])  Statement(try {, [])  AssignmentExpression(=, [VariableReference(FileOutputStream out, []), Expression(new FileOutputStream(data.getFileDescriptor()), [])])    VariableReference(FileOutputStream out, [])    Expression(new FileOutputStream(data.getFileDescriptor()), [])  AssignmentExpression(=, [VariableReference(byte[] buf, []), Expression(new byte[4], [])])    VariableReference(byte[] buf, [])    Expression(new byte[4], [])  MethodCall(out.write(buf), [VariableReference(out, []), Expression(buf, [])])    VariableReference(out, [])    Expression(buf, [])  Statement(} catch (IOException e) {, [])  MethodCall(Log.e(TAG, ""Unable to finalize backup stream!""), [VariableReference(Log, []), Expression(TAG, []), Expression(""Unable to finalize backup stream!"", [])])    VariableReference(Log, [])    Expression(TAG, [])    Expression(""Unable to finalize backup stream!"", [])  Statement(}, [])  MethodCall(Binder.restoreCallingIdentity(ident), [VariableReference(Binder, []), Expression(ident, [])])    VariableReference(Binder, [])    Expression(ident, [])  Statement(try {, [])  MethodCall(callbackBinder.opCompleteForUser(getBackupUserId(), token, 0), [VariableReference(callbackBinder, []), Expression(getBackupUserId(), []), Expression(token, []), Expression(0, [])])    VariableReference(callbackBinder, [])    Expression(getBackupUserId(), [])    Expression(token, [])    Expression(0, [])  Statement(} catch (RemoteException e) {, [])  Statement(// we'll time out anyway, so we're safe, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(if (Binder.getCallingPid() !, []), Expression(Process.myPid()) {, [])])    VariableReference(if (Binder.getCallingPid() !, [])    Expression(Process.myPid()) {, [])  MethodCall(IoUtils.closeQuietly(data), [VariableReference(IoUtils, []), Expression(data, [])])    VariableReference(IoUtils, [])    Expression(data, [])  Statement(}, [])  Statement(}, [])  Statement(}, [])",1,,,0,[@Override],[@Override],0,,,,1,"3,4",0,4,0,"In the sequence of statements within the method, the order of the initialization of `long ident` has changed but `waitForSharedPrefs()` remains. This does not affect the return value or exceptions thrown by the method, so the change type is 4.","The change in the sequence of statements does not lead to different return values or exceptions; hence, no Compatibility Issue exists."
9,"<android.text.method.NumberKeyListener: boolean addAmPmChars(Collection<Character>,Locale)>",30,31,,,,"MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(if (locale, []), Expression(, [])]), Statement(return false, []), Statement(}, []), AssignmentExpression(=, [VariableReference(final String[] amPm, []), Expression(LocaleData.get(locale).amPm, [])]), AssignmentExpression(=, [VariableReference(for (int i, []), Expression(0, [])]), Statement(i < amPm.length, []), Statement(i++) {, []), AssignmentExpression(=, [VariableReference(for (int j, []), Expression(0, [])]), MethodCall(j < amPm[i].length(), [VariableReference(j < amPm[i], []), Expression(, [])]), Statement(j++) {, []), AssignmentExpression(=, [VariableReference(final char ch, []), Expression(amPm[i].charAt(j), [])]), MethodCall(if (Character.isBmpCodePoint(ch)), [VariableReference(if (Character, []), Expression(ch), [])]), MethodCall(collection.add(Character.valueOf(ch)), [VariableReference(collection, []), Expression(Character.valueOf(ch), [])]), Statement(} else {, []), Statement(// We don't support non-BMP characters., []), Statement(return false, []), Statement(}, []), Statement(}, []), Statement(}, []), Statement(return true, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(if (locale, []), Expression(, [])])    VariableReference(if (locale, [])    Expression(, [])  Statement(return false, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(final String[] amPm, []), Expression(LocaleData.get(locale).amPm, [])])    VariableReference(final String[] amPm, [])    Expression(LocaleData.get(locale).amPm, [])  AssignmentExpression(=, [VariableReference(for (int i, []), Expression(0, [])])    VariableReference(for (int i, [])    Expression(0, [])  Statement(i < amPm.length, [])  Statement(i++) {, [])  AssignmentExpression(=, [VariableReference(for (int j, []), Expression(0, [])])    VariableReference(for (int j, [])    Expression(0, [])  MethodCall(j < amPm[i].length(), [VariableReference(j < amPm[i], []), Expression(, [])])    VariableReference(j < amPm[i], [])    Expression(, [])  Statement(j++) {, [])  AssignmentExpression(=, [VariableReference(final char ch, []), Expression(amPm[i].charAt(j), [])])    VariableReference(final char ch, [])    Expression(amPm[i].charAt(j), [])  MethodCall(if (Character.isBmpCodePoint(ch)), [VariableReference(if (Character, []), Expression(ch), [])])    VariableReference(if (Character, [])    Expression(ch), [])  MethodCall(collection.add(Character.valueOf(ch)), [VariableReference(collection, []), Expression(Character.valueOf(ch), [])])    VariableReference(collection, [])    Expression(Character.valueOf(ch), [])  Statement(} else {, [])  Statement(// We don't support non-BMP characters., [])  Statement(return false, [])  Statement(}, [])  Statement(}, [])  Statement(}, [])  Statement(return true, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(if (locale, []), Expression(, [])]), Statement(return false, []), Statement(}, []), AssignmentExpression(=, [VariableReference(final String[] amPm, []), Expression(DateFormat.getIcuDateFormatSymbols(locale).getAmPmStrings(), [])]), AssignmentExpression(=, [VariableReference(for (int i, []), Expression(0, [])]), Statement(i < amPm.length, []), Statement(i++) {, []), AssignmentExpression(=, [VariableReference(for (int j, []), Expression(0, [])]), MethodCall(j < amPm[i].length(), [VariableReference(j < amPm[i], []), Expression(, [])]), Statement(j++) {, []), AssignmentExpression(=, [VariableReference(final char ch, []), Expression(amPm[i].charAt(j), [])]), MethodCall(if (Character.isBmpCodePoint(ch)), [VariableReference(if (Character, []), Expression(ch), [])]), MethodCall(collection.add(Character.valueOf(ch)), [VariableReference(collection, []), Expression(Character.valueOf(ch), [])]), Statement(} else {, []), Statement(// We don't support non-BMP characters., []), Statement(return false, []), Statement(}, []), Statement(}, []), Statement(}, []), Statement(return true, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(if (locale, []), Expression(, [])])    VariableReference(if (locale, [])    Expression(, [])  Statement(return false, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(final String[] amPm, []), Expression(DateFormat.getIcuDateFormatSymbols(locale).getAmPmStrings(), [])])    VariableReference(final String[] amPm, [])    Expression(DateFormat.getIcuDateFormatSymbols(locale).getAmPmStrings(), [])  AssignmentExpression(=, [VariableReference(for (int i, []), Expression(0, [])])    VariableReference(for (int i, [])    Expression(0, [])  Statement(i < amPm.length, [])  Statement(i++) {, [])  AssignmentExpression(=, [VariableReference(for (int j, []), Expression(0, [])])    VariableReference(for (int j, [])    Expression(0, [])  MethodCall(j < amPm[i].length(), [VariableReference(j < amPm[i], []), Expression(, [])])    VariableReference(j < amPm[i], [])    Expression(, [])  Statement(j++) {, [])  AssignmentExpression(=, [VariableReference(final char ch, []), Expression(amPm[i].charAt(j), [])])    VariableReference(final char ch, [])    Expression(amPm[i].charAt(j), [])  MethodCall(if (Character.isBmpCodePoint(ch)), [VariableReference(if (Character, []), Expression(ch), [])])    VariableReference(if (Character, [])    Expression(ch), [])  MethodCall(collection.add(Character.valueOf(ch)), [VariableReference(collection, []), Expression(Character.valueOf(ch), [])])    VariableReference(collection, [])    Expression(Character.valueOf(ch), [])  Statement(} else {, [])  Statement(// We don't support non-BMP characters., [])  Statement(return false, [])  Statement(}, [])  Statement(}, [])  Statement(}, [])  Statement(return true, [])  Statement(}, [])",1,"/* package */
","/* package */
",0,,,0,,,,2,"4,5",0,5,1,"The change involves modifying the API call used to obtain the `amPm` values from `LocaleData.get(locale).amPm` to `DateFormat.getIcuDateFormatSymbols(locale).getAmPmStrings()`, so the change type is 5.","Since the new dependent API might return different AM/PM strings, this could lead to different elements being added to the `collection` and thus different return values. Therefore, the CI type is 1."
10,<android.app.UiAutomation: void clearWindowAnimationFrameStats()>,30,31,,,,"MethodDeclaration(method_body, [Statement({, []), Statement(synchronized (mLock) {, []), Statement(throwIfNotConnectedLocked(), []), Statement(}, []), Statement(try {, []), Statement(if (DEBUG) {, []), MethodCall(Log.i(LOG_TAG, ""Clearing window animation frame stats""), [VariableReference(Log, []), Expression(LOG_TAG, []), Expression(""Clearing window animation frame stats"", [])]), Statement(}, []), Statement(// Calling out without a lock held., []), MethodCall(mUiAutomationConnection.clearWindowAnimationFrameStats(), [VariableReference(mUiAutomationConnection, []), Expression(, [])]), Statement(} catch (RemoteException re) {, []), MethodCall(Log.e(LOG_TAG, ""Error clearing window animation frame stats!"", re), [VariableReference(Log, []), Expression(LOG_TAG, []), Expression(""Error clearing window animation frame stats!"", []), Expression(re, [])]), Statement(}, []), Statement(}, [])])  Statement({, [])  Statement(synchronized (mLock) {, [])  Statement(throwIfNotConnectedLocked(), [])  Statement(}, [])  Statement(try {, [])  Statement(if (DEBUG) {, [])  MethodCall(Log.i(LOG_TAG, ""Clearing window animation frame stats""), [VariableReference(Log, []), Expression(LOG_TAG, []), Expression(""Clearing window animation frame stats"", [])])    VariableReference(Log, [])    Expression(LOG_TAG, [])    Expression(""Clearing window animation frame stats"", [])  Statement(}, [])  Statement(// Calling out without a lock held., [])  MethodCall(mUiAutomationConnection.clearWindowAnimationFrameStats(), [VariableReference(mUiAutomationConnection, []), Expression(, [])])    VariableReference(mUiAutomationConnection, [])    Expression(, [])  Statement(} catch (RemoteException re) {, [])  MethodCall(Log.e(LOG_TAG, ""Error clearing window animation frame stats!"", re), [VariableReference(Log, []), Expression(LOG_TAG, []), Expression(""Error clearing window animation frame stats!"", []), Expression(re, [])])    VariableReference(Log, [])    Expression(LOG_TAG, [])    Expression(""Error clearing window animation frame stats!"", [])    Expression(re, [])  Statement(}, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(try {, []), Statement(if (DEBUG) {, []), MethodCall(Log.i(LOG_TAG, ""Clearing window animation frame stats""), [VariableReference(Log, []), Expression(LOG_TAG, []), Expression(""Clearing window animation frame stats"", [])]), Statement(}, []), Statement(// Calling out without a lock held., []), MethodCall(mUiAutomationConnection.clearWindowAnimationFrameStats(), [VariableReference(mUiAutomationConnection, []), Expression(, [])]), Statement(} catch (RemoteException re) {, []), MethodCall(Log.e(LOG_TAG, ""Error clearing window animation frame stats!"", re), [VariableReference(Log, []), Expression(LOG_TAG, []), Expression(""Error clearing window animation frame stats!"", []), Expression(re, [])]), Statement(}, []), Statement(}, [])])  Statement({, [])  Statement(try {, [])  Statement(if (DEBUG) {, [])  MethodCall(Log.i(LOG_TAG, ""Clearing window animation frame stats""), [VariableReference(Log, []), Expression(LOG_TAG, []), Expression(""Clearing window animation frame stats"", [])])    VariableReference(Log, [])    Expression(LOG_TAG, [])    Expression(""Clearing window animation frame stats"", [])  Statement(}, [])  Statement(// Calling out without a lock held., [])  MethodCall(mUiAutomationConnection.clearWindowAnimationFrameStats(), [VariableReference(mUiAutomationConnection, []), Expression(, [])])    VariableReference(mUiAutomationConnection, [])    Expression(, [])  Statement(} catch (RemoteException re) {, [])  MethodCall(Log.e(LOG_TAG, ""Error clearing window animation frame stats!"", re), [VariableReference(Log, []), Expression(LOG_TAG, []), Expression(""Error clearing window animation frame stats!"", []), Expression(re, [])])    VariableReference(Log, [])    Expression(LOG_TAG, [])    Expression(""Error clearing window animation frame stats!"", [])    Expression(re, [])  Statement(}, [])  Statement(}, [])",1,"/**
 * Clears the window animation rendering statistics. These statistics contain
 * information about the most recently rendered window animation frames, i.e.
 * for window transition animations.
 *
 * @see android.view.WindowAnimationFrameStats
 * @see #getWindowAnimationFrameStats()
 * @see android.R.styleable#WindowAnimation
 */
","/**
 * Clears the window animation rendering statistics. These statistics contain
 * information about the most recently rendered window animation frames, i.e.
 * for window transition animations.
 *
 * @see android.view.WindowAnimationFrameStats
 * @see #getWindowAnimationFrameStats()
 * @see android.R.styleable#WindowAnimation
 */
",0,,,0,,,,"1,2",4,2,3,1,"The synchronized block for mLock and the related method call to `throwIfNotConnectedLocked` have been removed in the late implementation. This represents a change in control dependency, so the change type is 3.","The removal of the synchronized block and checks associated with `throwIfNotConnectedLocked` can lead to different behavior regarding when the method executes and its connection status. This could potentially cause the method to behave differently, resulting in different outcomes when the API is invoked. Therefore, the CI type is 1."
11,"<android.view.ViewGroup: boolean requestFocus(int,Rect)>",30,31,,,,"MethodDeclaration(method_body, [Statement({, []), Statement(if (DBG) {, []), AssignmentExpression(=, [VariableReference(System.out.println(this + "" ViewGroup.requestFocus direction, []), Expression("" + direction), [])]), Statement(}, []), AssignmentExpression(=, [VariableReference(int descendantFocusability, []), Expression(getDescendantFocusability(), [])]), Statement(boolean result, []), Statement(switch(descendantFocusability) {, []), Statement(case FOCUS_BLOCK_DESCENDANTS:, []), AssignmentExpression(=, [VariableReference(result, []), Expression(super.requestFocus(direction, previouslyFocusedRect), [])]), Statement(break, []), Statement(case FOCUS_BEFORE_DESCENDANTS:, []), Statement({, []), AssignmentExpression(=, [VariableReference(final boolean took, []), Expression(super.requestFocus(direction, previouslyFocusedRect), [])]), AssignmentExpression(=, [VariableReference(result, []), Expression(took ? took : onRequestFocusInDescendants(direction, previouslyFocusedRect), [])]), Statement(break, []), Statement(}, []), Statement(case FOCUS_AFTER_DESCENDANTS:, []), Statement({, []), AssignmentExpression(=, [VariableReference(final boolean took, []), Expression(onRequestFocusInDescendants(direction, previouslyFocusedRect), [])]), AssignmentExpression(=, [VariableReference(result, []), Expression(took ? took : super.requestFocus(direction, previouslyFocusedRect), [])]), Statement(break, []), Statement(}, []), Statement(default:, []), Statement(throw new IllegalStateException(""descendant focusability must be one of FOCUS_BEFORE_DESCENDANTS,"" + "" FOCUS_AFTER_DESCENDANTS, FOCUS_BLOCK_DESCENDANTS but is "" + descendantFocusability), []), Statement(}, []), AssignmentExpression(=, [VariableReference(if (result && !isLayoutValid() && ((mPrivateFlags & PFLAG_WANTS_FOCUS), []), Expression(, [])]), AssignmentExpression(=, [VariableReference(mPrivateFlags |, []), Expression(PFLAG_WANTS_FOCUS, [])]), Statement(}, []), Statement(return result, []), Statement(}, [])])  Statement({, [])  Statement(if (DBG) {, [])  AssignmentExpression(=, [VariableReference(System.out.println(this + "" ViewGroup.requestFocus direction, []), Expression("" + direction), [])])    VariableReference(System.out.println(this + "" ViewGroup.requestFocus direction, [])    Expression("" + direction), [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(int descendantFocusability, []), Expression(getDescendantFocusability(), [])])    VariableReference(int descendantFocusability, [])    Expression(getDescendantFocusability(), [])  Statement(boolean result, [])  Statement(switch(descendantFocusability) {, [])  Statement(case FOCUS_BLOCK_DESCENDANTS:, [])  AssignmentExpression(=, [VariableReference(result, []), Expression(super.requestFocus(direction, previouslyFocusedRect), [])])    VariableReference(result, [])    Expression(super.requestFocus(direction, previouslyFocusedRect), [])  Statement(break, [])  Statement(case FOCUS_BEFORE_DESCENDANTS:, [])  Statement({, [])  AssignmentExpression(=, [VariableReference(final boolean took, []), Expression(super.requestFocus(direction, previouslyFocusedRect), [])])    VariableReference(final boolean took, [])    Expression(super.requestFocus(direction, previouslyFocusedRect), [])  AssignmentExpression(=, [VariableReference(result, []), Expression(took ? took : onRequestFocusInDescendants(direction, previouslyFocusedRect), [])])    VariableReference(result, [])    Expression(took ? took : onRequestFocusInDescendants(direction, previouslyFocusedRect), [])  Statement(break, [])  Statement(}, [])  Statement(case FOCUS_AFTER_DESCENDANTS:, [])  Statement({, [])  AssignmentExpression(=, [VariableReference(final boolean took, []), Expression(onRequestFocusInDescendants(direction, previouslyFocusedRect), [])])    VariableReference(final boolean took, [])    Expression(onRequestFocusInDescendants(direction, previouslyFocusedRect), [])  AssignmentExpression(=, [VariableReference(result, []), Expression(took ? took : super.requestFocus(direction, previouslyFocusedRect), [])])    VariableReference(result, [])    Expression(took ? took : super.requestFocus(direction, previouslyFocusedRect), [])  Statement(break, [])  Statement(}, [])  Statement(default:, [])  Statement(throw new IllegalStateException(""descendant focusability must be one of FOCUS_BEFORE_DESCENDANTS,"" + "" FOCUS_AFTER_DESCENDANTS, FOCUS_BLOCK_DESCENDANTS but is "" + descendantFocusability), [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(if (result && !isLayoutValid() && ((mPrivateFlags & PFLAG_WANTS_FOCUS), []), Expression(, [])])    VariableReference(if (result && !isLayoutValid() && ((mPrivateFlags & PFLAG_WANTS_FOCUS), [])    Expression(, [])  AssignmentExpression(=, [VariableReference(mPrivateFlags |, []), Expression(PFLAG_WANTS_FOCUS, [])])    VariableReference(mPrivateFlags |, [])    Expression(PFLAG_WANTS_FOCUS, [])  Statement(}, [])  Statement(return result, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(if (DBG) {, []), AssignmentExpression(=, [VariableReference(System.out.println(this + "" ViewGroup.requestFocus direction, []), Expression("" + direction), [])]), Statement(}, []), AssignmentExpression(=, [VariableReference(int descendantFocusability, []), Expression(getDescendantFocusability(), [])]), Statement(boolean result, []), Statement(switch(descendantFocusability) {, []), Statement(case FOCUS_BLOCK_DESCENDANTS:, []), AssignmentExpression(=, [VariableReference(result, []), Expression(super.requestFocus(direction, previouslyFocusedRect), [])]), Statement(break, []), Statement(case FOCUS_BEFORE_DESCENDANTS:, []), Statement({, []), AssignmentExpression(=, [VariableReference(final boolean took, []), Expression(super.requestFocus(direction, previouslyFocusedRect), [])]), AssignmentExpression(=, [VariableReference(result, []), Expression(took ? took : onRequestFocusInDescendants(direction, previouslyFocusedRect), [])]), Statement(break, []), Statement(}, []), Statement(case FOCUS_AFTER_DESCENDANTS:, []), Statement({, []), AssignmentExpression(=, [VariableReference(final boolean took, []), Expression(onRequestFocusInDescendants(direction, previouslyFocusedRect), [])]), AssignmentExpression(=, [VariableReference(result, []), Expression(took ? took : super.requestFocus(direction, previouslyFocusedRect), [])]), Statement(break, []), Statement(}, []), Statement(default:, []), Statement(throw new IllegalStateException(""descendant focusability must be "" + ""one of FOCUS_BEFORE_DESCENDANTS, FOCUS_AFTER_DESCENDANTS, FOCUS_BLOCK_DESCENDANTS "" + ""but is "" + descendantFocusability), []), Statement(}, []), AssignmentExpression(=, [VariableReference(if (result && !isLayoutValid() && ((mPrivateFlags & PFLAG_WANTS_FOCUS), []), Expression(, [])]), AssignmentExpression(=, [VariableReference(mPrivateFlags |, []), Expression(PFLAG_WANTS_FOCUS, [])]), Statement(}, []), Statement(return result, []), Statement(}, [])])  Statement({, [])  Statement(if (DBG) {, [])  AssignmentExpression(=, [VariableReference(System.out.println(this + "" ViewGroup.requestFocus direction, []), Expression("" + direction), [])])    VariableReference(System.out.println(this + "" ViewGroup.requestFocus direction, [])    Expression("" + direction), [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(int descendantFocusability, []), Expression(getDescendantFocusability(), [])])    VariableReference(int descendantFocusability, [])    Expression(getDescendantFocusability(), [])  Statement(boolean result, [])  Statement(switch(descendantFocusability) {, [])  Statement(case FOCUS_BLOCK_DESCENDANTS:, [])  AssignmentExpression(=, [VariableReference(result, []), Expression(super.requestFocus(direction, previouslyFocusedRect), [])])    VariableReference(result, [])    Expression(super.requestFocus(direction, previouslyFocusedRect), [])  Statement(break, [])  Statement(case FOCUS_BEFORE_DESCENDANTS:, [])  Statement({, [])  AssignmentExpression(=, [VariableReference(final boolean took, []), Expression(super.requestFocus(direction, previouslyFocusedRect), [])])    VariableReference(final boolean took, [])    Expression(super.requestFocus(direction, previouslyFocusedRect), [])  AssignmentExpression(=, [VariableReference(result, []), Expression(took ? took : onRequestFocusInDescendants(direction, previouslyFocusedRect), [])])    VariableReference(result, [])    Expression(took ? took : onRequestFocusInDescendants(direction, previouslyFocusedRect), [])  Statement(break, [])  Statement(}, [])  Statement(case FOCUS_AFTER_DESCENDANTS:, [])  Statement({, [])  AssignmentExpression(=, [VariableReference(final boolean took, []), Expression(onRequestFocusInDescendants(direction, previouslyFocusedRect), [])])    VariableReference(final boolean took, [])    Expression(onRequestFocusInDescendants(direction, previouslyFocusedRect), [])  AssignmentExpression(=, [VariableReference(result, []), Expression(took ? took : super.requestFocus(direction, previouslyFocusedRect), [])])    VariableReference(result, [])    Expression(took ? took : super.requestFocus(direction, previouslyFocusedRect), [])  Statement(break, [])  Statement(}, [])  Statement(default:, [])  Statement(throw new IllegalStateException(""descendant focusability must be "" + ""one of FOCUS_BEFORE_DESCENDANTS, FOCUS_AFTER_DESCENDANTS, FOCUS_BLOCK_DESCENDANTS "" + ""but is "" + descendantFocusability), [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(if (result && !isLayoutValid() && ((mPrivateFlags & PFLAG_WANTS_FOCUS), []), Expression(, [])])    VariableReference(if (result && !isLayoutValid() && ((mPrivateFlags & PFLAG_WANTS_FOCUS), [])    Expression(, [])  AssignmentExpression(=, [VariableReference(mPrivateFlags |, []), Expression(PFLAG_WANTS_FOCUS, [])])    VariableReference(mPrivateFlags |, [])    Expression(PFLAG_WANTS_FOCUS, [])  Statement(}, [])  Statement(return result, [])  Statement(}, [])",1,"/**
 * {@inheritDoc}
 *
 * Looks for a view to give focus to respecting the setting specified by
 * {@link #getDescendantFocusability()}.
 *
 * Uses {@link #onRequestFocusInDescendants(int, android.graphics.Rect)} to
 * find focus within the children of this group when appropriate.
 *
 * @see #FOCUS_BEFORE_DESCENDANTS
 * @see #FOCUS_AFTER_DESCENDANTS
 * @see #FOCUS_BLOCK_DESCENDANTS
 * @see #onRequestFocusInDescendants(int, android.graphics.Rect)
 */
","/**
 * {@inheritDoc}
 *
 * Looks for a view to give focus to respecting the setting specified by
 * {@link #getDescendantFocusability()}.
 *
 * Uses {@link #onRequestFocusInDescendants(int, android.graphics.Rect)} to
 * find focus within the children of this group when appropriate.
 *
 * @see #FOCUS_BEFORE_DESCENDANTS
 * @see #FOCUS_AFTER_DESCENDANTS
 * @see #FOCUS_BLOCK_DESCENDANTS
 * @see #onRequestFocusInDescendants(int, android.graphics.Rect)
 */
",0,[@Override],[@Override],0,,,,1,2,2,3,1,The condition statement in the 'default' case of the 'switch' block has changed. It now concatenates strings in a slightly different way (by breaking long string into smaller sizes) to describe the illegal state.,"As the change in the 'default' case of the 'switch' block alters the condition statement leading to the IllegalStateException, it may result in different behaviour when the function is invoked, thus causing the return values to be different. Therefore, the CI type is 1."
12,<android.os.Parcel: void setDataSize(int)>,30,31,,,,"MethodDeclaration(method_body, [Statement({, []), Statement(updateNativeSize(nativeSetDataSize(mNativePtr, size)), []), Statement(}, [])])  Statement({, [])  Statement(updateNativeSize(nativeSetDataSize(mNativePtr, size)), [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(nativeSetDataSize(mNativePtr, size), []), Statement(}, [])])  Statement({, [])  Statement(nativeSetDataSize(mNativePtr, size), [])  Statement(}, [])",1,"/**
 * Change the amount of data in the parcel.  Can be either smaller or
 * larger than the current size.  If larger than the current capacity,
 * more memory will be allocated.
 *
 * @param size The new number of bytes in the Parcel.
 */
","/**
 * Change the amount of data in the parcel.  Can be either smaller or
 * larger than the current size.  If larger than the current capacity,
 * more memory will be allocated.
 *
 * @param size The new number of bytes in the Parcel.
 */
",0,,,0,,,,2,5,0,4,0,"The statement `updateNativeSize(nativeSetDataSize(mNativePtr, size))` in the early implementation has been changed to `nativeSetDataSize(mNativePtr, size)` in the late implementation. Since this change does not affect return or exception handling, the code change type is 4.","The removed `updateNativeSize` call might only affect internal state update logic and does not lead to different return values or exception handling directly, thus no compatibility issue exists."
13,"<android.view.inputmethod.InlineSuggestionsRequest: void writeToParcel(Parcel,int)>",30,31,,,,"MethodDeclaration(method_body, [Statement({, []), Statement(// You can override field parcelling by defining methods like:, []), AssignmentExpression(=, [VariableReference(byte flg, []), Expression(0, [])]), AssignmentExpression(=, [VariableReference(if (mHostInputToken !, []), Expression(null), [])]), AssignmentExpression(=, [VariableReference(flg |, []), Expression(0x20, [])]), MethodCall(dest.writeByte(flg), [VariableReference(dest, []), Expression(flg, [])]), MethodCall(dest.writeInt(mMaxSuggestionCount), [VariableReference(dest, []), Expression(mMaxSuggestionCount, [])]), MethodCall(dest.writeParcelableList(mInlinePresentationSpecs, flags), [VariableReference(dest, []), Expression(mInlinePresentationSpecs, []), Expression(flags, [])]), MethodCall(dest.writeString(mHostPackageName), [VariableReference(dest, []), Expression(mHostPackageName, [])]), MethodCall(dest.writeTypedObject(mSupportedLocales, flags), [VariableReference(dest, []), Expression(mSupportedLocales, []), Expression(flags, [])]), MethodCall(dest.writeBundle(mExtras), [VariableReference(dest, []), Expression(mExtras, [])]), Statement(parcelHostInputToken(dest, flags), []), MethodCall(dest.writeInt(mHostDisplayId), [VariableReference(dest, []), Expression(mHostDisplayId, [])]), Statement(}, [])])  Statement({, [])  Statement(// You can override field parcelling by defining methods like:, [])  AssignmentExpression(=, [VariableReference(byte flg, []), Expression(0, [])])    VariableReference(byte flg, [])    Expression(0, [])  AssignmentExpression(=, [VariableReference(if (mHostInputToken !, []), Expression(null), [])])    VariableReference(if (mHostInputToken !, [])    Expression(null), [])  AssignmentExpression(=, [VariableReference(flg |, []), Expression(0x20, [])])    VariableReference(flg |, [])    Expression(0x20, [])  MethodCall(dest.writeByte(flg), [VariableReference(dest, []), Expression(flg, [])])    VariableReference(dest, [])    Expression(flg, [])  MethodCall(dest.writeInt(mMaxSuggestionCount), [VariableReference(dest, []), Expression(mMaxSuggestionCount, [])])    VariableReference(dest, [])    Expression(mMaxSuggestionCount, [])  MethodCall(dest.writeParcelableList(mInlinePresentationSpecs, flags), [VariableReference(dest, []), Expression(mInlinePresentationSpecs, []), Expression(flags, [])])    VariableReference(dest, [])    Expression(mInlinePresentationSpecs, [])    Expression(flags, [])  MethodCall(dest.writeString(mHostPackageName), [VariableReference(dest, []), Expression(mHostPackageName, [])])    VariableReference(dest, [])    Expression(mHostPackageName, [])  MethodCall(dest.writeTypedObject(mSupportedLocales, flags), [VariableReference(dest, []), Expression(mSupportedLocales, []), Expression(flags, [])])    VariableReference(dest, [])    Expression(mSupportedLocales, [])    Expression(flags, [])  MethodCall(dest.writeBundle(mExtras), [VariableReference(dest, []), Expression(mExtras, [])])    VariableReference(dest, [])    Expression(mExtras, [])  Statement(parcelHostInputToken(dest, flags), [])  MethodCall(dest.writeInt(mHostDisplayId), [VariableReference(dest, []), Expression(mHostDisplayId, [])])    VariableReference(dest, [])    Expression(mHostDisplayId, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(// You can override field parcelling by defining methods like:, []), AssignmentExpression(=, [VariableReference(int flg, []), Expression(0, [])]), AssignmentExpression(=, [VariableReference(if (mHostInputToken !, []), Expression(null), [])]), AssignmentExpression(=, [VariableReference(flg |, []), Expression(0x20, [])]), AssignmentExpression(=, [VariableReference(if (mInlineTooltipPresentationSpec !, []), Expression(null), [])]), AssignmentExpression(=, [VariableReference(flg |, []), Expression(0x80, [])]), MethodCall(dest.writeInt(flg), [VariableReference(dest, []), Expression(flg, [])]), MethodCall(dest.writeInt(mMaxSuggestionCount), [VariableReference(dest, []), Expression(mMaxSuggestionCount, [])]), MethodCall(dest.writeParcelableList(mInlinePresentationSpecs, flags), [VariableReference(dest, []), Expression(mInlinePresentationSpecs, []), Expression(flags, [])]), MethodCall(dest.writeString(mHostPackageName), [VariableReference(dest, []), Expression(mHostPackageName, [])]), MethodCall(dest.writeTypedObject(mSupportedLocales, flags), [VariableReference(dest, []), Expression(mSupportedLocales, []), Expression(flags, [])]), MethodCall(dest.writeBundle(mExtras), [VariableReference(dest, []), Expression(mExtras, [])]), Statement(parcelHostInputToken(dest, flags), []), MethodCall(dest.writeInt(mHostDisplayId), [VariableReference(dest, []), Expression(mHostDisplayId, [])]), AssignmentExpression(=, [VariableReference(if (mInlineTooltipPresentationSpec !, []), Expression(null), [])]), MethodCall(dest.writeTypedObject(mInlineTooltipPresentationSpec, flags), [VariableReference(dest, []), Expression(mInlineTooltipPresentationSpec, []), Expression(flags, [])]), Statement(}, [])])  Statement({, [])  Statement(// You can override field parcelling by defining methods like:, [])  AssignmentExpression(=, [VariableReference(int flg, []), Expression(0, [])])    VariableReference(int flg, [])    Expression(0, [])  AssignmentExpression(=, [VariableReference(if (mHostInputToken !, []), Expression(null), [])])    VariableReference(if (mHostInputToken !, [])    Expression(null), [])  AssignmentExpression(=, [VariableReference(flg |, []), Expression(0x20, [])])    VariableReference(flg |, [])    Expression(0x20, [])  AssignmentExpression(=, [VariableReference(if (mInlineTooltipPresentationSpec !, []), Expression(null), [])])    VariableReference(if (mInlineTooltipPresentationSpec !, [])    Expression(null), [])  AssignmentExpression(=, [VariableReference(flg |, []), Expression(0x80, [])])    VariableReference(flg |, [])    Expression(0x80, [])  MethodCall(dest.writeInt(flg), [VariableReference(dest, []), Expression(flg, [])])    VariableReference(dest, [])    Expression(flg, [])  MethodCall(dest.writeInt(mMaxSuggestionCount), [VariableReference(dest, []), Expression(mMaxSuggestionCount, [])])    VariableReference(dest, [])    Expression(mMaxSuggestionCount, [])  MethodCall(dest.writeParcelableList(mInlinePresentationSpecs, flags), [VariableReference(dest, []), Expression(mInlinePresentationSpecs, []), Expression(flags, [])])    VariableReference(dest, [])    Expression(mInlinePresentationSpecs, [])    Expression(flags, [])  MethodCall(dest.writeString(mHostPackageName), [VariableReference(dest, []), Expression(mHostPackageName, [])])    VariableReference(dest, [])    Expression(mHostPackageName, [])  MethodCall(dest.writeTypedObject(mSupportedLocales, flags), [VariableReference(dest, []), Expression(mSupportedLocales, []), Expression(flags, [])])    VariableReference(dest, [])    Expression(mSupportedLocales, [])    Expression(flags, [])  MethodCall(dest.writeBundle(mExtras), [VariableReference(dest, []), Expression(mExtras, [])])    VariableReference(dest, [])    Expression(mExtras, [])  Statement(parcelHostInputToken(dest, flags), [])  MethodCall(dest.writeInt(mHostDisplayId), [VariableReference(dest, []), Expression(mHostDisplayId, [])])    VariableReference(dest, [])    Expression(mHostDisplayId, [])  AssignmentExpression(=, [VariableReference(if (mInlineTooltipPresentationSpec !, []), Expression(null), [])])    VariableReference(if (mInlineTooltipPresentationSpec !, [])    Expression(null), [])  MethodCall(dest.writeTypedObject(mInlineTooltipPresentationSpec, flags), [VariableReference(dest, []), Expression(mInlineTooltipPresentationSpec, []), Expression(flags, [])])    VariableReference(dest, [])    Expression(mInlineTooltipPresentationSpec, [])    Expression(flags, [])  Statement(}, [])",1,,,0,"[@Override, @DataClass.Generated.Member]","[@Override, @DataClass.Generated.Member]",0,,,,"1,2","3,4,5",0,"3,4",0,"The type of the variable `flg` has changed from `byte` to `int`. Additionally, new assignment expressions for `flg` have been added (`if (mInlineTooltipPresentationSpec != null)` and `flg |= 0x80`), and a new method call `dest.writeTypedObject(mInlineTooltipPresentationSpec, flags)` has been introduced. Therefore, the code change involves 3 (control dependency changed) and 4 (other statement changed).","The introduced changes do not lead to different return values or types, nor do they introduce new exception handling scenarios. The API's primary behavior related to return values and exception handling remains unaffected, so no CI exists."
14,<android.service.voice.VoiceInteractionSession: void onHandleAssist(AssistState)>,31,32,,,,"MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(if (state.getAssistData(), []), Expression(, [])]), Statement(return, []), AssignmentExpression(=, [VariableReference(} else if (state.getIndex(), []), Expression(, [])]), MethodCall(onHandleAssist(state.getAssistData(), state.getAssistStructure(), state.getAssistContent()), [VariableReference(onHandleAssist(state, []), Expression(), []), Expression(state.getAssistStructure(), []), Expression(state.getAssistContent(), [])]), Statement(} else {, []), MethodCall(onHandleAssistSecondary(state.getAssistData(), state.getAssistStructure(), state.getAssistContent(), state.getIndex(), state.getCount()), [VariableReference(onHandleAssistSecondary(state, []), Expression(), []), Expression(state.getAssistStructure(), []), Expression(state.getAssistContent(), []), Expression(state.getIndex(), []), Expression(state.getCount(), [])]), Statement(}, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(if (state.getAssistData(), []), Expression(, [])])    VariableReference(if (state.getAssistData(), [])    Expression(, [])  Statement(return, [])  AssignmentExpression(=, [VariableReference(} else if (state.getIndex(), []), Expression(, [])])    VariableReference(} else if (state.getIndex(), [])    Expression(, [])  MethodCall(onHandleAssist(state.getAssistData(), state.getAssistStructure(), state.getAssistContent()), [VariableReference(onHandleAssist(state, []), Expression(), []), Expression(state.getAssistStructure(), []), Expression(state.getAssistContent(), [])])    VariableReference(onHandleAssist(state, [])    Expression(), [])    Expression(state.getAssistStructure(), [])    Expression(state.getAssistContent(), [])  Statement(} else {, [])  MethodCall(onHandleAssistSecondary(state.getAssistData(), state.getAssistStructure(), state.getAssistContent(), state.getIndex(), state.getCount()), [VariableReference(onHandleAssistSecondary(state, []), Expression(), []), Expression(state.getAssistStructure(), []), Expression(state.getAssistContent(), []), Expression(state.getIndex(), []), Expression(state.getCount(), [])])    VariableReference(onHandleAssistSecondary(state, [])    Expression(), [])    Expression(state.getAssistStructure(), [])    Expression(state.getAssistContent(), [])    Expression(state.getIndex(), [])    Expression(state.getCount(), [])  Statement(}, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(if (state.getAssistData(), []), Expression(, [])]), Statement(return, []), AssignmentExpression(=, [VariableReference(} else if (state.getIndex(), []), Expression(, [])]), MethodCall(onHandleAssist(state.getAssistData(), state.getAssistStructure(), state.getAssistContent()), [VariableReference(onHandleAssist(state, []), Expression(), []), Expression(state.getAssistStructure(), []), Expression(state.getAssistContent(), [])]), Statement(} else {, []), MethodCall(onHandleAssistSecondary(state.getAssistData(), state.getAssistStructure(), state.getAssistContent(), state.getIndex(), state.getCount()), [VariableReference(onHandleAssistSecondary(state, []), Expression(), []), Expression(state.getAssistStructure(), []), Expression(state.getAssistContent(), []), Expression(state.getIndex(), []), Expression(state.getCount(), [])]), Statement(}, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(if (state.getAssistData(), []), Expression(, [])])    VariableReference(if (state.getAssistData(), [])    Expression(, [])  Statement(return, [])  AssignmentExpression(=, [VariableReference(} else if (state.getIndex(), []), Expression(, [])])    VariableReference(} else if (state.getIndex(), [])    Expression(, [])  MethodCall(onHandleAssist(state.getAssistData(), state.getAssistStructure(), state.getAssistContent()), [VariableReference(onHandleAssist(state, []), Expression(), []), Expression(state.getAssistStructure(), []), Expression(state.getAssistContent(), [])])    VariableReference(onHandleAssist(state, [])    Expression(), [])    Expression(state.getAssistStructure(), [])    Expression(state.getAssistContent(), [])  Statement(} else {, [])  MethodCall(onHandleAssistSecondary(state.getAssistData(), state.getAssistStructure(), state.getAssistContent(), state.getIndex(), state.getCount()), [VariableReference(onHandleAssistSecondary(state, []), Expression(), []), Expression(state.getAssistStructure(), []), Expression(state.getAssistContent(), []), Expression(state.getIndex(), []), Expression(state.getCount(), [])])    VariableReference(onHandleAssistSecondary(state, [])    Expression(), [])    Expression(state.getAssistStructure(), [])    Expression(state.getAssistContent(), [])    Expression(state.getIndex(), [])    Expression(state.getCount(), [])  Statement(}, [])  Statement(}, [])",0,"/**
 * Called to receive data from the application that the user was currently viewing when
 * an assist session is started. If the original show request did not specify
 * {@link #SHOW_WITH_ASSIST}, {@link AssistState} parameter will only provide
 * {@link ActivityId}.
 *
 * <p>This method is called for all activities along with an index and count that indicates
 * which activity the data is for. {@code index} will be between 0 and {@code count}-1 and
 * this method is called once for each activity in no particular order. The {@code count}
 * indicates how many activities to expect assist data for, including the top focused one.
 * The focused activity can be determined by calling {@link AssistState#isFocused()}.
 *
 * <p>To be responsive to assist requests, process assist data as soon as it is received,
 * without waiting for all queued activities to return assist data.
 *
 * @param state The state object capturing the state of an activity.
 */
","/**
 * Called to receive data from the application that the user was currently viewing when
 * an assist session is started. If the original show request did not specify
 * {@link #SHOW_WITH_ASSIST}, {@link AssistState} parameter will only provide
 * {@link ActivityId}. If there was a failure to write the assist data to
 * {@link AssistStructure}, the {@link AssistState#getAssistStructure()} will return null.
 *
 * <p>This method is called for all activities along with an index and count that indicates
 * which activity the data is for. {@code index} will be between 0 and {@code count}-1 and
 * this method is called once for each activity in no particular order. The {@code count}
 * indicates how many activities to expect assist data for, including the top focused one.
 * The focused activity can be determined by calling {@link AssistState#isFocused()}.
 *
 * <p>To be responsive to assist requests, process assist data as soon as it is received,
 * without waiting for all queued activities to return assist data.
 *
 * @param state The state object capturing the state of an activity.
 */
",1,,,0,,,,0,0,0,0,0,The abstract syntax trees (AST) of both implementations are identical. This indicates that there are no code changes between the early and late versions at the implementation level.,"Since there are no changes in the implementation, no compatibility issues exist."
15,<android.view.contentcapture.ContentCaptureManager: ComponentName getServiceComponentName()>,31,32,,,,"MethodDeclaration(method_body, [Statement({, []), Statement(return null, []), AssignmentExpression(=, [VariableReference(final SyncResultReceiver resultReceiver, []), Expression(new SyncResultReceiver(SYNC_CALLS_TIMEOUT_MS), [])]), Statement(try {, []), MethodCall(mService.getServiceComponentName(resultReceiver), [VariableReference(mService, []), Expression(resultReceiver, [])]), MethodCall(return resultReceiver.getParcelableResult(), [VariableReference(return resultReceiver, []), Expression(, [])]), Statement(} catch (RemoteException e) {, []), MethodCall(throw e.rethrowFromSystemServer(), [VariableReference(throw e, []), Expression(, [])]), Statement(}, []), Statement(}, [])])  Statement({, [])  Statement(return null, [])  AssignmentExpression(=, [VariableReference(final SyncResultReceiver resultReceiver, []), Expression(new SyncResultReceiver(SYNC_CALLS_TIMEOUT_MS), [])])    VariableReference(final SyncResultReceiver resultReceiver, [])    Expression(new SyncResultReceiver(SYNC_CALLS_TIMEOUT_MS), [])  Statement(try {, [])  MethodCall(mService.getServiceComponentName(resultReceiver), [VariableReference(mService, []), Expression(resultReceiver, [])])    VariableReference(mService, [])    Expression(resultReceiver, [])  MethodCall(return resultReceiver.getParcelableResult(), [VariableReference(return resultReceiver, []), Expression(, [])])    VariableReference(return resultReceiver, [])    Expression(, [])  Statement(} catch (RemoteException e) {, [])  MethodCall(throw e.rethrowFromSystemServer(), [VariableReference(throw e, []), Expression(, [])])    VariableReference(throw e, [])    Expression(, [])  Statement(}, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(return null, []), AssignmentExpression(=, [VariableReference(final SyncResultReceiver resultReceiver, []), Expression(new SyncResultReceiver(SYNC_CALLS_TIMEOUT_MS), [])]), Statement(try {, []), MethodCall(mService.getServiceComponentName(resultReceiver), [VariableReference(mService, []), Expression(resultReceiver, [])]), MethodCall(return resultReceiver.getParcelableResult(), [VariableReference(return resultReceiver, []), Expression(, [])]), Statement(} catch (RemoteException e) {, []), MethodCall(throw e.rethrowFromSystemServer(), [VariableReference(throw e, []), Expression(, [])]), Statement(}, []), Statement(}, [])])  Statement({, [])  Statement(return null, [])  AssignmentExpression(=, [VariableReference(final SyncResultReceiver resultReceiver, []), Expression(new SyncResultReceiver(SYNC_CALLS_TIMEOUT_MS), [])])    VariableReference(final SyncResultReceiver resultReceiver, [])    Expression(new SyncResultReceiver(SYNC_CALLS_TIMEOUT_MS), [])  Statement(try {, [])  MethodCall(mService.getServiceComponentName(resultReceiver), [VariableReference(mService, []), Expression(resultReceiver, [])])    VariableReference(mService, [])    Expression(resultReceiver, [])  MethodCall(return resultReceiver.getParcelableResult(), [VariableReference(return resultReceiver, []), Expression(, [])])    VariableReference(return resultReceiver, [])    Expression(, [])  Statement(} catch (RemoteException e) {, [])  MethodCall(throw e.rethrowFromSystemServer(), [VariableReference(throw e, []), Expression(, [])])    VariableReference(throw e, [])    Expression(, [])  Statement(}, [])  Statement(}, [])",0,"/**
 * Returns the component name of the system service that is consuming the captured events for
 * the current user.
 */
","/**
 * Returns the component name of the system service that is consuming the captured events for
 * the current user.
 *
 * @throws RuntimeException if getting the component name is timed out.
 */
",1,[@Nullable],[@Nullable],0,,,,0,0,0,2,2,"The early and late versions are the same except for the comments. The late version's comment adds a note about throwing a `RuntimeException` if getting the component name times out. This implies a potential change in how exceptions are thrown, so the code change type is 2.","Since the comment indicates that the method might throw a `RuntimeException` in cases of a timeout, this suggests a new exception handling behavior that wasn't explicitly documented before. Therefore, the CI type is 2."
16,<android.view.translation.TranslationResponseValue: CharSequence getTransliteration()>,31,32,,,,"MethodDeclaration(method_body, [Statement({, []), Statement(return mTransliteration, []), Statement(}, [])])  Statement({, [])  Statement(return mTransliteration, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(return mTransliteration, []), Statement(}, [])])  Statement({, [])  Statement(return mTransliteration, [])  Statement(}, [])",0,"/**
 * The transliteration result of the translated text.
 * TODO: Describe the result structure.
 */
","/**
 * The transliteration result of the translated text.
 *
 * <p>This returns a CharSequence representation of the transliteration of the translated text.
 */
",1,"[@DataClass.Generated.Member, @Nullable]","[@DataClass.Generated.Member, @Nullable]",0,,,,0,0,0,0,0,There is no change observed in the AST node of the method implementation between the early and late versions.,"Since there are no changes in the method implementation, there are no Compatibility Issues."
17,<android.view.contentcapture.ContentCaptureContext: void dump(PrintWriter)>,31,32,,,,"MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(if (mComponentName !, []), Expression(null) {, [])]), AssignmentExpression(=, [VariableReference(pw.print(""activity, []), Expression(""), [])]), MethodCall(pw.print(mComponentName.flattenToShortString()), [VariableReference(pw, []), Expression(mComponentName.flattenToShortString(), [])]), Statement(}, []), AssignmentExpression(=, [VariableReference(if (mId !, []), Expression(null) {, [])]), AssignmentExpression(=, [VariableReference(pw.print("", id, []), Expression(""), [])]), MethodCall(mId.dump(pw), [VariableReference(mId, []), Expression(pw, [])]), Statement(}, []), AssignmentExpression(=, [VariableReference(pw.print("", activityId, []), Expression(""), [])]), MethodCall(pw.print(mActivityId), [VariableReference(pw, []), Expression(mActivityId, [])]), AssignmentExpression(=, [VariableReference(pw.print("", displayId, []), Expression(""), [])]), MethodCall(pw.print(mDisplayId), [VariableReference(pw, []), Expression(mDisplayId, [])]), AssignmentExpression(=, [VariableReference(if (mParentSessionId !, []), Expression(NO_SESSION_ID) {, [])]), AssignmentExpression(=, [VariableReference(pw.print("", parentId, []), Expression(""), [])]), MethodCall(pw.print(mParentSessionId), [VariableReference(pw, []), Expression(mParentSessionId, [])]), Statement(}, []), Statement(if (mFlags > 0) {, []), AssignmentExpression(=, [VariableReference(pw.print("", flags, []), Expression(""), [])]), MethodCall(pw.print(mFlags), [VariableReference(pw, []), Expression(mFlags, [])]), Statement(}, []), AssignmentExpression(=, [VariableReference(if (mExtras !, []), Expression(null) {, [])]), Statement(// NOTE: cannot dump because it could contain PII, []), MethodCall(pw.print("", hasExtras""), [VariableReference(pw, []), Expression("", []), Expression(hasExtras"", [])]), Statement(}, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(if (mComponentName !, []), Expression(null) {, [])])    VariableReference(if (mComponentName !, [])    Expression(null) {, [])  AssignmentExpression(=, [VariableReference(pw.print(""activity, []), Expression(""), [])])    VariableReference(pw.print(""activity, [])    Expression(""), [])  MethodCall(pw.print(mComponentName.flattenToShortString()), [VariableReference(pw, []), Expression(mComponentName.flattenToShortString(), [])])    VariableReference(pw, [])    Expression(mComponentName.flattenToShortString(), [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(if (mId !, []), Expression(null) {, [])])    VariableReference(if (mId !, [])    Expression(null) {, [])  AssignmentExpression(=, [VariableReference(pw.print("", id, []), Expression(""), [])])    VariableReference(pw.print("", id, [])    Expression(""), [])  MethodCall(mId.dump(pw), [VariableReference(mId, []), Expression(pw, [])])    VariableReference(mId, [])    Expression(pw, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(pw.print("", activityId, []), Expression(""), [])])    VariableReference(pw.print("", activityId, [])    Expression(""), [])  MethodCall(pw.print(mActivityId), [VariableReference(pw, []), Expression(mActivityId, [])])    VariableReference(pw, [])    Expression(mActivityId, [])  AssignmentExpression(=, [VariableReference(pw.print("", displayId, []), Expression(""), [])])    VariableReference(pw.print("", displayId, [])    Expression(""), [])  MethodCall(pw.print(mDisplayId), [VariableReference(pw, []), Expression(mDisplayId, [])])    VariableReference(pw, [])    Expression(mDisplayId, [])  AssignmentExpression(=, [VariableReference(if (mParentSessionId !, []), Expression(NO_SESSION_ID) {, [])])    VariableReference(if (mParentSessionId !, [])    Expression(NO_SESSION_ID) {, [])  AssignmentExpression(=, [VariableReference(pw.print("", parentId, []), Expression(""), [])])    VariableReference(pw.print("", parentId, [])    Expression(""), [])  MethodCall(pw.print(mParentSessionId), [VariableReference(pw, []), Expression(mParentSessionId, [])])    VariableReference(pw, [])    Expression(mParentSessionId, [])  Statement(}, [])  Statement(if (mFlags > 0) {, [])  AssignmentExpression(=, [VariableReference(pw.print("", flags, []), Expression(""), [])])    VariableReference(pw.print("", flags, [])    Expression(""), [])  MethodCall(pw.print(mFlags), [VariableReference(pw, []), Expression(mFlags, [])])    VariableReference(pw, [])    Expression(mFlags, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(if (mExtras !, []), Expression(null) {, [])])    VariableReference(if (mExtras !, [])    Expression(null) {, [])  Statement(// NOTE: cannot dump because it could contain PII, [])  MethodCall(pw.print("", hasExtras""), [VariableReference(pw, []), Expression("", []), Expression(hasExtras"", [])])    VariableReference(pw, [])    Expression("", [])    Expression(hasExtras"", [])  Statement(}, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(if (mComponentName !, []), Expression(null) {, [])]), AssignmentExpression(=, [VariableReference(pw.print(""activity, []), Expression(""), [])]), MethodCall(pw.print(mComponentName.flattenToShortString()), [VariableReference(pw, []), Expression(mComponentName.flattenToShortString(), [])]), Statement(}, []), AssignmentExpression(=, [VariableReference(if (mId !, []), Expression(null) {, [])]), AssignmentExpression(=, [VariableReference(pw.print("", id, []), Expression(""), [])]), MethodCall(mId.dump(pw), [VariableReference(mId, []), Expression(pw, [])]), Statement(}, []), AssignmentExpression(=, [VariableReference(pw.print("", activityId, []), Expression(""), [])]), MethodCall(pw.print(mActivityId), [VariableReference(pw, []), Expression(mActivityId, [])]), AssignmentExpression(=, [VariableReference(pw.print("", displayId, []), Expression(""), [])]), MethodCall(pw.print(mDisplayId), [VariableReference(pw, []), Expression(mDisplayId, [])]), AssignmentExpression(=, [VariableReference(pw.print("", windowToken, []), Expression(""), [])]), MethodCall(pw.print(mWindowToken), [VariableReference(pw, []), Expression(mWindowToken, [])]), AssignmentExpression(=, [VariableReference(if (mParentSessionId !, []), Expression(NO_SESSION_ID) {, [])]), AssignmentExpression(=, [VariableReference(pw.print("", parentId, []), Expression(""), [])]), MethodCall(pw.print(mParentSessionId), [VariableReference(pw, []), Expression(mParentSessionId, [])]), Statement(}, []), Statement(if (mFlags > 0) {, []), AssignmentExpression(=, [VariableReference(pw.print("", flags, []), Expression(""), [])]), MethodCall(pw.print(mFlags), [VariableReference(pw, []), Expression(mFlags, [])]), Statement(}, []), AssignmentExpression(=, [VariableReference(if (mExtras !, []), Expression(null) {, [])]), Statement(// NOTE: cannot dump because it could contain PII, []), MethodCall(pw.print("", hasExtras""), [VariableReference(pw, []), Expression("", []), Expression(hasExtras"", [])]), Statement(}, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(if (mComponentName !, []), Expression(null) {, [])])    VariableReference(if (mComponentName !, [])    Expression(null) {, [])  AssignmentExpression(=, [VariableReference(pw.print(""activity, []), Expression(""), [])])    VariableReference(pw.print(""activity, [])    Expression(""), [])  MethodCall(pw.print(mComponentName.flattenToShortString()), [VariableReference(pw, []), Expression(mComponentName.flattenToShortString(), [])])    VariableReference(pw, [])    Expression(mComponentName.flattenToShortString(), [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(if (mId !, []), Expression(null) {, [])])    VariableReference(if (mId !, [])    Expression(null) {, [])  AssignmentExpression(=, [VariableReference(pw.print("", id, []), Expression(""), [])])    VariableReference(pw.print("", id, [])    Expression(""), [])  MethodCall(mId.dump(pw), [VariableReference(mId, []), Expression(pw, [])])    VariableReference(mId, [])    Expression(pw, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(pw.print("", activityId, []), Expression(""), [])])    VariableReference(pw.print("", activityId, [])    Expression(""), [])  MethodCall(pw.print(mActivityId), [VariableReference(pw, []), Expression(mActivityId, [])])    VariableReference(pw, [])    Expression(mActivityId, [])  AssignmentExpression(=, [VariableReference(pw.print("", displayId, []), Expression(""), [])])    VariableReference(pw.print("", displayId, [])    Expression(""), [])  MethodCall(pw.print(mDisplayId), [VariableReference(pw, []), Expression(mDisplayId, [])])    VariableReference(pw, [])    Expression(mDisplayId, [])  AssignmentExpression(=, [VariableReference(pw.print("", windowToken, []), Expression(""), [])])    VariableReference(pw.print("", windowToken, [])    Expression(""), [])  MethodCall(pw.print(mWindowToken), [VariableReference(pw, []), Expression(mWindowToken, [])])    VariableReference(pw, [])    Expression(mWindowToken, [])  AssignmentExpression(=, [VariableReference(if (mParentSessionId !, []), Expression(NO_SESSION_ID) {, [])])    VariableReference(if (mParentSessionId !, [])    Expression(NO_SESSION_ID) {, [])  AssignmentExpression(=, [VariableReference(pw.print("", parentId, []), Expression(""), [])])    VariableReference(pw.print("", parentId, [])    Expression(""), [])  MethodCall(pw.print(mParentSessionId), [VariableReference(pw, []), Expression(mParentSessionId, [])])    VariableReference(pw, [])    Expression(mParentSessionId, [])  Statement(}, [])  Statement(if (mFlags > 0) {, [])  AssignmentExpression(=, [VariableReference(pw.print("", flags, []), Expression(""), [])])    VariableReference(pw.print("", flags, [])    Expression(""), [])  MethodCall(pw.print(mFlags), [VariableReference(pw, []), Expression(mFlags, [])])    VariableReference(pw, [])    Expression(mFlags, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(if (mExtras !, []), Expression(null) {, [])])    VariableReference(if (mExtras !, [])    Expression(null) {, [])  Statement(// NOTE: cannot dump because it could contain PII, [])  MethodCall(pw.print("", hasExtras""), [VariableReference(pw, []), Expression("", []), Expression(hasExtras"", [])])    VariableReference(pw, [])    Expression("", [])    Expression(hasExtras"", [])  Statement(}, [])  Statement(}, [])",1,"// TODO(b/111276913): dump to proto as well
","// TODO(b/111276913): dump to proto as well
",0,,,0,,,,"1,2","4,5",0,4,0,"A new statement (pw.print(mWindowToken)) has been introduced, so the code change type is 4.","The change does not affect return statements or exception handling. Therefore, no Compatibility Issue exists."
18,<android.appwidget.AppWidgetHostView.ViewApplyListener: void onViewApplied(View)>,31,32,,,,"MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(AppWidgetHostView.this.mLayoutId, []), Expression(mLayoutId, [])]), AssignmentExpression(=, [VariableReference(mViewMode, []), Expression(VIEW_MODE_CONTENT, [])]), Statement(applyContent(v, mIsReapply, null), []), AssignmentExpression(=, [VariableReference(mLastInflatedRemoteViewsId, []), Expression(mViews.computeUniqueId(mLastInflatedRemoteViews), [])]), Statement(restoreInstanceState(), []), AssignmentExpression(=, [VariableReference(mLastExecutionSignal, []), Expression(null, [])]), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(AppWidgetHostView.this.mLayoutId, []), Expression(mLayoutId, [])])    VariableReference(AppWidgetHostView.this.mLayoutId, [])    Expression(mLayoutId, [])  AssignmentExpression(=, [VariableReference(mViewMode, []), Expression(VIEW_MODE_CONTENT, [])])    VariableReference(mViewMode, [])    Expression(VIEW_MODE_CONTENT, [])  Statement(applyContent(v, mIsReapply, null), [])  AssignmentExpression(=, [VariableReference(mLastInflatedRemoteViewsId, []), Expression(mViews.computeUniqueId(mLastInflatedRemoteViews), [])])    VariableReference(mLastInflatedRemoteViewsId, [])    Expression(mViews.computeUniqueId(mLastInflatedRemoteViews), [])  Statement(restoreInstanceState(), [])  AssignmentExpression(=, [VariableReference(mLastExecutionSignal, []), Expression(null, [])])    VariableReference(mLastExecutionSignal, [])    Expression(null, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(mViewMode, []), Expression(VIEW_MODE_CONTENT, [])]), Statement(applyContent(v, mIsReapply, null), []), AssignmentExpression(=, [VariableReference(mLastInflatedRemoteViewsId, []), Expression(mViews.computeUniqueId(mLastInflatedRemoteViews), [])]), Statement(restoreInstanceState(), []), AssignmentExpression(=, [VariableReference(mLastExecutionSignal, []), Expression(null, [])]), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(mViewMode, []), Expression(VIEW_MODE_CONTENT, [])])    VariableReference(mViewMode, [])    Expression(VIEW_MODE_CONTENT, [])  Statement(applyContent(v, mIsReapply, null), [])  AssignmentExpression(=, [VariableReference(mLastInflatedRemoteViewsId, []), Expression(mViews.computeUniqueId(mLastInflatedRemoteViews), [])])    VariableReference(mLastInflatedRemoteViewsId, [])    Expression(mViews.computeUniqueId(mLastInflatedRemoteViews), [])  Statement(restoreInstanceState(), [])  AssignmentExpression(=, [VariableReference(mLastExecutionSignal, []), Expression(null, [])])    VariableReference(mLastExecutionSignal, [])    Expression(null, [])  Statement(}, [])",1,,,0,[@Override],[@Override],0,,,,"1,2",4,0,4,0,"The line `AppWidgetHostView.this.mLayoutId = mLayoutId;` has been removed in the late implementation, which can be classified as ""Other statement changed.""","The removal of this assignment doesn't change the method's return value or exception handling behavior. Therefore, there is no Compatibility Issue."
19,"<android.app.admin.DevicePolicyManager: void setPasswordMinimumLowerCase(ComponentName,int)>",31,32,,,,"MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(if (mService !, []), Expression(null) {, [])]), Statement(try {, []), MethodCall(mService.setPasswordMinimumLowerCase(admin, length, mParentInstance), [VariableReference(mService, []), Expression(admin, []), Expression(length, []), Expression(mParentInstance, [])]), Statement(} catch (RemoteException e) {, []), MethodCall(throw e.rethrowFromSystemServer(), [VariableReference(throw e, []), Expression(, [])]), Statement(}, []), Statement(}, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(if (mService !, []), Expression(null) {, [])])    VariableReference(if (mService !, [])    Expression(null) {, [])  Statement(try {, [])  MethodCall(mService.setPasswordMinimumLowerCase(admin, length, mParentInstance), [VariableReference(mService, []), Expression(admin, []), Expression(length, []), Expression(mParentInstance, [])])    VariableReference(mService, [])    Expression(admin, [])    Expression(length, [])    Expression(mParentInstance, [])  Statement(} catch (RemoteException e) {, [])  MethodCall(throw e.rethrowFromSystemServer(), [VariableReference(throw e, []), Expression(, [])])    VariableReference(throw e, [])    Expression(, [])  Statement(}, [])  Statement(}, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(if (mService !, []), Expression(null) {, [])]), Statement(try {, []), MethodCall(mService.setPasswordMinimumLowerCase(admin, length, mParentInstance), [VariableReference(mService, []), Expression(admin, []), Expression(length, []), Expression(mParentInstance, [])]), Statement(} catch (RemoteException e) {, []), MethodCall(throw e.rethrowFromSystemServer(), [VariableReference(throw e, []), Expression(, [])]), Statement(}, []), Statement(}, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(if (mService !, []), Expression(null) {, [])])    VariableReference(if (mService !, [])    Expression(null) {, [])  Statement(try {, [])  MethodCall(mService.setPasswordMinimumLowerCase(admin, length, mParentInstance), [VariableReference(mService, []), Expression(admin, []), Expression(length, []), Expression(mParentInstance, [])])    VariableReference(mService, [])    Expression(admin, [])    Expression(length, [])    Expression(mParentInstance, [])  Statement(} catch (RemoteException e) {, [])  MethodCall(throw e.rethrowFromSystemServer(), [VariableReference(throw e, []), Expression(, [])])    VariableReference(throw e, [])    Expression(, [])  Statement(}, [])  Statement(}, [])  Statement(}, [])",0,"/**
 * Called by an application that is administering the device to set the minimum number of lower
 * case letters required in the password. After setting this, the user will not be able to enter
 * a new password that is not at least as restrictive as what has been set. Note that the
 * current password will remain until the user has set a new one, so the change does not take
 * place immediately. To prompt the user for a new password, use
 * {@link #ACTION_SET_NEW_PASSWORD} or {@link #ACTION_SET_NEW_PARENT_PROFILE_PASSWORD} after
 * setting this value. This constraint is only imposed if the administrator has also requested
 * {@link #PASSWORD_QUALITY_COMPLEX} with {@link #setPasswordQuality}. If an app targeting
 * SDK level {@link android.os.Build.VERSION_CODES#R} and above enforces this constraint without
 * settings password quality to {@link #PASSWORD_QUALITY_COMPLEX} first, this method will throw
 * {@link IllegalStateException}. The default value is 0.
 * <p>
 * On devices not supporting {@link PackageManager#FEATURE_SECURE_LOCK_SCREEN} feature, the
 * password is always treated as empty.
 * <p>
 * The calling device admin must have requested
 * {@link DeviceAdminInfo#USES_POLICY_LIMIT_PASSWORD} to be able to call this method; if it has
 * not, a security exception will be thrown.
 * <p>
 *
 * Apps targeting {@link android.os.Build.VERSION_CODES#R} and below can call this method on the
 * {@link DevicePolicyManager} instance returned by
 * {@link #getParentProfileInstance(ComponentName)} in order to set restrictions on the parent
 * profile.
 *
 * @deprecated see {@link #setPasswordQuality(ComponentName, int)} for details.
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated with.
 * @param length The new desired minimum number of lower case letters required in the password.
 * A value of 0 means there is no restriction.
 * @throws SecurityException if {@code admin} is not an active administrator or {@code admin}
 * does not use {@link DeviceAdminInfo#USES_POLICY_LIMIT_PASSWORD}
 * @throws IllegalStateException if the calling app is targeting SDK level
 * {@link android.os.Build.VERSION_CODES#R} and above and didn't set a sufficient password
 * quality requirement prior to calling this method.
 */
","/**
 * Called by an application that is administering the device to set the minimum number of lower
 * case letters required in the password. After setting this, the user will not be able to enter
 * a new password that is not at least as restrictive as what has been set. Note that the
 * current password will remain until the user has set a new one, so the change does not take
 * place immediately. To prompt the user for a new password, use
 * {@link #ACTION_SET_NEW_PASSWORD} or {@link #ACTION_SET_NEW_PARENT_PROFILE_PASSWORD} after
 * setting this value. This constraint is only imposed if the administrator has also requested
 * {@link #PASSWORD_QUALITY_COMPLEX} with {@link #setPasswordQuality}. If an app targeting
 * SDK level {@link android.os.Build.VERSION_CODES#R} and above enforces this constraint without
 * settings password quality to {@link #PASSWORD_QUALITY_COMPLEX} first, this method will throw
 * {@link IllegalStateException}. The default value is 0.
 * <p>
 * On devices not supporting {@link PackageManager#FEATURE_SECURE_LOCK_SCREEN} feature, the
 * password is always treated as empty.
 * <p>
 * The calling device admin must have requested
 * {@link DeviceAdminInfo#USES_POLICY_LIMIT_PASSWORD} to be able to call this method; if it has
 * not, a security exception will be thrown.
 * <p>
 * Apps targeting {@link android.os.Build.VERSION_CODES#R} and below can call this method on the
 * {@link DevicePolicyManager} instance returned by
 * {@link #getParentProfileInstance(ComponentName)} in order to set restrictions on the parent
 * profile.
 *
 * <p><string>Note:</strong> this method is ignored on
 * {PackageManager#FEATURE_AUTOMOTIVE automotive builds}.
 *
 * @deprecated see {@link #setPasswordQuality(ComponentName, int)} for details.
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated with.
 * @param length The new desired minimum number of lower case letters required in the password.
 * A value of 0 means there is no restriction.
 * @throws SecurityException if {@code admin} is not an active administrator or {@code admin}
 * does not use {@link DeviceAdminInfo#USES_POLICY_LIMIT_PASSWORD}
 * @throws IllegalStateException if the calling app is targeting SDK level
 * {@link android.os.Build.VERSION_CODES#R} and above and didn't set a sufficient password
 * quality requirement prior to calling this method.
 */
",1,[@Deprecated],[@Deprecated],0,,,,0,0,0,0,0,There are no observable changes between the early implementation and the late implementation based on the provided AST nodes.,"No changes have been detected in the API implementation that could lead to different behaviors. Therefore, no compatibility issues exist."
20,<android.inputmethodservice.IInputMethodWrapper: void executeMessage(Message)>,31,32,,,,"MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(InputMethod inputMethod, []), Expression(mInputMethod.get(), [])]), Statement(// Need a valid reference to the inputMethod for everything except a dump., []), AssignmentExpression(=, [VariableReference(if (inputMethod, []), Expression(, [])]), MethodCall(Log.w(TAG, ""Input method reference was null, ignoring message: "" + msg.what), [VariableReference(Log, []), Expression(TAG, []), Expression(""Input method reference was null, []), Expression(ignoring message: "" + msg.what, [])]), Statement(return, []), Statement(}, []), Statement(case DO_DUMP:, []), Statement({, []), AssignmentExpression(=, [VariableReference(AbstractInputMethodService target, []), Expression(mTarget.get(), [])]), AssignmentExpression(=, [VariableReference(if (target, []), Expression(, [])]), Statement(return, []), Statement(}, []), AssignmentExpression(=, [VariableReference(SomeArgs args, []), Expression((SomeArgs) msg.obj, [])]), Statement(try {, []), MethodCall(target.dump((FileDescriptor) args.arg1, (PrintWriter) args.arg2, (String[]) args.arg3), [VariableReference(target, []), Expression((FileDescriptor) args.arg1, []), Expression((PrintWriter) args.arg2, []), Expression((String[]) args.arg3, [])]), Statement(} catch (RuntimeException e) {, []), Statement(}, []), Statement(}, []), MethodCall(args.recycle(), [VariableReference(args, []), Expression(, [])]), Statement(return, []), Statement(}, []), Statement(case DO_INITIALIZE_INTERNAL:, []), Statement({, []), AssignmentExpression(=, [VariableReference(SomeArgs args, []), Expression((SomeArgs) msg.obj, [])]), Statement(try {, []), MethodCall(inputMethod.initializeInternal((IBinder) args.arg1, msg.arg1, (IInputMethodPrivilegedOperations) args.arg2, (int) args.arg3), [VariableReference(inputMethod, []), Expression((IBinder) args.arg1, []), Expression(msg.arg1, []), Expression((IInputMethodPrivilegedOperations) args.arg2, []), Expression((int) args.arg3, [])]), Statement(} finally {, []), MethodCall(args.recycle(), [VariableReference(args, []), Expression(, [])]), Statement(}, []), Statement(return, []), Statement(}, []), Statement(case DO_SET_INPUT_CONTEXT:, []), Statement({, []), MethodCall(inputMethod.bindInput((InputBinding) msg.obj), [VariableReference(inputMethod, []), Expression((InputBinding) msg.obj, [])]), Statement(return, []), Statement(}, []), Statement(case DO_UNSET_INPUT_CONTEXT:, []), MethodCall(inputMethod.unbindInput(), [VariableReference(inputMethod, []), Expression(, [])]), Statement(return, []), Statement(case DO_START_INPUT:, []), Statement({, []), AssignmentExpression(=, [VariableReference(final SomeArgs args, []), Expression((SomeArgs) msg.obj, [])]), AssignmentExpression(=, [VariableReference(final IBinder startInputToken, []), Expression((IBinder) args.arg1, [])]), AssignmentExpression(=, [VariableReference(final IInputContext inputContext, []), Expression((IInputContext) args.arg2, [])]), AssignmentExpression(=, [VariableReference(final EditorInfo info, []), Expression((EditorInfo) args.arg3, [])]), AssignmentExpression(=, [VariableReference(final CancellationGroup cancellationGroup, []), Expression((CancellationGroup) args.arg4, [])]), AssignmentExpression(=, [VariableReference(SomeArgs moreArgs, []), Expression((SomeArgs) args.arg5, [])]), AssignmentExpression(=, [VariableReference(final InputConnection ic, []), Expression(inputContext !, [])]), MethodCall(info.makeCompatible(mTargetSdkVersion), [VariableReference(info, []), Expression(mTargetSdkVersion, [])]), AssignmentExpression(=, [VariableReference(inputMethod.dispatchStartInputWithToken(ic, info, moreArgs.argi1, []), Expression(, [])]), Statement(startInputToken), []), MethodCall(args.recycle(), [VariableReference(args, []), Expression(, [])]), MethodCall(moreArgs.recycle(), [VariableReference(moreArgs, []), Expression(, [])]), Statement(return, []), Statement(}, []), Statement(case DO_CREATE_SESSION:, []), Statement({, []), AssignmentExpression(=, [VariableReference(SomeArgs args, []), Expression((SomeArgs) msg.obj, [])]), MethodCall(inputMethod.createSession(new InputMethodSessionCallbackWrapper(mContext, (InputChannel) args.arg1, (IInputSessionCallback) args.arg2)), [VariableReference(inputMethod, []), Expression(new InputMethodSessionCallbackWrapper(mContext, []), Expression((InputChannel) args.arg1, []), Expression((IInputSessionCallback) args.arg2), [])]), MethodCall(args.recycle(), [VariableReference(args, []), Expression(, [])]), Statement(return, []), Statement(}, []), Statement(case DO_SET_SESSION_ENABLED:, []), AssignmentExpression(=, [VariableReference(inputMethod.setSessionEnabled((InputMethodSession) msg.obj, msg.arg1 !, []), Expression(0), [])]), Statement(return, []), Statement(case DO_REVOKE_SESSION:, []), MethodCall(inputMethod.revokeSession((InputMethodSession) msg.obj), [VariableReference(inputMethod, []), Expression((InputMethodSession) msg.obj, [])]), Statement(return, []), Statement(case DO_SHOW_SOFT_INPUT:, []), Statement({, []), AssignmentExpression(=, [VariableReference(final SomeArgs args, []), Expression((SomeArgs) msg.obj, [])]), MethodCall(inputMethod.showSoftInputWithToken(msg.arg1, (ResultReceiver) args.arg2, (IBinder) args.arg1), [VariableReference(inputMethod, []), Expression(msg.arg1, []), Expression((ResultReceiver) args.arg2, []), Expression((IBinder) args.arg1, [])]), MethodCall(args.recycle(), [VariableReference(args, []), Expression(, [])]), Statement(return, []), Statement(}, []), Statement(case DO_HIDE_SOFT_INPUT:, []), Statement({, []), AssignmentExpression(=, [VariableReference(final SomeArgs args, []), Expression((SomeArgs) msg.obj, [])]), MethodCall(inputMethod.hideSoftInputWithToken(msg.arg1, (ResultReceiver) args.arg2, (IBinder) args.arg1), [VariableReference(inputMethod, []), Expression(msg.arg1, []), Expression((ResultReceiver) args.arg2, []), Expression((IBinder) args.arg1, [])]), MethodCall(args.recycle(), [VariableReference(args, []), Expression(, [])]), Statement(return, []), Statement(}, []), Statement(case DO_CHANGE_INPUTMETHOD_SUBTYPE:, []), MethodCall(inputMethod.changeInputMethodSubtype((InputMethodSubtype) msg.obj), [VariableReference(inputMethod, []), Expression((InputMethodSubtype) msg.obj, [])]), Statement(return, []), Statement(case DO_CREATE_INLINE_SUGGESTIONS_REQUEST:, []), AssignmentExpression(=, [VariableReference(final SomeArgs args, []), Expression((SomeArgs) msg.obj, [])]), MethodCall(inputMethod.onCreateInlineSuggestionsRequest((InlineSuggestionsRequestInfo) args.arg1, (IInlineSuggestionsRequestCallback) args.arg2), [VariableReference(inputMethod, []), Expression((InlineSuggestionsRequestInfo) args.arg1, []), Expression((IInlineSuggestionsRequestCallback) args.arg2, [])]), MethodCall(args.recycle(), [VariableReference(args, []), Expression(, [])]), Statement(return, []), Statement(}, []), MethodCall(Log.w(TAG, ""Unhandled message code: "" + msg.what), [VariableReference(Log, []), Expression(TAG, []), Expression(""Unhandled message code: "" + msg.what, [])]), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(InputMethod inputMethod, []), Expression(mInputMethod.get(), [])])    VariableReference(InputMethod inputMethod, [])    Expression(mInputMethod.get(), [])  Statement(// Need a valid reference to the inputMethod for everything except a dump., [])  AssignmentExpression(=, [VariableReference(if (inputMethod, []), Expression(, [])])    VariableReference(if (inputMethod, [])    Expression(, [])  MethodCall(Log.w(TAG, ""Input method reference was null, ignoring message: "" + msg.what), [VariableReference(Log, []), Expression(TAG, []), Expression(""Input method reference was null, []), Expression(ignoring message: "" + msg.what, [])])    VariableReference(Log, [])    Expression(TAG, [])    Expression(""Input method reference was null, [])    Expression(ignoring message: "" + msg.what, [])  Statement(return, [])  Statement(}, [])  Statement(case DO_DUMP:, [])  Statement({, [])  AssignmentExpression(=, [VariableReference(AbstractInputMethodService target, []), Expression(mTarget.get(), [])])    VariableReference(AbstractInputMethodService target, [])    Expression(mTarget.get(), [])  AssignmentExpression(=, [VariableReference(if (target, []), Expression(, [])])    VariableReference(if (target, [])    Expression(, [])  Statement(return, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(SomeArgs args, []), Expression((SomeArgs) msg.obj, [])])    VariableReference(SomeArgs args, [])    Expression((SomeArgs) msg.obj, [])  Statement(try {, [])  MethodCall(target.dump((FileDescriptor) args.arg1, (PrintWriter) args.arg2, (String[]) args.arg3), [VariableReference(target, []), Expression((FileDescriptor) args.arg1, []), Expression((PrintWriter) args.arg2, []), Expression((String[]) args.arg3, [])])    VariableReference(target, [])    Expression((FileDescriptor) args.arg1, [])    Expression((PrintWriter) args.arg2, [])    Expression((String[]) args.arg3, [])  Statement(} catch (RuntimeException e) {, [])  Statement(}, [])  Statement(}, [])  MethodCall(args.recycle(), [VariableReference(args, []), Expression(, [])])    VariableReference(args, [])    Expression(, [])  Statement(return, [])  Statement(}, [])  Statement(case DO_INITIALIZE_INTERNAL:, [])  Statement({, [])  AssignmentExpression(=, [VariableReference(SomeArgs args, []), Expression((SomeArgs) msg.obj, [])])    VariableReference(SomeArgs args, [])    Expression((SomeArgs) msg.obj, [])  Statement(try {, [])  MethodCall(inputMethod.initializeInternal((IBinder) args.arg1, msg.arg1, (IInputMethodPrivilegedOperations) args.arg2, (int) args.arg3), [VariableReference(inputMethod, []), Expression((IBinder) args.arg1, []), Expression(msg.arg1, []), Expression((IInputMethodPrivilegedOperations) args.arg2, []), Expression((int) args.arg3, [])])    VariableReference(inputMethod, [])    Expression((IBinder) args.arg1, [])    Expression(msg.arg1, [])    Expression((IInputMethodPrivilegedOperations) args.arg2, [])    Expression((int) args.arg3, [])  Statement(} finally {, [])  MethodCall(args.recycle(), [VariableReference(args, []), Expression(, [])])    VariableReference(args, [])    Expression(, [])  Statement(}, [])  Statement(return, [])  Statement(}, [])  Statement(case DO_SET_INPUT_CONTEXT:, [])  Statement({, [])  MethodCall(inputMethod.bindInput((InputBinding) msg.obj), [VariableReference(inputMethod, []), Expression((InputBinding) msg.obj, [])])    VariableReference(inputMethod, [])    Expression((InputBinding) msg.obj, [])  Statement(return, [])  Statement(}, [])  Statement(case DO_UNSET_INPUT_CONTEXT:, [])  MethodCall(inputMethod.unbindInput(), [VariableReference(inputMethod, []), Expression(, [])])    VariableReference(inputMethod, [])    Expression(, [])  Statement(return, [])  Statement(case DO_START_INPUT:, [])  Statement({, [])  AssignmentExpression(=, [VariableReference(final SomeArgs args, []), Expression((SomeArgs) msg.obj, [])])    VariableReference(final SomeArgs args, [])    Expression((SomeArgs) msg.obj, [])  AssignmentExpression(=, [VariableReference(final IBinder startInputToken, []), Expression((IBinder) args.arg1, [])])    VariableReference(final IBinder startInputToken, [])    Expression((IBinder) args.arg1, [])  AssignmentExpression(=, [VariableReference(final IInputContext inputContext, []), Expression((IInputContext) args.arg2, [])])    VariableReference(final IInputContext inputContext, [])    Expression((IInputContext) args.arg2, [])  AssignmentExpression(=, [VariableReference(final EditorInfo info, []), Expression((EditorInfo) args.arg3, [])])    VariableReference(final EditorInfo info, [])    Expression((EditorInfo) args.arg3, [])  AssignmentExpression(=, [VariableReference(final CancellationGroup cancellationGroup, []), Expression((CancellationGroup) args.arg4, [])])    VariableReference(final CancellationGroup cancellationGroup, [])    Expression((CancellationGroup) args.arg4, [])  AssignmentExpression(=, [VariableReference(SomeArgs moreArgs, []), Expression((SomeArgs) args.arg5, [])])    VariableReference(SomeArgs moreArgs, [])    Expression((SomeArgs) args.arg5, [])  AssignmentExpression(=, [VariableReference(final InputConnection ic, []), Expression(inputContext !, [])])    VariableReference(final InputConnection ic, [])    Expression(inputContext !, [])  MethodCall(info.makeCompatible(mTargetSdkVersion), [VariableReference(info, []), Expression(mTargetSdkVersion, [])])    VariableReference(info, [])    Expression(mTargetSdkVersion, [])  AssignmentExpression(=, [VariableReference(inputMethod.dispatchStartInputWithToken(ic, info, moreArgs.argi1, []), Expression(, [])])    VariableReference(inputMethod.dispatchStartInputWithToken(ic, info, moreArgs.argi1, [])    Expression(, [])  Statement(startInputToken), [])  MethodCall(args.recycle(), [VariableReference(args, []), Expression(, [])])    VariableReference(args, [])    Expression(, [])  MethodCall(moreArgs.recycle(), [VariableReference(moreArgs, []), Expression(, [])])    VariableReference(moreArgs, [])    Expression(, [])  Statement(return, [])  Statement(}, [])  Statement(case DO_CREATE_SESSION:, [])  Statement({, [])  AssignmentExpression(=, [VariableReference(SomeArgs args, []), Expression((SomeArgs) msg.obj, [])])    VariableReference(SomeArgs args, [])    Expression((SomeArgs) msg.obj, [])  MethodCall(inputMethod.createSession(new InputMethodSessionCallbackWrapper(mContext, (InputChannel) args.arg1, (IInputSessionCallback) args.arg2)), [VariableReference(inputMethod, []), Expression(new InputMethodSessionCallbackWrapper(mContext, []), Expression((InputChannel) args.arg1, []), Expression((IInputSessionCallback) args.arg2), [])])    VariableReference(inputMethod, [])    Expression(new InputMethodSessionCallbackWrapper(mContext, [])    Expression((InputChannel) args.arg1, [])    Expression((IInputSessionCallback) args.arg2), [])  MethodCall(args.recycle(), [VariableReference(args, []), Expression(, [])])    VariableReference(args, [])    Expression(, [])  Statement(return, [])  Statement(}, [])  Statement(case DO_SET_SESSION_ENABLED:, [])  AssignmentExpression(=, [VariableReference(inputMethod.setSessionEnabled((InputMethodSession) msg.obj, msg.arg1 !, []), Expression(0), [])])    VariableReference(inputMethod.setSessionEnabled((InputMethodSession) msg.obj, msg.arg1 !, [])    Expression(0), [])  Statement(return, [])  Statement(case DO_REVOKE_SESSION:, [])  MethodCall(inputMethod.revokeSession((InputMethodSession) msg.obj), [VariableReference(inputMethod, []), Expression((InputMethodSession) msg.obj, [])])    VariableReference(inputMethod, [])    Expression((InputMethodSession) msg.obj, [])  Statement(return, [])  Statement(case DO_SHOW_SOFT_INPUT:, [])  Statement({, [])  AssignmentExpression(=, [VariableReference(final SomeArgs args, []), Expression((SomeArgs) msg.obj, [])])    VariableReference(final SomeArgs args, [])    Expression((SomeArgs) msg.obj, [])  MethodCall(inputMethod.showSoftInputWithToken(msg.arg1, (ResultReceiver) args.arg2, (IBinder) args.arg1), [VariableReference(inputMethod, []), Expression(msg.arg1, []), Expression((ResultReceiver) args.arg2, []), Expression((IBinder) args.arg1, [])])    VariableReference(inputMethod, [])    Expression(msg.arg1, [])    Expression((ResultReceiver) args.arg2, [])    Expression((IBinder) args.arg1, [])  MethodCall(args.recycle(), [VariableReference(args, []), Expression(, [])])    VariableReference(args, [])    Expression(, [])  Statement(return, [])  Statement(}, [])  Statement(case DO_HIDE_SOFT_INPUT:, [])  Statement({, [])  AssignmentExpression(=, [VariableReference(final SomeArgs args, []), Expression((SomeArgs) msg.obj, [])])    VariableReference(final SomeArgs args, [])    Expression((SomeArgs) msg.obj, [])  MethodCall(inputMethod.hideSoftInputWithToken(msg.arg1, (ResultReceiver) args.arg2, (IBinder) args.arg1), [VariableReference(inputMethod, []), Expression(msg.arg1, []), Expression((ResultReceiver) args.arg2, []), Expression((IBinder) args.arg1, [])])    VariableReference(inputMethod, [])    Expression(msg.arg1, [])    Expression((ResultReceiver) args.arg2, [])    Expression((IBinder) args.arg1, [])  MethodCall(args.recycle(), [VariableReference(args, []), Expression(, [])])    VariableReference(args, [])    Expression(, [])  Statement(return, [])  Statement(}, [])  Statement(case DO_CHANGE_INPUTMETHOD_SUBTYPE:, [])  MethodCall(inputMethod.changeInputMethodSubtype((InputMethodSubtype) msg.obj), [VariableReference(inputMethod, []), Expression((InputMethodSubtype) msg.obj, [])])    VariableReference(inputMethod, [])    Expression((InputMethodSubtype) msg.obj, [])  Statement(return, [])  Statement(case DO_CREATE_INLINE_SUGGESTIONS_REQUEST:, [])  AssignmentExpression(=, [VariableReference(final SomeArgs args, []), Expression((SomeArgs) msg.obj, [])])    VariableReference(final SomeArgs args, [])    Expression((SomeArgs) msg.obj, [])  MethodCall(inputMethod.onCreateInlineSuggestionsRequest((InlineSuggestionsRequestInfo) args.arg1, (IInlineSuggestionsRequestCallback) args.arg2), [VariableReference(inputMethod, []), Expression((InlineSuggestionsRequestInfo) args.arg1, []), Expression((IInlineSuggestionsRequestCallback) args.arg2, [])])    VariableReference(inputMethod, [])    Expression((InlineSuggestionsRequestInfo) args.arg1, [])    Expression((IInlineSuggestionsRequestCallback) args.arg2, [])  MethodCall(args.recycle(), [VariableReference(args, []), Expression(, [])])    VariableReference(args, [])    Expression(, [])  Statement(return, [])  Statement(}, [])  MethodCall(Log.w(TAG, ""Unhandled message code: "" + msg.what), [VariableReference(Log, []), Expression(TAG, []), Expression(""Unhandled message code: "" + msg.what, [])])    VariableReference(Log, [])    Expression(TAG, [])    Expression(""Unhandled message code: "" + msg.what, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(InputMethod inputMethod, []), Expression(mInputMethod.get(), [])]), Statement(// Need a valid reference to the inputMethod for everything except a dump., []), AssignmentExpression(=, [VariableReference(if (inputMethod, []), Expression(, [])]), MethodCall(Log.w(TAG, ""Input method reference was null, ignoring message: "" + msg.what), [VariableReference(Log, []), Expression(TAG, []), Expression(""Input method reference was null, []), Expression(ignoring message: "" + msg.what, [])]), Statement(return, []), Statement(}, []), Statement(case DO_DUMP:, []), Statement({, []), AssignmentExpression(=, [VariableReference(AbstractInputMethodService target, []), Expression(mTarget.get(), [])]), AssignmentExpression(=, [VariableReference(if (target, []), Expression(, [])]), Statement(return, []), Statement(}, []), AssignmentExpression(=, [VariableReference(SomeArgs args, []), Expression((SomeArgs) msg.obj, [])]), Statement(try {, []), MethodCall(target.dump((FileDescriptor) args.arg1, (PrintWriter) args.arg2, (String[]) args.arg3), [VariableReference(target, []), Expression((FileDescriptor) args.arg1, []), Expression((PrintWriter) args.arg2, []), Expression((String[]) args.arg3, [])]), Statement(} catch (RuntimeException e) {, []), Statement(}, []), Statement(}, []), MethodCall(args.recycle(), [VariableReference(args, []), Expression(, [])]), Statement(return, []), Statement(}, []), Statement(case DO_INITIALIZE_INTERNAL:, []), Statement({, []), AssignmentExpression(=, [VariableReference(SomeArgs args, []), Expression((SomeArgs) msg.obj, [])]), Statement(try {, []), MethodCall(inputMethod.initializeInternal((IBinder) args.arg1, (IInputMethodPrivilegedOperations) args.arg2, msg.arg1), [VariableReference(inputMethod, []), Expression((IBinder) args.arg1, []), Expression((IInputMethodPrivilegedOperations) args.arg2, []), Expression(msg.arg1, [])]), Statement(} finally {, []), MethodCall(args.recycle(), [VariableReference(args, []), Expression(, [])]), Statement(}, []), Statement(return, []), Statement(}, []), Statement(case DO_SET_INPUT_CONTEXT:, []), Statement({, []), MethodCall(inputMethod.bindInput((InputBinding) msg.obj), [VariableReference(inputMethod, []), Expression((InputBinding) msg.obj, [])]), Statement(return, []), Statement(}, []), Statement(case DO_UNSET_INPUT_CONTEXT:, []), MethodCall(inputMethod.unbindInput(), [VariableReference(inputMethod, []), Expression(, [])]), Statement(return, []), Statement(case DO_START_INPUT:, []), Statement({, []), AssignmentExpression(=, [VariableReference(final SomeArgs args, []), Expression((SomeArgs) msg.obj, [])]), AssignmentExpression(=, [VariableReference(final IBinder startInputToken, []), Expression((IBinder) args.arg1, [])]), AssignmentExpression(=, [VariableReference(final IInputContext inputContext, []), Expression((IInputContext) args.arg2, [])]), AssignmentExpression(=, [VariableReference(final EditorInfo info, []), Expression((EditorInfo) args.arg3, [])]), AssignmentExpression(=, [VariableReference(final CancellationGroup cancellationGroup, []), Expression((CancellationGroup) args.arg4, [])]), AssignmentExpression(=, [VariableReference(SomeArgs moreArgs, []), Expression((SomeArgs) args.arg5, [])]), AssignmentExpression(=, [VariableReference(final InputConnection ic, []), Expression(inputContext !, [])]), MethodCall(info.makeCompatible(mTargetSdkVersion), [VariableReference(info, []), Expression(mTargetSdkVersion, [])]), AssignmentExpression(=, [VariableReference(inputMethod.dispatchStartInputWithToken(ic, info, moreArgs.argi1, []), Expression(, [])]), Statement(startInputToken), []), MethodCall(args.recycle(), [VariableReference(args, []), Expression(, [])]), MethodCall(moreArgs.recycle(), [VariableReference(moreArgs, []), Expression(, [])]), Statement(return, []), Statement(}, []), Statement(case DO_CREATE_SESSION:, []), Statement({, []), AssignmentExpression(=, [VariableReference(SomeArgs args, []), Expression((SomeArgs) msg.obj, [])]), MethodCall(inputMethod.createSession(new InputMethodSessionCallbackWrapper(mContext, (InputChannel) args.arg1, (IInputSessionCallback) args.arg2)), [VariableReference(inputMethod, []), Expression(new InputMethodSessionCallbackWrapper(mContext, []), Expression((InputChannel) args.arg1, []), Expression((IInputSessionCallback) args.arg2), [])]), MethodCall(args.recycle(), [VariableReference(args, []), Expression(, [])]), Statement(return, []), Statement(}, []), Statement(case DO_SET_SESSION_ENABLED:, []), AssignmentExpression(=, [VariableReference(inputMethod.setSessionEnabled((InputMethodSession) msg.obj, msg.arg1 !, []), Expression(0), [])]), Statement(return, []), Statement(case DO_REVOKE_SESSION:, []), MethodCall(inputMethod.revokeSession((InputMethodSession) msg.obj), [VariableReference(inputMethod, []), Expression((InputMethodSession) msg.obj, [])]), Statement(return, []), Statement(case DO_SHOW_SOFT_INPUT:, []), Statement({, []), AssignmentExpression(=, [VariableReference(final SomeArgs args, []), Expression((SomeArgs) msg.obj, [])]), MethodCall(inputMethod.showSoftInputWithToken(msg.arg1, (ResultReceiver) args.arg2, (IBinder) args.arg1), [VariableReference(inputMethod, []), Expression(msg.arg1, []), Expression((ResultReceiver) args.arg2, []), Expression((IBinder) args.arg1, [])]), MethodCall(args.recycle(), [VariableReference(args, []), Expression(, [])]), Statement(return, []), Statement(}, []), Statement(case DO_HIDE_SOFT_INPUT:, []), Statement({, []), AssignmentExpression(=, [VariableReference(final SomeArgs args, []), Expression((SomeArgs) msg.obj, [])]), MethodCall(inputMethod.hideSoftInputWithToken(msg.arg1, (ResultReceiver) args.arg2, (IBinder) args.arg1), [VariableReference(inputMethod, []), Expression(msg.arg1, []), Expression((ResultReceiver) args.arg2, []), Expression((IBinder) args.arg1, [])]), MethodCall(args.recycle(), [VariableReference(args, []), Expression(, [])]), Statement(return, []), Statement(}, []), Statement(case DO_CHANGE_INPUTMETHOD_SUBTYPE:, []), MethodCall(inputMethod.changeInputMethodSubtype((InputMethodSubtype) msg.obj), [VariableReference(inputMethod, []), Expression((InputMethodSubtype) msg.obj, [])]), Statement(return, []), Statement(case DO_CREATE_INLINE_SUGGESTIONS_REQUEST:, []), AssignmentExpression(=, [VariableReference(final SomeArgs args, []), Expression((SomeArgs) msg.obj, [])]), MethodCall(inputMethod.onCreateInlineSuggestionsRequest((InlineSuggestionsRequestInfo) args.arg1, (IInlineSuggestionsRequestCallback) args.arg2), [VariableReference(inputMethod, []), Expression((InlineSuggestionsRequestInfo) args.arg1, []), Expression((IInlineSuggestionsRequestCallback) args.arg2, [])]), MethodCall(args.recycle(), [VariableReference(args, []), Expression(, [])]), Statement(return, []), Statement(}, []), MethodCall(Log.w(TAG, ""Unhandled message code: "" + msg.what), [VariableReference(Log, []), Expression(TAG, []), Expression(""Unhandled message code: "" + msg.what, [])]), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(InputMethod inputMethod, []), Expression(mInputMethod.get(), [])])    VariableReference(InputMethod inputMethod, [])    Expression(mInputMethod.get(), [])  Statement(// Need a valid reference to the inputMethod for everything except a dump., [])  AssignmentExpression(=, [VariableReference(if (inputMethod, []), Expression(, [])])    VariableReference(if (inputMethod, [])    Expression(, [])  MethodCall(Log.w(TAG, ""Input method reference was null, ignoring message: "" + msg.what), [VariableReference(Log, []), Expression(TAG, []), Expression(""Input method reference was null, []), Expression(ignoring message: "" + msg.what, [])])    VariableReference(Log, [])    Expression(TAG, [])    Expression(""Input method reference was null, [])    Expression(ignoring message: "" + msg.what, [])  Statement(return, [])  Statement(}, [])  Statement(case DO_DUMP:, [])  Statement({, [])  AssignmentExpression(=, [VariableReference(AbstractInputMethodService target, []), Expression(mTarget.get(), [])])    VariableReference(AbstractInputMethodService target, [])    Expression(mTarget.get(), [])  AssignmentExpression(=, [VariableReference(if (target, []), Expression(, [])])    VariableReference(if (target, [])    Expression(, [])  Statement(return, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(SomeArgs args, []), Expression((SomeArgs) msg.obj, [])])    VariableReference(SomeArgs args, [])    Expression((SomeArgs) msg.obj, [])  Statement(try {, [])  MethodCall(target.dump((FileDescriptor) args.arg1, (PrintWriter) args.arg2, (String[]) args.arg3), [VariableReference(target, []), Expression((FileDescriptor) args.arg1, []), Expression((PrintWriter) args.arg2, []), Expression((String[]) args.arg3, [])])    VariableReference(target, [])    Expression((FileDescriptor) args.arg1, [])    Expression((PrintWriter) args.arg2, [])    Expression((String[]) args.arg3, [])  Statement(} catch (RuntimeException e) {, [])  Statement(}, [])  Statement(}, [])  MethodCall(args.recycle(), [VariableReference(args, []), Expression(, [])])    VariableReference(args, [])    Expression(, [])  Statement(return, [])  Statement(}, [])  Statement(case DO_INITIALIZE_INTERNAL:, [])  Statement({, [])  AssignmentExpression(=, [VariableReference(SomeArgs args, []), Expression((SomeArgs) msg.obj, [])])    VariableReference(SomeArgs args, [])    Expression((SomeArgs) msg.obj, [])  Statement(try {, [])  MethodCall(inputMethod.initializeInternal((IBinder) args.arg1, (IInputMethodPrivilegedOperations) args.arg2, msg.arg1), [VariableReference(inputMethod, []), Expression((IBinder) args.arg1, []), Expression((IInputMethodPrivilegedOperations) args.arg2, []), Expression(msg.arg1, [])])    VariableReference(inputMethod, [])    Expression((IBinder) args.arg1, [])    Expression((IInputMethodPrivilegedOperations) args.arg2, [])    Expression(msg.arg1, [])  Statement(} finally {, [])  MethodCall(args.recycle(), [VariableReference(args, []), Expression(, [])])    VariableReference(args, [])    Expression(, [])  Statement(}, [])  Statement(return, [])  Statement(}, [])  Statement(case DO_SET_INPUT_CONTEXT:, [])  Statement({, [])  MethodCall(inputMethod.bindInput((InputBinding) msg.obj), [VariableReference(inputMethod, []), Expression((InputBinding) msg.obj, [])])    VariableReference(inputMethod, [])    Expression((InputBinding) msg.obj, [])  Statement(return, [])  Statement(}, [])  Statement(case DO_UNSET_INPUT_CONTEXT:, [])  MethodCall(inputMethod.unbindInput(), [VariableReference(inputMethod, []), Expression(, [])])    VariableReference(inputMethod, [])    Expression(, [])  Statement(return, [])  Statement(case DO_START_INPUT:, [])  Statement({, [])  AssignmentExpression(=, [VariableReference(final SomeArgs args, []), Expression((SomeArgs) msg.obj, [])])    VariableReference(final SomeArgs args, [])    Expression((SomeArgs) msg.obj, [])  AssignmentExpression(=, [VariableReference(final IBinder startInputToken, []), Expression((IBinder) args.arg1, [])])    VariableReference(final IBinder startInputToken, [])    Expression((IBinder) args.arg1, [])  AssignmentExpression(=, [VariableReference(final IInputContext inputContext, []), Expression((IInputContext) args.arg2, [])])    VariableReference(final IInputContext inputContext, [])    Expression((IInputContext) args.arg2, [])  AssignmentExpression(=, [VariableReference(final EditorInfo info, []), Expression((EditorInfo) args.arg3, [])])    VariableReference(final EditorInfo info, [])    Expression((EditorInfo) args.arg3, [])  AssignmentExpression(=, [VariableReference(final CancellationGroup cancellationGroup, []), Expression((CancellationGroup) args.arg4, [])])    VariableReference(final CancellationGroup cancellationGroup, [])    Expression((CancellationGroup) args.arg4, [])  AssignmentExpression(=, [VariableReference(SomeArgs moreArgs, []), Expression((SomeArgs) args.arg5, [])])    VariableReference(SomeArgs moreArgs, [])    Expression((SomeArgs) args.arg5, [])  AssignmentExpression(=, [VariableReference(final InputConnection ic, []), Expression(inputContext !, [])])    VariableReference(final InputConnection ic, [])    Expression(inputContext !, [])  MethodCall(info.makeCompatible(mTargetSdkVersion), [VariableReference(info, []), Expression(mTargetSdkVersion, [])])    VariableReference(info, [])    Expression(mTargetSdkVersion, [])  AssignmentExpression(=, [VariableReference(inputMethod.dispatchStartInputWithToken(ic, info, moreArgs.argi1, []), Expression(, [])])    VariableReference(inputMethod.dispatchStartInputWithToken(ic, info, moreArgs.argi1, [])    Expression(, [])  Statement(startInputToken), [])  MethodCall(args.recycle(), [VariableReference(args, []), Expression(, [])])    VariableReference(args, [])    Expression(, [])  MethodCall(moreArgs.recycle(), [VariableReference(moreArgs, []), Expression(, [])])    VariableReference(moreArgs, [])    Expression(, [])  Statement(return, [])  Statement(}, [])  Statement(case DO_CREATE_SESSION:, [])  Statement({, [])  AssignmentExpression(=, [VariableReference(SomeArgs args, []), Expression((SomeArgs) msg.obj, [])])    VariableReference(SomeArgs args, [])    Expression((SomeArgs) msg.obj, [])  MethodCall(inputMethod.createSession(new InputMethodSessionCallbackWrapper(mContext, (InputChannel) args.arg1, (IInputSessionCallback) args.arg2)), [VariableReference(inputMethod, []), Expression(new InputMethodSessionCallbackWrapper(mContext, []), Expression((InputChannel) args.arg1, []), Expression((IInputSessionCallback) args.arg2), [])])    VariableReference(inputMethod, [])    Expression(new InputMethodSessionCallbackWrapper(mContext, [])    Expression((InputChannel) args.arg1, [])    Expression((IInputSessionCallback) args.arg2), [])  MethodCall(args.recycle(), [VariableReference(args, []), Expression(, [])])    VariableReference(args, [])    Expression(, [])  Statement(return, [])  Statement(}, [])  Statement(case DO_SET_SESSION_ENABLED:, [])  AssignmentExpression(=, [VariableReference(inputMethod.setSessionEnabled((InputMethodSession) msg.obj, msg.arg1 !, []), Expression(0), [])])    VariableReference(inputMethod.setSessionEnabled((InputMethodSession) msg.obj, msg.arg1 !, [])    Expression(0), [])  Statement(return, [])  Statement(case DO_REVOKE_SESSION:, [])  MethodCall(inputMethod.revokeSession((InputMethodSession) msg.obj), [VariableReference(inputMethod, []), Expression((InputMethodSession) msg.obj, [])])    VariableReference(inputMethod, [])    Expression((InputMethodSession) msg.obj, [])  Statement(return, [])  Statement(case DO_SHOW_SOFT_INPUT:, [])  Statement({, [])  AssignmentExpression(=, [VariableReference(final SomeArgs args, []), Expression((SomeArgs) msg.obj, [])])    VariableReference(final SomeArgs args, [])    Expression((SomeArgs) msg.obj, [])  MethodCall(inputMethod.showSoftInputWithToken(msg.arg1, (ResultReceiver) args.arg2, (IBinder) args.arg1), [VariableReference(inputMethod, []), Expression(msg.arg1, []), Expression((ResultReceiver) args.arg2, []), Expression((IBinder) args.arg1, [])])    VariableReference(inputMethod, [])    Expression(msg.arg1, [])    Expression((ResultReceiver) args.arg2, [])    Expression((IBinder) args.arg1, [])  MethodCall(args.recycle(), [VariableReference(args, []), Expression(, [])])    VariableReference(args, [])    Expression(, [])  Statement(return, [])  Statement(}, [])  Statement(case DO_HIDE_SOFT_INPUT:, [])  Statement({, [])  AssignmentExpression(=, [VariableReference(final SomeArgs args, []), Expression((SomeArgs) msg.obj, [])])    VariableReference(final SomeArgs args, [])    Expression((SomeArgs) msg.obj, [])  MethodCall(inputMethod.hideSoftInputWithToken(msg.arg1, (ResultReceiver) args.arg2, (IBinder) args.arg1), [VariableReference(inputMethod, []), Expression(msg.arg1, []), Expression((ResultReceiver) args.arg2, []), Expression((IBinder) args.arg1, [])])    VariableReference(inputMethod, [])    Expression(msg.arg1, [])    Expression((ResultReceiver) args.arg2, [])    Expression((IBinder) args.arg1, [])  MethodCall(args.recycle(), [VariableReference(args, []), Expression(, [])])    VariableReference(args, [])    Expression(, [])  Statement(return, [])  Statement(}, [])  Statement(case DO_CHANGE_INPUTMETHOD_SUBTYPE:, [])  MethodCall(inputMethod.changeInputMethodSubtype((InputMethodSubtype) msg.obj), [VariableReference(inputMethod, []), Expression((InputMethodSubtype) msg.obj, [])])    VariableReference(inputMethod, [])    Expression((InputMethodSubtype) msg.obj, [])  Statement(return, [])  Statement(case DO_CREATE_INLINE_SUGGESTIONS_REQUEST:, [])  AssignmentExpression(=, [VariableReference(final SomeArgs args, []), Expression((SomeArgs) msg.obj, [])])    VariableReference(final SomeArgs args, [])    Expression((SomeArgs) msg.obj, [])  MethodCall(inputMethod.onCreateInlineSuggestionsRequest((InlineSuggestionsRequestInfo) args.arg1, (IInlineSuggestionsRequestCallback) args.arg2), [VariableReference(inputMethod, []), Expression((InlineSuggestionsRequestInfo) args.arg1, []), Expression((IInlineSuggestionsRequestCallback) args.arg2, [])])    VariableReference(inputMethod, [])    Expression((InlineSuggestionsRequestInfo) args.arg1, [])    Expression((IInlineSuggestionsRequestCallback) args.arg2, [])  MethodCall(args.recycle(), [VariableReference(args, []), Expression(, [])])    VariableReference(args, [])    Expression(, [])  Statement(return, [])  Statement(}, [])  MethodCall(Log.w(TAG, ""Unhandled message code: "" + msg.what), [VariableReference(Log, []), Expression(TAG, []), Expression(""Unhandled message code: "" + msg.what, [])])    VariableReference(Log, [])    Expression(TAG, [])    Expression(""Unhandled message code: "" + msg.what, [])  Statement(}, [])",1,,,0,"[@MainThread, @Override]","[@MainThread, @Override]",0,,,,2,5,0,4,0,"The expression ((IBinder) args.arg1, msg.arg1, (IInputMethodPrivilegedOperations) args.arg2, (int) args.arg3) was changed to ((IBinder) args.arg1, (IInputMethodPrivilegedOperations) args.arg2, msg.arg1). The change does not affect return statements or exception handling statements directly, so it is classified as an ""Other statement changed"" type.","The modification in the statement structure does not influence the returned values or the exception handling mechanism, hence no Compatibility Issues are expected."
21,<android.text.style.StyleSpan: void updateMeasureState(TextPaint)>,31,32,,,,"MethodDeclaration(method_body, [Statement({, []), Statement(apply(paint, mStyle), []), Statement(}, [])])  Statement({, [])  Statement(apply(paint, mStyle), [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(apply(paint, mStyle, mFontWeightAdjustment), []), Statement(}, [])])  Statement({, [])  Statement(apply(paint, mStyle, mFontWeightAdjustment), [])  Statement(}, [])",1,,,0,[@Override],[@Override],0,,,,2,5,0,5,0,"The dependent API apply has changed, with an additional parameter (mFontWeightAdjustment) being introduced, so the change type is 5.","There is no indication that the addition of `mFontWeightAdjustment` as a parameter to the `apply` method will lead to different return values or exception handling in the `updateMeasureState` method itself. Therefore, no Compatibility Issue exists."
22,"<android.app.DisabledWallpaperManager: int setBitmap(Bitmap,Rect,boolean,int)>",31,32,,,,"MethodDeclaration(method_body, [Statement({, []), Statement(return unsupported(), []), Statement(}, [])])  Statement({, [])  Statement(return unsupported(), [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(unsupported(), []), Statement(return 0, []), Statement(}, [])])  Statement({, [])  Statement(unsupported(), [])  Statement(return 0, [])  Statement(}, [])",1,,,0,[@Override],[@Override],0,,,,1,"1,4",1,1,1,"The return statement has changed from `return unsupported()` to `unsupported(); return 0`, so the code change type is 1.","The change in the return statement will make the API potentially return a different value (from the result of `unsupported()` to `0`), so the CI type is 1."
23,"<android.view.View: boolean startDragAndDrop(ClipData,DragShadowBuilder,Object,int)>",31,32,,,,"MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(Log.d(VIEW_LOG_TAG, ""startDragAndDrop: data, []), Expression("" + data + "" flags, [])]), Statement(}, []), AssignmentExpression(=, [VariableReference(if (mAttachInfo, []), Expression(, [])]), MethodCall(Log.w(VIEW_LOG_TAG, ""startDragAndDrop called on a detached view.""), [VariableReference(Log, []), Expression(VIEW_LOG_TAG, []), Expression(""startDragAndDrop called on a detached view."", [])]), Statement(return false, []), Statement(}, []), MethodCall(Log.w(VIEW_LOG_TAG, ""startDragAndDrop called with an invalid surface.""), [VariableReference(Log, []), Expression(VIEW_LOG_TAG, []), Expression(""startDragAndDrop called with an invalid surface."", [])]), Statement(return false, []), Statement(}, []), AssignmentExpression(=, [VariableReference(if (data !, []), Expression(null) {, [])]), AssignmentExpression(=, [VariableReference(data.prepareToLeaveProcess((flags & View.DRAG_FLAG_GLOBAL) !, []), Expression(0), [])]), Statement(}, []), AssignmentExpression(=, [VariableReference(Point shadowSize, []), Expression(new Point(), [])]), AssignmentExpression(=, [VariableReference(Point shadowTouchPoint, []), Expression(new Point(), [])]), MethodCall(shadowBuilder.onProvideShadowMetrics(shadowSize, shadowTouchPoint), [VariableReference(shadowBuilder, []), Expression(shadowSize, []), Expression(shadowTouchPoint, [])]), Statement(throw new IllegalStateException(""Drag shadow dimensions must not be negative""), []), Statement(}, []), Statement(// does not accept zero size surface., []), AssignmentExpression(=, [VariableReference(if (shadowSize.x, []), Expression(, [])]), Statement(if (!sAcceptZeroSizeDragShadow) {, []), Statement(throw new IllegalStateException(""Drag shadow dimensions must be positive""), []), Statement(}, []), AssignmentExpression(=, [VariableReference(shadowSize.x, []), Expression(1, [])]), AssignmentExpression(=, [VariableReference(shadowSize.y, []), Expression(1, [])]), Statement(}, []), AssignmentExpression(=, [VariableReference(Log.d(VIEW_LOG_TAG, ""drag shadow: width, []), Expression("" + shadowSize.x + "" height, [])]), Statement(}, []), AssignmentExpression(=, [VariableReference(final ViewRootImpl root, []), Expression(mAttachInfo.mViewRootImpl, [])]), AssignmentExpression(=, [VariableReference(final SurfaceSession session, []), Expression(new SurfaceSession(), [])]), AssignmentExpression(=, [VariableReference(final SurfaceControl surfaceControl, []), Expression(new SurfaceControl.Builder(session).setName(""drag surface"").setParent(root.getSurfaceControl()).setBufferSize(shadowSize.x, shadowSize.y).setFormat(PixelFormat.TRANSLUCENT).setCallsite(""View.startDragAndDrop"").build(), [])]), AssignmentExpression(=, [VariableReference(final Surface surface, []), Expression(new Surface(), [])]), MethodCall(surface.copyFrom(surfaceControl), [VariableReference(surface, []), Expression(surfaceControl, [])]), AssignmentExpression(=, [VariableReference(IBinder token, []), Expression(null, [])]), Statement(try {, []), AssignmentExpression(=, [VariableReference(final Canvas canvas, []), Expression(isHardwareAccelerated() ? surface.lockHardwareCanvas() : surface.lockCanvas(null), [])]), Statement(try {, []), MethodCall(canvas.drawColor(0, PorterDuff.Mode.CLEAR), [VariableReference(canvas, []), Expression(0, []), Expression(PorterDuff.Mode.CLEAR, [])]), MethodCall(shadowBuilder.onDrawShadow(canvas), [VariableReference(shadowBuilder, []), Expression(canvas, [])]), Statement(} finally {, []), MethodCall(surface.unlockCanvasAndPost(canvas), [VariableReference(surface, []), Expression(canvas, [])]), Statement(}, []), Statement(// repurpose 'shadowSize' for the last touch point, []), MethodCall(root.getLastTouchPoint(shadowSize), [VariableReference(root, []), Expression(shadowSize, [])]), AssignmentExpression(=, [VariableReference(token, []), Expression(mAttachInfo.mSession.performDrag(mAttachInfo.mWindow, flags, surfaceControl, root.getLastTouchSource(), shadowSize.x, shadowSize.y, shadowTouchPoint.x, shadowTouchPoint.y, data), [])]), MethodCall(Log.d(VIEW_LOG_TAG, ""performDrag returned "" + token), [VariableReference(Log, []), Expression(VIEW_LOG_TAG, []), Expression(""performDrag returned "" + token, [])]), Statement(}, []), AssignmentExpression(=, [VariableReference(if (token !, []), Expression(null) {, [])]), AssignmentExpression(=, [VariableReference(if (mAttachInfo.mDragSurface !, []), Expression(null) {, [])]), Statement(}, []), AssignmentExpression(=, [VariableReference(mAttachInfo.mDragSurface, []), Expression(surface, [])]), AssignmentExpression(=, [VariableReference(mAttachInfo.mDragToken, []), Expression(token, [])]), Statement(// Cache the local state object for delivery with DragEvents, []), MethodCall(root.setLocalDragState(myLocalState), [VariableReference(root, []), Expression(myLocalState, [])]), Statement(}, []), AssignmentExpression(=, [VariableReference(return token !, []), Expression(null, [])]), Statement(} catch (Exception e) {, []), MethodCall(Log.e(VIEW_LOG_TAG, ""Unable to initiate drag"", e), [VariableReference(Log, []), Expression(VIEW_LOG_TAG, []), Expression(""Unable to initiate drag"", []), Expression(e, [])]), Statement(return false, []), Statement(} finally {, []), AssignmentExpression(=, [VariableReference(if (token, []), Expression(, [])]), MethodCall(surface.destroy(), [VariableReference(surface, []), Expression(, [])]), Statement(}, []), MethodCall(session.kill(), [VariableReference(session, []), Expression(, [])]), Statement(}, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(Log.d(VIEW_LOG_TAG, ""startDragAndDrop: data, []), Expression("" + data + "" flags, [])])    VariableReference(Log.d(VIEW_LOG_TAG, ""startDragAndDrop: data, [])    Expression("" + data + "" flags, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(if (mAttachInfo, []), Expression(, [])])    VariableReference(if (mAttachInfo, [])    Expression(, [])  MethodCall(Log.w(VIEW_LOG_TAG, ""startDragAndDrop called on a detached view.""), [VariableReference(Log, []), Expression(VIEW_LOG_TAG, []), Expression(""startDragAndDrop called on a detached view."", [])])    VariableReference(Log, [])    Expression(VIEW_LOG_TAG, [])    Expression(""startDragAndDrop called on a detached view."", [])  Statement(return false, [])  Statement(}, [])  MethodCall(Log.w(VIEW_LOG_TAG, ""startDragAndDrop called with an invalid surface.""), [VariableReference(Log, []), Expression(VIEW_LOG_TAG, []), Expression(""startDragAndDrop called with an invalid surface."", [])])    VariableReference(Log, [])    Expression(VIEW_LOG_TAG, [])    Expression(""startDragAndDrop called with an invalid surface."", [])  Statement(return false, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(if (data !, []), Expression(null) {, [])])    VariableReference(if (data !, [])    Expression(null) {, [])  AssignmentExpression(=, [VariableReference(data.prepareToLeaveProcess((flags & View.DRAG_FLAG_GLOBAL) !, []), Expression(0), [])])    VariableReference(data.prepareToLeaveProcess((flags & View.DRAG_FLAG_GLOBAL) !, [])    Expression(0), [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(Point shadowSize, []), Expression(new Point(), [])])    VariableReference(Point shadowSize, [])    Expression(new Point(), [])  AssignmentExpression(=, [VariableReference(Point shadowTouchPoint, []), Expression(new Point(), [])])    VariableReference(Point shadowTouchPoint, [])    Expression(new Point(), [])  MethodCall(shadowBuilder.onProvideShadowMetrics(shadowSize, shadowTouchPoint), [VariableReference(shadowBuilder, []), Expression(shadowSize, []), Expression(shadowTouchPoint, [])])    VariableReference(shadowBuilder, [])    Expression(shadowSize, [])    Expression(shadowTouchPoint, [])  Statement(throw new IllegalStateException(""Drag shadow dimensions must not be negative""), [])  Statement(}, [])  Statement(// does not accept zero size surface., [])  AssignmentExpression(=, [VariableReference(if (shadowSize.x, []), Expression(, [])])    VariableReference(if (shadowSize.x, [])    Expression(, [])  Statement(if (!sAcceptZeroSizeDragShadow) {, [])  Statement(throw new IllegalStateException(""Drag shadow dimensions must be positive""), [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(shadowSize.x, []), Expression(1, [])])    VariableReference(shadowSize.x, [])    Expression(1, [])  AssignmentExpression(=, [VariableReference(shadowSize.y, []), Expression(1, [])])    VariableReference(shadowSize.y, [])    Expression(1, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(Log.d(VIEW_LOG_TAG, ""drag shadow: width, []), Expression("" + shadowSize.x + "" height, [])])    VariableReference(Log.d(VIEW_LOG_TAG, ""drag shadow: width, [])    Expression("" + shadowSize.x + "" height, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(final ViewRootImpl root, []), Expression(mAttachInfo.mViewRootImpl, [])])    VariableReference(final ViewRootImpl root, [])    Expression(mAttachInfo.mViewRootImpl, [])  AssignmentExpression(=, [VariableReference(final SurfaceSession session, []), Expression(new SurfaceSession(), [])])    VariableReference(final SurfaceSession session, [])    Expression(new SurfaceSession(), [])  AssignmentExpression(=, [VariableReference(final SurfaceControl surfaceControl, []), Expression(new SurfaceControl.Builder(session).setName(""drag surface"").setParent(root.getSurfaceControl()).setBufferSize(shadowSize.x, shadowSize.y).setFormat(PixelFormat.TRANSLUCENT).setCallsite(""View.startDragAndDrop"").build(), [])])    VariableReference(final SurfaceControl surfaceControl, [])    Expression(new SurfaceControl.Builder(session).setName(""drag surface"").setParent(root.getSurfaceControl()).setBufferSize(shadowSize.x, shadowSize.y).setFormat(PixelFormat.TRANSLUCENT).setCallsite(""View.startDragAndDrop"").build(), [])  AssignmentExpression(=, [VariableReference(final Surface surface, []), Expression(new Surface(), [])])    VariableReference(final Surface surface, [])    Expression(new Surface(), [])  MethodCall(surface.copyFrom(surfaceControl), [VariableReference(surface, []), Expression(surfaceControl, [])])    VariableReference(surface, [])    Expression(surfaceControl, [])  AssignmentExpression(=, [VariableReference(IBinder token, []), Expression(null, [])])    VariableReference(IBinder token, [])    Expression(null, [])  Statement(try {, [])  AssignmentExpression(=, [VariableReference(final Canvas canvas, []), Expression(isHardwareAccelerated() ? surface.lockHardwareCanvas() : surface.lockCanvas(null), [])])    VariableReference(final Canvas canvas, [])    Expression(isHardwareAccelerated() ? surface.lockHardwareCanvas() : surface.lockCanvas(null), [])  Statement(try {, [])  MethodCall(canvas.drawColor(0, PorterDuff.Mode.CLEAR), [VariableReference(canvas, []), Expression(0, []), Expression(PorterDuff.Mode.CLEAR, [])])    VariableReference(canvas, [])    Expression(0, [])    Expression(PorterDuff.Mode.CLEAR, [])  MethodCall(shadowBuilder.onDrawShadow(canvas), [VariableReference(shadowBuilder, []), Expression(canvas, [])])    VariableReference(shadowBuilder, [])    Expression(canvas, [])  Statement(} finally {, [])  MethodCall(surface.unlockCanvasAndPost(canvas), [VariableReference(surface, []), Expression(canvas, [])])    VariableReference(surface, [])    Expression(canvas, [])  Statement(}, [])  Statement(// repurpose 'shadowSize' for the last touch point, [])  MethodCall(root.getLastTouchPoint(shadowSize), [VariableReference(root, []), Expression(shadowSize, [])])    VariableReference(root, [])    Expression(shadowSize, [])  AssignmentExpression(=, [VariableReference(token, []), Expression(mAttachInfo.mSession.performDrag(mAttachInfo.mWindow, flags, surfaceControl, root.getLastTouchSource(), shadowSize.x, shadowSize.y, shadowTouchPoint.x, shadowTouchPoint.y, data), [])])    VariableReference(token, [])    Expression(mAttachInfo.mSession.performDrag(mAttachInfo.mWindow, flags, surfaceControl, root.getLastTouchSource(), shadowSize.x, shadowSize.y, shadowTouchPoint.x, shadowTouchPoint.y, data), [])  MethodCall(Log.d(VIEW_LOG_TAG, ""performDrag returned "" + token), [VariableReference(Log, []), Expression(VIEW_LOG_TAG, []), Expression(""performDrag returned "" + token, [])])    VariableReference(Log, [])    Expression(VIEW_LOG_TAG, [])    Expression(""performDrag returned "" + token, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(if (token !, []), Expression(null) {, [])])    VariableReference(if (token !, [])    Expression(null) {, [])  AssignmentExpression(=, [VariableReference(if (mAttachInfo.mDragSurface !, []), Expression(null) {, [])])    VariableReference(if (mAttachInfo.mDragSurface !, [])    Expression(null) {, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(mAttachInfo.mDragSurface, []), Expression(surface, [])])    VariableReference(mAttachInfo.mDragSurface, [])    Expression(surface, [])  AssignmentExpression(=, [VariableReference(mAttachInfo.mDragToken, []), Expression(token, [])])    VariableReference(mAttachInfo.mDragToken, [])    Expression(token, [])  Statement(// Cache the local state object for delivery with DragEvents, [])  MethodCall(root.setLocalDragState(myLocalState), [VariableReference(root, []), Expression(myLocalState, [])])    VariableReference(root, [])    Expression(myLocalState, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(return token !, []), Expression(null, [])])    VariableReference(return token !, [])    Expression(null, [])  Statement(} catch (Exception e) {, [])  MethodCall(Log.e(VIEW_LOG_TAG, ""Unable to initiate drag"", e), [VariableReference(Log, []), Expression(VIEW_LOG_TAG, []), Expression(""Unable to initiate drag"", []), Expression(e, [])])    VariableReference(Log, [])    Expression(VIEW_LOG_TAG, [])    Expression(""Unable to initiate drag"", [])    Expression(e, [])  Statement(return false, [])  Statement(} finally {, [])  AssignmentExpression(=, [VariableReference(if (token, []), Expression(, [])])    VariableReference(if (token, [])    Expression(, [])  MethodCall(surface.destroy(), [VariableReference(surface, []), Expression(, [])])    VariableReference(surface, [])    Expression(, [])  Statement(}, [])  MethodCall(session.kill(), [VariableReference(session, []), Expression(, [])])    VariableReference(session, [])    Expression(, [])  Statement(}, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(Log.d(VIEW_LOG_TAG, ""startDragAndDrop: data, []), Expression("" + data + "" flags, [])]), Statement(}, []), AssignmentExpression(=, [VariableReference(if (mAttachInfo, []), Expression(, [])]), MethodCall(Log.w(VIEW_LOG_TAG, ""startDragAndDrop called on a detached view.""), [VariableReference(Log, []), Expression(VIEW_LOG_TAG, []), Expression(""startDragAndDrop called on a detached view."", [])]), Statement(return false, []), Statement(}, []), MethodCall(Log.w(VIEW_LOG_TAG, ""startDragAndDrop called with an invalid surface.""), [VariableReference(Log, []), Expression(VIEW_LOG_TAG, []), Expression(""startDragAndDrop called with an invalid surface."", [])]), Statement(return false, []), Statement(}, []), AssignmentExpression(=, [VariableReference(if (data !, []), Expression(null) {, [])]), AssignmentExpression(=, [VariableReference(data.prepareToLeaveProcess((flags & View.DRAG_FLAG_GLOBAL) !, []), Expression(0), [])]), Statement(}, []), AssignmentExpression(=, [VariableReference(Rect bounds, []), Expression(new Rect(), [])]), Statement(getBoundsOnScreen(bounds, true), []), AssignmentExpression(=, [VariableReference(Point lastTouchPoint, []), Expression(new Point(), [])]), AssignmentExpression(=, [VariableReference(final ViewRootImpl root, []), Expression(mAttachInfo.mViewRootImpl, [])]), Statement(// Skip surface logic since shadows and animation are not required during the a11y drag, []), AssignmentExpression(=, [VariableReference(final boolean a11yEnabled, []), Expression(AccessibilityManager.getInstance(mContext).isEnabled(), [])]), AssignmentExpression(=, [VariableReference(if (a11yEnabled && (flags & View.DRAG_FLAG_ACCESSIBILITY_ACTION) !, []), Expression(0) {, [])]), Statement(try {, []), AssignmentExpression(=, [VariableReference(IBinder token, []), Expression(mAttachInfo.mSession.performDrag(mAttachInfo.mWindow, flags, null, mAttachInfo.mViewRootImpl.getLastTouchSource(), 0f, 0f, 0f, 0f, data), [])]), MethodCall(Log.d(VIEW_LOG_TAG, ""startDragAndDrop via a11y action returned "" + token), [VariableReference(Log, []), Expression(VIEW_LOG_TAG, []), Expression(""startDragAndDrop via a11y action returned "" + token, [])]), Statement(}, []), AssignmentExpression(=, [VariableReference(if (token !, []), Expression(null) {, [])]), MethodCall(root.setLocalDragState(myLocalState), [VariableReference(root, []), Expression(myLocalState, [])]), AssignmentExpression(=, [VariableReference(mAttachInfo.mDragToken, []), Expression(token, [])]), Statement(setAccessibilityDragStarted(true), []), Statement(}, []), AssignmentExpression(=, [VariableReference(return token !, []), Expression(null, [])]), Statement(} catch (Exception e) {, []), MethodCall(Log.e(VIEW_LOG_TAG, ""Unable to initiate a11y drag"", e), [VariableReference(Log, []), Expression(VIEW_LOG_TAG, []), Expression(""Unable to initiate a11y drag"", []), Expression(e, [])]), Statement(return false, []), Statement(}, []), Statement(}, []), AssignmentExpression(=, [VariableReference(Point shadowSize, []), Expression(new Point(), [])]), AssignmentExpression(=, [VariableReference(Point shadowTouchPoint, []), Expression(new Point(), [])]), MethodCall(shadowBuilder.onProvideShadowMetrics(shadowSize, shadowTouchPoint), [VariableReference(shadowBuilder, []), Expression(shadowSize, []), Expression(shadowTouchPoint, [])]), Statement(throw new IllegalStateException(""Drag shadow dimensions must not be negative""), []), Statement(}, []), Statement(// does not accept zero size surface., []), AssignmentExpression(=, [VariableReference(if (shadowSize.x, []), Expression(, [])]), Statement(if (!sAcceptZeroSizeDragShadow) {, []), Statement(throw new IllegalStateException(""Drag shadow dimensions must be positive""), []), Statement(}, []), AssignmentExpression(=, [VariableReference(shadowSize.x, []), Expression(1, [])]), AssignmentExpression(=, [VariableReference(shadowSize.y, []), Expression(1, [])]), Statement(}, []), AssignmentExpression(=, [VariableReference(Log.d(VIEW_LOG_TAG, ""drag shadow: width, []), Expression("" + shadowSize.x + "" height, [])]), Statement(}, []), AssignmentExpression(=, [VariableReference(final SurfaceSession session, []), Expression(new SurfaceSession(), [])]), AssignmentExpression(=, [VariableReference(final SurfaceControl surfaceControl, []), Expression(new SurfaceControl.Builder(session).setName(""drag surface"").setParent(root.getSurfaceControl()).setBufferSize(shadowSize.x, shadowSize.y).setFormat(PixelFormat.TRANSLUCENT).setCallsite(""View.startDragAndDrop"").build(), [])]), AssignmentExpression(=, [VariableReference(final Surface surface, []), Expression(new Surface(), [])]), MethodCall(surface.copyFrom(surfaceControl), [VariableReference(surface, []), Expression(surfaceControl, [])]), AssignmentExpression(=, [VariableReference(IBinder token, []), Expression(null, [])]), Statement(try {, []), AssignmentExpression(=, [VariableReference(final Canvas canvas, []), Expression(isHardwareAccelerated() ? surface.lockHardwareCanvas() : surface.lockCanvas(null), [])]), Statement(try {, []), MethodCall(canvas.drawColor(0, PorterDuff.Mode.CLEAR), [VariableReference(canvas, []), Expression(0, []), Expression(PorterDuff.Mode.CLEAR, [])]), MethodCall(shadowBuilder.onDrawShadow(canvas), [VariableReference(shadowBuilder, []), Expression(canvas, [])]), Statement(} finally {, []), MethodCall(surface.unlockCanvasAndPost(canvas), [VariableReference(surface, []), Expression(canvas, [])]), Statement(}, []), AssignmentExpression(=, [VariableReference(token, []), Expression(mAttachInfo.mSession.performDrag(mAttachInfo.mWindow, flags, surfaceControl, root.getLastTouchSource(), lastTouchPoint.x, lastTouchPoint.y, shadowTouchPoint.x, shadowTouchPoint.y, data), [])]), MethodCall(Log.d(VIEW_LOG_TAG, ""performDrag returned "" + token), [VariableReference(Log, []), Expression(VIEW_LOG_TAG, []), Expression(""performDrag returned "" + token, [])]), Statement(}, []), AssignmentExpression(=, [VariableReference(if (token !, []), Expression(null) {, [])]), AssignmentExpression(=, [VariableReference(if (mAttachInfo.mDragSurface !, []), Expression(null) {, [])]), Statement(}, []), AssignmentExpression(=, [VariableReference(mAttachInfo.mDragSurface, []), Expression(surface, [])]), AssignmentExpression(=, [VariableReference(mAttachInfo.mDragToken, []), Expression(token, [])]), Statement(// Cache the local state object for delivery with DragEvents, []), MethodCall(root.setLocalDragState(myLocalState), [VariableReference(root, []), Expression(myLocalState, [])]), Statement(if (a11yEnabled) {, []), Statement(// Set for AccessibilityEvents, []), Statement(}, []), Statement(}, []), AssignmentExpression(=, [VariableReference(return token !, []), Expression(null, [])]), Statement(} catch (Exception e) {, []), MethodCall(Log.e(VIEW_LOG_TAG, ""Unable to initiate drag"", e), [VariableReference(Log, []), Expression(VIEW_LOG_TAG, []), Expression(""Unable to initiate drag"", []), Expression(e, [])]), Statement(return false, []), Statement(} finally {, []), AssignmentExpression(=, [VariableReference(if (token, []), Expression(, [])]), MethodCall(surface.destroy(), [VariableReference(surface, []), Expression(, [])]), Statement(}, []), MethodCall(session.kill(), [VariableReference(session, []), Expression(, [])]), Statement(}, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(Log.d(VIEW_LOG_TAG, ""startDragAndDrop: data, []), Expression("" + data + "" flags, [])])    VariableReference(Log.d(VIEW_LOG_TAG, ""startDragAndDrop: data, [])    Expression("" + data + "" flags, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(if (mAttachInfo, []), Expression(, [])])    VariableReference(if (mAttachInfo, [])    Expression(, [])  MethodCall(Log.w(VIEW_LOG_TAG, ""startDragAndDrop called on a detached view.""), [VariableReference(Log, []), Expression(VIEW_LOG_TAG, []), Expression(""startDragAndDrop called on a detached view."", [])])    VariableReference(Log, [])    Expression(VIEW_LOG_TAG, [])    Expression(""startDragAndDrop called on a detached view."", [])  Statement(return false, [])  Statement(}, [])  MethodCall(Log.w(VIEW_LOG_TAG, ""startDragAndDrop called with an invalid surface.""), [VariableReference(Log, []), Expression(VIEW_LOG_TAG, []), Expression(""startDragAndDrop called with an invalid surface."", [])])    VariableReference(Log, [])    Expression(VIEW_LOG_TAG, [])    Expression(""startDragAndDrop called with an invalid surface."", [])  Statement(return false, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(if (data !, []), Expression(null) {, [])])    VariableReference(if (data !, [])    Expression(null) {, [])  AssignmentExpression(=, [VariableReference(data.prepareToLeaveProcess((flags & View.DRAG_FLAG_GLOBAL) !, []), Expression(0), [])])    VariableReference(data.prepareToLeaveProcess((flags & View.DRAG_FLAG_GLOBAL) !, [])    Expression(0), [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(Rect bounds, []), Expression(new Rect(), [])])    VariableReference(Rect bounds, [])    Expression(new Rect(), [])  Statement(getBoundsOnScreen(bounds, true), [])  AssignmentExpression(=, [VariableReference(Point lastTouchPoint, []), Expression(new Point(), [])])    VariableReference(Point lastTouchPoint, [])    Expression(new Point(), [])  AssignmentExpression(=, [VariableReference(final ViewRootImpl root, []), Expression(mAttachInfo.mViewRootImpl, [])])    VariableReference(final ViewRootImpl root, [])    Expression(mAttachInfo.mViewRootImpl, [])  Statement(// Skip surface logic since shadows and animation are not required during the a11y drag, [])  AssignmentExpression(=, [VariableReference(final boolean a11yEnabled, []), Expression(AccessibilityManager.getInstance(mContext).isEnabled(), [])])    VariableReference(final boolean a11yEnabled, [])    Expression(AccessibilityManager.getInstance(mContext).isEnabled(), [])  AssignmentExpression(=, [VariableReference(if (a11yEnabled && (flags & View.DRAG_FLAG_ACCESSIBILITY_ACTION) !, []), Expression(0) {, [])])    VariableReference(if (a11yEnabled && (flags & View.DRAG_FLAG_ACCESSIBILITY_ACTION) !, [])    Expression(0) {, [])  Statement(try {, [])  AssignmentExpression(=, [VariableReference(IBinder token, []), Expression(mAttachInfo.mSession.performDrag(mAttachInfo.mWindow, flags, null, mAttachInfo.mViewRootImpl.getLastTouchSource(), 0f, 0f, 0f, 0f, data), [])])    VariableReference(IBinder token, [])    Expression(mAttachInfo.mSession.performDrag(mAttachInfo.mWindow, flags, null, mAttachInfo.mViewRootImpl.getLastTouchSource(), 0f, 0f, 0f, 0f, data), [])  MethodCall(Log.d(VIEW_LOG_TAG, ""startDragAndDrop via a11y action returned "" + token), [VariableReference(Log, []), Expression(VIEW_LOG_TAG, []), Expression(""startDragAndDrop via a11y action returned "" + token, [])])    VariableReference(Log, [])    Expression(VIEW_LOG_TAG, [])    Expression(""startDragAndDrop via a11y action returned "" + token, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(if (token !, []), Expression(null) {, [])])    VariableReference(if (token !, [])    Expression(null) {, [])  MethodCall(root.setLocalDragState(myLocalState), [VariableReference(root, []), Expression(myLocalState, [])])    VariableReference(root, [])    Expression(myLocalState, [])  AssignmentExpression(=, [VariableReference(mAttachInfo.mDragToken, []), Expression(token, [])])    VariableReference(mAttachInfo.mDragToken, [])    Expression(token, [])  Statement(setAccessibilityDragStarted(true), [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(return token !, []), Expression(null, [])])    VariableReference(return token !, [])    Expression(null, [])  Statement(} catch (Exception e) {, [])  MethodCall(Log.e(VIEW_LOG_TAG, ""Unable to initiate a11y drag"", e), [VariableReference(Log, []), Expression(VIEW_LOG_TAG, []), Expression(""Unable to initiate a11y drag"", []), Expression(e, [])])    VariableReference(Log, [])    Expression(VIEW_LOG_TAG, [])    Expression(""Unable to initiate a11y drag"", [])    Expression(e, [])  Statement(return false, [])  Statement(}, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(Point shadowSize, []), Expression(new Point(), [])])    VariableReference(Point shadowSize, [])    Expression(new Point(), [])  AssignmentExpression(=, [VariableReference(Point shadowTouchPoint, []), Expression(new Point(), [])])    VariableReference(Point shadowTouchPoint, [])    Expression(new Point(), [])  MethodCall(shadowBuilder.onProvideShadowMetrics(shadowSize, shadowTouchPoint), [VariableReference(shadowBuilder, []), Expression(shadowSize, []), Expression(shadowTouchPoint, [])])    VariableReference(shadowBuilder, [])    Expression(shadowSize, [])    Expression(shadowTouchPoint, [])  Statement(throw new IllegalStateException(""Drag shadow dimensions must not be negative""), [])  Statement(}, [])  Statement(// does not accept zero size surface., [])  AssignmentExpression(=, [VariableReference(if (shadowSize.x, []), Expression(, [])])    VariableReference(if (shadowSize.x, [])    Expression(, [])  Statement(if (!sAcceptZeroSizeDragShadow) {, [])  Statement(throw new IllegalStateException(""Drag shadow dimensions must be positive""), [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(shadowSize.x, []), Expression(1, [])])    VariableReference(shadowSize.x, [])    Expression(1, [])  AssignmentExpression(=, [VariableReference(shadowSize.y, []), Expression(1, [])])    VariableReference(shadowSize.y, [])    Expression(1, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(Log.d(VIEW_LOG_TAG, ""drag shadow: width, []), Expression("" + shadowSize.x + "" height, [])])    VariableReference(Log.d(VIEW_LOG_TAG, ""drag shadow: width, [])    Expression("" + shadowSize.x + "" height, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(final SurfaceSession session, []), Expression(new SurfaceSession(), [])])    VariableReference(final SurfaceSession session, [])    Expression(new SurfaceSession(), [])  AssignmentExpression(=, [VariableReference(final SurfaceControl surfaceControl, []), Expression(new SurfaceControl.Builder(session).setName(""drag surface"").setParent(root.getSurfaceControl()).setBufferSize(shadowSize.x, shadowSize.y).setFormat(PixelFormat.TRANSLUCENT).setCallsite(""View.startDragAndDrop"").build(), [])])    VariableReference(final SurfaceControl surfaceControl, [])    Expression(new SurfaceControl.Builder(session).setName(""drag surface"").setParent(root.getSurfaceControl()).setBufferSize(shadowSize.x, shadowSize.y).setFormat(PixelFormat.TRANSLUCENT).setCallsite(""View.startDragAndDrop"").build(), [])  AssignmentExpression(=, [VariableReference(final Surface surface, []), Expression(new Surface(), [])])    VariableReference(final Surface surface, [])    Expression(new Surface(), [])  MethodCall(surface.copyFrom(surfaceControl), [VariableReference(surface, []), Expression(surfaceControl, [])])    VariableReference(surface, [])    Expression(surfaceControl, [])  AssignmentExpression(=, [VariableReference(IBinder token, []), Expression(null, [])])    VariableReference(IBinder token, [])    Expression(null, [])  Statement(try {, [])  AssignmentExpression(=, [VariableReference(final Canvas canvas, []), Expression(isHardwareAccelerated() ? surface.lockHardwareCanvas() : surface.lockCanvas(null), [])])    VariableReference(final Canvas canvas, [])    Expression(isHardwareAccelerated() ? surface.lockHardwareCanvas() : surface.lockCanvas(null), [])  Statement(try {, [])  MethodCall(canvas.drawColor(0, PorterDuff.Mode.CLEAR), [VariableReference(canvas, []), Expression(0, []), Expression(PorterDuff.Mode.CLEAR, [])])    VariableReference(canvas, [])    Expression(0, [])    Expression(PorterDuff.Mode.CLEAR, [])  MethodCall(shadowBuilder.onDrawShadow(canvas), [VariableReference(shadowBuilder, []), Expression(canvas, [])])    VariableReference(shadowBuilder, [])    Expression(canvas, [])  Statement(} finally {, [])  MethodCall(surface.unlockCanvasAndPost(canvas), [VariableReference(surface, []), Expression(canvas, [])])    VariableReference(surface, [])    Expression(canvas, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(token, []), Expression(mAttachInfo.mSession.performDrag(mAttachInfo.mWindow, flags, surfaceControl, root.getLastTouchSource(), lastTouchPoint.x, lastTouchPoint.y, shadowTouchPoint.x, shadowTouchPoint.y, data), [])])    VariableReference(token, [])    Expression(mAttachInfo.mSession.performDrag(mAttachInfo.mWindow, flags, surfaceControl, root.getLastTouchSource(), lastTouchPoint.x, lastTouchPoint.y, shadowTouchPoint.x, shadowTouchPoint.y, data), [])  MethodCall(Log.d(VIEW_LOG_TAG, ""performDrag returned "" + token), [VariableReference(Log, []), Expression(VIEW_LOG_TAG, []), Expression(""performDrag returned "" + token, [])])    VariableReference(Log, [])    Expression(VIEW_LOG_TAG, [])    Expression(""performDrag returned "" + token, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(if (token !, []), Expression(null) {, [])])    VariableReference(if (token !, [])    Expression(null) {, [])  AssignmentExpression(=, [VariableReference(if (mAttachInfo.mDragSurface !, []), Expression(null) {, [])])    VariableReference(if (mAttachInfo.mDragSurface !, [])    Expression(null) {, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(mAttachInfo.mDragSurface, []), Expression(surface, [])])    VariableReference(mAttachInfo.mDragSurface, [])    Expression(surface, [])  AssignmentExpression(=, [VariableReference(mAttachInfo.mDragToken, []), Expression(token, [])])    VariableReference(mAttachInfo.mDragToken, [])    Expression(token, [])  Statement(// Cache the local state object for delivery with DragEvents, [])  MethodCall(root.setLocalDragState(myLocalState), [VariableReference(root, []), Expression(myLocalState, [])])    VariableReference(root, [])    Expression(myLocalState, [])  Statement(if (a11yEnabled) {, [])  Statement(// Set for AccessibilityEvents, [])  Statement(}, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(return token !, []), Expression(null, [])])    VariableReference(return token !, [])    Expression(null, [])  Statement(} catch (Exception e) {, [])  MethodCall(Log.e(VIEW_LOG_TAG, ""Unable to initiate drag"", e), [VariableReference(Log, []), Expression(VIEW_LOG_TAG, []), Expression(""Unable to initiate drag"", []), Expression(e, [])])    VariableReference(Log, [])    Expression(VIEW_LOG_TAG, [])    Expression(""Unable to initiate drag"", [])    Expression(e, [])  Statement(return false, [])  Statement(} finally {, [])  AssignmentExpression(=, [VariableReference(if (token, []), Expression(, [])])    VariableReference(if (token, [])    Expression(, [])  MethodCall(surface.destroy(), [VariableReference(surface, []), Expression(, [])])    VariableReference(surface, [])    Expression(, [])  Statement(}, [])  MethodCall(session.kill(), [VariableReference(session, []), Expression(, [])])    VariableReference(session, [])    Expression(, [])  Statement(}, [])  Statement(}, [])",1,"/**
 * Starts a drag and drop operation. When your application calls this method, it passes a
 * {@link android.view.View.DragShadowBuilder} object to the system. The
 * system calls this object's {@link DragShadowBuilder#onProvideShadowMetrics(Point, Point)}
 * to get metrics for the drag shadow, and then calls the object's
 * {@link DragShadowBuilder#onDrawShadow(Canvas)} to draw the drag shadow itself.
 * <p>
 * Once the system has the drag shadow, it begins the drag and drop operation by sending
 * drag events to all the View objects in your application that are currently visible. It does
 * this either by calling the View object's drag listener (an implementation of
 * {@link android.view.View.OnDragListener#onDrag(View,DragEvent) onDrag()} or by calling the
 * View object's {@link android.view.View#onDragEvent(DragEvent) onDragEvent()} method.
 * Both are passed a {@link android.view.DragEvent} object that has a
 * {@link android.view.DragEvent#getAction()} value of
 * {@link android.view.DragEvent#ACTION_DRAG_STARTED}.
 * </p>
 * <p>
 * Your application can invoke {@link #startDragAndDrop(ClipData, DragShadowBuilder, Object,
 * int) startDragAndDrop()} on any attached View object. The View object does not need to be
 * the one used in {@link android.view.View.DragShadowBuilder}, nor does it need to be related
 * to the View the user selected for dragging.
 * </p>
 * @param data A {@link android.content.ClipData} object pointing to the data to be
 * transferred by the drag and drop operation.
 * @param shadowBuilder A {@link android.view.View.DragShadowBuilder} object for building the
 * drag shadow.
 * @param myLocalState An {@link java.lang.Object} containing local data about the drag and
 * drop operation. When dispatching drag events to views in the same activity this object
 * will be available through {@link android.view.DragEvent#getLocalState()}. Views in other
 * activities will not have access to this data ({@link android.view.DragEvent#getLocalState()}
 * will return null).
 * <p>
 * myLocalState is a lightweight mechanism for the sending information from the dragged View
 * to the target Views. For example, it can contain flags that differentiate between a
 * a copy operation and a move operation.
 * </p>
 * @param flags Flags that control the drag and drop operation. This can be set to 0 for no
 * flags, or any combination of the following:
 * <ul>
 * <li>{@link #DRAG_FLAG_GLOBAL}</li>
 * <li>{@link #DRAG_FLAG_GLOBAL_PERSISTABLE_URI_PERMISSION}</li>
 * <li>{@link #DRAG_FLAG_GLOBAL_PREFIX_URI_PERMISSION}</li>
 * <li>{@link #DRAG_FLAG_GLOBAL_URI_READ}</li>
 * <li>{@link #DRAG_FLAG_GLOBAL_URI_WRITE}</li>
 * <li>{@link #DRAG_FLAG_OPAQUE}</li>
 * </ul>
 * @return {@code true} if the method completes successfully, or
 * {@code false} if it fails anywhere. Returning {@code false} means the system was unable to
 * do a drag because of another ongoing operation or some other reasons.
 */
","/**
 * Starts a drag and drop operation. When your application calls this method, it passes a
 * {@link android.view.View.DragShadowBuilder} object to the system. The
 * system calls this object's {@link DragShadowBuilder#onProvideShadowMetrics(Point, Point)}
 * to get metrics for the drag shadow, and then calls the object's
 * {@link DragShadowBuilder#onDrawShadow(Canvas)} to draw the drag shadow itself.
 * <p>
 * Once the system has the drag shadow, it begins the drag and drop operation by sending
 * drag events to all the View objects in your application that are currently visible. It does
 * this either by calling the View object's drag listener (an implementation of
 * {@link android.view.View.OnDragListener#onDrag(View,DragEvent) onDrag()} or by calling the
 * View object's {@link android.view.View#onDragEvent(DragEvent) onDragEvent()} method.
 * Both are passed a {@link android.view.DragEvent} object that has a
 * {@link android.view.DragEvent#getAction()} value of
 * {@link android.view.DragEvent#ACTION_DRAG_STARTED}.
 * </p>
 * <p>
 * Your application can invoke {@link #startDragAndDrop(ClipData, DragShadowBuilder, Object,
 * int) startDragAndDrop()} on any attached View object. The View object does not need to be
 * the one used in {@link android.view.View.DragShadowBuilder}, nor does it need to be related
 * to the View the user selected for dragging.
 * </p>
 * @param data A {@link android.content.ClipData} object pointing to the data to be
 * transferred by the drag and drop operation.
 * @param shadowBuilder A {@link android.view.View.DragShadowBuilder} object for building the
 * drag shadow.
 * @param myLocalState An {@link java.lang.Object} containing local data about the drag and
 * drop operation. When dispatching drag events to views in the same activity this object
 * will be available through {@link android.view.DragEvent#getLocalState()}. Views in other
 * activities will not have access to this data ({@link android.view.DragEvent#getLocalState()}
 * will return null).
 * <p>
 * myLocalState is a lightweight mechanism for the sending information from the dragged View
 * to the target Views. For example, it can contain flags that differentiate between a
 * a copy operation and a move operation.
 * </p>
 * @param flags Flags that control the drag and drop operation. This can be set to 0 for no
 * flags, or any combination of the following:
 * <ul>
 * <li>{@link #DRAG_FLAG_GLOBAL}</li>
 * <li>{@link #DRAG_FLAG_GLOBAL_PERSISTABLE_URI_PERMISSION}</li>
 * <li>{@link #DRAG_FLAG_GLOBAL_PREFIX_URI_PERMISSION}</li>
 * <li>{@link #DRAG_FLAG_GLOBAL_URI_READ}</li>
 * <li>{@link #DRAG_FLAG_GLOBAL_URI_WRITE}</li>
 * <li>{@link #DRAG_FLAG_OPAQUE}</li>
 * <li>{@link #DRAG_FLAG_ACCESSIBILITY_ACTION}</li>
 * </ul>
 * @return {@code true} if the method completes successfully, or
 * {@code false} if it fails anywhere. Returning {@code false} means the system was unable to
 * do a drag because of another ongoing operation or some other reasons.
 */
",1,,,0,,,,"1,2","1,2,3,4,5","1,2","3,2",2,"The control dependency has changed with the introduction of checks for `AccessibilityManager` and `a11yEnabled` conditions in the later version. This introduces a new flow in the code, and it also introduces new exception handling specific to accessibility drag (Invalid shadow size and exceptions related to performDrag). Thus, the code change type is 3,2.","The introduction of new control flows and exception handling means that there could be different exception handling in different scenarios. This makes the API handle exceptions differently in the new version, thus the CI type is 2."
24,"<android.content.Context: int[] checkUriPermissions(List<Uri>,int,int,int)>",31,32,,,,"MethodDeclaration(method_body, [Statement({, []), Statement(}, [])])  Statement({, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(}, [])])  Statement({, [])  Statement(}, [])",0,"/**
 * Determine whether a particular process and user ID has been granted
 * permission to access a list of URIs.  This only checks for permissions
 * that have been explicitly granted -- if the given process/uid has
 * more general access to the URI's content provider then this check will
 * always fail.
 *
 * @param uris The list of URIs that is being checked.
 * @param pid The process ID being checked against.  Must be &gt; 0.
 * @param uid The user ID being checked against.  A uid of 0 is the root
 * user, which will pass every permission check.
 * @param modeFlags The access modes to check for the list of uris
 *
 * @return Array of permission grants corresponding to each entry in the list of uris.
 * {@link PackageManager#PERMISSION_GRANTED} if the given pid/uid is allowed to access that uri,
 * or {@link PackageManager#PERMISSION_DENIED} if it is not.
 *
 * @see #checkCallingUriPermission
 */
","/**
 * Determine whether a particular process and user ID has been granted
 * permission to access a list of URIs.  This only checks for permissions
 * that have been explicitly granted -- if the given process/uid has
 * more general access to the URI's content provider then this check will
 * always fail.
 *
 * <strong>Note:</strong> On SDK Version {@link android.os.Build.VERSION_CODES#S},
 * calling this method from a secondary-user's context will incorrectly return
 * {@link PackageManager#PERMISSION_DENIED} for all {code uris}.
 *
 * @param uris The list of URIs that is being checked.
 * @param pid The process ID being checked against.  Must be &gt; 0.
 * @param uid The user ID being checked against.  A uid of 0 is the root
 * user, which will pass every permission check.
 * @param modeFlags The access modes to check for the list of uris
 *
 * @return Array of permission grants corresponding to each entry in the list of uris.
 * {@link PackageManager#PERMISSION_GRANTED} if the given pid/uid is allowed to access that uri,
 * or {@link PackageManager#PERMISSION_DENIED} if it is not.
 *
 * @see #checkCallingUriPermission
 */
",1,"[@NonNull, @PackageManager.PermissionResult]","[@NonNull, @PackageManager.PermissionResult]",0,,,,0,0,0,0,0,"The AST nodes for the early and late implementations show no changes, as both are essentially empty, and the annotations remain the same. ","Since there is no change in the method implementation, signatures, or annotations, there are no potential compatibility issues. Therefore, the CI type is 0."
25,<android.content.res.TypedArray: ColorStateList getColorStateList(int)>,32,33,,,,"MethodDeclaration(method_body, [Statement({, []), Statement(if (mRecycled) {, []), Statement(throw new RuntimeException(""Cannot make calls to a recycled instance!""), []), Statement(}, []), AssignmentExpression(=, [VariableReference(final TypedValue value, []), Expression(mValue, [])]), Statement(if (getValueAt(index * STYLE_NUM_ENTRIES, value)) {, []), AssignmentExpression(=, [VariableReference(if (value.type, []), Expression(, [])]), Statement(throw new UnsupportedOperationException(""Failed to resolve attribute at index "" + index + "": "" + value), []), Statement(}, []), MethodCall(return mResources.loadColorStateList(value, value.resourceId, mTheme), [VariableReference(return mResources, []), Expression(value, []), Expression(value.resourceId, []), Expression(mTheme, [])]), Statement(}, []), Statement(return null, []), Statement(}, [])])  Statement({, [])  Statement(if (mRecycled) {, [])  Statement(throw new RuntimeException(""Cannot make calls to a recycled instance!""), [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(final TypedValue value, []), Expression(mValue, [])])    VariableReference(final TypedValue value, [])    Expression(mValue, [])  Statement(if (getValueAt(index * STYLE_NUM_ENTRIES, value)) {, [])  AssignmentExpression(=, [VariableReference(if (value.type, []), Expression(, [])])    VariableReference(if (value.type, [])    Expression(, [])  Statement(throw new UnsupportedOperationException(""Failed to resolve attribute at index "" + index + "": "" + value), [])  Statement(}, [])  MethodCall(return mResources.loadColorStateList(value, value.resourceId, mTheme), [VariableReference(return mResources, []), Expression(value, []), Expression(value.resourceId, []), Expression(mTheme, [])])    VariableReference(return mResources, [])    Expression(value, [])    Expression(value.resourceId, [])    Expression(mTheme, [])  Statement(}, [])  Statement(return null, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(if (mRecycled) {, []), Statement(throw new RuntimeException(""Cannot make calls to a recycled instance!""), []), Statement(}, []), AssignmentExpression(=, [VariableReference(final TypedValue value, []), Expression(mValue, [])]), Statement(if (getValueAt(index * STYLE_NUM_ENTRIES, value)) {, []), AssignmentExpression(=, [VariableReference(if (value.type, []), Expression(, [])]), AssignmentExpression(=, [VariableReference(throw new UnsupportedOperationException(""Failed to resolve attribute at index "" + index + "": "" + value + "", theme, []), Expression("" + mTheme), [])]), Statement(}, []), MethodCall(return mResources.loadColorStateList(value, value.resourceId, mTheme), [VariableReference(return mResources, []), Expression(value, []), Expression(value.resourceId, []), Expression(mTheme, [])]), Statement(}, []), Statement(return null, []), Statement(}, [])])  Statement({, [])  Statement(if (mRecycled) {, [])  Statement(throw new RuntimeException(""Cannot make calls to a recycled instance!""), [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(final TypedValue value, []), Expression(mValue, [])])    VariableReference(final TypedValue value, [])    Expression(mValue, [])  Statement(if (getValueAt(index * STYLE_NUM_ENTRIES, value)) {, [])  AssignmentExpression(=, [VariableReference(if (value.type, []), Expression(, [])])    VariableReference(if (value.type, [])    Expression(, [])  AssignmentExpression(=, [VariableReference(throw new UnsupportedOperationException(""Failed to resolve attribute at index "" + index + "": "" + value + "", theme, []), Expression("" + mTheme), [])])    VariableReference(throw new UnsupportedOperationException(""Failed to resolve attribute at index "" + index + "": "" + value + "", theme, [])    Expression("" + mTheme), [])  Statement(}, [])  MethodCall(return mResources.loadColorStateList(value, value.resourceId, mTheme), [VariableReference(return mResources, []), Expression(value, []), Expression(value.resourceId, []), Expression(mTheme, [])])    VariableReference(return mResources, [])    Expression(value, [])    Expression(value.resourceId, [])    Expression(mTheme, [])  Statement(}, [])  Statement(return null, [])  Statement(}, [])",1,"/**
 * Retrieve the ColorStateList for the attribute at <var>index</var>.
 * The value may be either a single solid color or a reference to
 * a color or complex {@link android.content.res.ColorStateList}
 * description.
 * <p>
 * This method will return {@code null} if the attribute is not defined or
 * is not an integer color or color state list.
 *
 * @param index Index of attribute to retrieve.
 *
 * @return ColorStateList for the attribute, or {@code null} if not
 * defined.
 * @throws RuntimeException if the attribute if the TypedArray has already
 * been recycled.
 * @throws UnsupportedOperationException if the attribute is defined but is
 * not an integer color or color state list.
 */
","/**
 * Retrieve the ColorStateList for the attribute at <var>index</var>.
 * The value may be either a single solid color or a reference to
 * a color or complex {@link android.content.res.ColorStateList}
 * description.
 * <p>
 * This method will return {@code null} if the attribute is not defined or
 * is not an integer color or color state list.
 *
 * @param index Index of attribute to retrieve.
 *
 * @return ColorStateList for the attribute, or {@code null} if not
 * defined.
 * @throws RuntimeException if the attribute if the TypedArray has already
 * been recycled.
 * @throws UnsupportedOperationException if the attribute is defined but is
 * not an integer color or color state list.
 */
",0,[@Nullable],[@Nullable],0,,,,2,5,0,"2,4",2,"The exception handling statement has been modified to include the theme in the message string. This is classified as 2,4.","The updated exception handling statement presents a different message, which could lead to different exception behaviors. Hence, the CI type is 2."
26,<android.app.admin.DevicePolicyManager: int logoutUser(ComponentName)>,32,33,,,,"MethodDeclaration(method_body, [Statement({, []), Statement(throwIfParentInstance(""logoutUser""), []), Statement(try {, []), MethodCall(return mService.logoutUser(admin), [VariableReference(return mService, []), Expression(admin, [])]), Statement(} catch (RemoteException re) {, []), MethodCall(throw re.rethrowFromSystemServer(), [VariableReference(throw re, []), Expression(, [])]), Statement(}, []), Statement(}, [])])  Statement({, [])  Statement(throwIfParentInstance(""logoutUser""), [])  Statement(try {, [])  MethodCall(return mService.logoutUser(admin), [VariableReference(return mService, []), Expression(admin, [])])    VariableReference(return mService, [])    Expression(admin, [])  Statement(} catch (RemoteException re) {, [])  MethodCall(throw re.rethrowFromSystemServer(), [VariableReference(throw re, []), Expression(, [])])    VariableReference(throw re, [])    Expression(, [])  Statement(}, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(throwIfParentInstance(""logoutUser""), []), Statement(try {, []), MethodCall(return mService.logoutUser(admin), [VariableReference(return mService, []), Expression(admin, [])]), Statement(} catch (RemoteException re) {, []), MethodCall(throw re.rethrowFromSystemServer(), [VariableReference(throw re, []), Expression(, [])]), Statement(}, []), Statement(}, [])])  Statement({, [])  Statement(throwIfParentInstance(""logoutUser""), [])  Statement(try {, [])  MethodCall(return mService.logoutUser(admin), [VariableReference(return mService, []), Expression(admin, [])])    VariableReference(return mService, [])    Expression(admin, [])  Statement(} catch (RemoteException re) {, [])  MethodCall(throw re.rethrowFromSystemServer(), [VariableReference(throw re, []), Expression(, [])])    VariableReference(throw re, [])    Expression(, [])  Statement(}, [])  Statement(}, [])",0,"/**
 * Called by a profile owner of secondary user that is affiliated with the device to stop the
 * calling user and switch back to primary user.
 *
 * <p>Notice that on devices running with
 * {@link UserManager#isHeadlessSystemUserMode() headless system user mode}, there is no primary
 * user, so it switches back to the user that was in the foreground before the first call to
 * {@link #switchUser(ComponentName, UserHandle)} (or fails with
 * {@link UserManager#USER_OPERATION_ERROR_UNKNOWN} if that method was not called prior to this
 * call).
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated with.
 * @return one of the following result codes:
 * {@link UserManager#USER_OPERATION_ERROR_UNKNOWN},
 * {@link UserManager#USER_OPERATION_SUCCESS},
 * {@link UserManager#USER_OPERATION_ERROR_MANAGED_PROFILE},
 * {@link UserManager#USER_OPERATION_ERROR_CURRENT_USER}
 * @throws SecurityException if {@code admin} is not a profile owner affiliated with the device.
 * @see #getSecondaryUsers(ComponentName)
 */
","/**
 * Called by a profile owner of secondary user that is affiliated with the device to stop the
 * calling user and switch back to primary user (when the user was
 * {@link #switchUser(ComponentName, UserHandle)} switched to) or stop the user (when it was
 * {@link #startUserInBackground(ComponentName, UserHandle) started in background}.
 *
 * <p>Notice that on devices running with
 * {@link UserManager#isHeadlessSystemUserMode() headless system user mode}, there is no primary
 * user, so it switches back to the user that was in the foreground before the first call to
 * {@link #switchUser(ComponentName, UserHandle)} (or fails with
 * {@link UserManager#USER_OPERATION_ERROR_UNKNOWN} if that method was not called prior to this
 * call).
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated with.
 * @return one of the following result codes:
 * {@link UserManager#USER_OPERATION_ERROR_UNKNOWN},
 * {@link UserManager#USER_OPERATION_SUCCESS},
 * {@link UserManager#USER_OPERATION_ERROR_MANAGED_PROFILE},
 * {@link UserManager#USER_OPERATION_ERROR_CURRENT_USER}
 * @throws SecurityException if {@code admin} is not a profile owner affiliated with the device.
 * @see #getSecondaryUsers(ComponentName)
 */
",1,[@UserOperationResult],[@UserOperationResult],0,,,,0,0,0,0,0,"The abstract syntax tree (AST) for the early and late implementations are identical, indicating there have been no actual code changes.","Since there have been no changes in the implementation code, there are no compatibility issues."
27,"<android.view.contentcapture.DataRemovalRequest.Builder: Builder addLocusId(LocusId,int)>",32,33,,,,"MethodDeclaration(method_body, [Statement({, []), Statement(throwIfDestroyed(), []), MethodCall(Preconditions.checkState(!mForEverything, ""Already is for everything""), [VariableReference(Preconditions, []), Expression(!mForEverything, []), Expression(""Already is for everything"", [])]), MethodCall(Preconditions.checkNotNull(locusId), [VariableReference(Preconditions, []), Expression(locusId, [])]), AssignmentExpression(=, [VariableReference(if (mLocusIds, []), Expression(, [])]), AssignmentExpression(=, [VariableReference(mLocusIds, []), Expression(new ArrayList<>(), [])]), AssignmentExpression(=, [VariableReference(mFlags, []), Expression(new IntArray(), [])]), Statement(}, []), MethodCall(mLocusIds.add(locusId), [VariableReference(mLocusIds, []), Expression(locusId, [])]), MethodCall(mFlags.add(flags), [VariableReference(mFlags, []), Expression(flags, [])]), Statement(return this, []), Statement(}, [])])  Statement({, [])  Statement(throwIfDestroyed(), [])  MethodCall(Preconditions.checkState(!mForEverything, ""Already is for everything""), [VariableReference(Preconditions, []), Expression(!mForEverything, []), Expression(""Already is for everything"", [])])    VariableReference(Preconditions, [])    Expression(!mForEverything, [])    Expression(""Already is for everything"", [])  MethodCall(Preconditions.checkNotNull(locusId), [VariableReference(Preconditions, []), Expression(locusId, [])])    VariableReference(Preconditions, [])    Expression(locusId, [])  AssignmentExpression(=, [VariableReference(if (mLocusIds, []), Expression(, [])])    VariableReference(if (mLocusIds, [])    Expression(, [])  AssignmentExpression(=, [VariableReference(mLocusIds, []), Expression(new ArrayList<>(), [])])    VariableReference(mLocusIds, [])    Expression(new ArrayList<>(), [])  AssignmentExpression(=, [VariableReference(mFlags, []), Expression(new IntArray(), [])])    VariableReference(mFlags, [])    Expression(new IntArray(), [])  Statement(}, [])  MethodCall(mLocusIds.add(locusId), [VariableReference(mLocusIds, []), Expression(locusId, [])])    VariableReference(mLocusIds, [])    Expression(locusId, [])  MethodCall(mFlags.add(flags), [VariableReference(mFlags, []), Expression(flags, [])])    VariableReference(mFlags, [])    Expression(flags, [])  Statement(return this, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(throwIfDestroyed(), []), MethodCall(Preconditions.checkState(!mForEverything, ""Already is for everything""), [VariableReference(Preconditions, []), Expression(!mForEverything, []), Expression(""Already is for everything"", [])]), MethodCall(Objects.requireNonNull(locusId), [VariableReference(Objects, []), Expression(locusId, [])]), AssignmentExpression(=, [VariableReference(if (mLocusIds, []), Expression(, [])]), AssignmentExpression(=, [VariableReference(mLocusIds, []), Expression(new ArrayList<>(), [])]), AssignmentExpression(=, [VariableReference(mFlags, []), Expression(new IntArray(), [])]), Statement(}, []), MethodCall(mLocusIds.add(locusId), [VariableReference(mLocusIds, []), Expression(locusId, [])]), MethodCall(mFlags.add(flags), [VariableReference(mFlags, []), Expression(flags, [])]), Statement(return this, []), Statement(}, [])])  Statement({, [])  Statement(throwIfDestroyed(), [])  MethodCall(Preconditions.checkState(!mForEverything, ""Already is for everything""), [VariableReference(Preconditions, []), Expression(!mForEverything, []), Expression(""Already is for everything"", [])])    VariableReference(Preconditions, [])    Expression(!mForEverything, [])    Expression(""Already is for everything"", [])  MethodCall(Objects.requireNonNull(locusId), [VariableReference(Objects, []), Expression(locusId, [])])    VariableReference(Objects, [])    Expression(locusId, [])  AssignmentExpression(=, [VariableReference(if (mLocusIds, []), Expression(, [])])    VariableReference(if (mLocusIds, [])    Expression(, [])  AssignmentExpression(=, [VariableReference(mLocusIds, []), Expression(new ArrayList<>(), [])])    VariableReference(mLocusIds, [])    Expression(new ArrayList<>(), [])  AssignmentExpression(=, [VariableReference(mFlags, []), Expression(new IntArray(), [])])    VariableReference(mFlags, [])    Expression(new IntArray(), [])  Statement(}, [])  MethodCall(mLocusIds.add(locusId), [VariableReference(mLocusIds, []), Expression(locusId, [])])    VariableReference(mLocusIds, [])    Expression(locusId, [])  MethodCall(mFlags.add(flags), [VariableReference(mFlags, []), Expression(flags, [])])    VariableReference(mFlags, [])    Expression(flags, [])  Statement(return this, [])  Statement(}, [])",1,"/**
 * Request service to remove data associated with a given {@link LocusId}.
 *
 * @param locusId the {@link LocusId} being requested to be removed.
 * @param flags either {@link DataRemovalRequest#FLAG_IS_PREFIX} or {@code 0}
 *
 * @return this builder
 */
","/**
 * Request service to remove data associated with a given {@link LocusId}.
 *
 * @param locusId the {@link LocusId} being requested to be removed.
 * @param flags either {@link DataRemovalRequest#FLAG_IS_PREFIX} or {@code 0}
 *
 * @return this builder
 */
",0,[@NonNull],[@NonNull],0,,,,2,5,0,4,0,"The change involves a switch from `Preconditions.checkNotNull(locusId)` to `Objects.requireNonNull(locusId)`. Both statements serve the same purpose of ensuring the `locusId` is not null, so it is purely an implementation detail change. The code change type is 4.","Since the functional behavior remains the same and the purpose of the method is not affected by this change, no compatibility issue exists. Therefore, the CI type is 0."
28,"<android.text.BoringLayout: BoringLayout replaceOrMake(CharSequence,TextPaint,int,Alignment,float,float,Metrics,boolean,TruncateAt,int)>",32,33,,,,"MethodDeclaration(method_body, [Statement({, []), Statement(boolean trust, []), AssignmentExpression(=, [VariableReference(if (ellipsize, []), Expression(, [])]), Statement(replaceWith(source, paint, outerWidth, align, spacingMult, spacingAdd), []), AssignmentExpression(=, [VariableReference(mEllipsizedWidth, []), Expression(outerWidth, [])]), AssignmentExpression(=, [VariableReference(mEllipsizedStart, []), Expression(0, [])]), AssignmentExpression(=, [VariableReference(mEllipsizedCount, []), Expression(0, [])]), AssignmentExpression(=, [VariableReference(trust, []), Expression(true, [])]), Statement(} else {, []), MethodCall(replaceWith(TextUtils.ellipsize(source, paint, ellipsizedWidth, ellipsize, true, this), paint, outerWidth, align, spacingMult, spacingAdd), [VariableReference(replaceWith(TextUtils, []), Expression(source, []), Expression(paint, []), Expression(ellipsizedWidth, []), Expression(ellipsize, []), Expression(true, []), Expression(this), []), Expression(paint, []), Expression(outerWidth, []), Expression(align, []), Expression(spacingMult, []), Expression(spacingAdd, [])]), AssignmentExpression(=, [VariableReference(mEllipsizedWidth, []), Expression(ellipsizedWidth, [])]), AssignmentExpression(=, [VariableReference(trust, []), Expression(false, [])]), Statement(}, []), Statement(init(getText(), paint, align, metrics, includePad, trust), []), Statement(return this, []), Statement(}, [])])  Statement({, [])  Statement(boolean trust, [])  AssignmentExpression(=, [VariableReference(if (ellipsize, []), Expression(, [])])    VariableReference(if (ellipsize, [])    Expression(, [])  Statement(replaceWith(source, paint, outerWidth, align, spacingMult, spacingAdd), [])  AssignmentExpression(=, [VariableReference(mEllipsizedWidth, []), Expression(outerWidth, [])])    VariableReference(mEllipsizedWidth, [])    Expression(outerWidth, [])  AssignmentExpression(=, [VariableReference(mEllipsizedStart, []), Expression(0, [])])    VariableReference(mEllipsizedStart, [])    Expression(0, [])  AssignmentExpression(=, [VariableReference(mEllipsizedCount, []), Expression(0, [])])    VariableReference(mEllipsizedCount, [])    Expression(0, [])  AssignmentExpression(=, [VariableReference(trust, []), Expression(true, [])])    VariableReference(trust, [])    Expression(true, [])  Statement(} else {, [])  MethodCall(replaceWith(TextUtils.ellipsize(source, paint, ellipsizedWidth, ellipsize, true, this), paint, outerWidth, align, spacingMult, spacingAdd), [VariableReference(replaceWith(TextUtils, []), Expression(source, []), Expression(paint, []), Expression(ellipsizedWidth, []), Expression(ellipsize, []), Expression(true, []), Expression(this), []), Expression(paint, []), Expression(outerWidth, []), Expression(align, []), Expression(spacingMult, []), Expression(spacingAdd, [])])    VariableReference(replaceWith(TextUtils, [])    Expression(source, [])    Expression(paint, [])    Expression(ellipsizedWidth, [])    Expression(ellipsize, [])    Expression(true, [])    Expression(this), [])    Expression(paint, [])    Expression(outerWidth, [])    Expression(align, [])    Expression(spacingMult, [])    Expression(spacingAdd, [])  AssignmentExpression(=, [VariableReference(mEllipsizedWidth, []), Expression(ellipsizedWidth, [])])    VariableReference(mEllipsizedWidth, [])    Expression(ellipsizedWidth, [])  AssignmentExpression(=, [VariableReference(trust, []), Expression(false, [])])    VariableReference(trust, [])    Expression(false, [])  Statement(}, [])  Statement(init(getText(), paint, align, metrics, includePad, trust), [])  Statement(return this, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(return replaceOrMake(source, paint, outerWidth, align, metrics, includePad, ellipsize, ellipsizedWidth, false), []), Statement(}, [])])  Statement({, [])  Statement(return replaceOrMake(source, paint, outerWidth, align, metrics, includePad, ellipsize, ellipsizedWidth, false), [])  Statement(}, [])",1,"/**
 * Returns a BoringLayout for the specified text, potentially reusing
 * this one if it is already suitable.  The caller must make sure that
 * no one is still using this Layout.
 *
 * @param source the text to render
 * @param paint the default paint for the layout
 * @param outerWidth the wrapping width for the text
 * @param align whether to left, right, or center the text
 * @param spacingMult this value is no longer used by BoringLayout
 * @param spacingAdd this value is no longer used by BoringLayout
 * @param metrics {@code #Metrics} instance that contains information about FontMetrics and
 * line width
 * @param includePad set whether to include extra space beyond font ascent and descent which is
 * needed to avoid clipping in some scripts
 * @param ellipsize whether to ellipsize the text if width of the text is longer than the
 * requested width
 * @param ellipsizedWidth the width to which this Layout is ellipsizing. If {@code ellipsize} is
 * {@code null}, or is {@link TextUtils.TruncateAt#MARQUEE} this value is
 * not used, {@code outerwidth} is used instead
 */
","/**
 * Returns a BoringLayout for the specified text, potentially reusing
 * this one if it is already suitable.  The caller must make sure that
 * no one is still using this Layout.
 *
 * @param source the text to render
 * @param paint the default paint for the layout
 * @param outerWidth the wrapping width for the text
 * @param align whether to left, right, or center the text
 * @param spacingMult this value is no longer used by BoringLayout
 * @param spacingAdd this value is no longer used by BoringLayout
 * @param metrics {@code #Metrics} instance that contains information about FontMetrics and
 * line width
 * @param includePad set whether to include extra space beyond font ascent and descent which is
 * needed to avoid clipping in some scripts
 * @param ellipsize whether to ellipsize the text if width of the text is longer than the
 * requested width
 * @param ellipsizedWidth the width to which this Layout is ellipsizing. If {@code ellipsize} is
 * {@code null}, or is {@link TextUtils.TruncateAt#MARQUEE} this value is
 * not used, {@code outerWidth} is used instead
 */
",1,,,0,,,,"1,2","1,3,4,5",1,"1,4,5",1,"The late version replaces the body of the method with a call to another method (`replaceOrMake(...)`) and returns its value, instead of having its own logic. This introduces changes in the return statement, in other statements, and relies on the dependent method `replaceOrMake(...)` whose behavior might have changed. So, the change types are 1, 4, and 5.","Given the significant change in the return statement and the fact that the behavior now depends on a different method, the API might potentially return different values. Thus, the CI type is 1."
29,<android.service.dreams.DreamService: boolean isFullscreen()>,32,33,,,,"MethodDeclaration(method_body, [Statement({, []), Statement(return mFullscreen, []), Statement(}, [])])  Statement({, [])  Statement(return mFullscreen, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(return mFullscreen, []), Statement(}, [])])  Statement({, [])  Statement(return mFullscreen, [])  Statement(}, [])",0,"/**
 * Returns whether or not this dream is in fullscreen mode. Defaults to false.
 *
 * @see #setFullscreen(boolean)
 */
","/**
 * Returns whether this dream is in fullscreen mode. Defaults to false.
 *
 * @see #setFullscreen(boolean)
 */
",1,,,0,,,,0,0,0,0,0,"There are no changes between the early and late implementations of the method. The comments have minor wording differences, but these do not affect the implementation or behavior of the API.","Since no changes have been made to the code or control dependencies, no compatibility issues exist. The method will behave the same way in both versions, returning the same value without any new exception handling or changes in dependent APIs."
30,<android.os.Binder: void joinThreadPool()>,32,33,,,,"MethodDeclaration(method_body, [Statement({, []), MethodCall(BinderInternal.joinThreadPool(), [VariableReference(BinderInternal, []), Expression(, [])]), Statement(}, [])])  Statement({, [])  MethodCall(BinderInternal.joinThreadPool(), [VariableReference(BinderInternal, []), Expression(, [])])    VariableReference(BinderInternal, [])    Expression(, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), MethodCall(BinderInternal.joinThreadPool(), [VariableReference(BinderInternal, []), Expression(, [])]), Statement(}, [])])  Statement({, [])  MethodCall(BinderInternal.joinThreadPool(), [VariableReference(BinderInternal, []), Expression(, [])])    VariableReference(BinderInternal, [])    Expression(, [])  Statement(}, [])",0,"/**
 * Add the calling thread to the IPC thread pool.  This function does
 * not return until the current process is exiting.
 */
","/**
 * Add the calling thread to the IPC thread pool. This function does
 * not return until the current process is exiting.
 */
",1,,,0,,,,0,0,0,0,0,"No changes were detected between the early and late versions in terms of the implementation, comments, or annotations.","Since there are no changes in the API implementation, no Compatibility Issues exist."
31,<android.view.ViewRootImpl.NativePreImeInputStage: int onProcess(QueuedInputEvent)>,32,33,,,,"MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(if (mInputQueue !, []), Expression(null && q.mEvent instanceof KeyEvent) {, [])]), MethodCall(mInputQueue.sendInputEvent(q.mEvent, q, true, this), [VariableReference(mInputQueue, []), Expression(q.mEvent, []), Expression(q, []), Expression(true, []), Expression(this, [])]), Statement(return DEFER, []), Statement(}, []), Statement(return FORWARD, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(if (mInputQueue !, []), Expression(null && q.mEvent instanceof KeyEvent) {, [])])    VariableReference(if (mInputQueue !, [])    Expression(null && q.mEvent instanceof KeyEvent) {, [])  MethodCall(mInputQueue.sendInputEvent(q.mEvent, q, true, this), [VariableReference(mInputQueue, []), Expression(q.mEvent, []), Expression(q, []), Expression(true, []), Expression(this, [])])    VariableReference(mInputQueue, [])    Expression(q.mEvent, [])    Expression(q, [])    Expression(true, [])    Expression(this, [])  Statement(return DEFER, [])  Statement(}, [])  Statement(return FORWARD, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(final KeyEvent event, []), Expression((KeyEvent) q.mEvent, [])]), Statement(// view tree or IME, and invoke the appropriate {@link OnBackInvokedCallback}., []), AssignmentExpression(=, [VariableReference(if (isBack(event) && mContext !, []), Expression(null && WindowOnBackInvokedDispatcher.isOnBackInvokedCallbackEnabled(mContext)) {, [])]), AssignmentExpression(=, [VariableReference(OnBackInvokedCallback topCallback, []), Expression(getOnBackInvokedDispatcher().getTopCallback(), [])]), AssignmentExpression(=, [VariableReference(if (event.getAction(), []), Expression(, [])]), AssignmentExpression(=, [VariableReference(if (topCallback !, []), Expression(null) {, [])]), MethodCall(topCallback.onBackInvoked(), [VariableReference(topCallback, []), Expression(, [])]), Statement(return FINISH_HANDLED, []), Statement(}, []), Statement(} else {, []), Statement(// Drop other actions such as {@link KeyEvent.ACTION_DOWN}., []), Statement(return FINISH_NOT_HANDLED, []), Statement(}, []), Statement(}, []), Statement(}, []), AssignmentExpression(=, [VariableReference(if (mInputQueue !, []), Expression(null && q.mEvent instanceof KeyEvent) {, [])]), MethodCall(mInputQueue.sendInputEvent(q.mEvent, q, true, this), [VariableReference(mInputQueue, []), Expression(q.mEvent, []), Expression(q, []), Expression(true, []), Expression(this, [])]), Statement(return DEFER, []), Statement(}, []), Statement(return FORWARD, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(final KeyEvent event, []), Expression((KeyEvent) q.mEvent, [])])    VariableReference(final KeyEvent event, [])    Expression((KeyEvent) q.mEvent, [])  Statement(// view tree or IME, and invoke the appropriate {@link OnBackInvokedCallback}., [])  AssignmentExpression(=, [VariableReference(if (isBack(event) && mContext !, []), Expression(null && WindowOnBackInvokedDispatcher.isOnBackInvokedCallbackEnabled(mContext)) {, [])])    VariableReference(if (isBack(event) && mContext !, [])    Expression(null && WindowOnBackInvokedDispatcher.isOnBackInvokedCallbackEnabled(mContext)) {, [])  AssignmentExpression(=, [VariableReference(OnBackInvokedCallback topCallback, []), Expression(getOnBackInvokedDispatcher().getTopCallback(), [])])    VariableReference(OnBackInvokedCallback topCallback, [])    Expression(getOnBackInvokedDispatcher().getTopCallback(), [])  AssignmentExpression(=, [VariableReference(if (event.getAction(), []), Expression(, [])])    VariableReference(if (event.getAction(), [])    Expression(, [])  AssignmentExpression(=, [VariableReference(if (topCallback !, []), Expression(null) {, [])])    VariableReference(if (topCallback !, [])    Expression(null) {, [])  MethodCall(topCallback.onBackInvoked(), [VariableReference(topCallback, []), Expression(, [])])    VariableReference(topCallback, [])    Expression(, [])  Statement(return FINISH_HANDLED, [])  Statement(}, [])  Statement(} else {, [])  Statement(// Drop other actions such as {@link KeyEvent.ACTION_DOWN}., [])  Statement(return FINISH_NOT_HANDLED, [])  Statement(}, [])  Statement(}, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(if (mInputQueue !, []), Expression(null && q.mEvent instanceof KeyEvent) {, [])])    VariableReference(if (mInputQueue !, [])    Expression(null && q.mEvent instanceof KeyEvent) {, [])  MethodCall(mInputQueue.sendInputEvent(q.mEvent, q, true, this), [VariableReference(mInputQueue, []), Expression(q.mEvent, []), Expression(q, []), Expression(true, []), Expression(this, [])])    VariableReference(mInputQueue, [])    Expression(q.mEvent, [])    Expression(q, [])    Expression(true, [])    Expression(this, [])  Statement(return DEFER, [])  Statement(}, [])  Statement(return FORWARD, [])  Statement(}, [])",1,,,0,[@Override],[@Override],0,,,,"1,2","1,3,4,5",1,3,1,The control statements have significantly changed between the two versions. The late version introduces new conditions and control flows related to `KeyEvent` and `OnBackInvokedCallback`.,"The new control dependencies and conditions introduced in the late version can potentially alter the return value of the method, leading to the method possibly returning different values (`FINISH_HANDLED`, `FINISH_NOT_HANDLED`) instead of just `DEFER` or `FORWARD` as in the early version. Thus, the CI type is 1."
32,"<android.view.translation.UiTranslationManager: void registerUiTranslationStateCallback(Executor,UiTranslationStateCallback)>",32,33,,,,"MethodDeclaration(method_body, [Statement({, []), MethodCall(Objects.requireNonNull(executor), [VariableReference(Objects, []), Expression(executor, [])]), MethodCall(Objects.requireNonNull(callback), [VariableReference(Objects, []), Expression(callback, [])]), Statement(synchronized (mCallbacks) {, []), MethodCall(if (mCallbacks.containsKey(callback)), [VariableReference(if (mCallbacks, []), Expression(callback), [])]), Statement("" + "" ignoring.""), []), Statement(return, []), Statement(}, []), AssignmentExpression(=, [VariableReference(final IRemoteCallback remoteCallback, []), Expression(new UiTranslationStateRemoteCallback(executor, callback), [])]), Statement(try {, []), MethodCall(mService.registerUiTranslationStateCallback(remoteCallback, mContext.getUserId()), [VariableReference(mService, []), Expression(remoteCallback, []), Expression(mContext.getUserId(), [])]), Statement(} catch (RemoteException e) {, []), MethodCall(throw e.rethrowFromSystemServer(), [VariableReference(throw e, []), Expression(, [])]), Statement(}, []), MethodCall(mCallbacks.put(callback, remoteCallback), [VariableReference(mCallbacks, []), Expression(callback, []), Expression(remoteCallback, [])]), Statement(}, []), Statement(}, [])])  Statement({, [])  MethodCall(Objects.requireNonNull(executor), [VariableReference(Objects, []), Expression(executor, [])])    VariableReference(Objects, [])    Expression(executor, [])  MethodCall(Objects.requireNonNull(callback), [VariableReference(Objects, []), Expression(callback, [])])    VariableReference(Objects, [])    Expression(callback, [])  Statement(synchronized (mCallbacks) {, [])  MethodCall(if (mCallbacks.containsKey(callback)), [VariableReference(if (mCallbacks, []), Expression(callback), [])])    VariableReference(if (mCallbacks, [])    Expression(callback), [])  Statement("" + "" ignoring.""), [])  Statement(return, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(final IRemoteCallback remoteCallback, []), Expression(new UiTranslationStateRemoteCallback(executor, callback), [])])    VariableReference(final IRemoteCallback remoteCallback, [])    Expression(new UiTranslationStateRemoteCallback(executor, callback), [])  Statement(try {, [])  MethodCall(mService.registerUiTranslationStateCallback(remoteCallback, mContext.getUserId()), [VariableReference(mService, []), Expression(remoteCallback, []), Expression(mContext.getUserId(), [])])    VariableReference(mService, [])    Expression(remoteCallback, [])    Expression(mContext.getUserId(), [])  Statement(} catch (RemoteException e) {, [])  MethodCall(throw e.rethrowFromSystemServer(), [VariableReference(throw e, []), Expression(, [])])    VariableReference(throw e, [])    Expression(, [])  Statement(}, [])  MethodCall(mCallbacks.put(callback, remoteCallback), [VariableReference(mCallbacks, []), Expression(callback, []), Expression(remoteCallback, [])])    VariableReference(mCallbacks, [])    Expression(callback, [])    Expression(remoteCallback, [])  Statement(}, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), MethodCall(Objects.requireNonNull(executor), [VariableReference(Objects, []), Expression(executor, [])]), MethodCall(Objects.requireNonNull(callback), [VariableReference(Objects, []), Expression(callback, [])]), Statement(synchronized (mCallbacks) {, []), MethodCall(if (mCallbacks.containsKey(callback)), [VariableReference(if (mCallbacks, []), Expression(callback), [])]), Statement("" + "" ignoring.""), []), Statement(return, []), Statement(}, []), AssignmentExpression(=, [VariableReference(final IRemoteCallback remoteCallback, []), Expression(new UiTranslationStateRemoteCallback(executor, callback), [])]), Statement(try {, []), MethodCall(mService.registerUiTranslationStateCallback(remoteCallback, mContext.getUserId()), [VariableReference(mService, []), Expression(remoteCallback, []), Expression(mContext.getUserId(), [])]), Statement(} catch (RemoteException e) {, []), MethodCall(throw e.rethrowFromSystemServer(), [VariableReference(throw e, []), Expression(, [])]), Statement(}, []), MethodCall(mCallbacks.put(callback, remoteCallback), [VariableReference(mCallbacks, []), Expression(callback, []), Expression(remoteCallback, [])]), Statement(}, []), Statement(}, [])])  Statement({, [])  MethodCall(Objects.requireNonNull(executor), [VariableReference(Objects, []), Expression(executor, [])])    VariableReference(Objects, [])    Expression(executor, [])  MethodCall(Objects.requireNonNull(callback), [VariableReference(Objects, []), Expression(callback, [])])    VariableReference(Objects, [])    Expression(callback, [])  Statement(synchronized (mCallbacks) {, [])  MethodCall(if (mCallbacks.containsKey(callback)), [VariableReference(if (mCallbacks, []), Expression(callback), [])])    VariableReference(if (mCallbacks, [])    Expression(callback), [])  Statement("" + "" ignoring.""), [])  Statement(return, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(final IRemoteCallback remoteCallback, []), Expression(new UiTranslationStateRemoteCallback(executor, callback), [])])    VariableReference(final IRemoteCallback remoteCallback, [])    Expression(new UiTranslationStateRemoteCallback(executor, callback), [])  Statement(try {, [])  MethodCall(mService.registerUiTranslationStateCallback(remoteCallback, mContext.getUserId()), [VariableReference(mService, []), Expression(remoteCallback, []), Expression(mContext.getUserId(), [])])    VariableReference(mService, [])    Expression(remoteCallback, [])    Expression(mContext.getUserId(), [])  Statement(} catch (RemoteException e) {, [])  MethodCall(throw e.rethrowFromSystemServer(), [VariableReference(throw e, []), Expression(, [])])    VariableReference(throw e, [])    Expression(, [])  Statement(}, [])  MethodCall(mCallbacks.put(callback, remoteCallback), [VariableReference(mCallbacks, []), Expression(callback, []), Expression(remoteCallback, [])])    VariableReference(mCallbacks, [])    Expression(callback, [])    Expression(remoteCallback, [])  Statement(}, [])  Statement(}, [])",0,"/**
 * Register for notifications of UI Translation state changes on the foreground activity. This
 * is available to the owning application itself and also the current input method.
 * <p>
 * The application whose UI is being translated can use this to customize the UI Translation
 * behavior in ways that aren't made easy by methods like
 * {@link View#onCreateViewTranslationRequest(int[], Consumer)}.
 *
 * <p>
 * Input methods can use this to offer complementary features to UI Translation; for example,
 * enabling outgoing message translation when the system is translating incoming messages in a
 * communication app.
 *
 * @param callback the callback to register for receiving the state change
 * notifications
 */
","/**
 * Register for notifications of UI Translation state changes on the foreground Activity. This
 * is available to the owning application itself and also the current input method.
 * <p>
 * The application whose UI is being translated can use this to customize the UI Translation
 * behavior in ways that aren't made easy by methods like
 * {@link View#onCreateViewTranslationRequest(int[], Consumer)}.
 * <p>
 * Input methods can use this to offer complementary features to UI Translation; for example,
 * enabling outgoing message translation when the system is translating incoming messages in a
 * communication app.
 * <p>
 * Starting from {@link android.os.Build.VERSION_CODES#TIRAMISU}, if Activities are already
 * being translated when a callback is registered, methods on the callback will be invoked for
 * each translated activity, depending on the state of translation:
 * <ul>
 * <li>If translation is <em>not</em> paused,
 * {@link UiTranslationStateCallback#onStarted} will be invoked.</li>
 * <li>If translation <em>is</em> paused, {@link UiTranslationStateCallback#onStarted}
 * will first be invoked, followed by {@link UiTranslationStateCallback#onPaused}.</li>
 * </ul>
 *
 * @param callback the callback to register for receiving the state change
 * notifications
 */
",1,,,0,,,,0,0,0,0,0,There are no code changes between the early and late versions of the implementation.,"Since there are no code changes, there are no potential compatibility issues."
33,<android.view.ViewRootImpl.ViewRootHandler: String getMessageName(Message)>,32,33,,,,"MethodDeclaration(method_body, [Statement({, []), Statement(case MSG_INVALIDATE:, []), Statement(return ""MSG_INVALIDATE"", []), Statement(case MSG_INVALIDATE_RECT:, []), Statement(return ""MSG_INVALIDATE_RECT"", []), Statement(case MSG_DIE:, []), Statement(return ""MSG_DIE"", []), Statement(case MSG_RESIZED:, []), Statement(return ""MSG_RESIZED"", []), Statement(case MSG_RESIZED_REPORT:, []), Statement(return ""MSG_RESIZED_REPORT"", []), Statement(case MSG_WINDOW_FOCUS_CHANGED:, []), Statement(return ""MSG_WINDOW_FOCUS_CHANGED"", []), Statement(case MSG_DISPATCH_INPUT_EVENT:, []), Statement(return ""MSG_DISPATCH_INPUT_EVENT"", []), Statement(case MSG_DISPATCH_APP_VISIBILITY:, []), Statement(return ""MSG_DISPATCH_APP_VISIBILITY"", []), Statement(case MSG_DISPATCH_GET_NEW_SURFACE:, []), Statement(return ""MSG_DISPATCH_GET_NEW_SURFACE"", []), Statement(case MSG_DISPATCH_KEY_FROM_IME:, []), Statement(return ""MSG_DISPATCH_KEY_FROM_IME"", []), Statement(case MSG_DISPATCH_KEY_FROM_AUTOFILL:, []), Statement(return ""MSG_DISPATCH_KEY_FROM_AUTOFILL"", []), Statement(case MSG_CHECK_FOCUS:, []), Statement(return ""MSG_CHECK_FOCUS"", []), Statement(case MSG_CLOSE_SYSTEM_DIALOGS:, []), Statement(return ""MSG_CLOSE_SYSTEM_DIALOGS"", []), Statement(case MSG_DISPATCH_DRAG_EVENT:, []), Statement(return ""MSG_DISPATCH_DRAG_EVENT"", []), Statement(case MSG_DISPATCH_DRAG_LOCATION_EVENT:, []), Statement(return ""MSG_DISPATCH_DRAG_LOCATION_EVENT"", []), Statement(case MSG_DISPATCH_SYSTEM_UI_VISIBILITY:, []), Statement(return ""MSG_DISPATCH_SYSTEM_UI_VISIBILITY"", []), Statement(case MSG_UPDATE_CONFIGURATION:, []), Statement(return ""MSG_UPDATE_CONFIGURATION"", []), Statement(case MSG_PROCESS_INPUT_EVENTS:, []), Statement(return ""MSG_PROCESS_INPUT_EVENTS"", []), Statement(case MSG_CLEAR_ACCESSIBILITY_FOCUS_HOST:, []), Statement(return ""MSG_CLEAR_ACCESSIBILITY_FOCUS_HOST"", []), Statement(case MSG_WINDOW_MOVED:, []), Statement(return ""MSG_WINDOW_MOVED"", []), Statement(case MSG_SYNTHESIZE_INPUT_EVENT:, []), Statement(return ""MSG_SYNTHESIZE_INPUT_EVENT"", []), Statement(case MSG_DISPATCH_WINDOW_SHOWN:, []), Statement(return ""MSG_DISPATCH_WINDOW_SHOWN"", []), Statement(case MSG_UPDATE_POINTER_ICON:, []), Statement(return ""MSG_UPDATE_POINTER_ICON"", []), Statement(case MSG_POINTER_CAPTURE_CHANGED:, []), Statement(return ""MSG_POINTER_CAPTURE_CHANGED"", []), Statement(case MSG_DRAW_FINISHED:, []), Statement(return ""MSG_DRAW_FINISHED"", []), Statement(case MSG_INSETS_CHANGED:, []), Statement(return ""MSG_INSETS_CHANGED"", []), Statement(case MSG_INSETS_CONTROL_CHANGED:, []), Statement(return ""MSG_INSETS_CONTROL_CHANGED"", []), Statement(case MSG_SYSTEM_GESTURE_EXCLUSION_CHANGED:, []), Statement(return ""MSG_SYSTEM_GESTURE_EXCLUSION_CHANGED"", []), Statement(case MSG_LOCATION_IN_PARENT_DISPLAY_CHANGED:, []), Statement(return ""MSG_LOCATION_IN_PARENT_DISPLAY_CHANGED"", []), Statement(case MSG_SHOW_INSETS:, []), Statement(return ""MSG_SHOW_INSETS"", []), Statement(case MSG_HIDE_INSETS:, []), Statement(return ""MSG_HIDE_INSETS"", []), Statement(}, []), MethodCall(return super.getMessageName(message), [VariableReference(return super, []), Expression(message, [])]), Statement(}, [])])  Statement({, [])  Statement(case MSG_INVALIDATE:, [])  Statement(return ""MSG_INVALIDATE"", [])  Statement(case MSG_INVALIDATE_RECT:, [])  Statement(return ""MSG_INVALIDATE_RECT"", [])  Statement(case MSG_DIE:, [])  Statement(return ""MSG_DIE"", [])  Statement(case MSG_RESIZED:, [])  Statement(return ""MSG_RESIZED"", [])  Statement(case MSG_RESIZED_REPORT:, [])  Statement(return ""MSG_RESIZED_REPORT"", [])  Statement(case MSG_WINDOW_FOCUS_CHANGED:, [])  Statement(return ""MSG_WINDOW_FOCUS_CHANGED"", [])  Statement(case MSG_DISPATCH_INPUT_EVENT:, [])  Statement(return ""MSG_DISPATCH_INPUT_EVENT"", [])  Statement(case MSG_DISPATCH_APP_VISIBILITY:, [])  Statement(return ""MSG_DISPATCH_APP_VISIBILITY"", [])  Statement(case MSG_DISPATCH_GET_NEW_SURFACE:, [])  Statement(return ""MSG_DISPATCH_GET_NEW_SURFACE"", [])  Statement(case MSG_DISPATCH_KEY_FROM_IME:, [])  Statement(return ""MSG_DISPATCH_KEY_FROM_IME"", [])  Statement(case MSG_DISPATCH_KEY_FROM_AUTOFILL:, [])  Statement(return ""MSG_DISPATCH_KEY_FROM_AUTOFILL"", [])  Statement(case MSG_CHECK_FOCUS:, [])  Statement(return ""MSG_CHECK_FOCUS"", [])  Statement(case MSG_CLOSE_SYSTEM_DIALOGS:, [])  Statement(return ""MSG_CLOSE_SYSTEM_DIALOGS"", [])  Statement(case MSG_DISPATCH_DRAG_EVENT:, [])  Statement(return ""MSG_DISPATCH_DRAG_EVENT"", [])  Statement(case MSG_DISPATCH_DRAG_LOCATION_EVENT:, [])  Statement(return ""MSG_DISPATCH_DRAG_LOCATION_EVENT"", [])  Statement(case MSG_DISPATCH_SYSTEM_UI_VISIBILITY:, [])  Statement(return ""MSG_DISPATCH_SYSTEM_UI_VISIBILITY"", [])  Statement(case MSG_UPDATE_CONFIGURATION:, [])  Statement(return ""MSG_UPDATE_CONFIGURATION"", [])  Statement(case MSG_PROCESS_INPUT_EVENTS:, [])  Statement(return ""MSG_PROCESS_INPUT_EVENTS"", [])  Statement(case MSG_CLEAR_ACCESSIBILITY_FOCUS_HOST:, [])  Statement(return ""MSG_CLEAR_ACCESSIBILITY_FOCUS_HOST"", [])  Statement(case MSG_WINDOW_MOVED:, [])  Statement(return ""MSG_WINDOW_MOVED"", [])  Statement(case MSG_SYNTHESIZE_INPUT_EVENT:, [])  Statement(return ""MSG_SYNTHESIZE_INPUT_EVENT"", [])  Statement(case MSG_DISPATCH_WINDOW_SHOWN:, [])  Statement(return ""MSG_DISPATCH_WINDOW_SHOWN"", [])  Statement(case MSG_UPDATE_POINTER_ICON:, [])  Statement(return ""MSG_UPDATE_POINTER_ICON"", [])  Statement(case MSG_POINTER_CAPTURE_CHANGED:, [])  Statement(return ""MSG_POINTER_CAPTURE_CHANGED"", [])  Statement(case MSG_DRAW_FINISHED:, [])  Statement(return ""MSG_DRAW_FINISHED"", [])  Statement(case MSG_INSETS_CHANGED:, [])  Statement(return ""MSG_INSETS_CHANGED"", [])  Statement(case MSG_INSETS_CONTROL_CHANGED:, [])  Statement(return ""MSG_INSETS_CONTROL_CHANGED"", [])  Statement(case MSG_SYSTEM_GESTURE_EXCLUSION_CHANGED:, [])  Statement(return ""MSG_SYSTEM_GESTURE_EXCLUSION_CHANGED"", [])  Statement(case MSG_LOCATION_IN_PARENT_DISPLAY_CHANGED:, [])  Statement(return ""MSG_LOCATION_IN_PARENT_DISPLAY_CHANGED"", [])  Statement(case MSG_SHOW_INSETS:, [])  Statement(return ""MSG_SHOW_INSETS"", [])  Statement(case MSG_HIDE_INSETS:, [])  Statement(return ""MSG_HIDE_INSETS"", [])  Statement(}, [])  MethodCall(return super.getMessageName(message), [VariableReference(return super, []), Expression(message, [])])    VariableReference(return super, [])    Expression(message, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(case MSG_INVALIDATE:, []), Statement(return ""MSG_INVALIDATE"", []), Statement(case MSG_INVALIDATE_RECT:, []), Statement(return ""MSG_INVALIDATE_RECT"", []), Statement(case MSG_DIE:, []), Statement(return ""MSG_DIE"", []), Statement(case MSG_RESIZED:, []), Statement(return ""MSG_RESIZED"", []), Statement(case MSG_RESIZED_REPORT:, []), Statement(return ""MSG_RESIZED_REPORT"", []), Statement(case MSG_WINDOW_FOCUS_CHANGED:, []), Statement(return ""MSG_WINDOW_FOCUS_CHANGED"", []), Statement(case MSG_DISPATCH_INPUT_EVENT:, []), Statement(return ""MSG_DISPATCH_INPUT_EVENT"", []), Statement(case MSG_DISPATCH_APP_VISIBILITY:, []), Statement(return ""MSG_DISPATCH_APP_VISIBILITY"", []), Statement(case MSG_DISPATCH_GET_NEW_SURFACE:, []), Statement(return ""MSG_DISPATCH_GET_NEW_SURFACE"", []), Statement(case MSG_DISPATCH_KEY_FROM_IME:, []), Statement(return ""MSG_DISPATCH_KEY_FROM_IME"", []), Statement(case MSG_DISPATCH_KEY_FROM_AUTOFILL:, []), Statement(return ""MSG_DISPATCH_KEY_FROM_AUTOFILL"", []), Statement(case MSG_CHECK_FOCUS:, []), Statement(return ""MSG_CHECK_FOCUS"", []), Statement(case MSG_CLOSE_SYSTEM_DIALOGS:, []), Statement(return ""MSG_CLOSE_SYSTEM_DIALOGS"", []), Statement(case MSG_DISPATCH_DRAG_EVENT:, []), Statement(return ""MSG_DISPATCH_DRAG_EVENT"", []), Statement(case MSG_DISPATCH_DRAG_LOCATION_EVENT:, []), Statement(return ""MSG_DISPATCH_DRAG_LOCATION_EVENT"", []), Statement(case MSG_DISPATCH_SYSTEM_UI_VISIBILITY:, []), Statement(return ""MSG_DISPATCH_SYSTEM_UI_VISIBILITY"", []), Statement(case MSG_UPDATE_CONFIGURATION:, []), Statement(return ""MSG_UPDATE_CONFIGURATION"", []), Statement(case MSG_PROCESS_INPUT_EVENTS:, []), Statement(return ""MSG_PROCESS_INPUT_EVENTS"", []), Statement(case MSG_CLEAR_ACCESSIBILITY_FOCUS_HOST:, []), Statement(return ""MSG_CLEAR_ACCESSIBILITY_FOCUS_HOST"", []), Statement(case MSG_WINDOW_MOVED:, []), Statement(return ""MSG_WINDOW_MOVED"", []), Statement(case MSG_SYNTHESIZE_INPUT_EVENT:, []), Statement(return ""MSG_SYNTHESIZE_INPUT_EVENT"", []), Statement(case MSG_DISPATCH_WINDOW_SHOWN:, []), Statement(return ""MSG_DISPATCH_WINDOW_SHOWN"", []), Statement(case MSG_UPDATE_POINTER_ICON:, []), Statement(return ""MSG_UPDATE_POINTER_ICON"", []), Statement(case MSG_POINTER_CAPTURE_CHANGED:, []), Statement(return ""MSG_POINTER_CAPTURE_CHANGED"", []), Statement(case MSG_INSETS_CONTROL_CHANGED:, []), Statement(return ""MSG_INSETS_CONTROL_CHANGED"", []), Statement(case MSG_SYSTEM_GESTURE_EXCLUSION_CHANGED:, []), Statement(return ""MSG_SYSTEM_GESTURE_EXCLUSION_CHANGED"", []), Statement(case MSG_SHOW_INSETS:, []), Statement(return ""MSG_SHOW_INSETS"", []), Statement(case MSG_HIDE_INSETS:, []), Statement(return ""MSG_HIDE_INSETS"", []), Statement(case MSG_WINDOW_TOUCH_MODE_CHANGED:, []), Statement(return ""MSG_WINDOW_TOUCH_MODE_CHANGED"", []), Statement(case MSG_KEEP_CLEAR_RECTS_CHANGED:, []), Statement(return ""MSG_KEEP_CLEAR_RECTS_CHANGED"", []), Statement(}, []), MethodCall(return super.getMessageName(message), [VariableReference(return super, []), Expression(message, [])]), Statement(}, [])])  Statement({, [])  Statement(case MSG_INVALIDATE:, [])  Statement(return ""MSG_INVALIDATE"", [])  Statement(case MSG_INVALIDATE_RECT:, [])  Statement(return ""MSG_INVALIDATE_RECT"", [])  Statement(case MSG_DIE:, [])  Statement(return ""MSG_DIE"", [])  Statement(case MSG_RESIZED:, [])  Statement(return ""MSG_RESIZED"", [])  Statement(case MSG_RESIZED_REPORT:, [])  Statement(return ""MSG_RESIZED_REPORT"", [])  Statement(case MSG_WINDOW_FOCUS_CHANGED:, [])  Statement(return ""MSG_WINDOW_FOCUS_CHANGED"", [])  Statement(case MSG_DISPATCH_INPUT_EVENT:, [])  Statement(return ""MSG_DISPATCH_INPUT_EVENT"", [])  Statement(case MSG_DISPATCH_APP_VISIBILITY:, [])  Statement(return ""MSG_DISPATCH_APP_VISIBILITY"", [])  Statement(case MSG_DISPATCH_GET_NEW_SURFACE:, [])  Statement(return ""MSG_DISPATCH_GET_NEW_SURFACE"", [])  Statement(case MSG_DISPATCH_KEY_FROM_IME:, [])  Statement(return ""MSG_DISPATCH_KEY_FROM_IME"", [])  Statement(case MSG_DISPATCH_KEY_FROM_AUTOFILL:, [])  Statement(return ""MSG_DISPATCH_KEY_FROM_AUTOFILL"", [])  Statement(case MSG_CHECK_FOCUS:, [])  Statement(return ""MSG_CHECK_FOCUS"", [])  Statement(case MSG_CLOSE_SYSTEM_DIALOGS:, [])  Statement(return ""MSG_CLOSE_SYSTEM_DIALOGS"", [])  Statement(case MSG_DISPATCH_DRAG_EVENT:, [])  Statement(return ""MSG_DISPATCH_DRAG_EVENT"", [])  Statement(case MSG_DISPATCH_DRAG_LOCATION_EVENT:, [])  Statement(return ""MSG_DISPATCH_DRAG_LOCATION_EVENT"", [])  Statement(case MSG_DISPATCH_SYSTEM_UI_VISIBILITY:, [])  Statement(return ""MSG_DISPATCH_SYSTEM_UI_VISIBILITY"", [])  Statement(case MSG_UPDATE_CONFIGURATION:, [])  Statement(return ""MSG_UPDATE_CONFIGURATION"", [])  Statement(case MSG_PROCESS_INPUT_EVENTS:, [])  Statement(return ""MSG_PROCESS_INPUT_EVENTS"", [])  Statement(case MSG_CLEAR_ACCESSIBILITY_FOCUS_HOST:, [])  Statement(return ""MSG_CLEAR_ACCESSIBILITY_FOCUS_HOST"", [])  Statement(case MSG_WINDOW_MOVED:, [])  Statement(return ""MSG_WINDOW_MOVED"", [])  Statement(case MSG_SYNTHESIZE_INPUT_EVENT:, [])  Statement(return ""MSG_SYNTHESIZE_INPUT_EVENT"", [])  Statement(case MSG_DISPATCH_WINDOW_SHOWN:, [])  Statement(return ""MSG_DISPATCH_WINDOW_SHOWN"", [])  Statement(case MSG_UPDATE_POINTER_ICON:, [])  Statement(return ""MSG_UPDATE_POINTER_ICON"", [])  Statement(case MSG_POINTER_CAPTURE_CHANGED:, [])  Statement(return ""MSG_POINTER_CAPTURE_CHANGED"", [])  Statement(case MSG_INSETS_CONTROL_CHANGED:, [])  Statement(return ""MSG_INSETS_CONTROL_CHANGED"", [])  Statement(case MSG_SYSTEM_GESTURE_EXCLUSION_CHANGED:, [])  Statement(return ""MSG_SYSTEM_GESTURE_EXCLUSION_CHANGED"", [])  Statement(case MSG_SHOW_INSETS:, [])  Statement(return ""MSG_SHOW_INSETS"", [])  Statement(case MSG_HIDE_INSETS:, [])  Statement(return ""MSG_HIDE_INSETS"", [])  Statement(case MSG_WINDOW_TOUCH_MODE_CHANGED:, [])  Statement(return ""MSG_WINDOW_TOUCH_MODE_CHANGED"", [])  Statement(case MSG_KEEP_CLEAR_RECTS_CHANGED:, [])  Statement(return ""MSG_KEEP_CLEAR_RECTS_CHANGED"", [])  Statement(}, [])  MethodCall(return super.getMessageName(message), [VariableReference(return super, []), Expression(message, [])])    VariableReference(return super, [])    Expression(message, [])  Statement(}, [])",1,,,0,[@Override],[@Override],0,,,,1,"1,3",1,3,0,"Two new case statements were added to handle MSG_WINDOW_TOUCH_MODE_CHANGED and MSG_KEEP_CLEAR_RECTS_CHANGED in the late version. This implies that more control dependencies have been introduced, so the code change type is 3.","The newly added case statements do not change the return values or introduce new exceptions but add control paths to handle more types of messages. Hence, there is no compatibility issue caused (CI type is 0)."
34,<android.view.autofill.AutofillManager.TrackedViews: void onVisibleForAutofillChangedLocked()>,32,33,,,,"MethodDeclaration(method_body, [Statement({, []), Statement(// The visibility of the views might have changed while the client was not be visible,, []), Statement(// hence update the visibility state for all views., []), AssignmentExpression(=, [VariableReference(AutofillClient client, []), Expression(getClient(), [])]), AssignmentExpression(=, [VariableReference(ArraySet<AutofillId> updatedVisibleTrackedIds, []), Expression(null, [])]), AssignmentExpression(=, [VariableReference(ArraySet<AutofillId> updatedInvisibleTrackedIds, []), Expression(null, [])]), AssignmentExpression(=, [VariableReference(if (client !, []), Expression(null) {, [])]), Statement(if (sVerbose) {, []), AssignmentExpression(=, [VariableReference(Log.v(TAG, ""onVisibleForAutofillChangedLocked(): inv, []), Expression("" + mInvisibleTrackedIds + "" vis, [])]), Statement(}, []), AssignmentExpression(=, [VariableReference(if (mInvisibleTrackedIds !, []), Expression(null) {, [])]), AssignmentExpression(=, [VariableReference(final ArrayList<AutofillId> orderedInvisibleIds, []), Expression(new ArrayList<>(mInvisibleTrackedIds), [])]), AssignmentExpression(=, [VariableReference(final boolean[] isVisible, []), Expression(client.autofillClientGetViewVisibility(Helper.toArray(orderedInvisibleIds)), [])]), AssignmentExpression(=, [VariableReference(final int numInvisibleTrackedIds, []), Expression(orderedInvisibleIds.size(), [])]), AssignmentExpression(=, [VariableReference(for (int i, []), Expression(0, [])]), Statement(i < numInvisibleTrackedIds, []), Statement(i++) {, []), AssignmentExpression(=, [VariableReference(final AutofillId id, []), Expression(orderedInvisibleIds.get(i), [])]), Statement(if (isVisible[i]) {, []), AssignmentExpression(=, [VariableReference(updatedVisibleTrackedIds, []), Expression(addToSet(updatedVisibleTrackedIds, id), [])]), Statement(if (sDebug) {, []), MethodCall(Log.d(TAG, ""onVisibleForAutofill() "" + id + "" became visible""), [VariableReference(Log, []), Expression(TAG, []), Expression(""onVisibleForAutofill() "" + id + "" became visible"", [])]), Statement(}, []), Statement(} else {, []), AssignmentExpression(=, [VariableReference(updatedInvisibleTrackedIds, []), Expression(addToSet(updatedInvisibleTrackedIds, id), [])]), Statement(}, []), Statement(}, []), Statement(}, []), AssignmentExpression(=, [VariableReference(if (mVisibleTrackedIds !, []), Expression(null) {, [])]), AssignmentExpression(=, [VariableReference(final ArrayList<AutofillId> orderedVisibleIds, []), Expression(new ArrayList<>(mVisibleTrackedIds), [])]), AssignmentExpression(=, [VariableReference(final boolean[] isVisible, []), Expression(client.autofillClientGetViewVisibility(Helper.toArray(orderedVisibleIds)), [])]), AssignmentExpression(=, [VariableReference(final int numVisibleTrackedIds, []), Expression(orderedVisibleIds.size(), [])]), AssignmentExpression(=, [VariableReference(for (int i, []), Expression(0, [])]), Statement(i < numVisibleTrackedIds, []), Statement(i++) {, []), AssignmentExpression(=, [VariableReference(final AutofillId id, []), Expression(orderedVisibleIds.get(i), [])]), Statement(if (isVisible[i]) {, []), AssignmentExpression(=, [VariableReference(updatedVisibleTrackedIds, []), Expression(addToSet(updatedVisibleTrackedIds, id), [])]), Statement(} else {, []), AssignmentExpression(=, [VariableReference(updatedInvisibleTrackedIds, []), Expression(addToSet(updatedInvisibleTrackedIds, id), [])]), Statement(if (sDebug) {, []), MethodCall(Log.d(TAG, ""onVisibleForAutofill() "" + id + "" became invisible""), [VariableReference(Log, []), Expression(TAG, []), Expression(""onVisibleForAutofill() "" + id + "" became invisible"", [])]), Statement(}, []), Statement(}, []), Statement(}, []), Statement(}, []), AssignmentExpression(=, [VariableReference(mInvisibleTrackedIds, []), Expression(updatedInvisibleTrackedIds, [])]), AssignmentExpression(=, [VariableReference(mVisibleTrackedIds, []), Expression(updatedVisibleTrackedIds, [])]), Statement(}, []), AssignmentExpression(=, [VariableReference(if (mVisibleTrackedIds, []), Expression(, [])]), Statement(if (sVerbose) {, []), MethodCall(Log.v(TAG, ""onVisibleForAutofillChangedLocked(): no more visible ids""), [VariableReference(Log, []), Expression(TAG, []), Expression(""onVisibleForAutofillChangedLocked(): no more visible ids"", [])]), Statement(}, []), Statement(finishSessionLocked(), []), Statement(}, []), Statement(}, [])])  Statement({, [])  Statement(// The visibility of the views might have changed while the client was not be visible,, [])  Statement(// hence update the visibility state for all views., [])  AssignmentExpression(=, [VariableReference(AutofillClient client, []), Expression(getClient(), [])])    VariableReference(AutofillClient client, [])    Expression(getClient(), [])  AssignmentExpression(=, [VariableReference(ArraySet<AutofillId> updatedVisibleTrackedIds, []), Expression(null, [])])    VariableReference(ArraySet<AutofillId> updatedVisibleTrackedIds, [])    Expression(null, [])  AssignmentExpression(=, [VariableReference(ArraySet<AutofillId> updatedInvisibleTrackedIds, []), Expression(null, [])])    VariableReference(ArraySet<AutofillId> updatedInvisibleTrackedIds, [])    Expression(null, [])  AssignmentExpression(=, [VariableReference(if (client !, []), Expression(null) {, [])])    VariableReference(if (client !, [])    Expression(null) {, [])  Statement(if (sVerbose) {, [])  AssignmentExpression(=, [VariableReference(Log.v(TAG, ""onVisibleForAutofillChangedLocked(): inv, []), Expression("" + mInvisibleTrackedIds + "" vis, [])])    VariableReference(Log.v(TAG, ""onVisibleForAutofillChangedLocked(): inv, [])    Expression("" + mInvisibleTrackedIds + "" vis, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(if (mInvisibleTrackedIds !, []), Expression(null) {, [])])    VariableReference(if (mInvisibleTrackedIds !, [])    Expression(null) {, [])  AssignmentExpression(=, [VariableReference(final ArrayList<AutofillId> orderedInvisibleIds, []), Expression(new ArrayList<>(mInvisibleTrackedIds), [])])    VariableReference(final ArrayList<AutofillId> orderedInvisibleIds, [])    Expression(new ArrayList<>(mInvisibleTrackedIds), [])  AssignmentExpression(=, [VariableReference(final boolean[] isVisible, []), Expression(client.autofillClientGetViewVisibility(Helper.toArray(orderedInvisibleIds)), [])])    VariableReference(final boolean[] isVisible, [])    Expression(client.autofillClientGetViewVisibility(Helper.toArray(orderedInvisibleIds)), [])  AssignmentExpression(=, [VariableReference(final int numInvisibleTrackedIds, []), Expression(orderedInvisibleIds.size(), [])])    VariableReference(final int numInvisibleTrackedIds, [])    Expression(orderedInvisibleIds.size(), [])  AssignmentExpression(=, [VariableReference(for (int i, []), Expression(0, [])])    VariableReference(for (int i, [])    Expression(0, [])  Statement(i < numInvisibleTrackedIds, [])  Statement(i++) {, [])  AssignmentExpression(=, [VariableReference(final AutofillId id, []), Expression(orderedInvisibleIds.get(i), [])])    VariableReference(final AutofillId id, [])    Expression(orderedInvisibleIds.get(i), [])  Statement(if (isVisible[i]) {, [])  AssignmentExpression(=, [VariableReference(updatedVisibleTrackedIds, []), Expression(addToSet(updatedVisibleTrackedIds, id), [])])    VariableReference(updatedVisibleTrackedIds, [])    Expression(addToSet(updatedVisibleTrackedIds, id), [])  Statement(if (sDebug) {, [])  MethodCall(Log.d(TAG, ""onVisibleForAutofill() "" + id + "" became visible""), [VariableReference(Log, []), Expression(TAG, []), Expression(""onVisibleForAutofill() "" + id + "" became visible"", [])])    VariableReference(Log, [])    Expression(TAG, [])    Expression(""onVisibleForAutofill() "" + id + "" became visible"", [])  Statement(}, [])  Statement(} else {, [])  AssignmentExpression(=, [VariableReference(updatedInvisibleTrackedIds, []), Expression(addToSet(updatedInvisibleTrackedIds, id), [])])    VariableReference(updatedInvisibleTrackedIds, [])    Expression(addToSet(updatedInvisibleTrackedIds, id), [])  Statement(}, [])  Statement(}, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(if (mVisibleTrackedIds !, []), Expression(null) {, [])])    VariableReference(if (mVisibleTrackedIds !, [])    Expression(null) {, [])  AssignmentExpression(=, [VariableReference(final ArrayList<AutofillId> orderedVisibleIds, []), Expression(new ArrayList<>(mVisibleTrackedIds), [])])    VariableReference(final ArrayList<AutofillId> orderedVisibleIds, [])    Expression(new ArrayList<>(mVisibleTrackedIds), [])  AssignmentExpression(=, [VariableReference(final boolean[] isVisible, []), Expression(client.autofillClientGetViewVisibility(Helper.toArray(orderedVisibleIds)), [])])    VariableReference(final boolean[] isVisible, [])    Expression(client.autofillClientGetViewVisibility(Helper.toArray(orderedVisibleIds)), [])  AssignmentExpression(=, [VariableReference(final int numVisibleTrackedIds, []), Expression(orderedVisibleIds.size(), [])])    VariableReference(final int numVisibleTrackedIds, [])    Expression(orderedVisibleIds.size(), [])  AssignmentExpression(=, [VariableReference(for (int i, []), Expression(0, [])])    VariableReference(for (int i, [])    Expression(0, [])  Statement(i < numVisibleTrackedIds, [])  Statement(i++) {, [])  AssignmentExpression(=, [VariableReference(final AutofillId id, []), Expression(orderedVisibleIds.get(i), [])])    VariableReference(final AutofillId id, [])    Expression(orderedVisibleIds.get(i), [])  Statement(if (isVisible[i]) {, [])  AssignmentExpression(=, [VariableReference(updatedVisibleTrackedIds, []), Expression(addToSet(updatedVisibleTrackedIds, id), [])])    VariableReference(updatedVisibleTrackedIds, [])    Expression(addToSet(updatedVisibleTrackedIds, id), [])  Statement(} else {, [])  AssignmentExpression(=, [VariableReference(updatedInvisibleTrackedIds, []), Expression(addToSet(updatedInvisibleTrackedIds, id), [])])    VariableReference(updatedInvisibleTrackedIds, [])    Expression(addToSet(updatedInvisibleTrackedIds, id), [])  Statement(if (sDebug) {, [])  MethodCall(Log.d(TAG, ""onVisibleForAutofill() "" + id + "" became invisible""), [VariableReference(Log, []), Expression(TAG, []), Expression(""onVisibleForAutofill() "" + id + "" became invisible"", [])])    VariableReference(Log, [])    Expression(TAG, [])    Expression(""onVisibleForAutofill() "" + id + "" became invisible"", [])  Statement(}, [])  Statement(}, [])  Statement(}, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(mInvisibleTrackedIds, []), Expression(updatedInvisibleTrackedIds, [])])    VariableReference(mInvisibleTrackedIds, [])    Expression(updatedInvisibleTrackedIds, [])  AssignmentExpression(=, [VariableReference(mVisibleTrackedIds, []), Expression(updatedVisibleTrackedIds, [])])    VariableReference(mVisibleTrackedIds, [])    Expression(updatedVisibleTrackedIds, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(if (mVisibleTrackedIds, []), Expression(, [])])    VariableReference(if (mVisibleTrackedIds, [])    Expression(, [])  Statement(if (sVerbose) {, [])  MethodCall(Log.v(TAG, ""onVisibleForAutofillChangedLocked(): no more visible ids""), [VariableReference(Log, []), Expression(TAG, []), Expression(""onVisibleForAutofillChangedLocked(): no more visible ids"", [])])    VariableReference(Log, [])    Expression(TAG, [])    Expression(""onVisibleForAutofillChangedLocked(): no more visible ids"", [])  Statement(}, [])  Statement(finishSessionLocked(), [])  Statement(}, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(// The visibility of the views might have changed while the client was not be visible,, []), Statement(// hence update the visibility state for all views., []), AssignmentExpression(=, [VariableReference(AutofillClient client, []), Expression(getClient(), [])]), AssignmentExpression(=, [VariableReference(ArraySet<AutofillId> updatedVisibleTrackedIds, []), Expression(null, [])]), AssignmentExpression(=, [VariableReference(ArraySet<AutofillId> updatedInvisibleTrackedIds, []), Expression(null, [])]), AssignmentExpression(=, [VariableReference(if (client !, []), Expression(null) {, [])]), Statement(if (sVerbose) {, []), AssignmentExpression(=, [VariableReference(Log.v(TAG, ""onVisibleForAutofillChangedLocked(): inv, []), Expression("" + mInvisibleTrackedIds + "" vis, [])]), Statement(}, []), AssignmentExpression(=, [VariableReference(if (mInvisibleTrackedIds !, []), Expression(null) {, [])]), AssignmentExpression(=, [VariableReference(final ArrayList<AutofillId> orderedInvisibleIds, []), Expression(new ArrayList<>(mInvisibleTrackedIds), [])]), AssignmentExpression(=, [VariableReference(final boolean[] isVisible, []), Expression(client.autofillClientGetViewVisibility(Helper.toArray(orderedInvisibleIds)), [])]), AssignmentExpression(=, [VariableReference(final int numInvisibleTrackedIds, []), Expression(orderedInvisibleIds.size(), [])]), AssignmentExpression(=, [VariableReference(for (int i, []), Expression(0, [])]), Statement(i < numInvisibleTrackedIds, []), Statement(i++) {, []), AssignmentExpression(=, [VariableReference(final AutofillId id, []), Expression(orderedInvisibleIds.get(i), [])]), Statement(if (isVisible[i]) {, []), AssignmentExpression(=, [VariableReference(updatedVisibleTrackedIds, []), Expression(addToSet(updatedVisibleTrackedIds, id), [])]), Statement(if (sDebug) {, []), MethodCall(Log.d(TAG, ""onVisibleForAutofill() "" + id + "" became visible""), [VariableReference(Log, []), Expression(TAG, []), Expression(""onVisibleForAutofill() "" + id + "" became visible"", [])]), Statement(}, []), Statement(} else {, []), AssignmentExpression(=, [VariableReference(updatedInvisibleTrackedIds, []), Expression(addToSet(updatedInvisibleTrackedIds, id), [])]), Statement(}, []), Statement(}, []), Statement(}, []), AssignmentExpression(=, [VariableReference(if (mVisibleTrackedIds !, []), Expression(null) {, [])]), AssignmentExpression(=, [VariableReference(final ArrayList<AutofillId> orderedVisibleIds, []), Expression(new ArrayList<>(mVisibleTrackedIds), [])]), AssignmentExpression(=, [VariableReference(final boolean[] isVisible, []), Expression(client.autofillClientGetViewVisibility(Helper.toArray(orderedVisibleIds)), [])]), AssignmentExpression(=, [VariableReference(final int numVisibleTrackedIds, []), Expression(orderedVisibleIds.size(), [])]), AssignmentExpression(=, [VariableReference(for (int i, []), Expression(0, [])]), Statement(i < numVisibleTrackedIds, []), Statement(i++) {, []), AssignmentExpression(=, [VariableReference(final AutofillId id, []), Expression(orderedVisibleIds.get(i), [])]), Statement(if (isVisible[i]) {, []), AssignmentExpression(=, [VariableReference(updatedVisibleTrackedIds, []), Expression(addToSet(updatedVisibleTrackedIds, id), [])]), Statement(} else {, []), AssignmentExpression(=, [VariableReference(updatedInvisibleTrackedIds, []), Expression(addToSet(updatedInvisibleTrackedIds, id), [])]), Statement(if (sDebug) {, []), MethodCall(Log.d(TAG, ""onVisibleForAutofill() "" + id + "" became invisible""), [VariableReference(Log, []), Expression(TAG, []), Expression(""onVisibleForAutofill() "" + id + "" became invisible"", [])]), Statement(}, []), Statement(}, []), Statement(}, []), Statement(}, []), AssignmentExpression(=, [VariableReference(mInvisibleTrackedIds, []), Expression(updatedInvisibleTrackedIds, [])]), AssignmentExpression(=, [VariableReference(mVisibleTrackedIds, []), Expression(updatedVisibleTrackedIds, [])]), Statement(}, []), AssignmentExpression(=, [VariableReference(if (mVisibleTrackedIds, []), Expression(, [])]), Statement(if (sVerbose) {, []), MethodCall(Log.v(TAG, ""onVisibleForAutofillChangedLocked(): no more visible ids""), [VariableReference(Log, []), Expression(TAG, []), Expression(""onVisibleForAutofillChangedLocked(): no more visible ids"", [])]), Statement(}, []), AssignmentExpression(=, [VariableReference(finishSessionLocked(/* commitReason, []), Expression(*/, [])]), Statement(COMMIT_REASON_VIEW_CHANGED), []), Statement(}, []), Statement(}, [])])  Statement({, [])  Statement(// The visibility of the views might have changed while the client was not be visible,, [])  Statement(// hence update the visibility state for all views., [])  AssignmentExpression(=, [VariableReference(AutofillClient client, []), Expression(getClient(), [])])    VariableReference(AutofillClient client, [])    Expression(getClient(), [])  AssignmentExpression(=, [VariableReference(ArraySet<AutofillId> updatedVisibleTrackedIds, []), Expression(null, [])])    VariableReference(ArraySet<AutofillId> updatedVisibleTrackedIds, [])    Expression(null, [])  AssignmentExpression(=, [VariableReference(ArraySet<AutofillId> updatedInvisibleTrackedIds, []), Expression(null, [])])    VariableReference(ArraySet<AutofillId> updatedInvisibleTrackedIds, [])    Expression(null, [])  AssignmentExpression(=, [VariableReference(if (client !, []), Expression(null) {, [])])    VariableReference(if (client !, [])    Expression(null) {, [])  Statement(if (sVerbose) {, [])  AssignmentExpression(=, [VariableReference(Log.v(TAG, ""onVisibleForAutofillChangedLocked(): inv, []), Expression("" + mInvisibleTrackedIds + "" vis, [])])    VariableReference(Log.v(TAG, ""onVisibleForAutofillChangedLocked(): inv, [])    Expression("" + mInvisibleTrackedIds + "" vis, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(if (mInvisibleTrackedIds !, []), Expression(null) {, [])])    VariableReference(if (mInvisibleTrackedIds !, [])    Expression(null) {, [])  AssignmentExpression(=, [VariableReference(final ArrayList<AutofillId> orderedInvisibleIds, []), Expression(new ArrayList<>(mInvisibleTrackedIds), [])])    VariableReference(final ArrayList<AutofillId> orderedInvisibleIds, [])    Expression(new ArrayList<>(mInvisibleTrackedIds), [])  AssignmentExpression(=, [VariableReference(final boolean[] isVisible, []), Expression(client.autofillClientGetViewVisibility(Helper.toArray(orderedInvisibleIds)), [])])    VariableReference(final boolean[] isVisible, [])    Expression(client.autofillClientGetViewVisibility(Helper.toArray(orderedInvisibleIds)), [])  AssignmentExpression(=, [VariableReference(final int numInvisibleTrackedIds, []), Expression(orderedInvisibleIds.size(), [])])    VariableReference(final int numInvisibleTrackedIds, [])    Expression(orderedInvisibleIds.size(), [])  AssignmentExpression(=, [VariableReference(for (int i, []), Expression(0, [])])    VariableReference(for (int i, [])    Expression(0, [])  Statement(i < numInvisibleTrackedIds, [])  Statement(i++) {, [])  AssignmentExpression(=, [VariableReference(final AutofillId id, []), Expression(orderedInvisibleIds.get(i), [])])    VariableReference(final AutofillId id, [])    Expression(orderedInvisibleIds.get(i), [])  Statement(if (isVisible[i]) {, [])  AssignmentExpression(=, [VariableReference(updatedVisibleTrackedIds, []), Expression(addToSet(updatedVisibleTrackedIds, id), [])])    VariableReference(updatedVisibleTrackedIds, [])    Expression(addToSet(updatedVisibleTrackedIds, id), [])  Statement(if (sDebug) {, [])  MethodCall(Log.d(TAG, ""onVisibleForAutofill() "" + id + "" became visible""), [VariableReference(Log, []), Expression(TAG, []), Expression(""onVisibleForAutofill() "" + id + "" became visible"", [])])    VariableReference(Log, [])    Expression(TAG, [])    Expression(""onVisibleForAutofill() "" + id + "" became visible"", [])  Statement(}, [])  Statement(} else {, [])  AssignmentExpression(=, [VariableReference(updatedInvisibleTrackedIds, []), Expression(addToSet(updatedInvisibleTrackedIds, id), [])])    VariableReference(updatedInvisibleTrackedIds, [])    Expression(addToSet(updatedInvisibleTrackedIds, id), [])  Statement(}, [])  Statement(}, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(if (mVisibleTrackedIds !, []), Expression(null) {, [])])    VariableReference(if (mVisibleTrackedIds !, [])    Expression(null) {, [])  AssignmentExpression(=, [VariableReference(final ArrayList<AutofillId> orderedVisibleIds, []), Expression(new ArrayList<>(mVisibleTrackedIds), [])])    VariableReference(final ArrayList<AutofillId> orderedVisibleIds, [])    Expression(new ArrayList<>(mVisibleTrackedIds), [])  AssignmentExpression(=, [VariableReference(final boolean[] isVisible, []), Expression(client.autofillClientGetViewVisibility(Helper.toArray(orderedVisibleIds)), [])])    VariableReference(final boolean[] isVisible, [])    Expression(client.autofillClientGetViewVisibility(Helper.toArray(orderedVisibleIds)), [])  AssignmentExpression(=, [VariableReference(final int numVisibleTrackedIds, []), Expression(orderedVisibleIds.size(), [])])    VariableReference(final int numVisibleTrackedIds, [])    Expression(orderedVisibleIds.size(), [])  AssignmentExpression(=, [VariableReference(for (int i, []), Expression(0, [])])    VariableReference(for (int i, [])    Expression(0, [])  Statement(i < numVisibleTrackedIds, [])  Statement(i++) {, [])  AssignmentExpression(=, [VariableReference(final AutofillId id, []), Expression(orderedVisibleIds.get(i), [])])    VariableReference(final AutofillId id, [])    Expression(orderedVisibleIds.get(i), [])  Statement(if (isVisible[i]) {, [])  AssignmentExpression(=, [VariableReference(updatedVisibleTrackedIds, []), Expression(addToSet(updatedVisibleTrackedIds, id), [])])    VariableReference(updatedVisibleTrackedIds, [])    Expression(addToSet(updatedVisibleTrackedIds, id), [])  Statement(} else {, [])  AssignmentExpression(=, [VariableReference(updatedInvisibleTrackedIds, []), Expression(addToSet(updatedInvisibleTrackedIds, id), [])])    VariableReference(updatedInvisibleTrackedIds, [])    Expression(addToSet(updatedInvisibleTrackedIds, id), [])  Statement(if (sDebug) {, [])  MethodCall(Log.d(TAG, ""onVisibleForAutofill() "" + id + "" became invisible""), [VariableReference(Log, []), Expression(TAG, []), Expression(""onVisibleForAutofill() "" + id + "" became invisible"", [])])    VariableReference(Log, [])    Expression(TAG, [])    Expression(""onVisibleForAutofill() "" + id + "" became invisible"", [])  Statement(}, [])  Statement(}, [])  Statement(}, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(mInvisibleTrackedIds, []), Expression(updatedInvisibleTrackedIds, [])])    VariableReference(mInvisibleTrackedIds, [])    Expression(updatedInvisibleTrackedIds, [])  AssignmentExpression(=, [VariableReference(mVisibleTrackedIds, []), Expression(updatedVisibleTrackedIds, [])])    VariableReference(mVisibleTrackedIds, [])    Expression(updatedVisibleTrackedIds, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(if (mVisibleTrackedIds, []), Expression(, [])])    VariableReference(if (mVisibleTrackedIds, [])    Expression(, [])  Statement(if (sVerbose) {, [])  MethodCall(Log.v(TAG, ""onVisibleForAutofillChangedLocked(): no more visible ids""), [VariableReference(Log, []), Expression(TAG, []), Expression(""onVisibleForAutofillChangedLocked(): no more visible ids"", [])])    VariableReference(Log, [])    Expression(TAG, [])    Expression(""onVisibleForAutofillChangedLocked(): no more visible ids"", [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(finishSessionLocked(/* commitReason, []), Expression(*/, [])])    VariableReference(finishSessionLocked(/* commitReason, [])    Expression(*/, [])  Statement(COMMIT_REASON_VIEW_CHANGED), [])  Statement(}, [])  Statement(}, [])",1,"/**
 * Called once the client becomes visible.
 *
 * @see AutofillClient#autofillClientIsVisibleForAutofill()
 */
","/**
 * Called once the client becomes visible.
 *
 * @see AutofillClient#autofillClientIsVisibleForAutofill()
 */
",0,[@GuardedBy("mLock")],[@GuardedBy("mLock")],0,,,,2,5,0,4,0,"A commit reason (`COMMIT_REASON_VIEW_CHANGED`) was added to the `finishSessionLocked` call in the late implementation. This change affects the log message rather than the core logic of the method. Therefore, the change type is 4.","The change is related to a logging statement and does not impact the return value or exception handling of the method. Thus, there is no compatibility issue, and the CI type is 0."
35,"<android.os.Vibrator: void vibrate(long[],int,AudioAttributes)>",32,33,,,,"MethodDeclaration(method_body, [Statement({, []), Statement(// exceptions for compatibility purposes, []), AssignmentExpression(=, [VariableReference(if (repeat < -1 || repeat >, []), Expression(pattern.length) {, [])]), AssignmentExpression(=, [VariableReference(Log.e(TAG, ""vibrate called with repeat index out of bounds"" + "" (pattern.length, []), Expression("" + pattern.length + "", index, [])]), Statement(throw new ArrayIndexOutOfBoundsException(), []), Statement(}, []), Statement(try {, []), MethodCall(vibrate(VibrationEffect.createWaveform(pattern, repeat), attributes), [VariableReference(vibrate(VibrationEffect, []), Expression(pattern, []), Expression(repeat), []), Expression(attributes, [])]), Statement(} catch (IllegalArgumentException iae) {, []), MethodCall(Log.e(TAG, ""Failed to create VibrationEffect"", iae), [VariableReference(Log, []), Expression(TAG, []), Expression(""Failed to create VibrationEffect"", []), Expression(iae, [])]), Statement(}, []), Statement(}, [])])  Statement({, [])  Statement(// exceptions for compatibility purposes, [])  AssignmentExpression(=, [VariableReference(if (repeat < -1 || repeat >, []), Expression(pattern.length) {, [])])    VariableReference(if (repeat < -1 || repeat >, [])    Expression(pattern.length) {, [])  AssignmentExpression(=, [VariableReference(Log.e(TAG, ""vibrate called with repeat index out of bounds"" + "" (pattern.length, []), Expression("" + pattern.length + "", index, [])])    VariableReference(Log.e(TAG, ""vibrate called with repeat index out of bounds"" + "" (pattern.length, [])    Expression("" + pattern.length + "", index, [])  Statement(throw new ArrayIndexOutOfBoundsException(), [])  Statement(}, [])  Statement(try {, [])  MethodCall(vibrate(VibrationEffect.createWaveform(pattern, repeat), attributes), [VariableReference(vibrate(VibrationEffect, []), Expression(pattern, []), Expression(repeat), []), Expression(attributes, [])])    VariableReference(vibrate(VibrationEffect, [])    Expression(pattern, [])    Expression(repeat), [])    Expression(attributes, [])  Statement(} catch (IllegalArgumentException iae) {, [])  MethodCall(Log.e(TAG, ""Failed to create VibrationEffect"", iae), [VariableReference(Log, []), Expression(TAG, []), Expression(""Failed to create VibrationEffect"", []), Expression(iae, [])])    VariableReference(Log, [])    Expression(TAG, [])    Expression(""Failed to create VibrationEffect"", [])    Expression(iae, [])  Statement(}, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(// exceptions for compatibility purposes, []), AssignmentExpression(=, [VariableReference(if (repeat < -1 || repeat >, []), Expression(pattern.length) {, [])]), AssignmentExpression(=, [VariableReference(Log.e(TAG, ""vibrate called with repeat index out of bounds"" + "" (pattern.length, []), Expression("" + pattern.length + "", index, [])]), Statement(throw new ArrayIndexOutOfBoundsException(), []), Statement(}, []), Statement(try {, []), MethodCall(vibrate(VibrationEffect.createWaveform(pattern, repeat), attributes), [VariableReference(vibrate(VibrationEffect, []), Expression(pattern, []), Expression(repeat), []), Expression(attributes, [])]), Statement(} catch (IllegalArgumentException iae) {, []), MethodCall(Log.e(TAG, ""Failed to create VibrationEffect"", iae), [VariableReference(Log, []), Expression(TAG, []), Expression(""Failed to create VibrationEffect"", []), Expression(iae, [])]), Statement(}, []), Statement(}, [])])  Statement({, [])  Statement(// exceptions for compatibility purposes, [])  AssignmentExpression(=, [VariableReference(if (repeat < -1 || repeat >, []), Expression(pattern.length) {, [])])    VariableReference(if (repeat < -1 || repeat >, [])    Expression(pattern.length) {, [])  AssignmentExpression(=, [VariableReference(Log.e(TAG, ""vibrate called with repeat index out of bounds"" + "" (pattern.length, []), Expression("" + pattern.length + "", index, [])])    VariableReference(Log.e(TAG, ""vibrate called with repeat index out of bounds"" + "" (pattern.length, [])    Expression("" + pattern.length + "", index, [])  Statement(throw new ArrayIndexOutOfBoundsException(), [])  Statement(}, [])  Statement(try {, [])  MethodCall(vibrate(VibrationEffect.createWaveform(pattern, repeat), attributes), [VariableReference(vibrate(VibrationEffect, []), Expression(pattern, []), Expression(repeat), []), Expression(attributes, [])])    VariableReference(vibrate(VibrationEffect, [])    Expression(pattern, [])    Expression(repeat), [])    Expression(attributes, [])  Statement(} catch (IllegalArgumentException iae) {, [])  MethodCall(Log.e(TAG, ""Failed to create VibrationEffect"", iae), [VariableReference(Log, []), Expression(TAG, []), Expression(""Failed to create VibrationEffect"", []), Expression(iae, [])])    VariableReference(Log, [])    Expression(TAG, [])    Expression(""Failed to create VibrationEffect"", [])    Expression(iae, [])  Statement(}, [])  Statement(}, [])",0,"/**
 * Vibrate with a given pattern.
 *
 * <p>
 * Pass in an array of ints that are the durations for which to turn on or off
 * the vibrator in milliseconds.  The first value indicates the number of milliseconds
 * to wait before turning the vibrator on.  The next value indicates the number of milliseconds
 * for which to keep the vibrator on before turning it off.  Subsequent values alternate
 * between durations in milliseconds to turn the vibrator off or to turn the vibrator on.
 * </p><p>
 * To cause the pattern to repeat, pass the index into the pattern array at which
 * to start the repeat, or -1 to disable repeating.
 * </p>
 *
 * @param pattern    an array of longs of times for which to turn the vibrator on or off.
 * @param repeat     the index into pattern at which to repeat, or -1 if
 * you don't want to repeat.
 * @param attributes {@link AudioAttributes} corresponding to the vibration. For example,
 * specify {@link AudioAttributes#USAGE_ALARM} for alarm vibrations or
 * {@link AudioAttributes#USAGE_NOTIFICATION_RINGTONE} for
 * vibrations associated with incoming calls.
 * @deprecated Use {@link #vibrate(VibrationEffect, AudioAttributes)} instead.
 */
","/**
 * Vibrate with a given pattern.
 *
 * <p>
 * Pass in an array of ints that are the durations for which to turn on or off
 * the vibrator in milliseconds.  The first value indicates the number of milliseconds
 * to wait before turning the vibrator on.  The next value indicates the number of milliseconds
 * for which to keep the vibrator on before turning it off.  Subsequent values alternate
 * between durations in milliseconds to turn the vibrator off or to turn the vibrator on.
 * </p><p>
 * To cause the pattern to repeat, pass the index into the pattern array at which
 * to start the repeat, or -1 to disable repeating.
 * </p>
 *
 * <p>The app should be in the foreground for the vibration to happen. Background apps should
 * specify a ringtone, notification or alarm usage in order to vibrate.</p>
 *
 * @param pattern    an array of longs of times for which to turn the vibrator on or off.
 * @param repeat     the index into pattern at which to repeat, or -1 if
 * you don't want to repeat.
 * @param attributes {@link AudioAttributes} corresponding to the vibration. For example,
 * specify {@link AudioAttributes#USAGE_ALARM} for alarm vibrations or
 * {@link AudioAttributes#USAGE_NOTIFICATION_RINGTONE} for
 * vibrations associated with incoming calls.
 * @deprecated Use {@link #vibrate(VibrationEffect, VibrationAttributes)} instead.
 */
",1,"[@Deprecated, @RequiresPermission(android.Manifest.permission.VIBRATE)]","[@Deprecated, @RequiresPermission(android.Manifest.permission.VIBRATE)]",0,,,,0,0,0,0,0,"There was no change between the early and late versions of the method implementation in the AST nodes provided. The comments and annotations remain the same, and there are no changes in the method body.",No compatibility issues exist because there were no changes that could lead to different return values or exception handling.
36,<android.companion.AssociationRequest.Builder: Builder setSingleDevice(boolean)>,32,33,,,,"MethodDeclaration(method_body, [Statement({, []), Statement(checkNotUsed(), []), AssignmentExpression(=, [VariableReference(this.mSingleDevice, []), Expression(singleDevice, [])]), Statement(return this, []), Statement(}, [])])  Statement({, [])  Statement(checkNotUsed(), [])  AssignmentExpression(=, [VariableReference(this.mSingleDevice, []), Expression(singleDevice, [])])    VariableReference(this.mSingleDevice, [])    Expression(singleDevice, [])  Statement(return this, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(checkNotUsed(), []), AssignmentExpression(=, [VariableReference(this.mSingleDevice, []), Expression(singleDevice, [])]), Statement(return this, []), Statement(}, [])])  Statement({, [])  Statement(checkNotUsed(), [])  AssignmentExpression(=, [VariableReference(this.mSingleDevice, []), Expression(singleDevice, [])])    VariableReference(this.mSingleDevice, [])    Expression(singleDevice, [])  Statement(return this, [])  Statement(}, [])",0,"/**
 * Whether only a single device should match the provided filter.
 *
 * When scanning for a single device with a specifc {@link BluetoothDeviceFilter} mac
 * address, bonded devices are also searched among. This allows to obtain the necessary app
 * privileges even if the device is already paired.
 *
 * @param singleDevice if true, scanning for a device will stop as soon as at least one
 * fitting device is found
 */
","/**
 * Whether only a single device should match the provided filter.
 *
 * When scanning for a single device with a specific {@link BluetoothDeviceFilter} mac
 * address, bonded devices are also searched among. This allows to obtain the necessary app
 * privileges even if the device is already paired.
 *
 * @param singleDevice if true, scanning for a device will stop as soon as at least one
 * fitting device is found
 */
",1,[@NonNull],[@NonNull],0,,,,0,0,0,0,0,"There are no changes in the method implementation, comments, or annotations between the early and late versions, so the code change type is 0.","Since there are no changes in the method implementation, there is no potential for different behaviors between the two versions, and thus no Compatibility Issues exist."
37,<android.app.Activity: void onLowMemory()>,32,33,,,,"MethodDeclaration(method_body, [Statement({, []), Statement(if (DEBUG_LIFECYCLE), []), MethodCall(Slog.v(TAG, ""onLowMemory "" + this), [VariableReference(Slog, []), Expression(TAG, []), Expression(""onLowMemory "" + this, [])]), AssignmentExpression(=, [VariableReference(mCalled, []), Expression(true, [])]), MethodCall(mFragments.dispatchLowMemory(), [VariableReference(mFragments, []), Expression(, [])]), Statement(}, [])])  Statement({, [])  Statement(if (DEBUG_LIFECYCLE), [])  MethodCall(Slog.v(TAG, ""onLowMemory "" + this), [VariableReference(Slog, []), Expression(TAG, []), Expression(""onLowMemory "" + this, [])])    VariableReference(Slog, [])    Expression(TAG, [])    Expression(""onLowMemory "" + this, [])  AssignmentExpression(=, [VariableReference(mCalled, []), Expression(true, [])])    VariableReference(mCalled, [])    Expression(true, [])  MethodCall(mFragments.dispatchLowMemory(), [VariableReference(mFragments, []), Expression(, [])])    VariableReference(mFragments, [])    Expression(, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(if (DEBUG_LIFECYCLE), []), MethodCall(Slog.v(TAG, ""onLowMemory "" + this), [VariableReference(Slog, []), Expression(TAG, []), Expression(""onLowMemory "" + this, [])]), AssignmentExpression(=, [VariableReference(mCalled, []), Expression(true, [])]), MethodCall(mFragments.dispatchLowMemory(), [VariableReference(mFragments, []), Expression(, [])]), AssignmentExpression(=, [VariableReference(if (mCallbacksController !, []), Expression(null) {, [])]), MethodCall(mCallbacksController.dispatchLowMemory(), [VariableReference(mCallbacksController, []), Expression(, [])]), Statement(}, []), Statement(}, [])])  Statement({, [])  Statement(if (DEBUG_LIFECYCLE), [])  MethodCall(Slog.v(TAG, ""onLowMemory "" + this), [VariableReference(Slog, []), Expression(TAG, []), Expression(""onLowMemory "" + this, [])])    VariableReference(Slog, [])    Expression(TAG, [])    Expression(""onLowMemory "" + this, [])  AssignmentExpression(=, [VariableReference(mCalled, []), Expression(true, [])])    VariableReference(mCalled, [])    Expression(true, [])  MethodCall(mFragments.dispatchLowMemory(), [VariableReference(mFragments, []), Expression(, [])])    VariableReference(mFragments, [])    Expression(, [])  AssignmentExpression(=, [VariableReference(if (mCallbacksController !, []), Expression(null) {, [])])    VariableReference(if (mCallbacksController !, [])    Expression(null) {, [])  MethodCall(mCallbacksController.dispatchLowMemory(), [VariableReference(mCallbacksController, []), Expression(, [])])    VariableReference(mCallbacksController, [])    Expression(, [])  Statement(}, [])  Statement(}, [])",1,,,0,,,0,,,,"1,2","3,4",0,"3,4",1,The late implementation adds a new if statement for mCallbacksController and introduces an additional call to mCallbacksController.dispatchLowMemory(). Changes to control flow indicating 3) Control dependency changed; introduction of a new function call indicates 4) Other statement changed.,"The introduction of a new control dependency and a new function call could lead to different behaviors in the API execution, this may result in the API behaving differently in terms of managing low memory situations so the CI type is 1."
38,"<android.hardware.camera2.params.OutputConfiguration: void writeToParcel(Parcel,int)>",32,33,,,,"MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(if (dest, []), Expression(, [])]), Statement(throw new IllegalArgumentException(""dest must not be null""), []), Statement(}, []), MethodCall(dest.writeInt(mRotation), [VariableReference(dest, []), Expression(mRotation, [])]), MethodCall(dest.writeInt(mSurfaceGroupId), [VariableReference(dest, []), Expression(mSurfaceGroupId, [])]), MethodCall(dest.writeInt(mSurfaceType), [VariableReference(dest, []), Expression(mSurfaceType, [])]), MethodCall(dest.writeInt(mConfiguredSize.getWidth()), [VariableReference(dest, []), Expression(mConfiguredSize.getWidth(), [])]), MethodCall(dest.writeInt(mConfiguredSize.getHeight()), [VariableReference(dest, []), Expression(mConfiguredSize.getHeight(), [])]), MethodCall(dest.writeInt(mIsDeferredConfig ? 1 : 0), [VariableReference(dest, []), Expression(mIsDeferredConfig ? 1 : 0, [])]), MethodCall(dest.writeInt(mIsShared ? 1 : 0), [VariableReference(dest, []), Expression(mIsShared ? 1 : 0, [])]), MethodCall(dest.writeTypedList(mSurfaces), [VariableReference(dest, []), Expression(mSurfaces, [])]), MethodCall(dest.writeString(mPhysicalCameraId), [VariableReference(dest, []), Expression(mPhysicalCameraId, [])]), MethodCall(dest.writeInt(mIsMultiResolution ? 1 : 0), [VariableReference(dest, []), Expression(mIsMultiResolution ? 1 : 0, [])]), Statement(// writeList doesn't seem to work well with Integer list., []), MethodCall(dest.writeIntArray(convertIntegerToIntList(mSensorPixelModesUsed)), [VariableReference(dest, []), Expression(convertIntegerToIntList(mSensorPixelModesUsed), [])]), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(if (dest, []), Expression(, [])])    VariableReference(if (dest, [])    Expression(, [])  Statement(throw new IllegalArgumentException(""dest must not be null""), [])  Statement(}, [])  MethodCall(dest.writeInt(mRotation), [VariableReference(dest, []), Expression(mRotation, [])])    VariableReference(dest, [])    Expression(mRotation, [])  MethodCall(dest.writeInt(mSurfaceGroupId), [VariableReference(dest, []), Expression(mSurfaceGroupId, [])])    VariableReference(dest, [])    Expression(mSurfaceGroupId, [])  MethodCall(dest.writeInt(mSurfaceType), [VariableReference(dest, []), Expression(mSurfaceType, [])])    VariableReference(dest, [])    Expression(mSurfaceType, [])  MethodCall(dest.writeInt(mConfiguredSize.getWidth()), [VariableReference(dest, []), Expression(mConfiguredSize.getWidth(), [])])    VariableReference(dest, [])    Expression(mConfiguredSize.getWidth(), [])  MethodCall(dest.writeInt(mConfiguredSize.getHeight()), [VariableReference(dest, []), Expression(mConfiguredSize.getHeight(), [])])    VariableReference(dest, [])    Expression(mConfiguredSize.getHeight(), [])  MethodCall(dest.writeInt(mIsDeferredConfig ? 1 : 0), [VariableReference(dest, []), Expression(mIsDeferredConfig ? 1 : 0, [])])    VariableReference(dest, [])    Expression(mIsDeferredConfig ? 1 : 0, [])  MethodCall(dest.writeInt(mIsShared ? 1 : 0), [VariableReference(dest, []), Expression(mIsShared ? 1 : 0, [])])    VariableReference(dest, [])    Expression(mIsShared ? 1 : 0, [])  MethodCall(dest.writeTypedList(mSurfaces), [VariableReference(dest, []), Expression(mSurfaces, [])])    VariableReference(dest, [])    Expression(mSurfaces, [])  MethodCall(dest.writeString(mPhysicalCameraId), [VariableReference(dest, []), Expression(mPhysicalCameraId, [])])    VariableReference(dest, [])    Expression(mPhysicalCameraId, [])  MethodCall(dest.writeInt(mIsMultiResolution ? 1 : 0), [VariableReference(dest, []), Expression(mIsMultiResolution ? 1 : 0, [])])    VariableReference(dest, [])    Expression(mIsMultiResolution ? 1 : 0, [])  Statement(// writeList doesn't seem to work well with Integer list., [])  MethodCall(dest.writeIntArray(convertIntegerToIntList(mSensorPixelModesUsed)), [VariableReference(dest, []), Expression(convertIntegerToIntList(mSensorPixelModesUsed), [])])    VariableReference(dest, [])    Expression(convertIntegerToIntList(mSensorPixelModesUsed), [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(if (dest, []), Expression(, [])]), Statement(throw new IllegalArgumentException(""dest must not be null""), []), Statement(}, []), MethodCall(dest.writeInt(mRotation), [VariableReference(dest, []), Expression(mRotation, [])]), MethodCall(dest.writeInt(mSurfaceGroupId), [VariableReference(dest, []), Expression(mSurfaceGroupId, [])]), MethodCall(dest.writeInt(mSurfaceType), [VariableReference(dest, []), Expression(mSurfaceType, [])]), MethodCall(dest.writeInt(mConfiguredSize.getWidth()), [VariableReference(dest, []), Expression(mConfiguredSize.getWidth(), [])]), MethodCall(dest.writeInt(mConfiguredSize.getHeight()), [VariableReference(dest, []), Expression(mConfiguredSize.getHeight(), [])]), MethodCall(dest.writeInt(mIsDeferredConfig ? 1 : 0), [VariableReference(dest, []), Expression(mIsDeferredConfig ? 1 : 0, [])]), MethodCall(dest.writeInt(mIsShared ? 1 : 0), [VariableReference(dest, []), Expression(mIsShared ? 1 : 0, [])]), MethodCall(dest.writeTypedList(mSurfaces), [VariableReference(dest, []), Expression(mSurfaces, [])]), MethodCall(dest.writeString(mPhysicalCameraId), [VariableReference(dest, []), Expression(mPhysicalCameraId, [])]), MethodCall(dest.writeInt(mIsMultiResolution ? 1 : 0), [VariableReference(dest, []), Expression(mIsMultiResolution ? 1 : 0, [])]), Statement(// writeList doesn't seem to work well with Integer list., []), MethodCall(dest.writeIntArray(convertIntegerToIntList(mSensorPixelModesUsed)), [VariableReference(dest, []), Expression(convertIntegerToIntList(mSensorPixelModesUsed), [])]), MethodCall(dest.writeLong(mDynamicRangeProfile), [VariableReference(dest, []), Expression(mDynamicRangeProfile, [])]), MethodCall(dest.writeLong(mStreamUseCase), [VariableReference(dest, []), Expression(mStreamUseCase, [])]), MethodCall(dest.writeInt(mTimestampBase), [VariableReference(dest, []), Expression(mTimestampBase, [])]), MethodCall(dest.writeInt(mMirrorMode), [VariableReference(dest, []), Expression(mMirrorMode, [])]), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(if (dest, []), Expression(, [])])    VariableReference(if (dest, [])    Expression(, [])  Statement(throw new IllegalArgumentException(""dest must not be null""), [])  Statement(}, [])  MethodCall(dest.writeInt(mRotation), [VariableReference(dest, []), Expression(mRotation, [])])    VariableReference(dest, [])    Expression(mRotation, [])  MethodCall(dest.writeInt(mSurfaceGroupId), [VariableReference(dest, []), Expression(mSurfaceGroupId, [])])    VariableReference(dest, [])    Expression(mSurfaceGroupId, [])  MethodCall(dest.writeInt(mSurfaceType), [VariableReference(dest, []), Expression(mSurfaceType, [])])    VariableReference(dest, [])    Expression(mSurfaceType, [])  MethodCall(dest.writeInt(mConfiguredSize.getWidth()), [VariableReference(dest, []), Expression(mConfiguredSize.getWidth(), [])])    VariableReference(dest, [])    Expression(mConfiguredSize.getWidth(), [])  MethodCall(dest.writeInt(mConfiguredSize.getHeight()), [VariableReference(dest, []), Expression(mConfiguredSize.getHeight(), [])])    VariableReference(dest, [])    Expression(mConfiguredSize.getHeight(), [])  MethodCall(dest.writeInt(mIsDeferredConfig ? 1 : 0), [VariableReference(dest, []), Expression(mIsDeferredConfig ? 1 : 0, [])])    VariableReference(dest, [])    Expression(mIsDeferredConfig ? 1 : 0, [])  MethodCall(dest.writeInt(mIsShared ? 1 : 0), [VariableReference(dest, []), Expression(mIsShared ? 1 : 0, [])])    VariableReference(dest, [])    Expression(mIsShared ? 1 : 0, [])  MethodCall(dest.writeTypedList(mSurfaces), [VariableReference(dest, []), Expression(mSurfaces, [])])    VariableReference(dest, [])    Expression(mSurfaces, [])  MethodCall(dest.writeString(mPhysicalCameraId), [VariableReference(dest, []), Expression(mPhysicalCameraId, [])])    VariableReference(dest, [])    Expression(mPhysicalCameraId, [])  MethodCall(dest.writeInt(mIsMultiResolution ? 1 : 0), [VariableReference(dest, []), Expression(mIsMultiResolution ? 1 : 0, [])])    VariableReference(dest, [])    Expression(mIsMultiResolution ? 1 : 0, [])  Statement(// writeList doesn't seem to work well with Integer list., [])  MethodCall(dest.writeIntArray(convertIntegerToIntList(mSensorPixelModesUsed)), [VariableReference(dest, []), Expression(convertIntegerToIntList(mSensorPixelModesUsed), [])])    VariableReference(dest, [])    Expression(convertIntegerToIntList(mSensorPixelModesUsed), [])  MethodCall(dest.writeLong(mDynamicRangeProfile), [VariableReference(dest, []), Expression(mDynamicRangeProfile, [])])    VariableReference(dest, [])    Expression(mDynamicRangeProfile, [])  MethodCall(dest.writeLong(mStreamUseCase), [VariableReference(dest, []), Expression(mStreamUseCase, [])])    VariableReference(dest, [])    Expression(mStreamUseCase, [])  MethodCall(dest.writeInt(mTimestampBase), [VariableReference(dest, []), Expression(mTimestampBase, [])])    VariableReference(dest, [])    Expression(mTimestampBase, [])  MethodCall(dest.writeInt(mMirrorMode), [VariableReference(dest, []), Expression(mMirrorMode, [])])    VariableReference(dest, [])    Expression(mMirrorMode, [])  Statement(}, [])",1,,,0,[@Override],[@Override],0,,,,"1,2",4,0,4,0,Additional method calls (dest.writeLong and dest.writeInt) were added to the late implementation of the `writeToParcel` method without affecting the return values or exception handling. The change type is 4.,"The added method calls do not alter the return values or exceptions thrown by this method. Therefore, no Compatibility Issue exists as it does not result in different behavior regarding return values or exceptions. The CI type is 0."
39,<android.os.BaseBundle: ArrayList<Integer> getIntegerArrayList(String)>,32,33,,,,"MethodDeclaration(method_body, [Statement({, []), Statement(unparcel(), []), AssignmentExpression(=, [VariableReference(Object o, []), Expression(mMap.get(key), [])]), AssignmentExpression(=, [VariableReference(if (o, []), Expression(, [])]), Statement(return null, []), Statement(}, []), Statement(try {, []), Statement(return (ArrayList<Integer>) o, []), Statement(} catch (ClassCastException e) {, []), Statement(typeWarning(key, o, ""ArrayList<Integer>"", e), []), Statement(return null, []), Statement(}, []), Statement(}, [])])  Statement({, [])  Statement(unparcel(), [])  AssignmentExpression(=, [VariableReference(Object o, []), Expression(mMap.get(key), [])])    VariableReference(Object o, [])    Expression(mMap.get(key), [])  AssignmentExpression(=, [VariableReference(if (o, []), Expression(, [])])    VariableReference(if (o, [])    Expression(, [])  Statement(return null, [])  Statement(}, [])  Statement(try {, [])  Statement(return (ArrayList<Integer>) o, [])  Statement(} catch (ClassCastException e) {, [])  Statement(typeWarning(key, o, ""ArrayList<Integer>"", e), [])  Statement(return null, [])  Statement(}, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(}, [])])  Statement({, [])  Statement(}, [])",1,"/**
 * Returns the value associated with the given key, or null if
 * no mapping of the desired type exists for the given key or a null
 * value is explicitly associated with the key.
 *
 * @param key a String, or null
 * @return an ArrayList<String> value, or null
 */
","/**
 * Returns the value associated with the given key, or null if
 * no mapping of the desired type exists for the given key or a null
 * value is explicitly associated with the key.
 *
 * @param key a String, or null
 * @return an ArrayList<String> value, or null
 */
",0,[@Nullable],[@Nullable],0,,,,"1,2","1,2,3,4,5","1,2","1,2","1,2","The early version's implementation includes logic to fetch an object from `mMap`, handle class casting, and return the appropriate value. This entire logic has been removed in the late version, and the method now contains an empty body. This change type is classified as 1 (Return statement changed) and 2 (Exception handling statement changed) because both return behavior and exception handling logic have been altered.","The removal of the core logic will cause the late version to not return the expected value, potentially leading to different return values or types. Additionally, the removal of the `try-catch` block that handles `ClassCastException` means that the method will no longer handle this exception as it did before. Therefore, the CI type is 1 (caused by potential different return values or types) and 2 (caused by potential different exception handlings)."
41,<android.service.dreams.DreamService: void onDreamingStarted()>,32,33,,,,"MethodDeclaration(method_body, [Statement({, []), Statement(if (mDebug), []), MethodCall(Slog.v(TAG, ""onDreamingStarted()""), [VariableReference(Slog, []), Expression(TAG, []), Expression(""onDreamingStarted()"", [])]), Statement(// hook for subclasses, []), Statement(}, [])])  Statement({, [])  Statement(if (mDebug), [])  MethodCall(Slog.v(TAG, ""onDreamingStarted()""), [VariableReference(Slog, []), Expression(TAG, []), Expression(""onDreamingStarted()"", [])])    VariableReference(Slog, [])    Expression(TAG, [])    Expression(""onDreamingStarted()"", [])  Statement(// hook for subclasses, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(if (mDebug), []), MethodCall(Slog.v(mTag, ""onDreamingStarted()""), [VariableReference(Slog, []), Expression(mTag, []), Expression(""onDreamingStarted()"", [])]), Statement(// hook for subclasses, []), Statement(}, [])])  Statement({, [])  Statement(if (mDebug), [])  MethodCall(Slog.v(mTag, ""onDreamingStarted()""), [VariableReference(Slog, []), Expression(mTag, []), Expression(""onDreamingStarted()"", [])])    VariableReference(Slog, [])    Expression(mTag, [])    Expression(""onDreamingStarted()"", [])  Statement(// hook for subclasses, [])  Statement(}, [])",1,"/**
 * Called when the dream's window has been created and is visible and animation may now begin.
 */
","/**
 * Called when the dream's window has been created and is visible and animation may now begin.
 */
",0,,,0,,,,1,4,0,4,0,"The log statement within the `if (mDebug)` block has changed from logging `TAG` to logging `mTag`. This change does not affect the return value or exception handling; thus, it belongs to the ""Other statement changed"" category.","The log statement change does not introduce any potential difference in the return values or exception handling of the method. Therefore, no Compatibility Issue exists."
42,<android.os.PowerComponents.Builder: double getTotalPower()>,32,33,,,,"MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(double totalPowerMah, []), Expression(0, [])]), AssignmentExpression(=, [VariableReference(for (int i, []), Expression(mPowerComponentsMah.length - 1, [])]), AssignmentExpression(=, [VariableReference(i >, []), Expression(0, [])]), Statement(i--) {, []), AssignmentExpression(=, [VariableReference(totalPowerMah +, []), Expression(mPowerComponentsMah[i], [])]), Statement(}, []), Statement(return totalPowerMah, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(double totalPowerMah, []), Expression(0, [])])    VariableReference(double totalPowerMah, [])    Expression(0, [])  AssignmentExpression(=, [VariableReference(for (int i, []), Expression(mPowerComponentsMah.length - 1, [])])    VariableReference(for (int i, [])    Expression(mPowerComponentsMah.length - 1, [])  AssignmentExpression(=, [VariableReference(i >, []), Expression(0, [])])    VariableReference(i >, [])    Expression(0, [])  Statement(i--) {, [])  AssignmentExpression(=, [VariableReference(totalPowerMah +, []), Expression(mPowerComponentsMah[i], [])])    VariableReference(totalPowerMah +, [])    Expression(mPowerComponentsMah[i], [])  Statement(}, [])  Statement(return totalPowerMah, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(double totalPowerMah, []), Expression(0, [])]), AssignmentExpression(=, [VariableReference(for (int componentId, []), Expression(0, [])]), Statement(componentId < BatteryConsumer.POWER_COMPONENT_COUNT, []), Statement(componentId++) {, []), AssignmentExpression(=, [VariableReference(totalPowerMah +, []), Expression(mData.getDouble(mData.getKeyOrThrow(componentId, PROCESS_STATE_ANY).mPowerColumnIndex), [])]), Statement(}, []), AssignmentExpression(=, [VariableReference(for (int i, []), Expression(0, [])]), Statement(i < mData.layout.customPowerComponentCount, []), Statement(i++) {, []), AssignmentExpression(=, [VariableReference(totalPowerMah +, []), Expression(mData.getDouble(mData.layout.firstCustomConsumedPowerColumn + i), [])]), Statement(}, []), Statement(return totalPowerMah, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(double totalPowerMah, []), Expression(0, [])])    VariableReference(double totalPowerMah, [])    Expression(0, [])  AssignmentExpression(=, [VariableReference(for (int componentId, []), Expression(0, [])])    VariableReference(for (int componentId, [])    Expression(0, [])  Statement(componentId < BatteryConsumer.POWER_COMPONENT_COUNT, [])  Statement(componentId++) {, [])  AssignmentExpression(=, [VariableReference(totalPowerMah +, []), Expression(mData.getDouble(mData.getKeyOrThrow(componentId, PROCESS_STATE_ANY).mPowerColumnIndex), [])])    VariableReference(totalPowerMah +, [])    Expression(mData.getDouble(mData.getKeyOrThrow(componentId, PROCESS_STATE_ANY).mPowerColumnIndex), [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(for (int i, []), Expression(0, [])])    VariableReference(for (int i, [])    Expression(0, [])  Statement(i < mData.layout.customPowerComponentCount, [])  Statement(i++) {, [])  AssignmentExpression(=, [VariableReference(totalPowerMah +, []), Expression(mData.getDouble(mData.layout.firstCustomConsumedPowerColumn + i), [])])    VariableReference(totalPowerMah +, [])    Expression(mData.getDouble(mData.layout.firstCustomConsumedPowerColumn + i), [])  Statement(}, [])  Statement(return totalPowerMah, [])  Statement(}, [])",1,"/**
 * Returns the total power accumulated by this builder so far. It may change
 * by the time the {@code build()} method is called.
 */
","/**
 * Returns the total power accumulated by this builder so far. It may change
 * by the time the {@code build()} method is called.
 */
",0,,,0,,,,"1,2","1,3,4",1,"1,3,4,5",1,"The latest version introduces a significant change in the for-loop logic, which includes different conditions and expressions to accumulate `totalPowerMah` from different data structures. This involves both control dependency, other statement changes, and a dependent API change, so the code change types are 1,3,4,5.","The changes in the control flow and data sources from which `totalPowerMah` is accumulated could lead to a different return value. Hence, the CI type is 1."
43,<android.hardware.camera2.CameraDevice: void createExtensionSession(ExtensionSessionConfiguration)>,32,33,,,,"MethodDeclaration(method_body, [Statement({, []), Statement(throw new UnsupportedOperationException(""No default implementation""), []), Statement(}, [])])  Statement({, [])  Statement(throw new UnsupportedOperationException(""No default implementation""), [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(throw new UnsupportedOperationException(""No default implementation""), []), Statement(}, [])])  Statement({, [])  Statement(throw new UnsupportedOperationException(""No default implementation""), [])  Statement(}, [])",0,"/**
 * Initialize a specific device-specific extension augmented camera capture
 * session.
 *
 * <p>Extension sessions can be used to enable device-specific operation modes like
 * {@link CameraExtensionCharacteristics#EXTENSION_NIGHT} or
 * {@link CameraExtensionCharacteristics#EXTENSION_HDR}. These modes are less flexible than the
 * full camera API, but enable access to more sophisticated processing algorithms that can
 * capture multi-frame bursts to generate single output images. To query for available
 * extensions on this device call
 * {@link CameraExtensionCharacteristics#getSupportedExtensions()}.</p>
 *
 * <p>This method will also trigger the setup of the internal
 * processing pipeline for extension augmented preview and multi-frame
 * still capture.</p>
 *
 * <p>If a prior CameraCaptureSession already exists when this method is called, the previous
 * session will no longer be able to accept new capture requests and will be closed. Any
 * in-progress capture requests made on the prior session will be completed before it's closed.
 * </p>
 *
 * <p>The CameraExtensionSession will be active until the client
 * either calls CameraExtensionSession.close() or creates a new camera
 * capture session. In both cases all internal resources will be
 * released, continuous repeating requests stopped and any pending
 * multi-frame capture requests flushed.</p>
 *
 * <p>Note that the CameraExtensionSession currently supports at most wo
 * multi frame capture surface formats: ImageFormat.JPEG will be supported
 * by all extensions and ImageFormat.YUV_420_888 may or may not be supported.
 * Clients must query the multi-frame capture format support using
 * {@link CameraExtensionCharacteristics#getExtensionSupportedSizes(int, int)}.
 * For repeating requests CameraExtensionSession supports only
 * {@link android.graphics.SurfaceTexture} as output. Clients can query the supported resolution
 * for the repeating request output using
 * {@link CameraExtensionCharacteristics#getExtensionSupportedSizes(int, Class)
 * getExtensionSupportedSizes(..., Class)}.</p>
 *
 * <p>At the very minimum the initialization expects either one valid output
 * surface for repeating or one valid output for high-quality single requests registered in the
 * outputs argument of the extension configuration argument. At the maximum the initialization
 * will accept two valid output surfaces, one for repeating and the other for single requests.
 * Additional unsupported surfaces passed to ExtensionSessionConfiguration will cause an
 * {@link IllegalArgumentException} to be thrown.</p>
 *
 * @param extensionConfiguration extension configuration
 * @throws IllegalArgumentException If both the preview and still
 * capture surfaces are not set or invalid, or if any of the
 * registered surfaces do not meet the device-specific
 * extension requirements such as dimensions and/or
 * (output format)/(surface type), or if the extension is not
 * supported.
 * @see CameraExtensionCharacteristics#getSupportedExtensions
 * @see CameraExtensionCharacteristics#getExtensionSupportedSizes
 */
","/**
 * Initialize a specific device-specific extension augmented camera capture
 * session.
 *
 * <p>Extension sessions can be used to enable device-specific operation modes like
 * {@link CameraExtensionCharacteristics#EXTENSION_NIGHT} or
 * {@link CameraExtensionCharacteristics#EXTENSION_HDR}. These modes are less flexible than the
 * full camera API, but enable access to more sophisticated processing algorithms that can
 * capture multi-frame bursts to generate single output images. To query for available
 * extensions on this device call
 * {@link CameraExtensionCharacteristics#getSupportedExtensions()}.</p>
 *
 * <p>This method will also trigger the setup of the internal
 * processing pipeline for extension augmented preview and multi-frame
 * still capture.</p>
 *
 * <p>If a prior CameraCaptureSession already exists when this method is called, the previous
 * session will no longer be able to accept new capture requests and will be closed. Any
 * in-progress capture requests made on the prior session will be completed before it's closed.
 * </p>
 *
 * <p>The CameraExtensionSession will be active until the client
 * either calls CameraExtensionSession.close() or creates a new camera
 * capture session. In both cases all internal resources will be
 * released, continuous repeating requests stopped and any pending
 * multi-frame capture requests flushed.</p>
 *
 * <p>Note that the CameraExtensionSession currently supports at most wo
 * multi frame capture surface formats: ImageFormat.JPEG will be supported
 * by all extensions and ImageFormat.YUV_420_888 may or may not be supported.
 * Clients must query the multi-frame capture format support using
 * {@link CameraExtensionCharacteristics#getExtensionSupportedSizes(int, int)}.
 * For repeating requests CameraExtensionSession supports only
 * {@link android.graphics.SurfaceTexture} as output. Clients can query the supported resolution
 * for the repeating request output using
 * {@link CameraExtensionCharacteristics#getExtensionSupportedSizes(int, Class)
 * getExtensionSupportedSizes(..., Class)}.</p>
 *
 * <p>At the very minimum the initialization expects either one valid output
 * surface for repeating or one valid output for high-quality single requests registered in the
 * outputs argument of the extension configuration argument. At the maximum the initialization
 * will accept two valid output surfaces, one for repeating and the other for single requests.
 * Additional unsupported surfaces passed to ExtensionSessionConfiguration will cause an
 * {@link IllegalArgumentException} to be thrown.</p>
 *
 * @param extensionConfiguration extension configuration
 * @throws IllegalArgumentException If both the preview and still
 * capture surfaces are not set or invalid, or if any of the
 * registered surfaces do not meet the device-specific
 * extension requirements such as dimensions and/or
 * (output format)/(surface type), or if the extension is not
 * supported, or if any of the output configurations select
 * a dynamic range different from
 * {@link android.hardware.camera2.params.DynamicRangeProfiles#STANDARD},
 * or if any of the output configurations sets a stream use
 * case different from {@link
 * android.hardware.camera2.CameraCharacteristics#SCALER_AVAILABLE_STREAM_USE_CASES_DEFAULT}.
 * @see CameraExtensionCharacteristics#getSupportedExtensions
 * @see CameraExtensionCharacteristics#getExtensionSupportedSizes
 */
",1,,,0,,,,0,0,0,0,0,"There are no changes in the method implementation, AST node, annotation between the two versions. The only modification is in the comment, which does not affect the actual behavior of the method.","Since the implementation of the method has not changed and there are no changes in return statements or exception handling, there is no compatibility issue."
44,"<android.text.TextShaper: void shapeText(CharSequence,int,int,TextDirectionHeuristic,TextPaint,GlyphsConsumer)>",32,33,,,,"MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(MeasuredParagraph mp, []), Expression(MeasuredParagraph.buildForBidi(text, start, start + count, dir, null), [])]), AssignmentExpression(=, [VariableReference(TextLine tl, []), Expression(TextLine.obtain(), [])]), Statement(try {, []), MethodCall(tl.set(paint, text, start, start + count, mp.getParagraphDir(), mp.getDirections(0, count), [VariableReference(tl, []), Expression(paint, []), Expression(text, []), Expression(start, []), Expression(start + count, []), Expression(mp.getParagraphDir(), []), Expression(mp.getDirections(0, []), Expression(count, [])]), Statement(null, // ellipsis is not supported., []), Statement(-1, // ellipsis is not supported., []), Statement(-1), []), MethodCall(tl.shape(consumer), [VariableReference(tl, []), Expression(consumer, [])]), Statement(} finally {, []), MethodCall(TextLine.recycle(tl), [VariableReference(TextLine, []), Expression(tl, [])]), Statement(}, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(MeasuredParagraph mp, []), Expression(MeasuredParagraph.buildForBidi(text, start, start + count, dir, null), [])])    VariableReference(MeasuredParagraph mp, [])    Expression(MeasuredParagraph.buildForBidi(text, start, start + count, dir, null), [])  AssignmentExpression(=, [VariableReference(TextLine tl, []), Expression(TextLine.obtain(), [])])    VariableReference(TextLine tl, [])    Expression(TextLine.obtain(), [])  Statement(try {, [])  MethodCall(tl.set(paint, text, start, start + count, mp.getParagraphDir(), mp.getDirections(0, count), [VariableReference(tl, []), Expression(paint, []), Expression(text, []), Expression(start, []), Expression(start + count, []), Expression(mp.getParagraphDir(), []), Expression(mp.getDirections(0, []), Expression(count, [])])    VariableReference(tl, [])    Expression(paint, [])    Expression(text, [])    Expression(start, [])    Expression(start + count, [])    Expression(mp.getParagraphDir(), [])    Expression(mp.getDirections(0, [])    Expression(count, [])  Statement(null, // ellipsis is not supported., [])  Statement(-1, // ellipsis is not supported., [])  Statement(-1), [])  MethodCall(tl.shape(consumer), [VariableReference(tl, []), Expression(consumer, [])])    VariableReference(tl, [])    Expression(consumer, [])  Statement(} finally {, [])  MethodCall(TextLine.recycle(tl), [VariableReference(TextLine, []), Expression(tl, [])])    VariableReference(TextLine, [])    Expression(tl, [])  Statement(}, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(MeasuredParagraph mp, []), Expression(MeasuredParagraph.buildForBidi(text, start, start + count, dir, null), [])]), AssignmentExpression(=, [VariableReference(TextLine tl, []), Expression(TextLine.obtain(), [])]), Statement(try {, []), MethodCall(tl.set(paint, text, start, start + count, mp.getParagraphDir(), mp.getDirections(0, count), [VariableReference(tl, []), Expression(paint, []), Expression(text, []), Expression(start, []), Expression(start + count, []), Expression(mp.getParagraphDir(), []), Expression(mp.getDirections(0, []), Expression(count, [])]), Statement(null, // ellipsis is not supported., []), Statement(-1, // ellipsis is not supported., []), Statement(-1, false), []), MethodCall(tl.shape(consumer), [VariableReference(tl, []), Expression(consumer, [])]), Statement(} finally {, []), MethodCall(TextLine.recycle(tl), [VariableReference(TextLine, []), Expression(tl, [])]), Statement(}, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(MeasuredParagraph mp, []), Expression(MeasuredParagraph.buildForBidi(text, start, start + count, dir, null), [])])    VariableReference(MeasuredParagraph mp, [])    Expression(MeasuredParagraph.buildForBidi(text, start, start + count, dir, null), [])  AssignmentExpression(=, [VariableReference(TextLine tl, []), Expression(TextLine.obtain(), [])])    VariableReference(TextLine tl, [])    Expression(TextLine.obtain(), [])  Statement(try {, [])  MethodCall(tl.set(paint, text, start, start + count, mp.getParagraphDir(), mp.getDirections(0, count), [VariableReference(tl, []), Expression(paint, []), Expression(text, []), Expression(start, []), Expression(start + count, []), Expression(mp.getParagraphDir(), []), Expression(mp.getDirections(0, []), Expression(count, [])])    VariableReference(tl, [])    Expression(paint, [])    Expression(text, [])    Expression(start, [])    Expression(start + count, [])    Expression(mp.getParagraphDir(), [])    Expression(mp.getDirections(0, [])    Expression(count, [])  Statement(null, // ellipsis is not supported., [])  Statement(-1, // ellipsis is not supported., [])  Statement(-1, false), [])  MethodCall(tl.shape(consumer), [VariableReference(tl, []), Expression(consumer, [])])    VariableReference(tl, [])    Expression(consumer, [])  Statement(} finally {, [])  MethodCall(TextLine.recycle(tl), [VariableReference(TextLine, []), Expression(tl, [])])    VariableReference(TextLine, [])    Expression(tl, [])  Statement(}, [])  Statement(}, [])",1,"/**
 * Shape multi-styled text.
 *
 * In the LTR context, the shape result will go from left to right, thus you may want to draw
 * glyphs from left most position of the canvas. In the RTL context, the shape result will go
 * from right to left, thus you may want to draw glyphs from right most position of the canvas.
 *
 * @param text a styled text.
 * @param start a start index of shaping target in the text.
 * @param count a length of shaping target in the text.
 * @param dir a text direction.
 * @param paint a paint
 * @param consumer a consumer of the shape result.
 */
","/**
 * Shape multi-styled text.
 *
 * In the LTR context, the shape result will go from left to right, thus you may want to draw
 * glyphs from left most position of the canvas. In the RTL context, the shape result will go
 * from right to left, thus you may want to draw glyphs from right most position of the canvas.
 *
 * @param text a styled text.
 * @param start a start index of shaping target in the text.
 * @param count a length of shaping target in the text.
 * @param dir a text direction.
 * @param paint a paint
 * @param consumer a consumer of the shape result.
 */
",0,,,0,,,,2,5,0,4,0,"In the late version, there's a change in the statement within the 'try' block. The statement changes from `-1` to `-1, false`. This change does not affect the return value or the exception handling of the method. Hence, the code change type is 4.","Since the change does not impact the return value or exception handling mechanism but rather is an internal adjustment within a method call, there is no Compatibility Issue. Therefore, the CI type is 0."
45,<android.app.admin.DevicePolicyManager: List<ApnSetting> getOverrideApns(ComponentName)>,32,33,,,,"MethodDeclaration(method_body, [Statement({, []), Statement(throwIfParentInstance(""getOverrideApns""), []), AssignmentExpression(=, [VariableReference(if (mService !, []), Expression(null) {, [])]), Statement(try {, []), MethodCall(return mService.getOverrideApns(admin), [VariableReference(return mService, []), Expression(admin, [])]), Statement(} catch (RemoteException e) {, []), MethodCall(throw e.rethrowFromSystemServer(), [VariableReference(throw e, []), Expression(, [])]), Statement(}, []), Statement(}, []), MethodCall(return Collections.emptyList(), [VariableReference(return Collections, []), Expression(, [])]), Statement(}, [])])  Statement({, [])  Statement(throwIfParentInstance(""getOverrideApns""), [])  AssignmentExpression(=, [VariableReference(if (mService !, []), Expression(null) {, [])])    VariableReference(if (mService !, [])    Expression(null) {, [])  Statement(try {, [])  MethodCall(return mService.getOverrideApns(admin), [VariableReference(return mService, []), Expression(admin, [])])    VariableReference(return mService, [])    Expression(admin, [])  Statement(} catch (RemoteException e) {, [])  MethodCall(throw e.rethrowFromSystemServer(), [VariableReference(throw e, []), Expression(, [])])    VariableReference(throw e, [])    Expression(, [])  Statement(}, [])  Statement(}, [])  MethodCall(return Collections.emptyList(), [VariableReference(return Collections, []), Expression(, [])])    VariableReference(return Collections, [])    Expression(, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(throwIfParentInstance(""getOverrideApns""), []), AssignmentExpression(=, [VariableReference(if (mService !, []), Expression(null) {, [])]), Statement(try {, []), MethodCall(return mService.getOverrideApns(admin), [VariableReference(return mService, []), Expression(admin, [])]), Statement(} catch (RemoteException e) {, []), MethodCall(throw e.rethrowFromSystemServer(), [VariableReference(throw e, []), Expression(, [])]), Statement(}, []), Statement(}, []), MethodCall(return Collections.emptyList(), [VariableReference(return Collections, []), Expression(, [])]), Statement(}, [])])  Statement({, [])  Statement(throwIfParentInstance(""getOverrideApns""), [])  AssignmentExpression(=, [VariableReference(if (mService !, []), Expression(null) {, [])])    VariableReference(if (mService !, [])    Expression(null) {, [])  Statement(try {, [])  MethodCall(return mService.getOverrideApns(admin), [VariableReference(return mService, []), Expression(admin, [])])    VariableReference(return mService, [])    Expression(admin, [])  Statement(} catch (RemoteException e) {, [])  MethodCall(throw e.rethrowFromSystemServer(), [VariableReference(throw e, []), Expression(, [])])    VariableReference(throw e, [])    Expression(, [])  Statement(}, [])  Statement(}, [])  MethodCall(return Collections.emptyList(), [VariableReference(return Collections, []), Expression(, [])])    VariableReference(return Collections, [])    Expression(, [])  Statement(}, [])",0,"/**
 * Called by device owner to get all override APNs inserted by device owner.
 *
 * @param admin which {@link DeviceAdminReceiver} this request is associated with
 * @return A list of override APNs inserted by device owner.
 * @throws SecurityException if {@code admin} is not a device owner.
 *
 * @see #setOverrideApnsEnabled(ComponentName, boolean)
 */
","/**
 * Called by device owner or managed profile owner to get all override APNs inserted by
 * device owner or managed profile owner previously using {@link #addOverrideApn}.
 *
 * @param admin which {@link DeviceAdminReceiver} this request is associated with
 * @return A list of override APNs inserted by device owner.
 * @throws SecurityException if {@code admin} is not a device owner.
 *
 * @see #setOverrideApnsEnabled(ComponentName, boolean)
 */
",1,,,0,,,,0,0,0,0,0,There is no change between the early and late implementation code.,"Since there are no code changes, there are no compatibility issues. Therefore, no compatibility issue exists (CI type 0)."
46,<android.app.admin.DevicePolicyManager: boolean isPreferentialNetworkServiceEnabled()>,32,33,,,,"MethodDeclaration(method_body, [Statement({, []), Statement(throwIfParentInstance(""isPreferentialNetworkServiceEnabled""), []), AssignmentExpression(=, [VariableReference(if (mService, []), Expression(, [])]), Statement(return false, []), Statement(}, []), Statement(try {, []), MethodCall(return mService.isPreferentialNetworkServiceEnabled(myUserId()), [VariableReference(return mService, []), Expression(myUserId(), [])]), Statement(} catch (RemoteException e) {, []), MethodCall(throw e.rethrowFromSystemServer(), [VariableReference(throw e, []), Expression(, [])]), Statement(}, []), Statement(}, [])])  Statement({, [])  Statement(throwIfParentInstance(""isPreferentialNetworkServiceEnabled""), [])  AssignmentExpression(=, [VariableReference(if (mService, []), Expression(, [])])    VariableReference(if (mService, [])    Expression(, [])  Statement(return false, [])  Statement(}, [])  Statement(try {, [])  MethodCall(return mService.isPreferentialNetworkServiceEnabled(myUserId()), [VariableReference(return mService, []), Expression(myUserId(), [])])    VariableReference(return mService, [])    Expression(myUserId(), [])  Statement(} catch (RemoteException e) {, [])  MethodCall(throw e.rethrowFromSystemServer(), [VariableReference(throw e, []), Expression(, [])])    VariableReference(throw e, [])    Expression(, [])  Statement(}, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(throwIfParentInstance(""isPreferentialNetworkServiceEnabled""), []), MethodCall(return getPreferentialNetworkServiceConfigs().stream().anyMatch(c -> c.isEnabled()), [VariableReference(return getPreferentialNetworkServiceConfigs(), []), Expression().anyMatch(c -> c.isEnabled(), [])]), Statement(}, [])])  Statement({, [])  Statement(throwIfParentInstance(""isPreferentialNetworkServiceEnabled""), [])  MethodCall(return getPreferentialNetworkServiceConfigs().stream().anyMatch(c -> c.isEnabled()), [VariableReference(return getPreferentialNetworkServiceConfigs(), []), Expression().anyMatch(c -> c.isEnabled(), [])])    VariableReference(return getPreferentialNetworkServiceConfigs(), [])    Expression().anyMatch(c -> c.isEnabled(), [])  Statement(}, [])",1,"/**
 * Indicates whether preferential network service is enabled.
 *
 * <p>This method can be called by the profile owner of a managed profile.
 *
 * @return whether preferential network service is enabled.
 * @throws SecurityException if the caller is not the profile owner.
 */
","/**
 * Indicates whether preferential network service is enabled.
 *
 * <p> Before Android version {@link android.os.Build.VERSION_CODES#TIRAMISU}:
 * This method can be called by the profile owner of a managed profile.
 * <p> Starting from Android version {@link android.os.Build.VERSION_CODES#TIRAMISU}:
 * This method can be called by the profile owner of a managed profile
 * or device owner.
 *
 * @return whether preferential network service is enabled.
 * @throws SecurityException if the caller is not the profile owner or device owner.
 */
",1,,,0,,,,"1,2","1,2,3,4","1,2","1,3,5",1,"The code change includes a change in the return statement from `mService.isPreferentialNetworkServiceEnabled(myUserId())` to `getPreferentialNetworkServiceConfigs().stream().anyMatch(c -> c.isEnabled())`. This indicates a change in the method being called and its logic (`mService.isPreferentialNetworkServiceEnabled(myUserId())` to `getPreferentialNetworkServiceConfigs()`). Additionally, there is a noticeable change in the control flow because the exception handling in the early version has been removed in the late version.","The change in the method being called for fetching the preferential network service status and the change in control dependency can result in different return values. Therefore, this is a potential CI of type 1."
47,"<android.service.autofill.Dataset.Builder: Builder setValue(AutofillId,AutofillValue,RemoteViews,InlinePresentation)>",32,33,,,,"MethodDeclaration(method_body, [Statement({, []), Statement(throwIfDestroyed(), []), MethodCall(Preconditions.checkNotNull(presentation, ""presentation cannot be null""), [VariableReference(Preconditions, []), Expression(presentation, []), Expression(""presentation cannot be null"", [])]), MethodCall(Preconditions.checkNotNull(inlinePresentation, ""inlinePresentation cannot be null""), [VariableReference(Preconditions, []), Expression(inlinePresentation, []), Expression(""inlinePresentation cannot be null"", [])]), Statement(setLifeTheUniverseAndEverything(id, value, presentation, inlinePresentation, null), []), Statement(return this, []), Statement(}, [])])  Statement({, [])  Statement(throwIfDestroyed(), [])  MethodCall(Preconditions.checkNotNull(presentation, ""presentation cannot be null""), [VariableReference(Preconditions, []), Expression(presentation, []), Expression(""presentation cannot be null"", [])])    VariableReference(Preconditions, [])    Expression(presentation, [])    Expression(""presentation cannot be null"", [])  MethodCall(Preconditions.checkNotNull(inlinePresentation, ""inlinePresentation cannot be null""), [VariableReference(Preconditions, []), Expression(inlinePresentation, []), Expression(""inlinePresentation cannot be null"", [])])    VariableReference(Preconditions, [])    Expression(inlinePresentation, [])    Expression(""inlinePresentation cannot be null"", [])  Statement(setLifeTheUniverseAndEverything(id, value, presentation, inlinePresentation, null), [])  Statement(return this, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(throwIfDestroyed(), []), MethodCall(Objects.requireNonNull(presentation, ""presentation cannot be null""), [VariableReference(Objects, []), Expression(presentation, []), Expression(""presentation cannot be null"", [])]), MethodCall(Objects.requireNonNull(inlinePresentation, ""inlinePresentation cannot be null""), [VariableReference(Objects, []), Expression(inlinePresentation, []), Expression(""inlinePresentation cannot be null"", [])]), Statement(setLifeTheUniverseAndEverything(id, value, presentation, inlinePresentation, null, null, null), []), Statement(return this, []), Statement(}, [])])  Statement({, [])  Statement(throwIfDestroyed(), [])  MethodCall(Objects.requireNonNull(presentation, ""presentation cannot be null""), [VariableReference(Objects, []), Expression(presentation, []), Expression(""presentation cannot be null"", [])])    VariableReference(Objects, [])    Expression(presentation, [])    Expression(""presentation cannot be null"", [])  MethodCall(Objects.requireNonNull(inlinePresentation, ""inlinePresentation cannot be null""), [VariableReference(Objects, []), Expression(inlinePresentation, []), Expression(""inlinePresentation cannot be null"", [])])    VariableReference(Objects, [])    Expression(inlinePresentation, [])    Expression(""inlinePresentation cannot be null"", [])  Statement(setLifeTheUniverseAndEverything(id, value, presentation, inlinePresentation, null, null, null), [])  Statement(return this, [])  Statement(}, [])",1,"/**
 * Sets the value of a field, using a custom {@link RemoteViews presentation} to
 * visualize it and an {@link InlinePresentation} to visualize it as an inline suggestion.
 *
 * <p><b>Note:</b> If the dataset requires authentication but the service knows its text
 * value it's easier to filter by calling
 * {@link #setValue(AutofillId, AutofillValue, RemoteViews)} and using the value to filter.
 *
 * @param id id returned by {@link
 * android.app.assist.AssistStructure.ViewNode#getAutofillId()}.
 * @param value the value to be autofilled. Pass {@code null} if you do not have the value
 * but the target view is a logical part of the dataset. For example, if
 * the dataset needs authentication and you have no access to the value.
 * @param presentation the presentation used to visualize this field.
 * @param inlinePresentation The {@link InlinePresentation} used to visualize this dataset
 * as inline suggestions. If the dataset supports inline suggestions,
 * this should not be null.
 *
 * @throws IllegalStateException if {@link #build()} was already called.
 *
 * @return this builder.
 */
","/**
 * Sets the value of a field, using a custom {@link RemoteViews presentation} to
 * visualize it and an {@link InlinePresentation} to visualize it as an inline suggestion.
 *
 * <p><b>Note:</b> If the dataset requires authentication but the service knows its text
 * value it's easier to filter by calling
 * {@link #setValue(AutofillId, AutofillValue, RemoteViews)} and using the value to filter.
 *
 * @param id id returned by {@link
 * android.app.assist.AssistStructure.ViewNode#getAutofillId()}.
 * @param value the value to be autofilled. Pass {@code null} if you do not have the value
 * but the target view is a logical part of the dataset. For example, if
 * the dataset needs authentication and you have no access to the value.
 * @param presentation the presentation used to visualize this field.
 * @param inlinePresentation The {@link InlinePresentation} used to visualize this dataset
 * as inline suggestions. If the dataset supports inline suggestions,
 * this should not be null.
 *
 * @throws IllegalStateException if {@link #build()} was already called.
 *
 * @return this builder.
 * @deprecated Use {@link #setField(AutofillId, Field)} instead.
 */
",1,[@NonNull],"[@Deprecated, @NonNull]",1,,,,2,"1,5",1,"4,5",0,"The implementation has changed to use `Objects.requireNonNull()` instead of `Preconditions.checkNotNull()`. Additionally, the method `setLifeTheUniverseAndEverything` now has additional parameters. The code change type is 4,5.","The change, although altering the input parameter checks and method call with additional parameters, does not change the API's return value or exception handling from the client's perspective. Therefore, there is no compatibility issue, so the CI type is 0."
48,"<android.widget.RemoteViews.ViewGroupActionAdd: void apply(View,ViewGroup,InteractionHandler,ColorResources)>",32,33,,,,"MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(final Context context, []), Expression(root.getContext(), [])]), AssignmentExpression(=, [VariableReference(final ViewGroup target, []), Expression(root.findViewById(viewId), [])]), AssignmentExpression(=, [VariableReference(if (target, []), Expression(, [])]), Statement(return, []), Statement(}, []), Statement(// If removeAllViews was called, this returns the next potential recycled view., []), Statement(// If there are no more views to recycle (or removeAllViews was not called), this, []), Statement(// will return -1., []), AssignmentExpression(=, [VariableReference(final int nextChild, []), Expression(getNextRecyclableChild(target), [])]), AssignmentExpression(=, [VariableReference(RemoteViews rvToApply, []), Expression(mNestedViews.getRemoteViewsToApply(context), [])]), AssignmentExpression(=, [VariableReference(if (nextChild >, []), Expression(0 && mStableId !, [])]), Statement(// At that point, the views starting at index nextChild are the ones recyclable but, []), Statement(// not yet recycled. All views added on that round of application are placed before., []), Statement(// Find the next view with the same stable id, or -1., []), AssignmentExpression(=, [VariableReference(int recycledViewIndex, []), Expression(findViewIndexToRecycle(target, rvToApply), [])]), AssignmentExpression(=, [VariableReference(if (recycledViewIndex >, []), Expression(0) {, [])]), AssignmentExpression(=, [VariableReference(View child, []), Expression(target.getChildAt(recycledViewIndex), [])]), MethodCall(if (rvToApply.canRecycleView(child)), [VariableReference(if (rvToApply, []), Expression(child), [])]), Statement(if (nextChild < recycledViewIndex) {, []), MethodCall(target.removeViews(nextChild, recycledViewIndex - nextChild), [VariableReference(target, []), Expression(nextChild, []), Expression(recycledViewIndex - nextChild, [])]), Statement(}, []), MethodCall(setNextRecyclableChild(target, nextChild + 1, target.getChildCount()), [VariableReference(setNextRecyclableChild(target, nextChild + 1, target, []), Expression(), [])]), Statement(colorResources, false), []), Statement(return, []), Statement(}, []), Statement(// If we cannot recycle the views, we still remove all views in between to, []), Statement(// avoid weird behaviors and insert the new view in place of the old one., []), MethodCall(target.removeViews(nextChild, recycledViewIndex - nextChild + 1), [VariableReference(target, []), Expression(nextChild, []), Expression(recycledViewIndex - nextChild + 1, [])]), Statement(}, []), Statement(}, []), Statement(// If we cannot recycle, insert the new view before the next recyclable child., []), Statement(// Inflate nested views and add as children, []), AssignmentExpression(=, [VariableReference(View nestedView, []), Expression(rvToApply.apply(context, target, handler, null, /* size */, [])]), Statement(colorResources), []), AssignmentExpression(=, [VariableReference(if (mStableId !, []), Expression(NO_ID) {, [])]), Statement(setStableId(nestedView, mStableId), []), Statement(}, []), AssignmentExpression(=, [VariableReference(target.addView(nestedView, mIndex >, []), Expression(0 ? mIndex : nextChild), [])]), AssignmentExpression(=, [VariableReference(if (nextChild >, []), Expression(0) {, [])]), Statement(// If we are at the end, there is no reason to try to recycle anymore, []), MethodCall(setNextRecyclableChild(target, nextChild + 1, target.getChildCount()), [VariableReference(setNextRecyclableChild(target, nextChild + 1, target, []), Expression(), [])]), Statement(}, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(final Context context, []), Expression(root.getContext(), [])])    VariableReference(final Context context, [])    Expression(root.getContext(), [])  AssignmentExpression(=, [VariableReference(final ViewGroup target, []), Expression(root.findViewById(viewId), [])])    VariableReference(final ViewGroup target, [])    Expression(root.findViewById(viewId), [])  AssignmentExpression(=, [VariableReference(if (target, []), Expression(, [])])    VariableReference(if (target, [])    Expression(, [])  Statement(return, [])  Statement(}, [])  Statement(// If removeAllViews was called, this returns the next potential recycled view., [])  Statement(// If there are no more views to recycle (or removeAllViews was not called), this, [])  Statement(// will return -1., [])  AssignmentExpression(=, [VariableReference(final int nextChild, []), Expression(getNextRecyclableChild(target), [])])    VariableReference(final int nextChild, [])    Expression(getNextRecyclableChild(target), [])  AssignmentExpression(=, [VariableReference(RemoteViews rvToApply, []), Expression(mNestedViews.getRemoteViewsToApply(context), [])])    VariableReference(RemoteViews rvToApply, [])    Expression(mNestedViews.getRemoteViewsToApply(context), [])  AssignmentExpression(=, [VariableReference(if (nextChild >, []), Expression(0 && mStableId !, [])])    VariableReference(if (nextChild >, [])    Expression(0 && mStableId !, [])  Statement(// At that point, the views starting at index nextChild are the ones recyclable but, [])  Statement(// not yet recycled. All views added on that round of application are placed before., [])  Statement(// Find the next view with the same stable id, or -1., [])  AssignmentExpression(=, [VariableReference(int recycledViewIndex, []), Expression(findViewIndexToRecycle(target, rvToApply), [])])    VariableReference(int recycledViewIndex, [])    Expression(findViewIndexToRecycle(target, rvToApply), [])  AssignmentExpression(=, [VariableReference(if (recycledViewIndex >, []), Expression(0) {, [])])    VariableReference(if (recycledViewIndex >, [])    Expression(0) {, [])  AssignmentExpression(=, [VariableReference(View child, []), Expression(target.getChildAt(recycledViewIndex), [])])    VariableReference(View child, [])    Expression(target.getChildAt(recycledViewIndex), [])  MethodCall(if (rvToApply.canRecycleView(child)), [VariableReference(if (rvToApply, []), Expression(child), [])])    VariableReference(if (rvToApply, [])    Expression(child), [])  Statement(if (nextChild < recycledViewIndex) {, [])  MethodCall(target.removeViews(nextChild, recycledViewIndex - nextChild), [VariableReference(target, []), Expression(nextChild, []), Expression(recycledViewIndex - nextChild, [])])    VariableReference(target, [])    Expression(nextChild, [])    Expression(recycledViewIndex - nextChild, [])  Statement(}, [])  MethodCall(setNextRecyclableChild(target, nextChild + 1, target.getChildCount()), [VariableReference(setNextRecyclableChild(target, nextChild + 1, target, []), Expression(), [])])    VariableReference(setNextRecyclableChild(target, nextChild + 1, target, [])    Expression(), [])  Statement(colorResources, false), [])  Statement(return, [])  Statement(}, [])  Statement(// If we cannot recycle the views, we still remove all views in between to, [])  Statement(// avoid weird behaviors and insert the new view in place of the old one., [])  MethodCall(target.removeViews(nextChild, recycledViewIndex - nextChild + 1), [VariableReference(target, []), Expression(nextChild, []), Expression(recycledViewIndex - nextChild + 1, [])])    VariableReference(target, [])    Expression(nextChild, [])    Expression(recycledViewIndex - nextChild + 1, [])  Statement(}, [])  Statement(}, [])  Statement(// If we cannot recycle, insert the new view before the next recyclable child., [])  Statement(// Inflate nested views and add as children, [])  AssignmentExpression(=, [VariableReference(View nestedView, []), Expression(rvToApply.apply(context, target, handler, null, /* size */, [])])    VariableReference(View nestedView, [])    Expression(rvToApply.apply(context, target, handler, null, /* size */, [])  Statement(colorResources), [])  AssignmentExpression(=, [VariableReference(if (mStableId !, []), Expression(NO_ID) {, [])])    VariableReference(if (mStableId !, [])    Expression(NO_ID) {, [])  Statement(setStableId(nestedView, mStableId), [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(target.addView(nestedView, mIndex >, []), Expression(0 ? mIndex : nextChild), [])])    VariableReference(target.addView(nestedView, mIndex >, [])    Expression(0 ? mIndex : nextChild), [])  AssignmentExpression(=, [VariableReference(if (nextChild >, []), Expression(0) {, [])])    VariableReference(if (nextChild >, [])    Expression(0) {, [])  Statement(// If we are at the end, there is no reason to try to recycle anymore, [])  MethodCall(setNextRecyclableChild(target, nextChild + 1, target.getChildCount()), [VariableReference(setNextRecyclableChild(target, nextChild + 1, target, []), Expression(), [])])    VariableReference(setNextRecyclableChild(target, nextChild + 1, target, [])    Expression(), [])  Statement(}, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(final Context context, []), Expression(root.getContext(), [])]), AssignmentExpression(=, [VariableReference(final ViewGroup target, []), Expression(root.findViewById(viewId), [])]), AssignmentExpression(=, [VariableReference(if (target, []), Expression(, [])]), Statement(return, []), Statement(}, []), Statement(// If removeAllViews was called, this returns the next potential recycled view., []), Statement(// If there are no more views to recycle (or removeAllViews was not called), this, []), Statement(// will return -1., []), AssignmentExpression(=, [VariableReference(final int nextChild, []), Expression(getNextRecyclableChild(target), [])]), AssignmentExpression(=, [VariableReference(RemoteViews rvToApply, []), Expression(mNestedViews.getRemoteViewsToApply(context), [])]), AssignmentExpression(=, [VariableReference(int flagsToPropagate, []), Expression(mApplyFlags & FLAG_MASK_TO_PROPAGATE, [])]), AssignmentExpression(=, [VariableReference(if (flagsToPropagate !, []), Expression(0), [])]), MethodCall(rvToApply.addFlags(flagsToPropagate), [VariableReference(rvToApply, []), Expression(flagsToPropagate, [])]), AssignmentExpression(=, [VariableReference(if (nextChild >, []), Expression(0 && mStableId !, [])]), Statement(// At that point, the views starting at index nextChild are the ones recyclable but, []), Statement(// not yet recycled. All views added on that round of application are placed before., []), Statement(// Find the next view with the same stable id, or -1., []), AssignmentExpression(=, [VariableReference(int recycledViewIndex, []), Expression(findViewIndexToRecycle(target, rvToApply), [])]), AssignmentExpression(=, [VariableReference(if (recycledViewIndex >, []), Expression(0) {, [])]), AssignmentExpression(=, [VariableReference(View child, []), Expression(target.getChildAt(recycledViewIndex), [])]), MethodCall(if (rvToApply.canRecycleView(child)), [VariableReference(if (rvToApply, []), Expression(child), [])]), Statement(if (nextChild < recycledViewIndex) {, []), MethodCall(target.removeViews(nextChild, recycledViewIndex - nextChild), [VariableReference(target, []), Expression(nextChild, []), Expression(recycledViewIndex - nextChild, [])]), Statement(}, []), MethodCall(setNextRecyclableChild(target, nextChild + 1, target.getChildCount()), [VariableReference(setNextRecyclableChild(target, nextChild + 1, target, []), Expression(), [])]), Statement(colorResources), []), Statement(return, []), Statement(}, []), Statement(// If we cannot recycle the views, we still remove all views in between to, []), Statement(// avoid weird behaviors and insert the new view in place of the old one., []), MethodCall(target.removeViews(nextChild, recycledViewIndex - nextChild + 1), [VariableReference(target, []), Expression(nextChild, []), Expression(recycledViewIndex - nextChild + 1, [])]), Statement(}, []), Statement(}, []), Statement(// If we cannot recycle, insert the new view before the next recyclable child., []), Statement(// Inflate nested views and add as children, []), AssignmentExpression(=, [VariableReference(View nestedView, []), Expression(rvToApply.applyNestedViews(context, target, rootParent, handler, null, /* size */, [])]), Statement(colorResources), []), AssignmentExpression(=, [VariableReference(if (mStableId !, []), Expression(NO_ID) {, [])]), Statement(setStableId(nestedView, mStableId), []), Statement(}, []), AssignmentExpression(=, [VariableReference(target.addView(nestedView, mIndex >, []), Expression(0 ? mIndex : nextChild), [])]), AssignmentExpression(=, [VariableReference(if (nextChild >, []), Expression(0) {, [])]), Statement(// If we are at the end, there is no reason to try to recycle anymore, []), MethodCall(setNextRecyclableChild(target, nextChild + 1, target.getChildCount()), [VariableReference(setNextRecyclableChild(target, nextChild + 1, target, []), Expression(), [])]), Statement(}, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(final Context context, []), Expression(root.getContext(), [])])    VariableReference(final Context context, [])    Expression(root.getContext(), [])  AssignmentExpression(=, [VariableReference(final ViewGroup target, []), Expression(root.findViewById(viewId), [])])    VariableReference(final ViewGroup target, [])    Expression(root.findViewById(viewId), [])  AssignmentExpression(=, [VariableReference(if (target, []), Expression(, [])])    VariableReference(if (target, [])    Expression(, [])  Statement(return, [])  Statement(}, [])  Statement(// If removeAllViews was called, this returns the next potential recycled view., [])  Statement(// If there are no more views to recycle (or removeAllViews was not called), this, [])  Statement(// will return -1., [])  AssignmentExpression(=, [VariableReference(final int nextChild, []), Expression(getNextRecyclableChild(target), [])])    VariableReference(final int nextChild, [])    Expression(getNextRecyclableChild(target), [])  AssignmentExpression(=, [VariableReference(RemoteViews rvToApply, []), Expression(mNestedViews.getRemoteViewsToApply(context), [])])    VariableReference(RemoteViews rvToApply, [])    Expression(mNestedViews.getRemoteViewsToApply(context), [])  AssignmentExpression(=, [VariableReference(int flagsToPropagate, []), Expression(mApplyFlags & FLAG_MASK_TO_PROPAGATE, [])])    VariableReference(int flagsToPropagate, [])    Expression(mApplyFlags & FLAG_MASK_TO_PROPAGATE, [])  AssignmentExpression(=, [VariableReference(if (flagsToPropagate !, []), Expression(0), [])])    VariableReference(if (flagsToPropagate !, [])    Expression(0), [])  MethodCall(rvToApply.addFlags(flagsToPropagate), [VariableReference(rvToApply, []), Expression(flagsToPropagate, [])])    VariableReference(rvToApply, [])    Expression(flagsToPropagate, [])  AssignmentExpression(=, [VariableReference(if (nextChild >, []), Expression(0 && mStableId !, [])])    VariableReference(if (nextChild >, [])    Expression(0 && mStableId !, [])  Statement(// At that point, the views starting at index nextChild are the ones recyclable but, [])  Statement(// not yet recycled. All views added on that round of application are placed before., [])  Statement(// Find the next view with the same stable id, or -1., [])  AssignmentExpression(=, [VariableReference(int recycledViewIndex, []), Expression(findViewIndexToRecycle(target, rvToApply), [])])    VariableReference(int recycledViewIndex, [])    Expression(findViewIndexToRecycle(target, rvToApply), [])  AssignmentExpression(=, [VariableReference(if (recycledViewIndex >, []), Expression(0) {, [])])    VariableReference(if (recycledViewIndex >, [])    Expression(0) {, [])  AssignmentExpression(=, [VariableReference(View child, []), Expression(target.getChildAt(recycledViewIndex), [])])    VariableReference(View child, [])    Expression(target.getChildAt(recycledViewIndex), [])  MethodCall(if (rvToApply.canRecycleView(child)), [VariableReference(if (rvToApply, []), Expression(child), [])])    VariableReference(if (rvToApply, [])    Expression(child), [])  Statement(if (nextChild < recycledViewIndex) {, [])  MethodCall(target.removeViews(nextChild, recycledViewIndex - nextChild), [VariableReference(target, []), Expression(nextChild, []), Expression(recycledViewIndex - nextChild, [])])    VariableReference(target, [])    Expression(nextChild, [])    Expression(recycledViewIndex - nextChild, [])  Statement(}, [])  MethodCall(setNextRecyclableChild(target, nextChild + 1, target.getChildCount()), [VariableReference(setNextRecyclableChild(target, nextChild + 1, target, []), Expression(), [])])    VariableReference(setNextRecyclableChild(target, nextChild + 1, target, [])    Expression(), [])  Statement(colorResources), [])  Statement(return, [])  Statement(}, [])  Statement(// If we cannot recycle the views, we still remove all views in between to, [])  Statement(// avoid weird behaviors and insert the new view in place of the old one., [])  MethodCall(target.removeViews(nextChild, recycledViewIndex - nextChild + 1), [VariableReference(target, []), Expression(nextChild, []), Expression(recycledViewIndex - nextChild + 1, [])])    VariableReference(target, [])    Expression(nextChild, [])    Expression(recycledViewIndex - nextChild + 1, [])  Statement(}, [])  Statement(}, [])  Statement(// If we cannot recycle, insert the new view before the next recyclable child., [])  Statement(// Inflate nested views and add as children, [])  AssignmentExpression(=, [VariableReference(View nestedView, []), Expression(rvToApply.applyNestedViews(context, target, rootParent, handler, null, /* size */, [])])    VariableReference(View nestedView, [])    Expression(rvToApply.applyNestedViews(context, target, rootParent, handler, null, /* size */, [])  Statement(colorResources), [])  AssignmentExpression(=, [VariableReference(if (mStableId !, []), Expression(NO_ID) {, [])])    VariableReference(if (mStableId !, [])    Expression(NO_ID) {, [])  Statement(setStableId(nestedView, mStableId), [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(target.addView(nestedView, mIndex >, []), Expression(0 ? mIndex : nextChild), [])])    VariableReference(target.addView(nestedView, mIndex >, [])    Expression(0 ? mIndex : nextChild), [])  AssignmentExpression(=, [VariableReference(if (nextChild >, []), Expression(0) {, [])])    VariableReference(if (nextChild >, [])    Expression(0) {, [])  Statement(// If we are at the end, there is no reason to try to recycle anymore, [])  MethodCall(setNextRecyclableChild(target, nextChild + 1, target.getChildCount()), [VariableReference(setNextRecyclableChild(target, nextChild + 1, target, []), Expression(), [])])    VariableReference(setNextRecyclableChild(target, nextChild + 1, target, [])    Expression(), [])  Statement(}, [])  Statement(}, [])",1,,,0,[@Override],[@Override],0,,,,"1,2","3,4,5",1,"3,5",1,"A control dependency change occurred due to the introduction of `int flagsToPropagate` and the consequent check and method call with `flagsToPropagate`. Additionally, the dependent API `rvToApply.apply` was changed to `rvToApply.applyNestedViews`.","The code change potentially leads to different return values since the `apply` method is replaced by `applyNestedViews`, which may have different behavior. Therefore, the CI type is 1."
49,<android.view.contentcapture.ContentCaptureSession: void notifyViewDisappeared(AutofillId)>,32,33,,,,"MethodDeclaration(method_body, [Statement({, []), MethodCall(Preconditions.checkNotNull(id), [VariableReference(Preconditions, []), Expression(id, [])]), Statement(if (!isContentCaptureEnabled()), []), Statement(return, []), Statement(internalNotifyViewDisappeared(id), []), Statement(}, [])])  Statement({, [])  MethodCall(Preconditions.checkNotNull(id), [VariableReference(Preconditions, []), Expression(id, [])])    VariableReference(Preconditions, [])    Expression(id, [])  Statement(if (!isContentCaptureEnabled()), [])  Statement(return, [])  Statement(internalNotifyViewDisappeared(id), [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), MethodCall(Objects.requireNonNull(id), [VariableReference(Objects, []), Expression(id, [])]), Statement(if (!isContentCaptureEnabled()), []), Statement(return, []), Statement(internalNotifyViewDisappeared(id), []), Statement(}, [])])  Statement({, [])  MethodCall(Objects.requireNonNull(id), [VariableReference(Objects, []), Expression(id, [])])    VariableReference(Objects, [])    Expression(id, [])  Statement(if (!isContentCaptureEnabled()), [])  Statement(return, [])  Statement(internalNotifyViewDisappeared(id), [])  Statement(}, [])",1,"/**
 * Notifies the Content Capture Service that a node has been removed from the view structure.
 *
 * <p>Typically called ""manually"" by views that handle their own virtual view hierarchy, or
 * automatically by the Android System for standard views.
 *
 * @param id id of the node that has been removed.
 */
","/**
 * Notifies the Content Capture Service that a node has been removed from the view structure.
 *
 * <p>Typically called ""manually"" by views that handle their own virtual view hierarchy, or
 * automatically by the Android System for standard views.
 *
 * @param id id of the node that has been removed.
 */
",0,,,0,,,,2,5,0,5,0,"The change is in the dependent API from `Preconditions.checkNotNull(id)` to `Objects.requireNonNull(id)`, so the code change type is 5.","The underlying dependency has changed from `Preconditions.checkNotNull(id)` to `Objects.requireNonNull(id)`, but this does not lead to a compatibility issue as the outcome remains the same, just using a different utility. Hence, no CI exists."
50,"<android.webkit.WebView: String[] getHttpAuthUsernamePassword(String,String)>",27,28,,,,"MethodDeclaration(method_body, [Statement({, []), Statement(checkThread(), []), MethodCall(return mProvider.getHttpAuthUsernamePassword(host, realm), [VariableReference(return mProvider, []), Expression(host, []), Expression(realm, [])]), Statement(}, [])])  Statement({, [])  Statement(checkThread(), [])  MethodCall(return mProvider.getHttpAuthUsernamePassword(host, realm), [VariableReference(return mProvider, []), Expression(host, []), Expression(realm, [])])    VariableReference(return mProvider, [])    Expression(host, [])    Expression(realm, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(checkThread(), []), MethodCall(return mProvider.getHttpAuthUsernamePassword(host, realm), [VariableReference(return mProvider, []), Expression(host, []), Expression(realm, [])]), Statement(}, [])])  Statement({, [])  Statement(checkThread(), [])  MethodCall(return mProvider.getHttpAuthUsernamePassword(host, realm), [VariableReference(return mProvider, []), Expression(host, []), Expression(realm, [])])    VariableReference(return mProvider, [])    Expression(host, [])    Expression(realm, [])  Statement(}, [])",0,"/**
 * Retrieves HTTP authentication credentials for a given host and realm from the {@link
 * WebViewDatabase} instance.
 * @param host the host to which the credentials apply
 * @param realm the realm to which the credentials apply
 * @return the credentials as a String array, if found. The first element
 * is the username and the second element is the password. Null if
 * no credentials are found.
 * @deprecated Use {@link WebViewDatabase#getHttpAuthUsernamePassword} instead
 */
","/**
 * Retrieves HTTP authentication credentials for a given host and realm from the {@link
 * WebViewDatabase} instance.
 * @param host the host to which the credentials apply
 * @param realm the realm to which the credentials apply
 * @return the credentials as a String array, if found. The first element
 * is the username and the second element is the password. {@code null} if
 * no credentials are found.
 * @deprecated Use {@link WebViewDatabase#getHttpAuthUsernamePassword} instead
 */
",1,[@Deprecated],"[@Deprecated, @Nullable]",1,,,,0,0,0,4,0,"There are no changes in the actual code implementation, just the addition of an annotation (@Nullable) in the late version. So the code change type is 4.","The code changes do not affect the behavior of the API in terms of return values or exception handling, thus there is no Compatibility Issue (CI)."
51,<android.widget.TextView: void setText(int)>,27,28,,,,"MethodDeclaration(method_body, [Statement({, []), MethodCall(setText(getContext().getResources().getText(resid)), [VariableReference(setText(getContext(), []), Expression().getText(resid), [])]), AssignmentExpression(=, [VariableReference(mTextFromResource, []), Expression(true, [])]), Statement(}, [])])  Statement({, [])  MethodCall(setText(getContext().getResources().getText(resid)), [VariableReference(setText(getContext(), []), Expression().getText(resid), [])])    VariableReference(setText(getContext(), [])    Expression().getText(resid), [])  AssignmentExpression(=, [VariableReference(mTextFromResource, []), Expression(true, [])])    VariableReference(mTextFromResource, [])    Expression(true, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), MethodCall(setText(getContext().getResources().getText(resid)), [VariableReference(setText(getContext(), []), Expression().getText(resid), [])]), AssignmentExpression(=, [VariableReference(mTextSetFromXmlOrResourceId, []), Expression(true, [])]), AssignmentExpression(=, [VariableReference(mTextId, []), Expression(resid, [])]), Statement(}, [])])  Statement({, [])  MethodCall(setText(getContext().getResources().getText(resid)), [VariableReference(setText(getContext(), []), Expression().getText(resid), [])])    VariableReference(setText(getContext(), [])    Expression().getText(resid), [])  AssignmentExpression(=, [VariableReference(mTextSetFromXmlOrResourceId, []), Expression(true, [])])    VariableReference(mTextSetFromXmlOrResourceId, [])    Expression(true, [])  AssignmentExpression(=, [VariableReference(mTextId, []), Expression(resid, [])])    VariableReference(mTextId, [])    Expression(resid, [])  Statement(}, [])",1,"/**
 * Sets the text to be displayed using a string resource identifier.
 *
 * @param resid the resource identifier of the string resource to be displayed
 *
 * @see #setText(CharSequence)
 *
 * @attr ref android.R.styleable#TextView_text
 */
","/**
 * Sets the text to be displayed using a string resource identifier.
 *
 * @param resid the resource identifier of the string resource to be displayed
 *
 * @see #setText(CharSequence)
 *
 * @attr ref android.R.styleable#TextView_text
 */
",0,[@android.view.RemotableViewMethod],[@android.view.RemotableViewMethod],0,,,,1,4,1,4,0,"The statements within the method have experienced changes apart from return statements, exception handling statements, and control dependencies. Specifically, the new implementation includes additional assignments: `mTextSetFromXmlOrResourceId = true` and `mTextId = resid`. Hence, the code change type is 4.","The additional assignments do not affect the return values or the exception handling of the method. Therefore, no Compatibility Issue exists, resulting in CI type 0."
52,<android.view.inputmethod.InputMethodManager: boolean switchToLastInputMethod(IBinder)>,27,28,,,,"MethodDeclaration(method_body, [Statement({, []), Statement(synchronized (mH) {, []), Statement(try {, []), MethodCall(return mService.switchToLastInputMethod(imeToken), [VariableReference(return mService, []), Expression(imeToken, [])]), Statement(} catch (RemoteException e) {, []), MethodCall(throw e.rethrowFromSystemServer(), [VariableReference(throw e, []), Expression(, [])]), Statement(}, []), Statement(}, []), Statement(}, [])])  Statement({, [])  Statement(synchronized (mH) {, [])  Statement(try {, [])  MethodCall(return mService.switchToLastInputMethod(imeToken), [VariableReference(return mService, []), Expression(imeToken, [])])    VariableReference(return mService, [])    Expression(imeToken, [])  Statement(} catch (RemoteException e) {, [])  MethodCall(throw e.rethrowFromSystemServer(), [VariableReference(throw e, []), Expression(, [])])    VariableReference(throw e, [])    Expression(, [])  Statement(}, [])  Statement(}, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(return switchToPreviousInputMethodInternal(imeToken), []), Statement(}, [])])  Statement({, [])  Statement(return switchToPreviousInputMethodInternal(imeToken), [])  Statement(}, [])",1,"/**
 * Force switch to the last used input method and subtype. If the last input method didn't have
 * any subtypes, the framework will simply switch to the last input method with no subtype
 * specified.
 * @param imeToken Supplies the identifying token given to an input method when it was started,
 * which allows it to perform this operation on itself.
 * @return true if the current input method and subtype was successfully switched to the last
 * used input method and subtype.
 */
","/**
 * Force switch to the last used input method and subtype. If the last input method didn't have
 * any subtypes, the framework will simply switch to the last input method with no subtype
 * specified.
 * @param imeToken Supplies the identifying token given to an input method when it was started,
 * which allows it to perform this operation on itself.
 * @return true if the current input method and subtype was successfully switched to the last
 * used input method and subtype.
 * @deprecated Use {@link InputMethodService#switchToPreviousInputMethod()} instead. This method
 * was intended for IME developers who should be accessing APIs through the service. APIs in
 * this class are intended for app developers interacting with the IME.
 */
",1,,[@Deprecated],1,,,,"1,2","1,2,5","1,2","1,2,5","1,2","The return statement has changed from `return mService.switchToLastInputMethod(imeToken)` to `return switchToPreviousInputMethodInternal(imeToken)`. Additionally, the exception handling statement (`throw e.rethrowFromSystemServer()`) has been removed, suggesting that the method may handle exceptions differently. This falls under the categories 1 (Return statement changed), 2 (Exception handling statement changed) and 5 (Dependent API changed).","The change in the return statement indicates that the method could now return different values compared to the old implementation. Additionally, the removal of the exception handling code suggests potential differences in how exceptions are managed. As such, the CI type is 1 (potentially different return values) and 2 (potentially different exception handling)."
53,<android.net.IpSecManager.UdpEncapsulationSocket: void close()>,27,28,,,,"MethodDeclaration(method_body, [Statement({, []), Statement(try {, []), MethodCall(mService.closeUdpEncapsulationSocket(mResourceId), [VariableReference(mService, []), Expression(mResourceId, [])]), Statement(} catch (RemoteException e) {, []), MethodCall(throw e.rethrowFromSystemServer(), [VariableReference(throw e, []), Expression(, [])]), Statement(}, []), Statement(try {, []), MethodCall(mPfd.close(), [VariableReference(mPfd, []), Expression(, [])]), Statement(} catch (IOException e) {, []), AssignmentExpression(=, [VariableReference(Log.e(TAG, ""Failed to close UDP Encapsulation Socket with Port, []), Expression("" + mPort), [])]), Statement(throw e, []), Statement(}, []), MethodCall(mCloseGuard.close(), [VariableReference(mCloseGuard, []), Expression(, [])]), Statement(}, [])])  Statement({, [])  Statement(try {, [])  MethodCall(mService.closeUdpEncapsulationSocket(mResourceId), [VariableReference(mService, []), Expression(mResourceId, [])])    VariableReference(mService, [])    Expression(mResourceId, [])  Statement(} catch (RemoteException e) {, [])  MethodCall(throw e.rethrowFromSystemServer(), [VariableReference(throw e, []), Expression(, [])])    VariableReference(throw e, [])    Expression(, [])  Statement(}, [])  Statement(try {, [])  MethodCall(mPfd.close(), [VariableReference(mPfd, []), Expression(, [])])    VariableReference(mPfd, [])    Expression(, [])  Statement(} catch (IOException e) {, [])  AssignmentExpression(=, [VariableReference(Log.e(TAG, ""Failed to close UDP Encapsulation Socket with Port, []), Expression("" + mPort), [])])    VariableReference(Log.e(TAG, ""Failed to close UDP Encapsulation Socket with Port, [])    Expression("" + mPort), [])  Statement(throw e, [])  Statement(}, [])  MethodCall(mCloseGuard.close(), [VariableReference(mCloseGuard, []), Expression(, [])])    VariableReference(mCloseGuard, [])    Expression(, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(try {, []), MethodCall(mService.closeUdpEncapsulationSocket(mResourceId), [VariableReference(mService, []), Expression(mResourceId, [])]), AssignmentExpression(=, [VariableReference(mResourceId, []), Expression(INVALID_RESOURCE_ID, [])]), Statement(} catch (RemoteException e) {, []), MethodCall(throw e.rethrowFromSystemServer(), [VariableReference(throw e, []), Expression(, [])]), Statement(} catch (Exception e) {, []), Statement(// On close we swallow all random exceptions since failure to close is not, []), Statement(// actionable by the user., []), AssignmentExpression(=, [VariableReference(Log.e(TAG, ""Failed to close "" + this + "", Exception, []), Expression("" + e), [])]), Statement(} finally {, []), AssignmentExpression(=, [VariableReference(mResourceId, []), Expression(INVALID_RESOURCE_ID, [])]), MethodCall(mCloseGuard.close(), [VariableReference(mCloseGuard, []), Expression(, [])]), Statement(}, []), Statement(try {, []), MethodCall(mPfd.close(), [VariableReference(mPfd, []), Expression(, [])]), Statement(} catch (IOException e) {, []), AssignmentExpression(=, [VariableReference(Log.e(TAG, ""Failed to close UDP Encapsulation Socket with Port, []), Expression("" + mPort), [])]), Statement(throw e, []), Statement(}, []), Statement(}, [])])  Statement({, [])  Statement(try {, [])  MethodCall(mService.closeUdpEncapsulationSocket(mResourceId), [VariableReference(mService, []), Expression(mResourceId, [])])    VariableReference(mService, [])    Expression(mResourceId, [])  AssignmentExpression(=, [VariableReference(mResourceId, []), Expression(INVALID_RESOURCE_ID, [])])    VariableReference(mResourceId, [])    Expression(INVALID_RESOURCE_ID, [])  Statement(} catch (RemoteException e) {, [])  MethodCall(throw e.rethrowFromSystemServer(), [VariableReference(throw e, []), Expression(, [])])    VariableReference(throw e, [])    Expression(, [])  Statement(} catch (Exception e) {, [])  Statement(// On close we swallow all random exceptions since failure to close is not, [])  Statement(// actionable by the user., [])  AssignmentExpression(=, [VariableReference(Log.e(TAG, ""Failed to close "" + this + "", Exception, []), Expression("" + e), [])])    VariableReference(Log.e(TAG, ""Failed to close "" + this + "", Exception, [])    Expression("" + e), [])  Statement(} finally {, [])  AssignmentExpression(=, [VariableReference(mResourceId, []), Expression(INVALID_RESOURCE_ID, [])])    VariableReference(mResourceId, [])    Expression(INVALID_RESOURCE_ID, [])  MethodCall(mCloseGuard.close(), [VariableReference(mCloseGuard, []), Expression(, [])])    VariableReference(mCloseGuard, [])    Expression(, [])  Statement(}, [])  Statement(try {, [])  MethodCall(mPfd.close(), [VariableReference(mPfd, []), Expression(, [])])    VariableReference(mPfd, [])    Expression(, [])  Statement(} catch (IOException e) {, [])  AssignmentExpression(=, [VariableReference(Log.e(TAG, ""Failed to close UDP Encapsulation Socket with Port, []), Expression("" + mPort), [])])    VariableReference(Log.e(TAG, ""Failed to close UDP Encapsulation Socket with Port, [])    Expression("" + mPort), [])  Statement(throw e, [])  Statement(}, [])  Statement(}, [])",1,,"/**
 * Close this socket.
 *
 * <p>This closes the wrapped socket. Open encapsulation sockets count against a user's
 * resource limits, and forgetting to close them eventually will result in {@link
 * ResourceUnavailableException} being thrown.
 */
",1,[@Override],[@Override],0,,,,"1,2","2,4,5",2,"2,3,4",2,"The late version introduces additional exception handling (`catch (Exception e)`), modifies the handling of `RemoteException`, and changes some other statements with added logging and a finally block. Therefore, the code change types are 2, 3, and 4.","The additional `catch (Exception e)` block and changes to exception handling can lead to different exceptions being thrown or handled in different ways than in the early version. As a result, the CI type is 2."
54,<android.webkit.WebView: WebBackForwardList restoreState(Bundle)>,27,28,,,,"MethodDeclaration(method_body, [Statement({, []), Statement(checkThread(), []), MethodCall(return mProvider.restoreState(inState), [VariableReference(return mProvider, []), Expression(inState, [])]), Statement(}, [])])  Statement({, [])  Statement(checkThread(), [])  MethodCall(return mProvider.restoreState(inState), [VariableReference(return mProvider, []), Expression(inState, [])])    VariableReference(return mProvider, [])    Expression(inState, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(checkThread(), []), MethodCall(return mProvider.restoreState(inState), [VariableReference(return mProvider, []), Expression(inState, [])]), Statement(}, [])])  Statement({, [])  Statement(checkThread(), [])  MethodCall(return mProvider.restoreState(inState), [VariableReference(return mProvider, []), Expression(inState, [])])    VariableReference(return mProvider, [])    Expression(inState, [])  Statement(}, [])",0,"/**
 * Restores the state of this WebView from the given Bundle. This method is
 * intended for use in {@link android.app.Activity#onRestoreInstanceState}
 * and should be called to restore the state of this WebView. If
 * it is called after this WebView has had a chance to build state (load
 * pages, create a back/forward list, etc.) there may be undesirable
 * side-effects. Please note that this method no longer restores the
 * display data for this WebView.
 *
 * @param inState the incoming Bundle of state
 * @return the restored back/forward list or null if restoreState failed
 */
","/**
 * Restores the state of this WebView from the given Bundle. This method is
 * intended for use in {@link android.app.Activity#onRestoreInstanceState}
 * and should be called to restore the state of this WebView. If
 * it is called after this WebView has had a chance to build state (load
 * pages, create a back/forward list, etc.) there may be undesirable
 * side-effects. Please note that this method no longer restores the
 * display data for this WebView.
 *
 * @param inState the incoming Bundle of state
 * @return the restored back/forward list or {@code null} if restoreState failed
 */
",1,,[@Nullable],1,,,,0,0,0,0,0,"There is no change between the early and late versions of the implementation nodes provided. Additionally, annotations and comments do not impact the functional behavior of the method.","Since the code stays the same in both versions, there is no potential for different return values or exception handling, hence no compatibility issue exists."
55,<android.widget.TextView: void setElegantTextHeight(boolean)>,27,28,,,,"MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(if (elegant !, []), Expression(mTextPaint.isElegantTextHeight()) {, [])]), MethodCall(mTextPaint.setElegantTextHeight(elegant), [VariableReference(mTextPaint, []), Expression(elegant, [])]), AssignmentExpression(=, [VariableReference(if (mLayout !, []), Expression(null) {, [])]), Statement(nullLayouts(), []), Statement(requestLayout(), []), Statement(invalidate(), []), Statement(}, []), Statement(}, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(if (elegant !, []), Expression(mTextPaint.isElegantTextHeight()) {, [])])    VariableReference(if (elegant !, [])    Expression(mTextPaint.isElegantTextHeight()) {, [])  MethodCall(mTextPaint.setElegantTextHeight(elegant), [VariableReference(mTextPaint, []), Expression(elegant, [])])    VariableReference(mTextPaint, [])    Expression(elegant, [])  AssignmentExpression(=, [VariableReference(if (mLayout !, []), Expression(null) {, [])])    VariableReference(if (mLayout !, [])    Expression(null) {, [])  Statement(nullLayouts(), [])  Statement(requestLayout(), [])  Statement(invalidate(), [])  Statement(}, [])  Statement(}, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(if (elegant !, []), Expression(mTextPaint.isElegantTextHeight()) {, [])]), MethodCall(mTextPaint.setElegantTextHeight(elegant), [VariableReference(mTextPaint, []), Expression(elegant, [])]), AssignmentExpression(=, [VariableReference(if (mLayout !, []), Expression(null) {, [])]), Statement(nullLayouts(), []), Statement(requestLayout(), []), Statement(invalidate(), []), Statement(}, []), Statement(}, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(if (elegant !, []), Expression(mTextPaint.isElegantTextHeight()) {, [])])    VariableReference(if (elegant !, [])    Expression(mTextPaint.isElegantTextHeight()) {, [])  MethodCall(mTextPaint.setElegantTextHeight(elegant), [VariableReference(mTextPaint, []), Expression(elegant, [])])    VariableReference(mTextPaint, [])    Expression(elegant, [])  AssignmentExpression(=, [VariableReference(if (mLayout !, []), Expression(null) {, [])])    VariableReference(if (mLayout !, [])    Expression(null) {, [])  Statement(nullLayouts(), [])  Statement(requestLayout(), [])  Statement(invalidate(), [])  Statement(}, [])  Statement(}, [])  Statement(}, [])",0,"/**
 * Set the TextView's elegant height metrics flag. This setting selects font
 * variants that have not been compacted to fit Latin-based vertical
 * metrics, and also increases top and bottom bounds to provide more space.
 *
 * @param elegant set the paint's elegant metrics flag.
 *
 * @attr ref android.R.styleable#TextView_elegantTextHeight
 */
","/**
 * Set the TextView's elegant height metrics flag. This setting selects font
 * variants that have not been compacted to fit Latin-based vertical
 * metrics, and also increases top and bottom bounds to provide more space.
 *
 * @param elegant set the paint's elegant metrics flag.
 *
 * @see #isElegantTextHeight()
 * @see Paint#isElegantTextHeight()
 *
 * @attr ref android.R.styleable#TextView_elegantTextHeight
 */
",1,,,0,,,,0,0,0,0,0,There are no observable changes in the method's implementation or its annotations between the two versions.,"Since there are no changes in the implementation or annotations of this method, there is no potential for a compatibility issue."
56,<android.widget.Toast.TN: void handleHide()>,27,28,,,,"MethodDeclaration(method_body, [Statement({, []), Statement(if (localLOGV), []), AssignmentExpression(=, [VariableReference(Log.v(TAG, ""HANDLE HIDE: "" + this + "" mView, []), Expression("" + mView), [])]), AssignmentExpression(=, [VariableReference(if (mView !, []), Expression(null) {, [])]), Statement(// the view isn't yet added, so let's try not to crash., []), AssignmentExpression(=, [VariableReference(if (mView.getParent() !, []), Expression(null) {, [])]), Statement(if (localLOGV), []), MethodCall(Log.v(TAG, ""REMOVE! "" + mView + "" in "" + this), [VariableReference(Log, []), Expression(TAG, []), Expression(""REMOVE! "" + mView + "" in "" + this, [])]), MethodCall(mWM.removeViewImmediate(mView), [VariableReference(mWM, []), Expression(mView, [])]), Statement(}, []), AssignmentExpression(=, [VariableReference(mView, []), Expression(null, [])]), Statement(}, []), Statement(}, [])])  Statement({, [])  Statement(if (localLOGV), [])  AssignmentExpression(=, [VariableReference(Log.v(TAG, ""HANDLE HIDE: "" + this + "" mView, []), Expression("" + mView), [])])    VariableReference(Log.v(TAG, ""HANDLE HIDE: "" + this + "" mView, [])    Expression("" + mView), [])  AssignmentExpression(=, [VariableReference(if (mView !, []), Expression(null) {, [])])    VariableReference(if (mView !, [])    Expression(null) {, [])  Statement(// the view isn't yet added, so let's try not to crash., [])  AssignmentExpression(=, [VariableReference(if (mView.getParent() !, []), Expression(null) {, [])])    VariableReference(if (mView.getParent() !, [])    Expression(null) {, [])  Statement(if (localLOGV), [])  MethodCall(Log.v(TAG, ""REMOVE! "" + mView + "" in "" + this), [VariableReference(Log, []), Expression(TAG, []), Expression(""REMOVE! "" + mView + "" in "" + this, [])])    VariableReference(Log, [])    Expression(TAG, [])    Expression(""REMOVE! "" + mView + "" in "" + this, [])  MethodCall(mWM.removeViewImmediate(mView), [VariableReference(mWM, []), Expression(mView, [])])    VariableReference(mWM, [])    Expression(mView, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(mView, []), Expression(null, [])])    VariableReference(mView, [])    Expression(null, [])  Statement(}, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(if (localLOGV), []), AssignmentExpression(=, [VariableReference(Log.v(TAG, ""HANDLE HIDE: "" + this + "" mView, []), Expression("" + mView), [])]), AssignmentExpression(=, [VariableReference(if (mView !, []), Expression(null) {, [])]), Statement(// the view isn't yet added, so let's try not to crash., []), AssignmentExpression(=, [VariableReference(if (mView.getParent() !, []), Expression(null) {, [])]), Statement(if (localLOGV), []), MethodCall(Log.v(TAG, ""REMOVE! "" + mView + "" in "" + this), [VariableReference(Log, []), Expression(TAG, []), Expression(""REMOVE! "" + mView + "" in "" + this, [])]), MethodCall(mWM.removeViewImmediate(mView), [VariableReference(mWM, []), Expression(mView, [])]), Statement(}, []), Statement(// the resources., []), Statement(try {, []), MethodCall(getService().finishToken(mPackageName, this), [VariableReference(getService(), []), Expression(mPackageName, []), Expression(this, [])]), Statement(} catch (RemoteException e) {, []), Statement(}, []), AssignmentExpression(=, [VariableReference(mView, []), Expression(null, [])]), Statement(}, []), Statement(}, [])])  Statement({, [])  Statement(if (localLOGV), [])  AssignmentExpression(=, [VariableReference(Log.v(TAG, ""HANDLE HIDE: "" + this + "" mView, []), Expression("" + mView), [])])    VariableReference(Log.v(TAG, ""HANDLE HIDE: "" + this + "" mView, [])    Expression("" + mView), [])  AssignmentExpression(=, [VariableReference(if (mView !, []), Expression(null) {, [])])    VariableReference(if (mView !, [])    Expression(null) {, [])  Statement(// the view isn't yet added, so let's try not to crash., [])  AssignmentExpression(=, [VariableReference(if (mView.getParent() !, []), Expression(null) {, [])])    VariableReference(if (mView.getParent() !, [])    Expression(null) {, [])  Statement(if (localLOGV), [])  MethodCall(Log.v(TAG, ""REMOVE! "" + mView + "" in "" + this), [VariableReference(Log, []), Expression(TAG, []), Expression(""REMOVE! "" + mView + "" in "" + this, [])])    VariableReference(Log, [])    Expression(TAG, [])    Expression(""REMOVE! "" + mView + "" in "" + this, [])  MethodCall(mWM.removeViewImmediate(mView), [VariableReference(mWM, []), Expression(mView, [])])    VariableReference(mWM, [])    Expression(mView, [])  Statement(}, [])  Statement(// the resources., [])  Statement(try {, [])  MethodCall(getService().finishToken(mPackageName, this), [VariableReference(getService(), []), Expression(mPackageName, []), Expression(this, [])])    VariableReference(getService(), [])    Expression(mPackageName, [])    Expression(this, [])  Statement(} catch (RemoteException e) {, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(mView, []), Expression(null, [])])    VariableReference(mView, [])    Expression(null, [])  Statement(}, [])  Statement(}, [])",1,,,0,,,0,,,,"1,2","2,4",2,"2,3",2,"A new `try-catch` statement was introduced in the late version, which handles the `RemoteException`. This change is both a control dependency change (type 3) and an exception handling change (type 2).","The API's exception handling has changed due to the introduction of a `RemoteException`. This means the API might now throw a different exception than before, leading to different behavior. Hence, the CI type is 2."
57,"<android.provider.Settings.System: boolean putString(ContentResolver,String,String)>",27,28,,,,"MethodDeclaration(method_body, [Statement({, []), MethodCall(return putStringForUser(resolver, name, value, UserHandle.myUserId()), [VariableReference(return putStringForUser(resolver, name, value, UserHandle, []), Expression(), [])]), Statement(}, [])])  Statement({, [])  MethodCall(return putStringForUser(resolver, name, value, UserHandle.myUserId()), [VariableReference(return putStringForUser(resolver, name, value, UserHandle, []), Expression(), [])])    VariableReference(return putStringForUser(resolver, name, value, UserHandle, [])    Expression(), [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), MethodCall(return putStringForUser(resolver, name, value, resolver.getUserId()), [VariableReference(return putStringForUser(resolver, name, value, resolver, []), Expression(), [])]), Statement(}, [])])  Statement({, [])  MethodCall(return putStringForUser(resolver, name, value, resolver.getUserId()), [VariableReference(return putStringForUser(resolver, name, value, resolver, []), Expression(), [])])    VariableReference(return putStringForUser(resolver, name, value, resolver, [])    Expression(), [])  Statement(}, [])",1,"/**
 * Store a name/value pair into the database.
 * @param resolver to access the database with
 * @param name to store
 * @param value to associate with the name
 * @return true if the value was set, false on database errors
 */
","/**
 * Store a name/value pair into the database.
 * @param resolver to access the database with
 * @param name to store
 * @param value to associate with the name
 * @return true if the value was set, false on database errors
 */
",0,,,0,,,,"1,2","1,5",1,"1,5",1,"The parameter passed to the method `putStringForUser` has changed from `UserHandle.myUserId()` to `resolver.getUserId()`. This change affects the return statement, so the code change type is 1,5.","Because the `putStringForUser` method call is now using `resolver.getUserId()` instead of `UserHandle.myUserId()`, this could result in different return values. Therefore, the CI type is 1."
58,"<android.webkit.WebChromeClient: void onReceivedTouchIconUrl(WebView,String,boolean)>",27,28,,,,"MethodDeclaration(method_body, [Statement({, []), Statement(}, [])])  Statement({, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(}, [])])  Statement({, [])  Statement(}, [])",0,"/**
 * Notify the host application of the url for an apple-touch-icon.
 * @param view The WebView that initiated the callback.
 * @param url The icon url.
 * @param precomposed True if the url is for a precomposed touch icon.
 */
","/**
 * Notify the host application of the url for an apple-touch-icon.
 * @param view The WebView that initiated the callback.
 * @param url The icon url.
 * @param precomposed {@code true} if the url is for a precomposed touch icon.
 */
",1,,,0,,,,0,0,0,0,0,There is no change in the implementation of the method between the two versions. Only a minor non-functional change in the comment occurred where the annotation style for the "precomposed" parameter description was updated to use {@code true}.,"Since there is no change in the actual code implementation of the method, there are no Compatibility Issues."
59,"<android.bluetooth.le.ScanFilter.Builder: Builder setServiceUuid(ParcelUuid,ParcelUuid)>",27,28,,,,"MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(if (mUuidMask !, []), Expression(null && mServiceUuid, [])]), Statement(throw new IllegalArgumentException(""uuid is null while uuidMask is not null!""), []), Statement(}, []), AssignmentExpression(=, [VariableReference(mServiceUuid, []), Expression(serviceUuid, [])]), AssignmentExpression(=, [VariableReference(mUuidMask, []), Expression(uuidMask, [])]), Statement(return this, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(if (mUuidMask !, []), Expression(null && mServiceUuid, [])])    VariableReference(if (mUuidMask !, [])    Expression(null && mServiceUuid, [])  Statement(throw new IllegalArgumentException(""uuid is null while uuidMask is not null!""), [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(mServiceUuid, []), Expression(serviceUuid, [])])    VariableReference(mServiceUuid, [])    Expression(serviceUuid, [])  AssignmentExpression(=, [VariableReference(mUuidMask, []), Expression(uuidMask, [])])    VariableReference(mUuidMask, [])    Expression(uuidMask, [])  Statement(return this, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(if (mUuidMask !, []), Expression(null && mServiceUuid, [])]), Statement(throw new IllegalArgumentException(""uuid is null while uuidMask is not null!""), []), Statement(}, []), AssignmentExpression(=, [VariableReference(mServiceUuid, []), Expression(serviceUuid, [])]), AssignmentExpression(=, [VariableReference(mUuidMask, []), Expression(uuidMask, [])]), Statement(return this, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(if (mUuidMask !, []), Expression(null && mServiceUuid, [])])    VariableReference(if (mUuidMask !, [])    Expression(null && mServiceUuid, [])  Statement(throw new IllegalArgumentException(""uuid is null while uuidMask is not null!""), [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(mServiceUuid, []), Expression(serviceUuid, [])])    VariableReference(mServiceUuid, [])    Expression(serviceUuid, [])  AssignmentExpression(=, [VariableReference(mUuidMask, []), Expression(uuidMask, [])])    VariableReference(mUuidMask, [])    Expression(uuidMask, [])  Statement(return this, [])  Statement(}, [])",0,"/**
 * Set filter on partial service uuid. The {@code uuidMask} is the bit mask for the
 * {@code serviceUuid}. Set any bit in the mask to 1 to indicate a match is needed for the
 * bit in {@code serviceUuid}, and 0 to ignore that bit.
 *
 * @throws IllegalArgumentException If {@code serviceUuid} is {@code null} but
 * {@code uuidMask} is not {@code null}.
 */
","/**
 * Set filter on partial service uuid. The {@code uuidMask} is the bit mask for the
 * {@code serviceUuid}. Set any bit in the mask to 1 to indicate a match is needed for the
 * bit in {@code serviceUuid}, and 0 to ignore that bit.
 *
 * @throws IllegalArgumentException If {@code serviceUuid} is {@code null} but {@code
 * uuidMask} is not {@code null}.
 */
",1,,,0,,,,0,0,0,0,0,There is no change in the code implementation between the early and late versions including comments or annotations. Both versions of the method perform identical operations and checks.,"Since there are no changes between the early and late versions, there is no compatibility issue."
60,"<android.app.usage.NetworkStatsManager: NetworkStats queryDetailsForUid(int,String,long,long,int)>",27,28,,,,"MethodDeclaration(method_body, [Statement({, []), Statement(}, [])])  Statement({, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(}, [])])  Statement({, [])  Statement(}, [])",1,"/**
 * Query network usage statistics details for a given uid.
 *
 * #see queryDetailsForUidTag(int, String, long, long, int, int)
 */
","/**
 * Query network usage statistics details for a given uid.
 *
 * #see queryDetailsForUidTagState(int, String, long, long, int, int, int)
 */
",1,,,0,,,,"1,2","1,5",1,0,0,"There are no changes in the method implementation between the early and late versions as both versions only contain an empty method body. The comment reference change does not affect the method's implementation, so the code change type is 0.","As there are no changes in the method implementation between versions, there are no potential differences in return values or exception handling behaviors, so the CI type is 0."
61,<android.net.NetworkStats.Entry: String toString()>,27,28,,,,"MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(final StringBuilder builder, []), Expression(new StringBuilder(), [])]), AssignmentExpression(=, [VariableReference(builder.append(""iface, []), Expression("").append(iface), [])]), AssignmentExpression(=, [VariableReference(builder.append("" uid, []), Expression("").append(uid), [])]), AssignmentExpression(=, [VariableReference(builder.append("" set, []), Expression("").append(setToString(set)), [])]), AssignmentExpression(=, [VariableReference(builder.append("" tag, []), Expression("").append(tagToString(tag)), [])]), AssignmentExpression(=, [VariableReference(builder.append("" metered, []), Expression("").append(meteredToString(metered)), [])]), AssignmentExpression(=, [VariableReference(builder.append("" roaming, []), Expression("").append(roamingToString(roaming)), [])]), AssignmentExpression(=, [VariableReference(builder.append("" rxBytes, []), Expression("").append(rxBytes), [])]), AssignmentExpression(=, [VariableReference(builder.append("" rxPackets, []), Expression("").append(rxPackets), [])]), AssignmentExpression(=, [VariableReference(builder.append("" txBytes, []), Expression("").append(txBytes), [])]), AssignmentExpression(=, [VariableReference(builder.append("" txPackets, []), Expression("").append(txPackets), [])]), AssignmentExpression(=, [VariableReference(builder.append("" operations, []), Expression("").append(operations), [])]), MethodCall(return builder.toString(), [VariableReference(return builder, []), Expression(, [])]), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(final StringBuilder builder, []), Expression(new StringBuilder(), [])])    VariableReference(final StringBuilder builder, [])    Expression(new StringBuilder(), [])  AssignmentExpression(=, [VariableReference(builder.append(""iface, []), Expression("").append(iface), [])])    VariableReference(builder.append(""iface, [])    Expression("").append(iface), [])  AssignmentExpression(=, [VariableReference(builder.append("" uid, []), Expression("").append(uid), [])])    VariableReference(builder.append("" uid, [])    Expression("").append(uid), [])  AssignmentExpression(=, [VariableReference(builder.append("" set, []), Expression("").append(setToString(set)), [])])    VariableReference(builder.append("" set, [])    Expression("").append(setToString(set)), [])  AssignmentExpression(=, [VariableReference(builder.append("" tag, []), Expression("").append(tagToString(tag)), [])])    VariableReference(builder.append("" tag, [])    Expression("").append(tagToString(tag)), [])  AssignmentExpression(=, [VariableReference(builder.append("" metered, []), Expression("").append(meteredToString(metered)), [])])    VariableReference(builder.append("" metered, [])    Expression("").append(meteredToString(metered)), [])  AssignmentExpression(=, [VariableReference(builder.append("" roaming, []), Expression("").append(roamingToString(roaming)), [])])    VariableReference(builder.append("" roaming, [])    Expression("").append(roamingToString(roaming)), [])  AssignmentExpression(=, [VariableReference(builder.append("" rxBytes, []), Expression("").append(rxBytes), [])])    VariableReference(builder.append("" rxBytes, [])    Expression("").append(rxBytes), [])  AssignmentExpression(=, [VariableReference(builder.append("" rxPackets, []), Expression("").append(rxPackets), [])])    VariableReference(builder.append("" rxPackets, [])    Expression("").append(rxPackets), [])  AssignmentExpression(=, [VariableReference(builder.append("" txBytes, []), Expression("").append(txBytes), [])])    VariableReference(builder.append("" txBytes, [])    Expression("").append(txBytes), [])  AssignmentExpression(=, [VariableReference(builder.append("" txPackets, []), Expression("").append(txPackets), [])])    VariableReference(builder.append("" txPackets, [])    Expression("").append(txPackets), [])  AssignmentExpression(=, [VariableReference(builder.append("" operations, []), Expression("").append(operations), [])])    VariableReference(builder.append("" operations, [])    Expression("").append(operations), [])  MethodCall(return builder.toString(), [VariableReference(return builder, []), Expression(, [])])    VariableReference(return builder, [])    Expression(, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(final StringBuilder builder, []), Expression(new StringBuilder(), [])]), AssignmentExpression(=, [VariableReference(builder.append(""iface, []), Expression("").append(iface), [])]), AssignmentExpression(=, [VariableReference(builder.append("" uid, []), Expression("").append(uid), [])]), AssignmentExpression(=, [VariableReference(builder.append("" set, []), Expression("").append(setToString(set)), [])]), AssignmentExpression(=, [VariableReference(builder.append("" tag, []), Expression("").append(tagToString(tag)), [])]), AssignmentExpression(=, [VariableReference(builder.append("" metered, []), Expression("").append(meteredToString(metered)), [])]), AssignmentExpression(=, [VariableReference(builder.append("" roaming, []), Expression("").append(roamingToString(roaming)), [])]), AssignmentExpression(=, [VariableReference(builder.append("" defaultNetwork, []), Expression("").append(defaultNetworkToString(defaultNetwork)), [])]), AssignmentExpression(=, [VariableReference(builder.append("" rxBytes, []), Expression("").append(rxBytes), [])]), AssignmentExpression(=, [VariableReference(builder.append("" rxPackets, []), Expression("").append(rxPackets), [])]), AssignmentExpression(=, [VariableReference(builder.append("" txBytes, []), Expression("").append(txBytes), [])]), AssignmentExpression(=, [VariableReference(builder.append("" txPackets, []), Expression("").append(txPackets), [])]), AssignmentExpression(=, [VariableReference(builder.append("" operations, []), Expression("").append(operations), [])]), MethodCall(return builder.toString(), [VariableReference(return builder, []), Expression(, [])]), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(final StringBuilder builder, []), Expression(new StringBuilder(), [])])    VariableReference(final StringBuilder builder, [])    Expression(new StringBuilder(), [])  AssignmentExpression(=, [VariableReference(builder.append(""iface, []), Expression("").append(iface), [])])    VariableReference(builder.append(""iface, [])    Expression("").append(iface), [])  AssignmentExpression(=, [VariableReference(builder.append("" uid, []), Expression("").append(uid), [])])    VariableReference(builder.append("" uid, [])    Expression("").append(uid), [])  AssignmentExpression(=, [VariableReference(builder.append("" set, []), Expression("").append(setToString(set)), [])])    VariableReference(builder.append("" set, [])    Expression("").append(setToString(set)), [])  AssignmentExpression(=, [VariableReference(builder.append("" tag, []), Expression("").append(tagToString(tag)), [])])    VariableReference(builder.append("" tag, [])    Expression("").append(tagToString(tag)), [])  AssignmentExpression(=, [VariableReference(builder.append("" metered, []), Expression("").append(meteredToString(metered)), [])])    VariableReference(builder.append("" metered, [])    Expression("").append(meteredToString(metered)), [])  AssignmentExpression(=, [VariableReference(builder.append("" roaming, []), Expression("").append(roamingToString(roaming)), [])])    VariableReference(builder.append("" roaming, [])    Expression("").append(roamingToString(roaming)), [])  AssignmentExpression(=, [VariableReference(builder.append("" defaultNetwork, []), Expression("").append(defaultNetworkToString(defaultNetwork)), [])])    VariableReference(builder.append("" defaultNetwork, [])    Expression("").append(defaultNetworkToString(defaultNetwork)), [])  AssignmentExpression(=, [VariableReference(builder.append("" rxBytes, []), Expression("").append(rxBytes), [])])    VariableReference(builder.append("" rxBytes, [])    Expression("").append(rxBytes), [])  AssignmentExpression(=, [VariableReference(builder.append("" rxPackets, []), Expression("").append(rxPackets), [])])    VariableReference(builder.append("" rxPackets, [])    Expression("").append(rxPackets), [])  AssignmentExpression(=, [VariableReference(builder.append("" txBytes, []), Expression("").append(txBytes), [])])    VariableReference(builder.append("" txBytes, [])    Expression("").append(txBytes), [])  AssignmentExpression(=, [VariableReference(builder.append("" txPackets, []), Expression("").append(txPackets), [])])    VariableReference(builder.append("" txPackets, [])    Expression("").append(txPackets), [])  AssignmentExpression(=, [VariableReference(builder.append("" operations, []), Expression("").append(operations), [])])    VariableReference(builder.append("" operations, [])    Expression("").append(operations), [])  MethodCall(return builder.toString(), [VariableReference(return builder, []), Expression(, [])])    VariableReference(return builder, [])    Expression(, [])  Statement(}, [])",1,,,0,[@Override],[@Override],0,,,,"1,2","1,4",1,4,0,"A new assignment expression `builder.append("" defaultNetwork"").append(defaultNetworkToString(defaultNetwork));` has been introduced in the late implementation, so the code change type is classified as 4.","This change does not affect the return value or exception handling directly, so there is no Compatibility Issue."
62,<android.webkit.WebChromeClient: boolean onConsoleMessage(ConsoleMessage)>,27,28,,,,"MethodDeclaration(method_body, [Statement({, []), Statement(// Call the old version of this function for backwards compatability., []), MethodCall(onConsoleMessage(consoleMessage.message(), consoleMessage.lineNumber(), consoleMessage.sourceId()), [VariableReference(onConsoleMessage(consoleMessage, []), Expression(), []), Expression(consoleMessage.lineNumber(), []), Expression(consoleMessage.sourceId(), [])]), Statement(return false, []), Statement(}, [])])  Statement({, [])  Statement(// Call the old version of this function for backwards compatability., [])  MethodCall(onConsoleMessage(consoleMessage.message(), consoleMessage.lineNumber(), consoleMessage.sourceId()), [VariableReference(onConsoleMessage(consoleMessage, []), Expression(), []), Expression(consoleMessage.lineNumber(), []), Expression(consoleMessage.sourceId(), [])])    VariableReference(onConsoleMessage(consoleMessage, [])    Expression(), [])    Expression(consoleMessage.lineNumber(), [])    Expression(consoleMessage.sourceId(), [])  Statement(return false, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(// Call the old version of this function for backwards compatability., []), MethodCall(onConsoleMessage(consoleMessage.message(), consoleMessage.lineNumber(), consoleMessage.sourceId()), [VariableReference(onConsoleMessage(consoleMessage, []), Expression(), []), Expression(consoleMessage.lineNumber(), []), Expression(consoleMessage.sourceId(), [])]), Statement(return false, []), Statement(}, [])])  Statement({, [])  Statement(// Call the old version of this function for backwards compatability., [])  MethodCall(onConsoleMessage(consoleMessage.message(), consoleMessage.lineNumber(), consoleMessage.sourceId()), [VariableReference(onConsoleMessage(consoleMessage, []), Expression(), []), Expression(consoleMessage.lineNumber(), []), Expression(consoleMessage.sourceId(), [])])    VariableReference(onConsoleMessage(consoleMessage, [])    Expression(), [])    Expression(consoleMessage.lineNumber(), [])    Expression(consoleMessage.sourceId(), [])  Statement(return false, [])  Statement(}, [])",0,"/**
 * Report a JavaScript console message to the host application. The ChromeClient
 * should override this to process the log message as they see fit.
 * @param consoleMessage Object containing details of the console message.
 * @return true if the message is handled by the client.
 */
","/**
 * Report a JavaScript console message to the host application. The ChromeClient
 * should override this to process the log message as they see fit.
 * @param consoleMessage Object containing details of the console message.
 * @return {@code true} if the message is handled by the client.
 */
",1,,,0,,,,0,0,0,0,0,There is no detected difference in the code implementations between the early and late versions based on the provided AST nodes.,No compatibility issue exists as there is no change in the method implementation.
63,"<android.hardware.radio.RadioManager.ModuleProperties: void writeToParcel(Parcel,int)>",26,27,,,,"MethodDeclaration(method_body, [Statement({, []), MethodCall(dest.writeInt(mId), [VariableReference(dest, []), Expression(mId, [])]), MethodCall(dest.writeInt(mClassId), [VariableReference(dest, []), Expression(mClassId, [])]), MethodCall(dest.writeString(mImplementor), [VariableReference(dest, []), Expression(mImplementor, [])]), MethodCall(dest.writeString(mProduct), [VariableReference(dest, []), Expression(mProduct, [])]), MethodCall(dest.writeString(mVersion), [VariableReference(dest, []), Expression(mVersion, [])]), MethodCall(dest.writeString(mSerial), [VariableReference(dest, []), Expression(mSerial, [])]), MethodCall(dest.writeInt(mNumTuners), [VariableReference(dest, []), Expression(mNumTuners, [])]), MethodCall(dest.writeInt(mNumAudioSources), [VariableReference(dest, []), Expression(mNumAudioSources, [])]), MethodCall(dest.writeInt(mIsCaptureSupported ? 1 : 0), [VariableReference(dest, []), Expression(mIsCaptureSupported ? 1 : 0, [])]), MethodCall(dest.writeParcelableArray(mBands, flags), [VariableReference(dest, []), Expression(mBands, []), Expression(flags, [])]), Statement(}, [])])  Statement({, [])  MethodCall(dest.writeInt(mId), [VariableReference(dest, []), Expression(mId, [])])    VariableReference(dest, [])    Expression(mId, [])  MethodCall(dest.writeInt(mClassId), [VariableReference(dest, []), Expression(mClassId, [])])    VariableReference(dest, [])    Expression(mClassId, [])  MethodCall(dest.writeString(mImplementor), [VariableReference(dest, []), Expression(mImplementor, [])])    VariableReference(dest, [])    Expression(mImplementor, [])  MethodCall(dest.writeString(mProduct), [VariableReference(dest, []), Expression(mProduct, [])])    VariableReference(dest, [])    Expression(mProduct, [])  MethodCall(dest.writeString(mVersion), [VariableReference(dest, []), Expression(mVersion, [])])    VariableReference(dest, [])    Expression(mVersion, [])  MethodCall(dest.writeString(mSerial), [VariableReference(dest, []), Expression(mSerial, [])])    VariableReference(dest, [])    Expression(mSerial, [])  MethodCall(dest.writeInt(mNumTuners), [VariableReference(dest, []), Expression(mNumTuners, [])])    VariableReference(dest, [])    Expression(mNumTuners, [])  MethodCall(dest.writeInt(mNumAudioSources), [VariableReference(dest, []), Expression(mNumAudioSources, [])])    VariableReference(dest, [])    Expression(mNumAudioSources, [])  MethodCall(dest.writeInt(mIsCaptureSupported ? 1 : 0), [VariableReference(dest, []), Expression(mIsCaptureSupported ? 1 : 0, [])])    VariableReference(dest, [])    Expression(mIsCaptureSupported ? 1 : 0, [])  MethodCall(dest.writeParcelableArray(mBands, flags), [VariableReference(dest, []), Expression(mBands, []), Expression(flags, [])])    VariableReference(dest, [])    Expression(mBands, [])    Expression(flags, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), MethodCall(dest.writeInt(mId), [VariableReference(dest, []), Expression(mId, [])]), MethodCall(dest.writeString(mServiceName), [VariableReference(dest, []), Expression(mServiceName, [])]), MethodCall(dest.writeInt(mClassId), [VariableReference(dest, []), Expression(mClassId, [])]), MethodCall(dest.writeString(mImplementor), [VariableReference(dest, []), Expression(mImplementor, [])]), MethodCall(dest.writeString(mProduct), [VariableReference(dest, []), Expression(mProduct, [])]), MethodCall(dest.writeString(mVersion), [VariableReference(dest, []), Expression(mVersion, [])]), MethodCall(dest.writeString(mSerial), [VariableReference(dest, []), Expression(mSerial, [])]), MethodCall(dest.writeInt(mNumTuners), [VariableReference(dest, []), Expression(mNumTuners, [])]), MethodCall(dest.writeInt(mNumAudioSources), [VariableReference(dest, []), Expression(mNumAudioSources, [])]), MethodCall(dest.writeInt(mIsCaptureSupported ? 1 : 0), [VariableReference(dest, []), Expression(mIsCaptureSupported ? 1 : 0, [])]), MethodCall(dest.writeParcelableArray(mBands, flags), [VariableReference(dest, []), Expression(mBands, []), Expression(flags, [])]), MethodCall(dest.writeInt(mIsBgScanSupported ? 1 : 0), [VariableReference(dest, []), Expression(mIsBgScanSupported ? 1 : 0, [])]), MethodCall(dest.writeIntArray(setToArray(mSupportedProgramTypes)), [VariableReference(dest, []), Expression(setToArray(mSupportedProgramTypes), [])]), MethodCall(dest.writeIntArray(setToArray(mSupportedIdentifierTypes)), [VariableReference(dest, []), Expression(setToArray(mSupportedIdentifierTypes), [])]), Statement(writeStringMap(dest, mVendorInfo), []), Statement(}, [])])  Statement({, [])  MethodCall(dest.writeInt(mId), [VariableReference(dest, []), Expression(mId, [])])    VariableReference(dest, [])    Expression(mId, [])  MethodCall(dest.writeString(mServiceName), [VariableReference(dest, []), Expression(mServiceName, [])])    VariableReference(dest, [])    Expression(mServiceName, [])  MethodCall(dest.writeInt(mClassId), [VariableReference(dest, []), Expression(mClassId, [])])    VariableReference(dest, [])    Expression(mClassId, [])  MethodCall(dest.writeString(mImplementor), [VariableReference(dest, []), Expression(mImplementor, [])])    VariableReference(dest, [])    Expression(mImplementor, [])  MethodCall(dest.writeString(mProduct), [VariableReference(dest, []), Expression(mProduct, [])])    VariableReference(dest, [])    Expression(mProduct, [])  MethodCall(dest.writeString(mVersion), [VariableReference(dest, []), Expression(mVersion, [])])    VariableReference(dest, [])    Expression(mVersion, [])  MethodCall(dest.writeString(mSerial), [VariableReference(dest, []), Expression(mSerial, [])])    VariableReference(dest, [])    Expression(mSerial, [])  MethodCall(dest.writeInt(mNumTuners), [VariableReference(dest, []), Expression(mNumTuners, [])])    VariableReference(dest, [])    Expression(mNumTuners, [])  MethodCall(dest.writeInt(mNumAudioSources), [VariableReference(dest, []), Expression(mNumAudioSources, [])])    VariableReference(dest, [])    Expression(mNumAudioSources, [])  MethodCall(dest.writeInt(mIsCaptureSupported ? 1 : 0), [VariableReference(dest, []), Expression(mIsCaptureSupported ? 1 : 0, [])])    VariableReference(dest, [])    Expression(mIsCaptureSupported ? 1 : 0, [])  MethodCall(dest.writeParcelableArray(mBands, flags), [VariableReference(dest, []), Expression(mBands, []), Expression(flags, [])])    VariableReference(dest, [])    Expression(mBands, [])    Expression(flags, [])  MethodCall(dest.writeInt(mIsBgScanSupported ? 1 : 0), [VariableReference(dest, []), Expression(mIsBgScanSupported ? 1 : 0, [])])    VariableReference(dest, [])    Expression(mIsBgScanSupported ? 1 : 0, [])  MethodCall(dest.writeIntArray(setToArray(mSupportedProgramTypes)), [VariableReference(dest, []), Expression(setToArray(mSupportedProgramTypes), [])])    VariableReference(dest, [])    Expression(setToArray(mSupportedProgramTypes), [])  MethodCall(dest.writeIntArray(setToArray(mSupportedIdentifierTypes)), [VariableReference(dest, []), Expression(setToArray(mSupportedIdentifierTypes), [])])    VariableReference(dest, [])    Expression(setToArray(mSupportedIdentifierTypes), [])  Statement(writeStringMap(dest, mVendorInfo), [])  Statement(}, [])",1,,,0,[@Override],[@Override],0,,,,"1,2","1,4",1,4,0,"Additional fields and statements have been added in the late version implementation for writing more properties to the Parcel object. These changes include new calls to `writeString`, `writeInt`, `writeIntArray`, and a method call to `writeStringMap`. Therefore, the change type is 4.","The added statements do not affect the return type or exception handling of the method. They are additional operations for writing data to the Parcel, which does not result in any compatibility issues in terms of different return values or exceptions. Therefore, the CI type is 0."
64,<android.app.Notification.Builder: Builder setGroupAlertBehavior(int)>,26,27,,,,"MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(mN.mGroupAlertBehavior, []), Expression(groupAlertBehavior, [])]), Statement(return this, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(mN.mGroupAlertBehavior, []), Expression(groupAlertBehavior, [])])    VariableReference(mN.mGroupAlertBehavior, [])    Expression(groupAlertBehavior, [])  Statement(return this, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(mN.mGroupAlertBehavior, []), Expression(groupAlertBehavior, [])]), Statement(return this, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(mN.mGroupAlertBehavior, []), Expression(groupAlertBehavior, [])])    VariableReference(mN.mGroupAlertBehavior, [])    Expression(groupAlertBehavior, [])  Statement(return this, [])  Statement(}, [])",0,"/**
 * Sets the group alert behavior for this notification. Use this method to mute this
 * notification if alerts for this notification's group should be handled by a different
 * notification. This is only applicable for notifications that belong to a
 * {@link #setGroup(String) group}.
 *
 * <p> The default value is {@link #GROUP_ALERT_ALL}.</p>
 */
","/**
 * Sets the group alert behavior for this notification. Use this method to mute this
 * notification if alerts for this notification's group should be handled by a different
 * notification. This is only applicable for notifications that belong to a
 * {@link #setGroup(String) group}. This must be called on all notifications you want to
 * mute. For example, if you want only the summary of your group to make noise, all
 * children in the group should have the group alert behavior {@link #GROUP_ALERT_SUMMARY}.
 *
 * <p> The default value is {@link #GROUP_ALERT_ALL}.</p>
 */
",1,,,0,,,,0,0,0,0,0,There are no changes in the implementation and annotations. The only modification is in the comments.,"Since there are no changes in the implementation, return statements, exception handling, control dependencies, or dependent APIs, there is no compatibility issue. The change in comments does not affect the behavior of the API."
65,"<android.app.FragmentManagerImpl: void dispatchOnFragmentPreAttached(Fragment,Context,boolean)>",26,27,,,,"MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(if (mParent !, []), Expression(null) {, [])]), AssignmentExpression(=, [VariableReference(FragmentManager parentManager, []), Expression(mParent.getFragmentManager(), [])]), Statement(if (parentManager instanceof FragmentManagerImpl) {, []), MethodCall(((FragmentManagerImpl) parentManager).dispatchOnFragmentPreAttached(f, context, true), [VariableReference(((FragmentManagerImpl) parentManager), []), Expression(f, []), Expression(context, []), Expression(true, [])]), Statement(}, []), Statement(}, []), AssignmentExpression(=, [VariableReference(if (mLifecycleCallbacks, []), Expression(, [])]), Statement(return, []), Statement(}, []), Statement(for (Pair<FragmentLifecycleCallbacks, Boolean> p : mLifecycleCallbacks) {, []), Statement(}, []), Statement(}, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(if (mParent !, []), Expression(null) {, [])])    VariableReference(if (mParent !, [])    Expression(null) {, [])  AssignmentExpression(=, [VariableReference(FragmentManager parentManager, []), Expression(mParent.getFragmentManager(), [])])    VariableReference(FragmentManager parentManager, [])    Expression(mParent.getFragmentManager(), [])  Statement(if (parentManager instanceof FragmentManagerImpl) {, [])  MethodCall(((FragmentManagerImpl) parentManager).dispatchOnFragmentPreAttached(f, context, true), [VariableReference(((FragmentManagerImpl) parentManager), []), Expression(f, []), Expression(context, []), Expression(true, [])])    VariableReference(((FragmentManagerImpl) parentManager), [])    Expression(f, [])    Expression(context, [])    Expression(true, [])  Statement(}, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(if (mLifecycleCallbacks, []), Expression(, [])])    VariableReference(if (mLifecycleCallbacks, [])    Expression(, [])  Statement(return, [])  Statement(}, [])  Statement(for (Pair<FragmentLifecycleCallbacks, Boolean> p : mLifecycleCallbacks) {, [])  Statement(}, [])  Statement(}, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(if (mParent !, []), Expression(null) {, [])]), AssignmentExpression(=, [VariableReference(FragmentManager parentManager, []), Expression(mParent.getFragmentManager(), [])]), Statement(if (parentManager instanceof FragmentManagerImpl) {, []), MethodCall(((FragmentManagerImpl) parentManager).dispatchOnFragmentPreAttached(f, context, true), [VariableReference(((FragmentManagerImpl) parentManager), []), Expression(f, []), Expression(context, []), Expression(true, [])]), Statement(}, []), Statement(}, []), Statement(for (Pair<FragmentLifecycleCallbacks, Boolean> p : mLifecycleCallbacks) {, []), Statement(}, []), Statement(}, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(if (mParent !, []), Expression(null) {, [])])    VariableReference(if (mParent !, [])    Expression(null) {, [])  AssignmentExpression(=, [VariableReference(FragmentManager parentManager, []), Expression(mParent.getFragmentManager(), [])])    VariableReference(FragmentManager parentManager, [])    Expression(mParent.getFragmentManager(), [])  Statement(if (parentManager instanceof FragmentManagerImpl) {, [])  MethodCall(((FragmentManagerImpl) parentManager).dispatchOnFragmentPreAttached(f, context, true), [VariableReference(((FragmentManagerImpl) parentManager), []), Expression(f, []), Expression(context, []), Expression(true, [])])    VariableReference(((FragmentManagerImpl) parentManager), [])    Expression(f, [])    Expression(context, [])    Expression(true, [])  Statement(}, [])  Statement(}, [])  Statement(for (Pair<FragmentLifecycleCallbacks, Boolean> p : mLifecycleCallbacks) {, [])  Statement(}, [])  Statement(}, [])  Statement(}, [])",1,,,0,,,0,,,,1,"1,3",1,4,0,"The early version contains a redundant if statement check for `mLifecycleCallbacks` before entering the for-loop, which was removed in the late version. This change simplifies the code but does not alter its behavior since the for-loop would handle the same cases either way. Hence, the code change is classified as 4.","Since the core logic and control flow of the method remain unchanged, no different return values or exceptions are introduced. Therefore, there is no Compatibility Issue, and the CI type is 0."
66,<android.widget.ArrayAdapter: CharSequence[] getAutofillOptions()>,26,27,,,,"MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(if (!mObjectsFromResources || mObjects, []), Expression(, [])]), Statement(return null, []), Statement(}, []), AssignmentExpression(=, [VariableReference(final int size, []), Expression(mObjects.size(), [])]), AssignmentExpression(=, [VariableReference(final CharSequence[] options, []), Expression(new CharSequence[size], [])]), MethodCall(mObjects.toArray(options), [VariableReference(mObjects, []), Expression(options, [])]), Statement(return options, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(if (!mObjectsFromResources || mObjects, []), Expression(, [])])    VariableReference(if (!mObjectsFromResources || mObjects, [])    Expression(, [])  Statement(return null, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(final int size, []), Expression(mObjects.size(), [])])    VariableReference(final int size, [])    Expression(mObjects.size(), [])  AssignmentExpression(=, [VariableReference(final CharSequence[] options, []), Expression(new CharSequence[size], [])])    VariableReference(final CharSequence[] options, [])    Expression(new CharSequence[size], [])  MethodCall(mObjects.toArray(options), [VariableReference(mObjects, []), Expression(options, [])])    VariableReference(mObjects, [])    Expression(options, [])  Statement(return options, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(// First check if app developer explicitly set them., []), AssignmentExpression(=, [VariableReference(final CharSequence[] explicitOptions, []), Expression(super.getAutofillOptions(), [])]), AssignmentExpression(=, [VariableReference(if (explicitOptions !, []), Expression(null) {, [])]), Statement(return explicitOptions, []), Statement(}, []), Statement(// Otherwise, only return options that came from static resources., []), AssignmentExpression(=, [VariableReference(if (!mObjectsFromResources || mObjects, []), Expression(, [])]), Statement(return null, []), Statement(}, []), AssignmentExpression(=, [VariableReference(final int size, []), Expression(mObjects.size(), [])]), AssignmentExpression(=, [VariableReference(final CharSequence[] options, []), Expression(new CharSequence[size], [])]), MethodCall(mObjects.toArray(options), [VariableReference(mObjects, []), Expression(options, [])]), Statement(return options, []), Statement(}, [])])  Statement({, [])  Statement(// First check if app developer explicitly set them., [])  AssignmentExpression(=, [VariableReference(final CharSequence[] explicitOptions, []), Expression(super.getAutofillOptions(), [])])    VariableReference(final CharSequence[] explicitOptions, [])    Expression(super.getAutofillOptions(), [])  AssignmentExpression(=, [VariableReference(if (explicitOptions !, []), Expression(null) {, [])])    VariableReference(if (explicitOptions !, [])    Expression(null) {, [])  Statement(return explicitOptions, [])  Statement(}, [])  Statement(// Otherwise, only return options that came from static resources., [])  AssignmentExpression(=, [VariableReference(if (!mObjectsFromResources || mObjects, []), Expression(, [])])    VariableReference(if (!mObjectsFromResources || mObjects, [])    Expression(, [])  Statement(return null, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(final int size, []), Expression(mObjects.size(), [])])    VariableReference(final int size, [])    Expression(mObjects.size(), [])  AssignmentExpression(=, [VariableReference(final CharSequence[] options, []), Expression(new CharSequence[size], [])])    VariableReference(final CharSequence[] options, [])    Expression(new CharSequence[size], [])  MethodCall(mObjects.toArray(options), [VariableReference(mObjects, []), Expression(options, [])])    VariableReference(mObjects, [])    Expression(options, [])  Statement(return options, [])  Statement(}, [])",1,"/**
 * {@inheritDoc}
 *
 * @return values from the string array used by {@link #createFromResource(Context, int, int)},
 * or {@code null} if object was created otherwsie or if contents were dynamically changed after
 * creation.
 */
","/**
 * {@inheritDoc}
 *
 * @return values from the string array used by {@link #createFromResource(Context, int, int)},
 * or {@code null} if object was created otherwsie or if contents were dynamically changed after
 * creation.
 */
",0,[@Override],[@Override],0,,,,"1,2","1,3,4",1,"1,3,5",1,"The late version introduces a check for explicitly set options from `super.getAutofillOptions()`, affecting the return value and `if` control dependencies. The dependent method `super.getAutofillOptions()` is also involved. Thus, the change type is 1,3,5.","The introduction of `super.getAutofillOptions()` and the new control logic can lead to different return values compared to the early version, causing potential compatibility issues. Hence, the CI type is 1."
67,<android.os.PowerManager.WakeLock: String toString()>,26,27,,,,"MethodDeclaration(method_body, [Statement({, []), Statement(synchronized (mToken) {, []), AssignmentExpression(=, [VariableReference(return ""WakeLock{"" + Integer.toHexString(System.identityHashCode(this)) + "" held, []), Expression("" + mHeld + "", refCount, [])]), Statement(}, []), Statement(}, [])])  Statement({, [])  Statement(synchronized (mToken) {, [])  AssignmentExpression(=, [VariableReference(return ""WakeLock{"" + Integer.toHexString(System.identityHashCode(this)) + "" held, []), Expression("" + mHeld + "", refCount, [])])    VariableReference(return ""WakeLock{"" + Integer.toHexString(System.identityHashCode(this)) + "" held, [])    Expression("" + mHeld + "", refCount, [])  Statement(}, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(synchronized (mToken) {, []), AssignmentExpression(=, [VariableReference(return ""WakeLock{"" + Integer.toHexString(System.identityHashCode(this)) + "" held, []), Expression("" + mHeld + "", refCount, [])]), Statement(}, []), Statement(}, [])])  Statement({, [])  Statement(synchronized (mToken) {, [])  AssignmentExpression(=, [VariableReference(return ""WakeLock{"" + Integer.toHexString(System.identityHashCode(this)) + "" held, []), Expression("" + mHeld + "", refCount, [])])    VariableReference(return ""WakeLock{"" + Integer.toHexString(System.identityHashCode(this)) + "" held, [])    Expression("" + mHeld + "", refCount, [])  Statement(}, [])  Statement(}, [])",1,,,0,[@Override],[@Override],0,,,,2,"1,5",1,0,0,"The implementation and comments for the `toString()` method in both versions are identical based on the provided AST nodes and information. Hence, no code changes were detected.","There is no potential for different behaviors since there were no changes between the early and late versions. Therefore, no compatibility issue exists."
68,<android.service.vr.VrListenerService.VrListenerHandler: void handleMessage(Message)>,26,27,,,,"MethodDeclaration(method_body, [Statement({, []), Statement(case MSG_ON_CURRENT_VR_ACTIVITY_CHANGED:, []), Statement({, []), Statement(}, []), Statement(break, []), Statement(}, []), Statement(}, [])])  Statement({, [])  Statement(case MSG_ON_CURRENT_VR_ACTIVITY_CHANGED:, [])  Statement({, [])  Statement(}, [])  Statement(break, [])  Statement(}, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(case MSG_ON_CURRENT_VR_ACTIVITY_CHANGED:, []), Statement({, []), AssignmentExpression(=, [VariableReference(VrListenerService.this.onCurrentVrActivityChanged((ComponentName) msg.obj, msg.arg1, []), Expression(, [])]), Statement(}, []), Statement(break, []), Statement(}, []), Statement(}, [])])  Statement({, [])  Statement(case MSG_ON_CURRENT_VR_ACTIVITY_CHANGED:, [])  Statement({, [])  AssignmentExpression(=, [VariableReference(VrListenerService.this.onCurrentVrActivityChanged((ComponentName) msg.obj, msg.arg1, []), Expression(, [])])    VariableReference(VrListenerService.this.onCurrentVrActivityChanged((ComponentName) msg.obj, msg.arg1, [])    Expression(, [])  Statement(}, [])  Statement(break, [])  Statement(}, [])  Statement(}, [])",1,,,0,[@Override],[@Override],0,,,,2,5,0,4,0,"An assignment statement was introduced within the case `MSG_ON_CURRENT_VR_ACTIVITY_CHANGED` block in the late version, so the change type is 4.","The additional statement does not alter the return value or introduce new exception handling; hence, no Compatibility Issue arises, so the CI type is 0."
69,<android.hardware.usb.UsbConfiguration: String getName()>,25,26,,,,"MethodDeclaration(method_body, [Statement({, []), Statement(return mName, []), Statement(}, [])])  Statement({, [])  Statement(return mName, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(return mName, []), Statement(}, [])])  Statement({, [])  Statement(return mName, [])  Statement(}, [])",0,"/**
 * Returns the configuration's name.
 *
 * @return the configuration's name
 */
","/**
 * Returns the configuration's name.
 *
 * @return the configuration's name, or {@code null} if the property could not be read
 */
",1,,[@Nullable],1,,,,0,0,0,0,0,"There is no change in the code implementation in both versions according to the AST nodes. The comments have minor wording differences, but they do not affect the method's behavior.","Since there is no change in the actual code implementation, the CI type is 0."
70,"<android.hardware.usb.UsbDeviceConnection: int bulkTransfer(UsbEndpoint,byte[],int,int)>",25,26,,,,"MethodDeclaration(method_body, [Statement({, []), Statement(return bulkTransfer(endpoint, buffer, 0, length, timeout), []), Statement(}, [])])  Statement({, [])  Statement(return bulkTransfer(endpoint, buffer, 0, length, timeout), [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(return bulkTransfer(endpoint, buffer, 0, length, timeout), []), Statement(}, [])])  Statement({, [])  Statement(return bulkTransfer(endpoint, buffer, 0, length, timeout), [])  Statement(}, [])",0,"/**
 * Performs a bulk transaction on the given endpoint.
 * The direction of the transfer is determined by the direction of the endpoint.
 * <p>
 * This method transfers data starting from index 0 in the buffer.
 * To specify a different offset, use
 * {@link #bulkTransfer(UsbEndpoint, byte[], int, int, int)}.
 * </p>
 *
 * @param endpoint the endpoint for this transaction
 * @param buffer buffer for data to send or receive
 * @param length the length of the data to send or receive
 * @param timeout in milliseconds
 * @return length of data transferred (or zero) for success,
 * or negative value for failure
 */
","/**
 * Performs a bulk transaction on the given endpoint.
 * The direction of the transfer is determined by the direction of the endpoint.
 * <p>
 * This method transfers data starting from index 0 in the buffer.
 * To specify a different offset, use
 * {@link #bulkTransfer(UsbEndpoint, byte[], int, int, int)}.
 * </p>
 *
 * @param endpoint the endpoint for this transaction
 * @param buffer buffer for data to send or receive; can be {@code null} to wait for next
 * transaction without reading data
 * @param length the length of the data to send or receive
 * @param timeout in milliseconds, 0 is infinite
 * @return length of data transferred (or zero) for success,
 * or negative value for failure
 */
",1,,,0,,,,0,0,0,0,0,"The abstract syntax tree (AST) nodes for both early and late implementations are identical, indicating there are no changes in the code.","As there are no changes in the code, there is no potential for different return values or exception handling, hence no compatibility issues exist."
71,<android.app.Fragment: boolean getAllowEnterTransitionOverlap()>,25,26,,,,"MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(return (mAllowEnterTransitionOverlap, []), Expression(, [])]), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(return (mAllowEnterTransitionOverlap, []), Expression(, [])])    VariableReference(return (mAllowEnterTransitionOverlap, [])    Expression(, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(return (mAnimationInfo, []), Expression(, [])]), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(return (mAnimationInfo, []), Expression(, [])])    VariableReference(return (mAnimationInfo, [])    Expression(, [])  Statement(}, [])",1,"/**
 * Returns whether the the exit transition and enter transition overlap or not.
 * When true, the enter transition will start as soon as possible. When false, the
 * enter transition will wait until the exit transition completes before starting.
 *
 * @return true when the enter transition should start as soon as possible or false to
 * when it should wait until the exiting transition completes.
 * @attr ref android.R.styleable#Fragment_fragmentAllowEnterTransitionOverlap
 */
","/**
 * Returns whether the the exit transition and enter transition overlap or not.
 * When true, the enter transition will start as soon as possible. When false, the
 * enter transition will wait until the exit transition completes before starting.
 *
 * @return true when the enter transition should start as soon as possible or false to
 * when it should wait until the exiting transition completes.
 * @attr ref android.R.styleable#Fragment_fragmentAllowEnterTransitionOverlap
 */
",0,,,0,,,,"1,2","1,5",1,1,1,The return statement within the method has changed from returning `mAllowEnterTransitionOverlap` to `mAnimationInfo`. This falls under the "Return statement changed" category.,"This change can lead to the method returning different boolean values between the two versions, potentially altering the behavior of the calling code. Hence, the compatibility issue type is 1, indicating potential different return values."
72,<android.content.pm.ShortcutManager: boolean setDynamicShortcuts(List<ShortcutInfo>)>,25,26,,,,"MethodDeclaration(method_body, [Statement({, []), Statement(try {, []), MethodCall(return mService.setDynamicShortcuts(mContext.getPackageName(), new ParceledListSlice(shortcutInfoList), injectMyUserId()), [VariableReference(return mService, []), Expression(mContext.getPackageName(), []), Expression(new ParceledListSlice(shortcutInfoList), []), Expression(injectMyUserId(), [])]), Statement(} catch (RemoteException e) {, []), MethodCall(throw e.rethrowFromSystemServer(), [VariableReference(throw e, []), Expression(, [])]), Statement(}, []), Statement(}, [])])  Statement({, [])  Statement(try {, [])  MethodCall(return mService.setDynamicShortcuts(mContext.getPackageName(), new ParceledListSlice(shortcutInfoList), injectMyUserId()), [VariableReference(return mService, []), Expression(mContext.getPackageName(), []), Expression(new ParceledListSlice(shortcutInfoList), []), Expression(injectMyUserId(), [])])    VariableReference(return mService, [])    Expression(mContext.getPackageName(), [])    Expression(new ParceledListSlice(shortcutInfoList), [])    Expression(injectMyUserId(), [])  Statement(} catch (RemoteException e) {, [])  MethodCall(throw e.rethrowFromSystemServer(), [VariableReference(throw e, []), Expression(, [])])    VariableReference(throw e, [])    Expression(, [])  Statement(}, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(try {, []), MethodCall(return mService.setDynamicShortcuts(mContext.getPackageName(), new ParceledListSlice(shortcutInfoList), injectMyUserId()), [VariableReference(return mService, []), Expression(mContext.getPackageName(), []), Expression(new ParceledListSlice(shortcutInfoList), []), Expression(injectMyUserId(), [])]), Statement(} catch (RemoteException e) {, []), MethodCall(throw e.rethrowFromSystemServer(), [VariableReference(throw e, []), Expression(, [])]), Statement(}, []), Statement(}, [])])  Statement({, [])  Statement(try {, [])  MethodCall(return mService.setDynamicShortcuts(mContext.getPackageName(), new ParceledListSlice(shortcutInfoList), injectMyUserId()), [VariableReference(return mService, []), Expression(mContext.getPackageName(), []), Expression(new ParceledListSlice(shortcutInfoList), []), Expression(injectMyUserId(), [])])    VariableReference(return mService, [])    Expression(mContext.getPackageName(), [])    Expression(new ParceledListSlice(shortcutInfoList), [])    Expression(injectMyUserId(), [])  Statement(} catch (RemoteException e) {, [])  MethodCall(throw e.rethrowFromSystemServer(), [VariableReference(throw e, []), Expression(, [])])    VariableReference(throw e, [])    Expression(, [])  Statement(}, [])  Statement(}, [])",0,"/**
 * Publish the list of shortcuts.  All existing dynamic shortcuts from the caller application
 * will be replaced.  If there are already pinned shortcuts with the same IDs,
 * the mutable pinned shortcuts are updated.
 *
 * <p>This API will be rate-limited.
 *
 * @return {@code true} if the call has succeeded. {@code false} if the call is rate-limited.
 *
 * @throws IllegalArgumentException if {@link #getMaxShortcutCountPerActivity()} is exceeded,
 * or when trying to update immutable shortcuts.
 *
 * @throws IllegalStateException when the user is locked.
 */
","/**
 * Publish the list of shortcuts.  All existing dynamic shortcuts from the caller app
 * will be replaced.  If there are already pinned shortcuts with the same IDs,
 * the mutable pinned shortcuts are updated.
 *
 * <p>This API will be rate-limited.
 *
 * @return {@code true} if the call has succeeded. {@code false} if the call is rate-limited.
 *
 * @throws IllegalArgumentException if {@link #getMaxShortcutCountPerActivity()} is exceeded,
 * or when trying to update immutable shortcuts.
 *
 * @throws IllegalStateException when the user is locked.
 */
",1,,,0,,,,0,0,0,0,0,"There are no changes between the early and late versions regarding the method body, comments, or annotations.","Since there are no code changes, there are no compatibility issues."
73,"<android.app.Activity: void startActivityFromFragment(Fragment,Intent,int,Bundle)>",25,26,,,,"MethodDeclaration(method_body, [Statement({, []), Statement(}, [])])  Statement({, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(}, [])])  Statement({, [])  Statement(}, [])",0,"/**
 * This is called when a Fragment in this activity calls its
 * {@link Fragment#startActivity} or {@link Fragment#startActivityForResult}
 * method.
 *
 * <p>This method throws {@link android.content.ActivityNotFoundException}
 * if there was no Activity found to run the given Intent.
 *
 * @param fragment The fragment making the call.
 * @param intent The intent to start.
 * @param requestCode Reply request code.  < 0 if reply is not requested.
 * @param options Additional options for how the Activity should be started.
 * See {@link android.content.Context#startActivity(Intent, Bundle)
 * Context.startActivity(Intent, Bundle)} for more details.
 *
 * @throws android.content.ActivityNotFoundException
 *
 * @see Fragment#startActivity
 * @see Fragment#startActivityForResult
 */
","/**
 * This is called when a Fragment in this activity calls its
 * {@link Fragment#startActivity} or {@link Fragment#startActivityForResult}
 * method.
 *
 * <p>This method throws {@link android.content.ActivityNotFoundException}
 * if there was no Activity found to run the given Intent.
 *
 * @param fragment The fragment making the call.
 * @param intent The intent to start.
 * @param requestCode Reply request code.  < 0 if reply is not requested.
 * @param options Additional options for how the Activity should be started.
 * See {@link android.content.Context#startActivity(Intent, Bundle)}
 * Context.startActivity(Intent, Bundle)} for more details.
 *
 * @throws android.content.ActivityNotFoundException
 *
 * @see Fragment#startActivity
 * @see Fragment#startActivityForResult
 */
",1,,,0,,,,0,0,0,0,0,"There are no changes between the early and late implementations, comments, or annotations.",No compatibility issues exist as there are no changes between the early and late versions.
74,<android.app.FragmentManagerImpl: void dispatchDestroy()>,25,26,,,,"MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(mDestroyed, []), Expression(true, [])]), Statement(execPendingActions(), []), AssignmentExpression(=, [VariableReference(mHost, []), Expression(null, [])]), AssignmentExpression(=, [VariableReference(mContainer, []), Expression(null, [])]), AssignmentExpression(=, [VariableReference(mParent, []), Expression(null, [])]), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(mDestroyed, []), Expression(true, [])])    VariableReference(mDestroyed, [])    Expression(true, [])  Statement(execPendingActions(), [])  AssignmentExpression(=, [VariableReference(mHost, []), Expression(null, [])])    VariableReference(mHost, [])    Expression(null, [])  AssignmentExpression(=, [VariableReference(mContainer, []), Expression(null, [])])    VariableReference(mContainer, [])    Expression(null, [])  AssignmentExpression(=, [VariableReference(mParent, []), Expression(null, [])])    VariableReference(mParent, [])    Expression(null, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(mDestroyed, []), Expression(true, [])]), Statement(execPendingActions(), []), AssignmentExpression(=, [VariableReference(mHost, []), Expression(null, [])]), AssignmentExpression(=, [VariableReference(mContainer, []), Expression(null, [])]), AssignmentExpression(=, [VariableReference(mParent, []), Expression(null, [])]), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(mDestroyed, []), Expression(true, [])])    VariableReference(mDestroyed, [])    Expression(true, [])  Statement(execPendingActions(), [])  AssignmentExpression(=, [VariableReference(mHost, []), Expression(null, [])])    VariableReference(mHost, [])    Expression(null, [])  AssignmentExpression(=, [VariableReference(mContainer, []), Expression(null, [])])    VariableReference(mContainer, [])    Expression(null, [])  AssignmentExpression(=, [VariableReference(mParent, []), Expression(null, [])])    VariableReference(mParent, [])    Expression(null, [])  Statement(}, [])",1,,,0,,,0,,,,2,5,1,0,0,There is no change in the method implementation between the early_version and the late_version.,"Since there are no changes in the implementation, no compatibility issues exist based on the given definitions."
75,"<android.content.res.ResourcesImpl.ThemeImpl: TypedArray obtainStyledAttributes(Theme,AttributeSet,int[],int,int)>",25,26,,,,"MethodDeclaration(method_body, [Statement({, []), Statement(synchronized (mKey) {, []), AssignmentExpression(=, [VariableReference(final int len, []), Expression(attrs.length, [])]), AssignmentExpression(=, [VariableReference(final TypedArray array, []), Expression(TypedArray.obtain(wrapper.getResources(), len), [])]), Statement(// XXX note that for now we only work with compiled XML files., []), Statement(// To support generic XML files we will need to manually parse, []), Statement(// out the attributes from the XML file (applying type information, []), Statement(// contained in the resources and such)., []), AssignmentExpression(=, [VariableReference(final XmlBlock.Parser parser, []), Expression((XmlBlock.Parser) set, [])]), AssignmentExpression(=, [VariableReference(AssetManager.applyStyle(mTheme, defStyleAttr, defStyleRes, parser !, []), Expression(null ? parser.mParseState : 0, attrs, array.mData, array.mIndices), [])]), AssignmentExpression(=, [VariableReference(array.mTheme, []), Expression(wrapper, [])]), AssignmentExpression(=, [VariableReference(array.mXml, []), Expression(parser, [])]), Statement(return array, []), Statement(}, []), Statement(}, [])])  Statement({, [])  Statement(synchronized (mKey) {, [])  AssignmentExpression(=, [VariableReference(final int len, []), Expression(attrs.length, [])])    VariableReference(final int len, [])    Expression(attrs.length, [])  AssignmentExpression(=, [VariableReference(final TypedArray array, []), Expression(TypedArray.obtain(wrapper.getResources(), len), [])])    VariableReference(final TypedArray array, [])    Expression(TypedArray.obtain(wrapper.getResources(), len), [])  Statement(// XXX note that for now we only work with compiled XML files., [])  Statement(// To support generic XML files we will need to manually parse, [])  Statement(// out the attributes from the XML file (applying type information, [])  Statement(// contained in the resources and such)., [])  AssignmentExpression(=, [VariableReference(final XmlBlock.Parser parser, []), Expression((XmlBlock.Parser) set, [])])    VariableReference(final XmlBlock.Parser parser, [])    Expression((XmlBlock.Parser) set, [])  AssignmentExpression(=, [VariableReference(AssetManager.applyStyle(mTheme, defStyleAttr, defStyleRes, parser !, []), Expression(null ? parser.mParseState : 0, attrs, array.mData, array.mIndices), [])])    VariableReference(AssetManager.applyStyle(mTheme, defStyleAttr, defStyleRes, parser !, [])    Expression(null ? parser.mParseState : 0, attrs, array.mData, array.mIndices), [])  AssignmentExpression(=, [VariableReference(array.mTheme, []), Expression(wrapper, [])])    VariableReference(array.mTheme, [])    Expression(wrapper, [])  AssignmentExpression(=, [VariableReference(array.mXml, []), Expression(parser, [])])    VariableReference(array.mXml, [])    Expression(parser, [])  Statement(return array, [])  Statement(}, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(synchronized (mKey) {, []), AssignmentExpression(=, [VariableReference(final int len, []), Expression(attrs.length, [])]), AssignmentExpression(=, [VariableReference(final TypedArray array, []), Expression(TypedArray.obtain(wrapper.getResources(), len), [])]), Statement(// XXX note that for now we only work with compiled XML files., []), Statement(// To support generic XML files we will need to manually parse, []), Statement(// out the attributes from the XML file (applying type information, []), Statement(// contained in the resources and such)., []), AssignmentExpression(=, [VariableReference(final XmlBlock.Parser parser, []), Expression((XmlBlock.Parser) set, [])]), AssignmentExpression(=, [VariableReference(AssetManager.applyStyle(mTheme, defStyleAttr, defStyleRes, parser !, []), Expression(null ? parser.mParseState : 0, attrs, attrs.length, array.mDataAddress, array.mIndicesAddress), [])]), AssignmentExpression(=, [VariableReference(array.mTheme, []), Expression(wrapper, [])]), AssignmentExpression(=, [VariableReference(array.mXml, []), Expression(parser, [])]), Statement(return array, []), Statement(}, []), Statement(}, [])])  Statement({, [])  Statement(synchronized (mKey) {, [])  AssignmentExpression(=, [VariableReference(final int len, []), Expression(attrs.length, [])])    VariableReference(final int len, [])    Expression(attrs.length, [])  AssignmentExpression(=, [VariableReference(final TypedArray array, []), Expression(TypedArray.obtain(wrapper.getResources(), len), [])])    VariableReference(final TypedArray array, [])    Expression(TypedArray.obtain(wrapper.getResources(), len), [])  Statement(// XXX note that for now we only work with compiled XML files., [])  Statement(// To support generic XML files we will need to manually parse, [])  Statement(// out the attributes from the XML file (applying type information, [])  Statement(// contained in the resources and such)., [])  AssignmentExpression(=, [VariableReference(final XmlBlock.Parser parser, []), Expression((XmlBlock.Parser) set, [])])    VariableReference(final XmlBlock.Parser parser, [])    Expression((XmlBlock.Parser) set, [])  AssignmentExpression(=, [VariableReference(AssetManager.applyStyle(mTheme, defStyleAttr, defStyleRes, parser !, []), Expression(null ? parser.mParseState : 0, attrs, attrs.length, array.mDataAddress, array.mIndicesAddress), [])])    VariableReference(AssetManager.applyStyle(mTheme, defStyleAttr, defStyleRes, parser !, [])    Expression(null ? parser.mParseState : 0, attrs, attrs.length, array.mDataAddress, array.mIndicesAddress), [])  AssignmentExpression(=, [VariableReference(array.mTheme, []), Expression(wrapper, [])])    VariableReference(array.mTheme, [])    Expression(wrapper, [])  AssignmentExpression(=, [VariableReference(array.mXml, []), Expression(parser, [])])    VariableReference(array.mXml, [])    Expression(parser, [])  Statement(return array, [])  Statement(}, [])  Statement(}, [])",1,,,0,[@NonNull],[@NonNull],0,,,,2,5,1,4,0,"The expression within `AssetManager.applyStyle(mTheme, defStyleAttr, defStyleRes, parser !...)` has altered in the late implementation by changing parameters to `null ? parser.mParseState : 0, attrs, attrs.length, array.mDataAddress, array.mIndicesAddress`. This change belongs to other statement changes.","The change is not likely to produce different values or handle exceptions differently, so no compatibility issue is observed."
76,<android.app.admin.DevicePolicyManager: int getPermissionPolicy(ComponentName)>,25,26,,,,"MethodDeclaration(method_body, [Statement({, []), Statement(throwIfParentInstance(""getPermissionPolicy""), []), Statement(try {, []), MethodCall(return mService.getPermissionPolicy(admin), [VariableReference(return mService, []), Expression(admin, [])]), Statement(} catch (RemoteException re) {, []), MethodCall(throw re.rethrowFromSystemServer(), [VariableReference(throw re, []), Expression(, [])]), Statement(}, []), Statement(}, [])])  Statement({, [])  Statement(throwIfParentInstance(""getPermissionPolicy""), [])  Statement(try {, [])  MethodCall(return mService.getPermissionPolicy(admin), [VariableReference(return mService, []), Expression(admin, [])])    VariableReference(return mService, [])    Expression(admin, [])  Statement(} catch (RemoteException re) {, [])  MethodCall(throw re.rethrowFromSystemServer(), [VariableReference(throw re, []), Expression(, [])])    VariableReference(throw re, [])    Expression(, [])  Statement(}, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(throwIfParentInstance(""getPermissionPolicy""), []), Statement(try {, []), MethodCall(return mService.getPermissionPolicy(admin), [VariableReference(return mService, []), Expression(admin, [])]), Statement(} catch (RemoteException re) {, []), MethodCall(throw re.rethrowFromSystemServer(), [VariableReference(throw re, []), Expression(, [])]), Statement(}, []), Statement(}, [])])  Statement({, [])  Statement(throwIfParentInstance(""getPermissionPolicy""), [])  Statement(try {, [])  MethodCall(return mService.getPermissionPolicy(admin), [VariableReference(return mService, []), Expression(admin, [])])    VariableReference(return mService, [])    Expression(admin, [])  Statement(} catch (RemoteException re) {, [])  MethodCall(throw re.rethrowFromSystemServer(), [VariableReference(throw re, []), Expression(, [])])    VariableReference(throw re, [])    Expression(, [])  Statement(}, [])  Statement(}, [])",0,"/**
 * Returns the current runtime permission policy set by the device or profile owner. The
 * default is {@link #PERMISSION_POLICY_PROMPT}.
 * @param admin Which profile or device owner this request is associated with.
 * @return the current policy for future permission requests.
 */
","/**
 * Returns the current runtime permission policy set by the device or profile owner. The
 * default is {@link #PERMISSION_POLICY_PROMPT}.
 *
 * @param admin Which profile or device owner this request is associated with.
 * @return the current policy for future permission requests.
 */
",1,,,0,,,,0,0,0,0,0,There are no changes between the early and late implementations. The method body and AST nodes are identical.,"Since there are no changes in the implementation, no Compatibility Issue exists."
77,"<android.app.Notification.Builder: Builder setSound(Uri,int)>",25,26,,,,"MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(mN.sound, []), Expression(sound, [])]), AssignmentExpression(=, [VariableReference(mN.audioStreamType, []), Expression(streamType, [])]), Statement(return this, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(mN.sound, []), Expression(sound, [])])    VariableReference(mN.sound, [])    Expression(sound, [])  AssignmentExpression(=, [VariableReference(mN.audioStreamType, []), Expression(streamType, [])])    VariableReference(mN.audioStreamType, [])    Expression(streamType, [])  Statement(return this, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), MethodCall(PlayerBase.deprecateStreamTypeForPlayback(streamType, ""Notification"", ""setSound()""), [VariableReference(PlayerBase, []), Expression(streamType, []), Expression(""Notification"", []), Expression(""setSound()"", [])]), AssignmentExpression(=, [VariableReference(mN.sound, []), Expression(sound, [])]), AssignmentExpression(=, [VariableReference(mN.audioStreamType, []), Expression(streamType, [])]), Statement(return this, []), Statement(}, [])])  Statement({, [])  MethodCall(PlayerBase.deprecateStreamTypeForPlayback(streamType, ""Notification"", ""setSound()""), [VariableReference(PlayerBase, []), Expression(streamType, []), Expression(""Notification"", []), Expression(""setSound()"", [])])    VariableReference(PlayerBase, [])    Expression(streamType, [])    Expression(""Notification"", [])    Expression(""setSound()"", [])  AssignmentExpression(=, [VariableReference(mN.sound, []), Expression(sound, [])])    VariableReference(mN.sound, [])    Expression(sound, [])  AssignmentExpression(=, [VariableReference(mN.audioStreamType, []), Expression(streamType, [])])    VariableReference(mN.audioStreamType, [])    Expression(streamType, [])  Statement(return this, [])  Statement(}, [])",1,"/**
 * Set the sound to play, along with a specific stream on which to play it.
 *
 * See {@link android.media.AudioManager} for the <code>STREAM_</code> constants.
 *
 * <p>
 * A notification that is noisy is more likely to be presented as a heads-up notification.
 * </p>
 * @deprecated use {@link #setSound(Uri, AudioAttributes)} instead.
 * @see Notification#sound
 */
","/**
 * Set the sound to play, along with a specific stream on which to play it.
 *
 * See {@link android.media.AudioManager} for the <code>STREAM_</code> constants.
 *
 * @deprecated use {@link NotificationChannel#setSound(Uri, AudioAttributes)}.
 */
",1,[@Deprecated],[@Deprecated],0,,,,2,4,0,4,0,"A new method call (PlayerBase.deprecateStreamTypeForPlayback) is added before assigning the values to `mN.sound` and `mN.audioStreamType`, so the code change type is 4.","Although the change involves adding a method call that may log a warning or internally handle the stream type deprecation, it does not affect the return value or exception handling of the `setSound(Uri,int)` method. Therefore, no compatibility issue exists."
78,"<android.provider.DocumentsProvider: String renameDocument(String,String)>",25,26,,,,"MethodDeclaration(method_body, [Statement({, []), Statement(throw new UnsupportedOperationException(""Rename not supported""), []), Statement(}, [])])  Statement({, [])  Statement(throw new UnsupportedOperationException(""Rename not supported""), [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(throw new UnsupportedOperationException(""Rename not supported""), []), Statement(}, [])])  Statement({, [])  Statement(throw new UnsupportedOperationException(""Rename not supported""), [])  Statement(}, [])",0,"/**
 * Rename an existing document.
 * <p>
 * If a different {@link Document#COLUMN_DOCUMENT_ID} must be used to
 * represent the renamed document, generate and return it. Any outstanding
 * URI permission grants will be updated to point at the new document. If
 * the original {@link Document#COLUMN_DOCUMENT_ID} is still valid after the
 * rename, return {@code null}.
 *
 * @param documentId the document to rename.
 * @param displayName the updated display name of the document. The provider
 * may alter this name to meet any internal constraints, such as
 * avoiding conflicting names.
 */
","/**
 * Rename an existing document.
 * <p>
 * If a different {@link Document#COLUMN_DOCUMENT_ID} must be used to
 * represent the renamed document, generate and return it. Any outstanding
 * URI permission grants will be updated to point at the new document. If
 * the original {@link Document#COLUMN_DOCUMENT_ID} is still valid after the
 * rename, return {@code null}.
 *
 * @param documentId the document to rename.
 * @param displayName the updated display name of the document. The provider
 * may alter this name to meet any internal constraints, such as
 * avoiding conflicting names.
 * @throws AuthenticationRequiredException If authentication is required from
 * the user (such as login credentials), but it is not guaranteed
 * that the client will handle this properly.
 */
",1,[@SuppressWarnings("unused")],[@SuppressWarnings("unused")],0,,,,0,0,0,2,2,"Although the implementation of the method body has not changed, the Late comment introduces the possibility of throwing an `AuthenticationRequiredException`. Thus, the code change type is 2.","The updated comment suggests that an `AuthenticationRequiredException` may be thrown, which was not indicated in the Early version. So, the CI type is 2."
79,"<android.app.admin.DevicePolicyManager: boolean isPackageSuspended(ComponentName,String)>",25,26,,,,"MethodDeclaration(method_body, [Statement({, []), Statement(throwIfParentInstance(""isPackageSuspended""), []), AssignmentExpression(=, [VariableReference(if (mService !, []), Expression(null) {, [])]), Statement(try {, []), MethodCall(return mService.isPackageSuspended(admin, packageName), [VariableReference(return mService, []), Expression(admin, []), Expression(packageName, [])]), Statement(} catch (RemoteException e) {, []), MethodCall(throw e.rethrowFromSystemServer(), [VariableReference(throw e, []), Expression(, [])]), Statement(} catch (IllegalArgumentException ex) {, []), Statement(throw new NameNotFoundException(packageName), []), Statement(}, []), Statement(}, []), Statement(return false, []), Statement(}, [])])  Statement({, [])  Statement(throwIfParentInstance(""isPackageSuspended""), [])  AssignmentExpression(=, [VariableReference(if (mService !, []), Expression(null) {, [])])    VariableReference(if (mService !, [])    Expression(null) {, [])  Statement(try {, [])  MethodCall(return mService.isPackageSuspended(admin, packageName), [VariableReference(return mService, []), Expression(admin, []), Expression(packageName, [])])    VariableReference(return mService, [])    Expression(admin, [])    Expression(packageName, [])  Statement(} catch (RemoteException e) {, [])  MethodCall(throw e.rethrowFromSystemServer(), [VariableReference(throw e, []), Expression(, [])])    VariableReference(throw e, [])    Expression(, [])  Statement(} catch (IllegalArgumentException ex) {, [])  Statement(throw new NameNotFoundException(packageName), [])  Statement(}, [])  Statement(}, [])  Statement(return false, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(throwIfParentInstance(""isPackageSuspended""), []), AssignmentExpression(=, [VariableReference(if (mService !, []), Expression(null) {, [])]), Statement(try {, []), MethodCall(return mService.isPackageSuspended(admin, mContext.getPackageName(), packageName), [VariableReference(return mService, []), Expression(admin, []), Expression(mContext.getPackageName(), []), Expression(packageName, [])]), Statement(} catch (RemoteException e) {, []), MethodCall(throw e.rethrowFromSystemServer(), [VariableReference(throw e, []), Expression(, [])]), Statement(} catch (IllegalArgumentException ex) {, []), Statement(throw new NameNotFoundException(packageName), []), Statement(}, []), Statement(}, []), Statement(return false, []), Statement(}, [])])  Statement({, [])  Statement(throwIfParentInstance(""isPackageSuspended""), [])  AssignmentExpression(=, [VariableReference(if (mService !, []), Expression(null) {, [])])    VariableReference(if (mService !, [])    Expression(null) {, [])  Statement(try {, [])  MethodCall(return mService.isPackageSuspended(admin, mContext.getPackageName(), packageName), [VariableReference(return mService, []), Expression(admin, []), Expression(mContext.getPackageName(), []), Expression(packageName, [])])    VariableReference(return mService, [])    Expression(admin, [])    Expression(mContext.getPackageName(), [])    Expression(packageName, [])  Statement(} catch (RemoteException e) {, [])  MethodCall(throw e.rethrowFromSystemServer(), [VariableReference(throw e, []), Expression(, [])])    VariableReference(throw e, [])    Expression(, [])  Statement(} catch (IllegalArgumentException ex) {, [])  Statement(throw new NameNotFoundException(packageName), [])  Statement(}, [])  Statement(}, [])  Statement(return false, [])  Statement(}, [])",1,"/**
 * Called by device or profile owners to determine if a package is suspended.
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated with.
 * @param packageName The name of the package to retrieve the suspended status of.
 * @return {@code true} if the package is suspended or {@code false} if the package is not
 * suspended, could not be found or an error occurred.
 * @throws SecurityException if {@code admin} is not a device or profile owner.
 * @throws NameNotFoundException if the package could not be found.
 */
","/**
 * Determine if a package is suspended. This function can be called by a device owner, profile
 * owner, or by a delegate given the {@link #DELEGATION_PACKAGE_ACCESS} scope via
 * {@link #setDelegatedScopes}.
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated with, or
 * {@code null} if the caller is a package access delegate.
 * @param packageName The name of the package to retrieve the suspended status of.
 * @return {@code true} if the package is suspended or {@code false} if the package is not
 * suspended, could not be found or an error occurred.
 * @throws SecurityException if {@code admin} is not a device or profile owner.
 * @throws NameNotFoundException if the package could not be found.
 * @see #setDelegatedScopes
 * @see #DELEGATION_PACKAGE_ACCESS
 */
",1,,,0,,,,2,"1,5",1,5,1,"The API call to `mService.isPackageSuspended` has changed its parameters from `(admin, packageName)` to `(admin, mContext.getPackageName(), packageName)`. Therefore, the dependent API has changed, so the change type is 5.","There's a potential for the API to return different values due to changes in the parameters passed to the dependent method `mService.isPackageSuspended`. Hence, the CI type is 1."
80,<android.app.UiAutomation: AccessibilityNodeInfo findFocus(int)>,25,26,,,,"MethodDeclaration(method_body, [Statement({, []), MethodCall(return AccessibilityInteractionClient.getInstance().findFocus(mConnectionId, AccessibilityNodeInfo.ANY_WINDOW_ID, AccessibilityNodeInfo.ROOT_NODE_ID, focus), [VariableReference(return AccessibilityInteractionClient, []), Expression().findFocus(mConnectionId, []), Expression(AccessibilityNodeInfo.ANY_WINDOW_ID, []), Expression(AccessibilityNodeInfo.ROOT_NODE_ID, []), Expression(focus, [])]), Statement(}, [])])  Statement({, [])  MethodCall(return AccessibilityInteractionClient.getInstance().findFocus(mConnectionId, AccessibilityNodeInfo.ANY_WINDOW_ID, AccessibilityNodeInfo.ROOT_NODE_ID, focus), [VariableReference(return AccessibilityInteractionClient, []), Expression().findFocus(mConnectionId, []), Expression(AccessibilityNodeInfo.ANY_WINDOW_ID, []), Expression(AccessibilityNodeInfo.ROOT_NODE_ID, []), Expression(focus, [])])    VariableReference(return AccessibilityInteractionClient, [])    Expression().findFocus(mConnectionId, [])    Expression(AccessibilityNodeInfo.ANY_WINDOW_ID, [])    Expression(AccessibilityNodeInfo.ROOT_NODE_ID, [])    Expression(focus, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), MethodCall(return AccessibilityInteractionClient.getInstance().findFocus(mConnectionId, AccessibilityWindowInfo.ANY_WINDOW_ID, AccessibilityNodeInfo.ROOT_NODE_ID, focus), [VariableReference(return AccessibilityInteractionClient, []), Expression().findFocus(mConnectionId, []), Expression(AccessibilityWindowInfo.ANY_WINDOW_ID, []), Expression(AccessibilityNodeInfo.ROOT_NODE_ID, []), Expression(focus, [])]), Statement(}, [])])  Statement({, [])  MethodCall(return AccessibilityInteractionClient.getInstance().findFocus(mConnectionId, AccessibilityWindowInfo.ANY_WINDOW_ID, AccessibilityNodeInfo.ROOT_NODE_ID, focus), [VariableReference(return AccessibilityInteractionClient, []), Expression().findFocus(mConnectionId, []), Expression(AccessibilityWindowInfo.ANY_WINDOW_ID, []), Expression(AccessibilityNodeInfo.ROOT_NODE_ID, []), Expression(focus, [])])    VariableReference(return AccessibilityInteractionClient, [])    Expression().findFocus(mConnectionId, [])    Expression(AccessibilityWindowInfo.ANY_WINDOW_ID, [])    Expression(AccessibilityNodeInfo.ROOT_NODE_ID, [])    Expression(focus, [])  Statement(}, [])",1,"/**
 * Find the view that has the specified focus type. The search is performed
 * across all windows.
 * <p>
 * <strong>Note:</strong> In order to access the windows you have to opt-in
 * to retrieve the interactive windows by setting the
 * {@link AccessibilityServiceInfo#FLAG_RETRIEVE_INTERACTIVE_WINDOWS} flag.
 * Otherwise, the search will be performed only in the active window.
 * </p>
 *
 * @param focus The focus to find. One of {@link AccessibilityNodeInfo#FOCUS_INPUT} or
 * {@link AccessibilityNodeInfo#FOCUS_ACCESSIBILITY}.
 * @return The node info of the focused view or null.
 *
 * @see AccessibilityNodeInfo#FOCUS_INPUT
 * @see AccessibilityNodeInfo#FOCUS_ACCESSIBILITY
 */
","/**
 * Find the view that has the specified focus type. The search is performed
 * across all windows.
 * <p>
 * <strong>Note:</strong> In order to access the windows you have to opt-in
 * to retrieve the interactive windows by setting the
 * {@link AccessibilityServiceInfo#FLAG_RETRIEVE_INTERACTIVE_WINDOWS} flag.
 * Otherwise, the search will be performed only in the active window.
 * </p>
 *
 * @param focus The focus to find. One of {@link AccessibilityNodeInfo#FOCUS_INPUT} or
 * {@link AccessibilityNodeInfo#FOCUS_ACCESSIBILITY}.
 * @return The node info of the focused view or null.
 *
 * @see AccessibilityNodeInfo#FOCUS_INPUT
 * @see AccessibilityNodeInfo#FOCUS_ACCESSIBILITY
 */
",0,,,0,,,,"1,2","1,5",1,"1,5",1,"The return statement has changed in terms of the parameter from `AccessibilityNodeInfo.ANY_WINDOW_ID` to `AccessibilityWindowInfo.ANY_WINDOW_ID`. This change involves a different type in the dependent API, so the code change type is 1,5.","Since the parameter type passed to the `findFocus` method has changed, this can potentially lead to the method returning different values, thus a Compatibility Issue exists. Therefore, the CI type is 1."
81,"<android.net.nsd.NsdServiceInfo: Map<String, byte[]> getAttributes()>",25,26,,,,"MethodDeclaration(method_body, [Statement({, []), MethodCall(return Collections.unmodifiableMap(mTxtRecord), [VariableReference(return Collections, []), Expression(mTxtRecord, [])]), Statement(}, [])])  Statement({, [])  MethodCall(return Collections.unmodifiableMap(mTxtRecord), [VariableReference(return Collections, []), Expression(mTxtRecord, [])])    VariableReference(return Collections, [])    Expression(mTxtRecord, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), MethodCall(return Collections.unmodifiableMap(mTxtRecord), [VariableReference(return Collections, []), Expression(mTxtRecord, [])]), Statement(}, [])])  Statement({, [])  MethodCall(return Collections.unmodifiableMap(mTxtRecord), [VariableReference(return Collections, []), Expression(mTxtRecord, [])])    VariableReference(return Collections, [])    Expression(mTxtRecord, [])  Statement(}, [])",0,"/**
 * Retrive attributes as a map of String keys to byte[] values.
 *
 * <p> The returned map is unmodifiable; changes must be made through {@link #setAttribute} and
 * {@link #removeAttribute}.
 */
","/**
 * Retrieve attributes as a map of String keys to byte[] values. The attributes map is only
 * valid for a resolved service.
 *
 * <p> The returned map is unmodifiable; changes must be made through {@link #setAttribute} and
 * {@link #removeAttribute}.
 */
",1,,,0,,,,0,0,0,0,0,There are no changes in the actual method implementation or its structure as the AST nodes for both versions are identical. The comments have a slight difference but they do not affect the behavior of the method.,"There are no changes in the method's return value or exception handling, so no compatibility issue exists."
82,"<android.content.pm.PackageInstaller.SessionParams: void writeToParcel(Parcel,int)>",25,26,,,,"MethodDeclaration(method_body, [Statement({, []), MethodCall(dest.writeInt(mode), [VariableReference(dest, []), Expression(mode, [])]), MethodCall(dest.writeInt(installFlags), [VariableReference(dest, []), Expression(installFlags, [])]), MethodCall(dest.writeInt(installLocation), [VariableReference(dest, []), Expression(installLocation, [])]), MethodCall(dest.writeLong(sizeBytes), [VariableReference(dest, []), Expression(sizeBytes, [])]), MethodCall(dest.writeString(appPackageName), [VariableReference(dest, []), Expression(appPackageName, [])]), MethodCall(dest.writeParcelable(appIcon, flags), [VariableReference(dest, []), Expression(appIcon, []), Expression(flags, [])]), MethodCall(dest.writeString(appLabel), [VariableReference(dest, []), Expression(appLabel, [])]), MethodCall(dest.writeParcelable(originatingUri, flags), [VariableReference(dest, []), Expression(originatingUri, []), Expression(flags, [])]), MethodCall(dest.writeInt(originatingUid), [VariableReference(dest, []), Expression(originatingUid, [])]), MethodCall(dest.writeParcelable(referrerUri, flags), [VariableReference(dest, []), Expression(referrerUri, []), Expression(flags, [])]), MethodCall(dest.writeString(abiOverride), [VariableReference(dest, []), Expression(abiOverride, [])]), MethodCall(dest.writeString(volumeUuid), [VariableReference(dest, []), Expression(volumeUuid, [])]), MethodCall(dest.writeStringArray(grantedRuntimePermissions), [VariableReference(dest, []), Expression(grantedRuntimePermissions, [])]), Statement(}, [])])  Statement({, [])  MethodCall(dest.writeInt(mode), [VariableReference(dest, []), Expression(mode, [])])    VariableReference(dest, [])    Expression(mode, [])  MethodCall(dest.writeInt(installFlags), [VariableReference(dest, []), Expression(installFlags, [])])    VariableReference(dest, [])    Expression(installFlags, [])  MethodCall(dest.writeInt(installLocation), [VariableReference(dest, []), Expression(installLocation, [])])    VariableReference(dest, [])    Expression(installLocation, [])  MethodCall(dest.writeLong(sizeBytes), [VariableReference(dest, []), Expression(sizeBytes, [])])    VariableReference(dest, [])    Expression(sizeBytes, [])  MethodCall(dest.writeString(appPackageName), [VariableReference(dest, []), Expression(appPackageName, [])])    VariableReference(dest, [])    Expression(appPackageName, [])  MethodCall(dest.writeParcelable(appIcon, flags), [VariableReference(dest, []), Expression(appIcon, []), Expression(flags, [])])    VariableReference(dest, [])    Expression(appIcon, [])    Expression(flags, [])  MethodCall(dest.writeString(appLabel), [VariableReference(dest, []), Expression(appLabel, [])])    VariableReference(dest, [])    Expression(appLabel, [])  MethodCall(dest.writeParcelable(originatingUri, flags), [VariableReference(dest, []), Expression(originatingUri, []), Expression(flags, [])])    VariableReference(dest, [])    Expression(originatingUri, [])    Expression(flags, [])  MethodCall(dest.writeInt(originatingUid), [VariableReference(dest, []), Expression(originatingUid, [])])    VariableReference(dest, [])    Expression(originatingUid, [])  MethodCall(dest.writeParcelable(referrerUri, flags), [VariableReference(dest, []), Expression(referrerUri, []), Expression(flags, [])])    VariableReference(dest, [])    Expression(referrerUri, [])    Expression(flags, [])  MethodCall(dest.writeString(abiOverride), [VariableReference(dest, []), Expression(abiOverride, [])])    VariableReference(dest, [])    Expression(abiOverride, [])  MethodCall(dest.writeString(volumeUuid), [VariableReference(dest, []), Expression(volumeUuid, [])])    VariableReference(dest, [])    Expression(volumeUuid, [])  MethodCall(dest.writeStringArray(grantedRuntimePermissions), [VariableReference(dest, []), Expression(grantedRuntimePermissions, [])])    VariableReference(dest, [])    Expression(grantedRuntimePermissions, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), MethodCall(dest.writeInt(mode), [VariableReference(dest, []), Expression(mode, [])]), MethodCall(dest.writeInt(installFlags), [VariableReference(dest, []), Expression(installFlags, [])]), MethodCall(dest.writeInt(installLocation), [VariableReference(dest, []), Expression(installLocation, [])]), MethodCall(dest.writeInt(installReason), [VariableReference(dest, []), Expression(installReason, [])]), MethodCall(dest.writeLong(sizeBytes), [VariableReference(dest, []), Expression(sizeBytes, [])]), MethodCall(dest.writeString(appPackageName), [VariableReference(dest, []), Expression(appPackageName, [])]), MethodCall(dest.writeParcelable(appIcon, flags), [VariableReference(dest, []), Expression(appIcon, []), Expression(flags, [])]), MethodCall(dest.writeString(appLabel), [VariableReference(dest, []), Expression(appLabel, [])]), MethodCall(dest.writeParcelable(originatingUri, flags), [VariableReference(dest, []), Expression(originatingUri, []), Expression(flags, [])]), MethodCall(dest.writeInt(originatingUid), [VariableReference(dest, []), Expression(originatingUid, [])]), MethodCall(dest.writeParcelable(referrerUri, flags), [VariableReference(dest, []), Expression(referrerUri, []), Expression(flags, [])]), MethodCall(dest.writeString(abiOverride), [VariableReference(dest, []), Expression(abiOverride, [])]), MethodCall(dest.writeString(volumeUuid), [VariableReference(dest, []), Expression(volumeUuid, [])]), MethodCall(dest.writeStringArray(grantedRuntimePermissions), [VariableReference(dest, []), Expression(grantedRuntimePermissions, [])]), Statement(}, [])])  Statement({, [])  MethodCall(dest.writeInt(mode), [VariableReference(dest, []), Expression(mode, [])])    VariableReference(dest, [])    Expression(mode, [])  MethodCall(dest.writeInt(installFlags), [VariableReference(dest, []), Expression(installFlags, [])])    VariableReference(dest, [])    Expression(installFlags, [])  MethodCall(dest.writeInt(installLocation), [VariableReference(dest, []), Expression(installLocation, [])])    VariableReference(dest, [])    Expression(installLocation, [])  MethodCall(dest.writeInt(installReason), [VariableReference(dest, []), Expression(installReason, [])])    VariableReference(dest, [])    Expression(installReason, [])  MethodCall(dest.writeLong(sizeBytes), [VariableReference(dest, []), Expression(sizeBytes, [])])    VariableReference(dest, [])    Expression(sizeBytes, [])  MethodCall(dest.writeString(appPackageName), [VariableReference(dest, []), Expression(appPackageName, [])])    VariableReference(dest, [])    Expression(appPackageName, [])  MethodCall(dest.writeParcelable(appIcon, flags), [VariableReference(dest, []), Expression(appIcon, []), Expression(flags, [])])    VariableReference(dest, [])    Expression(appIcon, [])    Expression(flags, [])  MethodCall(dest.writeString(appLabel), [VariableReference(dest, []), Expression(appLabel, [])])    VariableReference(dest, [])    Expression(appLabel, [])  MethodCall(dest.writeParcelable(originatingUri, flags), [VariableReference(dest, []), Expression(originatingUri, []), Expression(flags, [])])    VariableReference(dest, [])    Expression(originatingUri, [])    Expression(flags, [])  MethodCall(dest.writeInt(originatingUid), [VariableReference(dest, []), Expression(originatingUid, [])])    VariableReference(dest, [])    Expression(originatingUid, [])  MethodCall(dest.writeParcelable(referrerUri, flags), [VariableReference(dest, []), Expression(referrerUri, []), Expression(flags, [])])    VariableReference(dest, [])    Expression(referrerUri, [])    Expression(flags, [])  MethodCall(dest.writeString(abiOverride), [VariableReference(dest, []), Expression(abiOverride, [])])    VariableReference(dest, [])    Expression(abiOverride, [])  MethodCall(dest.writeString(volumeUuid), [VariableReference(dest, []), Expression(volumeUuid, [])])    VariableReference(dest, [])    Expression(volumeUuid, [])  MethodCall(dest.writeStringArray(grantedRuntimePermissions), [VariableReference(dest, []), Expression(grantedRuntimePermissions, [])])    VariableReference(dest, [])    Expression(grantedRuntimePermissions, [])  Statement(}, [])",1,,,0,[@Override],[@Override],0,,,,1,4,1,"1,4",0,A new statement `dest.writeInt(installReason)` has been added to the method body. This is classified as a return statement change as the value written to the `Parcel` can be considered part of the return values written to a `Parcel`.,"The addition of the new statement `dest.writeInt(installReason)` does not affect the return values or exception handlings of this API in a manner that leads to significant differences in behavior. Therefore, there is no corresponding compatibility issue."
83,<android.os.ParcelFileDescriptor.AutoCloseOutputStream: void close()>,28,29,,,,"MethodDeclaration(method_body, [Statement({, []), Statement(try {, []), MethodCall(mPfd.close(), [VariableReference(mPfd, []), Expression(, [])]), Statement(} finally {, []), MethodCall(super.close(), [VariableReference(super, []), Expression(, [])]), Statement(}, []), Statement(}, [])])  Statement({, [])  Statement(try {, [])  MethodCall(mPfd.close(), [VariableReference(mPfd, []), Expression(, [])])    VariableReference(mPfd, [])    Expression(, [])  Statement(} finally {, [])  MethodCall(super.close(), [VariableReference(super, []), Expression(, [])])    VariableReference(super, [])    Expression(, [])  Statement(}, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(try {, []), MethodCall(super.close(), [VariableReference(super, []), Expression(, [])]), Statement(} finally {, []), MethodCall(mPfd.close(), [VariableReference(mPfd, []), Expression(, [])]), Statement(}, []), Statement(}, [])])  Statement({, [])  Statement(try {, [])  MethodCall(super.close(), [VariableReference(super, []), Expression(, [])])    VariableReference(super, [])    Expression(, [])  Statement(} finally {, [])  MethodCall(mPfd.close(), [VariableReference(mPfd, []), Expression(, [])])    VariableReference(mPfd, [])    Expression(, [])  Statement(}, [])  Statement(}, [])",1,,,0,[@Override],[@Override],0,,,,1,3,0,"2,3",2,"The order of method calls within the try-finally block has changed. Specifically, in the early version, `mPfd.close()` is called inside the try block and `super.close()` is called inside the finally block. In the late version, `super.close()` is called inside the try block and `mPfd.close()` is called inside the finally block. This change in the order of execution affects both the control flow and the exception handling, so the change types are 2,3.","The change in the order of method calls potentially results in different exception handling behaviors. In the early version, if `mPfd.close()` throws an exception, `super.close()` will still be executed. In the late version, if `super.close()` throws an exception, the call to `mPfd.close()` in the finally block might not be properly executed. This could lead to differences in resource clean-up and exception propagation, so the CI type is 2."
84,"<android.app.usage.UsageStatsManager: List<UsageStats> queryUsageStats(int,long,long)>",28,29,,,,"MethodDeclaration(method_body, [Statement({, []), Statement(try {, []), AssignmentExpression(=, [VariableReference(@SuppressWarnings(""unchecked"") ParceledListSlice<UsageStats> slice, []), Expression(mService.queryUsageStats(intervalType, beginTime, endTime, mContext.getOpPackageName()), [])]), AssignmentExpression(=, [VariableReference(if (slice !, []), Expression(null) {, [])]), MethodCall(return slice.getList(), [VariableReference(return slice, []), Expression(, [])]), Statement(}, []), Statement(} catch (RemoteException e) {, []), Statement(// fallthrough and return the empty list., []), Statement(}, []), MethodCall(return Collections.emptyList(), [VariableReference(return Collections, []), Expression(, [])]), Statement(}, [])])  Statement({, [])  Statement(try {, [])  AssignmentExpression(=, [VariableReference(@SuppressWarnings(""unchecked"") ParceledListSlice<UsageStats> slice, []), Expression(mService.queryUsageStats(intervalType, beginTime, endTime, mContext.getOpPackageName()), [])])    VariableReference(@SuppressWarnings(""unchecked"") ParceledListSlice<UsageStats> slice, [])    Expression(mService.queryUsageStats(intervalType, beginTime, endTime, mContext.getOpPackageName()), [])  AssignmentExpression(=, [VariableReference(if (slice !, []), Expression(null) {, [])])    VariableReference(if (slice !, [])    Expression(null) {, [])  MethodCall(return slice.getList(), [VariableReference(return slice, []), Expression(, [])])    VariableReference(return slice, [])    Expression(, [])  Statement(}, [])  Statement(} catch (RemoteException e) {, [])  Statement(// fallthrough and return the empty list., [])  Statement(}, [])  MethodCall(return Collections.emptyList(), [VariableReference(return Collections, []), Expression(, [])])    VariableReference(return Collections, [])    Expression(, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(try {, []), AssignmentExpression(=, [VariableReference(@SuppressWarnings(""unchecked"") ParceledListSlice<UsageStats> slice, []), Expression(mService.queryUsageStats(intervalType, beginTime, endTime, mContext.getOpPackageName()), [])]), AssignmentExpression(=, [VariableReference(if (slice !, []), Expression(null) {, [])]), MethodCall(return slice.getList(), [VariableReference(return slice, []), Expression(, [])]), Statement(}, []), Statement(} catch (RemoteException e) {, []), Statement(// fallthrough and return the empty list., []), Statement(}, []), MethodCall(return Collections.emptyList(), [VariableReference(return Collections, []), Expression(, [])]), Statement(}, [])])  Statement({, [])  Statement(try {, [])  AssignmentExpression(=, [VariableReference(@SuppressWarnings(""unchecked"") ParceledListSlice<UsageStats> slice, []), Expression(mService.queryUsageStats(intervalType, beginTime, endTime, mContext.getOpPackageName()), [])])    VariableReference(@SuppressWarnings(""unchecked"") ParceledListSlice<UsageStats> slice, [])    Expression(mService.queryUsageStats(intervalType, beginTime, endTime, mContext.getOpPackageName()), [])  AssignmentExpression(=, [VariableReference(if (slice !, []), Expression(null) {, [])])    VariableReference(if (slice !, [])    Expression(null) {, [])  MethodCall(return slice.getList(), [VariableReference(return slice, []), Expression(, [])])    VariableReference(return slice, [])    Expression(, [])  Statement(}, [])  Statement(} catch (RemoteException e) {, [])  Statement(// fallthrough and return the empty list., [])  Statement(}, [])  MethodCall(return Collections.emptyList(), [VariableReference(return Collections, []), Expression(, [])])    VariableReference(return Collections, [])    Expression(, [])  Statement(}, [])",0,"/**
 * Gets application usage stats for the given time range, aggregated by the specified interval.
 * <p>The returned list will contain a {@link UsageStats} object for each package that
 * has data for an interval that is a subset of the time range given. To illustrate:</p>
 * <pre>
 * intervalType = INTERVAL_YEARLY
 * beginTime = 2013
 * endTime = 2015 (exclusive)
 *
 * Results:
 * 2013 - com.example.alpha
 * 2013 - com.example.beta
 * 2014 - com.example.alpha
 * 2014 - com.example.beta
 * 2014 - com.example.charlie
 * </pre>
 *
 * <p> The caller must have {@link android.Manifest.permission#PACKAGE_USAGE_STATS} </p>
 *
 * @param intervalType The time interval by which the stats are aggregated.
 * @param beginTime The inclusive beginning of the range of stats to include in the results.
 * @param endTime The exclusive end of the range of stats to include in the results.
 * @return A list of {@link UsageStats}
 *
 * @see #INTERVAL_DAILY
 * @see #INTERVAL_WEEKLY
 * @see #INTERVAL_MONTHLY
 * @see #INTERVAL_YEARLY
 * @see #INTERVAL_BEST
 */
","/**
 * Gets application usage stats for the given time range, aggregated by the specified interval.
 *
 * <p>
 * The returned list will contain one or more {@link UsageStats} objects for each package, with
 * usage data that covers at least the given time range.
 * Note: The begin and end times of the time range may be expanded to the nearest whole interval
 * period.
 * </p>
 *
 * <p> The caller must have {@link android.Manifest.permission#PACKAGE_USAGE_STATS} </p>
 *
 * @param intervalType The time interval by which the stats are aggregated.
 * @param beginTime The inclusive beginning of the range of stats to include in the results.
 * Defined in terms of ""Unix time"", see
 * {@link java.lang.System#currentTimeMillis}.
 * @param endTime The exclusive end of the range of stats to include in the results. Defined
 * in terms of ""Unix time"", see {@link java.lang.System#currentTimeMillis}.
 * @return A list of {@link UsageStats}
 *
 * @see #INTERVAL_DAILY
 * @see #INTERVAL_WEEKLY
 * @see #INTERVAL_MONTHLY
 * @see #INTERVAL_YEARLY
 * @see #INTERVAL_BEST
 */
",1,,,0,,,,0,0,0,0,0,The AST nodes for both early and late implementations indicate there are no changes (all nodes are identical).,"Since there are no changes in implementation between the two versions, no Compatibility Issue exists."
85,"<android.view.LayoutInflater: View createViewFromTag(View,String,Context,AttributeSet,boolean)>",28,29,,,,"MethodDeclaration(method_body, [Statement({, []), MethodCall(if (name.equals(""view"")), [VariableReference(if (name, []), Expression(""view""), [])]), AssignmentExpression(=, [VariableReference(name, []), Expression(attrs.getAttributeValue(null, ""class""), [])]), Statement(}, []), Statement(// Apply a theme wrapper, if allowed and one is specified., []), Statement(if (!ignoreThemeAttr) {, []), AssignmentExpression(=, [VariableReference(final TypedArray ta, []), Expression(context.obtainStyledAttributes(attrs, ATTRS_THEME), [])]), AssignmentExpression(=, [VariableReference(final int themeResId, []), Expression(ta.getResourceId(0, 0), [])]), AssignmentExpression(=, [VariableReference(if (themeResId !, []), Expression(0) {, [])]), AssignmentExpression(=, [VariableReference(context, []), Expression(new ContextThemeWrapper(context, themeResId), [])]), Statement(}, []), MethodCall(ta.recycle(), [VariableReference(ta, []), Expression(, [])]), Statement(}, []), MethodCall(if (name.equals(TAG_1995)), [VariableReference(if (name, []), Expression(TAG_1995), [])]), Statement(// Let's party like it's 1995!, []), Statement(return new BlinkLayout(context, attrs), []), Statement(}, []), Statement(try {, []), Statement(View view, []), AssignmentExpression(=, [VariableReference(if (mFactory2 !, []), Expression(null) {, [])]), AssignmentExpression(=, [VariableReference(view, []), Expression(mFactory2.onCreateView(parent, name, context, attrs), [])]), AssignmentExpression(=, [VariableReference(} else if (mFactory !, []), Expression(null) {, [])]), AssignmentExpression(=, [VariableReference(view, []), Expression(mFactory.onCreateView(name, context, attrs), [])]), Statement(} else {, []), AssignmentExpression(=, [VariableReference(view, []), Expression(null, [])]), Statement(}, []), AssignmentExpression(=, [VariableReference(if (view, []), Expression(, [])]), AssignmentExpression(=, [VariableReference(view, []), Expression(mPrivateFactory.onCreateView(parent, name, context, attrs), [])]), Statement(}, []), AssignmentExpression(=, [VariableReference(if (view, []), Expression(, [])]), AssignmentExpression(=, [VariableReference(final Object lastContext, []), Expression(mConstructorArgs[0], [])]), AssignmentExpression(=, [VariableReference(mConstructorArgs[0], []), Expression(context, [])]), Statement(try {, []), AssignmentExpression(=, [VariableReference(if (-1, []), Expression(, [])]), AssignmentExpression(=, [VariableReference(view, []), Expression(onCreateView(parent, name, attrs), [])]), Statement(} else {, []), AssignmentExpression(=, [VariableReference(view, []), Expression(createView(name, null, attrs), [])]), Statement(}, []), Statement(} finally {, []), AssignmentExpression(=, [VariableReference(mConstructorArgs[0], []), Expression(lastContext, [])]), Statement(}, []), Statement(}, []), Statement(return view, []), Statement(} catch (InflateException e) {, []), Statement(throw e, []), Statement(} catch (ClassNotFoundException e) {, []), AssignmentExpression(=, [VariableReference(final InflateException ie, []), Expression(new InflateException(attrs.getPositionDescription() + "": Error inflating class "" + name, e), [])]), MethodCall(ie.setStackTrace(EMPTY_STACK_TRACE), [VariableReference(ie, []), Expression(EMPTY_STACK_TRACE, [])]), Statement(throw ie, []), Statement(} catch (Exception e) {, []), AssignmentExpression(=, [VariableReference(final InflateException ie, []), Expression(new InflateException(attrs.getPositionDescription() + "": Error inflating class "" + name, e), [])]), MethodCall(ie.setStackTrace(EMPTY_STACK_TRACE), [VariableReference(ie, []), Expression(EMPTY_STACK_TRACE, [])]), Statement(throw ie, []), Statement(}, []), Statement(}, [])])  Statement({, [])  MethodCall(if (name.equals(""view"")), [VariableReference(if (name, []), Expression(""view""), [])])    VariableReference(if (name, [])    Expression(""view""), [])  AssignmentExpression(=, [VariableReference(name, []), Expression(attrs.getAttributeValue(null, ""class""), [])])    VariableReference(name, [])    Expression(attrs.getAttributeValue(null, ""class""), [])  Statement(}, [])  Statement(// Apply a theme wrapper, if allowed and one is specified., [])  Statement(if (!ignoreThemeAttr) {, [])  AssignmentExpression(=, [VariableReference(final TypedArray ta, []), Expression(context.obtainStyledAttributes(attrs, ATTRS_THEME), [])])    VariableReference(final TypedArray ta, [])    Expression(context.obtainStyledAttributes(attrs, ATTRS_THEME), [])  AssignmentExpression(=, [VariableReference(final int themeResId, []), Expression(ta.getResourceId(0, 0), [])])    VariableReference(final int themeResId, [])    Expression(ta.getResourceId(0, 0), [])  AssignmentExpression(=, [VariableReference(if (themeResId !, []), Expression(0) {, [])])    VariableReference(if (themeResId !, [])    Expression(0) {, [])  AssignmentExpression(=, [VariableReference(context, []), Expression(new ContextThemeWrapper(context, themeResId), [])])    VariableReference(context, [])    Expression(new ContextThemeWrapper(context, themeResId), [])  Statement(}, [])  MethodCall(ta.recycle(), [VariableReference(ta, []), Expression(, [])])    VariableReference(ta, [])    Expression(, [])  Statement(}, [])  MethodCall(if (name.equals(TAG_1995)), [VariableReference(if (name, []), Expression(TAG_1995), [])])    VariableReference(if (name, [])    Expression(TAG_1995), [])  Statement(// Let's party like it's 1995!, [])  Statement(return new BlinkLayout(context, attrs), [])  Statement(}, [])  Statement(try {, [])  Statement(View view, [])  AssignmentExpression(=, [VariableReference(if (mFactory2 !, []), Expression(null) {, [])])    VariableReference(if (mFactory2 !, [])    Expression(null) {, [])  AssignmentExpression(=, [VariableReference(view, []), Expression(mFactory2.onCreateView(parent, name, context, attrs), [])])    VariableReference(view, [])    Expression(mFactory2.onCreateView(parent, name, context, attrs), [])  AssignmentExpression(=, [VariableReference(} else if (mFactory !, []), Expression(null) {, [])])    VariableReference(} else if (mFactory !, [])    Expression(null) {, [])  AssignmentExpression(=, [VariableReference(view, []), Expression(mFactory.onCreateView(name, context, attrs), [])])    VariableReference(view, [])    Expression(mFactory.onCreateView(name, context, attrs), [])  Statement(} else {, [])  AssignmentExpression(=, [VariableReference(view, []), Expression(null, [])])    VariableReference(view, [])    Expression(null, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(if (view, []), Expression(, [])])    VariableReference(if (view, [])    Expression(, [])  AssignmentExpression(=, [VariableReference(view, []), Expression(mPrivateFactory.onCreateView(parent, name, context, attrs), [])])    VariableReference(view, [])    Expression(mPrivateFactory.onCreateView(parent, name, context, attrs), [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(if (view, []), Expression(, [])])    VariableReference(if (view, [])    Expression(, [])  AssignmentExpression(=, [VariableReference(final Object lastContext, []), Expression(mConstructorArgs[0], [])])    VariableReference(final Object lastContext, [])    Expression(mConstructorArgs[0], [])  AssignmentExpression(=, [VariableReference(mConstructorArgs[0], []), Expression(context, [])])    VariableReference(mConstructorArgs[0], [])    Expression(context, [])  Statement(try {, [])  AssignmentExpression(=, [VariableReference(if (-1, []), Expression(, [])])    VariableReference(if (-1, [])    Expression(, [])  AssignmentExpression(=, [VariableReference(view, []), Expression(onCreateView(parent, name, attrs), [])])    VariableReference(view, [])    Expression(onCreateView(parent, name, attrs), [])  Statement(} else {, [])  AssignmentExpression(=, [VariableReference(view, []), Expression(createView(name, null, attrs), [])])    VariableReference(view, [])    Expression(createView(name, null, attrs), [])  Statement(}, [])  Statement(} finally {, [])  AssignmentExpression(=, [VariableReference(mConstructorArgs[0], []), Expression(lastContext, [])])    VariableReference(mConstructorArgs[0], [])    Expression(lastContext, [])  Statement(}, [])  Statement(}, [])  Statement(return view, [])  Statement(} catch (InflateException e) {, [])  Statement(throw e, [])  Statement(} catch (ClassNotFoundException e) {, [])  AssignmentExpression(=, [VariableReference(final InflateException ie, []), Expression(new InflateException(attrs.getPositionDescription() + "": Error inflating class "" + name, e), [])])    VariableReference(final InflateException ie, [])    Expression(new InflateException(attrs.getPositionDescription() + "": Error inflating class "" + name, e), [])  MethodCall(ie.setStackTrace(EMPTY_STACK_TRACE), [VariableReference(ie, []), Expression(EMPTY_STACK_TRACE, [])])    VariableReference(ie, [])    Expression(EMPTY_STACK_TRACE, [])  Statement(throw ie, [])  Statement(} catch (Exception e) {, [])  AssignmentExpression(=, [VariableReference(final InflateException ie, []), Expression(new InflateException(attrs.getPositionDescription() + "": Error inflating class "" + name, e), [])])    VariableReference(final InflateException ie, [])    Expression(new InflateException(attrs.getPositionDescription() + "": Error inflating class "" + name, e), [])  MethodCall(ie.setStackTrace(EMPTY_STACK_TRACE), [VariableReference(ie, []), Expression(EMPTY_STACK_TRACE, [])])    VariableReference(ie, [])    Expression(EMPTY_STACK_TRACE, [])  Statement(throw ie, [])  Statement(}, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), MethodCall(if (name.equals(""view"")), [VariableReference(if (name, []), Expression(""view""), [])]), AssignmentExpression(=, [VariableReference(name, []), Expression(attrs.getAttributeValue(null, ""class""), [])]), Statement(}, []), Statement(// Apply a theme wrapper, if allowed and one is specified., []), Statement(if (!ignoreThemeAttr) {, []), AssignmentExpression(=, [VariableReference(final TypedArray ta, []), Expression(context.obtainStyledAttributes(attrs, ATTRS_THEME), [])]), AssignmentExpression(=, [VariableReference(final int themeResId, []), Expression(ta.getResourceId(0, 0), [])]), AssignmentExpression(=, [VariableReference(if (themeResId !, []), Expression(0) {, [])]), AssignmentExpression(=, [VariableReference(context, []), Expression(new ContextThemeWrapper(context, themeResId), [])]), Statement(}, []), MethodCall(ta.recycle(), [VariableReference(ta, []), Expression(, [])]), Statement(}, []), Statement(try {, []), AssignmentExpression(=, [VariableReference(View view, []), Expression(tryCreateView(parent, name, context, attrs), [])]), AssignmentExpression(=, [VariableReference(if (view, []), Expression(, [])]), AssignmentExpression(=, [VariableReference(final Object lastContext, []), Expression(mConstructorArgs[0], [])]), AssignmentExpression(=, [VariableReference(mConstructorArgs[0], []), Expression(context, [])]), Statement(try {, []), AssignmentExpression(=, [VariableReference(if (-1, []), Expression(, [])]), AssignmentExpression(=, [VariableReference(view, []), Expression(onCreateView(context, parent, name, attrs), [])]), Statement(} else {, []), AssignmentExpression(=, [VariableReference(view, []), Expression(createView(context, name, null, attrs), [])]), Statement(}, []), Statement(} finally {, []), AssignmentExpression(=, [VariableReference(mConstructorArgs[0], []), Expression(lastContext, [])]), Statement(}, []), Statement(}, []), Statement(return view, []), Statement(} catch (InflateException e) {, []), Statement(throw e, []), Statement(} catch (ClassNotFoundException e) {, []), AssignmentExpression(=, [VariableReference(final InflateException ie, []), Expression(new InflateException(getParserStateDescription(context, attrs) + "": Error inflating class "" + name, e), [])]), MethodCall(ie.setStackTrace(EMPTY_STACK_TRACE), [VariableReference(ie, []), Expression(EMPTY_STACK_TRACE, [])]), Statement(throw ie, []), Statement(} catch (Exception e) {, []), AssignmentExpression(=, [VariableReference(final InflateException ie, []), Expression(new InflateException(getParserStateDescription(context, attrs) + "": Error inflating class "" + name, e), [])]), MethodCall(ie.setStackTrace(EMPTY_STACK_TRACE), [VariableReference(ie, []), Expression(EMPTY_STACK_TRACE, [])]), Statement(throw ie, []), Statement(}, []), Statement(}, [])])  Statement({, [])  MethodCall(if (name.equals(""view"")), [VariableReference(if (name, []), Expression(""view""), [])])    VariableReference(if (name, [])    Expression(""view""), [])  AssignmentExpression(=, [VariableReference(name, []), Expression(attrs.getAttributeValue(null, ""class""), [])])    VariableReference(name, [])    Expression(attrs.getAttributeValue(null, ""class""), [])  Statement(}, [])  Statement(// Apply a theme wrapper, if allowed and one is specified., [])  Statement(if (!ignoreThemeAttr) {, [])  AssignmentExpression(=, [VariableReference(final TypedArray ta, []), Expression(context.obtainStyledAttributes(attrs, ATTRS_THEME), [])])    VariableReference(final TypedArray ta, [])    Expression(context.obtainStyledAttributes(attrs, ATTRS_THEME), [])  AssignmentExpression(=, [VariableReference(final int themeResId, []), Expression(ta.getResourceId(0, 0), [])])    VariableReference(final int themeResId, [])    Expression(ta.getResourceId(0, 0), [])  AssignmentExpression(=, [VariableReference(if (themeResId !, []), Expression(0) {, [])])    VariableReference(if (themeResId !, [])    Expression(0) {, [])  AssignmentExpression(=, [VariableReference(context, []), Expression(new ContextThemeWrapper(context, themeResId), [])])    VariableReference(context, [])    Expression(new ContextThemeWrapper(context, themeResId), [])  Statement(}, [])  MethodCall(ta.recycle(), [VariableReference(ta, []), Expression(, [])])    VariableReference(ta, [])    Expression(, [])  Statement(}, [])  Statement(try {, [])  AssignmentExpression(=, [VariableReference(View view, []), Expression(tryCreateView(parent, name, context, attrs), [])])    VariableReference(View view, [])    Expression(tryCreateView(parent, name, context, attrs), [])  AssignmentExpression(=, [VariableReference(if (view, []), Expression(, [])])    VariableReference(if (view, [])    Expression(, [])  AssignmentExpression(=, [VariableReference(final Object lastContext, []), Expression(mConstructorArgs[0], [])])    VariableReference(final Object lastContext, [])    Expression(mConstructorArgs[0], [])  AssignmentExpression(=, [VariableReference(mConstructorArgs[0], []), Expression(context, [])])    VariableReference(mConstructorArgs[0], [])    Expression(context, [])  Statement(try {, [])  AssignmentExpression(=, [VariableReference(if (-1, []), Expression(, [])])    VariableReference(if (-1, [])    Expression(, [])  AssignmentExpression(=, [VariableReference(view, []), Expression(onCreateView(context, parent, name, attrs), [])])    VariableReference(view, [])    Expression(onCreateView(context, parent, name, attrs), [])  Statement(} else {, [])  AssignmentExpression(=, [VariableReference(view, []), Expression(createView(context, name, null, attrs), [])])    VariableReference(view, [])    Expression(createView(context, name, null, attrs), [])  Statement(}, [])  Statement(} finally {, [])  AssignmentExpression(=, [VariableReference(mConstructorArgs[0], []), Expression(lastContext, [])])    VariableReference(mConstructorArgs[0], [])    Expression(lastContext, [])  Statement(}, [])  Statement(}, [])  Statement(return view, [])  Statement(} catch (InflateException e) {, [])  Statement(throw e, [])  Statement(} catch (ClassNotFoundException e) {, [])  AssignmentExpression(=, [VariableReference(final InflateException ie, []), Expression(new InflateException(getParserStateDescription(context, attrs) + "": Error inflating class "" + name, e), [])])    VariableReference(final InflateException ie, [])    Expression(new InflateException(getParserStateDescription(context, attrs) + "": Error inflating class "" + name, e), [])  MethodCall(ie.setStackTrace(EMPTY_STACK_TRACE), [VariableReference(ie, []), Expression(EMPTY_STACK_TRACE, [])])    VariableReference(ie, [])    Expression(EMPTY_STACK_TRACE, [])  Statement(throw ie, [])  Statement(} catch (Exception e) {, [])  AssignmentExpression(=, [VariableReference(final InflateException ie, []), Expression(new InflateException(getParserStateDescription(context, attrs) + "": Error inflating class "" + name, e), [])])    VariableReference(final InflateException ie, [])    Expression(new InflateException(getParserStateDescription(context, attrs) + "": Error inflating class "" + name, e), [])  MethodCall(ie.setStackTrace(EMPTY_STACK_TRACE), [VariableReference(ie, []), Expression(EMPTY_STACK_TRACE, [])])    VariableReference(ie, [])    Expression(EMPTY_STACK_TRACE, [])  Statement(throw ie, [])  Statement(}, [])  Statement(}, [])",1,"/**
 * Creates a view from a tag name using the supplied attribute set.
 * <p>
 * <strong>Note:</strong> Default visibility so the BridgeInflater can
 * override it.
 *
 * @param parent the parent view, used to inflate layout params
 * @param name the name of the XML tag used to define the view
 * @param context the inflation context for the view, typically the
 * {@code parent} or base layout inflater context
 * @param attrs the attribute set for the XML tag used to define the view
 * @param ignoreThemeAttr {@code true} to ignore the {@code android:theme}
 * attribute (if set) for the view being inflated,
 * {@code false} otherwise
 */
","/**
 * Creates a view from a tag name using the supplied attribute set.
 * <p>
 * <strong>Note:</strong> Default visibility so the BridgeInflater can
 * override it.
 *
 * @param parent the parent view, used to inflate layout params
 * @param name the name of the XML tag used to define the view
 * @param context the inflation context for the view, typically the
 * {@code parent} or base layout inflater context
 * @param attrs the attribute set for the XML tag used to define the view
 * @param ignoreThemeAttr {@code true} to ignore the {@code android:theme}
 * attribute (if set) for the view being inflated,
 * {@code false} otherwise
 */
",0,,[@UnsupportedAppUsage],1,,,,"1,2","1,3,4,5",1,"3,5",0,"The assignment and control flow has changed with the introduction of the `tryCreateView` method in the late version, so the change types are 3 and 5.","The changes are related to the flow and assignment within the method without affecting the return type or the exception handling in a potential impactful way noticeable to the users of this API. Hence, no Compatibility Issue exists and CI type is 0."
86,"<android.view.textclassifier.TextLinks.Builder: Builder addLink(int,int,Map<String, Float>)>",28,29,,,,"MethodDeclaration(method_body, [Statement({, []), MethodCall(mLinks.add(new TextLink(start, end, entityScores, null)), [VariableReference(mLinks, []), Expression(new TextLink(start, []), Expression(end, []), Expression(entityScores, []), Expression(null), [])]), Statement(return this, []), Statement(}, [])])  Statement({, [])  MethodCall(mLinks.add(new TextLink(start, end, entityScores, null)), [VariableReference(mLinks, []), Expression(new TextLink(start, []), Expression(end, []), Expression(entityScores, []), Expression(null), [])])    VariableReference(mLinks, [])    Expression(new TextLink(start, [])    Expression(end, [])    Expression(entityScores, [])    Expression(null), [])  Statement(return this, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(}, [])])  Statement({, [])  Statement(}, [])",1,"/**
 * Adds a TextLink.
 *
 * @param start The start index of the identified subsequence
 * @param end The end index of the identified subsequence
 * @param entityScores A mapping of entity type to confidence score
 *
 * @throws IllegalArgumentException if entityScores is null or empty.
 */
","/**
 * Adds a TextLink.
 *
 * @param start The start index of the identified subsequence
 * @param end The end index of the identified subsequence
 * @param entityScores A mapping of entity type to confidence score
 *
 * @throws IllegalArgumentException if entityScores is null or empty.
 */
",0,[@NonNull],[@NonNull],0,,,,"1,2","1,5",1,"1,4",1,"All MethodCall and return statement have been removed from the late version, so the code change type is 1,4.","The removal of the method call and return statement will cause the method to behave differently, primarily because it no longer adds a new `TextLink` and doesnt return the current `Builder` instance. Consequently, the CI type is 1."
87,<android.view.inputmethod.InputMethodManager: InputMethodSubtype getLastInputMethodSubtype()>,28,29,,,,"MethodDeclaration(method_body, [Statement({, []), Statement(synchronized (mH) {, []), Statement(try {, []), MethodCall(return mService.getLastInputMethodSubtype(), [VariableReference(return mService, []), Expression(, [])]), Statement(} catch (RemoteException e) {, []), MethodCall(throw e.rethrowFromSystemServer(), [VariableReference(throw e, []), Expression(, [])]), Statement(}, []), Statement(}, []), Statement(}, [])])  Statement({, [])  Statement(synchronized (mH) {, [])  Statement(try {, [])  MethodCall(return mService.getLastInputMethodSubtype(), [VariableReference(return mService, []), Expression(, [])])    VariableReference(return mService, [])    Expression(, [])  Statement(} catch (RemoteException e) {, [])  MethodCall(throw e.rethrowFromSystemServer(), [VariableReference(throw e, []), Expression(, [])])    VariableReference(throw e, [])    Expression(, [])  Statement(}, [])  Statement(}, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(try {, []), MethodCall(return mService.getLastInputMethodSubtype(), [VariableReference(return mService, []), Expression(, [])]), Statement(} catch (RemoteException e) {, []), MethodCall(throw e.rethrowFromSystemServer(), [VariableReference(throw e, []), Expression(, [])]), Statement(}, []), Statement(}, [])])  Statement({, [])  Statement(try {, [])  MethodCall(return mService.getLastInputMethodSubtype(), [VariableReference(return mService, []), Expression(, [])])    VariableReference(return mService, [])    Expression(, [])  Statement(} catch (RemoteException e) {, [])  MethodCall(throw e.rethrowFromSystemServer(), [VariableReference(throw e, []), Expression(, [])])    VariableReference(throw e, [])    Expression(, [])  Statement(}, [])  Statement(}, [])",1,,,0,,,0,,,,1,4,0,4,0,"The synchronized block around the method call and exception handling has been removed. No changes in the return statement or exception handling statement themselves, so the change type is 4.","Removing the synchronized block does not affect the return values or exception handling directly. It may affect concurrency behavior, but that does not fall under the compatibility issues as defined. Therefore, the CI type is 0."
88,<android.util.ArrayMap: String toString()>,28,29,,,,"MethodDeclaration(method_body, [Statement({, []), Statement(if (isEmpty()) {, []), Statement(return ""{}"", []), Statement(}, []), AssignmentExpression(=, [VariableReference(StringBuilder buffer, []), Expression(new StringBuilder(mSize * 28), [])]), MethodCall(buffer.append('{'), [VariableReference(buffer, []), Expression('{', [])]), AssignmentExpression(=, [VariableReference(for (int i, []), Expression(0, [])]), Statement(i < mSize, []), Statement(i++) {, []), Statement(if (i > 0) {, []), MethodCall(buffer.append("", ""), [VariableReference(buffer, []), Expression("", []), Expression("", [])]), Statement(}, []), AssignmentExpression(=, [VariableReference(Object key, []), Expression(keyAt(i), [])]), AssignmentExpression(=, [VariableReference(if (key !, []), Expression(this) {, [])]), MethodCall(buffer.append(key), [VariableReference(buffer, []), Expression(key, [])]), Statement(} else {, []), MethodCall(buffer.append(""(this Map)""), [VariableReference(buffer, []), Expression(""(this Map)"", [])]), Statement(}, []), AssignmentExpression(=, [VariableReference(buffer.append(', []), Expression('), [])]), AssignmentExpression(=, [VariableReference(Object value, []), Expression(valueAt(i), [])]), AssignmentExpression(=, [VariableReference(if (value !, []), Expression(this) {, [])]), MethodCall(buffer.append(value), [VariableReference(buffer, []), Expression(value, [])]), Statement(} else {, []), MethodCall(buffer.append(""(this Map)""), [VariableReference(buffer, []), Expression(""(this Map)"", [])]), Statement(}, []), Statement(}, []), MethodCall(buffer.append('}'), [VariableReference(buffer, []), Expression('}', [])]), MethodCall(return buffer.toString(), [VariableReference(return buffer, []), Expression(, [])]), Statement(}, [])])  Statement({, [])  Statement(if (isEmpty()) {, [])  Statement(return ""{}"", [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(StringBuilder buffer, []), Expression(new StringBuilder(mSize * 28), [])])    VariableReference(StringBuilder buffer, [])    Expression(new StringBuilder(mSize * 28), [])  MethodCall(buffer.append('{'), [VariableReference(buffer, []), Expression('{', [])])    VariableReference(buffer, [])    Expression('{', [])  AssignmentExpression(=, [VariableReference(for (int i, []), Expression(0, [])])    VariableReference(for (int i, [])    Expression(0, [])  Statement(i < mSize, [])  Statement(i++) {, [])  Statement(if (i > 0) {, [])  MethodCall(buffer.append("", ""), [VariableReference(buffer, []), Expression("", []), Expression("", [])])    VariableReference(buffer, [])    Expression("", [])    Expression("", [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(Object key, []), Expression(keyAt(i), [])])    VariableReference(Object key, [])    Expression(keyAt(i), [])  AssignmentExpression(=, [VariableReference(if (key !, []), Expression(this) {, [])])    VariableReference(if (key !, [])    Expression(this) {, [])  MethodCall(buffer.append(key), [VariableReference(buffer, []), Expression(key, [])])    VariableReference(buffer, [])    Expression(key, [])  Statement(} else {, [])  MethodCall(buffer.append(""(this Map)""), [VariableReference(buffer, []), Expression(""(this Map)"", [])])    VariableReference(buffer, [])    Expression(""(this Map)"", [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(buffer.append(', []), Expression('), [])])    VariableReference(buffer.append(', [])    Expression('), [])  AssignmentExpression(=, [VariableReference(Object value, []), Expression(valueAt(i), [])])    VariableReference(Object value, [])    Expression(valueAt(i), [])  AssignmentExpression(=, [VariableReference(if (value !, []), Expression(this) {, [])])    VariableReference(if (value !, [])    Expression(this) {, [])  MethodCall(buffer.append(value), [VariableReference(buffer, []), Expression(value, [])])    VariableReference(buffer, [])    Expression(value, [])  Statement(} else {, [])  MethodCall(buffer.append(""(this Map)""), [VariableReference(buffer, []), Expression(""(this Map)"", [])])    VariableReference(buffer, [])    Expression(""(this Map)"", [])  Statement(}, [])  Statement(}, [])  MethodCall(buffer.append('}'), [VariableReference(buffer, []), Expression('}', [])])    VariableReference(buffer, [])    Expression('}', [])  MethodCall(return buffer.toString(), [VariableReference(return buffer, []), Expression(, [])])    VariableReference(return buffer, [])    Expression(, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(if (isEmpty()) {, []), Statement(return ""{}"", []), Statement(}, []), AssignmentExpression(=, [VariableReference(StringBuilder buffer, []), Expression(new StringBuilder(mSize * 28), [])]), MethodCall(buffer.append('{'), [VariableReference(buffer, []), Expression('{', [])]), AssignmentExpression(=, [VariableReference(for (int i, []), Expression(0, [])]), Statement(i < mSize, []), Statement(i++) {, []), Statement(if (i > 0) {, []), MethodCall(buffer.append("", ""), [VariableReference(buffer, []), Expression("", []), Expression("", [])]), Statement(}, []), AssignmentExpression(=, [VariableReference(Object key, []), Expression(keyAt(i), [])]), AssignmentExpression(=, [VariableReference(if (key !, []), Expression(this) {, [])]), MethodCall(buffer.append(key), [VariableReference(buffer, []), Expression(key, [])]), Statement(} else {, []), MethodCall(buffer.append(""(this Map)""), [VariableReference(buffer, []), Expression(""(this Map)"", [])]), Statement(}, []), AssignmentExpression(=, [VariableReference(buffer.append(', []), Expression('), [])]), AssignmentExpression(=, [VariableReference(Object value, []), Expression(valueAt(i), [])]), AssignmentExpression(=, [VariableReference(if (value !, []), Expression(this) {, [])]), MethodCall(buffer.append(ArrayUtils.deepToString(value)), [VariableReference(buffer, []), Expression(ArrayUtils.deepToString(value), [])]), Statement(} else {, []), MethodCall(buffer.append(""(this Map)""), [VariableReference(buffer, []), Expression(""(this Map)"", [])]), Statement(}, []), Statement(}, []), MethodCall(buffer.append('}'), [VariableReference(buffer, []), Expression('}', [])]), MethodCall(return buffer.toString(), [VariableReference(return buffer, []), Expression(, [])]), Statement(}, [])])  Statement({, [])  Statement(if (isEmpty()) {, [])  Statement(return ""{}"", [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(StringBuilder buffer, []), Expression(new StringBuilder(mSize * 28), [])])    VariableReference(StringBuilder buffer, [])    Expression(new StringBuilder(mSize * 28), [])  MethodCall(buffer.append('{'), [VariableReference(buffer, []), Expression('{', [])])    VariableReference(buffer, [])    Expression('{', [])  AssignmentExpression(=, [VariableReference(for (int i, []), Expression(0, [])])    VariableReference(for (int i, [])    Expression(0, [])  Statement(i < mSize, [])  Statement(i++) {, [])  Statement(if (i > 0) {, [])  MethodCall(buffer.append("", ""), [VariableReference(buffer, []), Expression("", []), Expression("", [])])    VariableReference(buffer, [])    Expression("", [])    Expression("", [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(Object key, []), Expression(keyAt(i), [])])    VariableReference(Object key, [])    Expression(keyAt(i), [])  AssignmentExpression(=, [VariableReference(if (key !, []), Expression(this) {, [])])    VariableReference(if (key !, [])    Expression(this) {, [])  MethodCall(buffer.append(key), [VariableReference(buffer, []), Expression(key, [])])    VariableReference(buffer, [])    Expression(key, [])  Statement(} else {, [])  MethodCall(buffer.append(""(this Map)""), [VariableReference(buffer, []), Expression(""(this Map)"", [])])    VariableReference(buffer, [])    Expression(""(this Map)"", [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(buffer.append(', []), Expression('), [])])    VariableReference(buffer.append(', [])    Expression('), [])  AssignmentExpression(=, [VariableReference(Object value, []), Expression(valueAt(i), [])])    VariableReference(Object value, [])    Expression(valueAt(i), [])  AssignmentExpression(=, [VariableReference(if (value !, []), Expression(this) {, [])])    VariableReference(if (value !, [])    Expression(this) {, [])  MethodCall(buffer.append(ArrayUtils.deepToString(value)), [VariableReference(buffer, []), Expression(ArrayUtils.deepToString(value), [])])    VariableReference(buffer, [])    Expression(ArrayUtils.deepToString(value), [])  Statement(} else {, [])  MethodCall(buffer.append(""(this Map)""), [VariableReference(buffer, []), Expression(""(this Map)"", [])])    VariableReference(buffer, [])    Expression(""(this Map)"", [])  Statement(}, [])  Statement(}, [])  MethodCall(buffer.append('}'), [VariableReference(buffer, []), Expression('}', [])])    VariableReference(buffer, [])    Expression('}', [])  MethodCall(return buffer.toString(), [VariableReference(return buffer, []), Expression(, [])])    VariableReference(return buffer, [])    Expression(, [])  Statement(}, [])",1,"/**
 * {@inheritDoc}
 *
 * <p>This implementation composes a string by iterating over its mappings. If
 * this map contains itself as a key or a value, the string ""(this Map)""
 * will appear in its place.
 */
","/**
 * {@inheritDoc}
 *
 * <p>This implementation composes a string by iterating over its mappings. If
 * this map contains itself as a key or a value, the string ""(this Map)""
 * will appear in its place.
 */
",0,[@Override],[@Override],0,,,,"1,2",4,1,"1,4",1,"The code introduces a different method call (`ArrayUtils.deepToString(value)`) when appending the value to the string builder. This change affects the final composed string, so the code change type is 1,4.","By changing the method used to convert the value to a string, the API potentially returns a different string representation of the map. This counts as potentially returning a different value, thus the CI type is 1."
89,<android.hardware.camera2.CameraMetadata: List<TKey> getKeys()>,28,29,,,,"MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(Class<CameraMetadata<TKey>> thisClass, []), Expression((Class<CameraMetadata<TKey>>) getClass(), [])]), MethodCall(return Collections.unmodifiableList(getKeys(thisClass, getKeyClass(), [VariableReference(return Collections, []), Expression(getKeys(thisClass, []), Expression(getKeyClass(, [])]), Statement(null)), []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(Class<CameraMetadata<TKey>> thisClass, []), Expression((Class<CameraMetadata<TKey>>) getClass(), [])])    VariableReference(Class<CameraMetadata<TKey>> thisClass, [])    Expression((Class<CameraMetadata<TKey>>) getClass(), [])  MethodCall(return Collections.unmodifiableList(getKeys(thisClass, getKeyClass(), [VariableReference(return Collections, []), Expression(getKeys(thisClass, []), Expression(getKeyClass(, [])])    VariableReference(return Collections, [])    Expression(getKeys(thisClass, [])    Expression(getKeyClass(, [])  Statement(null)), [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(Class<CameraMetadata<TKey>> thisClass, []), Expression((Class<CameraMetadata<TKey>>) getClass(), [])]), MethodCall(return Collections.unmodifiableList(getKeys(thisClass, getKeyClass(), [VariableReference(return Collections, []), Expression(getKeys(thisClass, []), Expression(getKeyClass(, [])]), Statement(null, /*includeSynthetic*/, []), Statement(true)), []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(Class<CameraMetadata<TKey>> thisClass, []), Expression((Class<CameraMetadata<TKey>>) getClass(), [])])    VariableReference(Class<CameraMetadata<TKey>> thisClass, [])    Expression((Class<CameraMetadata<TKey>>) getClass(), [])  MethodCall(return Collections.unmodifiableList(getKeys(thisClass, getKeyClass(), [VariableReference(return Collections, []), Expression(getKeys(thisClass, []), Expression(getKeyClass(, [])])    VariableReference(return Collections, [])    Expression(getKeys(thisClass, [])    Expression(getKeyClass(, [])  Statement(null, /*includeSynthetic*/, [])  Statement(true)), [])  Statement(}, [])",1,"/**
 * Returns a list of the keys contained in this map.
 *
 * <p>The list returned is not modifiable, so any attempts to modify it will throw
 * a {@code UnsupportedOperationException}.</p>
 *
 * <p>All values retrieved by a key from this list with {@code #get} are guaranteed to be
 * non-{@code null}. Each key is only listed once in the list. The order of the keys
 * is undefined.</p>
 *
 * @return List of the keys contained in this map.
 */
","/**
 * Returns a list of the keys contained in this map.
 *
 * <p>The list returned is not modifiable, so any attempts to modify it will throw
 * a {@code UnsupportedOperationException}.</p>
 *
 * <p>All values retrieved by a key from this list with {@code #get} are guaranteed to be
 * non-{@code null}. Each key is only listed once in the list. The order of the keys
 * is undefined.</p>
 *
 * @return List of the keys contained in this map.
 */
",0,"[@SuppressWarnings(""unchecked""), @NonNull]","[@SuppressWarnings(""unchecked""), @NonNull]",0,,,,2,"1,5",1,0,0,"The AST nodes of both versions are identical, with no changes in return statements, exception handling, control dependencies, or other statements. The annotations and comments remain the same as well.","No changes were identified between the early and late versions, so there are no potential compatibility issues."
90,<android.app.Activity: int getRequestedOrientation()>,28,29,,,,"MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(if (mParent, []), Expression(, [])]), Statement(try {, []), MethodCall(return ActivityManager.getService().getRequestedOrientation(mToken), [VariableReference(return ActivityManager, []), Expression().getRequestedOrientation(mToken, [])]), Statement(} catch (RemoteException e) {, []), Statement(// Empty, []), Statement(}, []), Statement(} else {, []), MethodCall(return mParent.getRequestedOrientation(), [VariableReference(return mParent, []), Expression(, [])]), Statement(}, []), Statement(return ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(if (mParent, []), Expression(, [])])    VariableReference(if (mParent, [])    Expression(, [])  Statement(try {, [])  MethodCall(return ActivityManager.getService().getRequestedOrientation(mToken), [VariableReference(return ActivityManager, []), Expression().getRequestedOrientation(mToken, [])])    VariableReference(return ActivityManager, [])    Expression().getRequestedOrientation(mToken, [])  Statement(} catch (RemoteException e) {, [])  Statement(// Empty, [])  Statement(}, [])  Statement(} else {, [])  MethodCall(return mParent.getRequestedOrientation(), [VariableReference(return mParent, []), Expression(, [])])    VariableReference(return mParent, [])    Expression(, [])  Statement(}, [])  Statement(return ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(if (mParent, []), Expression(, [])]), Statement(try {, []), MethodCall(return ActivityTaskManager.getService().getRequestedOrientation(mToken), [VariableReference(return ActivityTaskManager, []), Expression().getRequestedOrientation(mToken, [])]), Statement(} catch (RemoteException e) {, []), Statement(// Empty, []), Statement(}, []), Statement(} else {, []), MethodCall(return mParent.getRequestedOrientation(), [VariableReference(return mParent, []), Expression(, [])]), Statement(}, []), Statement(return ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(if (mParent, []), Expression(, [])])    VariableReference(if (mParent, [])    Expression(, [])  Statement(try {, [])  MethodCall(return ActivityTaskManager.getService().getRequestedOrientation(mToken), [VariableReference(return ActivityTaskManager, []), Expression().getRequestedOrientation(mToken, [])])    VariableReference(return ActivityTaskManager, [])    Expression().getRequestedOrientation(mToken, [])  Statement(} catch (RemoteException e) {, [])  Statement(// Empty, [])  Statement(}, [])  Statement(} else {, [])  MethodCall(return mParent.getRequestedOrientation(), [VariableReference(return mParent, []), Expression(, [])])    VariableReference(return mParent, [])    Expression(, [])  Statement(}, [])  Statement(return ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED, [])  Statement(}, [])",1,"/**
 * Return the current requested orientation of the activity.  This will
 * either be the orientation requested in its component's manifest, or
 * the last requested orientation given to
 * {@link #setRequestedOrientation(int)}.
 *
 * @return Returns an orientation constant as used in
 * {@link ActivityInfo#screenOrientation ActivityInfo.screenOrientation}.
 */
","/**
 * Return the current requested orientation of the activity.  This will
 * either be the orientation requested in its component's manifest, or
 * the last requested orientation given to
 * {@link #setRequestedOrientation(int)}.
 *
 * @return Returns an orientation constant as used in
 * {@link ActivityInfo#screenOrientation ActivityInfo.screenOrientation}.
 */
",0,[@ActivityInfo.ScreenOrientation],[@ActivityInfo.ScreenOrientation],0,,,,2,"1,5",1,5,0,"The dependent API has changed from `ActivityManager.getService()` to `ActivityTaskManager.getService()`. Therefore, the change type is 5.","Although the dependent API has changed, it does not necessarily lead to a difference in return values or exception handling. Therefore, no Compatibility Issue exists."
91,<android.view.MenuItem: Mode getIconTintMode()>,28,29,,,,"MethodDeclaration(method_body, [Statement({, []), Statement(return null, []), Statement(}, [])])  Statement({, [])  Statement(return null, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(return null, []), Statement(}, [])])  Statement({, [])  Statement(return null, [])  Statement(}, [])",0,"/**
 * Returns the blending mode used to apply the tint to this item's icon, if specified.
 *
 * @return the blending mode used to apply the tint to this item's icon
 * @attr ref android.R.styleable#MenuItem_iconTintMode
 * @see #setIconTintMode(PorterDuff.Mode)
 */
","/**
 * Returns the blending mode used to apply the tint to this item's icon, if specified.
 *
 * @return the blending mode used to apply the tint to this item's icon
 * @attr ref android.R.styleable#MenuItem_iconTintMode
 * @see #setIconTintMode(PorterDuff.Mode)
 * @see #setIconTintBlendMode(BlendMode)
 */
",1,[@Nullable],[@Nullable],0,,,,0,0,0,0,0,"The AST representation of the method implementation, comments, and annotations are identical in both versions.","There are no changes in the method implementation, therefore, no compatibility issues exist."
92,<android.view.ViewTreeObserver: void merge(ViewTreeObserver)>,28,29,,,,"MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(if (observer.mOnWindowAttachListeners !, []), Expression(null) {, [])]), AssignmentExpression(=, [VariableReference(if (mOnWindowAttachListeners !, []), Expression(null) {, [])]), MethodCall(mOnWindowAttachListeners.addAll(observer.mOnWindowAttachListeners), [VariableReference(mOnWindowAttachListeners, []), Expression(observer.mOnWindowAttachListeners, [])]), Statement(} else {, []), AssignmentExpression(=, [VariableReference(mOnWindowAttachListeners, []), Expression(observer.mOnWindowAttachListeners, [])]), Statement(}, []), Statement(}, []), AssignmentExpression(=, [VariableReference(if (observer.mOnWindowFocusListeners !, []), Expression(null) {, [])]), AssignmentExpression(=, [VariableReference(if (mOnWindowFocusListeners !, []), Expression(null) {, [])]), MethodCall(mOnWindowFocusListeners.addAll(observer.mOnWindowFocusListeners), [VariableReference(mOnWindowFocusListeners, []), Expression(observer.mOnWindowFocusListeners, [])]), Statement(} else {, []), AssignmentExpression(=, [VariableReference(mOnWindowFocusListeners, []), Expression(observer.mOnWindowFocusListeners, [])]), Statement(}, []), Statement(}, []), AssignmentExpression(=, [VariableReference(if (observer.mOnGlobalFocusListeners !, []), Expression(null) {, [])]), AssignmentExpression(=, [VariableReference(if (mOnGlobalFocusListeners !, []), Expression(null) {, [])]), MethodCall(mOnGlobalFocusListeners.addAll(observer.mOnGlobalFocusListeners), [VariableReference(mOnGlobalFocusListeners, []), Expression(observer.mOnGlobalFocusListeners, [])]), Statement(} else {, []), AssignmentExpression(=, [VariableReference(mOnGlobalFocusListeners, []), Expression(observer.mOnGlobalFocusListeners, [])]), Statement(}, []), Statement(}, []), AssignmentExpression(=, [VariableReference(if (observer.mOnGlobalLayoutListeners !, []), Expression(null) {, [])]), AssignmentExpression(=, [VariableReference(if (mOnGlobalLayoutListeners !, []), Expression(null) {, [])]), MethodCall(mOnGlobalLayoutListeners.addAll(observer.mOnGlobalLayoutListeners), [VariableReference(mOnGlobalLayoutListeners, []), Expression(observer.mOnGlobalLayoutListeners, [])]), Statement(} else {, []), AssignmentExpression(=, [VariableReference(mOnGlobalLayoutListeners, []), Expression(observer.mOnGlobalLayoutListeners, [])]), Statement(}, []), Statement(}, []), AssignmentExpression(=, [VariableReference(if (observer.mOnPreDrawListeners !, []), Expression(null) {, [])]), AssignmentExpression(=, [VariableReference(if (mOnPreDrawListeners !, []), Expression(null) {, [])]), MethodCall(mOnPreDrawListeners.addAll(observer.mOnPreDrawListeners), [VariableReference(mOnPreDrawListeners, []), Expression(observer.mOnPreDrawListeners, [])]), Statement(} else {, []), AssignmentExpression(=, [VariableReference(mOnPreDrawListeners, []), Expression(observer.mOnPreDrawListeners, [])]), Statement(}, []), Statement(}, []), AssignmentExpression(=, [VariableReference(if (observer.mOnDrawListeners !, []), Expression(null) {, [])]), AssignmentExpression(=, [VariableReference(if (mOnDrawListeners !, []), Expression(null) {, [])]), MethodCall(mOnDrawListeners.addAll(observer.mOnDrawListeners), [VariableReference(mOnDrawListeners, []), Expression(observer.mOnDrawListeners, [])]), Statement(} else {, []), AssignmentExpression(=, [VariableReference(mOnDrawListeners, []), Expression(observer.mOnDrawListeners, [])]), Statement(}, []), Statement(}, []), AssignmentExpression(=, [VariableReference(if (observer.mOnTouchModeChangeListeners !, []), Expression(null) {, [])]), AssignmentExpression(=, [VariableReference(if (mOnTouchModeChangeListeners !, []), Expression(null) {, [])]), MethodCall(mOnTouchModeChangeListeners.addAll(observer.mOnTouchModeChangeListeners), [VariableReference(mOnTouchModeChangeListeners, []), Expression(observer.mOnTouchModeChangeListeners, [])]), Statement(} else {, []), AssignmentExpression(=, [VariableReference(mOnTouchModeChangeListeners, []), Expression(observer.mOnTouchModeChangeListeners, [])]), Statement(}, []), Statement(}, []), AssignmentExpression(=, [VariableReference(if (observer.mOnComputeInternalInsetsListeners !, []), Expression(null) {, [])]), AssignmentExpression(=, [VariableReference(if (mOnComputeInternalInsetsListeners !, []), Expression(null) {, [])]), MethodCall(mOnComputeInternalInsetsListeners.addAll(observer.mOnComputeInternalInsetsListeners), [VariableReference(mOnComputeInternalInsetsListeners, []), Expression(observer.mOnComputeInternalInsetsListeners, [])]), Statement(} else {, []), AssignmentExpression(=, [VariableReference(mOnComputeInternalInsetsListeners, []), Expression(observer.mOnComputeInternalInsetsListeners, [])]), Statement(}, []), Statement(}, []), AssignmentExpression(=, [VariableReference(if (observer.mOnScrollChangedListeners !, []), Expression(null) {, [])]), AssignmentExpression(=, [VariableReference(if (mOnScrollChangedListeners !, []), Expression(null) {, [])]), MethodCall(mOnScrollChangedListeners.addAll(observer.mOnScrollChangedListeners), [VariableReference(mOnScrollChangedListeners, []), Expression(observer.mOnScrollChangedListeners, [])]), Statement(} else {, []), AssignmentExpression(=, [VariableReference(mOnScrollChangedListeners, []), Expression(observer.mOnScrollChangedListeners, [])]), Statement(}, []), Statement(}, []), AssignmentExpression(=, [VariableReference(if (observer.mOnWindowShownListeners !, []), Expression(null) {, [])]), AssignmentExpression(=, [VariableReference(if (mOnWindowShownListeners !, []), Expression(null) {, [])]), MethodCall(mOnWindowShownListeners.addAll(observer.mOnWindowShownListeners), [VariableReference(mOnWindowShownListeners, []), Expression(observer.mOnWindowShownListeners, [])]), Statement(} else {, []), AssignmentExpression(=, [VariableReference(mOnWindowShownListeners, []), Expression(observer.mOnWindowShownListeners, [])]), Statement(}, []), Statement(}, []), MethodCall(observer.kill(), [VariableReference(observer, []), Expression(, [])]), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(if (observer.mOnWindowAttachListeners !, []), Expression(null) {, [])])    VariableReference(if (observer.mOnWindowAttachListeners !, [])    Expression(null) {, [])  AssignmentExpression(=, [VariableReference(if (mOnWindowAttachListeners !, []), Expression(null) {, [])])    VariableReference(if (mOnWindowAttachListeners !, [])    Expression(null) {, [])  MethodCall(mOnWindowAttachListeners.addAll(observer.mOnWindowAttachListeners), [VariableReference(mOnWindowAttachListeners, []), Expression(observer.mOnWindowAttachListeners, [])])    VariableReference(mOnWindowAttachListeners, [])    Expression(observer.mOnWindowAttachListeners, [])  Statement(} else {, [])  AssignmentExpression(=, [VariableReference(mOnWindowAttachListeners, []), Expression(observer.mOnWindowAttachListeners, [])])    VariableReference(mOnWindowAttachListeners, [])    Expression(observer.mOnWindowAttachListeners, [])  Statement(}, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(if (observer.mOnWindowFocusListeners !, []), Expression(null) {, [])])    VariableReference(if (observer.mOnWindowFocusListeners !, [])    Expression(null) {, [])  AssignmentExpression(=, [VariableReference(if (mOnWindowFocusListeners !, []), Expression(null) {, [])])    VariableReference(if (mOnWindowFocusListeners !, [])    Expression(null) {, [])  MethodCall(mOnWindowFocusListeners.addAll(observer.mOnWindowFocusListeners), [VariableReference(mOnWindowFocusListeners, []), Expression(observer.mOnWindowFocusListeners, [])])    VariableReference(mOnWindowFocusListeners, [])    Expression(observer.mOnWindowFocusListeners, [])  Statement(} else {, [])  AssignmentExpression(=, [VariableReference(mOnWindowFocusListeners, []), Expression(observer.mOnWindowFocusListeners, [])])    VariableReference(mOnWindowFocusListeners, [])    Expression(observer.mOnWindowFocusListeners, [])  Statement(}, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(if (observer.mOnGlobalFocusListeners !, []), Expression(null) {, [])])    VariableReference(if (observer.mOnGlobalFocusListeners !, [])    Expression(null) {, [])  AssignmentExpression(=, [VariableReference(if (mOnGlobalFocusListeners !, []), Expression(null) {, [])])    VariableReference(if (mOnGlobalFocusListeners !, [])    Expression(null) {, [])  MethodCall(mOnGlobalFocusListeners.addAll(observer.mOnGlobalFocusListeners), [VariableReference(mOnGlobalFocusListeners, []), Expression(observer.mOnGlobalFocusListeners, [])])    VariableReference(mOnGlobalFocusListeners, [])    Expression(observer.mOnGlobalFocusListeners, [])  Statement(} else {, [])  AssignmentExpression(=, [VariableReference(mOnGlobalFocusListeners, []), Expression(observer.mOnGlobalFocusListeners, [])])    VariableReference(mOnGlobalFocusListeners, [])    Expression(observer.mOnGlobalFocusListeners, [])  Statement(}, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(if (observer.mOnGlobalLayoutListeners !, []), Expression(null) {, [])])    VariableReference(if (observer.mOnGlobalLayoutListeners !, [])    Expression(null) {, [])  AssignmentExpression(=, [VariableReference(if (mOnGlobalLayoutListeners !, []), Expression(null) {, [])])    VariableReference(if (mOnGlobalLayoutListeners !, [])    Expression(null) {, [])  MethodCall(mOnGlobalLayoutListeners.addAll(observer.mOnGlobalLayoutListeners), [VariableReference(mOnGlobalLayoutListeners, []), Expression(observer.mOnGlobalLayoutListeners, [])])    VariableReference(mOnGlobalLayoutListeners, [])    Expression(observer.mOnGlobalLayoutListeners, [])  Statement(} else {, [])  AssignmentExpression(=, [VariableReference(mOnGlobalLayoutListeners, []), Expression(observer.mOnGlobalLayoutListeners, [])])    VariableReference(mOnGlobalLayoutListeners, [])    Expression(observer.mOnGlobalLayoutListeners, [])  Statement(}, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(if (observer.mOnPreDrawListeners !, []), Expression(null) {, [])])    VariableReference(if (observer.mOnPreDrawListeners !, [])    Expression(null) {, [])  AssignmentExpression(=, [VariableReference(if (mOnPreDrawListeners !, []), Expression(null) {, [])])    VariableReference(if (mOnPreDrawListeners !, [])    Expression(null) {, [])  MethodCall(mOnPreDrawListeners.addAll(observer.mOnPreDrawListeners), [VariableReference(mOnPreDrawListeners, []), Expression(observer.mOnPreDrawListeners, [])])    VariableReference(mOnPreDrawListeners, [])    Expression(observer.mOnPreDrawListeners, [])  Statement(} else {, [])  AssignmentExpression(=, [VariableReference(mOnPreDrawListeners, []), Expression(observer.mOnPreDrawListeners, [])])    VariableReference(mOnPreDrawListeners, [])    Expression(observer.mOnPreDrawListeners, [])  Statement(}, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(if (observer.mOnDrawListeners !, []), Expression(null) {, [])])    VariableReference(if (observer.mOnDrawListeners !, [])    Expression(null) {, [])  AssignmentExpression(=, [VariableReference(if (mOnDrawListeners !, []), Expression(null) {, [])])    VariableReference(if (mOnDrawListeners !, [])    Expression(null) {, [])  MethodCall(mOnDrawListeners.addAll(observer.mOnDrawListeners), [VariableReference(mOnDrawListeners, []), Expression(observer.mOnDrawListeners, [])])    VariableReference(mOnDrawListeners, [])    Expression(observer.mOnDrawListeners, [])  Statement(} else {, [])  AssignmentExpression(=, [VariableReference(mOnDrawListeners, []), Expression(observer.mOnDrawListeners, [])])    VariableReference(mOnDrawListeners, [])    Expression(observer.mOnDrawListeners, [])  Statement(}, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(if (observer.mOnTouchModeChangeListeners !, []), Expression(null) {, [])])    VariableReference(if (observer.mOnTouchModeChangeListeners !, [])    Expression(null) {, [])  AssignmentExpression(=, [VariableReference(if (mOnTouchModeChangeListeners !, []), Expression(null) {, [])])    VariableReference(if (mOnTouchModeChangeListeners !, [])    Expression(null) {, [])  MethodCall(mOnTouchModeChangeListeners.addAll(observer.mOnTouchModeChangeListeners), [VariableReference(mOnTouchModeChangeListeners, []), Expression(observer.mOnTouchModeChangeListeners, [])])    VariableReference(mOnTouchModeChangeListeners, [])    Expression(observer.mOnTouchModeChangeListeners, [])  Statement(} else {, [])  AssignmentExpression(=, [VariableReference(mOnTouchModeChangeListeners, []), Expression(observer.mOnTouchModeChangeListeners, [])])    VariableReference(mOnTouchModeChangeListeners, [])    Expression(observer.mOnTouchModeChangeListeners, [])  Statement(}, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(if (observer.mOnComputeInternalInsetsListeners !, []), Expression(null) {, [])])    VariableReference(if (observer.mOnComputeInternalInsetsListeners !, [])    Expression(null) {, [])  AssignmentExpression(=, [VariableReference(if (mOnComputeInternalInsetsListeners !, []), Expression(null) {, [])])    VariableReference(if (mOnComputeInternalInsetsListeners !, [])    Expression(null) {, [])  MethodCall(mOnComputeInternalInsetsListeners.addAll(observer.mOnComputeInternalInsetsListeners), [VariableReference(mOnComputeInternalInsetsListeners, []), Expression(observer.mOnComputeInternalInsetsListeners, [])])    VariableReference(mOnComputeInternalInsetsListeners, [])    Expression(observer.mOnComputeInternalInsetsListeners, [])  Statement(} else {, [])  AssignmentExpression(=, [VariableReference(mOnComputeInternalInsetsListeners, []), Expression(observer.mOnComputeInternalInsetsListeners, [])])    VariableReference(mOnComputeInternalInsetsListeners, [])    Expression(observer.mOnComputeInternalInsetsListeners, [])  Statement(}, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(if (observer.mOnScrollChangedListeners !, []), Expression(null) {, [])])    VariableReference(if (observer.mOnScrollChangedListeners !, [])    Expression(null) {, [])  AssignmentExpression(=, [VariableReference(if (mOnScrollChangedListeners !, []), Expression(null) {, [])])    VariableReference(if (mOnScrollChangedListeners !, [])    Expression(null) {, [])  MethodCall(mOnScrollChangedListeners.addAll(observer.mOnScrollChangedListeners), [VariableReference(mOnScrollChangedListeners, []), Expression(observer.mOnScrollChangedListeners, [])])    VariableReference(mOnScrollChangedListeners, [])    Expression(observer.mOnScrollChangedListeners, [])  Statement(} else {, [])  AssignmentExpression(=, [VariableReference(mOnScrollChangedListeners, []), Expression(observer.mOnScrollChangedListeners, [])])    VariableReference(mOnScrollChangedListeners, [])    Expression(observer.mOnScrollChangedListeners, [])  Statement(}, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(if (observer.mOnWindowShownListeners !, []), Expression(null) {, [])])    VariableReference(if (observer.mOnWindowShownListeners !, [])    Expression(null) {, [])  AssignmentExpression(=, [VariableReference(if (mOnWindowShownListeners !, []), Expression(null) {, [])])    VariableReference(if (mOnWindowShownListeners !, [])    Expression(null) {, [])  MethodCall(mOnWindowShownListeners.addAll(observer.mOnWindowShownListeners), [VariableReference(mOnWindowShownListeners, []), Expression(observer.mOnWindowShownListeners, [])])    VariableReference(mOnWindowShownListeners, [])    Expression(observer.mOnWindowShownListeners, [])  Statement(} else {, [])  AssignmentExpression(=, [VariableReference(mOnWindowShownListeners, []), Expression(observer.mOnWindowShownListeners, [])])    VariableReference(mOnWindowShownListeners, [])    Expression(observer.mOnWindowShownListeners, [])  Statement(}, [])  Statement(}, [])  MethodCall(observer.kill(), [VariableReference(observer, []), Expression(, [])])    VariableReference(observer, [])    Expression(, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(if (observer.mOnWindowAttachListeners !, []), Expression(null) {, [])]), AssignmentExpression(=, [VariableReference(if (mOnWindowAttachListeners !, []), Expression(null) {, [])]), MethodCall(mOnWindowAttachListeners.addAll(observer.mOnWindowAttachListeners), [VariableReference(mOnWindowAttachListeners, []), Expression(observer.mOnWindowAttachListeners, [])]), Statement(} else {, []), AssignmentExpression(=, [VariableReference(mOnWindowAttachListeners, []), Expression(observer.mOnWindowAttachListeners, [])]), Statement(}, []), Statement(}, []), AssignmentExpression(=, [VariableReference(if (observer.mOnWindowFocusListeners !, []), Expression(null) {, [])]), AssignmentExpression(=, [VariableReference(if (mOnWindowFocusListeners !, []), Expression(null) {, [])]), MethodCall(mOnWindowFocusListeners.addAll(observer.mOnWindowFocusListeners), [VariableReference(mOnWindowFocusListeners, []), Expression(observer.mOnWindowFocusListeners, [])]), Statement(} else {, []), AssignmentExpression(=, [VariableReference(mOnWindowFocusListeners, []), Expression(observer.mOnWindowFocusListeners, [])]), Statement(}, []), Statement(}, []), AssignmentExpression(=, [VariableReference(if (observer.mOnGlobalFocusListeners !, []), Expression(null) {, [])]), AssignmentExpression(=, [VariableReference(if (mOnGlobalFocusListeners !, []), Expression(null) {, [])]), MethodCall(mOnGlobalFocusListeners.addAll(observer.mOnGlobalFocusListeners), [VariableReference(mOnGlobalFocusListeners, []), Expression(observer.mOnGlobalFocusListeners, [])]), Statement(} else {, []), AssignmentExpression(=, [VariableReference(mOnGlobalFocusListeners, []), Expression(observer.mOnGlobalFocusListeners, [])]), Statement(}, []), Statement(}, []), AssignmentExpression(=, [VariableReference(if (observer.mOnGlobalLayoutListeners !, []), Expression(null) {, [])]), AssignmentExpression(=, [VariableReference(if (mOnGlobalLayoutListeners !, []), Expression(null) {, [])]), MethodCall(mOnGlobalLayoutListeners.addAll(observer.mOnGlobalLayoutListeners), [VariableReference(mOnGlobalLayoutListeners, []), Expression(observer.mOnGlobalLayoutListeners, [])]), Statement(} else {, []), AssignmentExpression(=, [VariableReference(mOnGlobalLayoutListeners, []), Expression(observer.mOnGlobalLayoutListeners, [])]), Statement(}, []), Statement(}, []), AssignmentExpression(=, [VariableReference(if (observer.mOnPreDrawListeners !, []), Expression(null) {, [])]), AssignmentExpression(=, [VariableReference(if (mOnPreDrawListeners !, []), Expression(null) {, [])]), MethodCall(mOnPreDrawListeners.addAll(observer.mOnPreDrawListeners), [VariableReference(mOnPreDrawListeners, []), Expression(observer.mOnPreDrawListeners, [])]), Statement(} else {, []), AssignmentExpression(=, [VariableReference(mOnPreDrawListeners, []), Expression(observer.mOnPreDrawListeners, [])]), Statement(}, []), Statement(}, []), AssignmentExpression(=, [VariableReference(if (observer.mOnDrawListeners !, []), Expression(null) {, [])]), AssignmentExpression(=, [VariableReference(if (mOnDrawListeners !, []), Expression(null) {, [])]), MethodCall(mOnDrawListeners.addAll(observer.mOnDrawListeners), [VariableReference(mOnDrawListeners, []), Expression(observer.mOnDrawListeners, [])]), Statement(} else {, []), AssignmentExpression(=, [VariableReference(mOnDrawListeners, []), Expression(observer.mOnDrawListeners, [])]), Statement(}, []), Statement(}, []), AssignmentExpression(=, [VariableReference(if (observer.mOnFrameCommitListeners !, []), Expression(null) {, [])]), AssignmentExpression(=, [VariableReference(if (mOnFrameCommitListeners !, []), Expression(null) {, [])]), MethodCall(mOnFrameCommitListeners.addAll(observer.captureFrameCommitCallbacks()), [VariableReference(mOnFrameCommitListeners, []), Expression(observer.captureFrameCommitCallbacks(), [])]), Statement(} else {, []), AssignmentExpression(=, [VariableReference(mOnFrameCommitListeners, []), Expression(observer.captureFrameCommitCallbacks(), [])]), Statement(}, []), Statement(}, []), AssignmentExpression(=, [VariableReference(if (observer.mOnTouchModeChangeListeners !, []), Expression(null) {, [])]), AssignmentExpression(=, [VariableReference(if (mOnTouchModeChangeListeners !, []), Expression(null) {, [])]), MethodCall(mOnTouchModeChangeListeners.addAll(observer.mOnTouchModeChangeListeners), [VariableReference(mOnTouchModeChangeListeners, []), Expression(observer.mOnTouchModeChangeListeners, [])]), Statement(} else {, []), AssignmentExpression(=, [VariableReference(mOnTouchModeChangeListeners, []), Expression(observer.mOnTouchModeChangeListeners, [])]), Statement(}, []), Statement(}, []), AssignmentExpression(=, [VariableReference(if (observer.mOnComputeInternalInsetsListeners !, []), Expression(null) {, [])]), AssignmentExpression(=, [VariableReference(if (mOnComputeInternalInsetsListeners !, []), Expression(null) {, [])]), MethodCall(mOnComputeInternalInsetsListeners.addAll(observer.mOnComputeInternalInsetsListeners), [VariableReference(mOnComputeInternalInsetsListeners, []), Expression(observer.mOnComputeInternalInsetsListeners, [])]), Statement(} else {, []), AssignmentExpression(=, [VariableReference(mOnComputeInternalInsetsListeners, []), Expression(observer.mOnComputeInternalInsetsListeners, [])]), Statement(}, []), Statement(}, []), AssignmentExpression(=, [VariableReference(if (observer.mOnScrollChangedListeners !, []), Expression(null) {, [])]), AssignmentExpression(=, [VariableReference(if (mOnScrollChangedListeners !, []), Expression(null) {, [])]), MethodCall(mOnScrollChangedListeners.addAll(observer.mOnScrollChangedListeners), [VariableReference(mOnScrollChangedListeners, []), Expression(observer.mOnScrollChangedListeners, [])]), Statement(} else {, []), AssignmentExpression(=, [VariableReference(mOnScrollChangedListeners, []), Expression(observer.mOnScrollChangedListeners, [])]), Statement(}, []), Statement(}, []), AssignmentExpression(=, [VariableReference(if (observer.mOnWindowShownListeners !, []), Expression(null) {, [])]), AssignmentExpression(=, [VariableReference(if (mOnWindowShownListeners !, []), Expression(null) {, [])]), MethodCall(mOnWindowShownListeners.addAll(observer.mOnWindowShownListeners), [VariableReference(mOnWindowShownListeners, []), Expression(observer.mOnWindowShownListeners, [])]), Statement(} else {, []), AssignmentExpression(=, [VariableReference(mOnWindowShownListeners, []), Expression(observer.mOnWindowShownListeners, [])]), Statement(}, []), Statement(}, []), AssignmentExpression(=, [VariableReference(if (observer.mGestureExclusionListeners !, []), Expression(null) {, [])]), AssignmentExpression(=, [VariableReference(if (mGestureExclusionListeners !, []), Expression(null) {, [])]), MethodCall(mGestureExclusionListeners.addAll(observer.mGestureExclusionListeners), [VariableReference(mGestureExclusionListeners, []), Expression(observer.mGestureExclusionListeners, [])]), Statement(} else {, []), AssignmentExpression(=, [VariableReference(mGestureExclusionListeners, []), Expression(observer.mGestureExclusionListeners, [])]), Statement(}, []), Statement(}, []), MethodCall(observer.kill(), [VariableReference(observer, []), Expression(, [])]), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(if (observer.mOnWindowAttachListeners !, []), Expression(null) {, [])])    VariableReference(if (observer.mOnWindowAttachListeners !, [])    Expression(null) {, [])  AssignmentExpression(=, [VariableReference(if (mOnWindowAttachListeners !, []), Expression(null) {, [])])    VariableReference(if (mOnWindowAttachListeners !, [])    Expression(null) {, [])  MethodCall(mOnWindowAttachListeners.addAll(observer.mOnWindowAttachListeners), [VariableReference(mOnWindowAttachListeners, []), Expression(observer.mOnWindowAttachListeners, [])])    VariableReference(mOnWindowAttachListeners, [])    Expression(observer.mOnWindowAttachListeners, [])  Statement(} else {, [])  AssignmentExpression(=, [VariableReference(mOnWindowAttachListeners, []), Expression(observer.mOnWindowAttachListeners, [])])    VariableReference(mOnWindowAttachListeners, [])    Expression(observer.mOnWindowAttachListeners, [])  Statement(}, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(if (observer.mOnWindowFocusListeners !, []), Expression(null) {, [])])    VariableReference(if (observer.mOnWindowFocusListeners !, [])    Expression(null) {, [])  AssignmentExpression(=, [VariableReference(if (mOnWindowFocusListeners !, []), Expression(null) {, [])])    VariableReference(if (mOnWindowFocusListeners !, [])    Expression(null) {, [])  MethodCall(mOnWindowFocusListeners.addAll(observer.mOnWindowFocusListeners), [VariableReference(mOnWindowFocusListeners, []), Expression(observer.mOnWindowFocusListeners, [])])    VariableReference(mOnWindowFocusListeners, [])    Expression(observer.mOnWindowFocusListeners, [])  Statement(} else {, [])  AssignmentExpression(=, [VariableReference(mOnWindowFocusListeners, []), Expression(observer.mOnWindowFocusListeners, [])])    VariableReference(mOnWindowFocusListeners, [])    Expression(observer.mOnWindowFocusListeners, [])  Statement(}, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(if (observer.mOnGlobalFocusListeners !, []), Expression(null) {, [])])    VariableReference(if (observer.mOnGlobalFocusListeners !, [])    Expression(null) {, [])  AssignmentExpression(=, [VariableReference(if (mOnGlobalFocusListeners !, []), Expression(null) {, [])])    VariableReference(if (mOnGlobalFocusListeners !, [])    Expression(null) {, [])  MethodCall(mOnGlobalFocusListeners.addAll(observer.mOnGlobalFocusListeners), [VariableReference(mOnGlobalFocusListeners, []), Expression(observer.mOnGlobalFocusListeners, [])])    VariableReference(mOnGlobalFocusListeners, [])    Expression(observer.mOnGlobalFocusListeners, [])  Statement(} else {, [])  AssignmentExpression(=, [VariableReference(mOnGlobalFocusListeners, []), Expression(observer.mOnGlobalFocusListeners, [])])    VariableReference(mOnGlobalFocusListeners, [])    Expression(observer.mOnGlobalFocusListeners, [])  Statement(}, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(if (observer.mOnGlobalLayoutListeners !, []), Expression(null) {, [])])    VariableReference(if (observer.mOnGlobalLayoutListeners !, [])    Expression(null) {, [])  AssignmentExpression(=, [VariableReference(if (mOnGlobalLayoutListeners !, []), Expression(null) {, [])])    VariableReference(if (mOnGlobalLayoutListeners !, [])    Expression(null) {, [])  MethodCall(mOnGlobalLayoutListeners.addAll(observer.mOnGlobalLayoutListeners), [VariableReference(mOnGlobalLayoutListeners, []), Expression(observer.mOnGlobalLayoutListeners, [])])    VariableReference(mOnGlobalLayoutListeners, [])    Expression(observer.mOnGlobalLayoutListeners, [])  Statement(} else {, [])  AssignmentExpression(=, [VariableReference(mOnGlobalLayoutListeners, []), Expression(observer.mOnGlobalLayoutListeners, [])])    VariableReference(mOnGlobalLayoutListeners, [])    Expression(observer.mOnGlobalLayoutListeners, [])  Statement(}, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(if (observer.mOnPreDrawListeners !, []), Expression(null) {, [])])    VariableReference(if (observer.mOnPreDrawListeners !, [])    Expression(null) {, [])  AssignmentExpression(=, [VariableReference(if (mOnPreDrawListeners !, []), Expression(null) {, [])])    VariableReference(if (mOnPreDrawListeners !, [])    Expression(null) {, [])  MethodCall(mOnPreDrawListeners.addAll(observer.mOnPreDrawListeners), [VariableReference(mOnPreDrawListeners, []), Expression(observer.mOnPreDrawListeners, [])])    VariableReference(mOnPreDrawListeners, [])    Expression(observer.mOnPreDrawListeners, [])  Statement(} else {, [])  AssignmentExpression(=, [VariableReference(mOnPreDrawListeners, []), Expression(observer.mOnPreDrawListeners, [])])    VariableReference(mOnPreDrawListeners, [])    Expression(observer.mOnPreDrawListeners, [])  Statement(}, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(if (observer.mOnDrawListeners !, []), Expression(null) {, [])])    VariableReference(if (observer.mOnDrawListeners !, [])    Expression(null) {, [])  AssignmentExpression(=, [VariableReference(if (mOnDrawListeners !, []), Expression(null) {, [])])    VariableReference(if (mOnDrawListeners !, [])    Expression(null) {, [])  MethodCall(mOnDrawListeners.addAll(observer.mOnDrawListeners), [VariableReference(mOnDrawListeners, []), Expression(observer.mOnDrawListeners, [])])    VariableReference(mOnDrawListeners, [])    Expression(observer.mOnDrawListeners, [])  Statement(} else {, [])  AssignmentExpression(=, [VariableReference(mOnDrawListeners, []), Expression(observer.mOnDrawListeners, [])])    VariableReference(mOnDrawListeners, [])    Expression(observer.mOnDrawListeners, [])  Statement(}, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(if (observer.mOnFrameCommitListeners !, []), Expression(null) {, [])])    VariableReference(if (observer.mOnFrameCommitListeners !, [])    Expression(null) {, [])  AssignmentExpression(=, [VariableReference(if (mOnFrameCommitListeners !, []), Expression(null) {, [])])    VariableReference(if (mOnFrameCommitListeners !, [])    Expression(null) {, [])  MethodCall(mOnFrameCommitListeners.addAll(observer.captureFrameCommitCallbacks()), [VariableReference(mOnFrameCommitListeners, []), Expression(observer.captureFrameCommitCallbacks(), [])])    VariableReference(mOnFrameCommitListeners, [])    Expression(observer.captureFrameCommitCallbacks(), [])  Statement(} else {, [])  AssignmentExpression(=, [VariableReference(mOnFrameCommitListeners, []), Expression(observer.captureFrameCommitCallbacks(), [])])    VariableReference(mOnFrameCommitListeners, [])    Expression(observer.captureFrameCommitCallbacks(), [])  Statement(}, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(if (observer.mOnTouchModeChangeListeners !, []), Expression(null) {, [])])    VariableReference(if (observer.mOnTouchModeChangeListeners !, [])    Expression(null) {, [])  AssignmentExpression(=, [VariableReference(if (mOnTouchModeChangeListeners !, []), Expression(null) {, [])])    VariableReference(if (mOnTouchModeChangeListeners !, [])    Expression(null) {, [])  MethodCall(mOnTouchModeChangeListeners.addAll(observer.mOnTouchModeChangeListeners), [VariableReference(mOnTouchModeChangeListeners, []), Expression(observer.mOnTouchModeChangeListeners, [])])    VariableReference(mOnTouchModeChangeListeners, [])    Expression(observer.mOnTouchModeChangeListeners, [])  Statement(} else {, [])  AssignmentExpression(=, [VariableReference(mOnTouchModeChangeListeners, []), Expression(observer.mOnTouchModeChangeListeners, [])])    VariableReference(mOnTouchModeChangeListeners, [])    Expression(observer.mOnTouchModeChangeListeners, [])  Statement(}, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(if (observer.mOnComputeInternalInsetsListeners !, []), Expression(null) {, [])])    VariableReference(if (observer.mOnComputeInternalInsetsListeners !, [])    Expression(null) {, [])  AssignmentExpression(=, [VariableReference(if (mOnComputeInternalInsetsListeners !, []), Expression(null) {, [])])    VariableReference(if (mOnComputeInternalInsetsListeners !, [])    Expression(null) {, [])  MethodCall(mOnComputeInternalInsetsListeners.addAll(observer.mOnComputeInternalInsetsListeners), [VariableReference(mOnComputeInternalInsetsListeners, []), Expression(observer.mOnComputeInternalInsetsListeners, [])])    VariableReference(mOnComputeInternalInsetsListeners, [])    Expression(observer.mOnComputeInternalInsetsListeners, [])  Statement(} else {, [])  AssignmentExpression(=, [VariableReference(mOnComputeInternalInsetsListeners, []), Expression(observer.mOnComputeInternalInsetsListeners, [])])    VariableReference(mOnComputeInternalInsetsListeners, [])    Expression(observer.mOnComputeInternalInsetsListeners, [])  Statement(}, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(if (observer.mOnScrollChangedListeners !, []), Expression(null) {, [])])    VariableReference(if (observer.mOnScrollChangedListeners !, [])    Expression(null) {, [])  AssignmentExpression(=, [VariableReference(if (mOnScrollChangedListeners !, []), Expression(null) {, [])])    VariableReference(if (mOnScrollChangedListeners !, [])    Expression(null) {, [])  MethodCall(mOnScrollChangedListeners.addAll(observer.mOnScrollChangedListeners), [VariableReference(mOnScrollChangedListeners, []), Expression(observer.mOnScrollChangedListeners, [])])    VariableReference(mOnScrollChangedListeners, [])    Expression(observer.mOnScrollChangedListeners, [])  Statement(} else {, [])  AssignmentExpression(=, [VariableReference(mOnScrollChangedListeners, []), Expression(observer.mOnScrollChangedListeners, [])])    VariableReference(mOnScrollChangedListeners, [])    Expression(observer.mOnScrollChangedListeners, [])  Statement(}, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(if (observer.mOnWindowShownListeners !, []), Expression(null) {, [])])    VariableReference(if (observer.mOnWindowShownListeners !, [])    Expression(null) {, [])  AssignmentExpression(=, [VariableReference(if (mOnWindowShownListeners !, []), Expression(null) {, [])])    VariableReference(if (mOnWindowShownListeners !, [])    Expression(null) {, [])  MethodCall(mOnWindowShownListeners.addAll(observer.mOnWindowShownListeners), [VariableReference(mOnWindowShownListeners, []), Expression(observer.mOnWindowShownListeners, [])])    VariableReference(mOnWindowShownListeners, [])    Expression(observer.mOnWindowShownListeners, [])  Statement(} else {, [])  AssignmentExpression(=, [VariableReference(mOnWindowShownListeners, []), Expression(observer.mOnWindowShownListeners, [])])    VariableReference(mOnWindowShownListeners, [])    Expression(observer.mOnWindowShownListeners, [])  Statement(}, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(if (observer.mGestureExclusionListeners !, []), Expression(null) {, [])])    VariableReference(if (observer.mGestureExclusionListeners !, [])    Expression(null) {, [])  AssignmentExpression(=, [VariableReference(if (mGestureExclusionListeners !, []), Expression(null) {, [])])    VariableReference(if (mGestureExclusionListeners !, [])    Expression(null) {, [])  MethodCall(mGestureExclusionListeners.addAll(observer.mGestureExclusionListeners), [VariableReference(mGestureExclusionListeners, []), Expression(observer.mGestureExclusionListeners, [])])    VariableReference(mGestureExclusionListeners, [])    Expression(observer.mGestureExclusionListeners, [])  Statement(} else {, [])  AssignmentExpression(=, [VariableReference(mGestureExclusionListeners, []), Expression(observer.mGestureExclusionListeners, [])])    VariableReference(mGestureExclusionListeners, [])    Expression(observer.mGestureExclusionListeners, [])  Statement(}, [])  Statement(}, [])  MethodCall(observer.kill(), [VariableReference(observer, []), Expression(, [])])    VariableReference(observer, [])    Expression(, [])  Statement(}, [])",1,"/**
 * Merges all the listeners registered on the specified observer with the listeners
 * registered on this object. After this method is invoked, the specified observer
 * will return false in {@link #isAlive()} and should not be used anymore.
 *
 * @param observer The ViewTreeObserver whose listeners must be added to this observer
 */
","/**
 * Merges all the listeners registered on the specified observer with the listeners
 * registered on this object. After this method is invoked, the specified observer
 * will return false in {@link #isAlive()} and should not be used anymore.
 *
 * @param observer The ViewTreeObserver whose listeners must be added to this observer
 */
",0,,,0,,,,"1,2","3,4",1,3,0,"The latest implementation introduced a new listener type `mOnFrameCommitListeners` and `mGestureExclusionListeners` in the merging logic of the `merge()` method. This indicates a change in the control dependency, as new control flows have been introduced for these listener types.","The introduction of new listeners to be merged does not cause a return value change or exception handling difference. Because there's no impact on return values or exception handling behaviours, no Compatibility Issue exists."
93,<android.os.StrictMode.AndroidBlockGuardPolicy: int getPolicyMask()>,28,29,,,,"MethodDeclaration(method_body, [Statement({, []), Statement(return mPolicyMask, []), Statement(}, [])])  Statement({, [])  Statement(return mPolicyMask, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(return mThreadPolicyMask, []), Statement(}, [])])  Statement({, [])  Statement(return mThreadPolicyMask, [])  Statement(}, [])",1,"// Part of BlockGuard.Policy interface:
","// Part of BlockGuard.Policy interface:
",0,,,0,,,,"1,2","1,5",1,1,1,"The return statement has changed from returning `mPolicyMask` to `mThreadPolicyMask`, so the code change type is 1.","Since the API now returns `mThreadPolicyMask` instead of `mPolicyMask`, it could return different values, hence the CI type is 1."
94,<android.net.ConnectivityManager: boolean isActiveNetworkMetered()>,22,23,,,,"MethodDeclaration(method_body, [Statement({, []), Statement(try {, []), MethodCall(return mService.isActiveNetworkMetered(), [VariableReference(return mService, []), Expression(, [])]), Statement(} catch (RemoteException e) {, []), Statement(return false, []), Statement(}, []), Statement(}, [])])  Statement({, [])  Statement(try {, [])  MethodCall(return mService.isActiveNetworkMetered(), [VariableReference(return mService, []), Expression(, [])])    VariableReference(return mService, [])    Expression(, [])  Statement(} catch (RemoteException e) {, [])  Statement(return false, [])  Statement(}, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(try {, []), MethodCall(return mService.isActiveNetworkMetered(), [VariableReference(return mService, []), Expression(, [])]), Statement(} catch (RemoteException e) {, []), Statement(return false, []), Statement(}, []), Statement(}, [])])  Statement({, [])  Statement(try {, [])  MethodCall(return mService.isActiveNetworkMetered(), [VariableReference(return mService, []), Expression(, [])])    VariableReference(return mService, [])    Expression(, [])  Statement(} catch (RemoteException e) {, [])  Statement(return false, [])  Statement(}, [])  Statement(}, [])",0,"/**
 * Returns if the currently active data network is metered. A network is
 * classified as metered when the user is sensitive to heavy data usage on
 * that connection due to monetary costs, data limitations or
 * battery/performance issues. You should check this before doing large
 * data transfers, and warn the user or delay the operation until another
 * network is available.
 *
 * @return {@code true} if large transfers should be avoided, otherwise
 * {@code false}.
 *
 * <p>This method requires the call to hold the permission
 * {@link android.Manifest.permission#ACCESS_NETWORK_STATE}.
 */
","/**
 * Returns if the currently active data network is metered. A network is
 * classified as metered when the user is sensitive to heavy data usage on
 * that connection due to monetary costs, data limitations or
 * battery/performance issues. You should check this before doing large
 * data transfers, and warn the user or delay the operation until another
 * network is available.
 * <p>This method requires the caller to hold the permission
 * {@link android.Manifest.permission#ACCESS_NETWORK_STATE}.
 *
 * @return {@code true} if large transfers should be avoided, otherwise
 * {@code false}.
 */
",1,,,0,,,,0,0,0,0,0,"There is no change in the code between the early and late versions. The AST, comments, and annotations are identical.","Since there are no changes in the code, there are no compatibility issues."
95,<android.view.InputDevice: String toString()>,22,23,,,,"MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(StringBuilder description, []), Expression(new StringBuilder(), [])]), MethodCall(description.append(""Input Device "").append(mId).append("": "").append(mName).append(""\n""), [VariableReference(description, []), Expression(""Input Device "").append(mId).append("": "").append(mName).append(""\n"", [])]), MethodCall(description.append(""  Descriptor: "").append(mDescriptor).append(""\n""), [VariableReference(description, []), Expression(""  Descriptor: "").append(mDescriptor).append(""\n"", [])]), MethodCall(description.append(""  Generation: "").append(mGeneration).append(""\n""), [VariableReference(description, []), Expression(""  Generation: "").append(mGeneration).append(""\n"", [])]), MethodCall(description.append(""  Location: "").append(mIsExternal ? ""external"" : ""built-in"").append(""\n""), [VariableReference(description, []), Expression(""  Location: "").append(mIsExternal ? ""external"" : ""built-in"").append(""\n"", [])]), MethodCall(description.append(""  Keyboard Type: ""), [VariableReference(description, []), Expression(""  Keyboard Type: "", [])]), Statement(switch(mKeyboardType) {, []), Statement(case KEYBOARD_TYPE_NONE:, []), MethodCall(description.append(""none""), [VariableReference(description, []), Expression(""none"", [])]), Statement(break, []), Statement(case KEYBOARD_TYPE_NON_ALPHABETIC:, []), MethodCall(description.append(""non-alphabetic""), [VariableReference(description, []), Expression(""non-alphabetic"", [])]), Statement(break, []), Statement(case KEYBOARD_TYPE_ALPHABETIC:, []), MethodCall(description.append(""alphabetic""), [VariableReference(description, []), Expression(""alphabetic"", [])]), Statement(break, []), Statement(}, []), MethodCall(description.append(""\n""), [VariableReference(description, []), Expression(""\n"", [])]), MethodCall(description.append(""  Has Vibrator: "").append(mHasVibrator).append(""\n""), [VariableReference(description, []), Expression(""  Has Vibrator: "").append(mHasVibrator).append(""\n"", [])]), MethodCall(description.append(""  Sources: 0x"").append(Integer.toHexString(mSources)).append("" (""), [VariableReference(description, []), Expression(""  Sources: 0x"").append(Integer.toHexString(mSources)).append("" ("", [])]), Statement(appendSourceDescriptionIfApplicable(description, SOURCE_KEYBOARD, ""keyboard""), []), Statement(appendSourceDescriptionIfApplicable(description, SOURCE_DPAD, ""dpad""), []), Statement(appendSourceDescriptionIfApplicable(description, SOURCE_TOUCHSCREEN, ""touchscreen""), []), Statement(appendSourceDescriptionIfApplicable(description, SOURCE_MOUSE, ""mouse""), []), Statement(appendSourceDescriptionIfApplicable(description, SOURCE_STYLUS, ""stylus""), []), Statement(appendSourceDescriptionIfApplicable(description, SOURCE_TRACKBALL, ""trackball""), []), Statement(appendSourceDescriptionIfApplicable(description, SOURCE_TOUCHPAD, ""touchpad""), []), Statement(appendSourceDescriptionIfApplicable(description, SOURCE_JOYSTICK, ""joystick""), []), Statement(appendSourceDescriptionIfApplicable(description, SOURCE_GAMEPAD, ""gamepad""), []), MethodCall(description.append("" )\n""), [VariableReference(description, []), Expression("" )\n"", [])]), AssignmentExpression(=, [VariableReference(final int numAxes, []), Expression(mMotionRanges.size(), [])]), AssignmentExpression(=, [VariableReference(for (int i, []), Expression(0, [])]), Statement(i < numAxes, []), Statement(i++) {, []), AssignmentExpression(=, [VariableReference(MotionRange range, []), Expression(mMotionRanges.get(i), [])]), MethodCall(description.append(""    "").append(MotionEvent.axisToString(range.mAxis)), [VariableReference(description, []), Expression(""    "").append(MotionEvent.axisToString(range.mAxis), [])]), AssignmentExpression(=, [VariableReference(description.append("": source, []), Expression(0x"").append(Integer.toHexString(range.mSource)), [])]), AssignmentExpression(=, [VariableReference(description.append("" min, []), Expression("").append(range.mMin), [])]), AssignmentExpression(=, [VariableReference(description.append("" max, []), Expression("").append(range.mMax), [])]), AssignmentExpression(=, [VariableReference(description.append("" flat, []), Expression("").append(range.mFlat), [])]), AssignmentExpression(=, [VariableReference(description.append("" fuzz, []), Expression("").append(range.mFuzz), [])]), AssignmentExpression(=, [VariableReference(description.append("" resolution, []), Expression("").append(range.mResolution), [])]), MethodCall(description.append(""\n""), [VariableReference(description, []), Expression(""\n"", [])]), Statement(}, []), MethodCall(return description.toString(), [VariableReference(return description, []), Expression(, [])]), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(StringBuilder description, []), Expression(new StringBuilder(), [])])    VariableReference(StringBuilder description, [])    Expression(new StringBuilder(), [])  MethodCall(description.append(""Input Device "").append(mId).append("": "").append(mName).append(""\n""), [VariableReference(description, []), Expression(""Input Device "").append(mId).append("": "").append(mName).append(""\n"", [])])    VariableReference(description, [])    Expression(""Input Device "").append(mId).append("": "").append(mName).append(""\n"", [])  MethodCall(description.append(""  Descriptor: "").append(mDescriptor).append(""\n""), [VariableReference(description, []), Expression(""  Descriptor: "").append(mDescriptor).append(""\n"", [])])    VariableReference(description, [])    Expression(""  Descriptor: "").append(mDescriptor).append(""\n"", [])  MethodCall(description.append(""  Generation: "").append(mGeneration).append(""\n""), [VariableReference(description, []), Expression(""  Generation: "").append(mGeneration).append(""\n"", [])])    VariableReference(description, [])    Expression(""  Generation: "").append(mGeneration).append(""\n"", [])  MethodCall(description.append(""  Location: "").append(mIsExternal ? ""external"" : ""built-in"").append(""\n""), [VariableReference(description, []), Expression(""  Location: "").append(mIsExternal ? ""external"" : ""built-in"").append(""\n"", [])])    VariableReference(description, [])    Expression(""  Location: "").append(mIsExternal ? ""external"" : ""built-in"").append(""\n"", [])  MethodCall(description.append(""  Keyboard Type: ""), [VariableReference(description, []), Expression(""  Keyboard Type: "", [])])    VariableReference(description, [])    Expression(""  Keyboard Type: "", [])  Statement(switch(mKeyboardType) {, [])  Statement(case KEYBOARD_TYPE_NONE:, [])  MethodCall(description.append(""none""), [VariableReference(description, []), Expression(""none"", [])])    VariableReference(description, [])    Expression(""none"", [])  Statement(break, [])  Statement(case KEYBOARD_TYPE_NON_ALPHABETIC:, [])  MethodCall(description.append(""non-alphabetic""), [VariableReference(description, []), Expression(""non-alphabetic"", [])])    VariableReference(description, [])    Expression(""non-alphabetic"", [])  Statement(break, [])  Statement(case KEYBOARD_TYPE_ALPHABETIC:, [])  MethodCall(description.append(""alphabetic""), [VariableReference(description, []), Expression(""alphabetic"", [])])    VariableReference(description, [])    Expression(""alphabetic"", [])  Statement(break, [])  Statement(}, [])  MethodCall(description.append(""\n""), [VariableReference(description, []), Expression(""\n"", [])])    VariableReference(description, [])    Expression(""\n"", [])  MethodCall(description.append(""  Has Vibrator: "").append(mHasVibrator).append(""\n""), [VariableReference(description, []), Expression(""  Has Vibrator: "").append(mHasVibrator).append(""\n"", [])])    VariableReference(description, [])    Expression(""  Has Vibrator: "").append(mHasVibrator).append(""\n"", [])  MethodCall(description.append(""  Sources: 0x"").append(Integer.toHexString(mSources)).append("" (""), [VariableReference(description, []), Expression(""  Sources: 0x"").append(Integer.toHexString(mSources)).append("" ("", [])])    VariableReference(description, [])    Expression(""  Sources: 0x"").append(Integer.toHexString(mSources)).append("" ("", [])  Statement(appendSourceDescriptionIfApplicable(description, SOURCE_KEYBOARD, ""keyboard""), [])  Statement(appendSourceDescriptionIfApplicable(description, SOURCE_DPAD, ""dpad""), [])  Statement(appendSourceDescriptionIfApplicable(description, SOURCE_TOUCHSCREEN, ""touchscreen""), [])  Statement(appendSourceDescriptionIfApplicable(description, SOURCE_MOUSE, ""mouse""), [])  Statement(appendSourceDescriptionIfApplicable(description, SOURCE_STYLUS, ""stylus""), [])  Statement(appendSourceDescriptionIfApplicable(description, SOURCE_TRACKBALL, ""trackball""), [])  Statement(appendSourceDescriptionIfApplicable(description, SOURCE_TOUCHPAD, ""touchpad""), [])  Statement(appendSourceDescriptionIfApplicable(description, SOURCE_JOYSTICK, ""joystick""), [])  Statement(appendSourceDescriptionIfApplicable(description, SOURCE_GAMEPAD, ""gamepad""), [])  MethodCall(description.append("" )\n""), [VariableReference(description, []), Expression("" )\n"", [])])    VariableReference(description, [])    Expression("" )\n"", [])  AssignmentExpression(=, [VariableReference(final int numAxes, []), Expression(mMotionRanges.size(), [])])    VariableReference(final int numAxes, [])    Expression(mMotionRanges.size(), [])  AssignmentExpression(=, [VariableReference(for (int i, []), Expression(0, [])])    VariableReference(for (int i, [])    Expression(0, [])  Statement(i < numAxes, [])  Statement(i++) {, [])  AssignmentExpression(=, [VariableReference(MotionRange range, []), Expression(mMotionRanges.get(i), [])])    VariableReference(MotionRange range, [])    Expression(mMotionRanges.get(i), [])  MethodCall(description.append(""    "").append(MotionEvent.axisToString(range.mAxis)), [VariableReference(description, []), Expression(""    "").append(MotionEvent.axisToString(range.mAxis), [])])    VariableReference(description, [])    Expression(""    "").append(MotionEvent.axisToString(range.mAxis), [])  AssignmentExpression(=, [VariableReference(description.append("": source, []), Expression(0x"").append(Integer.toHexString(range.mSource)), [])])    VariableReference(description.append("": source, [])    Expression(0x"").append(Integer.toHexString(range.mSource)), [])  AssignmentExpression(=, [VariableReference(description.append("" min, []), Expression("").append(range.mMin), [])])    VariableReference(description.append("" min, [])    Expression("").append(range.mMin), [])  AssignmentExpression(=, [VariableReference(description.append("" max, []), Expression("").append(range.mMax), [])])    VariableReference(description.append("" max, [])    Expression("").append(range.mMax), [])  AssignmentExpression(=, [VariableReference(description.append("" flat, []), Expression("").append(range.mFlat), [])])    VariableReference(description.append("" flat, [])    Expression("").append(range.mFlat), [])  AssignmentExpression(=, [VariableReference(description.append("" fuzz, []), Expression("").append(range.mFuzz), [])])    VariableReference(description.append("" fuzz, [])    Expression("").append(range.mFuzz), [])  AssignmentExpression(=, [VariableReference(description.append("" resolution, []), Expression("").append(range.mResolution), [])])    VariableReference(description.append("" resolution, [])    Expression("").append(range.mResolution), [])  MethodCall(description.append(""\n""), [VariableReference(description, []), Expression(""\n"", [])])    VariableReference(description, [])    Expression(""\n"", [])  Statement(}, [])  MethodCall(return description.toString(), [VariableReference(return description, []), Expression(, [])])    VariableReference(return description, [])    Expression(, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(StringBuilder description, []), Expression(new StringBuilder(), [])]), MethodCall(description.append(""Input Device "").append(mId).append("": "").append(mName).append(""\n""), [VariableReference(description, []), Expression(""Input Device "").append(mId).append("": "").append(mName).append(""\n"", [])]), MethodCall(description.append(""  Descriptor: "").append(mDescriptor).append(""\n""), [VariableReference(description, []), Expression(""  Descriptor: "").append(mDescriptor).append(""\n"", [])]), MethodCall(description.append(""  Generation: "").append(mGeneration).append(""\n""), [VariableReference(description, []), Expression(""  Generation: "").append(mGeneration).append(""\n"", [])]), MethodCall(description.append(""  Location: "").append(mIsExternal ? ""external"" : ""built-in"").append(""\n""), [VariableReference(description, []), Expression(""  Location: "").append(mIsExternal ? ""external"" : ""built-in"").append(""\n"", [])]), MethodCall(description.append(""  Keyboard Type: ""), [VariableReference(description, []), Expression(""  Keyboard Type: "", [])]), Statement(switch(mKeyboardType) {, []), Statement(case KEYBOARD_TYPE_NONE:, []), MethodCall(description.append(""none""), [VariableReference(description, []), Expression(""none"", [])]), Statement(break, []), Statement(case KEYBOARD_TYPE_NON_ALPHABETIC:, []), MethodCall(description.append(""non-alphabetic""), [VariableReference(description, []), Expression(""non-alphabetic"", [])]), Statement(break, []), Statement(case KEYBOARD_TYPE_ALPHABETIC:, []), MethodCall(description.append(""alphabetic""), [VariableReference(description, []), Expression(""alphabetic"", [])]), Statement(break, []), Statement(}, []), MethodCall(description.append(""\n""), [VariableReference(description, []), Expression(""\n"", [])]), MethodCall(description.append(""  Has Vibrator: "").append(mHasVibrator).append(""\n""), [VariableReference(description, []), Expression(""  Has Vibrator: "").append(mHasVibrator).append(""\n"", [])]), MethodCall(description.append(""  Has mic: "").append(mHasMicrophone).append(""\n""), [VariableReference(description, []), Expression(""  Has mic: "").append(mHasMicrophone).append(""\n"", [])]), MethodCall(description.append(""  Sources: 0x"").append(Integer.toHexString(mSources)).append("" (""), [VariableReference(description, []), Expression(""  Sources: 0x"").append(Integer.toHexString(mSources)).append("" ("", [])]), Statement(appendSourceDescriptionIfApplicable(description, SOURCE_KEYBOARD, ""keyboard""), []), Statement(appendSourceDescriptionIfApplicable(description, SOURCE_DPAD, ""dpad""), []), Statement(appendSourceDescriptionIfApplicable(description, SOURCE_TOUCHSCREEN, ""touchscreen""), []), Statement(appendSourceDescriptionIfApplicable(description, SOURCE_MOUSE, ""mouse""), []), Statement(appendSourceDescriptionIfApplicable(description, SOURCE_STYLUS, ""stylus""), []), Statement(appendSourceDescriptionIfApplicable(description, SOURCE_TRACKBALL, ""trackball""), []), Statement(appendSourceDescriptionIfApplicable(description, SOURCE_TOUCHPAD, ""touchpad""), []), Statement(appendSourceDescriptionIfApplicable(description, SOURCE_JOYSTICK, ""joystick""), []), Statement(appendSourceDescriptionIfApplicable(description, SOURCE_GAMEPAD, ""gamepad""), []), MethodCall(description.append("" )\n""), [VariableReference(description, []), Expression("" )\n"", [])]), AssignmentExpression(=, [VariableReference(final int numAxes, []), Expression(mMotionRanges.size(), [])]), AssignmentExpression(=, [VariableReference(for (int i, []), Expression(0, [])]), Statement(i < numAxes, []), Statement(i++) {, []), AssignmentExpression(=, [VariableReference(MotionRange range, []), Expression(mMotionRanges.get(i), [])]), MethodCall(description.append(""    "").append(MotionEvent.axisToString(range.mAxis)), [VariableReference(description, []), Expression(""    "").append(MotionEvent.axisToString(range.mAxis), [])]), AssignmentExpression(=, [VariableReference(description.append("": source, []), Expression(0x"").append(Integer.toHexString(range.mSource)), [])]), AssignmentExpression(=, [VariableReference(description.append("" min, []), Expression("").append(range.mMin), [])]), AssignmentExpression(=, [VariableReference(description.append("" max, []), Expression("").append(range.mMax), [])]), AssignmentExpression(=, [VariableReference(description.append("" flat, []), Expression("").append(range.mFlat), [])]), AssignmentExpression(=, [VariableReference(description.append("" fuzz, []), Expression("").append(range.mFuzz), [])]), AssignmentExpression(=, [VariableReference(description.append("" resolution, []), Expression("").append(range.mResolution), [])]), MethodCall(description.append(""\n""), [VariableReference(description, []), Expression(""\n"", [])]), Statement(}, []), MethodCall(return description.toString(), [VariableReference(return description, []), Expression(, [])]), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(StringBuilder description, []), Expression(new StringBuilder(), [])])    VariableReference(StringBuilder description, [])    Expression(new StringBuilder(), [])  MethodCall(description.append(""Input Device "").append(mId).append("": "").append(mName).append(""\n""), [VariableReference(description, []), Expression(""Input Device "").append(mId).append("": "").append(mName).append(""\n"", [])])    VariableReference(description, [])    Expression(""Input Device "").append(mId).append("": "").append(mName).append(""\n"", [])  MethodCall(description.append(""  Descriptor: "").append(mDescriptor).append(""\n""), [VariableReference(description, []), Expression(""  Descriptor: "").append(mDescriptor).append(""\n"", [])])    VariableReference(description, [])    Expression(""  Descriptor: "").append(mDescriptor).append(""\n"", [])  MethodCall(description.append(""  Generation: "").append(mGeneration).append(""\n""), [VariableReference(description, []), Expression(""  Generation: "").append(mGeneration).append(""\n"", [])])    VariableReference(description, [])    Expression(""  Generation: "").append(mGeneration).append(""\n"", [])  MethodCall(description.append(""  Location: "").append(mIsExternal ? ""external"" : ""built-in"").append(""\n""), [VariableReference(description, []), Expression(""  Location: "").append(mIsExternal ? ""external"" : ""built-in"").append(""\n"", [])])    VariableReference(description, [])    Expression(""  Location: "").append(mIsExternal ? ""external"" : ""built-in"").append(""\n"", [])  MethodCall(description.append(""  Keyboard Type: ""), [VariableReference(description, []), Expression(""  Keyboard Type: "", [])])    VariableReference(description, [])    Expression(""  Keyboard Type: "", [])  Statement(switch(mKeyboardType) {, [])  Statement(case KEYBOARD_TYPE_NONE:, [])  MethodCall(description.append(""none""), [VariableReference(description, []), Expression(""none"", [])])    VariableReference(description, [])    Expression(""none"", [])  Statement(break, [])  Statement(case KEYBOARD_TYPE_NON_ALPHABETIC:, [])  MethodCall(description.append(""non-alphabetic""), [VariableReference(description, []), Expression(""non-alphabetic"", [])])    VariableReference(description, [])    Expression(""non-alphabetic"", [])  Statement(break, [])  Statement(case KEYBOARD_TYPE_ALPHABETIC:, [])  MethodCall(description.append(""alphabetic""), [VariableReference(description, []), Expression(""alphabetic"", [])])    VariableReference(description, [])    Expression(""alphabetic"", [])  Statement(break, [])  Statement(}, [])  MethodCall(description.append(""\n""), [VariableReference(description, []), Expression(""\n"", [])])    VariableReference(description, [])    Expression(""\n"", [])  MethodCall(description.append(""  Has Vibrator: "").append(mHasVibrator).append(""\n""), [VariableReference(description, []), Expression(""  Has Vibrator: "").append(mHasVibrator).append(""\n"", [])])    VariableReference(description, [])    Expression(""  Has Vibrator: "").append(mHasVibrator).append(""\n"", [])  MethodCall(description.append(""  Has mic: "").append(mHasMicrophone).append(""\n""), [VariableReference(description, []), Expression(""  Has mic: "").append(mHasMicrophone).append(""\n"", [])])    VariableReference(description, [])    Expression(""  Has mic: "").append(mHasMicrophone).append(""\n"", [])  MethodCall(description.append(""  Sources: 0x"").append(Integer.toHexString(mSources)).append("" (""), [VariableReference(description, []), Expression(""  Sources: 0x"").append(Integer.toHexString(mSources)).append("" ("", [])])    VariableReference(description, [])    Expression(""  Sources: 0x"").append(Integer.toHexString(mSources)).append("" ("", [])  Statement(appendSourceDescriptionIfApplicable(description, SOURCE_KEYBOARD, ""keyboard""), [])  Statement(appendSourceDescriptionIfApplicable(description, SOURCE_DPAD, ""dpad""), [])  Statement(appendSourceDescriptionIfApplicable(description, SOURCE_TOUCHSCREEN, ""touchscreen""), [])  Statement(appendSourceDescriptionIfApplicable(description, SOURCE_MOUSE, ""mouse""), [])  Statement(appendSourceDescriptionIfApplicable(description, SOURCE_STYLUS, ""stylus""), [])  Statement(appendSourceDescriptionIfApplicable(description, SOURCE_TRACKBALL, ""trackball""), [])  Statement(appendSourceDescriptionIfApplicable(description, SOURCE_TOUCHPAD, ""touchpad""), [])  Statement(appendSourceDescriptionIfApplicable(description, SOURCE_JOYSTICK, ""joystick""), [])  Statement(appendSourceDescriptionIfApplicable(description, SOURCE_GAMEPAD, ""gamepad""), [])  MethodCall(description.append("" )\n""), [VariableReference(description, []), Expression("" )\n"", [])])    VariableReference(description, [])    Expression("" )\n"", [])  AssignmentExpression(=, [VariableReference(final int numAxes, []), Expression(mMotionRanges.size(), [])])    VariableReference(final int numAxes, [])    Expression(mMotionRanges.size(), [])  AssignmentExpression(=, [VariableReference(for (int i, []), Expression(0, [])])    VariableReference(for (int i, [])    Expression(0, [])  Statement(i < numAxes, [])  Statement(i++) {, [])  AssignmentExpression(=, [VariableReference(MotionRange range, []), Expression(mMotionRanges.get(i), [])])    VariableReference(MotionRange range, [])    Expression(mMotionRanges.get(i), [])  MethodCall(description.append(""    "").append(MotionEvent.axisToString(range.mAxis)), [VariableReference(description, []), Expression(""    "").append(MotionEvent.axisToString(range.mAxis), [])])    VariableReference(description, [])    Expression(""    "").append(MotionEvent.axisToString(range.mAxis), [])  AssignmentExpression(=, [VariableReference(description.append("": source, []), Expression(0x"").append(Integer.toHexString(range.mSource)), [])])    VariableReference(description.append("": source, [])    Expression(0x"").append(Integer.toHexString(range.mSource)), [])  AssignmentExpression(=, [VariableReference(description.append("" min, []), Expression("").append(range.mMin), [])])    VariableReference(description.append("" min, [])    Expression("").append(range.mMin), [])  AssignmentExpression(=, [VariableReference(description.append("" max, []), Expression("").append(range.mMax), [])])    VariableReference(description.append("" max, [])    Expression("").append(range.mMax), [])  AssignmentExpression(=, [VariableReference(description.append("" flat, []), Expression("").append(range.mFlat), [])])    VariableReference(description.append("" flat, [])    Expression("").append(range.mFlat), [])  AssignmentExpression(=, [VariableReference(description.append("" fuzz, []), Expression("").append(range.mFuzz), [])])    VariableReference(description.append("" fuzz, [])    Expression("").append(range.mFuzz), [])  AssignmentExpression(=, [VariableReference(description.append("" resolution, []), Expression("").append(range.mResolution), [])])    VariableReference(description.append("" resolution, [])    Expression("").append(range.mResolution), [])  MethodCall(description.append(""\n""), [VariableReference(description, []), Expression(""\n"", [])])    VariableReference(description, [])    Expression(""\n"", [])  Statement(}, [])  MethodCall(return description.toString(), [VariableReference(return description, []), Expression(, [])])    VariableReference(return description, [])    Expression(, [])  Statement(}, [])",1,,,0,[@Override],[@Override],0,,,,1,"1,4",1,4,0,A new line `description.append("  Has mic: ").append(mHasMicrophone).append("\n");` is added to the list of statements forming the description string. This can be classified as "Other statement changed".,"The added statement does not affect the return value types, nor does it handle exceptions differently compared to the early version. Therefore, no compatibility issue should arise based on the given definition with change types and rules setup."
96,<android.view.ViewGroup: boolean isAnimationCacheEnabled()>,22,23,,,,"MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(return (mGroupFlags & FLAG_ANIMATION_CACHE), []), Expression(, [])]), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(return (mGroupFlags & FLAG_ANIMATION_CACHE), []), Expression(, [])])    VariableReference(return (mGroupFlags & FLAG_ANIMATION_CACHE), [])    Expression(, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(return (mGroupFlags & FLAG_ANIMATION_CACHE), []), Expression(, [])]), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(return (mGroupFlags & FLAG_ANIMATION_CACHE), []), Expression(, [])])    VariableReference(return (mGroupFlags & FLAG_ANIMATION_CACHE), [])    Expression(, [])  Statement(}, [])",0,"/**
 * Indicates whether the children's drawing cache is used during a layout
 * animation. By default, the drawing cache is enabled but this will prevent
 * nested layout animations from working. To nest animations, you must disable
 * the cache.
 *
 * @return true if the animation cache is enabled, false otherwise
 *
 * @see #setAnimationCacheEnabled(boolean)
 * @see View#setDrawingCacheEnabled(boolean)
 */
","/**
 * Indicates whether the children's drawing cache is used during a layout
 * animation. By default, the drawing cache is enabled but this will prevent
 * nested layout animations from working. To nest animations, you must disable
 * the cache.
 *
 * @return true if the animation cache is enabled, false otherwise
 *
 * @see #setAnimationCacheEnabled(boolean)
 * @see View#setDrawingCacheEnabled(boolean)
 *
 * @deprecated As of {@link android.os.Build.VERSION_CODES#M}, this property is ignored.
 * Caching behavior of children may be controlled through {@link View#setLayerType(int, Paint)}.
 */
",1,[@ViewDebug.ExportedProperty],,1,,,,0,0,0,0,0,There are no changes in the implementation of the method itself across the given versions.,"Since the implementation hasn't changed between the two versions, there is no potential for different behaviors or compatibility issues."
97,"<android.hardware.SystemSensorManager.TriggerEventQueue: void dispatchSensorEvent(int,float[],int,long)>",22,23,,,,"MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(final Sensor sensor, []), Expression(sHandleToSensor.get(handle), [])]), AssignmentExpression(=, [VariableReference(TriggerEvent t, []), Expression(null, [])]), Statement(synchronized (mTriggerEvents) {, []), AssignmentExpression(=, [VariableReference(t, []), Expression(mTriggerEvents.get(handle), [])]), Statement(}, []), AssignmentExpression(=, [VariableReference(if (t, []), Expression(, [])]), MethodCall(Log.e(TAG, ""Error: Trigger Event is null for Sensor: "" + sensor), [VariableReference(Log, []), Expression(TAG, []), Expression(""Error: Trigger Event is null for Sensor: "" + sensor, [])]), Statement(return, []), Statement(}, []), Statement(// Copy from the values array., []), MethodCall(System.arraycopy(values, 0, t.values, 0, t.values.length), [VariableReference(System, []), Expression(values, []), Expression(0, []), Expression(t.values, []), Expression(0, []), Expression(t.values.length, [])]), AssignmentExpression(=, [VariableReference(t.timestamp, []), Expression(timestamp, [])]), AssignmentExpression(=, [VariableReference(t.sensor, []), Expression(sensor, [])]), Statement(// A trigger sensor is auto disabled. So just clean up and don't call native, []), Statement(// disable., []), MethodCall(mManager.cancelTriggerSensorImpl(mListener, sensor, false), [VariableReference(mManager, []), Expression(mListener, []), Expression(sensor, []), Expression(false, [])]), MethodCall(mListener.onTrigger(t), [VariableReference(mListener, []), Expression(t, [])]), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(final Sensor sensor, []), Expression(sHandleToSensor.get(handle), [])])    VariableReference(final Sensor sensor, [])    Expression(sHandleToSensor.get(handle), [])  AssignmentExpression(=, [VariableReference(TriggerEvent t, []), Expression(null, [])])    VariableReference(TriggerEvent t, [])    Expression(null, [])  Statement(synchronized (mTriggerEvents) {, [])  AssignmentExpression(=, [VariableReference(t, []), Expression(mTriggerEvents.get(handle), [])])    VariableReference(t, [])    Expression(mTriggerEvents.get(handle), [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(if (t, []), Expression(, [])])    VariableReference(if (t, [])    Expression(, [])  MethodCall(Log.e(TAG, ""Error: Trigger Event is null for Sensor: "" + sensor), [VariableReference(Log, []), Expression(TAG, []), Expression(""Error: Trigger Event is null for Sensor: "" + sensor, [])])    VariableReference(Log, [])    Expression(TAG, [])    Expression(""Error: Trigger Event is null for Sensor: "" + sensor, [])  Statement(return, [])  Statement(}, [])  Statement(// Copy from the values array., [])  MethodCall(System.arraycopy(values, 0, t.values, 0, t.values.length), [VariableReference(System, []), Expression(values, []), Expression(0, []), Expression(t.values, []), Expression(0, []), Expression(t.values.length, [])])    VariableReference(System, [])    Expression(values, [])    Expression(0, [])    Expression(t.values, [])    Expression(0, [])    Expression(t.values.length, [])  AssignmentExpression(=, [VariableReference(t.timestamp, []), Expression(timestamp, [])])    VariableReference(t.timestamp, [])    Expression(timestamp, [])  AssignmentExpression(=, [VariableReference(t.sensor, []), Expression(sensor, [])])    VariableReference(t.sensor, [])    Expression(sensor, [])  Statement(// A trigger sensor is auto disabled. So just clean up and don't call native, [])  Statement(// disable., [])  MethodCall(mManager.cancelTriggerSensorImpl(mListener, sensor, false), [VariableReference(mManager, []), Expression(mListener, []), Expression(sensor, []), Expression(false, [])])    VariableReference(mManager, [])    Expression(mListener, [])    Expression(sensor, [])    Expression(false, [])  MethodCall(mListener.onTrigger(t), [VariableReference(mListener, []), Expression(t, [])])    VariableReference(mListener, [])    Expression(t, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(final Sensor sensor, []), Expression(mManager.mHandleToSensor.get(handle), [])]), AssignmentExpression(=, [VariableReference(TriggerEvent t, []), Expression(null, [])]), Statement(synchronized (mTriggerEvents) {, []), AssignmentExpression(=, [VariableReference(t, []), Expression(mTriggerEvents.get(handle), [])]), Statement(}, []), AssignmentExpression(=, [VariableReference(if (t, []), Expression(, [])]), MethodCall(Log.e(TAG, ""Error: Trigger Event is null for Sensor: "" + sensor), [VariableReference(Log, []), Expression(TAG, []), Expression(""Error: Trigger Event is null for Sensor: "" + sensor, [])]), Statement(return, []), Statement(}, []), Statement(// Copy from the values array., []), MethodCall(System.arraycopy(values, 0, t.values, 0, t.values.length), [VariableReference(System, []), Expression(values, []), Expression(0, []), Expression(t.values, []), Expression(0, []), Expression(t.values.length, [])]), AssignmentExpression(=, [VariableReference(t.timestamp, []), Expression(timestamp, [])]), AssignmentExpression(=, [VariableReference(t.sensor, []), Expression(sensor, [])]), Statement(// A trigger sensor is auto disabled. So just clean up and don't call native, []), Statement(// disable., []), MethodCall(mManager.cancelTriggerSensorImpl(mListener, sensor, false), [VariableReference(mManager, []), Expression(mListener, []), Expression(sensor, []), Expression(false, [])]), MethodCall(mListener.onTrigger(t), [VariableReference(mListener, []), Expression(t, [])]), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(final Sensor sensor, []), Expression(mManager.mHandleToSensor.get(handle), [])])    VariableReference(final Sensor sensor, [])    Expression(mManager.mHandleToSensor.get(handle), [])  AssignmentExpression(=, [VariableReference(TriggerEvent t, []), Expression(null, [])])    VariableReference(TriggerEvent t, [])    Expression(null, [])  Statement(synchronized (mTriggerEvents) {, [])  AssignmentExpression(=, [VariableReference(t, []), Expression(mTriggerEvents.get(handle), [])])    VariableReference(t, [])    Expression(mTriggerEvents.get(handle), [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(if (t, []), Expression(, [])])    VariableReference(if (t, [])    Expression(, [])  MethodCall(Log.e(TAG, ""Error: Trigger Event is null for Sensor: "" + sensor), [VariableReference(Log, []), Expression(TAG, []), Expression(""Error: Trigger Event is null for Sensor: "" + sensor, [])])    VariableReference(Log, [])    Expression(TAG, [])    Expression(""Error: Trigger Event is null for Sensor: "" + sensor, [])  Statement(return, [])  Statement(}, [])  Statement(// Copy from the values array., [])  MethodCall(System.arraycopy(values, 0, t.values, 0, t.values.length), [VariableReference(System, []), Expression(values, []), Expression(0, []), Expression(t.values, []), Expression(0, []), Expression(t.values.length, [])])    VariableReference(System, [])    Expression(values, [])    Expression(0, [])    Expression(t.values, [])    Expression(0, [])    Expression(t.values.length, [])  AssignmentExpression(=, [VariableReference(t.timestamp, []), Expression(timestamp, [])])    VariableReference(t.timestamp, [])    Expression(timestamp, [])  AssignmentExpression(=, [VariableReference(t.sensor, []), Expression(sensor, [])])    VariableReference(t.sensor, [])    Expression(sensor, [])  Statement(// A trigger sensor is auto disabled. So just clean up and don't call native, [])  Statement(// disable., [])  MethodCall(mManager.cancelTriggerSensorImpl(mListener, sensor, false), [VariableReference(mManager, []), Expression(mListener, []), Expression(sensor, []), Expression(false, [])])    VariableReference(mManager, [])    Expression(mListener, [])    Expression(sensor, [])    Expression(false, [])  MethodCall(mListener.onTrigger(t), [VariableReference(mListener, []), Expression(t, [])])    VariableReference(mListener, [])    Expression(t, [])  Statement(}, [])",1,"// Called from native code.
","// Called from native code.
",0,"[@SuppressWarnings(""unused""), @Override]","[@SuppressWarnings(""unused""), @Override]",0,,,,2,"4,5",0,"4,5",0,The main change is in the `Expression` used to fetch the `Sensor` object. The early version uses:,```
98,<android.os.Bundle: boolean hasFileDescriptors()>,22,23,,,,"MethodDeclaration(method_body, [Statement({, []), Statement(if (!mFdsKnown) {, []), Statement(// keep going until we find one or run out of data, []), AssignmentExpression(=, [VariableReference(boolean fdFound, []), Expression(false, [])]), AssignmentExpression(=, [VariableReference(if (mParcelledData !, []), Expression(null) {, [])]), MethodCall(if (mParcelledData.hasFileDescriptors()), [VariableReference(if (mParcelledData, []), Expression(), [])]), AssignmentExpression(=, [VariableReference(fdFound, []), Expression(true, [])]), Statement(}, []), Statement(} else {, []), Statement(// It's been unparcelled, so we need to walk the map, []), AssignmentExpression(=, [VariableReference(for (int i, []), Expression(mMap.size() - 1, [])]), AssignmentExpression(=, [VariableReference(i >, []), Expression(0, [])]), Statement(i--) {, []), AssignmentExpression(=, [VariableReference(Object obj, []), Expression(mMap.valueAt(i), [])]), Statement(if (obj instanceof Parcelable) {, []), AssignmentExpression(=, [VariableReference(if ((((Parcelable) obj).describeContents() & Parcelable.CONTENTS_FILE_DESCRIPTOR) !, []), Expression(0) {, [])]), AssignmentExpression(=, [VariableReference(fdFound, []), Expression(true, [])]), Statement(break, []), Statement(}, []), Statement(} else if (obj instanceof Parcelable[]) {, []), AssignmentExpression(=, [VariableReference(Parcelable[] array, []), Expression((Parcelable[]) obj, [])]), AssignmentExpression(=, [VariableReference(for (int n, []), Expression(array.length - 1, [])]), AssignmentExpression(=, [VariableReference(n >, []), Expression(0, [])]), Statement(n--) {, []), AssignmentExpression(=, [VariableReference(if ((array[n].describeContents() & Parcelable.CONTENTS_FILE_DESCRIPTOR) !, []), Expression(0) {, [])]), AssignmentExpression(=, [VariableReference(fdFound, []), Expression(true, [])]), Statement(break, []), Statement(}, []), Statement(}, []), Statement(} else if (obj instanceof SparseArray) {, []), AssignmentExpression(=, [VariableReference(SparseArray<? extends Parcelable> array, []), Expression((SparseArray<? extends Parcelable>) obj, [])]), AssignmentExpression(=, [VariableReference(for (int n, []), Expression(array.size() - 1, [])]), AssignmentExpression(=, [VariableReference(n >, []), Expression(0, [])]), Statement(n--) {, []), AssignmentExpression(=, [VariableReference(if ((array.valueAt(n).describeContents() & Parcelable.CONTENTS_FILE_DESCRIPTOR) !, []), Expression(0) {, [])]), AssignmentExpression(=, [VariableReference(fdFound, []), Expression(true, [])]), Statement(break, []), Statement(}, []), Statement(}, []), Statement(} else if (obj instanceof ArrayList) {, []), AssignmentExpression(=, [VariableReference(ArrayList array, []), Expression((ArrayList) obj, [])]), Statement(// Parcelables, []), Statement(only look inside for Parcelables, []), MethodCall(if (!array.isEmpty() && (array.get(0) instanceof Parcelable)), [VariableReference(if (!array, []), Expression() && (array.get(0) instanceof Parcelable), [])]), AssignmentExpression(=, [VariableReference(for (int n, []), Expression(array.size() - 1, [])]), AssignmentExpression(=, [VariableReference(n >, []), Expression(0, [])]), Statement(n--) {, []), AssignmentExpression(=, [VariableReference(Parcelable p, []), Expression((Parcelable) array.get(n), [])]), AssignmentExpression(=, [VariableReference(if (p !, []), Expression(null && ((p.describeContents() & Parcelable.CONTENTS_FILE_DESCRIPTOR) !, [])]), AssignmentExpression(=, [VariableReference(fdFound, []), Expression(true, [])]), Statement(break, []), Statement(}, []), Statement(}, []), Statement(}, []), Statement(}, []), Statement(}, []), Statement(}, []), AssignmentExpression(=, [VariableReference(mHasFds, []), Expression(fdFound, [])]), AssignmentExpression(=, [VariableReference(mFdsKnown, []), Expression(true, [])]), Statement(}, []), Statement(return mHasFds, []), Statement(}, [])])  Statement({, [])  Statement(if (!mFdsKnown) {, [])  Statement(// keep going until we find one or run out of data, [])  AssignmentExpression(=, [VariableReference(boolean fdFound, []), Expression(false, [])])    VariableReference(boolean fdFound, [])    Expression(false, [])  AssignmentExpression(=, [VariableReference(if (mParcelledData !, []), Expression(null) {, [])])    VariableReference(if (mParcelledData !, [])    Expression(null) {, [])  MethodCall(if (mParcelledData.hasFileDescriptors()), [VariableReference(if (mParcelledData, []), Expression(), [])])    VariableReference(if (mParcelledData, [])    Expression(), [])  AssignmentExpression(=, [VariableReference(fdFound, []), Expression(true, [])])    VariableReference(fdFound, [])    Expression(true, [])  Statement(}, [])  Statement(} else {, [])  Statement(// It's been unparcelled, so we need to walk the map, [])  AssignmentExpression(=, [VariableReference(for (int i, []), Expression(mMap.size() - 1, [])])    VariableReference(for (int i, [])    Expression(mMap.size() - 1, [])  AssignmentExpression(=, [VariableReference(i >, []), Expression(0, [])])    VariableReference(i >, [])    Expression(0, [])  Statement(i--) {, [])  AssignmentExpression(=, [VariableReference(Object obj, []), Expression(mMap.valueAt(i), [])])    VariableReference(Object obj, [])    Expression(mMap.valueAt(i), [])  Statement(if (obj instanceof Parcelable) {, [])  AssignmentExpression(=, [VariableReference(if ((((Parcelable) obj).describeContents() & Parcelable.CONTENTS_FILE_DESCRIPTOR) !, []), Expression(0) {, [])])    VariableReference(if ((((Parcelable) obj).describeContents() & Parcelable.CONTENTS_FILE_DESCRIPTOR) !, [])    Expression(0) {, [])  AssignmentExpression(=, [VariableReference(fdFound, []), Expression(true, [])])    VariableReference(fdFound, [])    Expression(true, [])  Statement(break, [])  Statement(}, [])  Statement(} else if (obj instanceof Parcelable[]) {, [])  AssignmentExpression(=, [VariableReference(Parcelable[] array, []), Expression((Parcelable[]) obj, [])])    VariableReference(Parcelable[] array, [])    Expression((Parcelable[]) obj, [])  AssignmentExpression(=, [VariableReference(for (int n, []), Expression(array.length - 1, [])])    VariableReference(for (int n, [])    Expression(array.length - 1, [])  AssignmentExpression(=, [VariableReference(n >, []), Expression(0, [])])    VariableReference(n >, [])    Expression(0, [])  Statement(n--) {, [])  AssignmentExpression(=, [VariableReference(if ((array[n].describeContents() & Parcelable.CONTENTS_FILE_DESCRIPTOR) !, []), Expression(0) {, [])])    VariableReference(if ((array[n].describeContents() & Parcelable.CONTENTS_FILE_DESCRIPTOR) !, [])    Expression(0) {, [])  AssignmentExpression(=, [VariableReference(fdFound, []), Expression(true, [])])    VariableReference(fdFound, [])    Expression(true, [])  Statement(break, [])  Statement(}, [])  Statement(}, [])  Statement(} else if (obj instanceof SparseArray) {, [])  AssignmentExpression(=, [VariableReference(SparseArray<? extends Parcelable> array, []), Expression((SparseArray<? extends Parcelable>) obj, [])])    VariableReference(SparseArray<? extends Parcelable> array, [])    Expression((SparseArray<? extends Parcelable>) obj, [])  AssignmentExpression(=, [VariableReference(for (int n, []), Expression(array.size() - 1, [])])    VariableReference(for (int n, [])    Expression(array.size() - 1, [])  AssignmentExpression(=, [VariableReference(n >, []), Expression(0, [])])    VariableReference(n >, [])    Expression(0, [])  Statement(n--) {, [])  AssignmentExpression(=, [VariableReference(if ((array.valueAt(n).describeContents() & Parcelable.CONTENTS_FILE_DESCRIPTOR) !, []), Expression(0) {, [])])    VariableReference(if ((array.valueAt(n).describeContents() & Parcelable.CONTENTS_FILE_DESCRIPTOR) !, [])    Expression(0) {, [])  AssignmentExpression(=, [VariableReference(fdFound, []), Expression(true, [])])    VariableReference(fdFound, [])    Expression(true, [])  Statement(break, [])  Statement(}, [])  Statement(}, [])  Statement(} else if (obj instanceof ArrayList) {, [])  AssignmentExpression(=, [VariableReference(ArrayList array, []), Expression((ArrayList) obj, [])])    VariableReference(ArrayList array, [])    Expression((ArrayList) obj, [])  Statement(// Parcelables, [])  Statement(only look inside for Parcelables, [])  MethodCall(if (!array.isEmpty() && (array.get(0) instanceof Parcelable)), [VariableReference(if (!array, []), Expression() && (array.get(0) instanceof Parcelable), [])])    VariableReference(if (!array, [])    Expression() && (array.get(0) instanceof Parcelable), [])  AssignmentExpression(=, [VariableReference(for (int n, []), Expression(array.size() - 1, [])])    VariableReference(for (int n, [])    Expression(array.size() - 1, [])  AssignmentExpression(=, [VariableReference(n >, []), Expression(0, [])])    VariableReference(n >, [])    Expression(0, [])  Statement(n--) {, [])  AssignmentExpression(=, [VariableReference(Parcelable p, []), Expression((Parcelable) array.get(n), [])])    VariableReference(Parcelable p, [])    Expression((Parcelable) array.get(n), [])  AssignmentExpression(=, [VariableReference(if (p !, []), Expression(null && ((p.describeContents() & Parcelable.CONTENTS_FILE_DESCRIPTOR) !, [])])    VariableReference(if (p !, [])    Expression(null && ((p.describeContents() & Parcelable.CONTENTS_FILE_DESCRIPTOR) !, [])  AssignmentExpression(=, [VariableReference(fdFound, []), Expression(true, [])])    VariableReference(fdFound, [])    Expression(true, [])  Statement(break, [])  Statement(}, [])  Statement(}, [])  Statement(}, [])  Statement(}, [])  Statement(}, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(mHasFds, []), Expression(fdFound, [])])    VariableReference(mHasFds, [])    Expression(fdFound, [])  AssignmentExpression(=, [VariableReference(mFdsKnown, []), Expression(true, [])])    VariableReference(mFdsKnown, [])    Expression(true, [])  Statement(}, [])  Statement(return mHasFds, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(if (!mFdsKnown) {, []), Statement(// keep going until we find one or run out of data, []), AssignmentExpression(=, [VariableReference(boolean fdFound, []), Expression(false, [])]), AssignmentExpression(=, [VariableReference(if (mParcelledData !, []), Expression(null) {, [])]), MethodCall(if (mParcelledData.hasFileDescriptors()), [VariableReference(if (mParcelledData, []), Expression(), [])]), AssignmentExpression(=, [VariableReference(fdFound, []), Expression(true, [])]), Statement(}, []), Statement(} else {, []), Statement(// It's been unparcelled, so we need to walk the map, []), AssignmentExpression(=, [VariableReference(for (int i, []), Expression(mMap.size() - 1, [])]), AssignmentExpression(=, [VariableReference(i >, []), Expression(0, [])]), Statement(i--) {, []), AssignmentExpression(=, [VariableReference(Object obj, []), Expression(mMap.valueAt(i), [])]), Statement(if (obj instanceof Parcelable) {, []), AssignmentExpression(=, [VariableReference(if ((((Parcelable) obj).describeContents() & Parcelable.CONTENTS_FILE_DESCRIPTOR) !, []), Expression(0) {, [])]), AssignmentExpression(=, [VariableReference(fdFound, []), Expression(true, [])]), Statement(break, []), Statement(}, []), Statement(} else if (obj instanceof Parcelable[]) {, []), AssignmentExpression(=, [VariableReference(Parcelable[] array, []), Expression((Parcelable[]) obj, [])]), AssignmentExpression(=, [VariableReference(for (int n, []), Expression(array.length - 1, [])]), AssignmentExpression(=, [VariableReference(n >, []), Expression(0, [])]), Statement(n--) {, []), AssignmentExpression(=, [VariableReference(Parcelable p, []), Expression(array[n], [])]), AssignmentExpression(=, [VariableReference(if (p !, []), Expression(null && ((p.describeContents() & Parcelable.CONTENTS_FILE_DESCRIPTOR) !, [])]), AssignmentExpression(=, [VariableReference(fdFound, []), Expression(true, [])]), Statement(break, []), Statement(}, []), Statement(}, []), Statement(} else if (obj instanceof SparseArray) {, []), AssignmentExpression(=, [VariableReference(SparseArray<? extends Parcelable> array, []), Expression((SparseArray<? extends Parcelable>) obj, [])]), AssignmentExpression(=, [VariableReference(for (int n, []), Expression(array.size() - 1, [])]), AssignmentExpression(=, [VariableReference(n >, []), Expression(0, [])]), Statement(n--) {, []), AssignmentExpression(=, [VariableReference(Parcelable p, []), Expression(array.valueAt(n), [])]), AssignmentExpression(=, [VariableReference(if (p !, []), Expression(null && (p.describeContents() & Parcelable.CONTENTS_FILE_DESCRIPTOR) !, [])]), AssignmentExpression(=, [VariableReference(fdFound, []), Expression(true, [])]), Statement(break, []), Statement(}, []), Statement(}, []), Statement(} else if (obj instanceof ArrayList) {, []), AssignmentExpression(=, [VariableReference(ArrayList array, []), Expression((ArrayList) obj, [])]), Statement(// Parcelables, []), Statement(only look inside for Parcelables, []), MethodCall(if (!array.isEmpty() && (array.get(0) instanceof Parcelable)), [VariableReference(if (!array, []), Expression() && (array.get(0) instanceof Parcelable), [])]), AssignmentExpression(=, [VariableReference(for (int n, []), Expression(array.size() - 1, [])]), AssignmentExpression(=, [VariableReference(n >, []), Expression(0, [])]), Statement(n--) {, []), AssignmentExpression(=, [VariableReference(Parcelable p, []), Expression((Parcelable) array.get(n), [])]), AssignmentExpression(=, [VariableReference(if (p !, []), Expression(null && ((p.describeContents() & Parcelable.CONTENTS_FILE_DESCRIPTOR) !, [])]), AssignmentExpression(=, [VariableReference(fdFound, []), Expression(true, [])]), Statement(break, []), Statement(}, []), Statement(}, []), Statement(}, []), Statement(}, []), Statement(}, []), Statement(}, []), AssignmentExpression(=, [VariableReference(mHasFds, []), Expression(fdFound, [])]), AssignmentExpression(=, [VariableReference(mFdsKnown, []), Expression(true, [])]), Statement(}, []), Statement(return mHasFds, []), Statement(}, [])])  Statement({, [])  Statement(if (!mFdsKnown) {, [])  Statement(// keep going until we find one or run out of data, [])  AssignmentExpression(=, [VariableReference(boolean fdFound, []), Expression(false, [])])    VariableReference(boolean fdFound, [])    Expression(false, [])  AssignmentExpression(=, [VariableReference(if (mParcelledData !, []), Expression(null) {, [])])    VariableReference(if (mParcelledData !, [])    Expression(null) {, [])  MethodCall(if (mParcelledData.hasFileDescriptors()), [VariableReference(if (mParcelledData, []), Expression(), [])])    VariableReference(if (mParcelledData, [])    Expression(), [])  AssignmentExpression(=, [VariableReference(fdFound, []), Expression(true, [])])    VariableReference(fdFound, [])    Expression(true, [])  Statement(}, [])  Statement(} else {, [])  Statement(// It's been unparcelled, so we need to walk the map, [])  AssignmentExpression(=, [VariableReference(for (int i, []), Expression(mMap.size() - 1, [])])    VariableReference(for (int i, [])    Expression(mMap.size() - 1, [])  AssignmentExpression(=, [VariableReference(i >, []), Expression(0, [])])    VariableReference(i >, [])    Expression(0, [])  Statement(i--) {, [])  AssignmentExpression(=, [VariableReference(Object obj, []), Expression(mMap.valueAt(i), [])])    VariableReference(Object obj, [])    Expression(mMap.valueAt(i), [])  Statement(if (obj instanceof Parcelable) {, [])  AssignmentExpression(=, [VariableReference(if ((((Parcelable) obj).describeContents() & Parcelable.CONTENTS_FILE_DESCRIPTOR) !, []), Expression(0) {, [])])    VariableReference(if ((((Parcelable) obj).describeContents() & Parcelable.CONTENTS_FILE_DESCRIPTOR) !, [])    Expression(0) {, [])  AssignmentExpression(=, [VariableReference(fdFound, []), Expression(true, [])])    VariableReference(fdFound, [])    Expression(true, [])  Statement(break, [])  Statement(}, [])  Statement(} else if (obj instanceof Parcelable[]) {, [])  AssignmentExpression(=, [VariableReference(Parcelable[] array, []), Expression((Parcelable[]) obj, [])])    VariableReference(Parcelable[] array, [])    Expression((Parcelable[]) obj, [])  AssignmentExpression(=, [VariableReference(for (int n, []), Expression(array.length - 1, [])])    VariableReference(for (int n, [])    Expression(array.length - 1, [])  AssignmentExpression(=, [VariableReference(n >, []), Expression(0, [])])    VariableReference(n >, [])    Expression(0, [])  Statement(n--) {, [])  AssignmentExpression(=, [VariableReference(Parcelable p, []), Expression(array[n], [])])    VariableReference(Parcelable p, [])    Expression(array[n], [])  AssignmentExpression(=, [VariableReference(if (p !, []), Expression(null && ((p.describeContents() & Parcelable.CONTENTS_FILE_DESCRIPTOR) !, [])])    VariableReference(if (p !, [])    Expression(null && ((p.describeContents() & Parcelable.CONTENTS_FILE_DESCRIPTOR) !, [])  AssignmentExpression(=, [VariableReference(fdFound, []), Expression(true, [])])    VariableReference(fdFound, [])    Expression(true, [])  Statement(break, [])  Statement(}, [])  Statement(}, [])  Statement(} else if (obj instanceof SparseArray) {, [])  AssignmentExpression(=, [VariableReference(SparseArray<? extends Parcelable> array, []), Expression((SparseArray<? extends Parcelable>) obj, [])])    VariableReference(SparseArray<? extends Parcelable> array, [])    Expression((SparseArray<? extends Parcelable>) obj, [])  AssignmentExpression(=, [VariableReference(for (int n, []), Expression(array.size() - 1, [])])    VariableReference(for (int n, [])    Expression(array.size() - 1, [])  AssignmentExpression(=, [VariableReference(n >, []), Expression(0, [])])    VariableReference(n >, [])    Expression(0, [])  Statement(n--) {, [])  AssignmentExpression(=, [VariableReference(Parcelable p, []), Expression(array.valueAt(n), [])])    VariableReference(Parcelable p, [])    Expression(array.valueAt(n), [])  AssignmentExpression(=, [VariableReference(if (p !, []), Expression(null && (p.describeContents() & Parcelable.CONTENTS_FILE_DESCRIPTOR) !, [])])    VariableReference(if (p !, [])    Expression(null && (p.describeContents() & Parcelable.CONTENTS_FILE_DESCRIPTOR) !, [])  AssignmentExpression(=, [VariableReference(fdFound, []), Expression(true, [])])    VariableReference(fdFound, [])    Expression(true, [])  Statement(break, [])  Statement(}, [])  Statement(}, [])  Statement(} else if (obj instanceof ArrayList) {, [])  AssignmentExpression(=, [VariableReference(ArrayList array, []), Expression((ArrayList) obj, [])])    VariableReference(ArrayList array, [])    Expression((ArrayList) obj, [])  Statement(// Parcelables, [])  Statement(only look inside for Parcelables, [])  MethodCall(if (!array.isEmpty() && (array.get(0) instanceof Parcelable)), [VariableReference(if (!array, []), Expression() && (array.get(0) instanceof Parcelable), [])])    VariableReference(if (!array, [])    Expression() && (array.get(0) instanceof Parcelable), [])  AssignmentExpression(=, [VariableReference(for (int n, []), Expression(array.size() - 1, [])])    VariableReference(for (int n, [])    Expression(array.size() - 1, [])  AssignmentExpression(=, [VariableReference(n >, []), Expression(0, [])])    VariableReference(n >, [])    Expression(0, [])  Statement(n--) {, [])  AssignmentExpression(=, [VariableReference(Parcelable p, []), Expression((Parcelable) array.get(n), [])])    VariableReference(Parcelable p, [])    Expression((Parcelable) array.get(n), [])  AssignmentExpression(=, [VariableReference(if (p !, []), Expression(null && ((p.describeContents() & Parcelable.CONTENTS_FILE_DESCRIPTOR) !, [])])    VariableReference(if (p !, [])    Expression(null && ((p.describeContents() & Parcelable.CONTENTS_FILE_DESCRIPTOR) !, [])  AssignmentExpression(=, [VariableReference(fdFound, []), Expression(true, [])])    VariableReference(fdFound, [])    Expression(true, [])  Statement(break, [])  Statement(}, [])  Statement(}, [])  Statement(}, [])  Statement(}, [])  Statement(}, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(mHasFds, []), Expression(fdFound, [])])    VariableReference(mHasFds, [])    Expression(fdFound, [])  AssignmentExpression(=, [VariableReference(mFdsKnown, []), Expression(true, [])])    VariableReference(mFdsKnown, [])    Expression(true, [])  Statement(}, [])  Statement(return mHasFds, [])  Statement(}, [])",1,"/**
 * Reports whether the bundle contains any parcelled file descriptors.
 */
","/**
 * Reports whether the bundle contains any parcelled file descriptors.
 */
",0,,,0,,,,"1,2","3,4",1,3,0,"In the AST nodes for the late version, within the else-if branches, the `if` conditions for statement assignments have changed. The type of array elements being checked within the for?loops have been modified to directly assign the element (`array[n]`) instead of redefining it as a `Parcelable`. This modify how it is checked whether a `Parcelable` element contains a file descriptor, with this minor structural change likely intended to optimize the checks and readability. No new return statements, exceptions are introduced or deleted.","Although changes to the control flow and assignments occurred, the logical behavior for file descriptor checking within different object types remains effectively similar. It does not introduce a potential for a differing return value or exception, thus no compatibility issue (CI) detected."
99,"<android.content.IntentFilter: void writeToParcel(Parcel,int)>",22,23,,,,"MethodDeclaration(method_body, [Statement({, []), MethodCall(dest.writeStringList(mActions), [VariableReference(dest, []), Expression(mActions, [])]), AssignmentExpression(=, [VariableReference(if (mCategories !, []), Expression(null) {, [])]), MethodCall(dest.writeInt(1), [VariableReference(dest, []), Expression(1, [])]), MethodCall(dest.writeStringList(mCategories), [VariableReference(dest, []), Expression(mCategories, [])]), Statement(} else {, []), MethodCall(dest.writeInt(0), [VariableReference(dest, []), Expression(0, [])]), Statement(}, []), AssignmentExpression(=, [VariableReference(if (mDataSchemes !, []), Expression(null) {, [])]), MethodCall(dest.writeInt(1), [VariableReference(dest, []), Expression(1, [])]), MethodCall(dest.writeStringList(mDataSchemes), [VariableReference(dest, []), Expression(mDataSchemes, [])]), Statement(} else {, []), MethodCall(dest.writeInt(0), [VariableReference(dest, []), Expression(0, [])]), Statement(}, []), AssignmentExpression(=, [VariableReference(if (mDataTypes !, []), Expression(null) {, [])]), MethodCall(dest.writeInt(1), [VariableReference(dest, []), Expression(1, [])]), MethodCall(dest.writeStringList(mDataTypes), [VariableReference(dest, []), Expression(mDataTypes, [])]), Statement(} else {, []), MethodCall(dest.writeInt(0), [VariableReference(dest, []), Expression(0, [])]), Statement(}, []), AssignmentExpression(=, [VariableReference(if (mDataSchemeSpecificParts !, []), Expression(null) {, [])]), AssignmentExpression(=, [VariableReference(final int N, []), Expression(mDataSchemeSpecificParts.size(), [])]), MethodCall(dest.writeInt(N), [VariableReference(dest, []), Expression(N, [])]), AssignmentExpression(=, [VariableReference(for (int i, []), Expression(0, [])]), Statement(i < N, []), Statement(i++) {, []), MethodCall(mDataSchemeSpecificParts.get(i).writeToParcel(dest, flags), [VariableReference(mDataSchemeSpecificParts, []), Expression(i).writeToParcel(dest, []), Expression(flags, [])]), Statement(}, []), Statement(} else {, []), MethodCall(dest.writeInt(0), [VariableReference(dest, []), Expression(0, [])]), Statement(}, []), AssignmentExpression(=, [VariableReference(if (mDataAuthorities !, []), Expression(null) {, [])]), AssignmentExpression(=, [VariableReference(final int N, []), Expression(mDataAuthorities.size(), [])]), MethodCall(dest.writeInt(N), [VariableReference(dest, []), Expression(N, [])]), AssignmentExpression(=, [VariableReference(for (int i, []), Expression(0, [])]), Statement(i < N, []), Statement(i++) {, []), MethodCall(mDataAuthorities.get(i).writeToParcel(dest), [VariableReference(mDataAuthorities, []), Expression(i).writeToParcel(dest, [])]), Statement(}, []), Statement(} else {, []), MethodCall(dest.writeInt(0), [VariableReference(dest, []), Expression(0, [])]), Statement(}, []), AssignmentExpression(=, [VariableReference(if (mDataPaths !, []), Expression(null) {, [])]), AssignmentExpression(=, [VariableReference(final int N, []), Expression(mDataPaths.size(), [])]), MethodCall(dest.writeInt(N), [VariableReference(dest, []), Expression(N, [])]), AssignmentExpression(=, [VariableReference(for (int i, []), Expression(0, [])]), Statement(i < N, []), Statement(i++) {, []), MethodCall(mDataPaths.get(i).writeToParcel(dest, flags), [VariableReference(mDataPaths, []), Expression(i).writeToParcel(dest, []), Expression(flags, [])]), Statement(}, []), Statement(} else {, []), MethodCall(dest.writeInt(0), [VariableReference(dest, []), Expression(0, [])]), Statement(}, []), MethodCall(dest.writeInt(mPriority), [VariableReference(dest, []), Expression(mPriority, [])]), MethodCall(dest.writeInt(mHasPartialTypes ? 1 : 0), [VariableReference(dest, []), Expression(mHasPartialTypes ? 1 : 0, [])]), Statement(}, [])])  Statement({, [])  MethodCall(dest.writeStringList(mActions), [VariableReference(dest, []), Expression(mActions, [])])    VariableReference(dest, [])    Expression(mActions, [])  AssignmentExpression(=, [VariableReference(if (mCategories !, []), Expression(null) {, [])])    VariableReference(if (mCategories !, [])    Expression(null) {, [])  MethodCall(dest.writeInt(1), [VariableReference(dest, []), Expression(1, [])])    VariableReference(dest, [])    Expression(1, [])  MethodCall(dest.writeStringList(mCategories), [VariableReference(dest, []), Expression(mCategories, [])])    VariableReference(dest, [])    Expression(mCategories, [])  Statement(} else {, [])  MethodCall(dest.writeInt(0), [VariableReference(dest, []), Expression(0, [])])    VariableReference(dest, [])    Expression(0, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(if (mDataSchemes !, []), Expression(null) {, [])])    VariableReference(if (mDataSchemes !, [])    Expression(null) {, [])  MethodCall(dest.writeInt(1), [VariableReference(dest, []), Expression(1, [])])    VariableReference(dest, [])    Expression(1, [])  MethodCall(dest.writeStringList(mDataSchemes), [VariableReference(dest, []), Expression(mDataSchemes, [])])    VariableReference(dest, [])    Expression(mDataSchemes, [])  Statement(} else {, [])  MethodCall(dest.writeInt(0), [VariableReference(dest, []), Expression(0, [])])    VariableReference(dest, [])    Expression(0, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(if (mDataTypes !, []), Expression(null) {, [])])    VariableReference(if (mDataTypes !, [])    Expression(null) {, [])  MethodCall(dest.writeInt(1), [VariableReference(dest, []), Expression(1, [])])    VariableReference(dest, [])    Expression(1, [])  MethodCall(dest.writeStringList(mDataTypes), [VariableReference(dest, []), Expression(mDataTypes, [])])    VariableReference(dest, [])    Expression(mDataTypes, [])  Statement(} else {, [])  MethodCall(dest.writeInt(0), [VariableReference(dest, []), Expression(0, [])])    VariableReference(dest, [])    Expression(0, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(if (mDataSchemeSpecificParts !, []), Expression(null) {, [])])    VariableReference(if (mDataSchemeSpecificParts !, [])    Expression(null) {, [])  AssignmentExpression(=, [VariableReference(final int N, []), Expression(mDataSchemeSpecificParts.size(), [])])    VariableReference(final int N, [])    Expression(mDataSchemeSpecificParts.size(), [])  MethodCall(dest.writeInt(N), [VariableReference(dest, []), Expression(N, [])])    VariableReference(dest, [])    Expression(N, [])  AssignmentExpression(=, [VariableReference(for (int i, []), Expression(0, [])])    VariableReference(for (int i, [])    Expression(0, [])  Statement(i < N, [])  Statement(i++) {, [])  MethodCall(mDataSchemeSpecificParts.get(i).writeToParcel(dest, flags), [VariableReference(mDataSchemeSpecificParts, []), Expression(i).writeToParcel(dest, []), Expression(flags, [])])    VariableReference(mDataSchemeSpecificParts, [])    Expression(i).writeToParcel(dest, [])    Expression(flags, [])  Statement(}, [])  Statement(} else {, [])  MethodCall(dest.writeInt(0), [VariableReference(dest, []), Expression(0, [])])    VariableReference(dest, [])    Expression(0, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(if (mDataAuthorities !, []), Expression(null) {, [])])    VariableReference(if (mDataAuthorities !, [])    Expression(null) {, [])  AssignmentExpression(=, [VariableReference(final int N, []), Expression(mDataAuthorities.size(), [])])    VariableReference(final int N, [])    Expression(mDataAuthorities.size(), [])  MethodCall(dest.writeInt(N), [VariableReference(dest, []), Expression(N, [])])    VariableReference(dest, [])    Expression(N, [])  AssignmentExpression(=, [VariableReference(for (int i, []), Expression(0, [])])    VariableReference(for (int i, [])    Expression(0, [])  Statement(i < N, [])  Statement(i++) {, [])  MethodCall(mDataAuthorities.get(i).writeToParcel(dest), [VariableReference(mDataAuthorities, []), Expression(i).writeToParcel(dest, [])])    VariableReference(mDataAuthorities, [])    Expression(i).writeToParcel(dest, [])  Statement(}, [])  Statement(} else {, [])  MethodCall(dest.writeInt(0), [VariableReference(dest, []), Expression(0, [])])    VariableReference(dest, [])    Expression(0, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(if (mDataPaths !, []), Expression(null) {, [])])    VariableReference(if (mDataPaths !, [])    Expression(null) {, [])  AssignmentExpression(=, [VariableReference(final int N, []), Expression(mDataPaths.size(), [])])    VariableReference(final int N, [])    Expression(mDataPaths.size(), [])  MethodCall(dest.writeInt(N), [VariableReference(dest, []), Expression(N, [])])    VariableReference(dest, [])    Expression(N, [])  AssignmentExpression(=, [VariableReference(for (int i, []), Expression(0, [])])    VariableReference(for (int i, [])    Expression(0, [])  Statement(i < N, [])  Statement(i++) {, [])  MethodCall(mDataPaths.get(i).writeToParcel(dest, flags), [VariableReference(mDataPaths, []), Expression(i).writeToParcel(dest, []), Expression(flags, [])])    VariableReference(mDataPaths, [])    Expression(i).writeToParcel(dest, [])    Expression(flags, [])  Statement(}, [])  Statement(} else {, [])  MethodCall(dest.writeInt(0), [VariableReference(dest, []), Expression(0, [])])    VariableReference(dest, [])    Expression(0, [])  Statement(}, [])  MethodCall(dest.writeInt(mPriority), [VariableReference(dest, []), Expression(mPriority, [])])    VariableReference(dest, [])    Expression(mPriority, [])  MethodCall(dest.writeInt(mHasPartialTypes ? 1 : 0), [VariableReference(dest, []), Expression(mHasPartialTypes ? 1 : 0, [])])    VariableReference(dest, [])    Expression(mHasPartialTypes ? 1 : 0, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), MethodCall(dest.writeStringList(mActions), [VariableReference(dest, []), Expression(mActions, [])]), AssignmentExpression(=, [VariableReference(if (mCategories !, []), Expression(null) {, [])]), MethodCall(dest.writeInt(1), [VariableReference(dest, []), Expression(1, [])]), MethodCall(dest.writeStringList(mCategories), [VariableReference(dest, []), Expression(mCategories, [])]), Statement(} else {, []), MethodCall(dest.writeInt(0), [VariableReference(dest, []), Expression(0, [])]), Statement(}, []), AssignmentExpression(=, [VariableReference(if (mDataSchemes !, []), Expression(null) {, [])]), MethodCall(dest.writeInt(1), [VariableReference(dest, []), Expression(1, [])]), MethodCall(dest.writeStringList(mDataSchemes), [VariableReference(dest, []), Expression(mDataSchemes, [])]), Statement(} else {, []), MethodCall(dest.writeInt(0), [VariableReference(dest, []), Expression(0, [])]), Statement(}, []), AssignmentExpression(=, [VariableReference(if (mDataTypes !, []), Expression(null) {, [])]), MethodCall(dest.writeInt(1), [VariableReference(dest, []), Expression(1, [])]), MethodCall(dest.writeStringList(mDataTypes), [VariableReference(dest, []), Expression(mDataTypes, [])]), Statement(} else {, []), MethodCall(dest.writeInt(0), [VariableReference(dest, []), Expression(0, [])]), Statement(}, []), AssignmentExpression(=, [VariableReference(if (mDataSchemeSpecificParts !, []), Expression(null) {, [])]), AssignmentExpression(=, [VariableReference(final int N, []), Expression(mDataSchemeSpecificParts.size(), [])]), MethodCall(dest.writeInt(N), [VariableReference(dest, []), Expression(N, [])]), AssignmentExpression(=, [VariableReference(for (int i, []), Expression(0, [])]), Statement(i < N, []), Statement(i++) {, []), MethodCall(mDataSchemeSpecificParts.get(i).writeToParcel(dest, flags), [VariableReference(mDataSchemeSpecificParts, []), Expression(i).writeToParcel(dest, []), Expression(flags, [])]), Statement(}, []), Statement(} else {, []), MethodCall(dest.writeInt(0), [VariableReference(dest, []), Expression(0, [])]), Statement(}, []), AssignmentExpression(=, [VariableReference(if (mDataAuthorities !, []), Expression(null) {, [])]), AssignmentExpression(=, [VariableReference(final int N, []), Expression(mDataAuthorities.size(), [])]), MethodCall(dest.writeInt(N), [VariableReference(dest, []), Expression(N, [])]), AssignmentExpression(=, [VariableReference(for (int i, []), Expression(0, [])]), Statement(i < N, []), Statement(i++) {, []), MethodCall(mDataAuthorities.get(i).writeToParcel(dest), [VariableReference(mDataAuthorities, []), Expression(i).writeToParcel(dest, [])]), Statement(}, []), Statement(} else {, []), MethodCall(dest.writeInt(0), [VariableReference(dest, []), Expression(0, [])]), Statement(}, []), AssignmentExpression(=, [VariableReference(if (mDataPaths !, []), Expression(null) {, [])]), AssignmentExpression(=, [VariableReference(final int N, []), Expression(mDataPaths.size(), [])]), MethodCall(dest.writeInt(N), [VariableReference(dest, []), Expression(N, [])]), AssignmentExpression(=, [VariableReference(for (int i, []), Expression(0, [])]), Statement(i < N, []), Statement(i++) {, []), MethodCall(mDataPaths.get(i).writeToParcel(dest, flags), [VariableReference(mDataPaths, []), Expression(i).writeToParcel(dest, []), Expression(flags, [])]), Statement(}, []), Statement(} else {, []), MethodCall(dest.writeInt(0), [VariableReference(dest, []), Expression(0, [])]), Statement(}, []), MethodCall(dest.writeInt(mPriority), [VariableReference(dest, []), Expression(mPriority, [])]), MethodCall(dest.writeInt(mHasPartialTypes ? 1 : 0), [VariableReference(dest, []), Expression(mHasPartialTypes ? 1 : 0, [])]), MethodCall(dest.writeInt(getAutoVerify() ? 1 : 0), [VariableReference(dest, []), Expression(getAutoVerify() ? 1 : 0, [])]), Statement(}, [])])  Statement({, [])  MethodCall(dest.writeStringList(mActions), [VariableReference(dest, []), Expression(mActions, [])])    VariableReference(dest, [])    Expression(mActions, [])  AssignmentExpression(=, [VariableReference(if (mCategories !, []), Expression(null) {, [])])    VariableReference(if (mCategories !, [])    Expression(null) {, [])  MethodCall(dest.writeInt(1), [VariableReference(dest, []), Expression(1, [])])    VariableReference(dest, [])    Expression(1, [])  MethodCall(dest.writeStringList(mCategories), [VariableReference(dest, []), Expression(mCategories, [])])    VariableReference(dest, [])    Expression(mCategories, [])  Statement(} else {, [])  MethodCall(dest.writeInt(0), [VariableReference(dest, []), Expression(0, [])])    VariableReference(dest, [])    Expression(0, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(if (mDataSchemes !, []), Expression(null) {, [])])    VariableReference(if (mDataSchemes !, [])    Expression(null) {, [])  MethodCall(dest.writeInt(1), [VariableReference(dest, []), Expression(1, [])])    VariableReference(dest, [])    Expression(1, [])  MethodCall(dest.writeStringList(mDataSchemes), [VariableReference(dest, []), Expression(mDataSchemes, [])])    VariableReference(dest, [])    Expression(mDataSchemes, [])  Statement(} else {, [])  MethodCall(dest.writeInt(0), [VariableReference(dest, []), Expression(0, [])])    VariableReference(dest, [])    Expression(0, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(if (mDataTypes !, []), Expression(null) {, [])])    VariableReference(if (mDataTypes !, [])    Expression(null) {, [])  MethodCall(dest.writeInt(1), [VariableReference(dest, []), Expression(1, [])])    VariableReference(dest, [])    Expression(1, [])  MethodCall(dest.writeStringList(mDataTypes), [VariableReference(dest, []), Expression(mDataTypes, [])])    VariableReference(dest, [])    Expression(mDataTypes, [])  Statement(} else {, [])  MethodCall(dest.writeInt(0), [VariableReference(dest, []), Expression(0, [])])    VariableReference(dest, [])    Expression(0, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(if (mDataSchemeSpecificParts !, []), Expression(null) {, [])])    VariableReference(if (mDataSchemeSpecificParts !, [])    Expression(null) {, [])  AssignmentExpression(=, [VariableReference(final int N, []), Expression(mDataSchemeSpecificParts.size(), [])])    VariableReference(final int N, [])    Expression(mDataSchemeSpecificParts.size(), [])  MethodCall(dest.writeInt(N), [VariableReference(dest, []), Expression(N, [])])    VariableReference(dest, [])    Expression(N, [])  AssignmentExpression(=, [VariableReference(for (int i, []), Expression(0, [])])    VariableReference(for (int i, [])    Expression(0, [])  Statement(i < N, [])  Statement(i++) {, [])  MethodCall(mDataSchemeSpecificParts.get(i).writeToParcel(dest, flags), [VariableReference(mDataSchemeSpecificParts, []), Expression(i).writeToParcel(dest, []), Expression(flags, [])])    VariableReference(mDataSchemeSpecificParts, [])    Expression(i).writeToParcel(dest, [])    Expression(flags, [])  Statement(}, [])  Statement(} else {, [])  MethodCall(dest.writeInt(0), [VariableReference(dest, []), Expression(0, [])])    VariableReference(dest, [])    Expression(0, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(if (mDataAuthorities !, []), Expression(null) {, [])])    VariableReference(if (mDataAuthorities !, [])    Expression(null) {, [])  AssignmentExpression(=, [VariableReference(final int N, []), Expression(mDataAuthorities.size(), [])])    VariableReference(final int N, [])    Expression(mDataAuthorities.size(), [])  MethodCall(dest.writeInt(N), [VariableReference(dest, []), Expression(N, [])])    VariableReference(dest, [])    Expression(N, [])  AssignmentExpression(=, [VariableReference(for (int i, []), Expression(0, [])])    VariableReference(for (int i, [])    Expression(0, [])  Statement(i < N, [])  Statement(i++) {, [])  MethodCall(mDataAuthorities.get(i).writeToParcel(dest), [VariableReference(mDataAuthorities, []), Expression(i).writeToParcel(dest, [])])    VariableReference(mDataAuthorities, [])    Expression(i).writeToParcel(dest, [])  Statement(}, [])  Statement(} else {, [])  MethodCall(dest.writeInt(0), [VariableReference(dest, []), Expression(0, [])])    VariableReference(dest, [])    Expression(0, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(if (mDataPaths !, []), Expression(null) {, [])])    VariableReference(if (mDataPaths !, [])    Expression(null) {, [])  AssignmentExpression(=, [VariableReference(final int N, []), Expression(mDataPaths.size(), [])])    VariableReference(final int N, [])    Expression(mDataPaths.size(), [])  MethodCall(dest.writeInt(N), [VariableReference(dest, []), Expression(N, [])])    VariableReference(dest, [])    Expression(N, [])  AssignmentExpression(=, [VariableReference(for (int i, []), Expression(0, [])])    VariableReference(for (int i, [])    Expression(0, [])  Statement(i < N, [])  Statement(i++) {, [])  MethodCall(mDataPaths.get(i).writeToParcel(dest, flags), [VariableReference(mDataPaths, []), Expression(i).writeToParcel(dest, []), Expression(flags, [])])    VariableReference(mDataPaths, [])    Expression(i).writeToParcel(dest, [])    Expression(flags, [])  Statement(}, [])  Statement(} else {, [])  MethodCall(dest.writeInt(0), [VariableReference(dest, []), Expression(0, [])])    VariableReference(dest, [])    Expression(0, [])  Statement(}, [])  MethodCall(dest.writeInt(mPriority), [VariableReference(dest, []), Expression(mPriority, [])])    VariableReference(dest, [])    Expression(mPriority, [])  MethodCall(dest.writeInt(mHasPartialTypes ? 1 : 0), [VariableReference(dest, []), Expression(mHasPartialTypes ? 1 : 0, [])])    VariableReference(dest, [])    Expression(mHasPartialTypes ? 1 : 0, [])  MethodCall(dest.writeInt(getAutoVerify() ? 1 : 0), [VariableReference(dest, []), Expression(getAutoVerify() ? 1 : 0, [])])    VariableReference(dest, [])    Expression(getAutoVerify() ? 1 : 0, [])  Statement(}, [])",1,,,0,,,0,,,,1,"1,4",1,4,0,"The only addition in the late version is `dest.writeInt(getAutoVerify() ? 1 : 0);`. As this addition doesn't change any return statement, exception handling statement, or control dependency statement, the code change type is 4.","Since this added statement does not affect return values or exception handling, there is no compatibility issue, and the CI type is 0."
100,<android.content.res.TypedArray: Resources getResources()>,22,23,,,,"MethodDeclaration(method_body, [Statement({, []), Statement(if (mRecycled) {, []), Statement(throw new RuntimeException(""Cannot make calls to a recycled instance!""), []), Statement(}, []), Statement(return mResources, []), Statement(}, [])])  Statement({, [])  Statement(if (mRecycled) {, [])  Statement(throw new RuntimeException(""Cannot make calls to a recycled instance!""), [])  Statement(}, [])  Statement(return mResources, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(if (mRecycled) {, []), Statement(throw new RuntimeException(""Cannot make calls to a recycled instance!""), []), Statement(}, []), Statement(return mResources, []), Statement(}, [])])  Statement({, [])  Statement(if (mRecycled) {, [])  Statement(throw new RuntimeException(""Cannot make calls to a recycled instance!""), [])  Statement(}, [])  Statement(return mResources, [])  Statement(}, [])",0,"/**
 * Return the Resources object this array was loaded from.
 */
","/**
 * Returns the Resources object this array was loaded from.
 *
 * @throws RuntimeException if the TypedArray has already been recycled.
 */
",1,,,0,,,,0,0,0,0,0,"There are no changes between the early and late implementations. The changes are only present in the comments, where an additional detail about throwing a `RuntimeException` if the `TypedArray` has already been recycled has been added. No code logic has been altered.","Since there are no changes in the code logic or implementation itself, there is no Compatibility Issue. The only change is in the comments, which does not affect the API's behavior."
101,<android.widget.TimePicker: boolean is24HourView()>,22,23,,,,"MethodDeclaration(method_body, [Statement({, []), MethodCall(return mDelegate.is24HourView(), [VariableReference(return mDelegate, []), Expression(, [])]), Statement(}, [])])  Statement({, [])  MethodCall(return mDelegate.is24HourView(), [VariableReference(return mDelegate, []), Expression(, [])])    VariableReference(return mDelegate, [])    Expression(, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), MethodCall(return mDelegate.is24HourView(), [VariableReference(return mDelegate, []), Expression(, [])]), Statement(}, [])])  Statement({, [])  MethodCall(return mDelegate.is24HourView(), [VariableReference(return mDelegate, []), Expression(, [])])    VariableReference(return mDelegate, [])    Expression(, [])  Statement(}, [])",0,"/**
 * @return true if this is in 24 hour view else false.
 */
","/**
 * @return {@code true} if this widget displays time in 24-hour mode,
 * {@code false} otherwise}
 * @see #setIs24HourView(Boolean)
 */
",1,,,0,,,,0,0,0,0,0,There is no change in the implementation of the method between the early and late versions. The method body and structure remain identical.,"Since the method implementation has not changed between versions, there is no potential for any compatibility issues. Therefore, the CI type is 0."
102,<android.net.DhcpStateMachine.StoppedState: boolean processMessage(Message)>,22,23,,,,"MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(boolean retValue, []), Expression(HANDLED, [])]), Statement(if (DBG), []), MethodCall(Log.d(TAG, getName() + message.toString() + ""\n""), [VariableReference(Log, []), Expression(TAG, []), Expression(getName() + message.toString() + ""\n"", [])]), Statement(case CMD_START_DHCP:, []), Statement(if (mRegisteredForPreDhcpNotification) {, []), Statement(/* Notify controller before starting DHCP */, []), MethodCall(mController.sendMessage(CMD_PRE_DHCP_ACTION), [VariableReference(mController, []), Expression(CMD_PRE_DHCP_ACTION, [])]), Statement(transitionTo(mWaitBeforeStartState), []), Statement(} else {, []), Statement(transitionTo(mRunningState), []), Statement(}, []), Statement(}, []), Statement(break, []), Statement(case CMD_STOP_DHCP:, []), Statement(// ignore, []), Statement(break, []), Statement(default:, []), AssignmentExpression(=, [VariableReference(retValue, []), Expression(NOT_HANDLED, [])]), Statement(break, []), Statement(}, []), Statement(return retValue, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(boolean retValue, []), Expression(HANDLED, [])])    VariableReference(boolean retValue, [])    Expression(HANDLED, [])  Statement(if (DBG), [])  MethodCall(Log.d(TAG, getName() + message.toString() + ""\n""), [VariableReference(Log, []), Expression(TAG, []), Expression(getName() + message.toString() + ""\n"", [])])    VariableReference(Log, [])    Expression(TAG, [])    Expression(getName() + message.toString() + ""\n"", [])  Statement(case CMD_START_DHCP:, [])  Statement(if (mRegisteredForPreDhcpNotification) {, [])  Statement(/* Notify controller before starting DHCP */, [])  MethodCall(mController.sendMessage(CMD_PRE_DHCP_ACTION), [VariableReference(mController, []), Expression(CMD_PRE_DHCP_ACTION, [])])    VariableReference(mController, [])    Expression(CMD_PRE_DHCP_ACTION, [])  Statement(transitionTo(mWaitBeforeStartState), [])  Statement(} else {, [])  Statement(transitionTo(mRunningState), [])  Statement(}, [])  Statement(}, [])  Statement(break, [])  Statement(case CMD_STOP_DHCP:, [])  Statement(// ignore, [])  Statement(break, [])  Statement(default:, [])  AssignmentExpression(=, [VariableReference(retValue, []), Expression(NOT_HANDLED, [])])    VariableReference(retValue, [])    Expression(NOT_HANDLED, [])  Statement(break, [])  Statement(}, [])  Statement(return retValue, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(boolean retValue, []), Expression(HANDLED, [])]), Statement(if (DBG), []), MethodCall(Log.d(TAG, getName() + message.toString() + ""\n""), [VariableReference(Log, []), Expression(TAG, []), Expression(getName() + message.toString() + ""\n"", [])]), Statement(case CMD_START_DHCP:, []), Statement(if (mRegisteredForPreDhcpNotification) {, []), Statement(/* Notify controller before starting DHCP */, []), MethodCall(mController.sendMessage(CMD_PRE_DHCP_ACTION), [VariableReference(mController, []), Expression(CMD_PRE_DHCP_ACTION, [])]), Statement(transitionTo(mWaitBeforeStartState), []), Statement(} else {, []), Statement(if (runDhcpStart()) {, []), Statement(transitionTo(mRunningState), []), Statement(}, []), Statement(}, []), Statement(break, []), Statement(case CMD_STOP_DHCP:, []), Statement(// ignore, []), Statement(break, []), Statement(default:, []), AssignmentExpression(=, [VariableReference(retValue, []), Expression(NOT_HANDLED, [])]), Statement(break, []), Statement(}, []), Statement(return retValue, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(boolean retValue, []), Expression(HANDLED, [])])    VariableReference(boolean retValue, [])    Expression(HANDLED, [])  Statement(if (DBG), [])  MethodCall(Log.d(TAG, getName() + message.toString() + ""\n""), [VariableReference(Log, []), Expression(TAG, []), Expression(getName() + message.toString() + ""\n"", [])])    VariableReference(Log, [])    Expression(TAG, [])    Expression(getName() + message.toString() + ""\n"", [])  Statement(case CMD_START_DHCP:, [])  Statement(if (mRegisteredForPreDhcpNotification) {, [])  Statement(/* Notify controller before starting DHCP */, [])  MethodCall(mController.sendMessage(CMD_PRE_DHCP_ACTION), [VariableReference(mController, []), Expression(CMD_PRE_DHCP_ACTION, [])])    VariableReference(mController, [])    Expression(CMD_PRE_DHCP_ACTION, [])  Statement(transitionTo(mWaitBeforeStartState), [])  Statement(} else {, [])  Statement(if (runDhcpStart()) {, [])  Statement(transitionTo(mRunningState), [])  Statement(}, [])  Statement(}, [])  Statement(break, [])  Statement(case CMD_STOP_DHCP:, [])  Statement(// ignore, [])  Statement(break, [])  Statement(default:, [])  AssignmentExpression(=, [VariableReference(retValue, []), Expression(NOT_HANDLED, [])])    VariableReference(retValue, [])    Expression(NOT_HANDLED, [])  Statement(break, [])  Statement(}, [])  Statement(return retValue, [])  Statement(}, [])",1,,,0,[@Override],[@Override],0,,,,2,"3,5",1,"3,5",1,"The method body has an added conditional statement inside the else block: `if (runDhcpStart()) { transitionTo(mRunningState); }`. This alters the control flow and introduces a call to a potentially changing dependent API `runDhcpStart()`, so the change type is 3,5.","The added conditional statement and call to `runDhcpStart()` can affect the behavior of the `processMessage` method by potentially causing different return paths and outcomes, thus leading to a different returned value depending on the outcome of `runDhcpStart()`. Therefore, the CI type is 1."
103,<android.widget.ProgressBar: void setProgressDrawable(Drawable)>,23,24,,,,"MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(if (mProgressDrawable !, []), Expression(d) {, [])]), AssignmentExpression(=, [VariableReference(if (mProgressDrawable !, []), Expression(null) {, [])]), MethodCall(mProgressDrawable.setCallback(null), [VariableReference(mProgressDrawable, []), Expression(null, [])]), Statement(unscheduleDrawable(mProgressDrawable), []), Statement(}, []), AssignmentExpression(=, [VariableReference(mProgressDrawable, []), Expression(d, [])]), AssignmentExpression(=, [VariableReference(if (d !, []), Expression(null) {, [])]), MethodCall(d.setCallback(this), [VariableReference(d, []), Expression(this, [])]), MethodCall(d.setLayoutDirection(getLayoutDirection()), [VariableReference(d, []), Expression(getLayoutDirection(), [])]), MethodCall(if (d.isStateful()), [VariableReference(if (d, []), Expression(), [])]), MethodCall(d.setState(getDrawableState()), [VariableReference(d, []), Expression(getDrawableState(), [])]), Statement(}, []), Statement(// Make sure the ProgressBar is always tall enough, []), AssignmentExpression(=, [VariableReference(int drawableHeight, []), Expression(d.getMinimumHeight(), [])]), Statement(if (mMaxHeight < drawableHeight) {, []), AssignmentExpression(=, [VariableReference(mMaxHeight, []), Expression(drawableHeight, [])]), Statement(requestLayout(), []), Statement(}, []), Statement(applyProgressTints(), []), Statement(}, []), Statement(if (!mIndeterminate) {, []), AssignmentExpression(=, [VariableReference(mCurrentDrawable, []), Expression(d, [])]), Statement(postInvalidate(), []), Statement(}, []), Statement(updateDrawableBounds(getWidth(), getHeight()), []), Statement(updateDrawableState(), []), Statement(}, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(if (mProgressDrawable !, []), Expression(d) {, [])])    VariableReference(if (mProgressDrawable !, [])    Expression(d) {, [])  AssignmentExpression(=, [VariableReference(if (mProgressDrawable !, []), Expression(null) {, [])])    VariableReference(if (mProgressDrawable !, [])    Expression(null) {, [])  MethodCall(mProgressDrawable.setCallback(null), [VariableReference(mProgressDrawable, []), Expression(null, [])])    VariableReference(mProgressDrawable, [])    Expression(null, [])  Statement(unscheduleDrawable(mProgressDrawable), [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(mProgressDrawable, []), Expression(d, [])])    VariableReference(mProgressDrawable, [])    Expression(d, [])  AssignmentExpression(=, [VariableReference(if (d !, []), Expression(null) {, [])])    VariableReference(if (d !, [])    Expression(null) {, [])  MethodCall(d.setCallback(this), [VariableReference(d, []), Expression(this, [])])    VariableReference(d, [])    Expression(this, [])  MethodCall(d.setLayoutDirection(getLayoutDirection()), [VariableReference(d, []), Expression(getLayoutDirection(), [])])    VariableReference(d, [])    Expression(getLayoutDirection(), [])  MethodCall(if (d.isStateful()), [VariableReference(if (d, []), Expression(), [])])    VariableReference(if (d, [])    Expression(), [])  MethodCall(d.setState(getDrawableState()), [VariableReference(d, []), Expression(getDrawableState(), [])])    VariableReference(d, [])    Expression(getDrawableState(), [])  Statement(}, [])  Statement(// Make sure the ProgressBar is always tall enough, [])  AssignmentExpression(=, [VariableReference(int drawableHeight, []), Expression(d.getMinimumHeight(), [])])    VariableReference(int drawableHeight, [])    Expression(d.getMinimumHeight(), [])  Statement(if (mMaxHeight < drawableHeight) {, [])  AssignmentExpression(=, [VariableReference(mMaxHeight, []), Expression(drawableHeight, [])])    VariableReference(mMaxHeight, [])    Expression(drawableHeight, [])  Statement(requestLayout(), [])  Statement(}, [])  Statement(applyProgressTints(), [])  Statement(}, [])  Statement(if (!mIndeterminate) {, [])  AssignmentExpression(=, [VariableReference(mCurrentDrawable, []), Expression(d, [])])    VariableReference(mCurrentDrawable, [])    Expression(d, [])  Statement(postInvalidate(), [])  Statement(}, [])  Statement(updateDrawableBounds(getWidth(), getHeight()), [])  Statement(updateDrawableState(), [])  Statement(}, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(if (mProgressDrawable !, []), Expression(d) {, [])]), AssignmentExpression(=, [VariableReference(if (mProgressDrawable !, []), Expression(null) {, [])]), MethodCall(mProgressDrawable.setCallback(null), [VariableReference(mProgressDrawable, []), Expression(null, [])]), Statement(unscheduleDrawable(mProgressDrawable), []), Statement(}, []), AssignmentExpression(=, [VariableReference(mProgressDrawable, []), Expression(d, [])]), AssignmentExpression(=, [VariableReference(if (d !, []), Expression(null) {, [])]), MethodCall(d.setCallback(this), [VariableReference(d, []), Expression(this, [])]), MethodCall(d.setLayoutDirection(getLayoutDirection()), [VariableReference(d, []), Expression(getLayoutDirection(), [])]), MethodCall(if (d.isStateful()), [VariableReference(if (d, []), Expression(), [])]), MethodCall(d.setState(getDrawableState()), [VariableReference(d, []), Expression(getDrawableState(), [])]), Statement(}, []), Statement(// Make sure the ProgressBar is always tall enough, []), AssignmentExpression(=, [VariableReference(int drawableHeight, []), Expression(d.getMinimumHeight(), [])]), Statement(if (mMaxHeight < drawableHeight) {, []), AssignmentExpression(=, [VariableReference(mMaxHeight, []), Expression(drawableHeight, [])]), Statement(requestLayout(), []), Statement(}, []), Statement(applyProgressTints(), []), Statement(}, []), Statement(if (!mIndeterminate) {, []), Statement(swapCurrentDrawable(d), []), Statement(postInvalidate(), []), Statement(}, []), Statement(updateDrawableBounds(getWidth(), getHeight()), []), Statement(updateDrawableState(), []), Statement(}, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(if (mProgressDrawable !, []), Expression(d) {, [])])    VariableReference(if (mProgressDrawable !, [])    Expression(d) {, [])  AssignmentExpression(=, [VariableReference(if (mProgressDrawable !, []), Expression(null) {, [])])    VariableReference(if (mProgressDrawable !, [])    Expression(null) {, [])  MethodCall(mProgressDrawable.setCallback(null), [VariableReference(mProgressDrawable, []), Expression(null, [])])    VariableReference(mProgressDrawable, [])    Expression(null, [])  Statement(unscheduleDrawable(mProgressDrawable), [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(mProgressDrawable, []), Expression(d, [])])    VariableReference(mProgressDrawable, [])    Expression(d, [])  AssignmentExpression(=, [VariableReference(if (d !, []), Expression(null) {, [])])    VariableReference(if (d !, [])    Expression(null) {, [])  MethodCall(d.setCallback(this), [VariableReference(d, []), Expression(this, [])])    VariableReference(d, [])    Expression(this, [])  MethodCall(d.setLayoutDirection(getLayoutDirection()), [VariableReference(d, []), Expression(getLayoutDirection(), [])])    VariableReference(d, [])    Expression(getLayoutDirection(), [])  MethodCall(if (d.isStateful()), [VariableReference(if (d, []), Expression(), [])])    VariableReference(if (d, [])    Expression(), [])  MethodCall(d.setState(getDrawableState()), [VariableReference(d, []), Expression(getDrawableState(), [])])    VariableReference(d, [])    Expression(getDrawableState(), [])  Statement(}, [])  Statement(// Make sure the ProgressBar is always tall enough, [])  AssignmentExpression(=, [VariableReference(int drawableHeight, []), Expression(d.getMinimumHeight(), [])])    VariableReference(int drawableHeight, [])    Expression(d.getMinimumHeight(), [])  Statement(if (mMaxHeight < drawableHeight) {, [])  AssignmentExpression(=, [VariableReference(mMaxHeight, []), Expression(drawableHeight, [])])    VariableReference(mMaxHeight, [])    Expression(drawableHeight, [])  Statement(requestLayout(), [])  Statement(}, [])  Statement(applyProgressTints(), [])  Statement(}, [])  Statement(if (!mIndeterminate) {, [])  Statement(swapCurrentDrawable(d), [])  Statement(postInvalidate(), [])  Statement(}, [])  Statement(updateDrawableBounds(getWidth(), getHeight()), [])  Statement(updateDrawableState(), [])  Statement(}, [])  Statement(}, [])",1,"/**
 * Define the drawable used to draw the progress bar in progress mode.
 *
 * @param d the new drawable
 * @see #getProgressDrawable()
 * @see #setIndeterminate(boolean)
 */
","/**
 * Define the drawable used to draw the progress bar in progress mode.
 *
 * @param d the new drawable
 * @see #getProgressDrawable()
 * @see #setIndeterminate(boolean)
 */
",0,,,0,,,,"1,2","4,5",1,"3,4",0,"The control dependency has changed as the statement `swapCurrentDrawable(d)` replaces `mCurrentDrawable = d`. Additionally, some other statements unrelated to control dependency were also altered, so the change type is 3, 4.","Although changes were made to the implementation, these changes do not affect the return type or exception handling of the method. Therefore, no Compatibility Issue exists."
104,"<android.view.inputmethod.InputConnectionWrapper: boolean setComposingText(CharSequence,int)>",23,24,,,,"MethodDeclaration(method_body, [Statement({, []), MethodCall(return mTarget.setComposingText(text, newCursorPosition), [VariableReference(return mTarget, []), Expression(text, []), Expression(newCursorPosition, [])]), Statement(}, [])])  Statement({, [])  MethodCall(return mTarget.setComposingText(text, newCursorPosition), [VariableReference(return mTarget, []), Expression(text, []), Expression(newCursorPosition, [])])    VariableReference(return mTarget, [])    Expression(text, [])    Expression(newCursorPosition, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), MethodCall(return mTarget.setComposingText(text, newCursorPosition), [VariableReference(return mTarget, []), Expression(text, []), Expression(newCursorPosition, [])]), Statement(}, [])])  Statement({, [])  MethodCall(return mTarget.setComposingText(text, newCursorPosition), [VariableReference(return mTarget, []), Expression(text, []), Expression(newCursorPosition, [])])    VariableReference(return mTarget, [])    Expression(text, [])    Expression(newCursorPosition, [])  Statement(}, [])",0,,"/**
 * {@inheritDoc}
 * @throws NullPointerException if the target is {@code null}.
 */
",1,,,0,,,,0,0,0,2,2,"A new exception handling statement is introduced in the comment section (""@throws NullPointerException if the target is {@code null}""). While the actual implementation is unchanged, the comment now indicates that the method could throw a NullPointerException under certain conditions, which wasn't explicitly mentioned earlier. Thus, the code change type is 2.","Since the new version's comment indicates the potential for a new exception (NullPointerException), the CI type is 2."
105,<android.preference.PreferenceFragment: void onDestroyView()>,23,24,,,,"MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(mList, []), Expression(null, [])]), MethodCall(mHandler.removeCallbacks(mRequestFocus), [VariableReference(mHandler, []), Expression(mRequestFocus, [])]), MethodCall(mHandler.removeMessages(MSG_BIND_PREFERENCES), [VariableReference(mHandler, []), Expression(MSG_BIND_PREFERENCES, [])]), MethodCall(super.onDestroyView(), [VariableReference(super, []), Expression(, [])]), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(mList, []), Expression(null, [])])    VariableReference(mList, [])    Expression(null, [])  MethodCall(mHandler.removeCallbacks(mRequestFocus), [VariableReference(mHandler, []), Expression(mRequestFocus, [])])    VariableReference(mHandler, [])    Expression(mRequestFocus, [])  MethodCall(mHandler.removeMessages(MSG_BIND_PREFERENCES), [VariableReference(mHandler, []), Expression(MSG_BIND_PREFERENCES, [])])    VariableReference(mHandler, [])    Expression(MSG_BIND_PREFERENCES, [])  MethodCall(super.onDestroyView(), [VariableReference(super, []), Expression(, [])])    VariableReference(super, [])    Expression(, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(if (mList !, []), Expression(null) {, [])]), MethodCall(mList.setOnKeyListener(null), [VariableReference(mList, []), Expression(null, [])]), Statement(}, []), AssignmentExpression(=, [VariableReference(mList, []), Expression(null, [])]), MethodCall(mHandler.removeCallbacks(mRequestFocus), [VariableReference(mHandler, []), Expression(mRequestFocus, [])]), MethodCall(mHandler.removeMessages(MSG_BIND_PREFERENCES), [VariableReference(mHandler, []), Expression(MSG_BIND_PREFERENCES, [])]), MethodCall(super.onDestroyView(), [VariableReference(super, []), Expression(, [])]), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(if (mList !, []), Expression(null) {, [])])    VariableReference(if (mList !, [])    Expression(null) {, [])  MethodCall(mList.setOnKeyListener(null), [VariableReference(mList, []), Expression(null, [])])    VariableReference(mList, [])    Expression(null, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(mList, []), Expression(null, [])])    VariableReference(mList, [])    Expression(null, [])  MethodCall(mHandler.removeCallbacks(mRequestFocus), [VariableReference(mHandler, []), Expression(mRequestFocus, [])])    VariableReference(mHandler, [])    Expression(mRequestFocus, [])  MethodCall(mHandler.removeMessages(MSG_BIND_PREFERENCES), [VariableReference(mHandler, []), Expression(MSG_BIND_PREFERENCES, [])])    VariableReference(mHandler, [])    Expression(MSG_BIND_PREFERENCES, [])  MethodCall(super.onDestroyView(), [VariableReference(super, []), Expression(, [])])    VariableReference(super, [])    Expression(, [])  Statement(}, [])",1,,,0,[@Override],[@Override],0,,,,"1,2","3,4",0,"3,4",0,"A new control statement 'if (mList != null)' has been added, and within this block, a new method call `mList.setOnKeyListener(null)` is introduced. Therefore, the code change type involves control dependency change (3) and other statement change (4).","The added control statement and method call do not affect the return type or exception handling of the method. Therefore, no compatibility issue exists (0)."
106,"<android.app.admin.DevicePolicyManager: void setUserIcon(ComponentName,Bitmap)>",23,24,,,,"MethodDeclaration(method_body, [Statement({, []), Statement(try {, []), MethodCall(mService.setUserIcon(admin, icon), [VariableReference(mService, []), Expression(admin, []), Expression(icon, [])]), Statement(} catch (RemoteException re) {, []), MethodCall(Log.w(TAG, ""Could not set the user icon "", re), [VariableReference(Log, []), Expression(TAG, []), Expression(""Could not set the user icon "", []), Expression(re, [])]), Statement(}, []), Statement(}, [])])  Statement({, [])  Statement(try {, [])  MethodCall(mService.setUserIcon(admin, icon), [VariableReference(mService, []), Expression(admin, []), Expression(icon, [])])    VariableReference(mService, [])    Expression(admin, [])    Expression(icon, [])  Statement(} catch (RemoteException re) {, [])  MethodCall(Log.w(TAG, ""Could not set the user icon "", re), [VariableReference(Log, []), Expression(TAG, []), Expression(""Could not set the user icon "", []), Expression(re, [])])    VariableReference(Log, [])    Expression(TAG, [])    Expression(""Could not set the user icon "", [])    Expression(re, [])  Statement(}, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(throwIfParentInstance(""setUserIcon""), []), Statement(try {, []), MethodCall(mService.setUserIcon(admin, icon), [VariableReference(mService, []), Expression(admin, []), Expression(icon, [])]), Statement(} catch (RemoteException re) {, []), MethodCall(throw re.rethrowFromSystemServer(), [VariableReference(throw re, []), Expression(, [])]), Statement(}, []), Statement(}, [])])  Statement({, [])  Statement(throwIfParentInstance(""setUserIcon""), [])  Statement(try {, [])  MethodCall(mService.setUserIcon(admin, icon), [VariableReference(mService, []), Expression(admin, []), Expression(icon, [])])    VariableReference(mService, [])    Expression(admin, [])    Expression(icon, [])  Statement(} catch (RemoteException re) {, [])  MethodCall(throw re.rethrowFromSystemServer(), [VariableReference(throw re, []), Expression(, [])])    VariableReference(throw re, [])    Expression(, [])  Statement(}, [])  Statement(}, [])",1,"/**
 * Called by profile or device owners to set the current user's photo.
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated with.
 * @param icon the bitmap to set as the photo.
 */
","/**
 * Called by profile or device owners to set the user's photo.
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated with.
 * @param icon the bitmap to set as the photo.
 * @throws SecurityException if {@code admin} is not a device or profile owner.
 */
",1,,,0,,,,"1,2","2,4",2,"2,3,4",2,1. A new method call `throwIfParentInstance("setUserIcon")` has been introduced at the beginning of the method. ,"Thus, the code change types are 2, 3, 4."
107,<android.bluetooth.BluetoothGatt: boolean readCharacteristic(BluetoothGattCharacteristic)>,23,24,,,,"MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(if ((characteristic.getProperties() & BluetoothGattCharacteristic.PROPERTY_READ), []), Expression(, [])]), Statement(return false, []), Statement(if (VDBG), []), MethodCall(Log.d(TAG, ""readCharacteristic() - uuid: "" + characteristic.getUuid()), [VariableReference(Log, []), Expression(TAG, []), Expression(""readCharacteristic() - uuid: "" + characteristic.getUuid(), [])]), AssignmentExpression(=, [VariableReference(if (mService, []), Expression(, [])]), Statement(return false, []), AssignmentExpression(=, [VariableReference(BluetoothGattService service, []), Expression(characteristic.getService(), [])]), AssignmentExpression(=, [VariableReference(if (service, []), Expression(, [])]), Statement(return false, []), AssignmentExpression(=, [VariableReference(BluetoothDevice device, []), Expression(service.getDevice(), [])]), AssignmentExpression(=, [VariableReference(if (device, []), Expression(, [])]), Statement(return false, []), Statement(synchronized (mDeviceBusy) {, []), Statement(if (mDeviceBusy), []), Statement(return false, []), AssignmentExpression(=, [VariableReference(mDeviceBusy, []), Expression(true, [])]), Statement(}, []), Statement(try {, []), MethodCall(mService.readCharacteristic(mClientIf, device.getAddress(), service.getType(), service.getInstanceId(), new ParcelUuid(service.getUuid()), characteristic.getInstanceId(), new ParcelUuid(characteristic.getUuid()), AUTHENTICATION_NONE), [VariableReference(mService, []), Expression(mClientIf, []), Expression(device.getAddress(), []), Expression(service.getType(), []), Expression(service.getInstanceId(), []), Expression(new ParcelUuid(service.getUuid()), []), Expression(characteristic.getInstanceId(), []), Expression(new ParcelUuid(characteristic.getUuid()), []), Expression(AUTHENTICATION_NONE, [])]), Statement(} catch (RemoteException e) {, []), MethodCall(Log.e(TAG, """", e), [VariableReference(Log, []), Expression(TAG, []), Expression("""", []), Expression(e, [])]), AssignmentExpression(=, [VariableReference(mDeviceBusy, []), Expression(false, [])]), Statement(return false, []), Statement(}, []), Statement(return true, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(if ((characteristic.getProperties() & BluetoothGattCharacteristic.PROPERTY_READ), []), Expression(, [])])    VariableReference(if ((characteristic.getProperties() & BluetoothGattCharacteristic.PROPERTY_READ), [])    Expression(, [])  Statement(return false, [])  Statement(if (VDBG), [])  MethodCall(Log.d(TAG, ""readCharacteristic() - uuid: "" + characteristic.getUuid()), [VariableReference(Log, []), Expression(TAG, []), Expression(""readCharacteristic() - uuid: "" + characteristic.getUuid(), [])])    VariableReference(Log, [])    Expression(TAG, [])    Expression(""readCharacteristic() - uuid: "" + characteristic.getUuid(), [])  AssignmentExpression(=, [VariableReference(if (mService, []), Expression(, [])])    VariableReference(if (mService, [])    Expression(, [])  Statement(return false, [])  AssignmentExpression(=, [VariableReference(BluetoothGattService service, []), Expression(characteristic.getService(), [])])    VariableReference(BluetoothGattService service, [])    Expression(characteristic.getService(), [])  AssignmentExpression(=, [VariableReference(if (service, []), Expression(, [])])    VariableReference(if (service, [])    Expression(, [])  Statement(return false, [])  AssignmentExpression(=, [VariableReference(BluetoothDevice device, []), Expression(service.getDevice(), [])])    VariableReference(BluetoothDevice device, [])    Expression(service.getDevice(), [])  AssignmentExpression(=, [VariableReference(if (device, []), Expression(, [])])    VariableReference(if (device, [])    Expression(, [])  Statement(return false, [])  Statement(synchronized (mDeviceBusy) {, [])  Statement(if (mDeviceBusy), [])  Statement(return false, [])  AssignmentExpression(=, [VariableReference(mDeviceBusy, []), Expression(true, [])])    VariableReference(mDeviceBusy, [])    Expression(true, [])  Statement(}, [])  Statement(try {, [])  MethodCall(mService.readCharacteristic(mClientIf, device.getAddress(), service.getType(), service.getInstanceId(), new ParcelUuid(service.getUuid()), characteristic.getInstanceId(), new ParcelUuid(characteristic.getUuid()), AUTHENTICATION_NONE), [VariableReference(mService, []), Expression(mClientIf, []), Expression(device.getAddress(), []), Expression(service.getType(), []), Expression(service.getInstanceId(), []), Expression(new ParcelUuid(service.getUuid()), []), Expression(characteristic.getInstanceId(), []), Expression(new ParcelUuid(characteristic.getUuid()), []), Expression(AUTHENTICATION_NONE, [])])    VariableReference(mService, [])    Expression(mClientIf, [])    Expression(device.getAddress(), [])    Expression(service.getType(), [])    Expression(service.getInstanceId(), [])    Expression(new ParcelUuid(service.getUuid()), [])    Expression(characteristic.getInstanceId(), [])    Expression(new ParcelUuid(characteristic.getUuid()), [])    Expression(AUTHENTICATION_NONE, [])  Statement(} catch (RemoteException e) {, [])  MethodCall(Log.e(TAG, """", e), [VariableReference(Log, []), Expression(TAG, []), Expression("""", []), Expression(e, [])])    VariableReference(Log, [])    Expression(TAG, [])    Expression("""", [])    Expression(e, [])  AssignmentExpression(=, [VariableReference(mDeviceBusy, []), Expression(false, [])])    VariableReference(mDeviceBusy, [])    Expression(false, [])  Statement(return false, [])  Statement(}, [])  Statement(return true, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(if ((characteristic.getProperties() & BluetoothGattCharacteristic.PROPERTY_READ), []), Expression(, [])]), Statement(return false, []), Statement(if (VDBG), []), MethodCall(Log.d(TAG, ""readCharacteristic() - uuid: "" + characteristic.getUuid()), [VariableReference(Log, []), Expression(TAG, []), Expression(""readCharacteristic() - uuid: "" + characteristic.getUuid(), [])]), AssignmentExpression(=, [VariableReference(if (mService, []), Expression(, [])]), Statement(return false, []), AssignmentExpression(=, [VariableReference(BluetoothGattService service, []), Expression(characteristic.getService(), [])]), AssignmentExpression(=, [VariableReference(if (service, []), Expression(, [])]), Statement(return false, []), AssignmentExpression(=, [VariableReference(BluetoothDevice device, []), Expression(service.getDevice(), [])]), AssignmentExpression(=, [VariableReference(if (device, []), Expression(, [])]), Statement(return false, []), Statement(synchronized (mDeviceBusy) {, []), Statement(if (mDeviceBusy), []), Statement(return false, []), AssignmentExpression(=, [VariableReference(mDeviceBusy, []), Expression(true, [])]), Statement(}, []), Statement(try {, []), MethodCall(mService.readCharacteristic(mClientIf, device.getAddress(), characteristic.getInstanceId(), AUTHENTICATION_NONE), [VariableReference(mService, []), Expression(mClientIf, []), Expression(device.getAddress(), []), Expression(characteristic.getInstanceId(), []), Expression(AUTHENTICATION_NONE, [])]), Statement(} catch (RemoteException e) {, []), MethodCall(Log.e(TAG, """", e), [VariableReference(Log, []), Expression(TAG, []), Expression("""", []), Expression(e, [])]), AssignmentExpression(=, [VariableReference(mDeviceBusy, []), Expression(false, [])]), Statement(return false, []), Statement(}, []), Statement(return true, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(if ((characteristic.getProperties() & BluetoothGattCharacteristic.PROPERTY_READ), []), Expression(, [])])    VariableReference(if ((characteristic.getProperties() & BluetoothGattCharacteristic.PROPERTY_READ), [])    Expression(, [])  Statement(return false, [])  Statement(if (VDBG), [])  MethodCall(Log.d(TAG, ""readCharacteristic() - uuid: "" + characteristic.getUuid()), [VariableReference(Log, []), Expression(TAG, []), Expression(""readCharacteristic() - uuid: "" + characteristic.getUuid(), [])])    VariableReference(Log, [])    Expression(TAG, [])    Expression(""readCharacteristic() - uuid: "" + characteristic.getUuid(), [])  AssignmentExpression(=, [VariableReference(if (mService, []), Expression(, [])])    VariableReference(if (mService, [])    Expression(, [])  Statement(return false, [])  AssignmentExpression(=, [VariableReference(BluetoothGattService service, []), Expression(characteristic.getService(), [])])    VariableReference(BluetoothGattService service, [])    Expression(characteristic.getService(), [])  AssignmentExpression(=, [VariableReference(if (service, []), Expression(, [])])    VariableReference(if (service, [])    Expression(, [])  Statement(return false, [])  AssignmentExpression(=, [VariableReference(BluetoothDevice device, []), Expression(service.getDevice(), [])])    VariableReference(BluetoothDevice device, [])    Expression(service.getDevice(), [])  AssignmentExpression(=, [VariableReference(if (device, []), Expression(, [])])    VariableReference(if (device, [])    Expression(, [])  Statement(return false, [])  Statement(synchronized (mDeviceBusy) {, [])  Statement(if (mDeviceBusy), [])  Statement(return false, [])  AssignmentExpression(=, [VariableReference(mDeviceBusy, []), Expression(true, [])])    VariableReference(mDeviceBusy, [])    Expression(true, [])  Statement(}, [])  Statement(try {, [])  MethodCall(mService.readCharacteristic(mClientIf, device.getAddress(), characteristic.getInstanceId(), AUTHENTICATION_NONE), [VariableReference(mService, []), Expression(mClientIf, []), Expression(device.getAddress(), []), Expression(characteristic.getInstanceId(), []), Expression(AUTHENTICATION_NONE, [])])    VariableReference(mService, [])    Expression(mClientIf, [])    Expression(device.getAddress(), [])    Expression(characteristic.getInstanceId(), [])    Expression(AUTHENTICATION_NONE, [])  Statement(} catch (RemoteException e) {, [])  MethodCall(Log.e(TAG, """", e), [VariableReference(Log, []), Expression(TAG, []), Expression("""", []), Expression(e, [])])    VariableReference(Log, [])    Expression(TAG, [])    Expression("""", [])    Expression(e, [])  AssignmentExpression(=, [VariableReference(mDeviceBusy, []), Expression(false, [])])    VariableReference(mDeviceBusy, [])    Expression(false, [])  Statement(return false, [])  Statement(}, [])  Statement(return true, [])  Statement(}, [])",1,"/**
 * Reads the requested characteristic from the associated remote device.
 *
 * <p>This is an asynchronous operation. The result of the read operation
 * is reported by the {@link BluetoothGattCallback#onCharacteristicRead}
 * callback.
 *
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH} permission.
 *
 * @param characteristic Characteristic to read from the remote device
 * @return true, if the read operation was initiated successfully
 */
","/**
 * Reads the requested characteristic from the associated remote device.
 *
 * <p>This is an asynchronous operation. The result of the read operation
 * is reported by the {@link BluetoothGattCallback#onCharacteristicRead}
 * callback.
 *
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH} permission.
 *
 * @param characteristic Characteristic to read from the remote device
 * @return true, if the read operation was initiated successfully
 */
",0,,,0,,,,2,5,1,"4,5",0,"The method call `mService.readCharacteristic` has changed from multiple parameters in the early version to fewer parameters in the late version. This indicates a possible change in the dependent API `readCharacteristic` of `mService`. Additionally, some minor internal statements related to this call have been changed, so the code change type is 4,5.","The modifications are focused on internal statements and dependent API changes. Without affecting return types or exception handling, there are no compatibility issues. Thus, the CI type is 0."
108,<android.widget.TextView: void drawableStateChanged()>,23,24,,,,"MethodDeclaration(method_body, [Statement({, []), MethodCall(super.drawableStateChanged(), [VariableReference(super, []), Expression(, [])]), AssignmentExpression(=, [VariableReference(if (mTextColor !, []), Expression(null && mTextColor.isStateful() || (mHintTextColor !, [])]), Statement(updateTextColors(), []), Statement(}, []), AssignmentExpression(=, [VariableReference(if (mDrawables !, []), Expression(null) {, [])]), AssignmentExpression(=, [VariableReference(final int[] state, []), Expression(getDrawableState(), [])]), AssignmentExpression(=, [VariableReference(if (dr !, []), Expression(null && dr.isStateful()) {, [])]), MethodCall(dr.setState(state), [VariableReference(dr, []), Expression(state, [])]), Statement(}, []), Statement(}, []), Statement(}, []), Statement(}, [])])  Statement({, [])  MethodCall(super.drawableStateChanged(), [VariableReference(super, []), Expression(, [])])    VariableReference(super, [])    Expression(, [])  AssignmentExpression(=, [VariableReference(if (mTextColor !, []), Expression(null && mTextColor.isStateful() || (mHintTextColor !, [])])    VariableReference(if (mTextColor !, [])    Expression(null && mTextColor.isStateful() || (mHintTextColor !, [])  Statement(updateTextColors(), [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(if (mDrawables !, []), Expression(null) {, [])])    VariableReference(if (mDrawables !, [])    Expression(null) {, [])  AssignmentExpression(=, [VariableReference(final int[] state, []), Expression(getDrawableState(), [])])    VariableReference(final int[] state, [])    Expression(getDrawableState(), [])  AssignmentExpression(=, [VariableReference(if (dr !, []), Expression(null && dr.isStateful()) {, [])])    VariableReference(if (dr !, [])    Expression(null && dr.isStateful()) {, [])  MethodCall(dr.setState(state), [VariableReference(dr, []), Expression(state, [])])    VariableReference(dr, [])    Expression(state, [])  Statement(}, [])  Statement(}, [])  Statement(}, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), MethodCall(super.drawableStateChanged(), [VariableReference(super, []), Expression(, [])]), AssignmentExpression(=, [VariableReference(if (mTextColor !, []), Expression(null && mTextColor.isStateful() || (mHintTextColor !, [])]), Statement(updateTextColors(), []), Statement(}, []), AssignmentExpression(=, [VariableReference(if (mDrawables !, []), Expression(null) {, [])]), AssignmentExpression(=, [VariableReference(final int[] state, []), Expression(getDrawableState(), [])]), AssignmentExpression(=, [VariableReference(if (dr !, []), Expression(null && dr.isStateful() && dr.setState(state)) {, [])]), Statement(invalidateDrawable(dr), []), Statement(}, []), Statement(}, []), Statement(}, []), Statement(}, [])])  Statement({, [])  MethodCall(super.drawableStateChanged(), [VariableReference(super, []), Expression(, [])])    VariableReference(super, [])    Expression(, [])  AssignmentExpression(=, [VariableReference(if (mTextColor !, []), Expression(null && mTextColor.isStateful() || (mHintTextColor !, [])])    VariableReference(if (mTextColor !, [])    Expression(null && mTextColor.isStateful() || (mHintTextColor !, [])  Statement(updateTextColors(), [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(if (mDrawables !, []), Expression(null) {, [])])    VariableReference(if (mDrawables !, [])    Expression(null) {, [])  AssignmentExpression(=, [VariableReference(final int[] state, []), Expression(getDrawableState(), [])])    VariableReference(final int[] state, [])    Expression(getDrawableState(), [])  AssignmentExpression(=, [VariableReference(if (dr !, []), Expression(null && dr.isStateful() && dr.setState(state)) {, [])])    VariableReference(if (dr !, [])    Expression(null && dr.isStateful() && dr.setState(state)) {, [])  Statement(invalidateDrawable(dr), [])  Statement(}, [])  Statement(}, [])  Statement(}, [])  Statement(}, [])",1,,,0,[@Override],[@Override],0,,,,"1,2","3,4,5",1,"3,4",0,"The control dependency has changed because the condition for setting the state of `dr` is now `null && dr.isStateful() && dr.setState(state)` instead of just `null && dr.isStateful()`. Additionally, a new statement `invalidateDrawable(dr)` has been added, so the change type is 3, 4.",The changes do not lead to potential differences in return values or exception handling since the method signature is `void`.
109,<android.widget.AbsSeekBar: void jumpDrawablesToCurrentState()>,23,24,,,,"MethodDeclaration(method_body, [Statement({, []), MethodCall(super.jumpDrawablesToCurrentState(), [VariableReference(super, []), Expression(, [])]), AssignmentExpression(=, [VariableReference(if (mThumb !, []), Expression(null) {, [])]), MethodCall(mThumb.jumpToCurrentState(), [VariableReference(mThumb, []), Expression(, [])]), Statement(}, []), Statement(}, [])])  Statement({, [])  MethodCall(super.jumpDrawablesToCurrentState(), [VariableReference(super, []), Expression(, [])])    VariableReference(super, [])    Expression(, [])  AssignmentExpression(=, [VariableReference(if (mThumb !, []), Expression(null) {, [])])    VariableReference(if (mThumb !, [])    Expression(null) {, [])  MethodCall(mThumb.jumpToCurrentState(), [VariableReference(mThumb, []), Expression(, [])])    VariableReference(mThumb, [])    Expression(, [])  Statement(}, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), MethodCall(super.jumpDrawablesToCurrentState(), [VariableReference(super, []), Expression(, [])]), AssignmentExpression(=, [VariableReference(if (mThumb !, []), Expression(null) {, [])]), MethodCall(mThumb.jumpToCurrentState(), [VariableReference(mThumb, []), Expression(, [])]), Statement(}, []), AssignmentExpression(=, [VariableReference(if (mTickMark !, []), Expression(null) {, [])]), MethodCall(mTickMark.jumpToCurrentState(), [VariableReference(mTickMark, []), Expression(, [])]), Statement(}, []), Statement(}, [])])  Statement({, [])  MethodCall(super.jumpDrawablesToCurrentState(), [VariableReference(super, []), Expression(, [])])    VariableReference(super, [])    Expression(, [])  AssignmentExpression(=, [VariableReference(if (mThumb !, []), Expression(null) {, [])])    VariableReference(if (mThumb !, [])    Expression(null) {, [])  MethodCall(mThumb.jumpToCurrentState(), [VariableReference(mThumb, []), Expression(, [])])    VariableReference(mThumb, [])    Expression(, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(if (mTickMark !, []), Expression(null) {, [])])    VariableReference(if (mTickMark !, [])    Expression(null) {, [])  MethodCall(mTickMark.jumpToCurrentState(), [VariableReference(mTickMark, []), Expression(, [])])    VariableReference(mTickMark, [])    Expression(, [])  Statement(}, [])  Statement(}, [])",1,,,0,[@Override],[@Override],0,,,,"1,2","1,3,4",0,4,0,"The late version adds handling for `mTickMark` by introducing a new `if` condition and method call (`if (mTickMark != null) mTickMark.jumpToCurrentState();`). This is different from the early version, where only `mThumb` was handled. This change doesn't fall into categories 1, 2, or 3 since it doesn't change return or exception statements, and the control structure itself remains largely the same but adds more execution steps. Therefore, it's classified as an 'other statement changed' type.","The added handling for `mTickMark` does not introduce potential for the API to return different values or types, nor does it change how exceptions are thrown. Given this, there is no compatibility issue stemming from the change."
110,"<android.preference.SeekBarVolumizer.Receiver: void onReceive(Context,Intent)>",23,24,,,,"MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(final String action, []), Expression(intent.getAction(), [])]), AssignmentExpression(=, [VariableReference(int streamType, []), Expression(intent.getIntExtra(AudioManager.EXTRA_VOLUME_STREAM_TYPE, -1), [])]), AssignmentExpression(=, [VariableReference(int streamValue, []), Expression(intent.getIntExtra(AudioManager.EXTRA_VOLUME_STREAM_VALUE, -1), [])]), AssignmentExpression(=, [VariableReference(final boolean streamMatch, []), Expression(mNotificationOrRing ? isNotificationOrRing(streamType) : (streamType, [])]), AssignmentExpression(=, [VariableReference(if (mSeekBar !, []), Expression(null && streamMatch && streamValue !, [])]), AssignmentExpression(=, [VariableReference(final boolean muted, []), Expression(mAudioManager.isStreamMute(mStreamType) || streamValue, [])]), MethodCall(mUiHandler.postUpdateSlider(streamValue, mLastAudibleStreamVolume, muted), [VariableReference(mUiHandler, []), Expression(streamValue, []), Expression(mLastAudibleStreamVolume, []), Expression(muted, [])]), Statement(}, []), Statement(if (mNotificationOrRing) {, []), AssignmentExpression(=, [VariableReference(mRingerMode, []), Expression(mAudioManager.getRingerModeInternal(), [])]), Statement(}, []), Statement(if (mAffectedByRingerMode) {, []), Statement(updateSlider(), []), Statement(}, []), AssignmentExpression(=, [VariableReference(mZenMode, []), Expression(mNotificationManager.getZenMode(), [])]), Statement(updateSlider(), []), Statement(}, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(final String action, []), Expression(intent.getAction(), [])])    VariableReference(final String action, [])    Expression(intent.getAction(), [])  AssignmentExpression(=, [VariableReference(int streamType, []), Expression(intent.getIntExtra(AudioManager.EXTRA_VOLUME_STREAM_TYPE, -1), [])])    VariableReference(int streamType, [])    Expression(intent.getIntExtra(AudioManager.EXTRA_VOLUME_STREAM_TYPE, -1), [])  AssignmentExpression(=, [VariableReference(int streamValue, []), Expression(intent.getIntExtra(AudioManager.EXTRA_VOLUME_STREAM_VALUE, -1), [])])    VariableReference(int streamValue, [])    Expression(intent.getIntExtra(AudioManager.EXTRA_VOLUME_STREAM_VALUE, -1), [])  AssignmentExpression(=, [VariableReference(final boolean streamMatch, []), Expression(mNotificationOrRing ? isNotificationOrRing(streamType) : (streamType, [])])    VariableReference(final boolean streamMatch, [])    Expression(mNotificationOrRing ? isNotificationOrRing(streamType) : (streamType, [])  AssignmentExpression(=, [VariableReference(if (mSeekBar !, []), Expression(null && streamMatch && streamValue !, [])])    VariableReference(if (mSeekBar !, [])    Expression(null && streamMatch && streamValue !, [])  AssignmentExpression(=, [VariableReference(final boolean muted, []), Expression(mAudioManager.isStreamMute(mStreamType) || streamValue, [])])    VariableReference(final boolean muted, [])    Expression(mAudioManager.isStreamMute(mStreamType) || streamValue, [])  MethodCall(mUiHandler.postUpdateSlider(streamValue, mLastAudibleStreamVolume, muted), [VariableReference(mUiHandler, []), Expression(streamValue, []), Expression(mLastAudibleStreamVolume, []), Expression(muted, [])])    VariableReference(mUiHandler, [])    Expression(streamValue, [])    Expression(mLastAudibleStreamVolume, [])    Expression(muted, [])  Statement(}, [])  Statement(if (mNotificationOrRing) {, [])  AssignmentExpression(=, [VariableReference(mRingerMode, []), Expression(mAudioManager.getRingerModeInternal(), [])])    VariableReference(mRingerMode, [])    Expression(mAudioManager.getRingerModeInternal(), [])  Statement(}, [])  Statement(if (mAffectedByRingerMode) {, [])  Statement(updateSlider(), [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(mZenMode, []), Expression(mNotificationManager.getZenMode(), [])])    VariableReference(mZenMode, [])    Expression(mNotificationManager.getZenMode(), [])  Statement(updateSlider(), [])  Statement(}, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(final String action, []), Expression(intent.getAction(), [])]), AssignmentExpression(=, [VariableReference(int streamType, []), Expression(intent.getIntExtra(AudioManager.EXTRA_VOLUME_STREAM_TYPE, -1), [])]), AssignmentExpression(=, [VariableReference(int streamValue, []), Expression(intent.getIntExtra(AudioManager.EXTRA_VOLUME_STREAM_VALUE, -1), [])]), Statement(updateVolumeSlider(streamType, streamValue), []), Statement(if (mNotificationOrRing) {, []), AssignmentExpression(=, [VariableReference(mRingerMode, []), Expression(mAudioManager.getRingerModeInternal(), [])]), Statement(}, []), Statement(if (mAffectedByRingerMode) {, []), Statement(updateSlider(), []), Statement(}, []), AssignmentExpression(=, [VariableReference(int streamType, []), Expression(intent.getIntExtra(AudioManager.EXTRA_VOLUME_STREAM_TYPE, -1), [])]), AssignmentExpression(=, [VariableReference(int streamVolume, []), Expression(mAudioManager.getStreamVolume(streamType), [])]), Statement(updateVolumeSlider(streamType, streamVolume), []), AssignmentExpression(=, [VariableReference(mZenMode, []), Expression(mNotificationManager.getZenMode(), [])]), Statement(updateSlider(), []), Statement(}, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(final String action, []), Expression(intent.getAction(), [])])    VariableReference(final String action, [])    Expression(intent.getAction(), [])  AssignmentExpression(=, [VariableReference(int streamType, []), Expression(intent.getIntExtra(AudioManager.EXTRA_VOLUME_STREAM_TYPE, -1), [])])    VariableReference(int streamType, [])    Expression(intent.getIntExtra(AudioManager.EXTRA_VOLUME_STREAM_TYPE, -1), [])  AssignmentExpression(=, [VariableReference(int streamValue, []), Expression(intent.getIntExtra(AudioManager.EXTRA_VOLUME_STREAM_VALUE, -1), [])])    VariableReference(int streamValue, [])    Expression(intent.getIntExtra(AudioManager.EXTRA_VOLUME_STREAM_VALUE, -1), [])  Statement(updateVolumeSlider(streamType, streamValue), [])  Statement(if (mNotificationOrRing) {, [])  AssignmentExpression(=, [VariableReference(mRingerMode, []), Expression(mAudioManager.getRingerModeInternal(), [])])    VariableReference(mRingerMode, [])    Expression(mAudioManager.getRingerModeInternal(), [])  Statement(}, [])  Statement(if (mAffectedByRingerMode) {, [])  Statement(updateSlider(), [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(int streamType, []), Expression(intent.getIntExtra(AudioManager.EXTRA_VOLUME_STREAM_TYPE, -1), [])])    VariableReference(int streamType, [])    Expression(intent.getIntExtra(AudioManager.EXTRA_VOLUME_STREAM_TYPE, -1), [])  AssignmentExpression(=, [VariableReference(int streamVolume, []), Expression(mAudioManager.getStreamVolume(streamType), [])])    VariableReference(int streamVolume, [])    Expression(mAudioManager.getStreamVolume(streamType), [])  Statement(updateVolumeSlider(streamType, streamVolume), [])  AssignmentExpression(=, [VariableReference(mZenMode, []), Expression(mNotificationManager.getZenMode(), [])])    VariableReference(mZenMode, [])    Expression(mNotificationManager.getZenMode(), [])  Statement(updateSlider(), [])  Statement(}, [])  Statement(}, [])",1,,,0,[@Override],[@Override],0,,,,"1,2","3,4",0,"1,3,4",0,Several changes were made:,"- The method `updateVolumeSlider(streamType, streamValue)` was introduced, and some nested logic was modified."
111,<android.widget.Editor.PinnedPopupWindow: void hide()>,23,24,,,,"MethodDeclaration(method_body, [Statement({, []), MethodCall(mPopupWindow.dismiss(), [VariableReference(mPopupWindow, []), Expression(, [])]), MethodCall(getPositionListener().removeSubscriber(this), [VariableReference(getPositionListener(), []), Expression(this, [])]), Statement(}, [])])  Statement({, [])  MethodCall(mPopupWindow.dismiss(), [VariableReference(mPopupWindow, []), Expression(, [])])    VariableReference(mPopupWindow, [])    Expression(, [])  MethodCall(getPositionListener().removeSubscriber(this), [VariableReference(getPositionListener(), []), Expression(this, [])])    VariableReference(getPositionListener(), [])    Expression(this, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(if (!isShowing()) {, []), Statement(return, []), Statement(}, []), MethodCall(mPopupWindow.dismiss(), [VariableReference(mPopupWindow, []), Expression(, [])]), MethodCall(getPositionListener().removeSubscriber(this), [VariableReference(getPositionListener(), []), Expression(this, [])]), Statement(}, [])])  Statement({, [])  Statement(if (!isShowing()) {, [])  Statement(return, [])  Statement(}, [])  MethodCall(mPopupWindow.dismiss(), [VariableReference(mPopupWindow, []), Expression(, [])])    VariableReference(mPopupWindow, [])    Expression(, [])  MethodCall(getPositionListener().removeSubscriber(this), [VariableReference(getPositionListener(), []), Expression(this, [])])    VariableReference(getPositionListener(), [])    Expression(this, [])  Statement(}, [])",1,,,0,,,0,,,,"1,2","1,3,4",1,"1,3",1,"The addition of the conditional statement `if (!isShowing()) { return; }` introduces a control dependency change and a new return statement, so the code change type is 1,3.","The newly added control statement may cause the method to return early under certain conditions, leading to different return behavior, so the CI type is 1."
112,<android.content.pm.PackageInstaller: List<SessionInfo> getAllSessions()>,23,24,,,,"MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(final ApplicationInfo info, []), Expression(mContext.getApplicationInfo(), [])]), AssignmentExpression(=, [VariableReference(if (""com.google.android.googlequicksearchbox"".equals(info.packageName) && info.versionCode <, []), Expression(300400110) {, [])]), MethodCall(Log.d(TAG, ""Ignoring callback request from old prebuilt""), [VariableReference(Log, []), Expression(TAG, []), Expression(""Ignoring callback request from old prebuilt"", [])]), Statement(return Collections.EMPTY_LIST, []), Statement(}, []), Statement(try {, []), MethodCall(return mInstaller.getAllSessions(mUserId).getList(), [VariableReference(return mInstaller, []), Expression(mUserId).getList(, [])]), Statement(} catch (RemoteException e) {, []), MethodCall(throw e.rethrowAsRuntimeException(), [VariableReference(throw e, []), Expression(, [])]), Statement(}, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(final ApplicationInfo info, []), Expression(mContext.getApplicationInfo(), [])])    VariableReference(final ApplicationInfo info, [])    Expression(mContext.getApplicationInfo(), [])  AssignmentExpression(=, [VariableReference(if (""com.google.android.googlequicksearchbox"".equals(info.packageName) && info.versionCode <, []), Expression(300400110) {, [])])    VariableReference(if (""com.google.android.googlequicksearchbox"".equals(info.packageName) && info.versionCode <, [])    Expression(300400110) {, [])  MethodCall(Log.d(TAG, ""Ignoring callback request from old prebuilt""), [VariableReference(Log, []), Expression(TAG, []), Expression(""Ignoring callback request from old prebuilt"", [])])    VariableReference(Log, [])    Expression(TAG, [])    Expression(""Ignoring callback request from old prebuilt"", [])  Statement(return Collections.EMPTY_LIST, [])  Statement(}, [])  Statement(try {, [])  MethodCall(return mInstaller.getAllSessions(mUserId).getList(), [VariableReference(return mInstaller, []), Expression(mUserId).getList(, [])])    VariableReference(return mInstaller, [])    Expression(mUserId).getList(, [])  Statement(} catch (RemoteException e) {, [])  MethodCall(throw e.rethrowAsRuntimeException(), [VariableReference(throw e, []), Expression(, [])])    VariableReference(throw e, [])    Expression(, [])  Statement(}, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(try {, []), MethodCall(return mInstaller.getAllSessions(mUserId).getList(), [VariableReference(return mInstaller, []), Expression(mUserId).getList(, [])]), Statement(} catch (RemoteException e) {, []), MethodCall(throw e.rethrowFromSystemServer(), [VariableReference(throw e, []), Expression(, [])]), Statement(}, []), Statement(}, [])])  Statement({, [])  Statement(try {, [])  MethodCall(return mInstaller.getAllSessions(mUserId).getList(), [VariableReference(return mInstaller, []), Expression(mUserId).getList(, [])])    VariableReference(return mInstaller, [])    Expression(mUserId).getList(, [])  Statement(} catch (RemoteException e) {, [])  MethodCall(throw e.rethrowFromSystemServer(), [VariableReference(throw e, []), Expression(, [])])    VariableReference(throw e, [])    Expression(, [])  Statement(}, [])  Statement(}, [])",1,"/**
 * Return list of all known install sessions, regardless of the installer.
 */
","/**
 * Return list of all known install sessions, regardless of the installer.
 */
",0,[@NonNull],[@NonNull],0,,,,"1,2","1,2,3,4,5","1,2","1,2,3","1,2","The early version of the method includes additional conditional checks and log statements. In the late version, the conditional checks, log statements, and associated early returns are removed. Also, the late version changes the exception handling statement from `throw e.rethrowAsRuntimeException()` to `throw e.rethrowFromSystemServer()`. Thus, the code change types include 1 (Return statement changed), 2 (Exception handling statement changed), and 3 (Control dependency changed).","The removal of the conditional check and its return statement could potentially alter the return value of the method, and the change in exception handling may lead to different exception behaviors. Thus, the CI types include 1 (Compatibility Issue caused by potential different return values or types) and 2 (Compatibility Issue caused by potential different exception handlings)."
113,<android.widget.ActionMenuPresenter.OpenOverflowRunnable: void run()>,23,24,,,,"MethodDeclaration(method_body, [Statement({, []), MethodCall(mMenu.changeMenuMode(), [VariableReference(mMenu, []), Expression(, [])]), AssignmentExpression(=, [VariableReference(final View menuView, []), Expression((View) mMenuView, [])]), AssignmentExpression(=, [VariableReference(if (menuView !, []), Expression(null && menuView.getWindowToken() !, [])]), AssignmentExpression(=, [VariableReference(mOverflowPopup, []), Expression(mPopup, [])]), Statement(}, []), AssignmentExpression(=, [VariableReference(mPostedOpenRunnable, []), Expression(null, [])]), Statement(}, [])])  Statement({, [])  MethodCall(mMenu.changeMenuMode(), [VariableReference(mMenu, []), Expression(, [])])    VariableReference(mMenu, [])    Expression(, [])  AssignmentExpression(=, [VariableReference(final View menuView, []), Expression((View) mMenuView, [])])    VariableReference(final View menuView, [])    Expression((View) mMenuView, [])  AssignmentExpression(=, [VariableReference(if (menuView !, []), Expression(null && menuView.getWindowToken() !, [])])    VariableReference(if (menuView !, [])    Expression(null && menuView.getWindowToken() !, [])  AssignmentExpression(=, [VariableReference(mOverflowPopup, []), Expression(mPopup, [])])    VariableReference(mOverflowPopup, [])    Expression(mPopup, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(mPostedOpenRunnable, []), Expression(null, [])])    VariableReference(mPostedOpenRunnable, [])    Expression(null, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(if (mMenu !, []), Expression(null) {, [])]), MethodCall(mMenu.changeMenuMode(), [VariableReference(mMenu, []), Expression(, [])]), Statement(}, []), AssignmentExpression(=, [VariableReference(final View menuView, []), Expression((View) mMenuView, [])]), AssignmentExpression(=, [VariableReference(if (menuView !, []), Expression(null && menuView.getWindowToken() !, [])]), AssignmentExpression(=, [VariableReference(mOverflowPopup, []), Expression(mPopup, [])]), Statement(}, []), AssignmentExpression(=, [VariableReference(mPostedOpenRunnable, []), Expression(null, [])]), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(if (mMenu !, []), Expression(null) {, [])])    VariableReference(if (mMenu !, [])    Expression(null) {, [])  MethodCall(mMenu.changeMenuMode(), [VariableReference(mMenu, []), Expression(, [])])    VariableReference(mMenu, [])    Expression(, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(final View menuView, []), Expression((View) mMenuView, [])])    VariableReference(final View menuView, [])    Expression((View) mMenuView, [])  AssignmentExpression(=, [VariableReference(if (menuView !, []), Expression(null && menuView.getWindowToken() !, [])])    VariableReference(if (menuView !, [])    Expression(null && menuView.getWindowToken() !, [])  AssignmentExpression(=, [VariableReference(mOverflowPopup, []), Expression(mPopup, [])])    VariableReference(mOverflowPopup, [])    Expression(mPopup, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(mPostedOpenRunnable, []), Expression(null, [])])    VariableReference(mPostedOpenRunnable, [])    Expression(null, [])  Statement(}, [])",1,,,0,,,0,,,,1,3,1,3,0,"The code including control dependencies has been changed. Specifically, an `if` condition is added before the `mMenu.changeMenuMode()` invocation.","Although a control dependency has been changed, it does not influence the return values or exception handling of the method `run()`; therefore, no compatibility issue exists."
114,"<android.accounts.AccountManager: AccountManagerFuture<Bundle> getAuthToken(Account,String,Bundle,boolean,AccountManagerCallback<Bundle>,Handler)>",23,24,,,,"MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(if (account, []), Expression(, [])]), Statement(throw new IllegalArgumentException(""account is null""), []), AssignmentExpression(=, [VariableReference(if (authTokenType, []), Expression(, [])]), Statement(throw new IllegalArgumentException(""authTokenType is null""), []), AssignmentExpression(=, [VariableReference(final Bundle optionsIn, []), Expression(new Bundle(), [])]), AssignmentExpression(=, [VariableReference(if (options !, []), Expression(null) {, [])]), MethodCall(optionsIn.putAll(options), [VariableReference(optionsIn, []), Expression(options, [])]), Statement(}, []), MethodCall(optionsIn.putString(KEY_ANDROID_PACKAGE_NAME, mContext.getPackageName()), [VariableReference(optionsIn, []), Expression(KEY_ANDROID_PACKAGE_NAME, []), Expression(mContext.getPackageName(), [])]), Statement(return new AmsTask(null, handler, callback) {, []), Statement(public void doWork() throws RemoteException {, []), Statement(optionsIn), []), Statement(}, []), MethodCall(}.start(), [VariableReference(}, []), Expression(, [])]), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(if (account, []), Expression(, [])])    VariableReference(if (account, [])    Expression(, [])  Statement(throw new IllegalArgumentException(""account is null""), [])  AssignmentExpression(=, [VariableReference(if (authTokenType, []), Expression(, [])])    VariableReference(if (authTokenType, [])    Expression(, [])  Statement(throw new IllegalArgumentException(""authTokenType is null""), [])  AssignmentExpression(=, [VariableReference(final Bundle optionsIn, []), Expression(new Bundle(), [])])    VariableReference(final Bundle optionsIn, [])    Expression(new Bundle(), [])  AssignmentExpression(=, [VariableReference(if (options !, []), Expression(null) {, [])])    VariableReference(if (options !, [])    Expression(null) {, [])  MethodCall(optionsIn.putAll(options), [VariableReference(optionsIn, []), Expression(options, [])])    VariableReference(optionsIn, [])    Expression(options, [])  Statement(}, [])  MethodCall(optionsIn.putString(KEY_ANDROID_PACKAGE_NAME, mContext.getPackageName()), [VariableReference(optionsIn, []), Expression(KEY_ANDROID_PACKAGE_NAME, []), Expression(mContext.getPackageName(), [])])    VariableReference(optionsIn, [])    Expression(KEY_ANDROID_PACKAGE_NAME, [])    Expression(mContext.getPackageName(), [])  Statement(return new AmsTask(null, handler, callback) {, [])  Statement(public void doWork() throws RemoteException {, [])  Statement(optionsIn), [])  Statement(}, [])  MethodCall(}.start(), [VariableReference(}, []), Expression(, [])])    VariableReference(}, [])    Expression(, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(if (account, []), Expression(, [])]), Statement(throw new IllegalArgumentException(""account is null""), []), AssignmentExpression(=, [VariableReference(if (authTokenType, []), Expression(, [])]), Statement(throw new IllegalArgumentException(""authTokenType is null""), []), AssignmentExpression(=, [VariableReference(final Bundle optionsIn, []), Expression(new Bundle(), [])]), AssignmentExpression(=, [VariableReference(if (options !, []), Expression(null) {, [])]), MethodCall(optionsIn.putAll(options), [VariableReference(optionsIn, []), Expression(options, [])]), Statement(}, []), MethodCall(optionsIn.putString(KEY_ANDROID_PACKAGE_NAME, mContext.getPackageName()), [VariableReference(optionsIn, []), Expression(KEY_ANDROID_PACKAGE_NAME, []), Expression(mContext.getPackageName(), [])]), Statement(return new AmsTask(null, handler, callback) {, []), Statement(@Override, []), Statement(public void doWork() throws RemoteException {, []), Statement(optionsIn), []), Statement(}, []), MethodCall(}.start(), [VariableReference(}, []), Expression(, [])]), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(if (account, []), Expression(, [])])    VariableReference(if (account, [])    Expression(, [])  Statement(throw new IllegalArgumentException(""account is null""), [])  AssignmentExpression(=, [VariableReference(if (authTokenType, []), Expression(, [])])    VariableReference(if (authTokenType, [])    Expression(, [])  Statement(throw new IllegalArgumentException(""authTokenType is null""), [])  AssignmentExpression(=, [VariableReference(final Bundle optionsIn, []), Expression(new Bundle(), [])])    VariableReference(final Bundle optionsIn, [])    Expression(new Bundle(), [])  AssignmentExpression(=, [VariableReference(if (options !, []), Expression(null) {, [])])    VariableReference(if (options !, [])    Expression(null) {, [])  MethodCall(optionsIn.putAll(options), [VariableReference(optionsIn, []), Expression(options, [])])    VariableReference(optionsIn, [])    Expression(options, [])  Statement(}, [])  MethodCall(optionsIn.putString(KEY_ANDROID_PACKAGE_NAME, mContext.getPackageName()), [VariableReference(optionsIn, []), Expression(KEY_ANDROID_PACKAGE_NAME, []), Expression(mContext.getPackageName(), [])])    VariableReference(optionsIn, [])    Expression(KEY_ANDROID_PACKAGE_NAME, [])    Expression(mContext.getPackageName(), [])  Statement(return new AmsTask(null, handler, callback) {, [])  Statement(@Override, [])  Statement(public void doWork() throws RemoteException {, [])  Statement(optionsIn), [])  Statement(}, [])  MethodCall(}.start(), [VariableReference(}, []), Expression(, [])])    VariableReference(}, [])    Expression(, [])  Statement(}, [])",1,"/**
 * Gets an auth token of the specified type for a particular account,
 * optionally raising a notification if the user must enter credentials.
 * This method is intended for background tasks and services where the
 * user should not be immediately interrupted with a password prompt.
 *
 * <p>If a previously generated auth token is cached for this account and
 * type, then it is returned.  Otherwise, if a saved password is
 * available, it is sent to the server to generate a new auth token.
 * Otherwise, an {@link Intent} is returned which, when started, will
 * prompt the user for a password.  If the notifyAuthFailure parameter is
 * set, a status bar notification is also created with the same Intent,
 * alerting the user that they need to enter a password at some point.
 *
 * <p>In that case, you may need to wait until the user responds, which
 * could take hours or days or forever.  When the user does respond and
 * supply a new password, the account manager will broadcast the
 * {@link #LOGIN_ACCOUNTS_CHANGED_ACTION} Intent, which applications can
 * use to try again.
 *
 * <p>If notifyAuthFailure is not set, it is the application's
 * responsibility to launch the returned Intent at some point.
 * Either way, the result from this call will not wait for user action.
 *
 * <p>Some authenticators have auth token <em>types</em>, whose value
 * is authenticator-dependent.  Some services use different token types to
 * access different functionality -- for example, Google uses different auth
 * tokens to access Gmail and Google Calendar for the same account.
 *
 * <p>This method may be called from any thread, but the returned
 * {@link AccountManagerFuture} must not be used on the main thread.
 *
 * <p><b>NOTE:</b> If targeting your app to work on API level 22 and before,
 * USE_CREDENTIALS permission is needed for those platforms. See docs for
 * this function in API level 22.
 *
 * @param account The account to fetch an auth token for
 * @param authTokenType The auth token type, an authenticator-dependent
 * string token, must not be null
 * @param options Authenticator-specific options for the request,
 * may be null or empty
 * @param notifyAuthFailure True to add a notification to prompt the
 * user for a password if necessary, false to leave that to the caller
 * @param callback Callback to invoke when the request completes,
 * null for no callback
 * @param handler {@link Handler} identifying the callback thread,
 * null for the main thread
 * @return An {@link AccountManagerFuture} which resolves to a Bundle with
 * at least the following fields on success:
 * <ul>
 * <li> {@link #KEY_ACCOUNT_NAME} - the name of the account you supplied
 * <li> {@link #KEY_ACCOUNT_TYPE} - the type of the account
 * <li> {@link #KEY_AUTHTOKEN} - the auth token you wanted
 * </ul>
 *
 * (Other authenticator-specific values may be returned.)  If the user
 * must enter credentials, the returned Bundle contains only
 * {@link #KEY_INTENT} with the {@link Intent} needed to launch a prompt.
 *
 * If an error occurred, {@link AccountManagerFuture#getResult()} throws:
 * <ul>
 * <li> {@link AuthenticatorException} if the authenticator failed to respond
 * <li> {@link OperationCanceledException} if the operation is canceled for
 * any reason, incluidng the user canceling a credential request
 * <li> {@link IOException} if the authenticator experienced an I/O problem
 * creating a new auth token, usually because of network trouble
 * </ul>
 * If the account is no longer present on the device, the return value is
 * authenticator-dependent.  The caller should verify the validity of the
 * account before requesting an auth token.
 */
","/**
 * Gets an auth token of the specified type for a particular account,
 * optionally raising a notification if the user must enter credentials.
 * This method is intended for background tasks and services where the
 * user should not be immediately interrupted with a password prompt.
 *
 * <p>If a previously generated auth token is cached for this account and
 * type, then it is returned.  Otherwise, if a saved password is
 * available, it is sent to the server to generate a new auth token.
 * Otherwise, an {@link Intent} is returned which, when started, will
 * prompt the user for a password.  If the notifyAuthFailure parameter is
 * set, a status bar notification is also created with the same Intent,
 * alerting the user that they need to enter a password at some point.
 *
 * <p>In that case, you may need to wait until the user responds, which
 * could take hours or days or forever.  When the user does respond and
 * supply a new password, the account manager will broadcast the
 * {@link #LOGIN_ACCOUNTS_CHANGED_ACTION} Intent, which applications can
 * use to try again.
 *
 * <p>If notifyAuthFailure is not set, it is the application's
 * responsibility to launch the returned Intent at some point.
 * Either way, the result from this call will not wait for user action.
 *
 * <p>Some authenticators have auth token <em>types</em>, whose value
 * is authenticator-dependent.  Some services use different token types to
 * access different functionality -- for example, Google uses different auth
 * tokens to access Gmail and Google Calendar for the same account.
 *
 * <p>This method may be called from any thread, but the returned
 * {@link AccountManagerFuture} must not be used on the main thread.
 *
 * <p><b>NOTE:</b> If targeting your app to work on API level 22 and before,
 * USE_CREDENTIALS permission is needed for those platforms. See docs for
 * this function in API level 22.
 *
 * @param account The account to fetch an auth token for
 * @param authTokenType The auth token type, an authenticator-dependent
 * string token, must not be null
 * @param options Authenticator-specific options for the request,
 * may be null or empty
 * @param notifyAuthFailure True to add a notification to prompt the
 * user for a password if necessary, false to leave that to the caller
 * @param callback Callback to invoke when the request completes,
 * null for no callback
 * @param handler {@link Handler} identifying the callback thread,
 * null for the main thread
 * @return An {@link AccountManagerFuture} which resolves to a Bundle with
 * at least the following fields on success:
 * <ul>
 * <li> {@link #KEY_ACCOUNT_NAME} - the name of the account you supplied
 * <li> {@link #KEY_ACCOUNT_TYPE} - the type of the account
 * <li> {@link #KEY_AUTHTOKEN} - the auth token you wanted
 * </ul>
 *
 * (Other authenticator-specific values may be returned.)  If the user
 * must enter credentials, the returned Bundle contains only
 * {@link #KEY_INTENT} with the {@link Intent} needed to launch a prompt.
 *
 * If an error occurred, {@link AccountManagerFuture#getResult()} throws:
 * <ul>
 * <li> {@link AuthenticatorException} if the authenticator failed to respond
 * <li> {@link OperationCanceledException} if the operation is canceled for
 * any reason, incluidng the user canceling a credential request
 * <li> {@link IOException} if the authenticator experienced an I/O problem
 * creating a new auth token, usually because of network trouble
 * </ul>
 * If the account is no longer present on the device, the return value is
 * authenticator-dependent.  The caller should verify the validity of the
 * account before requesting an auth token.
 */
",0,,,0,,,,1,4,0,"3,4",0,"The only addition in the late version of the method implementation is an `@Override` annotation for the `doWork` method inside the `AmsTask` class, which is a control dependency change. Additionally, adding the `@Override` annotation is also an ""other statement changed"" type.","Adding the `@Override` annotation does not change the behavior of the method or the class it belongs to. Hence, no compatibility issue is introduced, so the CI type is 0."
115,<android.net.NetworkRequest: int hashCode()>,24,25,,,,"MethodDeclaration(method_body, [Statement({, []), MethodCall(return requestId + (legacyType * 1013) + (networkCapabilities.hashCode() * 1051), [VariableReference(return requestId + (legacyType * 1013) + (networkCapabilities, []), Expression() * 1051, [])]), Statement(}, [])])  Statement({, [])  MethodCall(return requestId + (legacyType * 1013) + (networkCapabilities.hashCode() * 1051), [VariableReference(return requestId + (legacyType * 1013) + (networkCapabilities, []), Expression() * 1051, [])])    VariableReference(return requestId + (legacyType * 1013) + (networkCapabilities, [])    Expression() * 1051, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), MethodCall(return Objects.hash(requestId, legacyType, networkCapabilities, type), [VariableReference(return Objects, []), Expression(requestId, []), Expression(legacyType, []), Expression(networkCapabilities, []), Expression(type, [])]), Statement(}, [])])  Statement({, [])  MethodCall(return Objects.hash(requestId, legacyType, networkCapabilities, type), [VariableReference(return Objects, []), Expression(requestId, []), Expression(legacyType, []), Expression(networkCapabilities, []), Expression(type, [])])    VariableReference(return Objects, [])    Expression(requestId, [])    Expression(legacyType, [])    Expression(networkCapabilities, [])    Expression(type, [])  Statement(}, [])",1,,,0,,,0,,,,"1,2","1,5",1,1,1,"The return statement has changed from `return requestId + (legacyType * 1013) + (networkCapabilities.hashCode() * 1051)` to `return Objects.hash(requestId, legacyType, networkCapabilities, type)`. This change is in the return statement, so the code change type is 1.","As the change in the return statement can lead to different hash code values being returned when the hashCode() method is invoked, it potentially causes a Compatibility Issue. Therefore, the CI type is 1."
116,<android.view.TextureView: HardwareLayer getHardwareLayer()>,24,25,,,,"MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(if (mLayer, []), Expression(, [])]), AssignmentExpression(=, [VariableReference(if (mAttachInfo, []), Expression(, [])]), Statement(return null, []), Statement(}, []), AssignmentExpression(=, [VariableReference(mLayer, []), Expression(mAttachInfo.mHardwareRenderer.createTextureLayer(), [])]), Statement(if (!mUpdateSurface) {, []), Statement(// Create a new SurfaceTexture for the layer., []), AssignmentExpression(=, [VariableReference(mSurface, []), Expression(new SurfaceTexture(false), [])]), MethodCall(mLayer.setSurfaceTexture(mSurface), [VariableReference(mLayer, []), Expression(mSurface, [])]), Statement(}, []), MethodCall(mSurface.setDefaultBufferSize(getWidth(), getHeight()), [VariableReference(mSurface, []), Expression(getWidth(), []), Expression(getHeight(), [])]), Statement(nCreateNativeWindow(mSurface), []), MethodCall(mSurface.setOnFrameAvailableListener(mUpdateListener, mAttachInfo.mHandler), [VariableReference(mSurface, []), Expression(mUpdateListener, []), Expression(mAttachInfo.mHandler, [])]), AssignmentExpression(=, [VariableReference(if (mListener !, []), Expression(null && !mUpdateSurface) {, [])]), MethodCall(mListener.onSurfaceTextureAvailable(mSurface, getWidth(), getHeight()), [VariableReference(mListener, []), Expression(mSurface, []), Expression(getWidth(), []), Expression(getHeight(), [])]), Statement(}, []), MethodCall(mLayer.setLayerPaint(mLayerPaint), [VariableReference(mLayer, []), Expression(mLayerPaint, [])]), Statement(}, []), Statement(if (mUpdateSurface) {, []), Statement(// Someone has requested that we use a specific SurfaceTexture, so, []), Statement(// tell mLayer about it and set the SurfaceTexture to use the, []), Statement(// current view size., []), AssignmentExpression(=, [VariableReference(mUpdateSurface, []), Expression(false, [])]), Statement(// Since we are updating the layer, force an update to ensure its, []), Statement(updateLayer(), []), AssignmentExpression(=, [VariableReference(mMatrixChanged, []), Expression(true, [])]), MethodCall(mLayer.setSurfaceTexture(mSurface), [VariableReference(mLayer, []), Expression(mSurface, [])]), MethodCall(mSurface.setDefaultBufferSize(getWidth(), getHeight()), [VariableReference(mSurface, []), Expression(getWidth(), []), Expression(getHeight(), [])]), Statement(}, []), Statement(return mLayer, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(if (mLayer, []), Expression(, [])])    VariableReference(if (mLayer, [])    Expression(, [])  AssignmentExpression(=, [VariableReference(if (mAttachInfo, []), Expression(, [])])    VariableReference(if (mAttachInfo, [])    Expression(, [])  Statement(return null, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(mLayer, []), Expression(mAttachInfo.mHardwareRenderer.createTextureLayer(), [])])    VariableReference(mLayer, [])    Expression(mAttachInfo.mHardwareRenderer.createTextureLayer(), [])  Statement(if (!mUpdateSurface) {, [])  Statement(// Create a new SurfaceTexture for the layer., [])  AssignmentExpression(=, [VariableReference(mSurface, []), Expression(new SurfaceTexture(false), [])])    VariableReference(mSurface, [])    Expression(new SurfaceTexture(false), [])  MethodCall(mLayer.setSurfaceTexture(mSurface), [VariableReference(mLayer, []), Expression(mSurface, [])])    VariableReference(mLayer, [])    Expression(mSurface, [])  Statement(}, [])  MethodCall(mSurface.setDefaultBufferSize(getWidth(), getHeight()), [VariableReference(mSurface, []), Expression(getWidth(), []), Expression(getHeight(), [])])    VariableReference(mSurface, [])    Expression(getWidth(), [])    Expression(getHeight(), [])  Statement(nCreateNativeWindow(mSurface), [])  MethodCall(mSurface.setOnFrameAvailableListener(mUpdateListener, mAttachInfo.mHandler), [VariableReference(mSurface, []), Expression(mUpdateListener, []), Expression(mAttachInfo.mHandler, [])])    VariableReference(mSurface, [])    Expression(mUpdateListener, [])    Expression(mAttachInfo.mHandler, [])  AssignmentExpression(=, [VariableReference(if (mListener !, []), Expression(null && !mUpdateSurface) {, [])])    VariableReference(if (mListener !, [])    Expression(null && !mUpdateSurface) {, [])  MethodCall(mListener.onSurfaceTextureAvailable(mSurface, getWidth(), getHeight()), [VariableReference(mListener, []), Expression(mSurface, []), Expression(getWidth(), []), Expression(getHeight(), [])])    VariableReference(mListener, [])    Expression(mSurface, [])    Expression(getWidth(), [])    Expression(getHeight(), [])  Statement(}, [])  MethodCall(mLayer.setLayerPaint(mLayerPaint), [VariableReference(mLayer, []), Expression(mLayerPaint, [])])    VariableReference(mLayer, [])    Expression(mLayerPaint, [])  Statement(}, [])  Statement(if (mUpdateSurface) {, [])  Statement(// Someone has requested that we use a specific SurfaceTexture, so, [])  Statement(// tell mLayer about it and set the SurfaceTexture to use the, [])  Statement(// current view size., [])  AssignmentExpression(=, [VariableReference(mUpdateSurface, []), Expression(false, [])])    VariableReference(mUpdateSurface, [])    Expression(false, [])  Statement(// Since we are updating the layer, force an update to ensure its, [])  Statement(updateLayer(), [])  AssignmentExpression(=, [VariableReference(mMatrixChanged, []), Expression(true, [])])    VariableReference(mMatrixChanged, [])    Expression(true, [])  MethodCall(mLayer.setSurfaceTexture(mSurface), [VariableReference(mLayer, []), Expression(mSurface, [])])    VariableReference(mLayer, [])    Expression(mSurface, [])  MethodCall(mSurface.setDefaultBufferSize(getWidth(), getHeight()), [VariableReference(mSurface, []), Expression(getWidth(), []), Expression(getHeight(), [])])    VariableReference(mSurface, [])    Expression(getWidth(), [])    Expression(getHeight(), [])  Statement(}, [])  Statement(return mLayer, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(if (mLayer, []), Expression(, [])]), AssignmentExpression(=, [VariableReference(if (mAttachInfo, []), Expression(, [])]), Statement(return null, []), Statement(}, []), AssignmentExpression(=, [VariableReference(mLayer, []), Expression(mAttachInfo.mHardwareRenderer.createTextureLayer(), [])]), AssignmentExpression(=, [VariableReference(boolean createNewSurface, []), Expression((mSurface, [])]), Statement(if (createNewSurface) {, []), Statement(// Create a new SurfaceTexture for the layer., []), AssignmentExpression(=, [VariableReference(mSurface, []), Expression(new SurfaceTexture(false), [])]), Statement(nCreateNativeWindow(mSurface), []), Statement(}, []), MethodCall(mLayer.setSurfaceTexture(mSurface), [VariableReference(mLayer, []), Expression(mSurface, [])]), MethodCall(mSurface.setDefaultBufferSize(getWidth(), getHeight()), [VariableReference(mSurface, []), Expression(getWidth(), []), Expression(getHeight(), [])]), MethodCall(mSurface.setOnFrameAvailableListener(mUpdateListener, mAttachInfo.mHandler), [VariableReference(mSurface, []), Expression(mUpdateListener, []), Expression(mAttachInfo.mHandler, [])]), AssignmentExpression(=, [VariableReference(if (mListener !, []), Expression(null && createNewSurface) {, [])]), MethodCall(mListener.onSurfaceTextureAvailable(mSurface, getWidth(), getHeight()), [VariableReference(mListener, []), Expression(mSurface, []), Expression(getWidth(), []), Expression(getHeight(), [])]), Statement(}, []), MethodCall(mLayer.setLayerPaint(mLayerPaint), [VariableReference(mLayer, []), Expression(mLayerPaint, [])]), Statement(}, []), Statement(if (mUpdateSurface) {, []), Statement(// Someone has requested that we use a specific SurfaceTexture, so, []), Statement(// tell mLayer about it and set the SurfaceTexture to use the, []), Statement(// current view size., []), AssignmentExpression(=, [VariableReference(mUpdateSurface, []), Expression(false, [])]), Statement(// Since we are updating the layer, force an update to ensure its, []), Statement(updateLayer(), []), AssignmentExpression(=, [VariableReference(mMatrixChanged, []), Expression(true, [])]), MethodCall(mLayer.setSurfaceTexture(mSurface), [VariableReference(mLayer, []), Expression(mSurface, [])]), MethodCall(mSurface.setDefaultBufferSize(getWidth(), getHeight()), [VariableReference(mSurface, []), Expression(getWidth(), []), Expression(getHeight(), [])]), Statement(}, []), Statement(return mLayer, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(if (mLayer, []), Expression(, [])])    VariableReference(if (mLayer, [])    Expression(, [])  AssignmentExpression(=, [VariableReference(if (mAttachInfo, []), Expression(, [])])    VariableReference(if (mAttachInfo, [])    Expression(, [])  Statement(return null, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(mLayer, []), Expression(mAttachInfo.mHardwareRenderer.createTextureLayer(), [])])    VariableReference(mLayer, [])    Expression(mAttachInfo.mHardwareRenderer.createTextureLayer(), [])  AssignmentExpression(=, [VariableReference(boolean createNewSurface, []), Expression((mSurface, [])])    VariableReference(boolean createNewSurface, [])    Expression((mSurface, [])  Statement(if (createNewSurface) {, [])  Statement(// Create a new SurfaceTexture for the layer., [])  AssignmentExpression(=, [VariableReference(mSurface, []), Expression(new SurfaceTexture(false), [])])    VariableReference(mSurface, [])    Expression(new SurfaceTexture(false), [])  Statement(nCreateNativeWindow(mSurface), [])  Statement(}, [])  MethodCall(mLayer.setSurfaceTexture(mSurface), [VariableReference(mLayer, []), Expression(mSurface, [])])    VariableReference(mLayer, [])    Expression(mSurface, [])  MethodCall(mSurface.setDefaultBufferSize(getWidth(), getHeight()), [VariableReference(mSurface, []), Expression(getWidth(), []), Expression(getHeight(), [])])    VariableReference(mSurface, [])    Expression(getWidth(), [])    Expression(getHeight(), [])  MethodCall(mSurface.setOnFrameAvailableListener(mUpdateListener, mAttachInfo.mHandler), [VariableReference(mSurface, []), Expression(mUpdateListener, []), Expression(mAttachInfo.mHandler, [])])    VariableReference(mSurface, [])    Expression(mUpdateListener, [])    Expression(mAttachInfo.mHandler, [])  AssignmentExpression(=, [VariableReference(if (mListener !, []), Expression(null && createNewSurface) {, [])])    VariableReference(if (mListener !, [])    Expression(null && createNewSurface) {, [])  MethodCall(mListener.onSurfaceTextureAvailable(mSurface, getWidth(), getHeight()), [VariableReference(mListener, []), Expression(mSurface, []), Expression(getWidth(), []), Expression(getHeight(), [])])    VariableReference(mListener, [])    Expression(mSurface, [])    Expression(getWidth(), [])    Expression(getHeight(), [])  Statement(}, [])  MethodCall(mLayer.setLayerPaint(mLayerPaint), [VariableReference(mLayer, []), Expression(mLayerPaint, [])])    VariableReference(mLayer, [])    Expression(mLayerPaint, [])  Statement(}, [])  Statement(if (mUpdateSurface) {, [])  Statement(// Someone has requested that we use a specific SurfaceTexture, so, [])  Statement(// tell mLayer about it and set the SurfaceTexture to use the, [])  Statement(// current view size., [])  AssignmentExpression(=, [VariableReference(mUpdateSurface, []), Expression(false, [])])    VariableReference(mUpdateSurface, [])    Expression(false, [])  Statement(// Since we are updating the layer, force an update to ensure its, [])  Statement(updateLayer(), [])  AssignmentExpression(=, [VariableReference(mMatrixChanged, []), Expression(true, [])])    VariableReference(mMatrixChanged, [])    Expression(true, [])  MethodCall(mLayer.setSurfaceTexture(mSurface), [VariableReference(mLayer, []), Expression(mSurface, [])])    VariableReference(mLayer, [])    Expression(mSurface, [])  MethodCall(mSurface.setDefaultBufferSize(getWidth(), getHeight()), [VariableReference(mSurface, []), Expression(getWidth(), []), Expression(getHeight(), [])])    VariableReference(mSurface, [])    Expression(getWidth(), [])    Expression(getHeight(), [])  Statement(}, [])  Statement(return mLayer, [])  Statement(}, [])",1,,,0,,,0,,,,"1,2","3,4,5",1,"3,4",0,"The changes include introducing a variable `createNewSurface` and modifying the condition statements, along with other structural changes to the method body but not affecting the return or exceptions. Hence the changes are classified as 3 (Control dependency changed) and 4 (Other statement changed).","The changes do not alter the method's return value or the way exceptions are handled, so no compatibility issue is introduced, hence the CI type is 0."
117,<android.nfc.NfcAdapter: void disableReaderMode(Activity)>,24,25,,,,"MethodDeclaration(method_body, [Statement({, []), MethodCall(mNfcActivityManager.disableReaderMode(activity), [VariableReference(mNfcActivityManager, []), Expression(activity, [])]), Statement(}, [])])  Statement({, [])  MethodCall(mNfcActivityManager.disableReaderMode(activity), [VariableReference(mNfcActivityManager, []), Expression(activity, [])])    VariableReference(mNfcActivityManager, [])    Expression(activity, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(if (!sHasNfcFeature) {, []), Statement(throw new UnsupportedOperationException(), []), Statement(}, []), Statement(}, []), MethodCall(mNfcActivityManager.disableReaderMode(activity), [VariableReference(mNfcActivityManager, []), Expression(activity, [])]), Statement(}, [])])  Statement({, [])  Statement(if (!sHasNfcFeature) {, [])  Statement(throw new UnsupportedOperationException(), [])  Statement(}, [])  Statement(}, [])  MethodCall(mNfcActivityManager.disableReaderMode(activity), [VariableReference(mNfcActivityManager, []), Expression(activity, [])])    VariableReference(mNfcActivityManager, [])    Expression(activity, [])  Statement(}, [])",1,"/**
 * Restore the NFC adapter to normal mode of operation: supporting
 * peer-to-peer (Android Beam), card emulation, and polling for
 * all supported tag technologies.
 *
 * @param activity the Activity that currently has reader mode enabled
 */
","/**
 * Restore the NFC adapter to normal mode of operation: supporting
 * peer-to-peer (Android Beam), card emulation, and polling for
 * all supported tag technologies.
 *
 * @param activity the Activity that currently has reader mode enabled
 * @throws UnsupportedOperationException if FEATURE_NFC is unavailable.
 */
",1,,,0,,,,"1,2","2,3,4","1,2","2,3",2,"The new implementation introduces an `if` condition and throws `UnsupportedOperationException` if `sHasNfcFeature` is false, so the change type is 2,3.","Introducing a new `UnsupportedOperationException` when `sHasNfcFeature` is false could lead to different exception handling behaviors, so the CI type is 2."
118,<android.app.admin.DevicePolicyManager: int getPasswordMinimumLength(ComponentName)>,24,25,,,,"MethodDeclaration(method_body, [Statement({, []), Statement(return getPasswordMinimumLength(admin, myUserId()), []), Statement(}, [])])  Statement({, [])  Statement(return getPasswordMinimumLength(admin, myUserId()), [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(return getPasswordMinimumLength(admin, myUserId()), []), Statement(}, [])])  Statement({, [])  Statement(return getPasswordMinimumLength(admin, myUserId()), [])  Statement(}, [])",0,"/**
 * Retrieve the current minimum password length for a particular admin or all admins that set
 * retrictions on this user and its participating profiles. Restrictions on profiles that have
 * a separate challenge are not taken into account.
 *
 * <p>This method can be called on the {@link DevicePolicyManager} instance
 * returned by {@link #getParentProfileInstance(ComponentName)} in order to retrieve
 * restrictions on the parent profile.
 *
 * user and its profiles or a particular one.
 * @param admin The name of the admin component to check, or {@code null} to aggregate
 * all admins.
 */
","/**
 * Retrieve the current minimum password length for a particular admin or all admins that set
 * restrictions on this user and its participating profiles. Restrictions on profiles that have
 * a separate challenge are not taken into account.
 *
 * <p>This method can be called on the {@link DevicePolicyManager} instance
 * returned by {@link #getParentProfileInstance(ComponentName)} in order to retrieve
 * restrictions on the parent profile.
 *
 * user and its profiles or a particular one.
 * @param admin The name of the admin component to check, or {@code null} to aggregate
 * all admins.
 */
",1,,,0,,,,0,0,0,0,0,"There is no change in the implementation, comments, or annotations between the early and late versions.",No compatibility issue exists as there is no change in the code or functionality.
119,"<android.provider.DocumentsProvider: String copyDocument(String,String)>",25,26,,,,"MethodDeclaration(method_body, [Statement({, []), Statement(throw new UnsupportedOperationException(""Copy not supported""), []), Statement(}, [])])  Statement({, [])  Statement(throw new UnsupportedOperationException(""Copy not supported""), [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(throw new UnsupportedOperationException(""Copy not supported""), []), Statement(}, [])])  Statement({, [])  Statement(throw new UnsupportedOperationException(""Copy not supported""), [])  Statement(}, [])",0,"/**
 * Copy the requested document or a document tree.
 * <p>
 * Copies a document including all child documents to another location within
 * the same document provider. Upon completion returns the document id of
 * the copied document at the target destination. {@code null} must never
 * be returned.
 *
 * @param sourceDocumentId the document to copy.
 * @param targetParentDocumentId the target document to be copied into as a child.
 */
","/**
 * Copy the requested document or a document tree.
 * <p>
 * Copies a document including all child documents to another location within
 * the same document provider. Upon completion returns the document id of
 * the copied document at the target destination. {@code null} must never
 * be returned.
 *
 * @param sourceDocumentId the document to copy.
 * @param targetParentDocumentId the target document to be copied into as a child.
 * @throws AuthenticationRequiredException If authentication is required from
 * the user (such as login credentials), but it is not guaranteed
 * that the client will handle this properly.
 */
",1,[@SuppressWarnings("unused")],[@SuppressWarnings("unused")],0,,,,0,0,0,2,0,"Even though there's an additional exception (`AuthenticationRequiredException`) mentioned in the late version's comment, the implementation of the method in both versions remains the same. Hence, no code change has occurred within the implementation itself.","Since the method implementation hasn't changed between the early and late versions, there are no compatibility issues."
120,<android.widget.TextView: void onCommitCorrection(CorrectionInfo)>,25,26,,,,"MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(if (mEditor !, []), Expression(null), [])]), MethodCall(mEditor.onCommitCorrection(info), [VariableReference(mEditor, []), Expression(info, [])]), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(if (mEditor !, []), Expression(null), [])])    VariableReference(if (mEditor !, [])    Expression(null), [])  MethodCall(mEditor.onCommitCorrection(info), [VariableReference(mEditor, []), Expression(info, [])])    VariableReference(mEditor, [])    Expression(info, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(if (mEditor !, []), Expression(null), [])]), MethodCall(mEditor.onCommitCorrection(info), [VariableReference(mEditor, []), Expression(info, [])]), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(if (mEditor !, []), Expression(null), [])])    VariableReference(if (mEditor !, [])    Expression(null), [])  MethodCall(mEditor.onCommitCorrection(info), [VariableReference(mEditor, []), Expression(info, [])])    VariableReference(mEditor, [])    Expression(info, [])  Statement(}, [])",0,"/**
 * Called by the framework in response to a text auto-correction (such as fixing a typo using a
 * a dictionnary) from the current input method, provided by it calling
 * {@link InputConnection#commitCorrection} InputConnection.commitCorrection()}. The default
 * implementation flashes the background of the corrected word to provide feedback to the user.
 *
 * @param info The auto correct info about the text that was corrected.
 */
","/**
 * Called by the framework in response to a text auto-correction (such as fixing a typo using a
 * dictionary) from the current input method, provided by it calling
 * {@link InputConnection#commitCorrection(CorrectionInfo) InputConnection.commitCorrection()}.
 * The default implementation flashes the background of the corrected word to provide
 * feedback to the user.
 *
 * @param info The auto correct info about the text that was corrected.
 */
",1,,,0,,,,0,0,0,0,0,"According to the given AST nodes, there is no change in the method implementation, comments, or annotations between the early and late versions. Thus, the code change type is 0.","Since there is no change in the code, no compatibility issues exist."
121,<android.appwidget.AppWidgetManager: List<AppWidgetProviderInfo> getInstalledProvidersForProfile(UserHandle)>,25,26,,,,"MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(if (mService, []), Expression(, [])]), MethodCall(return Collections.emptyList(), [VariableReference(return Collections, []), Expression(, [])]), Statement(}, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(if (mService, []), Expression(, [])])    VariableReference(if (mService, [])    Expression(, [])  MethodCall(return Collections.emptyList(), [VariableReference(return Collections, []), Expression(, [])])    VariableReference(return Collections, [])    Expression(, [])  Statement(}, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(if (mService, []), Expression(, [])]), MethodCall(return Collections.emptyList(), [VariableReference(return Collections, []), Expression(, [])]), Statement(}, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(if (mService, []), Expression(, [])])    VariableReference(if (mService, [])    Expression(, [])  MethodCall(return Collections.emptyList(), [VariableReference(return Collections, []), Expression(, [])])    VariableReference(return Collections, [])    Expression(, [])  Statement(}, [])  Statement(}, [])",1,"/**
 * Gets the AppWidget providers for the given user profile. User profile can only
 * be the current user or a profile of the current user. For example, the current
 * user may have a corporate profile. In this case the parent user profile has a
 * child profile, the corporate one.
 *
 * @param profile The profile for which to get providers. Passing null is equivaled
 * to passing only the current user handle.
 * @return The intalled providers.
 *
 * @see android.os.Process#myUserHandle()
 * @see android.os.UserManager#getUserProfiles()
 */
","/**
 * Gets the AppWidget providers for the given user profile. User profile can only
 * be the current user or a profile of the current user. For example, the current
 * user may have a corporate profile. In this case the parent user profile has a
 * child profile, the corporate one.
 *
 * @param profile The profile for which to get providers. Passing null is equivalent
 * to querying for only the calling user.
 * @return The installed providers, or an empty list if none are found for the given user.
 *
 * @see android.os.Process#myUserHandle()
 * @see android.os.UserManager#getUserProfiles()
 */
",1,,[@NonNull],1,,,,2,"1,5",1,0,0,"Upon examining the provided AST nodes and the method body, it is evident that there are no differences between the early and late implementations. Thus, the code change type is 0.","Since there are no changes in the code, there is no potential for a change in behavior. Therefore, no Compatibility Issue exists (CI type is 0)."
122,"<android.view.View: boolean onKeyDown(int,KeyEvent)>",25,26,,,,"MethodDeclaration(method_body, [Statement({, []), MethodCall(if (KeyEvent.isConfirmKey(keyCode)), [VariableReference(if (KeyEvent, []), Expression(keyCode), [])]), AssignmentExpression(=, [VariableReference(if ((mViewFlags & ENABLED_MASK), []), Expression(, [])]), Statement(return true, []), Statement(}, []), Statement(// Long clickable items don't necessarily have to be clickable., []), AssignmentExpression(=, [VariableReference(if (((mViewFlags & CLICKABLE), []), Expression(, [])]), Statement(// For the purposes of menu anchoring and drawable hotspots,, []), Statement(// key events are considered to be at the center of the view., []), AssignmentExpression(=, [VariableReference(final float x, []), Expression(getWidth() / 2f, [])]), AssignmentExpression(=, [VariableReference(final float y, []), Expression(getHeight() / 2f, [])]), Statement(setPressed(true, x, y), []), Statement(checkForLongClick(0, x, y), []), Statement(return true, []), Statement(}, []), Statement(}, []), Statement(return false, []), Statement(}, [])])  Statement({, [])  MethodCall(if (KeyEvent.isConfirmKey(keyCode)), [VariableReference(if (KeyEvent, []), Expression(keyCode), [])])    VariableReference(if (KeyEvent, [])    Expression(keyCode), [])  AssignmentExpression(=, [VariableReference(if ((mViewFlags & ENABLED_MASK), []), Expression(, [])])    VariableReference(if ((mViewFlags & ENABLED_MASK), [])    Expression(, [])  Statement(return true, [])  Statement(}, [])  Statement(// Long clickable items don't necessarily have to be clickable., [])  AssignmentExpression(=, [VariableReference(if (((mViewFlags & CLICKABLE), []), Expression(, [])])    VariableReference(if (((mViewFlags & CLICKABLE), [])    Expression(, [])  Statement(// For the purposes of menu anchoring and drawable hotspots,, [])  Statement(// key events are considered to be at the center of the view., [])  AssignmentExpression(=, [VariableReference(final float x, []), Expression(getWidth() / 2f, [])])    VariableReference(final float x, [])    Expression(getWidth() / 2f, [])  AssignmentExpression(=, [VariableReference(final float y, []), Expression(getHeight() / 2f, [])])    VariableReference(final float y, [])    Expression(getHeight() / 2f, [])  Statement(setPressed(true, x, y), [])  Statement(checkForLongClick(0, x, y), [])  Statement(return true, [])  Statement(}, [])  Statement(}, [])  Statement(return false, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), MethodCall(if (KeyEvent.isConfirmKey(keyCode)), [VariableReference(if (KeyEvent, []), Expression(keyCode), [])]), AssignmentExpression(=, [VariableReference(if ((mViewFlags & ENABLED_MASK), []), Expression(, [])]), Statement(return true, []), Statement(}, []), AssignmentExpression(=, [VariableReference(if (event.getRepeatCount(), []), Expression(, [])]), Statement(// Long clickable items don't necessarily have to be clickable., []), AssignmentExpression(=, [VariableReference(final boolean clickable, []), Expression((mViewFlags & CLICKABLE), [])]), AssignmentExpression(=, [VariableReference(if (clickable || (mViewFlags & TOOLTIP), []), Expression(, [])]), Statement(// For the purposes of menu anchoring and drawable hotspots,, []), Statement(// key events are considered to be at the center of the view., []), AssignmentExpression(=, [VariableReference(final float x, []), Expression(getWidth() / 2f, [])]), AssignmentExpression(=, [VariableReference(final float y, []), Expression(getHeight() / 2f, [])]), Statement(if (clickable) {, []), Statement(setPressed(true, x, y), []), Statement(}, []), Statement(checkForLongClick(0, x, y), []), Statement(return true, []), Statement(}, []), Statement(}, []), Statement(}, []), Statement(return false, []), Statement(}, [])])  Statement({, [])  MethodCall(if (KeyEvent.isConfirmKey(keyCode)), [VariableReference(if (KeyEvent, []), Expression(keyCode), [])])    VariableReference(if (KeyEvent, [])    Expression(keyCode), [])  AssignmentExpression(=, [VariableReference(if ((mViewFlags & ENABLED_MASK), []), Expression(, [])])    VariableReference(if ((mViewFlags & ENABLED_MASK), [])    Expression(, [])  Statement(return true, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(if (event.getRepeatCount(), []), Expression(, [])])    VariableReference(if (event.getRepeatCount(), [])    Expression(, [])  Statement(// Long clickable items don't necessarily have to be clickable., [])  AssignmentExpression(=, [VariableReference(final boolean clickable, []), Expression((mViewFlags & CLICKABLE), [])])    VariableReference(final boolean clickable, [])    Expression((mViewFlags & CLICKABLE), [])  AssignmentExpression(=, [VariableReference(if (clickable || (mViewFlags & TOOLTIP), []), Expression(, [])])    VariableReference(if (clickable || (mViewFlags & TOOLTIP), [])    Expression(, [])  Statement(// For the purposes of menu anchoring and drawable hotspots,, [])  Statement(// key events are considered to be at the center of the view., [])  AssignmentExpression(=, [VariableReference(final float x, []), Expression(getWidth() / 2f, [])])    VariableReference(final float x, [])    Expression(getWidth() / 2f, [])  AssignmentExpression(=, [VariableReference(final float y, []), Expression(getHeight() / 2f, [])])    VariableReference(final float y, [])    Expression(getHeight() / 2f, [])  Statement(if (clickable) {, [])  Statement(setPressed(true, x, y), [])  Statement(}, [])  Statement(checkForLongClick(0, x, y), [])  Statement(return true, [])  Statement(}, [])  Statement(}, [])  Statement(}, [])  Statement(return false, [])  Statement(}, [])",1,"/**
 * Default implementation of {@link KeyEvent.Callback#onKeyDown(int, KeyEvent)
 * KeyEvent.Callback.onKeyDown()}: perform press of the view
 * when {@link KeyEvent#KEYCODE_DPAD_CENTER} or {@link KeyEvent#KEYCODE_ENTER}
 * is released, if the view is enabled and clickable.
 * <p>
 * Key presses in software keyboards will generally NOT trigger this
 * listener, although some may elect to do so in some situations. Do not
 * rely on this to catch software key presses.
 *
 * @param keyCode a key code that represents the button pressed, from
 * {@link android.view.KeyEvent}
 * @param event the KeyEvent object that defines the button action
 */
","/**
 * Default implementation of {@link KeyEvent.Callback#onKeyDown(int, KeyEvent)
 * KeyEvent.Callback.onKeyDown()}: perform press of the view
 * when {@link KeyEvent#KEYCODE_DPAD_CENTER} or {@link KeyEvent#KEYCODE_ENTER}
 * is released, if the view is enabled and clickable.
 * <p>
 * Key presses in software keyboards will generally NOT trigger this
 * listener, although some may elect to do so in some situations. Do not
 * rely on this to catch software key presses.
 *
 * @param keyCode a key code that represents the button pressed, from
 * {@link android.view.KeyEvent}
 * @param event the KeyEvent object that defines the button action
 */
",0,,,0,,,,"1,2","3,4",1,"3,4",0,"There are control dependency changes with the addition of new conditions (like `event.getRepeatCount()`, `clickable || (mViewFlags & TOOLTIP)`), and other statements regarding boolean flag `clickable` and repetition count in the `if` conditions. Hence, the change types are 3,4.","The control dependency changes and added statements do not fundamentally change the potential return values or exception handling of the API, as the original logic is preserved. Therefore, no compatibility issue exists."
123,<android.text.method.TimeKeyListener: TimeKeyListener getInstance()>,25,26,,,,"MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(if (sInstance !, []), Expression(null), [])]), Statement(return sInstance, []), AssignmentExpression(=, [VariableReference(sInstance, []), Expression(new TimeKeyListener(), [])]), Statement(return sInstance, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(if (sInstance !, []), Expression(null), [])])    VariableReference(if (sInstance !, [])    Expression(null), [])  Statement(return sInstance, [])  AssignmentExpression(=, [VariableReference(sInstance, []), Expression(new TimeKeyListener(), [])])    VariableReference(sInstance, [])    Expression(new TimeKeyListener(), [])  Statement(return sInstance, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(return getInstance(null), []), Statement(}, [])])  Statement({, [])  Statement(return getInstance(null), [])  Statement(}, [])",1,,"/**
 * @deprecated Use {@link #getInstance(Locale)} instead.
 */
",1,,"[@Deprecated, @NonNull]",1,,,,"1,2","1,3,5",1,"1,5",1,"The early implementation directly manipulates the `sInstance` variable and returns it, whereas the late implementation calls `getInstance(null)` and returns its result. Hence, the return statement and the dependent API have changed. Additionally, the method is now annotated with `@Deprecated` and `@NonNull`. So, the change type is 1 and 5.","The change in how the instance is obtained could result in different return values or behaviors, leading to a potential compatibility issue. Therefore, the CI type is 1."
124,"<android.app.assist.AssistStructure.ParcelTransferWriter: void writeView(ViewNode,Parcel,PooledStringWriter,int)>",25,26,,,,"MethodDeclaration(method_body, [Statement({, []), Statement(if (DEBUG_PARCEL), []), AssignmentExpression(=, [VariableReference(Log.d(TAG, ""write view: at "" + out.dataPosition() + "", windows, []), Expression("" + mNumWrittenWindows + "", views, [])]), MethodCall(out.writeInt(VALIDATE_VIEW_TOKEN), [VariableReference(out, []), Expression(VALIDATE_VIEW_TOKEN, [])]), AssignmentExpression(=, [VariableReference(int flags, []), Expression(child.writeSelfToParcel(out, pwriter, mTmpMatrix), [])]), Statement(mNumWrittenViews++, []), Statement(// If the child has children, push it on the stack to write them next., []), AssignmentExpression(=, [VariableReference(if ((flags & ViewNode.FLAGS_HAS_CHILDREN) !, []), Expression(0) {, [])]), Statement(if (DEBUG_PARCEL_TREE || DEBUG_PARCEL_CHILDREN), []), MethodCall(Log.d(TAG, ""Preparing to write "" + child.mChildren.length + "" children: @ #"" + mNumWrittenViews + "", level "" + (mCurViewStackPos + levelAdj)), [VariableReference(Log, []), Expression(TAG, []), Expression(""Preparing to write "" + child.mChildren.length + "" children: @ #"" + mNumWrittenViews + "", []), Expression(level "" + (mCurViewStackPos + levelAdj), [])]), MethodCall(out.writeInt(child.mChildren.length), [VariableReference(out, []), Expression(child.mChildren.length, [])]), AssignmentExpression(=, [VariableReference(int pos, []), Expression(++mCurViewStackPos, [])]), Statement(pushViewStackEntry(child, pos), []), Statement(}, []), Statement(}, [])])  Statement({, [])  Statement(if (DEBUG_PARCEL), [])  AssignmentExpression(=, [VariableReference(Log.d(TAG, ""write view: at "" + out.dataPosition() + "", windows, []), Expression("" + mNumWrittenWindows + "", views, [])])    VariableReference(Log.d(TAG, ""write view: at "" + out.dataPosition() + "", windows, [])    Expression("" + mNumWrittenWindows + "", views, [])  MethodCall(out.writeInt(VALIDATE_VIEW_TOKEN), [VariableReference(out, []), Expression(VALIDATE_VIEW_TOKEN, [])])    VariableReference(out, [])    Expression(VALIDATE_VIEW_TOKEN, [])  AssignmentExpression(=, [VariableReference(int flags, []), Expression(child.writeSelfToParcel(out, pwriter, mTmpMatrix), [])])    VariableReference(int flags, [])    Expression(child.writeSelfToParcel(out, pwriter, mTmpMatrix), [])  Statement(mNumWrittenViews++, [])  Statement(// If the child has children, push it on the stack to write them next., [])  AssignmentExpression(=, [VariableReference(if ((flags & ViewNode.FLAGS_HAS_CHILDREN) !, []), Expression(0) {, [])])    VariableReference(if ((flags & ViewNode.FLAGS_HAS_CHILDREN) !, [])    Expression(0) {, [])  Statement(if (DEBUG_PARCEL_TREE || DEBUG_PARCEL_CHILDREN), [])  MethodCall(Log.d(TAG, ""Preparing to write "" + child.mChildren.length + "" children: @ #"" + mNumWrittenViews + "", level "" + (mCurViewStackPos + levelAdj)), [VariableReference(Log, []), Expression(TAG, []), Expression(""Preparing to write "" + child.mChildren.length + "" children: @ #"" + mNumWrittenViews + "", []), Expression(level "" + (mCurViewStackPos + levelAdj), [])])    VariableReference(Log, [])    Expression(TAG, [])    Expression(""Preparing to write "" + child.mChildren.length + "" children: @ #"" + mNumWrittenViews + "", [])    Expression(level "" + (mCurViewStackPos + levelAdj), [])  MethodCall(out.writeInt(child.mChildren.length), [VariableReference(out, []), Expression(child.mChildren.length, [])])    VariableReference(out, [])    Expression(child.mChildren.length, [])  AssignmentExpression(=, [VariableReference(int pos, []), Expression(++mCurViewStackPos, [])])    VariableReference(int pos, [])    Expression(++mCurViewStackPos, [])  Statement(pushViewStackEntry(child, pos), [])  Statement(}, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(if (DEBUG_PARCEL), []), AssignmentExpression(=, [VariableReference(Log.d(TAG, ""write view: at "" + out.dataPosition() + "", windows, []), Expression("" + mNumWrittenWindows + "", views, [])]), MethodCall(out.writeInt(VALIDATE_VIEW_TOKEN), [VariableReference(out, []), Expression(VALIDATE_VIEW_TOKEN, [])]), AssignmentExpression(=, [VariableReference(int flags, []), Expression(child.writeSelfToParcel(out, pwriter, mSanitizeOnWrite, mTmpMatrix), [])]), Statement(mNumWrittenViews++, []), Statement(// If the child has children, push it on the stack to write them next., []), AssignmentExpression(=, [VariableReference(if ((flags & ViewNode.FLAGS_HAS_CHILDREN) !, []), Expression(0) {, [])]), Statement(if (DEBUG_PARCEL_TREE || DEBUG_PARCEL_CHILDREN), []), MethodCall(Log.d(TAG, ""Preparing to write "" + child.mChildren.length + "" children: @ #"" + mNumWrittenViews + "", level "" + (mCurViewStackPos + levelAdj)), [VariableReference(Log, []), Expression(TAG, []), Expression(""Preparing to write "" + child.mChildren.length + "" children: @ #"" + mNumWrittenViews + "", []), Expression(level "" + (mCurViewStackPos + levelAdj), [])]), MethodCall(out.writeInt(child.mChildren.length), [VariableReference(out, []), Expression(child.mChildren.length, [])]), AssignmentExpression(=, [VariableReference(int pos, []), Expression(++mCurViewStackPos, [])]), Statement(pushViewStackEntry(child, pos), []), Statement(}, []), Statement(}, [])])  Statement({, [])  Statement(if (DEBUG_PARCEL), [])  AssignmentExpression(=, [VariableReference(Log.d(TAG, ""write view: at "" + out.dataPosition() + "", windows, []), Expression("" + mNumWrittenWindows + "", views, [])])    VariableReference(Log.d(TAG, ""write view: at "" + out.dataPosition() + "", windows, [])    Expression("" + mNumWrittenWindows + "", views, [])  MethodCall(out.writeInt(VALIDATE_VIEW_TOKEN), [VariableReference(out, []), Expression(VALIDATE_VIEW_TOKEN, [])])    VariableReference(out, [])    Expression(VALIDATE_VIEW_TOKEN, [])  AssignmentExpression(=, [VariableReference(int flags, []), Expression(child.writeSelfToParcel(out, pwriter, mSanitizeOnWrite, mTmpMatrix), [])])    VariableReference(int flags, [])    Expression(child.writeSelfToParcel(out, pwriter, mSanitizeOnWrite, mTmpMatrix), [])  Statement(mNumWrittenViews++, [])  Statement(// If the child has children, push it on the stack to write them next., [])  AssignmentExpression(=, [VariableReference(if ((flags & ViewNode.FLAGS_HAS_CHILDREN) !, []), Expression(0) {, [])])    VariableReference(if ((flags & ViewNode.FLAGS_HAS_CHILDREN) !, [])    Expression(0) {, [])  Statement(if (DEBUG_PARCEL_TREE || DEBUG_PARCEL_CHILDREN), [])  MethodCall(Log.d(TAG, ""Preparing to write "" + child.mChildren.length + "" children: @ #"" + mNumWrittenViews + "", level "" + (mCurViewStackPos + levelAdj)), [VariableReference(Log, []), Expression(TAG, []), Expression(""Preparing to write "" + child.mChildren.length + "" children: @ #"" + mNumWrittenViews + "", []), Expression(level "" + (mCurViewStackPos + levelAdj), [])])    VariableReference(Log, [])    Expression(TAG, [])    Expression(""Preparing to write "" + child.mChildren.length + "" children: @ #"" + mNumWrittenViews + "", [])    Expression(level "" + (mCurViewStackPos + levelAdj), [])  MethodCall(out.writeInt(child.mChildren.length), [VariableReference(out, []), Expression(child.mChildren.length, [])])    VariableReference(out, [])    Expression(child.mChildren.length, [])  AssignmentExpression(=, [VariableReference(int pos, []), Expression(++mCurViewStackPos, [])])    VariableReference(int pos, [])    Expression(++mCurViewStackPos, [])  Statement(pushViewStackEntry(child, pos), [])  Statement(}, [])  Statement(}, [])",1,,,0,,,0,,,,2,5,1,"4,5",0,"The method call **child.writeSelfToParcel(out, pwriter, mTmpMatrix)** has been modified to **child.writeSelfToParcel(out, pwriter, mSanitizeOnWrite, mTmpMatrix)**. This indicates that an additional argument has been added to the child.writeSelfToParcel method call, making this both a change in statements (4) and a change in the dependent API (5).","Although there is a change in the dependent API and an additional argument is being passed to the method child.writeSelfToParcel, this change does not affect the return type or exception handling directly in the writeView method. Therefore, the CI type is 0."
125,<android.text.TextUtils: boolean isEmpty(CharSequence)>,25,26,,,,"MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(if (str, []), Expression(, [])]), Statement(return true, []), Statement(else, []), Statement(return false, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(if (str, []), Expression(, [])])    VariableReference(if (str, [])    Expression(, [])  Statement(return true, [])  Statement(else, [])  Statement(return false, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(return str, []), Expression(, [])]), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(return str, []), Expression(, [])])    VariableReference(return str, [])    Expression(, [])  Statement(}, [])",1,"/**
 * Returns true if the string is null or 0-length.
 * @param str the string to be examined
 * @return true if str is null or zero length
 */
","/**
 * Returns true if the string is null or 0-length.
 * @param str the string to be examined
 * @return true if str is null or zero length
 */
",0,,,0,,,,1,"1,3",1,1,1,"The early implementation involves a conditional check and returns true if the string is null or empty and false otherwise. The late implementation simply returns the string itself, bypassing the logical check for null or empty. This change affects the return value directly, so the change type is 1.","Since the late version's implementation directly returns the `str` parameter instead of performing the logical check and returning a boolean value, the return values could be different under the same conditions. Therefore, the CI type is 1."
126,<android.widget.TextView: void setMinWidth(int)>,25,26,,,,"MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(mMinWidth, []), Expression(minpixels, [])]), AssignmentExpression(=, [VariableReference(mMinWidthMode, []), Expression(PIXELS, [])]), Statement(requestLayout(), []), Statement(invalidate(), []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(mMinWidth, []), Expression(minpixels, [])])    VariableReference(mMinWidth, [])    Expression(minpixels, [])  AssignmentExpression(=, [VariableReference(mMinWidthMode, []), Expression(PIXELS, [])])    VariableReference(mMinWidthMode, [])    Expression(PIXELS, [])  Statement(requestLayout(), [])  Statement(invalidate(), [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(mMinWidth, []), Expression(minPixels, [])]), AssignmentExpression(=, [VariableReference(mMinWidthMode, []), Expression(PIXELS, [])]), Statement(requestLayout(), []), Statement(invalidate(), []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(mMinWidth, []), Expression(minPixels, [])])    VariableReference(mMinWidth, [])    Expression(minPixels, [])  AssignmentExpression(=, [VariableReference(mMinWidthMode, []), Expression(PIXELS, [])])    VariableReference(mMinWidthMode, [])    Expression(PIXELS, [])  Statement(requestLayout(), [])  Statement(invalidate(), [])  Statement(}, [])",1,"/**
 * Makes the TextView at least this many pixels wide
 *
 * @attr ref android.R.styleable#TextView_minWidth
 */
","/**
 * Sets the width of the TextView to be at least {@code minPixels} wide.
 * <p>
 * This value is used for width calculation if LayoutParams does not force TextView to have an
 * exact width. Setting this value overrides previous minimum width configurations such as
 * {@link #setMinEms(int)} or {@link #setEms(int)}.
 * <p>
 * The value given here is different than {@link #setMinimumWidth(int)}. Between
 * {@code minWidth} and the value set in {@link #setMinimumWidth(int)}, the greater one is used
 * to decide the final width.
 *
 * @param minPixels the minimum width of TextView in terms of pixels
 *
 * @see #getMinWidth()
 * @see #setWidth(int)
 *
 * @attr ref android.R.styleable#TextView_minWidth
 */
",1,[@android.view.RemotableViewMethod],[@android.view.RemotableViewMethod],0,,,,1,4,0,0,0,There is no change in the method implementation between the early and late versions.,"Since there are no changes in the method's actual code, there is no possibility of a compatibility issue."
127,<android.service.notification.NotificationListenerService.MyHandler: void handleMessage(Message)>,25,26,,,,"MethodDeclaration(method_body, [Statement({, []), Statement(if (!isConnected) {, []), Statement(return, []), Statement(}, []), Statement(case MSG_ON_NOTIFICATION_POSTED:, []), Statement({, []), AssignmentExpression(=, [VariableReference(SomeArgs args, []), Expression((SomeArgs) msg.obj, [])]), AssignmentExpression(=, [VariableReference(StatusBarNotification sbn, []), Expression((StatusBarNotification) args.arg1, [])]), AssignmentExpression(=, [VariableReference(RankingMap rankingMap, []), Expression((RankingMap) args.arg2, [])]), MethodCall(args.recycle(), [VariableReference(args, []), Expression(, [])]), Statement(onNotificationPosted(sbn, rankingMap), []), Statement(}, []), Statement(break, []), Statement(case MSG_ON_NOTIFICATION_REMOVED:, []), Statement({, []), AssignmentExpression(=, [VariableReference(SomeArgs args, []), Expression((SomeArgs) msg.obj, [])]), AssignmentExpression(=, [VariableReference(StatusBarNotification sbn, []), Expression((StatusBarNotification) args.arg1, [])]), AssignmentExpression(=, [VariableReference(RankingMap rankingMap, []), Expression((RankingMap) args.arg2, [])]), MethodCall(args.recycle(), [VariableReference(args, []), Expression(, [])]), Statement(onNotificationRemoved(sbn, rankingMap), []), Statement(}, []), Statement(break, []), Statement(case MSG_ON_LISTENER_CONNECTED:, []), Statement({, []), Statement(onListenerConnected(), []), Statement(}, []), Statement(break, []), Statement(case MSG_ON_NOTIFICATION_RANKING_UPDATE:, []), Statement({, []), AssignmentExpression(=, [VariableReference(RankingMap rankingMap, []), Expression((RankingMap) msg.obj, [])]), Statement(onNotificationRankingUpdate(rankingMap), []), Statement(}, []), Statement(break, []), Statement(case MSG_ON_LISTENER_HINTS_CHANGED:, []), Statement({, []), AssignmentExpression(=, [VariableReference(final int hints, []), Expression(msg.arg1, [])]), Statement(onListenerHintsChanged(hints), []), Statement(}, []), Statement(break, []), Statement(case MSG_ON_INTERRUPTION_FILTER_CHANGED:, []), Statement({, []), AssignmentExpression(=, [VariableReference(final int interruptionFilter, []), Expression(msg.arg1, [])]), Statement(onInterruptionFilterChanged(interruptionFilter), []), Statement(}, []), Statement(break, []), Statement(}, []), Statement(}, [])])  Statement({, [])  Statement(if (!isConnected) {, [])  Statement(return, [])  Statement(}, [])  Statement(case MSG_ON_NOTIFICATION_POSTED:, [])  Statement({, [])  AssignmentExpression(=, [VariableReference(SomeArgs args, []), Expression((SomeArgs) msg.obj, [])])    VariableReference(SomeArgs args, [])    Expression((SomeArgs) msg.obj, [])  AssignmentExpression(=, [VariableReference(StatusBarNotification sbn, []), Expression((StatusBarNotification) args.arg1, [])])    VariableReference(StatusBarNotification sbn, [])    Expression((StatusBarNotification) args.arg1, [])  AssignmentExpression(=, [VariableReference(RankingMap rankingMap, []), Expression((RankingMap) args.arg2, [])])    VariableReference(RankingMap rankingMap, [])    Expression((RankingMap) args.arg2, [])  MethodCall(args.recycle(), [VariableReference(args, []), Expression(, [])])    VariableReference(args, [])    Expression(, [])  Statement(onNotificationPosted(sbn, rankingMap), [])  Statement(}, [])  Statement(break, [])  Statement(case MSG_ON_NOTIFICATION_REMOVED:, [])  Statement({, [])  AssignmentExpression(=, [VariableReference(SomeArgs args, []), Expression((SomeArgs) msg.obj, [])])    VariableReference(SomeArgs args, [])    Expression((SomeArgs) msg.obj, [])  AssignmentExpression(=, [VariableReference(StatusBarNotification sbn, []), Expression((StatusBarNotification) args.arg1, [])])    VariableReference(StatusBarNotification sbn, [])    Expression((StatusBarNotification) args.arg1, [])  AssignmentExpression(=, [VariableReference(RankingMap rankingMap, []), Expression((RankingMap) args.arg2, [])])    VariableReference(RankingMap rankingMap, [])    Expression((RankingMap) args.arg2, [])  MethodCall(args.recycle(), [VariableReference(args, []), Expression(, [])])    VariableReference(args, [])    Expression(, [])  Statement(onNotificationRemoved(sbn, rankingMap), [])  Statement(}, [])  Statement(break, [])  Statement(case MSG_ON_LISTENER_CONNECTED:, [])  Statement({, [])  Statement(onListenerConnected(), [])  Statement(}, [])  Statement(break, [])  Statement(case MSG_ON_NOTIFICATION_RANKING_UPDATE:, [])  Statement({, [])  AssignmentExpression(=, [VariableReference(RankingMap rankingMap, []), Expression((RankingMap) msg.obj, [])])    VariableReference(RankingMap rankingMap, [])    Expression((RankingMap) msg.obj, [])  Statement(onNotificationRankingUpdate(rankingMap), [])  Statement(}, [])  Statement(break, [])  Statement(case MSG_ON_LISTENER_HINTS_CHANGED:, [])  Statement({, [])  AssignmentExpression(=, [VariableReference(final int hints, []), Expression(msg.arg1, [])])    VariableReference(final int hints, [])    Expression(msg.arg1, [])  Statement(onListenerHintsChanged(hints), [])  Statement(}, [])  Statement(break, [])  Statement(case MSG_ON_INTERRUPTION_FILTER_CHANGED:, [])  Statement({, [])  AssignmentExpression(=, [VariableReference(final int interruptionFilter, []), Expression(msg.arg1, [])])    VariableReference(final int interruptionFilter, [])    Expression(msg.arg1, [])  Statement(onInterruptionFilterChanged(interruptionFilter), [])  Statement(}, [])  Statement(break, [])  Statement(}, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(if (!isConnected) {, []), Statement(return, []), Statement(}, []), Statement(case MSG_ON_NOTIFICATION_POSTED:, []), Statement({, []), AssignmentExpression(=, [VariableReference(SomeArgs args, []), Expression((SomeArgs) msg.obj, [])]), AssignmentExpression(=, [VariableReference(StatusBarNotification sbn, []), Expression((StatusBarNotification) args.arg1, [])]), AssignmentExpression(=, [VariableReference(RankingMap rankingMap, []), Expression((RankingMap) args.arg2, [])]), MethodCall(args.recycle(), [VariableReference(args, []), Expression(, [])]), Statement(onNotificationPosted(sbn, rankingMap), []), Statement(}, []), Statement(break, []), Statement(case MSG_ON_NOTIFICATION_REMOVED:, []), Statement({, []), AssignmentExpression(=, [VariableReference(SomeArgs args, []), Expression((SomeArgs) msg.obj, [])]), AssignmentExpression(=, [VariableReference(StatusBarNotification sbn, []), Expression((StatusBarNotification) args.arg1, [])]), AssignmentExpression(=, [VariableReference(RankingMap rankingMap, []), Expression((RankingMap) args.arg2, [])]), AssignmentExpression(=, [VariableReference(int reason, []), Expression((int) args.arg3, [])]), MethodCall(args.recycle(), [VariableReference(args, []), Expression(, [])]), Statement(onNotificationRemoved(sbn, rankingMap, reason), []), Statement(}, []), Statement(break, []), Statement(case MSG_ON_LISTENER_CONNECTED:, []), Statement({, []), Statement(onListenerConnected(), []), Statement(}, []), Statement(break, []), Statement(case MSG_ON_NOTIFICATION_RANKING_UPDATE:, []), Statement({, []), AssignmentExpression(=, [VariableReference(RankingMap rankingMap, []), Expression((RankingMap) msg.obj, [])]), Statement(onNotificationRankingUpdate(rankingMap), []), Statement(}, []), Statement(break, []), Statement(case MSG_ON_LISTENER_HINTS_CHANGED:, []), Statement({, []), AssignmentExpression(=, [VariableReference(final int hints, []), Expression(msg.arg1, [])]), Statement(onListenerHintsChanged(hints), []), Statement(}, []), Statement(break, []), Statement(case MSG_ON_INTERRUPTION_FILTER_CHANGED:, []), Statement({, []), AssignmentExpression(=, [VariableReference(final int interruptionFilter, []), Expression(msg.arg1, [])]), Statement(onInterruptionFilterChanged(interruptionFilter), []), Statement(}, []), Statement(break, []), Statement(case MSG_ON_NOTIFICATION_CHANNEL_MODIFIED:, []), Statement({, []), AssignmentExpression(=, [VariableReference(SomeArgs args, []), Expression((SomeArgs) msg.obj, [])]), AssignmentExpression(=, [VariableReference(String pkgName, []), Expression((String) args.arg1, [])]), AssignmentExpression(=, [VariableReference(UserHandle user, []), Expression((UserHandle) args.arg2, [])]), AssignmentExpression(=, [VariableReference(NotificationChannel channel, []), Expression((NotificationChannel) args.arg3, [])]), AssignmentExpression(=, [VariableReference(int modificationType, []), Expression((int) args.arg4, [])]), Statement(onNotificationChannelModified(pkgName, user, channel, modificationType), []), Statement(}, []), Statement(break, []), Statement(case MSG_ON_NOTIFICATION_CHANNEL_GROUP_MODIFIED:, []), Statement({, []), AssignmentExpression(=, [VariableReference(SomeArgs args, []), Expression((SomeArgs) msg.obj, [])]), AssignmentExpression(=, [VariableReference(String pkgName, []), Expression((String) args.arg1, [])]), AssignmentExpression(=, [VariableReference(UserHandle user, []), Expression((UserHandle) args.arg2, [])]), AssignmentExpression(=, [VariableReference(NotificationChannelGroup group, []), Expression((NotificationChannelGroup) args.arg3, [])]), AssignmentExpression(=, [VariableReference(int modificationType, []), Expression((int) args.arg4, [])]), Statement(onNotificationChannelGroupModified(pkgName, user, group, modificationType), []), Statement(}, []), Statement(break, []), Statement(}, []), Statement(}, [])])  Statement({, [])  Statement(if (!isConnected) {, [])  Statement(return, [])  Statement(}, [])  Statement(case MSG_ON_NOTIFICATION_POSTED:, [])  Statement({, [])  AssignmentExpression(=, [VariableReference(SomeArgs args, []), Expression((SomeArgs) msg.obj, [])])    VariableReference(SomeArgs args, [])    Expression((SomeArgs) msg.obj, [])  AssignmentExpression(=, [VariableReference(StatusBarNotification sbn, []), Expression((StatusBarNotification) args.arg1, [])])    VariableReference(StatusBarNotification sbn, [])    Expression((StatusBarNotification) args.arg1, [])  AssignmentExpression(=, [VariableReference(RankingMap rankingMap, []), Expression((RankingMap) args.arg2, [])])    VariableReference(RankingMap rankingMap, [])    Expression((RankingMap) args.arg2, [])  MethodCall(args.recycle(), [VariableReference(args, []), Expression(, [])])    VariableReference(args, [])    Expression(, [])  Statement(onNotificationPosted(sbn, rankingMap), [])  Statement(}, [])  Statement(break, [])  Statement(case MSG_ON_NOTIFICATION_REMOVED:, [])  Statement({, [])  AssignmentExpression(=, [VariableReference(SomeArgs args, []), Expression((SomeArgs) msg.obj, [])])    VariableReference(SomeArgs args, [])    Expression((SomeArgs) msg.obj, [])  AssignmentExpression(=, [VariableReference(StatusBarNotification sbn, []), Expression((StatusBarNotification) args.arg1, [])])    VariableReference(StatusBarNotification sbn, [])    Expression((StatusBarNotification) args.arg1, [])  AssignmentExpression(=, [VariableReference(RankingMap rankingMap, []), Expression((RankingMap) args.arg2, [])])    VariableReference(RankingMap rankingMap, [])    Expression((RankingMap) args.arg2, [])  AssignmentExpression(=, [VariableReference(int reason, []), Expression((int) args.arg3, [])])    VariableReference(int reason, [])    Expression((int) args.arg3, [])  MethodCall(args.recycle(), [VariableReference(args, []), Expression(, [])])    VariableReference(args, [])    Expression(, [])  Statement(onNotificationRemoved(sbn, rankingMap, reason), [])  Statement(}, [])  Statement(break, [])  Statement(case MSG_ON_LISTENER_CONNECTED:, [])  Statement({, [])  Statement(onListenerConnected(), [])  Statement(}, [])  Statement(break, [])  Statement(case MSG_ON_NOTIFICATION_RANKING_UPDATE:, [])  Statement({, [])  AssignmentExpression(=, [VariableReference(RankingMap rankingMap, []), Expression((RankingMap) msg.obj, [])])    VariableReference(RankingMap rankingMap, [])    Expression((RankingMap) msg.obj, [])  Statement(onNotificationRankingUpdate(rankingMap), [])  Statement(}, [])  Statement(break, [])  Statement(case MSG_ON_LISTENER_HINTS_CHANGED:, [])  Statement({, [])  AssignmentExpression(=, [VariableReference(final int hints, []), Expression(msg.arg1, [])])    VariableReference(final int hints, [])    Expression(msg.arg1, [])  Statement(onListenerHintsChanged(hints), [])  Statement(}, [])  Statement(break, [])  Statement(case MSG_ON_INTERRUPTION_FILTER_CHANGED:, [])  Statement({, [])  AssignmentExpression(=, [VariableReference(final int interruptionFilter, []), Expression(msg.arg1, [])])    VariableReference(final int interruptionFilter, [])    Expression(msg.arg1, [])  Statement(onInterruptionFilterChanged(interruptionFilter), [])  Statement(}, [])  Statement(break, [])  Statement(case MSG_ON_NOTIFICATION_CHANNEL_MODIFIED:, [])  Statement({, [])  AssignmentExpression(=, [VariableReference(SomeArgs args, []), Expression((SomeArgs) msg.obj, [])])    VariableReference(SomeArgs args, [])    Expression((SomeArgs) msg.obj, [])  AssignmentExpression(=, [VariableReference(String pkgName, []), Expression((String) args.arg1, [])])    VariableReference(String pkgName, [])    Expression((String) args.arg1, [])  AssignmentExpression(=, [VariableReference(UserHandle user, []), Expression((UserHandle) args.arg2, [])])    VariableReference(UserHandle user, [])    Expression((UserHandle) args.arg2, [])  AssignmentExpression(=, [VariableReference(NotificationChannel channel, []), Expression((NotificationChannel) args.arg3, [])])    VariableReference(NotificationChannel channel, [])    Expression((NotificationChannel) args.arg3, [])  AssignmentExpression(=, [VariableReference(int modificationType, []), Expression((int) args.arg4, [])])    VariableReference(int modificationType, [])    Expression((int) args.arg4, [])  Statement(onNotificationChannelModified(pkgName, user, channel, modificationType), [])  Statement(}, [])  Statement(break, [])  Statement(case MSG_ON_NOTIFICATION_CHANNEL_GROUP_MODIFIED:, [])  Statement({, [])  AssignmentExpression(=, [VariableReference(SomeArgs args, []), Expression((SomeArgs) msg.obj, [])])    VariableReference(SomeArgs args, [])    Expression((SomeArgs) msg.obj, [])  AssignmentExpression(=, [VariableReference(String pkgName, []), Expression((String) args.arg1, [])])    VariableReference(String pkgName, [])    Expression((String) args.arg1, [])  AssignmentExpression(=, [VariableReference(UserHandle user, []), Expression((UserHandle) args.arg2, [])])    VariableReference(UserHandle user, [])    Expression((UserHandle) args.arg2, [])  AssignmentExpression(=, [VariableReference(NotificationChannelGroup group, []), Expression((NotificationChannelGroup) args.arg3, [])])    VariableReference(NotificationChannelGroup group, [])    Expression((NotificationChannelGroup) args.arg3, [])  AssignmentExpression(=, [VariableReference(int modificationType, []), Expression((int) args.arg4, [])])    VariableReference(int modificationType, [])    Expression((int) args.arg4, [])  Statement(onNotificationChannelGroupModified(pkgName, user, group, modificationType), [])  Statement(}, [])  Statement(break, [])  Statement(}, [])  Statement(}, [])",1,,,0,[@Override],[@Override],0,,,,"1,2","3,4,5",1,"3,4",1,"New control dependency statements are added for handling new cases, specifically the addition of cases `MSG_ON_NOTIFICATION_CHANNEL_MODIFIED` and `MSG_ON_NOTIFICATION_CHANNEL_GROUP_MODIFIED`. The statements in these cases include assignments and method calls. Existing `MSG_ON_NOTIFICATION_REMOVED` case changed at the statement level with the inclusion of new parameter `reason` and its associated assignment.","The addition of the control dependency statements and the modified `MSG_ON_NOTIFICATION_REMOVED` case indicate that the method could potentially return different results or behave differently in its execution, leading to potential CI, hence the CI type is 1."
128,<android.app.EnterTransitionCoordinator: void onTransitionsComplete()>,25,26,,,,"MethodDeclaration(method_body, [Statement({, []), Statement(moveSharedElementsFromOverlay(), []), AssignmentExpression(=, [VariableReference(final ViewGroup decorView, []), Expression(getDecor(), [])]), AssignmentExpression(=, [VariableReference(if (decorView !, []), Expression(null) {, [])]), MethodCall(decorView.sendAccessibilityEvent(AccessibilityEvent.TYPE_WINDOW_CONTENT_CHANGED), [VariableReference(decorView, []), Expression(AccessibilityEvent.TYPE_WINDOW_CONTENT_CHANGED, [])]), Statement(}, []), Statement(}, [])])  Statement({, [])  Statement(moveSharedElementsFromOverlay(), [])  AssignmentExpression(=, [VariableReference(final ViewGroup decorView, []), Expression(getDecor(), [])])    VariableReference(final ViewGroup decorView, [])    Expression(getDecor(), [])  AssignmentExpression(=, [VariableReference(if (decorView !, []), Expression(null) {, [])])    VariableReference(if (decorView !, [])    Expression(null) {, [])  MethodCall(decorView.sendAccessibilityEvent(AccessibilityEvent.TYPE_WINDOW_CONTENT_CHANGED), [VariableReference(decorView, []), Expression(AccessibilityEvent.TYPE_WINDOW_CONTENT_CHANGED, [])])    VariableReference(decorView, [])    Expression(AccessibilityEvent.TYPE_WINDOW_CONTENT_CHANGED, [])  Statement(}, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(moveSharedElementsFromOverlay(), []), AssignmentExpression(=, [VariableReference(final ViewGroup decorView, []), Expression(getDecor(), [])]), AssignmentExpression(=, [VariableReference(if (decorView !, []), Expression(null) {, [])]), MethodCall(decorView.sendAccessibilityEvent(AccessibilityEvent.TYPE_WINDOW_CONTENT_CHANGED), [VariableReference(decorView, []), Expression(AccessibilityEvent.TYPE_WINDOW_CONTENT_CHANGED, [])]), AssignmentExpression(=, [VariableReference(Window window, []), Expression(getWindow(), [])]), AssignmentExpression(=, [VariableReference(if (window !, []), Expression(null && mReplacedBackground, [])]), MethodCall(window.setBackgroundDrawable(null), [VariableReference(window, []), Expression(null, [])]), Statement(}, []), Statement(}, []), Statement(}, [])])  Statement({, [])  Statement(moveSharedElementsFromOverlay(), [])  AssignmentExpression(=, [VariableReference(final ViewGroup decorView, []), Expression(getDecor(), [])])    VariableReference(final ViewGroup decorView, [])    Expression(getDecor(), [])  AssignmentExpression(=, [VariableReference(if (decorView !, []), Expression(null) {, [])])    VariableReference(if (decorView !, [])    Expression(null) {, [])  MethodCall(decorView.sendAccessibilityEvent(AccessibilityEvent.TYPE_WINDOW_CONTENT_CHANGED), [VariableReference(decorView, []), Expression(AccessibilityEvent.TYPE_WINDOW_CONTENT_CHANGED, [])])    VariableReference(decorView, [])    Expression(AccessibilityEvent.TYPE_WINDOW_CONTENT_CHANGED, [])  AssignmentExpression(=, [VariableReference(Window window, []), Expression(getWindow(), [])])    VariableReference(Window window, [])    Expression(getWindow(), [])  AssignmentExpression(=, [VariableReference(if (window !, []), Expression(null && mReplacedBackground, [])])    VariableReference(if (window !, [])    Expression(null && mReplacedBackground, [])  MethodCall(window.setBackgroundDrawable(null), [VariableReference(window, []), Expression(null, [])])    VariableReference(window, [])    Expression(null, [])  Statement(}, [])  Statement(}, [])  Statement(}, [])",1,,,0,[@Override],[@Override],0,,,,"1,2","3,4",1,"3,4",0,"The late implementation added new assignments and method calls related to the `Window` object, specifically `getWindow()`, a check on `window != null && mReplacedBackground`, and `window.setBackgroundDrawable(null)`. The added statements are neither changing existing exception handling nor return types. Thus, the change type is 3,4.","Although there are changes in the control dependencies (added conditions and method calls related to `window`), these changes do not affect return values or exception handling, thus no CI exists and the CI type is 0."
129,<android.widget.VideoView: void stopPlayback()>,25,26,,,,"MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(if (mMediaPlayer !, []), Expression(null) {, [])]), MethodCall(mMediaPlayer.stop(), [VariableReference(mMediaPlayer, []), Expression(, [])]), MethodCall(mMediaPlayer.release(), [VariableReference(mMediaPlayer, []), Expression(, [])]), AssignmentExpression(=, [VariableReference(mMediaPlayer, []), Expression(null, [])]), AssignmentExpression(=, [VariableReference(mCurrentState, []), Expression(STATE_IDLE, [])]), AssignmentExpression(=, [VariableReference(mTargetState, []), Expression(STATE_IDLE, [])]), AssignmentExpression(=, [VariableReference(AudioManager am, []), Expression((AudioManager) mContext.getSystemService(Context.AUDIO_SERVICE), [])]), MethodCall(am.abandonAudioFocus(null), [VariableReference(am, []), Expression(null, [])]), Statement(}, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(if (mMediaPlayer !, []), Expression(null) {, [])])    VariableReference(if (mMediaPlayer !, [])    Expression(null) {, [])  MethodCall(mMediaPlayer.stop(), [VariableReference(mMediaPlayer, []), Expression(, [])])    VariableReference(mMediaPlayer, [])    Expression(, [])  MethodCall(mMediaPlayer.release(), [VariableReference(mMediaPlayer, []), Expression(, [])])    VariableReference(mMediaPlayer, [])    Expression(, [])  AssignmentExpression(=, [VariableReference(mMediaPlayer, []), Expression(null, [])])    VariableReference(mMediaPlayer, [])    Expression(null, [])  AssignmentExpression(=, [VariableReference(mCurrentState, []), Expression(STATE_IDLE, [])])    VariableReference(mCurrentState, [])    Expression(STATE_IDLE, [])  AssignmentExpression(=, [VariableReference(mTargetState, []), Expression(STATE_IDLE, [])])    VariableReference(mTargetState, [])    Expression(STATE_IDLE, [])  AssignmentExpression(=, [VariableReference(AudioManager am, []), Expression((AudioManager) mContext.getSystemService(Context.AUDIO_SERVICE), [])])    VariableReference(AudioManager am, [])    Expression((AudioManager) mContext.getSystemService(Context.AUDIO_SERVICE), [])  MethodCall(am.abandonAudioFocus(null), [VariableReference(am, []), Expression(null, [])])    VariableReference(am, [])    Expression(null, [])  Statement(}, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(if (mMediaPlayer !, []), Expression(null) {, [])]), MethodCall(mMediaPlayer.stop(), [VariableReference(mMediaPlayer, []), Expression(, [])]), MethodCall(mMediaPlayer.release(), [VariableReference(mMediaPlayer, []), Expression(, [])]), AssignmentExpression(=, [VariableReference(mMediaPlayer, []), Expression(null, [])]), AssignmentExpression(=, [VariableReference(mCurrentState, []), Expression(STATE_IDLE, [])]), AssignmentExpression(=, [VariableReference(mTargetState, []), Expression(STATE_IDLE, [])]), MethodCall(mAudioManager.abandonAudioFocus(null), [VariableReference(mAudioManager, []), Expression(null, [])]), Statement(}, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(if (mMediaPlayer !, []), Expression(null) {, [])])    VariableReference(if (mMediaPlayer !, [])    Expression(null) {, [])  MethodCall(mMediaPlayer.stop(), [VariableReference(mMediaPlayer, []), Expression(, [])])    VariableReference(mMediaPlayer, [])    Expression(, [])  MethodCall(mMediaPlayer.release(), [VariableReference(mMediaPlayer, []), Expression(, [])])    VariableReference(mMediaPlayer, [])    Expression(, [])  AssignmentExpression(=, [VariableReference(mMediaPlayer, []), Expression(null, [])])    VariableReference(mMediaPlayer, [])    Expression(null, [])  AssignmentExpression(=, [VariableReference(mCurrentState, []), Expression(STATE_IDLE, [])])    VariableReference(mCurrentState, [])    Expression(STATE_IDLE, [])  AssignmentExpression(=, [VariableReference(mTargetState, []), Expression(STATE_IDLE, [])])    VariableReference(mTargetState, [])    Expression(STATE_IDLE, [])  MethodCall(mAudioManager.abandonAudioFocus(null), [VariableReference(mAudioManager, []), Expression(null, [])])    VariableReference(mAudioManager, [])    Expression(null, [])  Statement(}, [])  Statement(}, [])",1,,,0,,,0,,,,"1,2",4,0,5,0,"The change involves replacing `AudioManager am` with `mAudioManager`, but the functionality remains the same. Since it is just a refactor to use a presumably existing class member, the code change type is 5.","This change does not affect the behavior in terms of return value or exception handling, so no compatibility issue exists."
130,<android.app.Notification.Action.Builder: Action build()>,25,26,,,,"MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(RemoteInput[] remoteInputs, []), Expression(mRemoteInputs !, [])]), Statement(return new Action(mIcon, mTitle, mIntent, mExtras, remoteInputs, mAllowGeneratedReplies), []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(RemoteInput[] remoteInputs, []), Expression(mRemoteInputs !, [])])    VariableReference(RemoteInput[] remoteInputs, [])    Expression(mRemoteInputs !, [])  Statement(return new Action(mIcon, mTitle, mIntent, mExtras, remoteInputs, mAllowGeneratedReplies), [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(ArrayList<RemoteInput> dataOnlyInputs, []), Expression(new ArrayList<>(), [])]), AssignmentExpression(=, [VariableReference(RemoteInput[] previousDataInputs, []), Expression((RemoteInput[]) mExtras.getParcelableArray(EXTRA_DATA_ONLY_INPUTS), [])]), AssignmentExpression(=, [VariableReference(if (previousDataInputs !, []), Expression(null) {, [])]), Statement(for (RemoteInput input : previousDataInputs) {, []), MethodCall(dataOnlyInputs.add(input), [VariableReference(dataOnlyInputs, []), Expression(input, [])]), Statement(}, []), Statement(}, []), AssignmentExpression(=, [VariableReference(List<RemoteInput> textInputs, []), Expression(new ArrayList<>(), [])]), AssignmentExpression(=, [VariableReference(if (mRemoteInputs !, []), Expression(null) {, [])]), Statement(for (RemoteInput input : mRemoteInputs) {, []), MethodCall(if (input.isDataOnly()), [VariableReference(if (input, []), Expression(), [])]), MethodCall(dataOnlyInputs.add(input), [VariableReference(dataOnlyInputs, []), Expression(input, [])]), Statement(} else {, []), MethodCall(textInputs.add(input), [VariableReference(textInputs, []), Expression(input, [])]), Statement(}, []), Statement(}, []), Statement(}, []), MethodCall(if (!dataOnlyInputs.isEmpty()), [VariableReference(if (!dataOnlyInputs, []), Expression(), [])]), AssignmentExpression(=, [VariableReference(RemoteInput[] dataInputsArr, []), Expression(dataOnlyInputs.toArray(new RemoteInput[dataOnlyInputs.size()]), [])]), MethodCall(mExtras.putParcelableArray(EXTRA_DATA_ONLY_INPUTS, dataInputsArr), [VariableReference(mExtras, []), Expression(EXTRA_DATA_ONLY_INPUTS, []), Expression(dataInputsArr, [])]), Statement(}, []), AssignmentExpression(=, [VariableReference(RemoteInput[] textInputsArr, []), Expression(textInputs.isEmpty() ? null : textInputs.toArray(new RemoteInput[textInputs.size()]), [])]), Statement(return new Action(mIcon, mTitle, mIntent, mExtras, textInputsArr, mAllowGeneratedReplies), []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(ArrayList<RemoteInput> dataOnlyInputs, []), Expression(new ArrayList<>(), [])])    VariableReference(ArrayList<RemoteInput> dataOnlyInputs, [])    Expression(new ArrayList<>(), [])  AssignmentExpression(=, [VariableReference(RemoteInput[] previousDataInputs, []), Expression((RemoteInput[]) mExtras.getParcelableArray(EXTRA_DATA_ONLY_INPUTS), [])])    VariableReference(RemoteInput[] previousDataInputs, [])    Expression((RemoteInput[]) mExtras.getParcelableArray(EXTRA_DATA_ONLY_INPUTS), [])  AssignmentExpression(=, [VariableReference(if (previousDataInputs !, []), Expression(null) {, [])])    VariableReference(if (previousDataInputs !, [])    Expression(null) {, [])  Statement(for (RemoteInput input : previousDataInputs) {, [])  MethodCall(dataOnlyInputs.add(input), [VariableReference(dataOnlyInputs, []), Expression(input, [])])    VariableReference(dataOnlyInputs, [])    Expression(input, [])  Statement(}, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(List<RemoteInput> textInputs, []), Expression(new ArrayList<>(), [])])    VariableReference(List<RemoteInput> textInputs, [])    Expression(new ArrayList<>(), [])  AssignmentExpression(=, [VariableReference(if (mRemoteInputs !, []), Expression(null) {, [])])    VariableReference(if (mRemoteInputs !, [])    Expression(null) {, [])  Statement(for (RemoteInput input : mRemoteInputs) {, [])  MethodCall(if (input.isDataOnly()), [VariableReference(if (input, []), Expression(), [])])    VariableReference(if (input, [])    Expression(), [])  MethodCall(dataOnlyInputs.add(input), [VariableReference(dataOnlyInputs, []), Expression(input, [])])    VariableReference(dataOnlyInputs, [])    Expression(input, [])  Statement(} else {, [])  MethodCall(textInputs.add(input), [VariableReference(textInputs, []), Expression(input, [])])    VariableReference(textInputs, [])    Expression(input, [])  Statement(}, [])  Statement(}, [])  Statement(}, [])  MethodCall(if (!dataOnlyInputs.isEmpty()), [VariableReference(if (!dataOnlyInputs, []), Expression(), [])])    VariableReference(if (!dataOnlyInputs, [])    Expression(), [])  AssignmentExpression(=, [VariableReference(RemoteInput[] dataInputsArr, []), Expression(dataOnlyInputs.toArray(new RemoteInput[dataOnlyInputs.size()]), [])])    VariableReference(RemoteInput[] dataInputsArr, [])    Expression(dataOnlyInputs.toArray(new RemoteInput[dataOnlyInputs.size()]), [])  MethodCall(mExtras.putParcelableArray(EXTRA_DATA_ONLY_INPUTS, dataInputsArr), [VariableReference(mExtras, []), Expression(EXTRA_DATA_ONLY_INPUTS, []), Expression(dataInputsArr, [])])    VariableReference(mExtras, [])    Expression(EXTRA_DATA_ONLY_INPUTS, [])    Expression(dataInputsArr, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(RemoteInput[] textInputsArr, []), Expression(textInputs.isEmpty() ? null : textInputs.toArray(new RemoteInput[textInputs.size()]), [])])    VariableReference(RemoteInput[] textInputsArr, [])    Expression(textInputs.isEmpty() ? null : textInputs.toArray(new RemoteInput[textInputs.size()]), [])  Statement(return new Action(mIcon, mTitle, mIntent, mExtras, textInputsArr, mAllowGeneratedReplies), [])  Statement(}, [])",1,"/**
 * Combine all of the options that have been set and return a new {@link Action}
 * object.
 * @return the built action
 */
","/**
 * Combine all of the options that have been set and return a new {@link Action}
 * object.
 * @return the built action
 */
",0,,,0,,,,"1,2","1,3,4,5",1,"1,3,4",1,The implementation has been significantly modified:,
131,"<android.app.SharedPreferencesImpl.EditorImpl: Editor putInt(String,int)>",25,26,,,,"MethodDeclaration(method_body, [Statement({, []), Statement(synchronized (this) {, []), MethodCall(mModified.put(key, value), [VariableReference(mModified, []), Expression(key, []), Expression(value, [])]), Statement(return this, []), Statement(}, []), Statement(}, [])])  Statement({, [])  Statement(synchronized (this) {, [])  MethodCall(mModified.put(key, value), [VariableReference(mModified, []), Expression(key, []), Expression(value, [])])    VariableReference(mModified, [])    Expression(key, [])    Expression(value, [])  Statement(return this, [])  Statement(}, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(synchronized (mLock) {, []), MethodCall(mModified.put(key, value), [VariableReference(mModified, []), Expression(key, []), Expression(value, [])]), Statement(return this, []), Statement(}, []), Statement(}, [])])  Statement({, [])  Statement(synchronized (mLock) {, [])  MethodCall(mModified.put(key, value), [VariableReference(mModified, []), Expression(key, []), Expression(value, [])])    VariableReference(mModified, [])    Expression(key, [])    Expression(value, [])  Statement(return this, [])  Statement(}, [])  Statement(}, [])",1,,,0,,,0,,,,1,4,0,4,0,"The synchronization lock has changed from `this` to `mLock`, which is neither a return statement change, exception handling statement change, nor a control dependency change. It is classified as an other statement change category.","Changing the synchronization lock object from `this` to `mLock` does not affect the return values or the exceptions thrown by the method. Therefore, there is no compatibility issue caused by potential different return values or types or exceptions."
132,<android.appwidget.AppWidgetHost: int allocateAppWidgetId()>,26,27,,,,"MethodDeclaration(method_body, [Statement({, []), Statement(try {, []), MethodCall(return sService.allocateAppWidgetId(mContextOpPackageName, mHostId), [VariableReference(return sService, []), Expression(mContextOpPackageName, []), Expression(mHostId, [])]), Statement(} catch (RemoteException e) {, []), Statement(throw new RuntimeException(""system server dead?"", e), []), Statement(}, []), Statement(}, [])])  Statement({, [])  Statement(try {, [])  MethodCall(return sService.allocateAppWidgetId(mContextOpPackageName, mHostId), [VariableReference(return sService, []), Expression(mContextOpPackageName, []), Expression(mHostId, [])])    VariableReference(return sService, [])    Expression(mContextOpPackageName, [])    Expression(mHostId, [])  Statement(} catch (RemoteException e) {, [])  Statement(throw new RuntimeException(""system server dead?"", e), [])  Statement(}, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(if (sService, []), Expression(, [])]), Statement(return -1, []), Statement(}, []), Statement(try {, []), MethodCall(return sService.allocateAppWidgetId(mContextOpPackageName, mHostId), [VariableReference(return sService, []), Expression(mContextOpPackageName, []), Expression(mHostId, [])]), Statement(} catch (RemoteException e) {, []), Statement(throw new RuntimeException(""system server dead?"", e), []), Statement(}, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(if (sService, []), Expression(, [])])    VariableReference(if (sService, [])    Expression(, [])  Statement(return -1, [])  Statement(}, [])  Statement(try {, [])  MethodCall(return sService.allocateAppWidgetId(mContextOpPackageName, mHostId), [VariableReference(return sService, []), Expression(mContextOpPackageName, []), Expression(mHostId, [])])    VariableReference(return sService, [])    Expression(mContextOpPackageName, [])    Expression(mHostId, [])  Statement(} catch (RemoteException e) {, [])  Statement(throw new RuntimeException(""system server dead?"", e), [])  Statement(}, [])  Statement(}, [])",1,"/**
 * Get a appWidgetId for a host in the calling process.
 *
 * @return a appWidgetId
 */
","/**
 * Get a appWidgetId for a host in the calling process.
 *
 * @return a appWidgetId
 */
",0,,,0,,,,1,"1,3",1,"1,2,3","1,2","A new control dependency (an if statement checking if `sService` is null) is introduced in the late version, and if `sService` is null, the method now returns `-1` rather than calling `sService.allocateAppWidgetId`. Additionally, the try-catch block remains but the control flow changes with the new if statement. Thus, the change types are 1 (return statement changed), 2 (exception handling statement changed), and 3 (control dependency changed).","The introduction of the new control dependency potentially causes the method to return a different value (`-1`), and thus the CI type is 1. Also, handling of `RemoteException` remains, but the method's new logic can also potentially result in different exception scenarios. Thus, the CI type is 2."
133,<android.webkit.WebView: void shortPressOnTextField()>,4,5,<android.webkit.WebView: void shortPressOnTextField()>,<android.webkit.WebView: void shortPressOnTextField()>,0,"MethodDeclaration(method_body, [Statement({, []), Statement(if (inEditingMode()) {, []), AssignmentExpression(=, [VariableReference(View v, []), Expression(mTextEntry, [])]), AssignmentExpression(=, [VariableReference(int x, []), Expression(viewToContent((v.getLeft() + v.getRight()) >> 1), [])]), AssignmentExpression(=, [VariableReference(int y, []), Expression(viewToContent((v.getTop() + v.getBottom()) >> 1), [])]), Statement(nativeMotionUp(x, y, mNavSlop, true), []), Statement(}, []), Statement(}, [])])  Statement({, [])  Statement(if (inEditingMode()) {, [])  AssignmentExpression(=, [VariableReference(View v, []), Expression(mTextEntry, [])])    VariableReference(View v, [])    Expression(mTextEntry, [])  AssignmentExpression(=, [VariableReference(int x, []), Expression(viewToContent((v.getLeft() + v.getRight()) >> 1), [])])    VariableReference(int x, [])    Expression(viewToContent((v.getLeft() + v.getRight()) >> 1), [])  AssignmentExpression(=, [VariableReference(int y, []), Expression(viewToContent((v.getTop() + v.getBottom()) >> 1), [])])    VariableReference(int y, [])    Expression(viewToContent((v.getTop() + v.getBottom()) >> 1), [])  Statement(nativeMotionUp(x, y, mNavSlop, true), [])  Statement(}, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(if (inEditingMode()) {, []), AssignmentExpression(=, [VariableReference(View v, []), Expression(mWebTextView, [])]), AssignmentExpression(=, [VariableReference(int x, []), Expression(viewToContentX((v.getLeft() + v.getRight()) >> 1), [])]), AssignmentExpression(=, [VariableReference(int y, []), Expression(viewToContentY((v.getTop() + v.getBottom()) >> 1), [])]), Statement(nativeTextInputMotionUp(x, y), []), Statement(}, []), Statement(}, [])])  Statement({, [])  Statement(if (inEditingMode()) {, [])  AssignmentExpression(=, [VariableReference(View v, []), Expression(mWebTextView, [])])    VariableReference(View v, [])    Expression(mWebTextView, [])  AssignmentExpression(=, [VariableReference(int x, []), Expression(viewToContentX((v.getLeft() + v.getRight()) >> 1), [])])    VariableReference(int x, [])    Expression(viewToContentX((v.getLeft() + v.getRight()) >> 1), [])  AssignmentExpression(=, [VariableReference(int y, []), Expression(viewToContentY((v.getTop() + v.getBottom()) >> 1), [])])    VariableReference(int y, [])    Expression(viewToContentY((v.getTop() + v.getBottom()) >> 1), [])  Statement(nativeTextInputMotionUp(x, y), [])  Statement(}, [])  Statement(}, [])",1,"/*package*/
","/*package*/
",0,,,0,,,0,"1,2","4,5",0,"1,4,5",1,Several changes have occurred:,- The `nativeMotionUp` call has changed to `nativeTextInputMotionUp`.
134,<android.webkit.MimeTypeMap: String getFileExtensionFromUrl(String)>,4,5,<android.webkit.MimeTypeMap: String getFileExtensionFromUrl(String)>,<android.webkit.MimeTypeMap: String getFileExtensionFromUrl(String)>,0,"MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(if (url !, []), Expression(null && url.length() > 0) {, [])]), AssignmentExpression(=, [VariableReference(int query, []), Expression(url.lastIndexOf('?'), [])]), Statement(if (query > 0) {, []), AssignmentExpression(=, [VariableReference(url, []), Expression(url.substring(0, query), [])]), Statement(}, []), AssignmentExpression(=, [VariableReference(int filenamePos, []), Expression(url.lastIndexOf('/'), [])]), AssignmentExpression(=, [VariableReference(String filename, []), Expression(0 <, [])]), Statement(// consider it valid for our matching purposes:, []), MethodCall(if (filename.length() > 0 && Pattern.matches(""[a-zA-Z_0-9\\.\\-\\(\\)]+"", filename)), [VariableReference(if (filename, []), Expression() > 0 && Pattern.matches(""[a-zA-Z_0-9\\.\\-\\(\\)]+"", []), Expression(filename), [])]), AssignmentExpression(=, [VariableReference(int dotPos, []), Expression(filename.lastIndexOf('.'), [])]), AssignmentExpression(=, [VariableReference(if (0 <, []), Expression(dotPos) {, [])]), MethodCall(return filename.substring(dotPos + 1), [VariableReference(return filename, []), Expression(dotPos + 1, [])]), Statement(}, []), Statement(}, []), Statement(}, []), Statement(return """", []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(if (url !, []), Expression(null && url.length() > 0) {, [])])    VariableReference(if (url !, [])    Expression(null && url.length() > 0) {, [])  AssignmentExpression(=, [VariableReference(int query, []), Expression(url.lastIndexOf('?'), [])])    VariableReference(int query, [])    Expression(url.lastIndexOf('?'), [])  Statement(if (query > 0) {, [])  AssignmentExpression(=, [VariableReference(url, []), Expression(url.substring(0, query), [])])    VariableReference(url, [])    Expression(url.substring(0, query), [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(int filenamePos, []), Expression(url.lastIndexOf('/'), [])])    VariableReference(int filenamePos, [])    Expression(url.lastIndexOf('/'), [])  AssignmentExpression(=, [VariableReference(String filename, []), Expression(0 <, [])])    VariableReference(String filename, [])    Expression(0 <, [])  Statement(// consider it valid for our matching purposes:, [])  MethodCall(if (filename.length() > 0 && Pattern.matches(""[a-zA-Z_0-9\\.\\-\\(\\)]+"", filename)), [VariableReference(if (filename, []), Expression() > 0 && Pattern.matches(""[a-zA-Z_0-9\\.\\-\\(\\)]+"", []), Expression(filename), [])])    VariableReference(if (filename, [])    Expression() > 0 && Pattern.matches(""[a-zA-Z_0-9\\.\\-\\(\\)]+"", [])    Expression(filename), [])  AssignmentExpression(=, [VariableReference(int dotPos, []), Expression(filename.lastIndexOf('.'), [])])    VariableReference(int dotPos, [])    Expression(filename.lastIndexOf('.'), [])  AssignmentExpression(=, [VariableReference(if (0 <, []), Expression(dotPos) {, [])])    VariableReference(if (0 <, [])    Expression(dotPos) {, [])  MethodCall(return filename.substring(dotPos + 1), [VariableReference(return filename, []), Expression(dotPos + 1, [])])    VariableReference(return filename, [])    Expression(dotPos + 1, [])  Statement(}, [])  Statement(}, [])  Statement(}, [])  Statement(return """", [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(if (url !, []), Expression(null && url.length() > 0) {, [])]), AssignmentExpression(=, [VariableReference(int query, []), Expression(url.lastIndexOf('?'), [])]), Statement(if (query > 0) {, []), AssignmentExpression(=, [VariableReference(url, []), Expression(url.substring(0, query), [])]), Statement(}, []), AssignmentExpression(=, [VariableReference(int filenamePos, []), Expression(url.lastIndexOf('/'), [])]), AssignmentExpression(=, [VariableReference(String filename, []), Expression(0 <, [])]), Statement(// consider it valid for our matching purposes:, []), MethodCall(if (filename.length() > 0 && Pattern.matches(""[a-zA-Z_0-9\\.\\-\\(\\)]+"", filename)), [VariableReference(if (filename, []), Expression() > 0 && Pattern.matches(""[a-zA-Z_0-9\\.\\-\\(\\)]+"", []), Expression(filename), [])]), AssignmentExpression(=, [VariableReference(int dotPos, []), Expression(filename.lastIndexOf('.'), [])]), AssignmentExpression(=, [VariableReference(if (0 <, []), Expression(dotPos) {, [])]), MethodCall(return filename.substring(dotPos + 1), [VariableReference(return filename, []), Expression(dotPos + 1, [])]), Statement(}, []), Statement(}, []), Statement(}, []), Statement(return """", []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(if (url !, []), Expression(null && url.length() > 0) {, [])])    VariableReference(if (url !, [])    Expression(null && url.length() > 0) {, [])  AssignmentExpression(=, [VariableReference(int query, []), Expression(url.lastIndexOf('?'), [])])    VariableReference(int query, [])    Expression(url.lastIndexOf('?'), [])  Statement(if (query > 0) {, [])  AssignmentExpression(=, [VariableReference(url, []), Expression(url.substring(0, query), [])])    VariableReference(url, [])    Expression(url.substring(0, query), [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(int filenamePos, []), Expression(url.lastIndexOf('/'), [])])    VariableReference(int filenamePos, [])    Expression(url.lastIndexOf('/'), [])  AssignmentExpression(=, [VariableReference(String filename, []), Expression(0 <, [])])    VariableReference(String filename, [])    Expression(0 <, [])  Statement(// consider it valid for our matching purposes:, [])  MethodCall(if (filename.length() > 0 && Pattern.matches(""[a-zA-Z_0-9\\.\\-\\(\\)]+"", filename)), [VariableReference(if (filename, []), Expression() > 0 && Pattern.matches(""[a-zA-Z_0-9\\.\\-\\(\\)]+"", []), Expression(filename), [])])    VariableReference(if (filename, [])    Expression() > 0 && Pattern.matches(""[a-zA-Z_0-9\\.\\-\\(\\)]+"", [])    Expression(filename), [])  AssignmentExpression(=, [VariableReference(int dotPos, []), Expression(filename.lastIndexOf('.'), [])])    VariableReference(int dotPos, [])    Expression(filename.lastIndexOf('.'), [])  AssignmentExpression(=, [VariableReference(if (0 <, []), Expression(dotPos) {, [])])    VariableReference(if (0 <, [])    Expression(dotPos) {, [])  MethodCall(return filename.substring(dotPos + 1), [VariableReference(return filename, []), Expression(dotPos + 1, [])])    VariableReference(return filename, [])    Expression(dotPos + 1, [])  Statement(}, [])  Statement(}, [])  Statement(}, [])  Statement(return """", [])  Statement(}, [])",0,"/**
 * Returns the file extension or an empty string iff there is no
 * extension.
 */
","/**
 * Returns the file extension or an empty string iff there is no
 * extension. This method is a convenience method for obtaining the
 * extension of a url and has undefined results for other Strings.
 * @param url
 * @return The file extension of the given url.
 */
",1,,,0,,,0,0,0,0,0,0,There are no changes in the method implementation between the early and the late versions.,No Compatibility Issue exists as the method implementation remains unchanged.
135,<android.content.SyncManager.SyncQueue: void removeByKey(String)>,5,6,<android.content.SyncManager.SyncQueue: void removeByKey(String)>,<android.content.SyncManager.SyncQueue: void removeByKey(String)>,0,"MethodDeclaration(method_body, [])","MethodDeclaration(method_body, [Statement({, []), Statement(if (DEBUG_CHECK_DATA_CONSISTENCY), []), Statement(debugCheckDataStructures(true), []), AssignmentExpression(=, [VariableReference(SyncOperation operationToRemove, []), Expression(mOpsByKey.remove(operationKey), [])]), MethodCall(if (!mOpsByWhen.remove(operationToRemove)), [VariableReference(if (!mOpsByWhen, []), Expression(operationToRemove), [])]), Statement(throw new IllegalStateException(""unable to find "" + operationToRemove + "" in mOpsByWhen""), []), Statement(}, []), MethodCall(if (!mSyncStorageEngine.deleteFromPending(operationToRemove.pendingOperation)), [VariableReference(if (!mSyncStorageEngine, []), Expression(operationToRemove.pendingOperation), [])]), AssignmentExpression(=, [VariableReference(final String errorMessage, []), Expression(""unable to find pending row for "" + operationToRemove, [])]), MethodCall(Log.e(TAG, errorMessage, new IllegalStateException(errorMessage)), [VariableReference(Log, []), Expression(TAG, []), Expression(errorMessage, []), Expression(new IllegalStateException(errorMessage), [])]), Statement(}, []), Statement(if (DEBUG_CHECK_DATA_CONSISTENCY), []), Statement(debugCheckDataStructures(true), []), Statement(}, [])])  Statement({, [])  Statement(if (DEBUG_CHECK_DATA_CONSISTENCY), [])  Statement(debugCheckDataStructures(true), [])  AssignmentExpression(=, [VariableReference(SyncOperation operationToRemove, []), Expression(mOpsByKey.remove(operationKey), [])])    VariableReference(SyncOperation operationToRemove, [])    Expression(mOpsByKey.remove(operationKey), [])  MethodCall(if (!mOpsByWhen.remove(operationToRemove)), [VariableReference(if (!mOpsByWhen, []), Expression(operationToRemove), [])])    VariableReference(if (!mOpsByWhen, [])    Expression(operationToRemove), [])  Statement(throw new IllegalStateException(""unable to find "" + operationToRemove + "" in mOpsByWhen""), [])  Statement(}, [])  MethodCall(if (!mSyncStorageEngine.deleteFromPending(operationToRemove.pendingOperation)), [VariableReference(if (!mSyncStorageEngine, []), Expression(operationToRemove.pendingOperation), [])])    VariableReference(if (!mSyncStorageEngine, [])    Expression(operationToRemove.pendingOperation), [])  AssignmentExpression(=, [VariableReference(final String errorMessage, []), Expression(""unable to find pending row for "" + operationToRemove, [])])    VariableReference(final String errorMessage, [])    Expression(""unable to find pending row for "" + operationToRemove, [])  MethodCall(Log.e(TAG, errorMessage, new IllegalStateException(errorMessage)), [VariableReference(Log, []), Expression(TAG, []), Expression(errorMessage, []), Expression(new IllegalStateException(errorMessage), [])])    VariableReference(Log, [])    Expression(TAG, [])    Expression(errorMessage, [])    Expression(new IllegalStateException(errorMessage), [])  Statement(}, [])  Statement(if (DEBUG_CHECK_DATA_CONSISTENCY), [])  Statement(debugCheckDataStructures(true), [])  Statement(}, [])",1,,,0,,,0,,,0,"1,2","3,4",2,"2,3,4",2,"In the late version, multiple statements have been added compared to the early version. These include debug checks, removal from mOpsByWhen, exception handling with IllegalStateException, an attempt to delete from pending operations followed by logging if an error occurs, and additional debug checks. Hence, the changes belong to the categories: exception handling statement changed (2), control dependency changed (3), and other statement changed (4).","The changes introduce new exception handling (IllegalStateException) and potentially affect the overall flow and error logging of the function. This can lead to different behaviors when dealing with exceptions, so the CI type is 2."
136,"<android.provider.ContactsContract.QuickContact: void showQuickContact(Context,View,Uri,int,String[])>",5,6,"<android.provider.ContactsContract.QuickContact: void showQuickContact(Context,View,Uri,int,String[])>","<android.provider.ContactsContract.QuickContact: void showQuickContact(Context,View,Uri,int,String[])>",0,"MethodDeclaration(method_body, [Statement({, []), Statement(// Find location and bounds of target view, []), AssignmentExpression(=, [VariableReference(final int[] location, []), Expression(new int[2], [])]), MethodCall(target.getLocationOnScreen(location), [VariableReference(target, []), Expression(location, [])]), AssignmentExpression(=, [VariableReference(final Rect rect, []), Expression(new Rect(), [])]), AssignmentExpression(=, [VariableReference(rect.left, []), Expression(location[0], [])]), AssignmentExpression(=, [VariableReference(rect.top, []), Expression(location[1], [])]), AssignmentExpression(=, [VariableReference(rect.right, []), Expression(rect.left + target.getWidth(), [])]), AssignmentExpression(=, [VariableReference(rect.bottom, []), Expression(rect.top + target.getHeight(), [])]), Statement(// Trigger with obtained rectangle, []), Statement(showQuickContact(context, rect, lookupUri, mode, excludeMimes), []), Statement(}, [])])  Statement({, [])  Statement(// Find location and bounds of target view, [])  AssignmentExpression(=, [VariableReference(final int[] location, []), Expression(new int[2], [])])    VariableReference(final int[] location, [])    Expression(new int[2], [])  MethodCall(target.getLocationOnScreen(location), [VariableReference(target, []), Expression(location, [])])    VariableReference(target, [])    Expression(location, [])  AssignmentExpression(=, [VariableReference(final Rect rect, []), Expression(new Rect(), [])])    VariableReference(final Rect rect, [])    Expression(new Rect(), [])  AssignmentExpression(=, [VariableReference(rect.left, []), Expression(location[0], [])])    VariableReference(rect.left, [])    Expression(location[0], [])  AssignmentExpression(=, [VariableReference(rect.top, []), Expression(location[1], [])])    VariableReference(rect.top, [])    Expression(location[1], [])  AssignmentExpression(=, [VariableReference(rect.right, []), Expression(rect.left + target.getWidth(), [])])    VariableReference(rect.right, [])    Expression(rect.left + target.getWidth(), [])  AssignmentExpression(=, [VariableReference(rect.bottom, []), Expression(rect.top + target.getHeight(), [])])    VariableReference(rect.bottom, [])    Expression(rect.top + target.getHeight(), [])  Statement(// Trigger with obtained rectangle, [])  Statement(showQuickContact(context, rect, lookupUri, mode, excludeMimes), [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(// Find location and bounds of target view, []), AssignmentExpression(=, [VariableReference(final int[] location, []), Expression(new int[2], [])]), MethodCall(target.getLocationOnScreen(location), [VariableReference(target, []), Expression(location, [])]), AssignmentExpression(=, [VariableReference(final Rect rect, []), Expression(new Rect(), [])]), AssignmentExpression(=, [VariableReference(rect.left, []), Expression(location[0], [])]), AssignmentExpression(=, [VariableReference(rect.top, []), Expression(location[1], [])]), AssignmentExpression(=, [VariableReference(rect.right, []), Expression(rect.left + target.getWidth(), [])]), AssignmentExpression(=, [VariableReference(rect.bottom, []), Expression(rect.top + target.getHeight(), [])]), Statement(// Trigger with obtained rectangle, []), Statement(showQuickContact(context, rect, lookupUri, mode, excludeMimes), []), Statement(}, [])])  Statement({, [])  Statement(// Find location and bounds of target view, [])  AssignmentExpression(=, [VariableReference(final int[] location, []), Expression(new int[2], [])])    VariableReference(final int[] location, [])    Expression(new int[2], [])  MethodCall(target.getLocationOnScreen(location), [VariableReference(target, []), Expression(location, [])])    VariableReference(target, [])    Expression(location, [])  AssignmentExpression(=, [VariableReference(final Rect rect, []), Expression(new Rect(), [])])    VariableReference(final Rect rect, [])    Expression(new Rect(), [])  AssignmentExpression(=, [VariableReference(rect.left, []), Expression(location[0], [])])    VariableReference(rect.left, [])    Expression(location[0], [])  AssignmentExpression(=, [VariableReference(rect.top, []), Expression(location[1], [])])    VariableReference(rect.top, [])    Expression(location[1], [])  AssignmentExpression(=, [VariableReference(rect.right, []), Expression(rect.left + target.getWidth(), [])])    VariableReference(rect.right, [])    Expression(rect.left + target.getWidth(), [])  AssignmentExpression(=, [VariableReference(rect.bottom, []), Expression(rect.top + target.getHeight(), [])])    VariableReference(rect.bottom, [])    Expression(rect.top + target.getHeight(), [])  Statement(// Trigger with obtained rectangle, [])  Statement(showQuickContact(context, rect, lookupUri, mode, excludeMimes), [])  Statement(}, [])",0,"/**
 * Trigger a dialog that lists the various methods of interacting with
 * the requested {@link Contacts} entry. This may be based on available
 * {@link Data} rows under that contact, and may also include social
 * status and presence details.
 *
 * @param context The parent {@link Context} that may be used as the
 * parent for this dialog.
 * @param target Specific {@link View} from your layout that this dialog
 * should be centered around. In particular, if the dialog
 * has a ""callout"" arrow, it will be pointed and centered
 * around this {@link View}.
 * @param lookupUri A {@link ContactsContract.Contacts#CONTENT_LOOKUP_URI} style
 * {@link Uri} that describes a specific contact to feature
 * in this dialog.
 * @param mode Any of {@link #MODE_SMALL}, {@link #MODE_MEDIUM}, or
 * {@link #MODE_LARGE}, indicating the desired dialog size,
 * when supported.
 * @param excludeMimes Optional list of {@link Data#MIMETYPE} MIME-types
 * to exclude when showing this dialog. For example, when
 * already viewing the contact details card, this can be used
 * to omit the details entry from the dialog.
 */
","/**
 * Trigger a dialog that lists the various methods of interacting with
 * the requested {@link Contacts} entry. This may be based on available
 * {@link ContactsContract.Data} rows under that contact, and may also
 * include social status and presence details.
 *
 * @param context The parent {@link Context} that may be used as the
 * parent for this dialog.
 * @param target Specific {@link View} from your layout that this dialog
 * should be centered around. In particular, if the dialog
 * has a ""callout"" arrow, it will be pointed and centered
 * around this {@link View}.
 * @param lookupUri A {@link ContactsContract.Contacts#CONTENT_LOOKUP_URI} style
 * {@link Uri} that describes a specific contact to feature
 * in this dialog.
 * @param mode Any of {@link #MODE_SMALL}, {@link #MODE_MEDIUM}, or
 * {@link #MODE_LARGE}, indicating the desired dialog size,
 * when supported.
 * @param excludeMimes Optional list of {@link Data#MIMETYPE} MIME-types
 * to exclude when showing this dialog. For example, when
 * already viewing the contact details card, this can be used
 * to omit the details entry from the dialog.
 */
",1,,,0,,,0,0,0,0,0,0,"There are no changes in the method implementation between the Early and Late versions. The AST nodes for both implementations are identical, and there are no changes in comments or annotations.","Since there is no change in the implementation, no Compatibility Issue exists. Therefore, the CI type is 0."
137,<android.webkit.WebView: void shortPressOnTextField()>,6,7,<android.webkit.WebView: void shortPressOnTextField()>,<android.webkit.WebView: void shortPressOnTextField()>,0,"MethodDeclaration(method_body, [Statement({, []), Statement(if (inEditingMode()) {, []), AssignmentExpression(=, [VariableReference(View v, []), Expression(mWebTextView, [])]), AssignmentExpression(=, [VariableReference(int x, []), Expression(viewToContentX((v.getLeft() + v.getRight()) >> 1), [])]), AssignmentExpression(=, [VariableReference(int y, []), Expression(viewToContentY((v.getTop() + v.getBottom()) >> 1), [])]), Statement(nativeTextInputMotionUp(x, y), []), Statement(}, []), Statement(}, [])])  Statement({, [])  Statement(if (inEditingMode()) {, [])  AssignmentExpression(=, [VariableReference(View v, []), Expression(mWebTextView, [])])    VariableReference(View v, [])    Expression(mWebTextView, [])  AssignmentExpression(=, [VariableReference(int x, []), Expression(viewToContentX((v.getLeft() + v.getRight()) >> 1), [])])    VariableReference(int x, [])    Expression(viewToContentX((v.getLeft() + v.getRight()) >> 1), [])  AssignmentExpression(=, [VariableReference(int y, []), Expression(viewToContentY((v.getTop() + v.getBottom()) >> 1), [])])    VariableReference(int y, [])    Expression(viewToContentY((v.getTop() + v.getBottom()) >> 1), [])  Statement(nativeTextInputMotionUp(x, y), [])  Statement(}, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(if (inEditingMode()) {, []), AssignmentExpression(=, [VariableReference(View v, []), Expression(mWebTextView, [])]), AssignmentExpression(=, [VariableReference(int x, []), Expression(viewToContentX((v.getLeft() + v.getRight()) >> 1), [])]), AssignmentExpression(=, [VariableReference(int y, []), Expression(viewToContentY((v.getTop() + v.getBottom()) >> 1), [])]), Statement(displaySoftKeyboard(true), []), Statement(nativeTextInputMotionUp(x, y), []), Statement(}, []), Statement(}, [])])  Statement({, [])  Statement(if (inEditingMode()) {, [])  AssignmentExpression(=, [VariableReference(View v, []), Expression(mWebTextView, [])])    VariableReference(View v, [])    Expression(mWebTextView, [])  AssignmentExpression(=, [VariableReference(int x, []), Expression(viewToContentX((v.getLeft() + v.getRight()) >> 1), [])])    VariableReference(int x, [])    Expression(viewToContentX((v.getLeft() + v.getRight()) >> 1), [])  AssignmentExpression(=, [VariableReference(int y, []), Expression(viewToContentY((v.getTop() + v.getBottom()) >> 1), [])])    VariableReference(int y, [])    Expression(viewToContentY((v.getTop() + v.getBottom()) >> 1), [])  Statement(displaySoftKeyboard(true), [])  Statement(nativeTextInputMotionUp(x, y), [])  Statement(}, [])  Statement(}, [])",1,"/*package*/
","/*package*/
",0,,,0,,,0,2,4,0,4,0,"A new statement `displaySoftKeyboard(true)` has been introduced within the control dependency block, so the code change type is 4.","The addition of the `displaySoftKeyboard(true)` statement does not alter the return value or throw different exceptions; it simply adds functionality. Therefore, no Compatibility Issue exists."
138,<android.hardware.Camera.Parameters: List<Integer> getSupportedPictureFormats()>,6,7,<android.hardware.Camera.Parameters: List<Integer> getSupportedPictureFormats()>,<android.hardware.Camera.Parameters: List<Integer> getSupportedPictureFormats()>,0,"MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(String str, []), Expression(get(KEY_PICTURE_SIZE + SUPPORTED_VALUES_SUFFIX), [])]), Statement(return splitInt(str), []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(String str, []), Expression(get(KEY_PICTURE_SIZE + SUPPORTED_VALUES_SUFFIX), [])])    VariableReference(String str, [])    Expression(get(KEY_PICTURE_SIZE + SUPPORTED_VALUES_SUFFIX), [])  Statement(return splitInt(str), [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(String str, []), Expression(get(KEY_PICTURE_FORMAT + SUPPORTED_VALUES_SUFFIX), [])]), AssignmentExpression(=, [VariableReference(ArrayList<Integer> formats, []), Expression(new ArrayList<Integer>(), [])]), Statement(for (String s : split(str)) {, []), AssignmentExpression(=, [VariableReference(int f, []), Expression(pixelFormatForCameraFormat(s), [])]), AssignmentExpression(=, [VariableReference(if (f, []), Expression(, [])]), Statement(continue, []), MethodCall(formats.add(f), [VariableReference(formats, []), Expression(f, [])]), Statement(}, []), Statement(return formats, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(String str, []), Expression(get(KEY_PICTURE_FORMAT + SUPPORTED_VALUES_SUFFIX), [])])    VariableReference(String str, [])    Expression(get(KEY_PICTURE_FORMAT + SUPPORTED_VALUES_SUFFIX), [])  AssignmentExpression(=, [VariableReference(ArrayList<Integer> formats, []), Expression(new ArrayList<Integer>(), [])])    VariableReference(ArrayList<Integer> formats, [])    Expression(new ArrayList<Integer>(), [])  Statement(for (String s : split(str)) {, [])  AssignmentExpression(=, [VariableReference(int f, []), Expression(pixelFormatForCameraFormat(s), [])])    VariableReference(int f, [])    Expression(pixelFormatForCameraFormat(s), [])  AssignmentExpression(=, [VariableReference(if (f, []), Expression(, [])])    VariableReference(if (f, [])    Expression(, [])  Statement(continue, [])  MethodCall(formats.add(f), [VariableReference(formats, []), Expression(f, [])])    VariableReference(formats, [])    Expression(f, [])  Statement(}, [])  Statement(return formats, [])  Statement(}, [])",1,"/**
 * Gets the supported picture formats.
 *
 * @return a List of Integer objects (values are PixelFormat.XXX). null
 * if picture setting is not supported.
 */
","/**
 * Gets the supported picture formats.
 *
 * @return a List of Integer objects (values are PixelFormat.XXX). This
 * method will always return a list with at least one element.
 */
",1,,,0,,,0,"1,2","1,3,4",1,"1,3,4",1,There have been several changes in the method implementation:,- Control dependency has changed as the method now incorporates a `for` loop and an `if` statement inside the loop.
139,<android.webkit.HTML5VideoViewProxy: void handleMessage(Message)>,7,8,<android.webkit.HTML5VideoViewProxy: void handleMessage(Message)>,<android.webkit.HTML5VideoViewProxy: void handleMessage(Message)>,0,"MethodDeclaration(method_body, [Statement({, []), Statement(// This executes on the UI thread., []), Statement(case PLAY:, []), Statement({, []), AssignmentExpression(=, [VariableReference(String url, []), Expression((String) msg.obj, [])]), AssignmentExpression(=, [VariableReference(WebChromeClient client, []), Expression(mWebView.getWebChromeClient(), [])]), AssignmentExpression(=, [VariableReference(if (client !, []), Expression(null) {, [])]), MethodCall(VideoPlayer.play(url, mSeekPosition, this, client), [VariableReference(VideoPlayer, []), Expression(url, []), Expression(mSeekPosition, []), Expression(this, []), Expression(client, [])]), Statement(}, []), Statement(break, []), Statement(}, []), Statement(case SEEK:, []), Statement({, []), AssignmentExpression(=, [VariableReference(Integer time, []), Expression((Integer) msg.obj, [])]), AssignmentExpression(=, [VariableReference(mSeekPosition, []), Expression(time, [])]), MethodCall(VideoPlayer.seek(mSeekPosition, this), [VariableReference(VideoPlayer, []), Expression(mSeekPosition, []), Expression(this, [])]), Statement(break, []), Statement(}, []), Statement(case PAUSE:, []), Statement({, []), MethodCall(VideoPlayer.pause(this), [VariableReference(VideoPlayer, []), Expression(this, [])]), Statement(break, []), Statement(}, []), Statement(case ERROR:, []), Statement({, []), AssignmentExpression(=, [VariableReference(WebChromeClient client, []), Expression(mWebView.getWebChromeClient(), [])]), AssignmentExpression(=, [VariableReference(if (client !, []), Expression(null) {, [])]), MethodCall(client.onHideCustomView(), [VariableReference(client, []), Expression(, [])]), Statement(}, []), Statement(break, []), Statement(}, []), Statement(case LOAD_DEFAULT_POSTER:, []), Statement({, []), AssignmentExpression(=, [VariableReference(WebChromeClient client, []), Expression(mWebView.getWebChromeClient(), [])]), AssignmentExpression(=, [VariableReference(if (client !, []), Expression(null) {, [])]), MethodCall(doSetPoster(client.getDefaultVideoPoster()), [VariableReference(doSetPoster(client, []), Expression(), [])]), Statement(}, []), Statement(break, []), Statement(}, []), Statement(}, []), Statement(}, [])])  Statement({, [])  Statement(// This executes on the UI thread., [])  Statement(case PLAY:, [])  Statement({, [])  AssignmentExpression(=, [VariableReference(String url, []), Expression((String) msg.obj, [])])    VariableReference(String url, [])    Expression((String) msg.obj, [])  AssignmentExpression(=, [VariableReference(WebChromeClient client, []), Expression(mWebView.getWebChromeClient(), [])])    VariableReference(WebChromeClient client, [])    Expression(mWebView.getWebChromeClient(), [])  AssignmentExpression(=, [VariableReference(if (client !, []), Expression(null) {, [])])    VariableReference(if (client !, [])    Expression(null) {, [])  MethodCall(VideoPlayer.play(url, mSeekPosition, this, client), [VariableReference(VideoPlayer, []), Expression(url, []), Expression(mSeekPosition, []), Expression(this, []), Expression(client, [])])    VariableReference(VideoPlayer, [])    Expression(url, [])    Expression(mSeekPosition, [])    Expression(this, [])    Expression(client, [])  Statement(}, [])  Statement(break, [])  Statement(}, [])  Statement(case SEEK:, [])  Statement({, [])  AssignmentExpression(=, [VariableReference(Integer time, []), Expression((Integer) msg.obj, [])])    VariableReference(Integer time, [])    Expression((Integer) msg.obj, [])  AssignmentExpression(=, [VariableReference(mSeekPosition, []), Expression(time, [])])    VariableReference(mSeekPosition, [])    Expression(time, [])  MethodCall(VideoPlayer.seek(mSeekPosition, this), [VariableReference(VideoPlayer, []), Expression(mSeekPosition, []), Expression(this, [])])    VariableReference(VideoPlayer, [])    Expression(mSeekPosition, [])    Expression(this, [])  Statement(break, [])  Statement(}, [])  Statement(case PAUSE:, [])  Statement({, [])  MethodCall(VideoPlayer.pause(this), [VariableReference(VideoPlayer, []), Expression(this, [])])    VariableReference(VideoPlayer, [])    Expression(this, [])  Statement(break, [])  Statement(}, [])  Statement(case ERROR:, [])  Statement({, [])  AssignmentExpression(=, [VariableReference(WebChromeClient client, []), Expression(mWebView.getWebChromeClient(), [])])    VariableReference(WebChromeClient client, [])    Expression(mWebView.getWebChromeClient(), [])  AssignmentExpression(=, [VariableReference(if (client !, []), Expression(null) {, [])])    VariableReference(if (client !, [])    Expression(null) {, [])  MethodCall(client.onHideCustomView(), [VariableReference(client, []), Expression(, [])])    VariableReference(client, [])    Expression(, [])  Statement(}, [])  Statement(break, [])  Statement(}, [])  Statement(case LOAD_DEFAULT_POSTER:, [])  Statement({, [])  AssignmentExpression(=, [VariableReference(WebChromeClient client, []), Expression(mWebView.getWebChromeClient(), [])])    VariableReference(WebChromeClient client, [])    Expression(mWebView.getWebChromeClient(), [])  AssignmentExpression(=, [VariableReference(if (client !, []), Expression(null) {, [])])    VariableReference(if (client !, [])    Expression(null) {, [])  MethodCall(doSetPoster(client.getDefaultVideoPoster()), [VariableReference(doSetPoster(client, []), Expression(), [])])    VariableReference(doSetPoster(client, [])    Expression(), [])  Statement(}, [])  Statement(break, [])  Statement(}, [])  Statement(}, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(// This executes on the UI thread., []), Statement(case PLAY:, []), Statement({, []), AssignmentExpression(=, [VariableReference(String url, []), Expression((String) msg.obj, [])]), AssignmentExpression(=, [VariableReference(WebChromeClient client, []), Expression(mWebView.getWebChromeClient(), [])]), AssignmentExpression(=, [VariableReference(if (client !, []), Expression(null) {, [])]), MethodCall(VideoPlayer.play(url, mSeekPosition, this, client), [VariableReference(VideoPlayer, []), Expression(url, []), Expression(mSeekPosition, []), Expression(this, []), Expression(client, [])]), Statement(}, []), Statement(break, []), Statement(}, []), Statement(case SEEK:, []), Statement({, []), AssignmentExpression(=, [VariableReference(Integer time, []), Expression((Integer) msg.obj, [])]), AssignmentExpression(=, [VariableReference(mSeekPosition, []), Expression(time, [])]), MethodCall(VideoPlayer.seek(mSeekPosition, this), [VariableReference(VideoPlayer, []), Expression(mSeekPosition, []), Expression(this, [])]), Statement(break, []), Statement(}, []), Statement(case PAUSE:, []), Statement({, []), MethodCall(VideoPlayer.pause(this), [VariableReference(VideoPlayer, []), Expression(this, [])]), Statement(break, []), Statement(}, []), Statement(case ENDED:, []), Statement(case ERROR:, []), Statement({, []), AssignmentExpression(=, [VariableReference(WebChromeClient client, []), Expression(mWebView.getWebChromeClient(), [])]), AssignmentExpression(=, [VariableReference(if (client !, []), Expression(null) {, [])]), MethodCall(client.onHideCustomView(), [VariableReference(client, []), Expression(, [])]), Statement(}, []), Statement(break, []), Statement(}, []), Statement(case LOAD_DEFAULT_POSTER:, []), Statement({, []), AssignmentExpression(=, [VariableReference(WebChromeClient client, []), Expression(mWebView.getWebChromeClient(), [])]), AssignmentExpression(=, [VariableReference(if (client !, []), Expression(null) {, [])]), MethodCall(doSetPoster(client.getDefaultVideoPoster()), [VariableReference(doSetPoster(client, []), Expression(), [])]), Statement(}, []), Statement(break, []), Statement(}, []), Statement(case TIMEUPDATE:, []), Statement({, []), MethodCall(if (VideoPlayer.isPlaying(this)), [VariableReference(if (VideoPlayer, []), Expression(this), [])]), Statement(sendTimeupdate(), []), Statement(}, []), Statement(break, []), Statement(}, []), Statement(}, []), Statement(}, [])])  Statement({, [])  Statement(// This executes on the UI thread., [])  Statement(case PLAY:, [])  Statement({, [])  AssignmentExpression(=, [VariableReference(String url, []), Expression((String) msg.obj, [])])    VariableReference(String url, [])    Expression((String) msg.obj, [])  AssignmentExpression(=, [VariableReference(WebChromeClient client, []), Expression(mWebView.getWebChromeClient(), [])])    VariableReference(WebChromeClient client, [])    Expression(mWebView.getWebChromeClient(), [])  AssignmentExpression(=, [VariableReference(if (client !, []), Expression(null) {, [])])    VariableReference(if (client !, [])    Expression(null) {, [])  MethodCall(VideoPlayer.play(url, mSeekPosition, this, client), [VariableReference(VideoPlayer, []), Expression(url, []), Expression(mSeekPosition, []), Expression(this, []), Expression(client, [])])    VariableReference(VideoPlayer, [])    Expression(url, [])    Expression(mSeekPosition, [])    Expression(this, [])    Expression(client, [])  Statement(}, [])  Statement(break, [])  Statement(}, [])  Statement(case SEEK:, [])  Statement({, [])  AssignmentExpression(=, [VariableReference(Integer time, []), Expression((Integer) msg.obj, [])])    VariableReference(Integer time, [])    Expression((Integer) msg.obj, [])  AssignmentExpression(=, [VariableReference(mSeekPosition, []), Expression(time, [])])    VariableReference(mSeekPosition, [])    Expression(time, [])  MethodCall(VideoPlayer.seek(mSeekPosition, this), [VariableReference(VideoPlayer, []), Expression(mSeekPosition, []), Expression(this, [])])    VariableReference(VideoPlayer, [])    Expression(mSeekPosition, [])    Expression(this, [])  Statement(break, [])  Statement(}, [])  Statement(case PAUSE:, [])  Statement({, [])  MethodCall(VideoPlayer.pause(this), [VariableReference(VideoPlayer, []), Expression(this, [])])    VariableReference(VideoPlayer, [])    Expression(this, [])  Statement(break, [])  Statement(}, [])  Statement(case ENDED:, [])  Statement(case ERROR:, [])  Statement({, [])  AssignmentExpression(=, [VariableReference(WebChromeClient client, []), Expression(mWebView.getWebChromeClient(), [])])    VariableReference(WebChromeClient client, [])    Expression(mWebView.getWebChromeClient(), [])  AssignmentExpression(=, [VariableReference(if (client !, []), Expression(null) {, [])])    VariableReference(if (client !, [])    Expression(null) {, [])  MethodCall(client.onHideCustomView(), [VariableReference(client, []), Expression(, [])])    VariableReference(client, [])    Expression(, [])  Statement(}, [])  Statement(break, [])  Statement(}, [])  Statement(case LOAD_DEFAULT_POSTER:, [])  Statement({, [])  AssignmentExpression(=, [VariableReference(WebChromeClient client, []), Expression(mWebView.getWebChromeClient(), [])])    VariableReference(WebChromeClient client, [])    Expression(mWebView.getWebChromeClient(), [])  AssignmentExpression(=, [VariableReference(if (client !, []), Expression(null) {, [])])    VariableReference(if (client !, [])    Expression(null) {, [])  MethodCall(doSetPoster(client.getDefaultVideoPoster()), [VariableReference(doSetPoster(client, []), Expression(), [])])    VariableReference(doSetPoster(client, [])    Expression(), [])  Statement(}, [])  Statement(break, [])  Statement(}, [])  Statement(case TIMEUPDATE:, [])  Statement({, [])  MethodCall(if (VideoPlayer.isPlaying(this)), [VariableReference(if (VideoPlayer, []), Expression(this), [])])    VariableReference(if (VideoPlayer, [])    Expression(this), [])  Statement(sendTimeupdate(), [])  Statement(}, [])  Statement(break, [])  Statement(}, [])  Statement(}, [])  Statement(}, [])",1,"// Handler for the messages from WebCore thread to the UI thread.
","// Handler for the messages from WebCore or Timer thread to the UI thread.
",1,[@Override],[@Override],0,,,0,"1,2",3,0,"1,3",1,"A new `case TIMEUPDATE:` block has been added, introducing changes in control flow and adding new method calls (`if (VideoPlayer.isPlaying(this)` and `sendTimeupdate()`) thus, the change type is 1,3.",
140,<android.webkit.HTML5VideoViewProxy: void handleMessage(Message)>,8,9,<android.webkit.HTML5VideoViewProxy: void handleMessage(Message)>,<android.webkit.HTML5VideoViewProxy: void handleMessage(Message)>,0,"MethodDeclaration(method_body, [Statement({, []), Statement(// This executes on the UI thread., []), Statement(case PLAY:, []), Statement({, []), AssignmentExpression(=, [VariableReference(String url, []), Expression((String) msg.obj, [])]), AssignmentExpression(=, [VariableReference(WebChromeClient client, []), Expression(mWebView.getWebChromeClient(), [])]), AssignmentExpression(=, [VariableReference(if (client !, []), Expression(null) {, [])]), MethodCall(VideoPlayer.play(url, mSeekPosition, this, client), [VariableReference(VideoPlayer, []), Expression(url, []), Expression(mSeekPosition, []), Expression(this, []), Expression(client, [])]), Statement(}, []), Statement(break, []), Statement(}, []), Statement(case SEEK:, []), Statement({, []), AssignmentExpression(=, [VariableReference(Integer time, []), Expression((Integer) msg.obj, [])]), AssignmentExpression(=, [VariableReference(mSeekPosition, []), Expression(time, [])]), MethodCall(VideoPlayer.seek(mSeekPosition, this), [VariableReference(VideoPlayer, []), Expression(mSeekPosition, []), Expression(this, [])]), Statement(break, []), Statement(}, []), Statement(case PAUSE:, []), Statement({, []), MethodCall(VideoPlayer.pause(this), [VariableReference(VideoPlayer, []), Expression(this, [])]), Statement(break, []), Statement(}, []), Statement(case ENDED:, []), Statement(case ERROR:, []), Statement({, []), AssignmentExpression(=, [VariableReference(WebChromeClient client, []), Expression(mWebView.getWebChromeClient(), [])]), AssignmentExpression(=, [VariableReference(if (client !, []), Expression(null) {, [])]), MethodCall(client.onHideCustomView(), [VariableReference(client, []), Expression(, [])]), Statement(}, []), Statement(break, []), Statement(}, []), Statement(case LOAD_DEFAULT_POSTER:, []), Statement({, []), AssignmentExpression(=, [VariableReference(WebChromeClient client, []), Expression(mWebView.getWebChromeClient(), [])]), AssignmentExpression(=, [VariableReference(if (client !, []), Expression(null) {, [])]), MethodCall(doSetPoster(client.getDefaultVideoPoster()), [VariableReference(doSetPoster(client, []), Expression(), [])]), Statement(}, []), Statement(break, []), Statement(}, []), Statement(case TIMEUPDATE:, []), Statement({, []), MethodCall(if (VideoPlayer.isPlaying(this)), [VariableReference(if (VideoPlayer, []), Expression(this), [])]), Statement(sendTimeupdate(), []), Statement(}, []), Statement(break, []), Statement(}, []), Statement(}, []), Statement(}, [])])  Statement({, [])  Statement(// This executes on the UI thread., [])  Statement(case PLAY:, [])  Statement({, [])  AssignmentExpression(=, [VariableReference(String url, []), Expression((String) msg.obj, [])])    VariableReference(String url, [])    Expression((String) msg.obj, [])  AssignmentExpression(=, [VariableReference(WebChromeClient client, []), Expression(mWebView.getWebChromeClient(), [])])    VariableReference(WebChromeClient client, [])    Expression(mWebView.getWebChromeClient(), [])  AssignmentExpression(=, [VariableReference(if (client !, []), Expression(null) {, [])])    VariableReference(if (client !, [])    Expression(null) {, [])  MethodCall(VideoPlayer.play(url, mSeekPosition, this, client), [VariableReference(VideoPlayer, []), Expression(url, []), Expression(mSeekPosition, []), Expression(this, []), Expression(client, [])])    VariableReference(VideoPlayer, [])    Expression(url, [])    Expression(mSeekPosition, [])    Expression(this, [])    Expression(client, [])  Statement(}, [])  Statement(break, [])  Statement(}, [])  Statement(case SEEK:, [])  Statement({, [])  AssignmentExpression(=, [VariableReference(Integer time, []), Expression((Integer) msg.obj, [])])    VariableReference(Integer time, [])    Expression((Integer) msg.obj, [])  AssignmentExpression(=, [VariableReference(mSeekPosition, []), Expression(time, [])])    VariableReference(mSeekPosition, [])    Expression(time, [])  MethodCall(VideoPlayer.seek(mSeekPosition, this), [VariableReference(VideoPlayer, []), Expression(mSeekPosition, []), Expression(this, [])])    VariableReference(VideoPlayer, [])    Expression(mSeekPosition, [])    Expression(this, [])  Statement(break, [])  Statement(}, [])  Statement(case PAUSE:, [])  Statement({, [])  MethodCall(VideoPlayer.pause(this), [VariableReference(VideoPlayer, []), Expression(this, [])])    VariableReference(VideoPlayer, [])    Expression(this, [])  Statement(break, [])  Statement(}, [])  Statement(case ENDED:, [])  Statement(case ERROR:, [])  Statement({, [])  AssignmentExpression(=, [VariableReference(WebChromeClient client, []), Expression(mWebView.getWebChromeClient(), [])])    VariableReference(WebChromeClient client, [])    Expression(mWebView.getWebChromeClient(), [])  AssignmentExpression(=, [VariableReference(if (client !, []), Expression(null) {, [])])    VariableReference(if (client !, [])    Expression(null) {, [])  MethodCall(client.onHideCustomView(), [VariableReference(client, []), Expression(, [])])    VariableReference(client, [])    Expression(, [])  Statement(}, [])  Statement(break, [])  Statement(}, [])  Statement(case LOAD_DEFAULT_POSTER:, [])  Statement({, [])  AssignmentExpression(=, [VariableReference(WebChromeClient client, []), Expression(mWebView.getWebChromeClient(), [])])    VariableReference(WebChromeClient client, [])    Expression(mWebView.getWebChromeClient(), [])  AssignmentExpression(=, [VariableReference(if (client !, []), Expression(null) {, [])])    VariableReference(if (client !, [])    Expression(null) {, [])  MethodCall(doSetPoster(client.getDefaultVideoPoster()), [VariableReference(doSetPoster(client, []), Expression(), [])])    VariableReference(doSetPoster(client, [])    Expression(), [])  Statement(}, [])  Statement(break, [])  Statement(}, [])  Statement(case TIMEUPDATE:, [])  Statement({, [])  MethodCall(if (VideoPlayer.isPlaying(this)), [VariableReference(if (VideoPlayer, []), Expression(this), [])])    VariableReference(if (VideoPlayer, [])    Expression(this), [])  Statement(sendTimeupdate(), [])  Statement(}, [])  Statement(break, [])  Statement(}, [])  Statement(}, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(// This executes on the UI thread., []), Statement(case PLAY:, []), Statement({, []), AssignmentExpression(=, [VariableReference(String url, []), Expression((String) msg.obj, [])]), AssignmentExpression(=, [VariableReference(WebChromeClient client, []), Expression(mWebView.getWebChromeClient(), [])]), AssignmentExpression(=, [VariableReference(if (client !, []), Expression(null) {, [])]), MethodCall(VideoPlayer.play(url, mSeekPosition, this, client), [VariableReference(VideoPlayer, []), Expression(url, []), Expression(mSeekPosition, []), Expression(this, []), Expression(client, [])]), Statement(}, []), Statement(break, []), Statement(}, []), Statement(case SEEK:, []), Statement({, []), AssignmentExpression(=, [VariableReference(Integer time, []), Expression((Integer) msg.obj, [])]), AssignmentExpression(=, [VariableReference(mSeekPosition, []), Expression(time, [])]), MethodCall(VideoPlayer.seek(mSeekPosition, this), [VariableReference(VideoPlayer, []), Expression(mSeekPosition, []), Expression(this, [])]), Statement(break, []), Statement(}, []), Statement(case PAUSE:, []), Statement({, []), MethodCall(VideoPlayer.pause(this), [VariableReference(VideoPlayer, []), Expression(this, [])]), Statement(break, []), Statement(}, []), Statement(case ENDED:, []), AssignmentExpression(=, [VariableReference(if (msg.arg1, []), Expression(, [])]), AssignmentExpression(=, [VariableReference(VideoPlayer.isVideoSelfEnded, []), Expression(true, [])]), Statement(case ERROR:, []), Statement({, []), AssignmentExpression(=, [VariableReference(WebChromeClient client, []), Expression(mWebView.getWebChromeClient(), [])]), AssignmentExpression(=, [VariableReference(if (client !, []), Expression(null) {, [])]), MethodCall(client.onHideCustomView(), [VariableReference(client, []), Expression(, [])]), Statement(}, []), Statement(break, []), Statement(}, []), Statement(case LOAD_DEFAULT_POSTER:, []), Statement({, []), AssignmentExpression(=, [VariableReference(WebChromeClient client, []), Expression(mWebView.getWebChromeClient(), [])]), AssignmentExpression(=, [VariableReference(if (client !, []), Expression(null) {, [])]), MethodCall(doSetPoster(client.getDefaultVideoPoster()), [VariableReference(doSetPoster(client, []), Expression(), [])]), Statement(}, []), Statement(break, []), Statement(}, []), Statement(case TIMEUPDATE:, []), Statement({, []), MethodCall(if (VideoPlayer.isPlaying(this)), [VariableReference(if (VideoPlayer, []), Expression(this), [])]), Statement(sendTimeupdate(), []), Statement(}, []), Statement(break, []), Statement(}, []), Statement(}, []), Statement(}, [])])  Statement({, [])  Statement(// This executes on the UI thread., [])  Statement(case PLAY:, [])  Statement({, [])  AssignmentExpression(=, [VariableReference(String url, []), Expression((String) msg.obj, [])])    VariableReference(String url, [])    Expression((String) msg.obj, [])  AssignmentExpression(=, [VariableReference(WebChromeClient client, []), Expression(mWebView.getWebChromeClient(), [])])    VariableReference(WebChromeClient client, [])    Expression(mWebView.getWebChromeClient(), [])  AssignmentExpression(=, [VariableReference(if (client !, []), Expression(null) {, [])])    VariableReference(if (client !, [])    Expression(null) {, [])  MethodCall(VideoPlayer.play(url, mSeekPosition, this, client), [VariableReference(VideoPlayer, []), Expression(url, []), Expression(mSeekPosition, []), Expression(this, []), Expression(client, [])])    VariableReference(VideoPlayer, [])    Expression(url, [])    Expression(mSeekPosition, [])    Expression(this, [])    Expression(client, [])  Statement(}, [])  Statement(break, [])  Statement(}, [])  Statement(case SEEK:, [])  Statement({, [])  AssignmentExpression(=, [VariableReference(Integer time, []), Expression((Integer) msg.obj, [])])    VariableReference(Integer time, [])    Expression((Integer) msg.obj, [])  AssignmentExpression(=, [VariableReference(mSeekPosition, []), Expression(time, [])])    VariableReference(mSeekPosition, [])    Expression(time, [])  MethodCall(VideoPlayer.seek(mSeekPosition, this), [VariableReference(VideoPlayer, []), Expression(mSeekPosition, []), Expression(this, [])])    VariableReference(VideoPlayer, [])    Expression(mSeekPosition, [])    Expression(this, [])  Statement(break, [])  Statement(}, [])  Statement(case PAUSE:, [])  Statement({, [])  MethodCall(VideoPlayer.pause(this), [VariableReference(VideoPlayer, []), Expression(this, [])])    VariableReference(VideoPlayer, [])    Expression(this, [])  Statement(break, [])  Statement(}, [])  Statement(case ENDED:, [])  AssignmentExpression(=, [VariableReference(if (msg.arg1, []), Expression(, [])])    VariableReference(if (msg.arg1, [])    Expression(, [])  AssignmentExpression(=, [VariableReference(VideoPlayer.isVideoSelfEnded, []), Expression(true, [])])    VariableReference(VideoPlayer.isVideoSelfEnded, [])    Expression(true, [])  Statement(case ERROR:, [])  Statement({, [])  AssignmentExpression(=, [VariableReference(WebChromeClient client, []), Expression(mWebView.getWebChromeClient(), [])])    VariableReference(WebChromeClient client, [])    Expression(mWebView.getWebChromeClient(), [])  AssignmentExpression(=, [VariableReference(if (client !, []), Expression(null) {, [])])    VariableReference(if (client !, [])    Expression(null) {, [])  MethodCall(client.onHideCustomView(), [VariableReference(client, []), Expression(, [])])    VariableReference(client, [])    Expression(, [])  Statement(}, [])  Statement(break, [])  Statement(}, [])  Statement(case LOAD_DEFAULT_POSTER:, [])  Statement({, [])  AssignmentExpression(=, [VariableReference(WebChromeClient client, []), Expression(mWebView.getWebChromeClient(), [])])    VariableReference(WebChromeClient client, [])    Expression(mWebView.getWebChromeClient(), [])  AssignmentExpression(=, [VariableReference(if (client !, []), Expression(null) {, [])])    VariableReference(if (client !, [])    Expression(null) {, [])  MethodCall(doSetPoster(client.getDefaultVideoPoster()), [VariableReference(doSetPoster(client, []), Expression(), [])])    VariableReference(doSetPoster(client, [])    Expression(), [])  Statement(}, [])  Statement(break, [])  Statement(}, [])  Statement(case TIMEUPDATE:, [])  Statement({, [])  MethodCall(if (VideoPlayer.isPlaying(this)), [VariableReference(if (VideoPlayer, []), Expression(this), [])])    VariableReference(if (VideoPlayer, [])    Expression(this), [])  Statement(sendTimeupdate(), [])  Statement(}, [])  Statement(break, [])  Statement(}, [])  Statement(}, [])  Statement(}, [])",1,"// Handler for the messages from WebCore or Timer thread to the UI thread.
","// Handler for the messages from WebCore or Timer thread to the UI thread.
",0,[@Override],[@Override],0,,,0,1,"3,4",0,3,0,"The ENDED case in the switch statement has been modified to include two assignment expressions, so the change type is 3.","Given the added assignment expressions, there is no evidence that the method will potentially return different values or throw different exceptions; thus, no compatibility issue exists."
141,"<android.content.ContentProvider: int bulkInsert(Uri,ContentValues[])>",8,9,"<android.content.ContentProvider: int bulkInsert(Uri,ContentValues[])>","<android.content.ContentProvider: int bulkInsert(Uri,ContentValues[])>",0,"MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(int numValues, []), Expression(values.length, [])]), AssignmentExpression(=, [VariableReference(for (int i, []), Expression(0, [])]), Statement(i < numValues, []), Statement(i++) {, []), Statement(insert(uri, values[i]), []), Statement(}, []), Statement(return numValues, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(int numValues, []), Expression(values.length, [])])    VariableReference(int numValues, [])    Expression(values.length, [])  AssignmentExpression(=, [VariableReference(for (int i, []), Expression(0, [])])    VariableReference(for (int i, [])    Expression(0, [])  Statement(i < numValues, [])  Statement(i++) {, [])  Statement(insert(uri, values[i]), [])  Statement(}, [])  Statement(return numValues, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(int numValues, []), Expression(values.length, [])]), AssignmentExpression(=, [VariableReference(for (int i, []), Expression(0, [])]), Statement(i < numValues, []), Statement(i++) {, []), Statement(insert(uri, values[i]), []), Statement(}, []), Statement(return numValues, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(int numValues, []), Expression(values.length, [])])    VariableReference(int numValues, [])    Expression(values.length, [])  AssignmentExpression(=, [VariableReference(for (int i, []), Expression(0, [])])    VariableReference(for (int i, [])    Expression(0, [])  Statement(i < numValues, [])  Statement(i++) {, [])  Statement(insert(uri, values[i]), [])  Statement(}, [])  Statement(return numValues, [])  Statement(}, [])",0,"/**
 * Implement this to insert a set of new rows, or the default implementation will
 * iterate over the values and call {@link #insert} on each of them.
 * As a courtesy, call {@link ContentResolver#notifyChange(android.net.Uri ,android.database.ContentObserver) notifyChange()}
 * after inserting.
 * This method can be called from multiple
 * threads, as described in
 * <a href=""{@docRoot}guide/topics/fundamentals.html#procthread"">Application Fundamentals:
 * Processes and Threads</a>.
 *
 * @param uri The content:// URI of the insertion request.
 * @param values An array of sets of column_name/value pairs to add to the database.
 * @return The number of values that were inserted.
 */
","/**
 * Override this to handle requests to insert a set of new rows, or the
 * default implementation will iterate over the values and call
 * {@link #insert} on each of them.
 * As a courtesy, call {@link ContentResolver#notifyChange(android.net.Uri ,android.database.ContentObserver) notifyChange()}
 * after inserting.
 * This method can be called from multiple threads, as described in
 * <a href=""{@docRoot}guide/topics/fundamentals.html#procthread"">Application Fundamentals:
 * Processes and Threads</a>.
 *
 * @param uri The content:// URI of the insertion request.
 * @param values An array of sets of column_name/value pairs to add to the database.
 * @return The number of values that were inserted.
 */
",1,,,0,,,0,0,0,0,0,0,"There are no changes in the implementation, comments, or annotations between the two versions.","As there are no changes in the code, there are no compatibility issues."
142,<android.widget.ProgressBar: boolean isIndeterminate()>,8,9,<android.widget.ProgressBar: boolean isIndeterminate()>,<android.widget.ProgressBar: boolean isIndeterminate()>,0,"MethodDeclaration(method_body, [Statement({, []), Statement(return mIndeterminate, []), Statement(}, [])])  Statement({, [])  Statement(return mIndeterminate, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(return mIndeterminate, []), Statement(}, [])])  Statement({, [])  Statement(return mIndeterminate, [])  Statement(}, [])",0,"/**
 * <p>Indicate whether this progress bar is in indeterminate mode.</p>
 *
 * @return true if the progress bar is in indeterminate mode
 */
","/**
 * <p>Indicate whether this progress bar is in indeterminate mode.</p>
 *
 * @return true if the progress bar is in indeterminate mode
 */
",0,[@ViewDebug.ExportedProperty],[@ViewDebug.ExportedProperty(category = "progress")],1,,,0,0,0,0,4,0,"The only change is an annotation change from `@ViewDebug.ExportedProperty` to `@ViewDebug.ExportedProperty(category = ""progress"")`. This change does not affect the method's implementation, so the code change type is 4.","The change in the annotation does not lead to any difference in return values or exception handling. Therefore, no Compatibility Issue exists."
143,<android.app.Activity: void performStop()>,9,10,<android.app.Activity: void performStop()>,<android.app.Activity: void performStop()>,0,"MethodDeclaration(method_body, [Statement({, []), Statement(if (!mStopped) {, []), AssignmentExpression(=, [VariableReference(if (mWindow !, []), Expression(null) {, [])]), MethodCall(mWindow.closeAllPanels(), [VariableReference(mWindow, []), Expression(, [])]), Statement(}, []), AssignmentExpression(=, [VariableReference(mCalled, []), Expression(false, [])]), MethodCall(mInstrumentation.callActivityOnStop(this), [VariableReference(mInstrumentation, []), Expression(this, [])]), Statement(if (!mCalled) {, []), MethodCall(throw new SuperNotCalledException(""Activity "" + mComponent.toShortString() + "" did not call through to super.onStop()""), [VariableReference(throw new SuperNotCalledException(""Activity "" + mComponent, []), Expression() + "" did not call through to super.onStop()"", [])]), Statement(}, []), Statement(synchronized (mManagedCursors) {, []), AssignmentExpression(=, [VariableReference(final int N, []), Expression(mManagedCursors.size(), [])]), AssignmentExpression(=, [VariableReference(for (int i, []), Expression(0, [])]), Statement(i < N, []), Statement(i++) {, []), AssignmentExpression(=, [VariableReference(ManagedCursor mc, []), Expression(mManagedCursors.get(i), [])]), AssignmentExpression(=, [VariableReference(mc.mReleased, []), Expression(true, [])]), Statement(}, []), Statement(}, []), Statement(}, []), AssignmentExpression(=, [VariableReference(mStopped, []), Expression(true, [])]), Statement(}, []), AssignmentExpression(=, [VariableReference(mResumed, []), Expression(false, [])]), Statement(}, [])])  Statement({, [])  Statement(if (!mStopped) {, [])  AssignmentExpression(=, [VariableReference(if (mWindow !, []), Expression(null) {, [])])    VariableReference(if (mWindow !, [])    Expression(null) {, [])  MethodCall(mWindow.closeAllPanels(), [VariableReference(mWindow, []), Expression(, [])])    VariableReference(mWindow, [])    Expression(, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(mCalled, []), Expression(false, [])])    VariableReference(mCalled, [])    Expression(false, [])  MethodCall(mInstrumentation.callActivityOnStop(this), [VariableReference(mInstrumentation, []), Expression(this, [])])    VariableReference(mInstrumentation, [])    Expression(this, [])  Statement(if (!mCalled) {, [])  MethodCall(throw new SuperNotCalledException(""Activity "" + mComponent.toShortString() + "" did not call through to super.onStop()""), [VariableReference(throw new SuperNotCalledException(""Activity "" + mComponent, []), Expression() + "" did not call through to super.onStop()"", [])])    VariableReference(throw new SuperNotCalledException(""Activity "" + mComponent, [])    Expression() + "" did not call through to super.onStop()"", [])  Statement(}, [])  Statement(synchronized (mManagedCursors) {, [])  AssignmentExpression(=, [VariableReference(final int N, []), Expression(mManagedCursors.size(), [])])    VariableReference(final int N, [])    Expression(mManagedCursors.size(), [])  AssignmentExpression(=, [VariableReference(for (int i, []), Expression(0, [])])    VariableReference(for (int i, [])    Expression(0, [])  Statement(i < N, [])  Statement(i++) {, [])  AssignmentExpression(=, [VariableReference(ManagedCursor mc, []), Expression(mManagedCursors.get(i), [])])    VariableReference(ManagedCursor mc, [])    Expression(mManagedCursors.get(i), [])  AssignmentExpression(=, [VariableReference(mc.mReleased, []), Expression(true, [])])    VariableReference(mc.mReleased, [])    Expression(true, [])  Statement(}, [])  Statement(}, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(mStopped, []), Expression(true, [])])    VariableReference(mStopped, [])    Expression(true, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(mResumed, []), Expression(false, [])])    VariableReference(mResumed, [])    Expression(false, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(if (!mStopped) {, []), AssignmentExpression(=, [VariableReference(if (mWindow !, []), Expression(null) {, [])]), MethodCall(mWindow.closeAllPanels(), [VariableReference(mWindow, []), Expression(, [])]), Statement(}, []), AssignmentExpression(=, [VariableReference(mCalled, []), Expression(false, [])]), MethodCall(mInstrumentation.callActivityOnStop(this), [VariableReference(mInstrumentation, []), Expression(this, [])]), Statement(if (!mCalled) {, []), MethodCall(throw new SuperNotCalledException(""Activity "" + mComponent.toShortString() + "" did not call through to super.onStop()""), [VariableReference(throw new SuperNotCalledException(""Activity "" + mComponent, []), Expression() + "" did not call through to super.onStop()"", [])]), Statement(}, []), Statement(synchronized (mManagedCursors) {, []), AssignmentExpression(=, [VariableReference(final int N, []), Expression(mManagedCursors.size(), [])]), AssignmentExpression(=, [VariableReference(for (int i, []), Expression(0, [])]), Statement(i < N, []), Statement(i++) {, []), AssignmentExpression(=, [VariableReference(ManagedCursor mc, []), Expression(mManagedCursors.get(i), [])]), AssignmentExpression(=, [VariableReference(mc.mReleased, []), Expression(true, [])]), Statement(}, []), Statement(}, []), Statement(}, []), AssignmentExpression(=, [VariableReference(mStopped, []), Expression(true, [])]), Statement(}, []), Statement(}, [])])  Statement({, [])  Statement(if (!mStopped) {, [])  AssignmentExpression(=, [VariableReference(if (mWindow !, []), Expression(null) {, [])])    VariableReference(if (mWindow !, [])    Expression(null) {, [])  MethodCall(mWindow.closeAllPanels(), [VariableReference(mWindow, []), Expression(, [])])    VariableReference(mWindow, [])    Expression(, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(mCalled, []), Expression(false, [])])    VariableReference(mCalled, [])    Expression(false, [])  MethodCall(mInstrumentation.callActivityOnStop(this), [VariableReference(mInstrumentation, []), Expression(this, [])])    VariableReference(mInstrumentation, [])    Expression(this, [])  Statement(if (!mCalled) {, [])  MethodCall(throw new SuperNotCalledException(""Activity "" + mComponent.toShortString() + "" did not call through to super.onStop()""), [VariableReference(throw new SuperNotCalledException(""Activity "" + mComponent, []), Expression() + "" did not call through to super.onStop()"", [])])    VariableReference(throw new SuperNotCalledException(""Activity "" + mComponent, [])    Expression() + "" did not call through to super.onStop()"", [])  Statement(}, [])  Statement(synchronized (mManagedCursors) {, [])  AssignmentExpression(=, [VariableReference(final int N, []), Expression(mManagedCursors.size(), [])])    VariableReference(final int N, [])    Expression(mManagedCursors.size(), [])  AssignmentExpression(=, [VariableReference(for (int i, []), Expression(0, [])])    VariableReference(for (int i, [])    Expression(0, [])  Statement(i < N, [])  Statement(i++) {, [])  AssignmentExpression(=, [VariableReference(ManagedCursor mc, []), Expression(mManagedCursors.get(i), [])])    VariableReference(ManagedCursor mc, [])    Expression(mManagedCursors.get(i), [])  AssignmentExpression(=, [VariableReference(mc.mReleased, []), Expression(true, [])])    VariableReference(mc.mReleased, [])    Expression(true, [])  Statement(}, [])  Statement(}, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(mStopped, []), Expression(true, [])])    VariableReference(mStopped, [])    Expression(true, [])  Statement(}, [])  Statement(}, [])",1,,,0,,,0,,,0,1,4,0,0,0,There is no code change between the early and late versions of the method.,"As there is no code change, there is no Compatibility Issue."
144,"<android.database.sqlite.SQLiteDatabase: long replaceOrThrow(String,String,ContentValues)>",9,10,"<android.database.sqlite.SQLiteDatabase: long replaceOrThrow(String,String,ContentValues)>","<android.database.sqlite.SQLiteDatabase: long replaceOrThrow(String,String,ContentValues)>",0,"MethodDeclaration(method_body, [Statement({, []), Statement(return insertWithOnConflict(table, nullColumnHack, initialValues, CONFLICT_REPLACE), []), Statement(}, [])])  Statement({, [])  Statement(return insertWithOnConflict(table, nullColumnHack, initialValues, CONFLICT_REPLACE), [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(return insertWithOnConflict(table, nullColumnHack, initialValues, CONFLICT_REPLACE), []), Statement(}, [])])  Statement({, [])  Statement(return insertWithOnConflict(table, nullColumnHack, initialValues, CONFLICT_REPLACE), [])  Statement(}, [])",0,"/**
 * Convenience method for replacing a row in the database.
 *
 * @param table the table in which to replace the row
 * @param nullColumnHack SQL doesn't allow inserting a completely empty row,
 * so if initialValues is empty this row will explicitly be
 * assigned a NULL value
 * @param initialValues this map contains the initial column values for
 * the row. The key
 * @throws SQLException
 * @return the row ID of the newly inserted row, or -1 if an error occurred
 */
","/**
 * Convenience method for replacing a row in the database.
 *
 * @param table the table in which to replace the row
 * @param nullColumnHack optional; may be <code>null</code>.
 * SQL doesn't allow inserting a completely empty row without
 * naming at least one column name.  If your provided <code>initialValues</code> is
 * empty, no column names are known and an empty row can't be inserted.
 * If not set to null, the <code>nullColumnHack</code> parameter
 * provides the name of nullable column name to explicitly insert a NULL into
 * in the case where your <code>initialValues</code> is empty.
 * @param initialValues this map contains the initial column values for
 * the row. The key
 * @throws SQLException
 * @return the row ID of the newly inserted row, or -1 if an error occurred
 */
",1,,,0,,,0,0,0,0,0,0,"There are no code changes between the early and late implementation versions. The only differences are in the comments, which provide more detailed explanations in the late version, but comment changes do not affect code behavior. Hence, the code change type is 0.","Since there are no changes in the implementation code, the API behavior remains unchanged between the two versions. Therefore, no Compatibility Issue exists (CI type is 0)."
145,<android.widget.AbsListView: void hideSelector()>,13,14,<android.widget.AbsListView: void hideSelector()>,<android.widget.AbsListView: void hideSelector()>,0,"MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(if (mSelectedPosition !, []), Expression(INVALID_POSITION) {, [])]), AssignmentExpression(=, [VariableReference(if (mLayoutMode !, []), Expression(LAYOUT_SPECIFIC) {, [])]), AssignmentExpression(=, [VariableReference(mResurrectToPosition, []), Expression(mSelectedPosition, [])]), Statement(}, []), AssignmentExpression(=, [VariableReference(if (mNextSelectedPosition >, []), Expression(0 && mNextSelectedPosition !, [])]), AssignmentExpression(=, [VariableReference(mResurrectToPosition, []), Expression(mNextSelectedPosition, [])]), Statement(}, []), Statement(setSelectedPositionInt(INVALID_POSITION), []), Statement(setNextSelectedPositionInt(INVALID_POSITION), []), AssignmentExpression(=, [VariableReference(mSelectedTop, []), Expression(0, [])]), AssignmentExpression(=, [VariableReference(mSelectorShowing, []), Expression(false, [])]), Statement(}, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(if (mSelectedPosition !, []), Expression(INVALID_POSITION) {, [])])    VariableReference(if (mSelectedPosition !, [])    Expression(INVALID_POSITION) {, [])  AssignmentExpression(=, [VariableReference(if (mLayoutMode !, []), Expression(LAYOUT_SPECIFIC) {, [])])    VariableReference(if (mLayoutMode !, [])    Expression(LAYOUT_SPECIFIC) {, [])  AssignmentExpression(=, [VariableReference(mResurrectToPosition, []), Expression(mSelectedPosition, [])])    VariableReference(mResurrectToPosition, [])    Expression(mSelectedPosition, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(if (mNextSelectedPosition >, []), Expression(0 && mNextSelectedPosition !, [])])    VariableReference(if (mNextSelectedPosition >, [])    Expression(0 && mNextSelectedPosition !, [])  AssignmentExpression(=, [VariableReference(mResurrectToPosition, []), Expression(mNextSelectedPosition, [])])    VariableReference(mResurrectToPosition, [])    Expression(mNextSelectedPosition, [])  Statement(}, [])  Statement(setSelectedPositionInt(INVALID_POSITION), [])  Statement(setNextSelectedPositionInt(INVALID_POSITION), [])  AssignmentExpression(=, [VariableReference(mSelectedTop, []), Expression(0, [])])    VariableReference(mSelectedTop, [])    Expression(0, [])  AssignmentExpression(=, [VariableReference(mSelectorShowing, []), Expression(false, [])])    VariableReference(mSelectorShowing, [])    Expression(false, [])  Statement(}, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(if (mSelectedPosition !, []), Expression(INVALID_POSITION) {, [])]), AssignmentExpression(=, [VariableReference(if (mLayoutMode !, []), Expression(LAYOUT_SPECIFIC) {, [])]), AssignmentExpression(=, [VariableReference(mResurrectToPosition, []), Expression(mSelectedPosition, [])]), Statement(}, []), AssignmentExpression(=, [VariableReference(if (mNextSelectedPosition >, []), Expression(0 && mNextSelectedPosition !, [])]), AssignmentExpression(=, [VariableReference(mResurrectToPosition, []), Expression(mNextSelectedPosition, [])]), Statement(}, []), Statement(setSelectedPositionInt(INVALID_POSITION), []), Statement(setNextSelectedPositionInt(INVALID_POSITION), []), AssignmentExpression(=, [VariableReference(mSelectedTop, []), Expression(0, [])]), Statement(}, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(if (mSelectedPosition !, []), Expression(INVALID_POSITION) {, [])])    VariableReference(if (mSelectedPosition !, [])    Expression(INVALID_POSITION) {, [])  AssignmentExpression(=, [VariableReference(if (mLayoutMode !, []), Expression(LAYOUT_SPECIFIC) {, [])])    VariableReference(if (mLayoutMode !, [])    Expression(LAYOUT_SPECIFIC) {, [])  AssignmentExpression(=, [VariableReference(mResurrectToPosition, []), Expression(mSelectedPosition, [])])    VariableReference(mResurrectToPosition, [])    Expression(mSelectedPosition, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(if (mNextSelectedPosition >, []), Expression(0 && mNextSelectedPosition !, [])])    VariableReference(if (mNextSelectedPosition >, [])    Expression(0 && mNextSelectedPosition !, [])  AssignmentExpression(=, [VariableReference(mResurrectToPosition, []), Expression(mNextSelectedPosition, [])])    VariableReference(mResurrectToPosition, [])    Expression(mNextSelectedPosition, [])  Statement(}, [])  Statement(setSelectedPositionInt(INVALID_POSITION), [])  Statement(setNextSelectedPositionInt(INVALID_POSITION), [])  AssignmentExpression(=, [VariableReference(mSelectedTop, []), Expression(0, [])])    VariableReference(mSelectedTop, [])    Expression(0, [])  Statement(}, [])  Statement(}, [])",1,,,0,,,0,,,0,1,4,0,"3,4",0,The statements regarding the variable `mSelectorShowing` have been removed from the late version. This falls under control dependency change (3) and other statement change (4).,"The change doesn't directly affect return values or exception handling. Thus, no Compatibility Issue exists."
146,"<android.database.CursorWindow: String getString(int,int)>",13,14,"<android.database.CursorWindow: String getString(int,int)>","<android.database.CursorWindow: String getString(int,int)>",0,"MethodDeclaration(method_body, [Statement({, []), Statement(acquireReference(), []), Statement(try {, []), Statement(return getString_native(row - mStartPos, col), []), Statement(} finally {, []), Statement(releaseReference(), []), Statement(}, []), Statement(}, [])])  Statement({, [])  Statement(acquireReference(), [])  Statement(try {, [])  Statement(return getString_native(row - mStartPos, col), [])  Statement(} finally {, [])  Statement(releaseReference(), [])  Statement(}, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(acquireReference(), []), Statement(try {, []), Statement(return nativeGetString(mWindowPtr, row - mStartPos, column), []), Statement(} finally {, []), Statement(releaseReference(), []), Statement(}, []), Statement(}, [])])  Statement({, [])  Statement(acquireReference(), [])  Statement(try {, [])  Statement(return nativeGetString(mWindowPtr, row - mStartPos, column), [])  Statement(} finally {, [])  Statement(releaseReference(), [])  Statement(}, [])  Statement(}, [])",1,"/**
 * Returns a String for the given field.
 *
 * @param row the row to read from, row - getStartPosition() being the actual row in the window
 * @param col the column to read from
 * @return a String value for the given field
 */
","/**
 * Gets the value of the field at the specified row and column index as a string.
 * <p>
 * The result is determined as follows:
 * <ul>
 * <li>If the field is of type {@link Cursor#FIELD_TYPE_NULL}, then the result
 * is <code>null</code>.</li>
 * <li>If the field is of type {@link Cursor#FIELD_TYPE_STRING}, then the result
 * is the string value.</li>
 * <li>If the field is of type {@link Cursor#FIELD_TYPE_INTEGER}, then the result
 * is a string representation of the integer in decimal, obtained by formatting the
 * value with the <code>printf</code> family of functions using
 * format specifier <code>%lld</code>.</li>
 * <li>If the field is of type {@link Cursor#FIELD_TYPE_FLOAT}, then the result
 * is a string representation of the floating-point value in decimal, obtained by
 * formatting the value with the <code>printf</code> family of functions using
 * format specifier <code>%g</code>.</li>
 * <li>If the field is of type {@link Cursor#FIELD_TYPE_BLOB}, then a
 * {@link SQLiteException} is thrown.</li>
 * </ul>
 * </p>
 *
 * @param row The zero-based row index, relative to the cursor window's
 * start position ({@link #getStartPosition()}).
 * @param column The zero-based column index.
 * @return The value of the field as a string.
 */
",1,,,0,,,0,"1,2","1,5",1,"1,5",1,"The return statement has been changed from getString_native(row - mStartPos, col) to nativeGetString(mWindowPtr, row - mStartPos, column). This means the method being called and its parameters have changed, which indicates a potential return value change. The code change type is 1,5.","Since the return value is derived from a different method and with potentially different parameters, the API could return different results. Hence, the CI type is 1."
147,<android.view.View: boolean dispatchHoverEvent(MotionEvent)>,14,15,<android.view.View: boolean dispatchHoverEvent(MotionEvent)>,<android.view.View: boolean dispatchHoverEvent(MotionEvent)>,0,"MethodDeclaration(method_body, [Statement({, []), Statement(// noinspection SimplifiableIfStatement, []), AssignmentExpression(=, [VariableReference(if (mOnHoverListener !, []), Expression(null && (mViewFlags & ENABLED_MASK), [])]), Statement(return true, []), Statement(}, []), Statement(return onHoverEvent(event), []), Statement(}, [])])  Statement({, [])  Statement(// noinspection SimplifiableIfStatement, [])  AssignmentExpression(=, [VariableReference(if (mOnHoverListener !, []), Expression(null && (mViewFlags & ENABLED_MASK), [])])    VariableReference(if (mOnHoverListener !, [])    Expression(null && (mViewFlags & ENABLED_MASK), [])  Statement(return true, [])  Statement(}, [])  Statement(return onHoverEvent(event), [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(// noinspection SimplifiableIfStatement, []), AssignmentExpression(=, [VariableReference(ListenerInfo li, []), Expression(mListenerInfo, [])]), AssignmentExpression(=, [VariableReference(if (li !, []), Expression(null && li.mOnHoverListener !, [])]), Statement(return true, []), Statement(}, []), Statement(return onHoverEvent(event), []), Statement(}, [])])  Statement({, [])  Statement(// noinspection SimplifiableIfStatement, [])  AssignmentExpression(=, [VariableReference(ListenerInfo li, []), Expression(mListenerInfo, [])])    VariableReference(ListenerInfo li, [])    Expression(mListenerInfo, [])  AssignmentExpression(=, [VariableReference(if (li !, []), Expression(null && li.mOnHoverListener !, [])])    VariableReference(if (li !, [])    Expression(null && li.mOnHoverListener !, [])  Statement(return true, [])  Statement(}, [])  Statement(return onHoverEvent(event), [])  Statement(}, [])",1,"/**
 * Dispatch a hover event.
 * <p>
 * Do not call this method directly.
 * Call {@link #dispatchGenericMotionEvent(MotionEvent)} instead.
 * </p>
 *
 * @param event The motion event to be dispatched.
 * @return True if the event was handled by the view, false otherwise.
 */
","/**
 * Dispatch a hover event.
 * <p>
 * Do not call this method directly.
 * Call {@link #dispatchGenericMotionEvent(MotionEvent)} instead.
 * </p>
 *
 * @param event The motion event to be dispatched.
 * @return True if the event was handled by the view, false otherwise.
 */
",0,,,0,,,0,1,4,1,4,0,"The implementation changed how the `mOnHoverListener` is accessed: previously accessing directly through `mOnHoverListener`, in the latest version, accessing through `li.mOnHoverListener` where `li` is assigned from `mListenerInfo`. This suggests a slight refactoring of the listener information storage.","The core functionality and behavior of the method remain unchanged, which results in no compatibility issues. Thus, the CI type is 0."
148,"<android.database.CursorWindow: String getString(int,int)>",14,15,"<android.database.CursorWindow: String getString(int,int)>","<android.database.CursorWindow: String getString(int,int)>",0,"MethodDeclaration(method_body, [Statement({, []), Statement(acquireReference(), []), Statement(try {, []), Statement(return nativeGetString(mWindowPtr, row - mStartPos, column), []), Statement(} finally {, []), Statement(releaseReference(), []), Statement(}, []), Statement(}, [])])  Statement({, [])  Statement(acquireReference(), [])  Statement(try {, [])  Statement(return nativeGetString(mWindowPtr, row - mStartPos, column), [])  Statement(} finally {, [])  Statement(releaseReference(), [])  Statement(}, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(acquireReference(), []), Statement(try {, []), Statement(return nativeGetString(mWindowPtr, row - mStartPos, column), []), Statement(} finally {, []), Statement(releaseReference(), []), Statement(}, []), Statement(}, [])])  Statement({, [])  Statement(acquireReference(), [])  Statement(try {, [])  Statement(return nativeGetString(mWindowPtr, row - mStartPos, column), [])  Statement(} finally {, [])  Statement(releaseReference(), [])  Statement(}, [])  Statement(}, [])",0,"/**
 * Gets the value of the field at the specified row and column index as a string.
 * <p>
 * The result is determined as follows:
 * <ul>
 * <li>If the field is of type {@link Cursor#FIELD_TYPE_NULL}, then the result
 * is <code>null</code>.</li>
 * <li>If the field is of type {@link Cursor#FIELD_TYPE_STRING}, then the result
 * is the string value.</li>
 * <li>If the field is of type {@link Cursor#FIELD_TYPE_INTEGER}, then the result
 * is a string representation of the integer in decimal, obtained by formatting the
 * value with the <code>printf</code> family of functions using
 * format specifier <code>%lld</code>.</li>
 * <li>If the field is of type {@link Cursor#FIELD_TYPE_FLOAT}, then the result
 * is a string representation of the floating-point value in decimal, obtained by
 * formatting the value with the <code>printf</code> family of functions using
 * format specifier <code>%g</code>.</li>
 * <li>If the field is of type {@link Cursor#FIELD_TYPE_BLOB}, then a
 * {@link SQLiteException} is thrown.</li>
 * </ul>
 * </p>
 *
 * @param row The zero-based row index, relative to the cursor window's
 * start position ({@link #getStartPosition()}).
 * @param column The zero-based column index.
 * @return The value of the field as a string.
 */
","/**
 * Gets the value of the field at the specified row and column index as a string.
 * <p>
 * The result is determined as follows:
 * <ul>
 * <li>If the field is of type {@link Cursor#FIELD_TYPE_NULL}, then the result
 * is <code>null</code>.</li>
 * <li>If the field is of type {@link Cursor#FIELD_TYPE_STRING}, then the result
 * is the string value.</li>
 * <li>If the field is of type {@link Cursor#FIELD_TYPE_INTEGER}, then the result
 * is a string representation of the integer in decimal, obtained by formatting the
 * value with the <code>printf</code> family of functions using
 * format specifier <code>%lld</code>.</li>
 * <li>If the field is of type {@link Cursor#FIELD_TYPE_FLOAT}, then the result
 * is a string representation of the floating-point value in decimal, obtained by
 * formatting the value with the <code>printf</code> family of functions using
 * format specifier <code>%g</code>.</li>
 * <li>If the field is of type {@link Cursor#FIELD_TYPE_BLOB}, then a
 * {@link SQLiteException} is thrown.</li>
 * </ul>
 * </p>
 *
 * @param row The zero-based row index.
 * @param column The zero-based column index.
 * @return The value of the field as a string.
 */
",1,,,0,,,0,0,0,0,0,0,"There is no change in the implementation, comments, or annotations between the early and late versions. The addition of the explicit mention that the row index is zero-based is a minor detail and does not affect the method's behavior.","Since there is no change in the implementation that could lead to different return values, exception throwing, or control dependencies, there is no Compatibility Issue."
149,<android.content.AsyncTaskLoader.LoadTask: void onPostExecute(D)>,15,16,<android.content.AsyncTaskLoader.LoadTask: void onPostExecute(D)>,<android.content.AsyncTaskLoader.LoadTask: void onPostExecute(D)>,0,"MethodDeclaration(method_body, [Statement({, []), Statement(if (DEBUG), []), MethodCall(Slog.v(TAG, this + "" onPostExecute""), [VariableReference(Slog, []), Expression(TAG, []), Expression(this + "" onPostExecute"", [])]), Statement(try {, []), Statement(} finally {, []), MethodCall(done.countDown(), [VariableReference(done, []), Expression(, [])]), Statement(}, []), Statement(}, [])])  Statement({, [])  Statement(if (DEBUG), [])  MethodCall(Slog.v(TAG, this + "" onPostExecute""), [VariableReference(Slog, []), Expression(TAG, []), Expression(this + "" onPostExecute"", [])])    VariableReference(Slog, [])    Expression(TAG, [])    Expression(this + "" onPostExecute"", [])  Statement(try {, [])  Statement(} finally {, [])  MethodCall(done.countDown(), [VariableReference(done, []), Expression(, [])])    VariableReference(done, [])    Expression(, [])  Statement(}, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(if (DEBUG), []), MethodCall(Slog.v(TAG, this + "" onPostExecute""), [VariableReference(Slog, []), Expression(TAG, []), Expression(this + "" onPostExecute"", [])]), Statement(try {, []), Statement(} finally {, []), MethodCall(mDone.countDown(), [VariableReference(mDone, []), Expression(, [])]), Statement(}, []), Statement(}, [])])  Statement({, [])  Statement(if (DEBUG), [])  MethodCall(Slog.v(TAG, this + "" onPostExecute""), [VariableReference(Slog, []), Expression(TAG, []), Expression(this + "" onPostExecute"", [])])    VariableReference(Slog, [])    Expression(TAG, [])    Expression(this + "" onPostExecute"", [])  Statement(try {, [])  Statement(} finally {, [])  MethodCall(mDone.countDown(), [VariableReference(mDone, []), Expression(, [])])    VariableReference(mDone, [])    Expression(, [])  Statement(}, [])  Statement(}, [])",1,"/* Runs on the UI thread */
","/* Runs on the UI thread */
",0,[@Override],[@Override],0,,,0,"1,2",5,0,4,0,"The only change is the variable name from `done` to `mDone` in the code. This is a straightforward variable renaming, so the code change type is 4.","The change is only a renaming of a variable, which does not affect the logic of the API. Therefore, no compatibility issue exists, so the CI type is 0."
150,"<android.widget.RemoteViews: void setInt(int,String,int)>",15,16,"<android.widget.RemoteViews: void setInt(int,String,int)>","<android.widget.RemoteViews: void setInt(int,String,int)>",0,"MethodDeclaration(method_body, [Statement({, []), Statement(}, [])])  Statement({, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(}, [])])  Statement({, [])  Statement(}, [])",0,"/**
 * Call a method taking one int on a view in the layout for this RemoteViews.
 *
 * @param viewId The id of the view whose text should change
 * @param methodName The name of the method to call.
 * @param value The value to pass to the method.
 */
","/**
 * Call a method taking one int on a view in the layout for this RemoteViews.
 *
 * @param viewId The id of the view on which to call the method.
 * @param methodName The name of the method to call.
 * @param value The value to pass to the method.
 */
",1,,,0,,,0,0,0,0,0,0,Both implementations in the early and late versions are identical as per the AST node representations provided. The comments and parameters in both versions are also essentially the same.,"Since there are no implementation changes between these versions, no Compatibility Issue exists."
151,<android.webkit.WebView: boolean shouldDelayChildPressedState()>,15,16,<android.webkit.WebView: boolean shouldDelayChildPressedState()>,<android.webkit.WebView: boolean shouldDelayChildPressedState()>,0,"MethodDeclaration(method_body, [Statement({, []), Statement(return true, []), Statement(}, [])])  Statement({, [])  Statement(return true, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), MethodCall(return mProvider.getViewDelegate().shouldDelayChildPressedState(), [VariableReference(return mProvider, []), Expression().shouldDelayChildPressedState(, [])]), Statement(}, [])])  Statement({, [])  MethodCall(return mProvider.getViewDelegate().shouldDelayChildPressedState(), [VariableReference(return mProvider, []), Expression().shouldDelayChildPressedState(, [])])    VariableReference(return mProvider, [])    Expression().shouldDelayChildPressedState(, [])  Statement(}, [])",1,,,0,[@Override],"[@Deprecated, @Override]",1,,,0,"1,2","1,5",1,"1,5",1,"The return statement has changed from a constant value (`return true`) to a method call (`return mProvider.getViewDelegate().shouldDelayChildPressedState()`). The dependent API (`mProvider.getViewDelegate().shouldDelayChildPressedState()`) has also been introduced. Hence, the code change type is 1,5.","The change in the return statement can cause the method to return different values since the return value now depends on the dependent method (`mProvider.getViewDelegate().shouldDelayChildPressedState()`), which could yield different results. Therefore, the CI type is 1."
152,<android.server.search.SearchManagerService: ComponentName getWebSearchActivity()>,16,17,<android.server.search.SearchManagerService: ComponentName getWebSearchActivity()>,<android.server.search.SearchManagerService: ComponentName getWebSearchActivity()>,0,"MethodDeclaration(method_body, [Statement({, []), MethodCall(return getSearchables().getWebSearchActivity(), [VariableReference(return getSearchables(), []), Expression(, [])]), Statement(}, [])])  Statement({, [])  MethodCall(return getSearchables().getWebSearchActivity(), [VariableReference(return getSearchables(), []), Expression(, [])])    VariableReference(return getSearchables(), [])    Expression(, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), MethodCall(return getSearchables(UserHandle.getCallingUserId()).getWebSearchActivity(), [VariableReference(return getSearchables(UserHandle, []), Expression()).getWebSearchActivity(, [])]), Statement(}, [])])  Statement({, [])  MethodCall(return getSearchables(UserHandle.getCallingUserId()).getWebSearchActivity(), [VariableReference(return getSearchables(UserHandle, []), Expression()).getWebSearchActivity(, [])])    VariableReference(return getSearchables(UserHandle, [])    Expression()).getWebSearchActivity(, [])  Statement(}, [])",1,"/**
 * Gets the name of the web search activity.
 */
","/**
 * Gets the name of the web search activity.
 */
",0,,,0,,,0,"1,2","1,5",1,3,0,"The method call getSearchables() has been changed to getSearchables(UserHandle.getCallingUserId()), which alters the control dependency but does not introduce changes to return statements or exception handling.","The control dependency change does not lead to a change in return value or exception handling in the given context, so no Compatibility Issue exists."
153,<android.webkit.AccessibilityInjector: void addAccessibilityApisIfNecessary()>,16,17,<android.webkit.AccessibilityInjector: void addAccessibilityApisIfNecessary()>,<android.webkit.AccessibilityInjector: void addAccessibilityApisIfNecessary()>,0,"MethodDeclaration(method_body, [Statement({, []), Statement(if (!isAccessibilityEnabled() || !isJavaScriptEnabled()) {, []), Statement(return, []), Statement(}, []), Statement(addTtsApis(), []), Statement(addCallbackApis(), []), Statement(}, [])])  Statement({, [])  Statement(if (!isAccessibilityEnabled() || !isJavaScriptEnabled()) {, [])  Statement(return, [])  Statement(}, [])  Statement(addTtsApis(), [])  Statement(addCallbackApis(), [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(if (!isAccessibilityEnabled() || !isJavaScriptEnabled()) {, []), Statement(return, []), Statement(}, []), Statement(addTtsApis(), []), Statement(addCallbackApis(), []), Statement(}, [])])  Statement({, [])  Statement(if (!isAccessibilityEnabled() || !isJavaScriptEnabled()) {, [])  Statement(return, [])  Statement(}, [])  Statement(addTtsApis(), [])  Statement(addCallbackApis(), [])  Statement(}, [])",0,"/**
 * Attempts to load scripting interfaces for accessibility.
 * <p>
 * This should be called when the window is attached.
 * </p>
 */
","/**
 * Attempts to load scripting interfaces for accessibility.
 * <p>
 * This should only be called before a page loads.
 */
",1,,,0,,,0,0,0,0,0,0,"There is no change in the implementation code between the two versions. Therefore, the code change type is 0.","Since there is no change in the implementation code, the CI type is 0. The difference in comments does not impact the actual method behavior."
154,"<android.webkit.AccessibilityInjector.CallbackHandler: void onResult(String,String)>",16,17,"<android.webkit.AccessibilityInjector.CallbackHandler: void onResult(String,String)>","<android.webkit.AccessibilityInjector.CallbackHandler: void onResult(String,String)>",0,"MethodDeclaration(method_body, [Statement({, []), Statement(final long resultId, []), Statement(try {, []), AssignmentExpression(=, [VariableReference(resultId, []), Expression(Long.parseLong(id), [])]), Statement(} catch (NumberFormatException e) {, []), Statement(return, []), Statement(}, []), Statement(synchronized (mResultLock) {, []), Statement(if (resultId > mResultId) {, []), AssignmentExpression(=, [VariableReference(mResult, []), Expression(Boolean.parseBoolean(result), [])]), AssignmentExpression(=, [VariableReference(mResultId, []), Expression(resultId, [])]), Statement(}, []), MethodCall(mResultLock.notifyAll(), [VariableReference(mResultLock, []), Expression(, [])]), Statement(}, []), Statement(}, [])])  Statement({, [])  Statement(final long resultId, [])  Statement(try {, [])  AssignmentExpression(=, [VariableReference(resultId, []), Expression(Long.parseLong(id), [])])    VariableReference(resultId, [])    Expression(Long.parseLong(id), [])  Statement(} catch (NumberFormatException e) {, [])  Statement(return, [])  Statement(}, [])  Statement(synchronized (mResultLock) {, [])  Statement(if (resultId > mResultId) {, [])  AssignmentExpression(=, [VariableReference(mResult, []), Expression(Boolean.parseBoolean(result), [])])    VariableReference(mResult, [])    Expression(Boolean.parseBoolean(result), [])  AssignmentExpression(=, [VariableReference(mResultId, []), Expression(resultId, [])])    VariableReference(mResultId, [])    Expression(resultId, [])  Statement(}, [])  MethodCall(mResultLock.notifyAll(), [VariableReference(mResultLock, []), Expression(, [])])    VariableReference(mResultLock, [])    Expression(, [])  Statement(}, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(if (DEBUG) {, []), MethodCall(Log.w(TAG, ""Saw CVOX result of '"" + result + ""' for ID "" + id), [VariableReference(Log, []), Expression(TAG, []), Expression(""Saw CVOX result of '"" + result + ""' for ID "" + id, [])]), Statement(}, []), Statement(final int resultId, []), Statement(try {, []), AssignmentExpression(=, [VariableReference(resultId, []), Expression(Integer.parseInt(id), [])]), Statement(} catch (NumberFormatException e) {, []), Statement(return, []), Statement(}, []), Statement(synchronized (mResultLock) {, []), Statement(if (resultId > mResultId) {, []), AssignmentExpression(=, [VariableReference(mResult, []), Expression(Boolean.parseBoolean(result), [])]), AssignmentExpression(=, [VariableReference(mResultId, []), Expression(resultId, [])]), Statement(} else {, []), Statement(if (DEBUG) {, []), MethodCall(Log.w(TAG, ""Result with ID "" + resultId + "" was stale vesus "" + mResultId), [VariableReference(Log, []), Expression(TAG, []), Expression(""Result with ID "" + resultId + "" was stale vesus "" + mResultId, [])]), Statement(}, []), Statement(}, []), MethodCall(mResultLock.notifyAll(), [VariableReference(mResultLock, []), Expression(, [])]), Statement(}, []), Statement(}, [])])  Statement({, [])  Statement(if (DEBUG) {, [])  MethodCall(Log.w(TAG, ""Saw CVOX result of '"" + result + ""' for ID "" + id), [VariableReference(Log, []), Expression(TAG, []), Expression(""Saw CVOX result of '"" + result + ""' for ID "" + id, [])])    VariableReference(Log, [])    Expression(TAG, [])    Expression(""Saw CVOX result of '"" + result + ""' for ID "" + id, [])  Statement(}, [])  Statement(final int resultId, [])  Statement(try {, [])  AssignmentExpression(=, [VariableReference(resultId, []), Expression(Integer.parseInt(id), [])])    VariableReference(resultId, [])    Expression(Integer.parseInt(id), [])  Statement(} catch (NumberFormatException e) {, [])  Statement(return, [])  Statement(}, [])  Statement(synchronized (mResultLock) {, [])  Statement(if (resultId > mResultId) {, [])  AssignmentExpression(=, [VariableReference(mResult, []), Expression(Boolean.parseBoolean(result), [])])    VariableReference(mResult, [])    Expression(Boolean.parseBoolean(result), [])  AssignmentExpression(=, [VariableReference(mResultId, []), Expression(resultId, [])])    VariableReference(mResultId, [])    Expression(resultId, [])  Statement(} else {, [])  Statement(if (DEBUG) {, [])  MethodCall(Log.w(TAG, ""Result with ID "" + resultId + "" was stale vesus "" + mResultId), [VariableReference(Log, []), Expression(TAG, []), Expression(""Result with ID "" + resultId + "" was stale vesus "" + mResultId, [])])    VariableReference(Log, [])    Expression(TAG, [])    Expression(""Result with ID "" + resultId + "" was stale vesus "" + mResultId, [])  Statement(}, [])  Statement(}, [])  MethodCall(mResultLock.notifyAll(), [VariableReference(mResultLock, []), Expression(, [])])    VariableReference(mResultLock, [])    Expression(, [])  Statement(}, [])  Statement(}, [])",1,"/**
 * Callback exposed to JavaScript. Handles returning the result of a
 * request to a waiting (or potentially timed out) thread.
 *
 * @param id The result id of the request as a {@link String}.
 * @param result The result of the request as a {@link String}.
 */
","/**
 * Callback exposed to JavaScript. Handles returning the result of a
 * request to a waiting (or potentially timed out) thread.
 *
 * @param id The result id of the request as a {@link String}.
 * @param result The result of the request as a {@link String}.
 */
",0,[@SuppressWarnings("unused")],"[@JavascriptInterface, @SuppressWarnings(""unused"")]",1,,,0,"1,2","3,4,5",1,"3,4",0,"The control flow has changed with the addition of logging statements conditioned on 'DEBUG'. The variable 'resultId' data type changed from 'long' to 'int', some `if` blocks and `else` block were added, so the change type is 3,4.","The overall functionality and return values of the method remain unaffected by these changes. Therefore, no compatibility issue exists (CI type 0)."
155,"<android.app.Activity: boolean startNextMatchingActivity(Intent,Bundle)>",17,18,"<android.app.Activity: boolean startNextMatchingActivity(Intent,Bundle)>","<android.app.Activity: boolean startNextMatchingActivity(Intent,Bundle)>",0,"MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(if (mParent, []), Expression(, [])]), Statement(try {, []), MethodCall(intent.setAllowFds(false), [VariableReference(intent, []), Expression(false, [])]), MethodCall(return ActivityManagerNative.getDefault().startNextMatchingActivity(mToken, intent, options), [VariableReference(return ActivityManagerNative, []), Expression().startNextMatchingActivity(mToken, []), Expression(intent, []), Expression(options, [])]), Statement(} catch (RemoteException e) {, []), Statement(// Empty, []), Statement(}, []), Statement(return false, []), Statement(}, []), Statement(throw new UnsupportedOperationException(""startNextMatchingActivity can only be called from a top-level activity""), []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(if (mParent, []), Expression(, [])])    VariableReference(if (mParent, [])    Expression(, [])  Statement(try {, [])  MethodCall(intent.setAllowFds(false), [VariableReference(intent, []), Expression(false, [])])    VariableReference(intent, [])    Expression(false, [])  MethodCall(return ActivityManagerNative.getDefault().startNextMatchingActivity(mToken, intent, options), [VariableReference(return ActivityManagerNative, []), Expression().startNextMatchingActivity(mToken, []), Expression(intent, []), Expression(options, [])])    VariableReference(return ActivityManagerNative, [])    Expression().startNextMatchingActivity(mToken, [])    Expression(intent, [])    Expression(options, [])  Statement(} catch (RemoteException e) {, [])  Statement(// Empty, [])  Statement(}, [])  Statement(return false, [])  Statement(}, [])  Statement(throw new UnsupportedOperationException(""startNextMatchingActivity can only be called from a top-level activity""), [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(if (mParent, []), Expression(, [])]), Statement(try {, []), MethodCall(intent.migrateExtraStreamToClipData(), [VariableReference(intent, []), Expression(, [])]), MethodCall(intent.prepareToLeaveProcess(), [VariableReference(intent, []), Expression(, [])]), MethodCall(return ActivityManagerNative.getDefault().startNextMatchingActivity(mToken, intent, options), [VariableReference(return ActivityManagerNative, []), Expression().startNextMatchingActivity(mToken, []), Expression(intent, []), Expression(options, [])]), Statement(} catch (RemoteException e) {, []), Statement(// Empty, []), Statement(}, []), Statement(return false, []), Statement(}, []), Statement(throw new UnsupportedOperationException(""startNextMatchingActivity can only be called from a top-level activity""), []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(if (mParent, []), Expression(, [])])    VariableReference(if (mParent, [])    Expression(, [])  Statement(try {, [])  MethodCall(intent.migrateExtraStreamToClipData(), [VariableReference(intent, []), Expression(, [])])    VariableReference(intent, [])    Expression(, [])  MethodCall(intent.prepareToLeaveProcess(), [VariableReference(intent, []), Expression(, [])])    VariableReference(intent, [])    Expression(, [])  MethodCall(return ActivityManagerNative.getDefault().startNextMatchingActivity(mToken, intent, options), [VariableReference(return ActivityManagerNative, []), Expression().startNextMatchingActivity(mToken, []), Expression(intent, []), Expression(options, [])])    VariableReference(return ActivityManagerNative, [])    Expression().startNextMatchingActivity(mToken, [])    Expression(intent, [])    Expression(options, [])  Statement(} catch (RemoteException e) {, [])  Statement(// Empty, [])  Statement(}, [])  Statement(return false, [])  Statement(}, [])  Statement(throw new UnsupportedOperationException(""startNextMatchingActivity can only be called from a top-level activity""), [])  Statement(}, [])",1,"/**
 * Special version of starting an activity, for use when you are replacing
 * other activity components.  You can use this to hand the Intent off
 * to the next Activity that can handle it.  You typically call this in
 * {@link #onCreate} with the Intent returned by {@link #getIntent}.
 *
 * @param intent The intent to dispatch to the next activity.  For
 * correct behavior, this must be the same as the Intent that started
 * your own activity; the only changes you can make are to the extras
 * inside of it.
 * @param options Additional options for how the Activity should be started.
 * See {@link android.content.Context#startActivity(Intent, Bundle)
 * Context.startActivity(Intent, Bundle)} for more details.
 *
 * @return Returns a boolean indicating whether there was another Activity
 * to start: true if there was a next activity to start, false if there
 * wasn't.  In general, if true is returned you will then want to call
 * finish() on yourself.
 */
","/**
 * Special version of starting an activity, for use when you are replacing
 * other activity components.  You can use this to hand the Intent off
 * to the next Activity that can handle it.  You typically call this in
 * {@link #onCreate} with the Intent returned by {@link #getIntent}.
 *
 * @param intent The intent to dispatch to the next activity.  For
 * correct behavior, this must be the same as the Intent that started
 * your own activity; the only changes you can make are to the extras
 * inside of it.
 * @param options Additional options for how the Activity should be started.
 * See {@link android.content.Context#startActivity(Intent, Bundle)
 * Context.startActivity(Intent, Bundle)} for more details.
 *
 * @return Returns a boolean indicating whether there was another Activity
 * to start: true if there was a next activity to start, false if there
 * wasn't.  In general, if true is returned you will then want to call
 * finish() on yourself.
 */
",0,,,0,,,0,"1,2",5,0,"4,5",0,"The early version of the method calls `intent.setAllowFds(false)`, while the late version of the method makes two calls: `intent.migrateExtraStreamToClipData()` and `intent.prepareToLeaveProcess()`. The main logic of starting the next activity remains the same (i.e., `ActivityManagerNative.getDefault().startNextMatchingActivity(mToken, intent, options)`), so the change type is 4,5.","The additional calls to `intent.migrateExtraStreamToClipData()` and `intent.prepareToLeaveProcess()` may imply more preparation steps for the intent before starting the next matching activity. However, these changes do not directly indicate a change in return values or exceptions thrown by this method itself. Hence, the CI type is 0."
156,"<android.content.ContentProvider: int bulkInsert(Uri,ContentValues[])>",17,18,"<android.content.ContentProvider: int bulkInsert(Uri,ContentValues[])>","<android.content.ContentProvider: int bulkInsert(Uri,ContentValues[])>",0,"MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(int numValues, []), Expression(values.length, [])]), AssignmentExpression(=, [VariableReference(for (int i, []), Expression(0, [])]), Statement(i < numValues, []), Statement(i++) {, []), Statement(insert(uri, values[i]), []), Statement(}, []), Statement(return numValues, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(int numValues, []), Expression(values.length, [])])    VariableReference(int numValues, [])    Expression(values.length, [])  AssignmentExpression(=, [VariableReference(for (int i, []), Expression(0, [])])    VariableReference(for (int i, [])    Expression(0, [])  Statement(i < numValues, [])  Statement(i++) {, [])  Statement(insert(uri, values[i]), [])  Statement(}, [])  Statement(return numValues, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(int numValues, []), Expression(values.length, [])]), AssignmentExpression(=, [VariableReference(for (int i, []), Expression(0, [])]), Statement(i < numValues, []), Statement(i++) {, []), Statement(insert(uri, values[i]), []), Statement(}, []), Statement(return numValues, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(int numValues, []), Expression(values.length, [])])    VariableReference(int numValues, [])    Expression(values.length, [])  AssignmentExpression(=, [VariableReference(for (int i, []), Expression(0, [])])    VariableReference(for (int i, [])    Expression(0, [])  Statement(i < numValues, [])  Statement(i++) {, [])  Statement(insert(uri, values[i]), [])  Statement(}, [])  Statement(return numValues, [])  Statement(}, [])",0,"/**
 * Override this to handle requests to insert a set of new rows, or the
 * default implementation will iterate over the values and call
 * {@link #insert} on each of them.
 * As a courtesy, call {@link ContentResolver#notifyChange(android.net.Uri ,android.database.ContentObserver) notifyChange()}
 * after inserting.
 * This method can be called from multiple threads, as described in
 * <a href=""{@docRoot}guide/topics/fundamentals/processes-and-threads.html#Threads"">Processes
 * and Threads</a>.
 *
 * @param uri The content:// URI of the insertion request.
 * @param values An array of sets of column_name/value pairs to add to the database.
 * @return The number of values that were inserted.
 */
","/**
 * Override this to handle requests to insert a set of new rows, or the
 * default implementation will iterate over the values and call
 * {@link #insert} on each of them.
 * As a courtesy, call {@link ContentResolver#notifyChange(android.net.Uri ,android.database.ContentObserver) notifyChange()}
 * after inserting.
 * This method can be called from multiple threads, as described in
 * <a href=""{@docRoot}guide/topics/fundamentals/processes-and-threads.html#Threads"">Processes
 * and Threads</a>.
 *
 * @param uri The content:// URI of the insertion request.
 * @param values An array of sets of column_name/value pairs to add to the database.
 * This must not be {@code null}.
 * @return The number of values that were inserted.
 */
",1,,,0,,,0,0,0,0,0,0,"The AST nodes for both the early and late implementations are identical. There is no change in the method body, indicating that the logic and behavior of the method have not been altered between versions 17 and 18.","Since there is no change in the method's implementation, there are no compatibility issues present. The API will behave the same in both versions, leading to no potential differences in return values, exception handling, or control flow. Therefore, the CI type is 0."
157,<android.view.Surface.CompatibleCanvas: void getMatrix(Matrix)>,17,18,<android.view.Surface.CompatibleCanvas: void getMatrix(Matrix)>,<android.view.Surface.CompatibleCanvas: void getMatrix(Matrix)>,0,"MethodDeclaration(method_body, [Statement({, []), MethodCall(super.getMatrix(m), [VariableReference(super, []), Expression(m, [])]), AssignmentExpression(=, [VariableReference(if (mOrigMatrix, []), Expression(, [])]), AssignmentExpression(=, [VariableReference(mOrigMatrix, []), Expression(new Matrix(), [])]), Statement(}, []), MethodCall(mOrigMatrix.set(m), [VariableReference(mOrigMatrix, []), Expression(m, [])]), Statement(}, [])])  Statement({, [])  MethodCall(super.getMatrix(m), [VariableReference(super, []), Expression(m, [])])    VariableReference(super, [])    Expression(m, [])  AssignmentExpression(=, [VariableReference(if (mOrigMatrix, []), Expression(, [])])    VariableReference(if (mOrigMatrix, [])    Expression(, [])  AssignmentExpression(=, [VariableReference(mOrigMatrix, []), Expression(new Matrix(), [])])    VariableReference(mOrigMatrix, [])    Expression(new Matrix(), [])  Statement(}, [])  MethodCall(mOrigMatrix.set(m), [VariableReference(mOrigMatrix, []), Expression(m, [])])    VariableReference(mOrigMatrix, [])    Expression(m, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), MethodCall(super.getMatrix(m), [VariableReference(super, []), Expression(m, [])]), AssignmentExpression(=, [VariableReference(if (mOrigMatrix, []), Expression(, [])]), AssignmentExpression(=, [VariableReference(mOrigMatrix, []), Expression(new Matrix(), [])]), Statement(}, []), MethodCall(mOrigMatrix.set(m), [VariableReference(mOrigMatrix, []), Expression(m, [])]), Statement(}, [])])  Statement({, [])  MethodCall(super.getMatrix(m), [VariableReference(super, []), Expression(m, [])])    VariableReference(super, [])    Expression(m, [])  AssignmentExpression(=, [VariableReference(if (mOrigMatrix, []), Expression(, [])])    VariableReference(if (mOrigMatrix, [])    Expression(, [])  AssignmentExpression(=, [VariableReference(mOrigMatrix, []), Expression(new Matrix(), [])])    VariableReference(mOrigMatrix, [])    Expression(new Matrix(), [])  Statement(}, [])  MethodCall(mOrigMatrix.set(m), [VariableReference(mOrigMatrix, []), Expression(m, [])])    VariableReference(mOrigMatrix, [])    Expression(m, [])  Statement(}, [])",0,,,0,[@Override],"[@SuppressWarnings(""deprecation""), @Override]",1,,,0,0,0,0,0,0,"There are no changes in the method body, and the only difference in the annotations is the addition of `@SuppressWarnings(""deprecation"")`. Since this annotation does not alter the implementation or behavior of the method, the code change type is 0.","Since the implementation remains the same, there are no compatibility issues. Thus, the CI type is 0."
158,"<android.widget.TextView: boolean onKeyDown(int,KeyEvent)>",18,19,"<android.widget.TextView: boolean onKeyDown(int,KeyEvent)>","<android.widget.TextView: boolean onKeyDown(int,KeyEvent)>",0,"MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(int which, []), Expression(doKeyDown(keyCode, event, null), [])]), AssignmentExpression(=, [VariableReference(if (which, []), Expression(, [])]), Statement(// Go through default dispatching., []), MethodCall(return super.onKeyDown(keyCode, event), [VariableReference(return super, []), Expression(keyCode, []), Expression(event, [])]), Statement(}, []), Statement(return true, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(int which, []), Expression(doKeyDown(keyCode, event, null), [])])    VariableReference(int which, [])    Expression(doKeyDown(keyCode, event, null), [])  AssignmentExpression(=, [VariableReference(if (which, []), Expression(, [])])    VariableReference(if (which, [])    Expression(, [])  Statement(// Go through default dispatching., [])  MethodCall(return super.onKeyDown(keyCode, event), [VariableReference(return super, []), Expression(keyCode, []), Expression(event, [])])    VariableReference(return super, [])    Expression(keyCode, [])    Expression(event, [])  Statement(}, [])  Statement(return true, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(int which, []), Expression(doKeyDown(keyCode, event, null), [])]), AssignmentExpression(=, [VariableReference(if (which, []), Expression(, [])]), MethodCall(return super.onKeyDown(keyCode, event), [VariableReference(return super, []), Expression(keyCode, []), Expression(event, [])]), Statement(}, []), Statement(return true, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(int which, []), Expression(doKeyDown(keyCode, event, null), [])])    VariableReference(int which, [])    Expression(doKeyDown(keyCode, event, null), [])  AssignmentExpression(=, [VariableReference(if (which, []), Expression(, [])])    VariableReference(if (which, [])    Expression(, [])  MethodCall(return super.onKeyDown(keyCode, event), [VariableReference(return super, []), Expression(keyCode, []), Expression(event, [])])    VariableReference(return super, [])    Expression(keyCode, [])    Expression(event, [])  Statement(}, [])  Statement(return true, [])  Statement(}, [])",1,,,0,[@Override],[@Override],0,,,0,0,0,0,0,0,Both the Early Implementation and Late Implementation are identical. There is no change detected in code.,There is no Compatibility Issue because there are no code changes between the early and late versions.
159,<android.view.View: void setSystemUiVisibility(int)>,18,19,<android.view.View: void setSystemUiVisibility(int)>,<android.view.View: void setSystemUiVisibility(int)>,0,"MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(if (visibility !, []), Expression(mSystemUiVisibility) {, [])]), AssignmentExpression(=, [VariableReference(mSystemUiVisibility, []), Expression(visibility, [])]), AssignmentExpression(=, [VariableReference(if (mParent !, []), Expression(null && mAttachInfo !, [])]), MethodCall(mParent.recomputeViewAttributes(this), [VariableReference(mParent, []), Expression(this, [])]), Statement(}, []), Statement(}, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(if (visibility !, []), Expression(mSystemUiVisibility) {, [])])    VariableReference(if (visibility !, [])    Expression(mSystemUiVisibility) {, [])  AssignmentExpression(=, [VariableReference(mSystemUiVisibility, []), Expression(visibility, [])])    VariableReference(mSystemUiVisibility, [])    Expression(visibility, [])  AssignmentExpression(=, [VariableReference(if (mParent !, []), Expression(null && mAttachInfo !, [])])    VariableReference(if (mParent !, [])    Expression(null && mAttachInfo !, [])  MethodCall(mParent.recomputeViewAttributes(this), [VariableReference(mParent, []), Expression(this, [])])    VariableReference(mParent, [])    Expression(this, [])  Statement(}, [])  Statement(}, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(if (visibility !, []), Expression(mSystemUiVisibility) {, [])]), AssignmentExpression(=, [VariableReference(mSystemUiVisibility, []), Expression(visibility, [])]), AssignmentExpression(=, [VariableReference(if (mParent !, []), Expression(null && mAttachInfo !, [])]), MethodCall(mParent.recomputeViewAttributes(this), [VariableReference(mParent, []), Expression(this, [])]), Statement(}, []), Statement(}, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(if (visibility !, []), Expression(mSystemUiVisibility) {, [])])    VariableReference(if (visibility !, [])    Expression(mSystemUiVisibility) {, [])  AssignmentExpression(=, [VariableReference(mSystemUiVisibility, []), Expression(visibility, [])])    VariableReference(mSystemUiVisibility, [])    Expression(visibility, [])  AssignmentExpression(=, [VariableReference(if (mParent !, []), Expression(null && mAttachInfo !, [])])    VariableReference(if (mParent !, [])    Expression(null && mAttachInfo !, [])  MethodCall(mParent.recomputeViewAttributes(this), [VariableReference(mParent, []), Expression(this, [])])    VariableReference(mParent, [])    Expression(this, [])  Statement(}, [])  Statement(}, [])  Statement(}, [])",0,"/**
 * Request that the visibility of the status bar or other screen/window
 * decorations be changed.
 *
 * <p>This method is used to put the over device UI into temporary modes
 * where the user's attention is focused more on the application content,
 * by dimming or hiding surrounding system affordances.  This is typically
 * used in conjunction with {@link Window#FEATURE_ACTION_BAR_OVERLAY
 * Window.FEATURE_ACTION_BAR_OVERLAY}, allowing the applications content
 * to be placed behind the action bar (and with these flags other system
 * affordances) so that smooth transitions between hiding and showing them
 * can be done.
 *
 * <p>Two representative examples of the use of system UI visibility is
 * implementing a content browsing application (like a magazine reader)
 * and a video playing application.
 *
 * <p>The first code shows a typical implementation of a View in a content
 * browsing application.  In this implementation, the application goes
 * into a content-oriented mode by hiding the status bar and action bar,
 * and putting the navigation elements into lights out mode.  The user can
 * then interact with content while in this mode.  Such an application should
 * provide an easy way for the user to toggle out of the mode (such as to
 * check information in the status bar or access notifications).  In the
 * implementation here, this is done simply by tapping on the content.
 *
 * {@sample development/samples/ApiDemos/src/com/example/android/apis/view/ContentBrowserActivity.java
 * content}
 *
 * <p>This second code sample shows a typical implementation of a View
 * in a video playing application.  In this situation, while the video is
 * playing the application would like to go into a complete full-screen mode,
 * to use as much of the display as possible for the video.  When in this state
 * the user can not interact with the application; the system intercepts
 * touching on the screen to pop the UI out of full screen mode.  See
 * {@link #fitSystemWindows(Rect)} for a sample layout that goes with this code.
 *
 * {@sample development/samples/ApiDemos/src/com/example/android/apis/view/VideoPlayerActivity.java
 * content}
 *
 * @param visibility  Bitwise-or of flags {@link #SYSTEM_UI_FLAG_LOW_PROFILE},
 * {@link #SYSTEM_UI_FLAG_HIDE_NAVIGATION}, {@link #SYSTEM_UI_FLAG_FULLSCREEN},
 * {@link #SYSTEM_UI_FLAG_LAYOUT_STABLE}, {@link #SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION},
 * and {@link #SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN}.
 */
","/**
 * Request that the visibility of the status bar or other screen/window
 * decorations be changed.
 *
 * <p>This method is used to put the over device UI into temporary modes
 * where the user's attention is focused more on the application content,
 * by dimming or hiding surrounding system affordances.  This is typically
 * used in conjunction with {@link Window#FEATURE_ACTION_BAR_OVERLAY
 * Window.FEATURE_ACTION_BAR_OVERLAY}, allowing the applications content
 * to be placed behind the action bar (and with these flags other system
 * affordances) so that smooth transitions between hiding and showing them
 * can be done.
 *
 * <p>Two representative examples of the use of system UI visibility is
 * implementing a content browsing application (like a magazine reader)
 * and a video playing application.
 *
 * <p>The first code shows a typical implementation of a View in a content
 * browsing application.  In this implementation, the application goes
 * into a content-oriented mode by hiding the status bar and action bar,
 * and putting the navigation elements into lights out mode.  The user can
 * then interact with content while in this mode.  Such an application should
 * provide an easy way for the user to toggle out of the mode (such as to
 * check information in the status bar or access notifications).  In the
 * implementation here, this is done simply by tapping on the content.
 *
 * {@sample development/samples/ApiDemos/src/com/example/android/apis/view/ContentBrowserActivity.java
 * content}
 *
 * <p>This second code sample shows a typical implementation of a View
 * in a video playing application.  In this situation, while the video is
 * playing the application would like to go into a complete full-screen mode,
 * to use as much of the display as possible for the video.  When in this state
 * the user can not interact with the application; the system intercepts
 * touching on the screen to pop the UI out of full screen mode.  See
 * {@link #fitSystemWindows(Rect)} for a sample layout that goes with this code.
 *
 * {@sample development/samples/ApiDemos/src/com/example/android/apis/view/VideoPlayerActivity.java
 * content}
 *
 * @param visibility  Bitwise-or of flags {@link #SYSTEM_UI_FLAG_LOW_PROFILE},
 * {@link #SYSTEM_UI_FLAG_HIDE_NAVIGATION}, {@link #SYSTEM_UI_FLAG_FULLSCREEN},
 * {@link #SYSTEM_UI_FLAG_LAYOUT_STABLE}, {@link #SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION},
 * {@link #SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN}, {@link #SYSTEM_UI_FLAG_IMMERSIVE},
 * and {@link #SYSTEM_UI_FLAG_IMMERSIVE_STICKY}.
 */
",1,,,0,,,0,0,0,0,0,0,There is no difference in the AST nodes between the two versions.,"Since there is no change in the AST nodes between the two versions, there is no compatibility issue."
160,"<android.webkit.WebView: void onMeasure(int,int)>",18,19,"<android.webkit.WebView: void onMeasure(int,int)>","<android.webkit.WebView: void onMeasure(int,int)>",0,"MethodDeclaration(method_body, [Statement({, []), MethodCall(super.onMeasure(widthMeasureSpec, heightMeasureSpec), [VariableReference(super, []), Expression(widthMeasureSpec, []), Expression(heightMeasureSpec, [])]), MethodCall(mProvider.getViewDelegate().onMeasure(widthMeasureSpec, heightMeasureSpec), [VariableReference(mProvider, []), Expression().onMeasure(widthMeasureSpec, []), Expression(heightMeasureSpec, [])]), Statement(}, [])])  Statement({, [])  MethodCall(super.onMeasure(widthMeasureSpec, heightMeasureSpec), [VariableReference(super, []), Expression(widthMeasureSpec, []), Expression(heightMeasureSpec, [])])    VariableReference(super, [])    Expression(widthMeasureSpec, [])    Expression(heightMeasureSpec, [])  MethodCall(mProvider.getViewDelegate().onMeasure(widthMeasureSpec, heightMeasureSpec), [VariableReference(mProvider, []), Expression().onMeasure(widthMeasureSpec, []), Expression(heightMeasureSpec, [])])    VariableReference(mProvider, [])    Expression().onMeasure(widthMeasureSpec, [])    Expression(heightMeasureSpec, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), MethodCall(super.onMeasure(widthMeasureSpec, heightMeasureSpec), [VariableReference(super, []), Expression(widthMeasureSpec, []), Expression(heightMeasureSpec, [])]), MethodCall(mProvider.getViewDelegate().onMeasure(widthMeasureSpec, heightMeasureSpec), [VariableReference(mProvider, []), Expression().onMeasure(widthMeasureSpec, []), Expression(heightMeasureSpec, [])]), Statement(}, [])])  Statement({, [])  MethodCall(super.onMeasure(widthMeasureSpec, heightMeasureSpec), [VariableReference(super, []), Expression(widthMeasureSpec, []), Expression(heightMeasureSpec, [])])    VariableReference(super, [])    Expression(widthMeasureSpec, [])    Expression(heightMeasureSpec, [])  MethodCall(mProvider.getViewDelegate().onMeasure(widthMeasureSpec, heightMeasureSpec), [VariableReference(mProvider, []), Expression().onMeasure(widthMeasureSpec, []), Expression(heightMeasureSpec, [])])    VariableReference(mProvider, [])    Expression().onMeasure(widthMeasureSpec, [])    Expression(heightMeasureSpec, [])  Statement(}, [])",0,,,0,"[@Deprecated, @Override]",[@Override],1,,,0,0,0,0,4,0,"Only the `@Deprecated` annotation has been removed in the late version, and there is no change in the method implementation, so the code change type is 4.","The change in the annotation does not affect the functionality or behavior of the method. Therefore, there are no compatibility issues, and the CI type is 0."
161,<android.print.PrintAttributes.MediaSize: MediaSize asPortrait()>,19,20,<android.print.PrintAttributes.MediaSize: MediaSize asPortrait()>,<android.print.PrintAttributes.MediaSize: MediaSize asPortrait()>,0,"MethodDeclaration(method_body, [Statement({, []), MethodCall(return new MediaSize(mId, mLabel, mPackageName, Math.min(mWidthMils, mHeightMils), Math.max(mWidthMils, mHeightMils), mLabelResId), [VariableReference(return new MediaSize(mId, mLabel, mPackageName, Math, []), Expression(mWidthMils, []), Expression(mHeightMils), []), Expression(Math.max(mWidthMils, []), Expression(mHeightMils), []), Expression(mLabelResId, [])]), Statement(}, [])])  Statement({, [])  MethodCall(return new MediaSize(mId, mLabel, mPackageName, Math.min(mWidthMils, mHeightMils), Math.max(mWidthMils, mHeightMils), mLabelResId), [VariableReference(return new MediaSize(mId, mLabel, mPackageName, Math, []), Expression(mWidthMils, []), Expression(mHeightMils), []), Expression(Math.max(mWidthMils, []), Expression(mHeightMils), []), Expression(mLabelResId, [])])    VariableReference(return new MediaSize(mId, mLabel, mPackageName, Math, [])    Expression(mWidthMils, [])    Expression(mHeightMils), [])    Expression(Math.max(mWidthMils, [])    Expression(mHeightMils), [])    Expression(mLabelResId, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(if (isPortrait()) {, []), Statement(return this, []), Statement(}, []), MethodCall(return new MediaSize(mId, mLabel, mPackageName, Math.min(mWidthMils, mHeightMils), Math.max(mWidthMils, mHeightMils), mLabelResId), [VariableReference(return new MediaSize(mId, mLabel, mPackageName, Math, []), Expression(mWidthMils, []), Expression(mHeightMils), []), Expression(Math.max(mWidthMils, []), Expression(mHeightMils), []), Expression(mLabelResId, [])]), Statement(}, [])])  Statement({, [])  Statement(if (isPortrait()) {, [])  Statement(return this, [])  Statement(}, [])  MethodCall(return new MediaSize(mId, mLabel, mPackageName, Math.min(mWidthMils, mHeightMils), Math.max(mWidthMils, mHeightMils), mLabelResId), [VariableReference(return new MediaSize(mId, mLabel, mPackageName, Math, []), Expression(mWidthMils, []), Expression(mHeightMils), []), Expression(Math.max(mWidthMils, []), Expression(mHeightMils), []), Expression(mLabelResId, [])])    VariableReference(return new MediaSize(mId, mLabel, mPackageName, Math, [])    Expression(mWidthMils, [])    Expression(mHeightMils), [])    Expression(Math.max(mWidthMils, [])    Expression(mHeightMils), [])    Expression(mLabelResId, [])  Statement(}, [])",1,"/**
 * Returns a new media size in a portrait orientation
 * which is the height is the greater dimension.
 *
 * @return New instance in landscape orientation.
 */
","/**
 * Returns a new media size instance in a portrait orientation,
 * which is the height is the greater dimension.
 *
 * @return New instance in landscape orientation if this one
 * is in landscape, otherwise this instance.
 */
",1,,,0,,,0,"1,2","1,3",1,"1,3",1,"A new control statement `if (isPortrait()) { return this; }` has been introduced before the return statement. The control statement has also modified the behaviour of the return statement under specific conditions, so the code change type is 1,3.","The inclusion of the control statement and new potential return value (`this`) means that the method could return different values based on its state, leading to a Compatibility Issue. Therefore, the CI type is 1."
162,"<android.provider.DocumentsProvider: Cursor queryRecentDocuments(String,String[])>",19,20,"<android.provider.DocumentsProvider: Cursor queryRecentDocuments(String,String[])>","<android.provider.DocumentsProvider: Cursor queryRecentDocuments(String,String[])>",0,"MethodDeclaration(method_body, [Statement({, []), Statement(throw new UnsupportedOperationException(""Recent not supported""), []), Statement(}, [])])  Statement({, [])  Statement(throw new UnsupportedOperationException(""Recent not supported""), [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(throw new UnsupportedOperationException(""Recent not supported""), []), Statement(}, [])])  Statement({, [])  Statement(throw new UnsupportedOperationException(""Recent not supported""), [])  Statement(}, [])",0,"/**
 * Return recently modified documents under the requested root. This will
 * only be called for roots that advertise
 * {@link Root#FLAG_SUPPORTS_RECENTS}. The returned documents should be
 * sorted by {@link Document#COLUMN_LAST_MODIFIED} in descending order, and
 * limited to only return the 64 most recently modified documents.
 *
 * @param projection list of {@link Document} columns to put into the
 * cursor. If {@code null} all supported columns should be
 * included.
 * @see DocumentsContract#EXTRA_LOADING
 */
","/**
 * Return recently modified documents under the requested root. This will
 * only be called for roots that advertise
 * {@link Root#FLAG_SUPPORTS_RECENTS}. The returned documents should be
 * sorted by {@link Document#COLUMN_LAST_MODIFIED} in descending order, and
 * limited to only return the 64 most recently modified documents.
 * <p>
 * Recent documents do not support change notifications.
 *
 * @param projection list of {@link Document} columns to put into the
 * cursor. If {@code null} all supported columns should be
 * included.
 * @see DocumentsContract#EXTRA_LOADING
 */
",1,[@SuppressWarnings("unused")],[@SuppressWarnings("unused")],0,,,0,0,0,0,0,0,There is no change in the implementation between the early and late versions. The AST nodes for method bodies are identical.,"As there is no change in the implementation, there is no compatibility issue."
163,<android.app.MediaRouteActionProvider: View onCreateActionView()>,19,20,<android.app.MediaRouteActionProvider: View onCreateActionView()>,<android.app.MediaRouteActionProvider: View onCreateActionView()>,0,"MethodDeclaration(method_body, [Statement({, []), Statement(}, [])])  Statement({, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(}, [])])  Statement({, [])  Statement(}, [])",0,,,0,[@Override],"[@Override, @SuppressWarnings(""deprecation"")]",1,,,0,0,0,0,0,0,"Based on the provided AST representation of both early and late versions, there are no changes in the method's implementation. The only difference is an additional `@SuppressWarnings(""deprecation"")` annotation in the late version, which does not affect the method's behavior.","There are no compatibility issues as there are no changes to the return statements, exception handling statements, control dependencies, or other statements that could affect the method's behavior. The additional annotation does not introduce any compatibility issues."
164,<android.os.CountDownTimer: CountDownTimer start()>,20,21,<android.os.CountDownTimer: CountDownTimer start()>,<android.os.CountDownTimer: CountDownTimer start()>,0,"MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(if (mMillisInFuture <, []), Expression(0) {, [])]), Statement(onFinish(), []), Statement(return this, []), Statement(}, []), AssignmentExpression(=, [VariableReference(mStopTimeInFuture, []), Expression(SystemClock.elapsedRealtime() + mMillisInFuture, [])]), MethodCall(mHandler.sendMessage(mHandler.obtainMessage(MSG)), [VariableReference(mHandler, []), Expression(mHandler.obtainMessage(MSG), [])]), Statement(return this, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(if (mMillisInFuture <, []), Expression(0) {, [])])    VariableReference(if (mMillisInFuture <, [])    Expression(0) {, [])  Statement(onFinish(), [])  Statement(return this, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(mStopTimeInFuture, []), Expression(SystemClock.elapsedRealtime() + mMillisInFuture, [])])    VariableReference(mStopTimeInFuture, [])    Expression(SystemClock.elapsedRealtime() + mMillisInFuture, [])  MethodCall(mHandler.sendMessage(mHandler.obtainMessage(MSG)), [VariableReference(mHandler, []), Expression(mHandler.obtainMessage(MSG), [])])    VariableReference(mHandler, [])    Expression(mHandler.obtainMessage(MSG), [])  Statement(return this, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(mCancelled, []), Expression(false, [])]), AssignmentExpression(=, [VariableReference(if (mMillisInFuture <, []), Expression(0) {, [])]), Statement(onFinish(), []), Statement(return this, []), Statement(}, []), AssignmentExpression(=, [VariableReference(mStopTimeInFuture, []), Expression(SystemClock.elapsedRealtime() + mMillisInFuture, [])]), MethodCall(mHandler.sendMessage(mHandler.obtainMessage(MSG)), [VariableReference(mHandler, []), Expression(mHandler.obtainMessage(MSG), [])]), Statement(return this, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(mCancelled, []), Expression(false, [])])    VariableReference(mCancelled, [])    Expression(false, [])  AssignmentExpression(=, [VariableReference(if (mMillisInFuture <, []), Expression(0) {, [])])    VariableReference(if (mMillisInFuture <, [])    Expression(0) {, [])  Statement(onFinish(), [])  Statement(return this, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(mStopTimeInFuture, []), Expression(SystemClock.elapsedRealtime() + mMillisInFuture, [])])    VariableReference(mStopTimeInFuture, [])    Expression(SystemClock.elapsedRealtime() + mMillisInFuture, [])  MethodCall(mHandler.sendMessage(mHandler.obtainMessage(MSG)), [VariableReference(mHandler, []), Expression(mHandler.obtainMessage(MSG), [])])    VariableReference(mHandler, [])    Expression(mHandler.obtainMessage(MSG), [])  Statement(return this, [])  Statement(}, [])",1,"/**
 * Start the countdown.
 */
","/**
 * Start the countdown.
 */
",0,,,0,,,0,1,4,0,4,0,"An assignment statements (`mCancelled = false`) has been added in the late version of the method, so the code change type is 4.","The introduced assignment statement does not change the return value or exception handling of the method. Hence, no compatibility issue exists in this case."
165,<android.service.dreams.DreamService: boolean isScreenBright()>,20,21,<android.service.dreams.DreamService: boolean isScreenBright()>,<android.service.dreams.DreamService: boolean isScreenBright()>,0,"MethodDeclaration(method_body, [Statement({, []), Statement(}, [])])  Statement({, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(}, [])])  Statement({, [])  Statement(}, [])",0,"/**
 * Returns whether or not this dream keeps the screen bright while dreaming. Defaults to false,
 * allowing the screen to dim if necessary.
 *
 * @see #setScreenBright(boolean)
 */
","/**
 * Returns whether or not this dream keeps the screen bright while dreaming.
 * Defaults to false, allowing the screen to dim if necessary.
 *
 * @see #setScreenBright(boolean)
 */
",1,,,0,,,0,0,0,0,0,0,"The AST nodes for the early and late implementations indicate no changes in the method body or structure. The only change is the formatting in the comments, which doesn't affect method behavior.","Since there are no changes in the method body, there are no compatibility issues."
166,"<android.app.Activity: Dialog onCreateDialog(int,Bundle)>",20,21,"<android.app.Activity: Dialog onCreateDialog(int,Bundle)>","<android.app.Activity: Dialog onCreateDialog(int,Bundle)>",0,"MethodDeclaration(method_body, [Statement({, []), Statement(return onCreateDialog(id), []), Statement(}, [])])  Statement({, [])  Statement(return onCreateDialog(id), [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(return onCreateDialog(id), []), Statement(}, [])])  Statement({, [])  Statement(return onCreateDialog(id), [])  Statement(}, [])",0,"/**
 * Callback for creating dialogs that are managed (saved and restored) for you
 * by the activity.  The default implementation calls through to
 * {@link #onCreateDialog(int)} for compatibility.
 *
 * <em>If you are targeting {@link android.os.Build.VERSION_CODES#HONEYCOMB}
 * or later, consider instead using a {@link DialogFragment} instead.</em>
 *
 * <p>If you use {@link #showDialog(int)}, the activity will call through to
 * this method the first time, and hang onto it thereafter.  Any dialog
 * that is created by this method will automatically be saved and restored
 * for you, including whether it is showing.
 *
 * <p>If you would like the activity to manage saving and restoring dialogs
 * for you, you should override this method and handle any ids that are
 * passed to {@link #showDialog}.
 *
 * <p>If you would like an opportunity to prepare your dialog before it is shown,
 * override {@link #onPrepareDialog(int, Dialog, Bundle)}.
 *
 * @param id The id of the dialog.
 * @param args The dialog arguments provided to {@link #showDialog(int, Bundle)}.
 * @return The dialog.  If you return null, the dialog will not be created.
 *
 * @see #onPrepareDialog(int, Dialog, Bundle)
 * @see #showDialog(int, Bundle)
 * @see #dismissDialog(int)
 * @see #removeDialog(int)
 *
 * @deprecated Use the new {@link DialogFragment} class with
 * {@link FragmentManager} instead; this is also
 * available on older platforms through the Android compatibility package.
 */
","/**
 * Callback for creating dialogs that are managed (saved and restored) for you
 * by the activity.  The default implementation calls through to
 * {@link #onCreateDialog(int)} for compatibility.
 *
 * <em>If you are targeting {@link android.os.Build.VERSION_CODES#HONEYCOMB}
 * or later, consider instead using a {@link DialogFragment} instead.</em>
 *
 * <p>If you use {@link #showDialog(int)}, the activity will call through to
 * this method the first time, and hang onto it thereafter.  Any dialog
 * that is created by this method will automatically be saved and restored
 * for you, including whether it is showing.
 *
 * <p>If you would like the activity to manage saving and restoring dialogs
 * for you, you should override this method and handle any ids that are
 * passed to {@link #showDialog}.
 *
 * <p>If you would like an opportunity to prepare your dialog before it is shown,
 * override {@link #onPrepareDialog(int, Dialog, Bundle)}.
 *
 * @param id The id of the dialog.
 * @param args The dialog arguments provided to {@link #showDialog(int, Bundle)}.
 * @return The dialog.  If you return null, the dialog will not be created.
 *
 * @see #onPrepareDialog(int, Dialog, Bundle)
 * @see #showDialog(int, Bundle)
 * @see #dismissDialog(int)
 * @see #removeDialog(int)
 *
 * @deprecated Use the new {@link DialogFragment} class with
 * {@link FragmentManager} instead; this is also
 * available on older platforms through the Android compatibility package.
 */
",0,[@Deprecated],"[@Nullable, @Deprecated]",1,,,0,0,0,0,5,0,"The change here is the addition of the @Nullable annotation in the late version. This annotation indicates that the return value can be null. This change does not modify the control flow, return type, or exception handling, so the change type is 5.","The addition of the @Nullable annotation does not alter the behavior of the method's implementation, as it is merely a metadata hint for developers and static analysis tools. Thus, no compatibility issue exists, so the CI type is 0."
167,<android.hardware.camera2.legacy.SurfaceTextureRenderer: void drawIntoSurfaces(CaptureCollector)>,21,22,<android.hardware.camera2.legacy.SurfaceTextureRenderer: void drawIntoSurfaces(CaptureCollector)>,<android.hardware.camera2.legacy.SurfaceTextureRenderer: void drawIntoSurfaces(CaptureCollector)>,0,"MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(if ((mSurfaces, []), Expression(, [])]), Statement(return, []), Statement(}, []), AssignmentExpression(=, [VariableReference(boolean doTiming, []), Expression(targetCollector.hasPendingPreviewCaptures(), [])]), Statement(checkGlError(""before updateTexImage""), []), Statement(if (doTiming) {, []), Statement(beginGlTiming(), []), Statement(}, []), MethodCall(mSurfaceTexture.updateTexImage(), [VariableReference(mSurfaceTexture, []), Expression(, [])]), AssignmentExpression(=, [VariableReference(long timestamp, []), Expression(mSurfaceTexture.getTimestamp(), [])]), AssignmentExpression(=, [VariableReference(Pair<RequestHolder, Long> captureHolder, []), Expression(targetCollector.previewCaptured(timestamp), [])]), Statement(// No preview request queued, drop frame., []), AssignmentExpression(=, [VariableReference(if (captureHolder, []), Expression(, [])]), Statement(if (DEBUG) {, []), MethodCall(Log.d(TAG, ""Dropping preview frame.""), [VariableReference(Log, []), Expression(TAG, []), Expression(""Dropping preview frame."", [])]), Statement(}, []), Statement(if (doTiming) {, []), Statement(endGlTiming(), []), Statement(}, []), Statement(return, []), Statement(}, []), AssignmentExpression(=, [VariableReference(RequestHolder request, []), Expression(captureHolder.first, [])]), AssignmentExpression(=, [VariableReference(Collection<Surface> targetSurfaces, []), Expression(request.getHolderTargets(), [])]), Statement(if (doTiming) {, []), Statement(addGlTimestamp(timestamp), []), Statement(}, []), AssignmentExpression(=, [VariableReference(List<Long> targetSurfaceIds, []), Expression(LegacyCameraDevice.getSurfaceIds(targetSurfaces), [])]), Statement(for (EGLSurfaceHolder holder : mSurfaces) {, []), MethodCall(if (LegacyCameraDevice.containsSurfaceId(holder.surface, targetSurfaceIds)), [VariableReference(if (LegacyCameraDevice, []), Expression(holder.surface, []), Expression(targetSurfaceIds), [])]), Statement(try {, []), MethodCall(LegacyCameraDevice.setSurfaceDimens(holder.surface, holder.width, holder.height), [VariableReference(LegacyCameraDevice, []), Expression(holder.surface, []), Expression(holder.width, []), Expression(holder.height, [])]), MethodCall(LegacyCameraDevice.setNextTimestamp(holder.surface, captureHolder.second), [VariableReference(LegacyCameraDevice, []), Expression(holder.surface, []), Expression(captureHolder.second, [])]), MethodCall(Log.w(TAG, ""Surface abandoned, dropping frame. "", e), [VariableReference(Log, []), Expression(TAG, []), Expression(""Surface abandoned, []), Expression(dropping frame. "", []), Expression(e, [])]), Statement(}, []), Statement(}, []), Statement(}, []), Statement(for (EGLSurfaceHolder holder : mConversionSurfaces) {, []), MethodCall(if (LegacyCameraDevice.containsSurfaceId(holder.surface, targetSurfaceIds)), [VariableReference(if (LegacyCameraDevice, []), Expression(holder.surface, []), Expression(targetSurfaceIds), [])]), MethodCall(mPBufferPixels.clear(), [VariableReference(mPBufferPixels, []), Expression(, [])]), Statement(0, /*y*/, []), Statement(0, holder.width, holder.height, GLES20.GL_RGBA, GLES20.GL_UNSIGNED_BYTE, mPBufferPixels), []), Statement(checkGlError(""glReadPixels""), []), Statement(try {, []), AssignmentExpression(=, [VariableReference(int format, []), Expression(LegacyCameraDevice.detectSurfaceType(holder.surface), [])]), MethodCall(LegacyCameraDevice.setNextTimestamp(holder.surface, captureHolder.second), [VariableReference(LegacyCameraDevice, []), Expression(holder.surface, []), Expression(captureHolder.second, [])]), MethodCall(LegacyCameraDevice.produceFrame(holder.surface, mPBufferPixels.array(), holder.width, holder.height, format), [VariableReference(LegacyCameraDevice, []), Expression(holder.surface, []), Expression(mPBufferPixels.array(), []), Expression(holder.width, []), Expression(holder.height, []), Expression(format, [])]), MethodCall(Log.w(TAG, ""Surface abandoned, dropping frame. "", e), [VariableReference(Log, []), Expression(TAG, []), Expression(""Surface abandoned, []), Expression(dropping frame. "", []), Expression(e, [])]), Statement(}, []), Statement(}, []), Statement(}, []), MethodCall(targetCollector.previewProduced(), [VariableReference(targetCollector, []), Expression(, [])]), Statement(if (doTiming) {, []), Statement(endGlTiming(), []), Statement(}, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(if ((mSurfaces, []), Expression(, [])])    VariableReference(if ((mSurfaces, [])    Expression(, [])  Statement(return, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(boolean doTiming, []), Expression(targetCollector.hasPendingPreviewCaptures(), [])])    VariableReference(boolean doTiming, [])    Expression(targetCollector.hasPendingPreviewCaptures(), [])  Statement(checkGlError(""before updateTexImage""), [])  Statement(if (doTiming) {, [])  Statement(beginGlTiming(), [])  Statement(}, [])  MethodCall(mSurfaceTexture.updateTexImage(), [VariableReference(mSurfaceTexture, []), Expression(, [])])    VariableReference(mSurfaceTexture, [])    Expression(, [])  AssignmentExpression(=, [VariableReference(long timestamp, []), Expression(mSurfaceTexture.getTimestamp(), [])])    VariableReference(long timestamp, [])    Expression(mSurfaceTexture.getTimestamp(), [])  AssignmentExpression(=, [VariableReference(Pair<RequestHolder, Long> captureHolder, []), Expression(targetCollector.previewCaptured(timestamp), [])])    VariableReference(Pair<RequestHolder, Long> captureHolder, [])    Expression(targetCollector.previewCaptured(timestamp), [])  Statement(// No preview request queued, drop frame., [])  AssignmentExpression(=, [VariableReference(if (captureHolder, []), Expression(, [])])    VariableReference(if (captureHolder, [])    Expression(, [])  Statement(if (DEBUG) {, [])  MethodCall(Log.d(TAG, ""Dropping preview frame.""), [VariableReference(Log, []), Expression(TAG, []), Expression(""Dropping preview frame."", [])])    VariableReference(Log, [])    Expression(TAG, [])    Expression(""Dropping preview frame."", [])  Statement(}, [])  Statement(if (doTiming) {, [])  Statement(endGlTiming(), [])  Statement(}, [])  Statement(return, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(RequestHolder request, []), Expression(captureHolder.first, [])])    VariableReference(RequestHolder request, [])    Expression(captureHolder.first, [])  AssignmentExpression(=, [VariableReference(Collection<Surface> targetSurfaces, []), Expression(request.getHolderTargets(), [])])    VariableReference(Collection<Surface> targetSurfaces, [])    Expression(request.getHolderTargets(), [])  Statement(if (doTiming) {, [])  Statement(addGlTimestamp(timestamp), [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(List<Long> targetSurfaceIds, []), Expression(LegacyCameraDevice.getSurfaceIds(targetSurfaces), [])])    VariableReference(List<Long> targetSurfaceIds, [])    Expression(LegacyCameraDevice.getSurfaceIds(targetSurfaces), [])  Statement(for (EGLSurfaceHolder holder : mSurfaces) {, [])  MethodCall(if (LegacyCameraDevice.containsSurfaceId(holder.surface, targetSurfaceIds)), [VariableReference(if (LegacyCameraDevice, []), Expression(holder.surface, []), Expression(targetSurfaceIds), [])])    VariableReference(if (LegacyCameraDevice, [])    Expression(holder.surface, [])    Expression(targetSurfaceIds), [])  Statement(try {, [])  MethodCall(LegacyCameraDevice.setSurfaceDimens(holder.surface, holder.width, holder.height), [VariableReference(LegacyCameraDevice, []), Expression(holder.surface, []), Expression(holder.width, []), Expression(holder.height, [])])    VariableReference(LegacyCameraDevice, [])    Expression(holder.surface, [])    Expression(holder.width, [])    Expression(holder.height, [])  MethodCall(LegacyCameraDevice.setNextTimestamp(holder.surface, captureHolder.second), [VariableReference(LegacyCameraDevice, []), Expression(holder.surface, []), Expression(captureHolder.second, [])])    VariableReference(LegacyCameraDevice, [])    Expression(holder.surface, [])    Expression(captureHolder.second, [])  MethodCall(Log.w(TAG, ""Surface abandoned, dropping frame. "", e), [VariableReference(Log, []), Expression(TAG, []), Expression(""Surface abandoned, []), Expression(dropping frame. "", []), Expression(e, [])])    VariableReference(Log, [])    Expression(TAG, [])    Expression(""Surface abandoned, [])    Expression(dropping frame. "", [])    Expression(e, [])  Statement(}, [])  Statement(}, [])  Statement(}, [])  Statement(for (EGLSurfaceHolder holder : mConversionSurfaces) {, [])  MethodCall(if (LegacyCameraDevice.containsSurfaceId(holder.surface, targetSurfaceIds)), [VariableReference(if (LegacyCameraDevice, []), Expression(holder.surface, []), Expression(targetSurfaceIds), [])])    VariableReference(if (LegacyCameraDevice, [])    Expression(holder.surface, [])    Expression(targetSurfaceIds), [])  MethodCall(mPBufferPixels.clear(), [VariableReference(mPBufferPixels, []), Expression(, [])])    VariableReference(mPBufferPixels, [])    Expression(, [])  Statement(0, /*y*/, [])  Statement(0, holder.width, holder.height, GLES20.GL_RGBA, GLES20.GL_UNSIGNED_BYTE, mPBufferPixels), [])  Statement(checkGlError(""glReadPixels""), [])  Statement(try {, [])  AssignmentExpression(=, [VariableReference(int format, []), Expression(LegacyCameraDevice.detectSurfaceType(holder.surface), [])])    VariableReference(int format, [])    Expression(LegacyCameraDevice.detectSurfaceType(holder.surface), [])  MethodCall(LegacyCameraDevice.setNextTimestamp(holder.surface, captureHolder.second), [VariableReference(LegacyCameraDevice, []), Expression(holder.surface, []), Expression(captureHolder.second, [])])    VariableReference(LegacyCameraDevice, [])    Expression(holder.surface, [])    Expression(captureHolder.second, [])  MethodCall(LegacyCameraDevice.produceFrame(holder.surface, mPBufferPixels.array(), holder.width, holder.height, format), [VariableReference(LegacyCameraDevice, []), Expression(holder.surface, []), Expression(mPBufferPixels.array(), []), Expression(holder.width, []), Expression(holder.height, []), Expression(format, [])])    VariableReference(LegacyCameraDevice, [])    Expression(holder.surface, [])    Expression(mPBufferPixels.array(), [])    Expression(holder.width, [])    Expression(holder.height, [])    Expression(format, [])  MethodCall(Log.w(TAG, ""Surface abandoned, dropping frame. "", e), [VariableReference(Log, []), Expression(TAG, []), Expression(""Surface abandoned, []), Expression(dropping frame. "", []), Expression(e, [])])    VariableReference(Log, [])    Expression(TAG, [])    Expression(""Surface abandoned, [])    Expression(dropping frame. "", [])    Expression(e, [])  Statement(}, [])  Statement(}, [])  Statement(}, [])  MethodCall(targetCollector.previewProduced(), [VariableReference(targetCollector, []), Expression(, [])])    VariableReference(targetCollector, [])    Expression(, [])  Statement(if (doTiming) {, [])  Statement(endGlTiming(), [])  Statement(}, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(if ((mSurfaces, []), Expression(, [])]), Statement(return, []), Statement(}, []), AssignmentExpression(=, [VariableReference(boolean doTiming, []), Expression(targetCollector.hasPendingPreviewCaptures(), [])]), Statement(checkGlError(""before updateTexImage""), []), Statement(if (doTiming) {, []), Statement(beginGlTiming(), []), Statement(}, []), MethodCall(mSurfaceTexture.updateTexImage(), [VariableReference(mSurfaceTexture, []), Expression(, [])]), AssignmentExpression(=, [VariableReference(long timestamp, []), Expression(mSurfaceTexture.getTimestamp(), [])]), AssignmentExpression(=, [VariableReference(Pair<RequestHolder, Long> captureHolder, []), Expression(targetCollector.previewCaptured(timestamp), [])]), Statement(// No preview request queued, drop frame., []), AssignmentExpression(=, [VariableReference(if (captureHolder, []), Expression(, [])]), Statement(if (DEBUG) {, []), MethodCall(Log.d(TAG, ""Dropping preview frame.""), [VariableReference(Log, []), Expression(TAG, []), Expression(""Dropping preview frame."", [])]), Statement(}, []), Statement(if (doTiming) {, []), Statement(endGlTiming(), []), Statement(}, []), Statement(return, []), Statement(}, []), AssignmentExpression(=, [VariableReference(RequestHolder request, []), Expression(captureHolder.first, [])]), AssignmentExpression(=, [VariableReference(Collection<Surface> targetSurfaces, []), Expression(request.getHolderTargets(), [])]), Statement(if (doTiming) {, []), Statement(addGlTimestamp(timestamp), []), Statement(}, []), AssignmentExpression(=, [VariableReference(List<Long> targetSurfaceIds, []), Expression(LegacyCameraDevice.getSurfaceIds(targetSurfaces), [])]), Statement(for (EGLSurfaceHolder holder : mSurfaces) {, []), MethodCall(if (LegacyCameraDevice.containsSurfaceId(holder.surface, targetSurfaceIds)), [VariableReference(if (LegacyCameraDevice, []), Expression(holder.surface, []), Expression(targetSurfaceIds), [])]), Statement(try {, []), MethodCall(LegacyCameraDevice.setSurfaceDimens(holder.surface, holder.width, holder.height), [VariableReference(LegacyCameraDevice, []), Expression(holder.surface, []), Expression(holder.width, []), Expression(holder.height, [])]), MethodCall(LegacyCameraDevice.setNextTimestamp(holder.surface, captureHolder.second), [VariableReference(LegacyCameraDevice, []), Expression(holder.surface, []), Expression(captureHolder.second, [])]), AssignmentExpression(=, [VariableReference(drawFrame(mSurfaceTexture, holder.width, holder.height, (mFacing, []), Expression(, [])]), MethodCall(Log.w(TAG, ""Surface abandoned, dropping frame. "", e), [VariableReference(Log, []), Expression(TAG, []), Expression(""Surface abandoned, []), Expression(dropping frame. "", []), Expression(e, [])]), Statement(}, []), Statement(}, []), Statement(}, []), Statement(for (EGLSurfaceHolder holder : mConversionSurfaces) {, []), MethodCall(if (LegacyCameraDevice.containsSurfaceId(holder.surface, targetSurfaceIds)), [VariableReference(if (LegacyCameraDevice, []), Expression(holder.surface, []), Expression(targetSurfaceIds), [])]), Statement(// glReadPixels reads from the bottom of the buffer, so add an extra vertical flip, []), AssignmentExpression(=, [VariableReference(drawFrame(mSurfaceTexture, holder.width, holder.height, (mFacing, []), Expression(, [])]), MethodCall(mPBufferPixels.clear(), [VariableReference(mPBufferPixels, []), Expression(, [])]), Statement(0, /*y*/, []), Statement(0, holder.width, holder.height, GLES20.GL_RGBA, GLES20.GL_UNSIGNED_BYTE, mPBufferPixels), []), Statement(checkGlError(""glReadPixels""), []), Statement(try {, []), AssignmentExpression(=, [VariableReference(int format, []), Expression(LegacyCameraDevice.detectSurfaceType(holder.surface), [])]), MethodCall(LegacyCameraDevice.setSurfaceDimens(holder.surface, holder.width, holder.height), [VariableReference(LegacyCameraDevice, []), Expression(holder.surface, []), Expression(holder.width, []), Expression(holder.height, [])]), MethodCall(LegacyCameraDevice.setNextTimestamp(holder.surface, captureHolder.second), [VariableReference(LegacyCameraDevice, []), Expression(holder.surface, []), Expression(captureHolder.second, [])]), MethodCall(LegacyCameraDevice.produceFrame(holder.surface, mPBufferPixels.array(), holder.width, holder.height, format), [VariableReference(LegacyCameraDevice, []), Expression(holder.surface, []), Expression(mPBufferPixels.array(), []), Expression(holder.width, []), Expression(holder.height, []), Expression(format, [])]), MethodCall(Log.w(TAG, ""Surface abandoned, dropping frame. "", e), [VariableReference(Log, []), Expression(TAG, []), Expression(""Surface abandoned, []), Expression(dropping frame. "", []), Expression(e, [])]), Statement(}, []), Statement(}, []), Statement(}, []), MethodCall(targetCollector.previewProduced(), [VariableReference(targetCollector, []), Expression(, [])]), Statement(if (doTiming) {, []), Statement(endGlTiming(), []), Statement(}, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(if ((mSurfaces, []), Expression(, [])])    VariableReference(if ((mSurfaces, [])    Expression(, [])  Statement(return, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(boolean doTiming, []), Expression(targetCollector.hasPendingPreviewCaptures(), [])])    VariableReference(boolean doTiming, [])    Expression(targetCollector.hasPendingPreviewCaptures(), [])  Statement(checkGlError(""before updateTexImage""), [])  Statement(if (doTiming) {, [])  Statement(beginGlTiming(), [])  Statement(}, [])  MethodCall(mSurfaceTexture.updateTexImage(), [VariableReference(mSurfaceTexture, []), Expression(, [])])    VariableReference(mSurfaceTexture, [])    Expression(, [])  AssignmentExpression(=, [VariableReference(long timestamp, []), Expression(mSurfaceTexture.getTimestamp(), [])])    VariableReference(long timestamp, [])    Expression(mSurfaceTexture.getTimestamp(), [])  AssignmentExpression(=, [VariableReference(Pair<RequestHolder, Long> captureHolder, []), Expression(targetCollector.previewCaptured(timestamp), [])])    VariableReference(Pair<RequestHolder, Long> captureHolder, [])    Expression(targetCollector.previewCaptured(timestamp), [])  Statement(// No preview request queued, drop frame., [])  AssignmentExpression(=, [VariableReference(if (captureHolder, []), Expression(, [])])    VariableReference(if (captureHolder, [])    Expression(, [])  Statement(if (DEBUG) {, [])  MethodCall(Log.d(TAG, ""Dropping preview frame.""), [VariableReference(Log, []), Expression(TAG, []), Expression(""Dropping preview frame."", [])])    VariableReference(Log, [])    Expression(TAG, [])    Expression(""Dropping preview frame."", [])  Statement(}, [])  Statement(if (doTiming) {, [])  Statement(endGlTiming(), [])  Statement(}, [])  Statement(return, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(RequestHolder request, []), Expression(captureHolder.first, [])])    VariableReference(RequestHolder request, [])    Expression(captureHolder.first, [])  AssignmentExpression(=, [VariableReference(Collection<Surface> targetSurfaces, []), Expression(request.getHolderTargets(), [])])    VariableReference(Collection<Surface> targetSurfaces, [])    Expression(request.getHolderTargets(), [])  Statement(if (doTiming) {, [])  Statement(addGlTimestamp(timestamp), [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(List<Long> targetSurfaceIds, []), Expression(LegacyCameraDevice.getSurfaceIds(targetSurfaces), [])])    VariableReference(List<Long> targetSurfaceIds, [])    Expression(LegacyCameraDevice.getSurfaceIds(targetSurfaces), [])  Statement(for (EGLSurfaceHolder holder : mSurfaces) {, [])  MethodCall(if (LegacyCameraDevice.containsSurfaceId(holder.surface, targetSurfaceIds)), [VariableReference(if (LegacyCameraDevice, []), Expression(holder.surface, []), Expression(targetSurfaceIds), [])])    VariableReference(if (LegacyCameraDevice, [])    Expression(holder.surface, [])    Expression(targetSurfaceIds), [])  Statement(try {, [])  MethodCall(LegacyCameraDevice.setSurfaceDimens(holder.surface, holder.width, holder.height), [VariableReference(LegacyCameraDevice, []), Expression(holder.surface, []), Expression(holder.width, []), Expression(holder.height, [])])    VariableReference(LegacyCameraDevice, [])    Expression(holder.surface, [])    Expression(holder.width, [])    Expression(holder.height, [])  MethodCall(LegacyCameraDevice.setNextTimestamp(holder.surface, captureHolder.second), [VariableReference(LegacyCameraDevice, []), Expression(holder.surface, []), Expression(captureHolder.second, [])])    VariableReference(LegacyCameraDevice, [])    Expression(holder.surface, [])    Expression(captureHolder.second, [])  AssignmentExpression(=, [VariableReference(drawFrame(mSurfaceTexture, holder.width, holder.height, (mFacing, []), Expression(, [])])    VariableReference(drawFrame(mSurfaceTexture, holder.width, holder.height, (mFacing, [])    Expression(, [])  MethodCall(Log.w(TAG, ""Surface abandoned, dropping frame. "", e), [VariableReference(Log, []), Expression(TAG, []), Expression(""Surface abandoned, []), Expression(dropping frame. "", []), Expression(e, [])])    VariableReference(Log, [])    Expression(TAG, [])    Expression(""Surface abandoned, [])    Expression(dropping frame. "", [])    Expression(e, [])  Statement(}, [])  Statement(}, [])  Statement(}, [])  Statement(for (EGLSurfaceHolder holder : mConversionSurfaces) {, [])  MethodCall(if (LegacyCameraDevice.containsSurfaceId(holder.surface, targetSurfaceIds)), [VariableReference(if (LegacyCameraDevice, []), Expression(holder.surface, []), Expression(targetSurfaceIds), [])])    VariableReference(if (LegacyCameraDevice, [])    Expression(holder.surface, [])    Expression(targetSurfaceIds), [])  Statement(// glReadPixels reads from the bottom of the buffer, so add an extra vertical flip, [])  AssignmentExpression(=, [VariableReference(drawFrame(mSurfaceTexture, holder.width, holder.height, (mFacing, []), Expression(, [])])    VariableReference(drawFrame(mSurfaceTexture, holder.width, holder.height, (mFacing, [])    Expression(, [])  MethodCall(mPBufferPixels.clear(), [VariableReference(mPBufferPixels, []), Expression(, [])])    VariableReference(mPBufferPixels, [])    Expression(, [])  Statement(0, /*y*/, [])  Statement(0, holder.width, holder.height, GLES20.GL_RGBA, GLES20.GL_UNSIGNED_BYTE, mPBufferPixels), [])  Statement(checkGlError(""glReadPixels""), [])  Statement(try {, [])  AssignmentExpression(=, [VariableReference(int format, []), Expression(LegacyCameraDevice.detectSurfaceType(holder.surface), [])])    VariableReference(int format, [])    Expression(LegacyCameraDevice.detectSurfaceType(holder.surface), [])  MethodCall(LegacyCameraDevice.setSurfaceDimens(holder.surface, holder.width, holder.height), [VariableReference(LegacyCameraDevice, []), Expression(holder.surface, []), Expression(holder.width, []), Expression(holder.height, [])])    VariableReference(LegacyCameraDevice, [])    Expression(holder.surface, [])    Expression(holder.width, [])    Expression(holder.height, [])  MethodCall(LegacyCameraDevice.setNextTimestamp(holder.surface, captureHolder.second), [VariableReference(LegacyCameraDevice, []), Expression(holder.surface, []), Expression(captureHolder.second, [])])    VariableReference(LegacyCameraDevice, [])    Expression(holder.surface, [])    Expression(captureHolder.second, [])  MethodCall(LegacyCameraDevice.produceFrame(holder.surface, mPBufferPixels.array(), holder.width, holder.height, format), [VariableReference(LegacyCameraDevice, []), Expression(holder.surface, []), Expression(mPBufferPixels.array(), []), Expression(holder.width, []), Expression(holder.height, []), Expression(format, [])])    VariableReference(LegacyCameraDevice, [])    Expression(holder.surface, [])    Expression(mPBufferPixels.array(), [])    Expression(holder.width, [])    Expression(holder.height, [])    Expression(format, [])  MethodCall(Log.w(TAG, ""Surface abandoned, dropping frame. "", e), [VariableReference(Log, []), Expression(TAG, []), Expression(""Surface abandoned, []), Expression(dropping frame. "", []), Expression(e, [])])    VariableReference(Log, [])    Expression(TAG, [])    Expression(""Surface abandoned, [])    Expression(dropping frame. "", [])    Expression(e, [])  Statement(}, [])  Statement(}, [])  Statement(}, [])  MethodCall(targetCollector.previewProduced(), [VariableReference(targetCollector, []), Expression(, [])])    VariableReference(targetCollector, [])    Expression(, [])  Statement(if (doTiming) {, [])  Statement(endGlTiming(), [])  Statement(}, [])  Statement(}, [])",1,"/**
 * Draw the current buffer in the {@link SurfaceTexture} returned from
 * {@link #getSurfaceTexture()} into the set of target {@link Surface}s
 * in the next request from the given {@link CaptureCollector}, or drop
 * the frame if none is available.
 *
 * <p>
 * Any {@link Surface}s targeted must be a subset of the {@link Surface}s
 * set in the last {@link #configureSurfaces(java.util.Collection)} call.
 * </p>
 *
 * @param targetCollector the surfaces to draw to.
 */
","/**
 * Draw the current buffer in the {@link SurfaceTexture} returned from
 * {@link #getSurfaceTexture()} into the set of target {@link Surface}s
 * in the next request from the given {@link CaptureCollector}, or drop
 * the frame if none is available.
 *
 * <p>
 * Any {@link Surface}s targeted must be a subset of the {@link Surface}s
 * set in the last {@link #configureSurfaces(java.util.Collection)} call.
 * </p>
 *
 * @param targetCollector the surfaces to draw to.
 */
",0,,,0,,,0,"1,2","4,5",0,"3,4",0,"The control dependency change: The while loop condition was modified to remove the parent check for null. Other statements inside the methods (such as method calls and assignments) were also modified, so the change type is 3,4.","The modifications to control dependencies and other statements do not seem to affect the return values or exception handling. Therefore, no compatibility issue exists."
168,"<android.accounts.AccountManager: AccountManagerFuture<Boolean> removeAccount(Account,AccountManagerCallback<Boolean>,Handler)>",21,22,"<android.accounts.AccountManager: AccountManagerFuture<Boolean> removeAccount(Account,AccountManagerCallback<Boolean>,Handler)>","<android.accounts.AccountManager: AccountManagerFuture<Boolean> removeAccount(Account,AccountManagerCallback<Boolean>,Handler)>",0,"MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(if (account, []), Expression(, [])]), Statement(throw new IllegalArgumentException(""account is null""), []), Statement(return new Future2Task<Boolean>(handler, callback) {, []), Statement(public void doWork() throws RemoteException {, []), MethodCall(mService.removeAccount(mResponse, account), [VariableReference(mService, []), Expression(mResponse, []), Expression(account, [])]), Statement(}, []), Statement(public Boolean bundleToResult(Bundle bundle) throws AuthenticatorException {, []), MethodCall(if (!bundle.containsKey(KEY_BOOLEAN_RESULT)), [VariableReference(if (!bundle, []), Expression(KEY_BOOLEAN_RESULT), [])]), Statement(throw new AuthenticatorException(""no result in response""), []), Statement(}, []), MethodCall(return bundle.getBoolean(KEY_BOOLEAN_RESULT), [VariableReference(return bundle, []), Expression(KEY_BOOLEAN_RESULT, [])]), Statement(}, []), MethodCall(}.start(), [VariableReference(}, []), Expression(, [])]), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(if (account, []), Expression(, [])])    VariableReference(if (account, [])    Expression(, [])  Statement(throw new IllegalArgumentException(""account is null""), [])  Statement(return new Future2Task<Boolean>(handler, callback) {, [])  Statement(public void doWork() throws RemoteException {, [])  MethodCall(mService.removeAccount(mResponse, account), [VariableReference(mService, []), Expression(mResponse, []), Expression(account, [])])    VariableReference(mService, [])    Expression(mResponse, [])    Expression(account, [])  Statement(}, [])  Statement(public Boolean bundleToResult(Bundle bundle) throws AuthenticatorException {, [])  MethodCall(if (!bundle.containsKey(KEY_BOOLEAN_RESULT)), [VariableReference(if (!bundle, []), Expression(KEY_BOOLEAN_RESULT), [])])    VariableReference(if (!bundle, [])    Expression(KEY_BOOLEAN_RESULT), [])  Statement(throw new AuthenticatorException(""no result in response""), [])  Statement(}, [])  MethodCall(return bundle.getBoolean(KEY_BOOLEAN_RESULT), [VariableReference(return bundle, []), Expression(KEY_BOOLEAN_RESULT, [])])    VariableReference(return bundle, [])    Expression(KEY_BOOLEAN_RESULT, [])  Statement(}, [])  MethodCall(}.start(), [VariableReference(}, []), Expression(, [])])    VariableReference(}, [])    Expression(, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(if (account, []), Expression(, [])]), Statement(throw new IllegalArgumentException(""account is null""), []), Statement(return new Future2Task<Boolean>(handler, callback) {, []), Statement(public void doWork() throws RemoteException {, []), MethodCall(mService.removeAccount(mResponse, account, false), [VariableReference(mService, []), Expression(mResponse, []), Expression(account, []), Expression(false, [])]), Statement(}, []), Statement(public Boolean bundleToResult(Bundle bundle) throws AuthenticatorException {, []), MethodCall(if (!bundle.containsKey(KEY_BOOLEAN_RESULT)), [VariableReference(if (!bundle, []), Expression(KEY_BOOLEAN_RESULT), [])]), Statement(throw new AuthenticatorException(""no result in response""), []), Statement(}, []), MethodCall(return bundle.getBoolean(KEY_BOOLEAN_RESULT), [VariableReference(return bundle, []), Expression(KEY_BOOLEAN_RESULT, [])]), Statement(}, []), MethodCall(}.start(), [VariableReference(}, []), Expression(, [])]), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(if (account, []), Expression(, [])])    VariableReference(if (account, [])    Expression(, [])  Statement(throw new IllegalArgumentException(""account is null""), [])  Statement(return new Future2Task<Boolean>(handler, callback) {, [])  Statement(public void doWork() throws RemoteException {, [])  MethodCall(mService.removeAccount(mResponse, account, false), [VariableReference(mService, []), Expression(mResponse, []), Expression(account, []), Expression(false, [])])    VariableReference(mService, [])    Expression(mResponse, [])    Expression(account, [])    Expression(false, [])  Statement(}, [])  Statement(public Boolean bundleToResult(Bundle bundle) throws AuthenticatorException {, [])  MethodCall(if (!bundle.containsKey(KEY_BOOLEAN_RESULT)), [VariableReference(if (!bundle, []), Expression(KEY_BOOLEAN_RESULT), [])])    VariableReference(if (!bundle, [])    Expression(KEY_BOOLEAN_RESULT), [])  Statement(throw new AuthenticatorException(""no result in response""), [])  Statement(}, [])  MethodCall(return bundle.getBoolean(KEY_BOOLEAN_RESULT), [VariableReference(return bundle, []), Expression(KEY_BOOLEAN_RESULT, [])])    VariableReference(return bundle, [])    Expression(KEY_BOOLEAN_RESULT, [])  Statement(}, [])  MethodCall(}.start(), [VariableReference(}, []), Expression(, [])])    VariableReference(}, [])    Expression(, [])  Statement(}, [])",1,"/**
 * Removes an account from the AccountManager.  Does nothing if the account
 * does not exist.  Does not delete the account from the server.
 * The authenticator may have its own policies preventing account
 * deletion, in which case the account will not be deleted.
 *
 * <p>This method may be called from any thread, but the returned
 * {@link AccountManagerFuture} must not be used on the main thread.
 *
 * <p>This method requires the caller to hold the permission
 * {@link android.Manifest.permission#MANAGE_ACCOUNTS}.
 *
 * @param account The {@link Account} to remove
 * @param callback Callback to invoke when the request completes,
 * null for no callback
 * @param handler {@link Handler} identifying the callback thread,
 * null for the main thread
 * @return An {@link AccountManagerFuture} which resolves to a Boolean,
 * true if the account has been successfully removed
 */
","/**
 * Removes an account from the AccountManager.  Does nothing if the account
 * does not exist.  Does not delete the account from the server.
 * The authenticator may have its own policies preventing account
 * deletion, in which case the account will not be deleted.
 *
 * <p>This method may be called from any thread, but the returned
 * {@link AccountManagerFuture} must not be used on the main thread.
 *
 * <p>This method requires the caller to hold the permission
 * {@link android.Manifest.permission#MANAGE_ACCOUNTS}.
 *
 * @param account The {@link Account} to remove
 * @param callback Callback to invoke when the request completes,
 * null for no callback
 * @param handler {@link Handler} identifying the callback thread,
 * null for the main thread
 * @return An {@link AccountManagerFuture} which resolves to a Boolean,
 * true if the account has been successfully removed
 * @deprecated use
 * {@link #removeAccount(Account, Activity, AccountManagerCallback, Handler)}
 * instead
 */
",1,,[@Deprecated],1,,,0,"1,2",5,0,"3,5",1,"The method call `mService.removeAccount(mResponse, account)` has changed to `mService.removeAccount(mResponse, account, false)` in the late version. This indicates a change in the dependent API, so the code change type is 3,5.","The addition of the `false` parameter in the `mService.removeAccount` call potentially alters the behavior of the API, leading to the possibility of different return values or effects. This constitutes a potential Compatibility Issue (CI) of type 1."
169,<android.widget.TextView: void setExtractedText(ExtractedText)>,22,23,<android.widget.TextView: void setExtractedText(ExtractedText)>,<android.widget.TextView: void setExtractedText(ExtractedText)>,0,"MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(Editable content, []), Expression(getEditableText(), [])]), AssignmentExpression(=, [VariableReference(if (text.text !, []), Expression(null) {, [])]), AssignmentExpression(=, [VariableReference(if (content, []), Expression(, [])]), MethodCall(removeParcelableSpans(content, 0, content.length()), [VariableReference(removeParcelableSpans(content, 0, content, []), Expression(), [])]), MethodCall(content.replace(0, content.length(), text.text), [VariableReference(content, []), Expression(0, []), Expression(content.length(), []), Expression(text.text, [])]), Statement(} else {, []), AssignmentExpression(=, [VariableReference(final int N, []), Expression(content.length(), [])]), AssignmentExpression(=, [VariableReference(int start, []), Expression(text.partialStartOffset, [])]), Statement(if (start > N), []), AssignmentExpression(=, [VariableReference(start, []), Expression(N, [])]), AssignmentExpression(=, [VariableReference(int end, []), Expression(text.partialEndOffset, [])]), Statement(if (end > N), []), AssignmentExpression(=, [VariableReference(end, []), Expression(N, [])]), Statement(removeParcelableSpans(content, start, end), []), MethodCall(content.replace(start, end, text.text), [VariableReference(content, []), Expression(start, []), Expression(end, []), Expression(text.text, [])]), Statement(}, []), Statement(}, []), Statement(// Now set the selection position...  make sure it is in range, to, []), Statement(// avoid crashes.  If this is a partial update, it is possible that, []), Statement(// the underlying text may have changed, causing us problems here., []), Statement(// Also we just don't want to trust clients to do the right thing., []), AssignmentExpression(=, [VariableReference(Spannable sp, []), Expression((Spannable) getText(), [])]), AssignmentExpression(=, [VariableReference(final int N, []), Expression(sp.length(), [])]), AssignmentExpression(=, [VariableReference(int start, []), Expression(text.selectionStart, [])]), Statement(if (start < 0), []), AssignmentExpression(=, [VariableReference(start, []), Expression(0, [])]), Statement(else if (start > N), []), AssignmentExpression(=, [VariableReference(start, []), Expression(N, [])]), AssignmentExpression(=, [VariableReference(int end, []), Expression(text.selectionEnd, [])]), Statement(if (end < 0), []), AssignmentExpression(=, [VariableReference(end, []), Expression(0, [])]), Statement(else if (end > N), []), AssignmentExpression(=, [VariableReference(end, []), Expression(N, [])]), MethodCall(Selection.setSelection(sp, start, end), [VariableReference(Selection, []), Expression(sp, []), Expression(start, []), Expression(end, [])]), Statement(// Finally, update the selection mode., []), AssignmentExpression(=, [VariableReference(if ((text.flags & ExtractedText.FLAG_SELECTING) !, []), Expression(0) {, [])]), MethodCall(MetaKeyKeyListener.startSelecting(this, sp), [VariableReference(MetaKeyKeyListener, []), Expression(this, []), Expression(sp, [])]), Statement(} else {, []), MethodCall(MetaKeyKeyListener.stopSelecting(this, sp), [VariableReference(MetaKeyKeyListener, []), Expression(this, []), Expression(sp, [])]), Statement(}, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(Editable content, []), Expression(getEditableText(), [])])    VariableReference(Editable content, [])    Expression(getEditableText(), [])  AssignmentExpression(=, [VariableReference(if (text.text !, []), Expression(null) {, [])])    VariableReference(if (text.text !, [])    Expression(null) {, [])  AssignmentExpression(=, [VariableReference(if (content, []), Expression(, [])])    VariableReference(if (content, [])    Expression(, [])  MethodCall(removeParcelableSpans(content, 0, content.length()), [VariableReference(removeParcelableSpans(content, 0, content, []), Expression(), [])])    VariableReference(removeParcelableSpans(content, 0, content, [])    Expression(), [])  MethodCall(content.replace(0, content.length(), text.text), [VariableReference(content, []), Expression(0, []), Expression(content.length(), []), Expression(text.text, [])])    VariableReference(content, [])    Expression(0, [])    Expression(content.length(), [])    Expression(text.text, [])  Statement(} else {, [])  AssignmentExpression(=, [VariableReference(final int N, []), Expression(content.length(), [])])    VariableReference(final int N, [])    Expression(content.length(), [])  AssignmentExpression(=, [VariableReference(int start, []), Expression(text.partialStartOffset, [])])    VariableReference(int start, [])    Expression(text.partialStartOffset, [])  Statement(if (start > N), [])  AssignmentExpression(=, [VariableReference(start, []), Expression(N, [])])    VariableReference(start, [])    Expression(N, [])  AssignmentExpression(=, [VariableReference(int end, []), Expression(text.partialEndOffset, [])])    VariableReference(int end, [])    Expression(text.partialEndOffset, [])  Statement(if (end > N), [])  AssignmentExpression(=, [VariableReference(end, []), Expression(N, [])])    VariableReference(end, [])    Expression(N, [])  Statement(removeParcelableSpans(content, start, end), [])  MethodCall(content.replace(start, end, text.text), [VariableReference(content, []), Expression(start, []), Expression(end, []), Expression(text.text, [])])    VariableReference(content, [])    Expression(start, [])    Expression(end, [])    Expression(text.text, [])  Statement(}, [])  Statement(}, [])  Statement(// Now set the selection position...  make sure it is in range, to, [])  Statement(// avoid crashes.  If this is a partial update, it is possible that, [])  Statement(// the underlying text may have changed, causing us problems here., [])  Statement(// Also we just don't want to trust clients to do the right thing., [])  AssignmentExpression(=, [VariableReference(Spannable sp, []), Expression((Spannable) getText(), [])])    VariableReference(Spannable sp, [])    Expression((Spannable) getText(), [])  AssignmentExpression(=, [VariableReference(final int N, []), Expression(sp.length(), [])])    VariableReference(final int N, [])    Expression(sp.length(), [])  AssignmentExpression(=, [VariableReference(int start, []), Expression(text.selectionStart, [])])    VariableReference(int start, [])    Expression(text.selectionStart, [])  Statement(if (start < 0), [])  AssignmentExpression(=, [VariableReference(start, []), Expression(0, [])])    VariableReference(start, [])    Expression(0, [])  Statement(else if (start > N), [])  AssignmentExpression(=, [VariableReference(start, []), Expression(N, [])])    VariableReference(start, [])    Expression(N, [])  AssignmentExpression(=, [VariableReference(int end, []), Expression(text.selectionEnd, [])])    VariableReference(int end, [])    Expression(text.selectionEnd, [])  Statement(if (end < 0), [])  AssignmentExpression(=, [VariableReference(end, []), Expression(0, [])])    VariableReference(end, [])    Expression(0, [])  Statement(else if (end > N), [])  AssignmentExpression(=, [VariableReference(end, []), Expression(N, [])])    VariableReference(end, [])    Expression(N, [])  MethodCall(Selection.setSelection(sp, start, end), [VariableReference(Selection, []), Expression(sp, []), Expression(start, []), Expression(end, [])])    VariableReference(Selection, [])    Expression(sp, [])    Expression(start, [])    Expression(end, [])  Statement(// Finally, update the selection mode., [])  AssignmentExpression(=, [VariableReference(if ((text.flags & ExtractedText.FLAG_SELECTING) !, []), Expression(0) {, [])])    VariableReference(if ((text.flags & ExtractedText.FLAG_SELECTING) !, [])    Expression(0) {, [])  MethodCall(MetaKeyKeyListener.startSelecting(this, sp), [VariableReference(MetaKeyKeyListener, []), Expression(this, []), Expression(sp, [])])    VariableReference(MetaKeyKeyListener, [])    Expression(this, [])    Expression(sp, [])  Statement(} else {, [])  MethodCall(MetaKeyKeyListener.stopSelecting(this, sp), [VariableReference(MetaKeyKeyListener, []), Expression(this, []), Expression(sp, [])])    VariableReference(MetaKeyKeyListener, [])    Expression(this, [])    Expression(sp, [])  Statement(}, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(Editable content, []), Expression(getEditableText(), [])]), AssignmentExpression(=, [VariableReference(if (text.text !, []), Expression(null) {, [])]), AssignmentExpression(=, [VariableReference(if (content, []), Expression(, [])]), Statement(} else {, []), AssignmentExpression(=, [VariableReference(int start, []), Expression(0, [])]), AssignmentExpression(=, [VariableReference(int end, []), Expression(content.length(), [])]), AssignmentExpression(=, [VariableReference(if (text.partialStartOffset >, []), Expression(0) {, [])]), AssignmentExpression(=, [VariableReference(final int N, []), Expression(content.length(), [])]), AssignmentExpression(=, [VariableReference(start, []), Expression(text.partialStartOffset, [])]), Statement(if (start > N), []), AssignmentExpression(=, [VariableReference(start, []), Expression(N, [])]), AssignmentExpression(=, [VariableReference(end, []), Expression(text.partialEndOffset, [])]), Statement(if (end > N), []), AssignmentExpression(=, [VariableReference(end, []), Expression(N, [])]), Statement(}, []), Statement(removeParcelableSpans(content, start, end), []), MethodCall(if (TextUtils.equals(content.subSequence(start, end), text.text)), [VariableReference(if (TextUtils, []), Expression(content.subSequence(start, []), Expression(end), []), Expression(text.text), [])]), Statement(// OK to copy spans only., []), MethodCall(TextUtils.copySpansFrom((Spanned) text.text, start, end, Object.class, content, start), [VariableReference(TextUtils, []), Expression((Spanned) text.text, []), Expression(start, []), Expression(end, []), Expression(Object.class, []), Expression(content, []), Expression(start, [])]), Statement(}, []), Statement(} else {, []), MethodCall(content.replace(start, end, text.text), [VariableReference(content, []), Expression(start, []), Expression(end, []), Expression(text.text, [])]), Statement(}, []), Statement(}, []), Statement(}, []), Statement(// Now set the selection position...  make sure it is in range, to, []), Statement(// avoid crashes.  If this is a partial update, it is possible that, []), Statement(// the underlying text may have changed, causing us problems here., []), Statement(// Also we just don't want to trust clients to do the right thing., []), AssignmentExpression(=, [VariableReference(Spannable sp, []), Expression((Spannable) getText(), [])]), AssignmentExpression(=, [VariableReference(final int N, []), Expression(sp.length(), [])]), AssignmentExpression(=, [VariableReference(int start, []), Expression(text.selectionStart, [])]), Statement(if (start < 0), []), AssignmentExpression(=, [VariableReference(start, []), Expression(0, [])]), Statement(else if (start > N), []), AssignmentExpression(=, [VariableReference(start, []), Expression(N, [])]), AssignmentExpression(=, [VariableReference(int end, []), Expression(text.selectionEnd, [])]), Statement(if (end < 0), []), AssignmentExpression(=, [VariableReference(end, []), Expression(0, [])]), Statement(else if (end > N), []), AssignmentExpression(=, [VariableReference(end, []), Expression(N, [])]), MethodCall(Selection.setSelection(sp, start, end), [VariableReference(Selection, []), Expression(sp, []), Expression(start, []), Expression(end, [])]), Statement(// Finally, update the selection mode., []), AssignmentExpression(=, [VariableReference(if ((text.flags & ExtractedText.FLAG_SELECTING) !, []), Expression(0) {, [])]), MethodCall(MetaKeyKeyListener.startSelecting(this, sp), [VariableReference(MetaKeyKeyListener, []), Expression(this, []), Expression(sp, [])]), Statement(} else {, []), MethodCall(MetaKeyKeyListener.stopSelecting(this, sp), [VariableReference(MetaKeyKeyListener, []), Expression(this, []), Expression(sp, [])]), Statement(}, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(Editable content, []), Expression(getEditableText(), [])])    VariableReference(Editable content, [])    Expression(getEditableText(), [])  AssignmentExpression(=, [VariableReference(if (text.text !, []), Expression(null) {, [])])    VariableReference(if (text.text !, [])    Expression(null) {, [])  AssignmentExpression(=, [VariableReference(if (content, []), Expression(, [])])    VariableReference(if (content, [])    Expression(, [])  Statement(} else {, [])  AssignmentExpression(=, [VariableReference(int start, []), Expression(0, [])])    VariableReference(int start, [])    Expression(0, [])  AssignmentExpression(=, [VariableReference(int end, []), Expression(content.length(), [])])    VariableReference(int end, [])    Expression(content.length(), [])  AssignmentExpression(=, [VariableReference(if (text.partialStartOffset >, []), Expression(0) {, [])])    VariableReference(if (text.partialStartOffset >, [])    Expression(0) {, [])  AssignmentExpression(=, [VariableReference(final int N, []), Expression(content.length(), [])])    VariableReference(final int N, [])    Expression(content.length(), [])  AssignmentExpression(=, [VariableReference(start, []), Expression(text.partialStartOffset, [])])    VariableReference(start, [])    Expression(text.partialStartOffset, [])  Statement(if (start > N), [])  AssignmentExpression(=, [VariableReference(start, []), Expression(N, [])])    VariableReference(start, [])    Expression(N, [])  AssignmentExpression(=, [VariableReference(end, []), Expression(text.partialEndOffset, [])])    VariableReference(end, [])    Expression(text.partialEndOffset, [])  Statement(if (end > N), [])  AssignmentExpression(=, [VariableReference(end, []), Expression(N, [])])    VariableReference(end, [])    Expression(N, [])  Statement(}, [])  Statement(removeParcelableSpans(content, start, end), [])  MethodCall(if (TextUtils.equals(content.subSequence(start, end), text.text)), [VariableReference(if (TextUtils, []), Expression(content.subSequence(start, []), Expression(end), []), Expression(text.text), [])])    VariableReference(if (TextUtils, [])    Expression(content.subSequence(start, [])    Expression(end), [])    Expression(text.text), [])  Statement(// OK to copy spans only., [])  MethodCall(TextUtils.copySpansFrom((Spanned) text.text, start, end, Object.class, content, start), [VariableReference(TextUtils, []), Expression((Spanned) text.text, []), Expression(start, []), Expression(end, []), Expression(Object.class, []), Expression(content, []), Expression(start, [])])    VariableReference(TextUtils, [])    Expression((Spanned) text.text, [])    Expression(start, [])    Expression(end, [])    Expression(Object.class, [])    Expression(content, [])    Expression(start, [])  Statement(}, [])  Statement(} else {, [])  MethodCall(content.replace(start, end, text.text), [VariableReference(content, []), Expression(start, []), Expression(end, []), Expression(text.text, [])])    VariableReference(content, [])    Expression(start, [])    Expression(end, [])    Expression(text.text, [])  Statement(}, [])  Statement(}, [])  Statement(}, [])  Statement(// Now set the selection position...  make sure it is in range, to, [])  Statement(// avoid crashes.  If this is a partial update, it is possible that, [])  Statement(// the underlying text may have changed, causing us problems here., [])  Statement(// Also we just don't want to trust clients to do the right thing., [])  AssignmentExpression(=, [VariableReference(Spannable sp, []), Expression((Spannable) getText(), [])])    VariableReference(Spannable sp, [])    Expression((Spannable) getText(), [])  AssignmentExpression(=, [VariableReference(final int N, []), Expression(sp.length(), [])])    VariableReference(final int N, [])    Expression(sp.length(), [])  AssignmentExpression(=, [VariableReference(int start, []), Expression(text.selectionStart, [])])    VariableReference(int start, [])    Expression(text.selectionStart, [])  Statement(if (start < 0), [])  AssignmentExpression(=, [VariableReference(start, []), Expression(0, [])])    VariableReference(start, [])    Expression(0, [])  Statement(else if (start > N), [])  AssignmentExpression(=, [VariableReference(start, []), Expression(N, [])])    VariableReference(start, [])    Expression(N, [])  AssignmentExpression(=, [VariableReference(int end, []), Expression(text.selectionEnd, [])])    VariableReference(int end, [])    Expression(text.selectionEnd, [])  Statement(if (end < 0), [])  AssignmentExpression(=, [VariableReference(end, []), Expression(0, [])])    VariableReference(end, [])    Expression(0, [])  Statement(else if (end > N), [])  AssignmentExpression(=, [VariableReference(end, []), Expression(N, [])])    VariableReference(end, [])    Expression(N, [])  MethodCall(Selection.setSelection(sp, start, end), [VariableReference(Selection, []), Expression(sp, []), Expression(start, []), Expression(end, [])])    VariableReference(Selection, [])    Expression(sp, [])    Expression(start, [])    Expression(end, [])  Statement(// Finally, update the selection mode., [])  AssignmentExpression(=, [VariableReference(if ((text.flags & ExtractedText.FLAG_SELECTING) !, []), Expression(0) {, [])])    VariableReference(if ((text.flags & ExtractedText.FLAG_SELECTING) !, [])    Expression(0) {, [])  MethodCall(MetaKeyKeyListener.startSelecting(this, sp), [VariableReference(MetaKeyKeyListener, []), Expression(this, []), Expression(sp, [])])    VariableReference(MetaKeyKeyListener, [])    Expression(this, [])    Expression(sp, [])  Statement(} else {, [])  MethodCall(MetaKeyKeyListener.stopSelecting(this, sp), [VariableReference(MetaKeyKeyListener, []), Expression(this, []), Expression(sp, [])])    VariableReference(MetaKeyKeyListener, [])    Expression(this, [])    Expression(sp, [])  Statement(}, [])  Statement(}, [])",1,"/**
 * Apply to this text view the given extracted text, as previously
 * returned by {@link #extractText(ExtractedTextRequest, ExtractedText)}.
 */
","/**
 * Apply to this text view the given extracted text, as previously
 * returned by {@link #extractText(ExtractedTextRequest, ExtractedText)}.
 */
",0,,,0,,,0,"1,2","3,4,5",0,"3,4",0,"The implementation has undergone changes in the control dependency (e.g., added and modified 'if' statements) and other statements such as method calls and assignments, so the code change type is 3,4.","Although the implementation has changed, these changes do not potentially cause different return values or different exception handlings. Therefore, the CI type is 0."
170,<android.net.Uri: Uri normalizeScheme()>,22,23,<android.net.Uri: Uri normalizeScheme()>,<android.net.Uri: Uri normalizeScheme()>,0,"MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(String scheme, []), Expression(getScheme(), [])]), Statement(// give up, []), AssignmentExpression(=, [VariableReference(if (scheme, []), Expression(, [])]), Statement(return this, []), AssignmentExpression(=, [VariableReference(String lowerScheme, []), Expression(scheme.toLowerCase(Locale.ROOT), [])]), Statement(// no change, []), MethodCall(if (scheme.equals(lowerScheme)), [VariableReference(if (scheme, []), Expression(lowerScheme), [])]), Statement(return this, []), MethodCall(return buildUpon().scheme(lowerScheme).build(), [VariableReference(return buildUpon(), []), Expression(lowerScheme).build(, [])]), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(String scheme, []), Expression(getScheme(), [])])    VariableReference(String scheme, [])    Expression(getScheme(), [])  Statement(// give up, [])  AssignmentExpression(=, [VariableReference(if (scheme, []), Expression(, [])])    VariableReference(if (scheme, [])    Expression(, [])  Statement(return this, [])  AssignmentExpression(=, [VariableReference(String lowerScheme, []), Expression(scheme.toLowerCase(Locale.ROOT), [])])    VariableReference(String lowerScheme, [])    Expression(scheme.toLowerCase(Locale.ROOT), [])  Statement(// no change, [])  MethodCall(if (scheme.equals(lowerScheme)), [VariableReference(if (scheme, []), Expression(lowerScheme), [])])    VariableReference(if (scheme, [])    Expression(lowerScheme), [])  Statement(return this, [])  MethodCall(return buildUpon().scheme(lowerScheme).build(), [VariableReference(return buildUpon(), []), Expression(lowerScheme).build(, [])])    VariableReference(return buildUpon(), [])    Expression(lowerScheme).build(, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(String scheme, []), Expression(getScheme(), [])]), Statement(// give up, []), AssignmentExpression(=, [VariableReference(if (scheme, []), Expression(, [])]), Statement(return this, []), AssignmentExpression(=, [VariableReference(String lowerScheme, []), Expression(scheme.toLowerCase(Locale.ROOT), [])]), Statement(// no change, []), MethodCall(if (scheme.equals(lowerScheme)), [VariableReference(if (scheme, []), Expression(lowerScheme), [])]), Statement(return this, []), MethodCall(return buildUpon().scheme(lowerScheme).build(), [VariableReference(return buildUpon(), []), Expression(lowerScheme).build(, [])]), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(String scheme, []), Expression(getScheme(), [])])    VariableReference(String scheme, [])    Expression(getScheme(), [])  Statement(// give up, [])  AssignmentExpression(=, [VariableReference(if (scheme, []), Expression(, [])])    VariableReference(if (scheme, [])    Expression(, [])  Statement(return this, [])  AssignmentExpression(=, [VariableReference(String lowerScheme, []), Expression(scheme.toLowerCase(Locale.ROOT), [])])    VariableReference(String lowerScheme, [])    Expression(scheme.toLowerCase(Locale.ROOT), [])  Statement(// no change, [])  MethodCall(if (scheme.equals(lowerScheme)), [VariableReference(if (scheme, []), Expression(lowerScheme), [])])    VariableReference(if (scheme, [])    Expression(lowerScheme), [])  Statement(return this, [])  MethodCall(return buildUpon().scheme(lowerScheme).build(), [VariableReference(return buildUpon(), []), Expression(lowerScheme).build(, [])])    VariableReference(return buildUpon(), [])    Expression(lowerScheme).build(, [])  Statement(}, [])",0,"/**
 * Return an equivalent URI with a lowercase scheme component.
 * This aligns the Uri with Android best practices for
 * intent filtering.
 *
 * <p>For example, ""HTTP://www.android.com"" becomes
 * ""http://www.android.com""
 *
 * <p>All URIs received from outside Android (such as user input,
 * or external sources like Bluetooth, NFC, or the Internet) should
 * be normalized before they are used to create an Intent.
 *
 * <p class=""note"">This method does <em>not</em> validate bad URI's,
 * or 'fix' poorly formatted URI's - so do not use it for input validation.
 * A Uri will always be returned, even if the Uri is badly formatted to
 * begin with and a scheme component cannot be found.
 *
 * @return normalized Uri (never null)
 * @see {@link android.content.Intent#setData}
 * @see {@link #setNormalizedData}
 */
","/**
 * Return an equivalent URI with a lowercase scheme component.
 * This aligns the Uri with Android best practices for
 * intent filtering.
 *
 * <p>For example, ""HTTP://www.android.com"" becomes
 * ""http://www.android.com""
 *
 * <p>All URIs received from outside Android (such as user input,
 * or external sources like Bluetooth, NFC, or the Internet) should
 * be normalized before they are used to create an Intent.
 *
 * <p class=""note"">This method does <em>not</em> validate bad URI's,
 * or 'fix' poorly formatted URI's - so do not use it for input validation.
 * A Uri will always be returned, even if the Uri is badly formatted to
 * begin with and a scheme component cannot be found.
 *
 * @return normalized Uri (never null)
 * @see {@link android.content.Intent#setData}
 * @see {@link android.content.Intent#setDataAndNormalize}
 */
",1,,,0,,,0,0,0,0,0,0,"The AST for both implementations is identical, indicating no change in the implementation.","Since there are no changes in the code implementation, no compatibility issue exists."
171,"<android.content.ContextWrapper: void sendStickyOrderedBroadcastAsUser(Intent,UserHandle,BroadcastReceiver,Handler,int,String,Bundle)>",22,23,"<android.content.ContextWrapper: void sendStickyOrderedBroadcastAsUser(Intent,UserHandle,BroadcastReceiver,Handler,int,String,Bundle)>","<android.content.ContextWrapper: void sendStickyOrderedBroadcastAsUser(Intent,UserHandle,BroadcastReceiver,Handler,int,String,Bundle)>",0,"MethodDeclaration(method_body, [Statement({, []), MethodCall(mBase.sendStickyOrderedBroadcastAsUser(intent, user, resultReceiver, scheduler, initialCode, initialData, initialExtras), [VariableReference(mBase, []), Expression(intent, []), Expression(user, []), Expression(resultReceiver, []), Expression(scheduler, []), Expression(initialCode, []), Expression(initialData, []), Expression(initialExtras, [])]), Statement(}, [])])  Statement({, [])  MethodCall(mBase.sendStickyOrderedBroadcastAsUser(intent, user, resultReceiver, scheduler, initialCode, initialData, initialExtras), [VariableReference(mBase, []), Expression(intent, []), Expression(user, []), Expression(resultReceiver, []), Expression(scheduler, []), Expression(initialCode, []), Expression(initialData, []), Expression(initialExtras, [])])    VariableReference(mBase, [])    Expression(intent, [])    Expression(user, [])    Expression(resultReceiver, [])    Expression(scheduler, [])    Expression(initialCode, [])    Expression(initialData, [])    Expression(initialExtras, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), MethodCall(mBase.sendStickyOrderedBroadcastAsUser(intent, user, resultReceiver, scheduler, initialCode, initialData, initialExtras), [VariableReference(mBase, []), Expression(intent, []), Expression(user, []), Expression(resultReceiver, []), Expression(scheduler, []), Expression(initialCode, []), Expression(initialData, []), Expression(initialExtras, [])]), Statement(}, [])])  Statement({, [])  MethodCall(mBase.sendStickyOrderedBroadcastAsUser(intent, user, resultReceiver, scheduler, initialCode, initialData, initialExtras), [VariableReference(mBase, []), Expression(intent, []), Expression(user, []), Expression(resultReceiver, []), Expression(scheduler, []), Expression(initialCode, []), Expression(initialData, []), Expression(initialExtras, [])])    VariableReference(mBase, [])    Expression(intent, [])    Expression(user, [])    Expression(resultReceiver, [])    Expression(scheduler, [])    Expression(initialCode, [])    Expression(initialData, [])    Expression(initialExtras, [])  Statement(}, [])",0,,,0,[@Override],"[@Override, @Deprecated]",1,,,0,0,0,0,0,0,"There are no changes detected in the method implementation between the given versions. The only difference is the addition of the `@Deprecated` annotation, which does not affect the method's functionality or behavior.",There are no compatibility issues since the method's implementation has not changed between the given versions. The addition of the `@Deprecated` annotation is informational and does not impact the method's execution.
172,<android.hardware.camera2.legacy.SurfaceTextureRenderer: void drawIntoSurfaces(CaptureCollector)>,23,24,<android.hardware.camera2.legacy.SurfaceTextureRenderer: void drawIntoSurfaces(CaptureCollector)>,<android.hardware.camera2.legacy.SurfaceTextureRenderer: void drawIntoSurfaces(CaptureCollector)>,0,"MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(if ((mSurfaces, []), Expression(, [])]), Statement(return, []), Statement(}, []), AssignmentExpression(=, [VariableReference(boolean doTiming, []), Expression(targetCollector.hasPendingPreviewCaptures(), [])]), Statement(checkGlError(""before updateTexImage""), []), Statement(if (doTiming) {, []), Statement(beginGlTiming(), []), Statement(}, []), MethodCall(mSurfaceTexture.updateTexImage(), [VariableReference(mSurfaceTexture, []), Expression(, [])]), AssignmentExpression(=, [VariableReference(long timestamp, []), Expression(mSurfaceTexture.getTimestamp(), [])]), AssignmentExpression(=, [VariableReference(Pair<RequestHolder, Long> captureHolder, []), Expression(targetCollector.previewCaptured(timestamp), [])]), Statement(// No preview request queued, drop frame., []), AssignmentExpression(=, [VariableReference(if (captureHolder, []), Expression(, [])]), Statement(if (DEBUG) {, []), MethodCall(Log.d(TAG, ""Dropping preview frame.""), [VariableReference(Log, []), Expression(TAG, []), Expression(""Dropping preview frame."", [])]), Statement(}, []), Statement(if (doTiming) {, []), Statement(endGlTiming(), []), Statement(}, []), Statement(return, []), Statement(}, []), AssignmentExpression(=, [VariableReference(RequestHolder request, []), Expression(captureHolder.first, [])]), AssignmentExpression(=, [VariableReference(Collection<Surface> targetSurfaces, []), Expression(request.getHolderTargets(), [])]), Statement(if (doTiming) {, []), Statement(addGlTimestamp(timestamp), []), Statement(}, []), AssignmentExpression(=, [VariableReference(List<Long> targetSurfaceIds, []), Expression(LegacyCameraDevice.getSurfaceIds(targetSurfaces), [])]), Statement(for (EGLSurfaceHolder holder : mSurfaces) {, []), MethodCall(if (LegacyCameraDevice.containsSurfaceId(holder.surface, targetSurfaceIds)), [VariableReference(if (LegacyCameraDevice, []), Expression(holder.surface, []), Expression(targetSurfaceIds), [])]), Statement(try {, []), MethodCall(LegacyCameraDevice.setSurfaceDimens(holder.surface, holder.width, holder.height), [VariableReference(LegacyCameraDevice, []), Expression(holder.surface, []), Expression(holder.width, []), Expression(holder.height, [])]), MethodCall(LegacyCameraDevice.setNextTimestamp(holder.surface, captureHolder.second), [VariableReference(LegacyCameraDevice, []), Expression(holder.surface, []), Expression(captureHolder.second, [])]), AssignmentExpression(=, [VariableReference(drawFrame(mSurfaceTexture, holder.width, holder.height, (mFacing, []), Expression(, [])]), MethodCall(Log.w(TAG, ""Surface abandoned, dropping frame. "", e), [VariableReference(Log, []), Expression(TAG, []), Expression(""Surface abandoned, []), Expression(dropping frame. "", []), Expression(e, [])]), Statement(}, []), Statement(}, []), Statement(}, []), Statement(for (EGLSurfaceHolder holder : mConversionSurfaces) {, []), MethodCall(if (LegacyCameraDevice.containsSurfaceId(holder.surface, targetSurfaceIds)), [VariableReference(if (LegacyCameraDevice, []), Expression(holder.surface, []), Expression(targetSurfaceIds), [])]), Statement(// glReadPixels reads from the bottom of the buffer, so add an extra vertical flip, []), AssignmentExpression(=, [VariableReference(drawFrame(mSurfaceTexture, holder.width, holder.height, (mFacing, []), Expression(, [])]), MethodCall(mPBufferPixels.clear(), [VariableReference(mPBufferPixels, []), Expression(, [])]), Statement(0, /*y*/, []), Statement(0, holder.width, holder.height, GLES20.GL_RGBA, GLES20.GL_UNSIGNED_BYTE, mPBufferPixels), []), Statement(checkGlError(""glReadPixels""), []), Statement(try {, []), AssignmentExpression(=, [VariableReference(int format, []), Expression(LegacyCameraDevice.detectSurfaceType(holder.surface), [])]), MethodCall(LegacyCameraDevice.setSurfaceDimens(holder.surface, holder.width, holder.height), [VariableReference(LegacyCameraDevice, []), Expression(holder.surface, []), Expression(holder.width, []), Expression(holder.height, [])]), MethodCall(LegacyCameraDevice.setNextTimestamp(holder.surface, captureHolder.second), [VariableReference(LegacyCameraDevice, []), Expression(holder.surface, []), Expression(captureHolder.second, [])]), MethodCall(LegacyCameraDevice.produceFrame(holder.surface, mPBufferPixels.array(), holder.width, holder.height, format), [VariableReference(LegacyCameraDevice, []), Expression(holder.surface, []), Expression(mPBufferPixels.array(), []), Expression(holder.width, []), Expression(holder.height, []), Expression(format, [])]), MethodCall(Log.w(TAG, ""Surface abandoned, dropping frame. "", e), [VariableReference(Log, []), Expression(TAG, []), Expression(""Surface abandoned, []), Expression(dropping frame. "", []), Expression(e, [])]), Statement(}, []), Statement(}, []), Statement(}, []), MethodCall(targetCollector.previewProduced(), [VariableReference(targetCollector, []), Expression(, [])]), Statement(if (doTiming) {, []), Statement(endGlTiming(), []), Statement(}, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(if ((mSurfaces, []), Expression(, [])])    VariableReference(if ((mSurfaces, [])    Expression(, [])  Statement(return, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(boolean doTiming, []), Expression(targetCollector.hasPendingPreviewCaptures(), [])])    VariableReference(boolean doTiming, [])    Expression(targetCollector.hasPendingPreviewCaptures(), [])  Statement(checkGlError(""before updateTexImage""), [])  Statement(if (doTiming) {, [])  Statement(beginGlTiming(), [])  Statement(}, [])  MethodCall(mSurfaceTexture.updateTexImage(), [VariableReference(mSurfaceTexture, []), Expression(, [])])    VariableReference(mSurfaceTexture, [])    Expression(, [])  AssignmentExpression(=, [VariableReference(long timestamp, []), Expression(mSurfaceTexture.getTimestamp(), [])])    VariableReference(long timestamp, [])    Expression(mSurfaceTexture.getTimestamp(), [])  AssignmentExpression(=, [VariableReference(Pair<RequestHolder, Long> captureHolder, []), Expression(targetCollector.previewCaptured(timestamp), [])])    VariableReference(Pair<RequestHolder, Long> captureHolder, [])    Expression(targetCollector.previewCaptured(timestamp), [])  Statement(// No preview request queued, drop frame., [])  AssignmentExpression(=, [VariableReference(if (captureHolder, []), Expression(, [])])    VariableReference(if (captureHolder, [])    Expression(, [])  Statement(if (DEBUG) {, [])  MethodCall(Log.d(TAG, ""Dropping preview frame.""), [VariableReference(Log, []), Expression(TAG, []), Expression(""Dropping preview frame."", [])])    VariableReference(Log, [])    Expression(TAG, [])    Expression(""Dropping preview frame."", [])  Statement(}, [])  Statement(if (doTiming) {, [])  Statement(endGlTiming(), [])  Statement(}, [])  Statement(return, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(RequestHolder request, []), Expression(captureHolder.first, [])])    VariableReference(RequestHolder request, [])    Expression(captureHolder.first, [])  AssignmentExpression(=, [VariableReference(Collection<Surface> targetSurfaces, []), Expression(request.getHolderTargets(), [])])    VariableReference(Collection<Surface> targetSurfaces, [])    Expression(request.getHolderTargets(), [])  Statement(if (doTiming) {, [])  Statement(addGlTimestamp(timestamp), [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(List<Long> targetSurfaceIds, []), Expression(LegacyCameraDevice.getSurfaceIds(targetSurfaces), [])])    VariableReference(List<Long> targetSurfaceIds, [])    Expression(LegacyCameraDevice.getSurfaceIds(targetSurfaces), [])  Statement(for (EGLSurfaceHolder holder : mSurfaces) {, [])  MethodCall(if (LegacyCameraDevice.containsSurfaceId(holder.surface, targetSurfaceIds)), [VariableReference(if (LegacyCameraDevice, []), Expression(holder.surface, []), Expression(targetSurfaceIds), [])])    VariableReference(if (LegacyCameraDevice, [])    Expression(holder.surface, [])    Expression(targetSurfaceIds), [])  Statement(try {, [])  MethodCall(LegacyCameraDevice.setSurfaceDimens(holder.surface, holder.width, holder.height), [VariableReference(LegacyCameraDevice, []), Expression(holder.surface, []), Expression(holder.width, []), Expression(holder.height, [])])    VariableReference(LegacyCameraDevice, [])    Expression(holder.surface, [])    Expression(holder.width, [])    Expression(holder.height, [])  MethodCall(LegacyCameraDevice.setNextTimestamp(holder.surface, captureHolder.second), [VariableReference(LegacyCameraDevice, []), Expression(holder.surface, []), Expression(captureHolder.second, [])])    VariableReference(LegacyCameraDevice, [])    Expression(holder.surface, [])    Expression(captureHolder.second, [])  AssignmentExpression(=, [VariableReference(drawFrame(mSurfaceTexture, holder.width, holder.height, (mFacing, []), Expression(, [])])    VariableReference(drawFrame(mSurfaceTexture, holder.width, holder.height, (mFacing, [])    Expression(, [])  MethodCall(Log.w(TAG, ""Surface abandoned, dropping frame. "", e), [VariableReference(Log, []), Expression(TAG, []), Expression(""Surface abandoned, []), Expression(dropping frame. "", []), Expression(e, [])])    VariableReference(Log, [])    Expression(TAG, [])    Expression(""Surface abandoned, [])    Expression(dropping frame. "", [])    Expression(e, [])  Statement(}, [])  Statement(}, [])  Statement(}, [])  Statement(for (EGLSurfaceHolder holder : mConversionSurfaces) {, [])  MethodCall(if (LegacyCameraDevice.containsSurfaceId(holder.surface, targetSurfaceIds)), [VariableReference(if (LegacyCameraDevice, []), Expression(holder.surface, []), Expression(targetSurfaceIds), [])])    VariableReference(if (LegacyCameraDevice, [])    Expression(holder.surface, [])    Expression(targetSurfaceIds), [])  Statement(// glReadPixels reads from the bottom of the buffer, so add an extra vertical flip, [])  AssignmentExpression(=, [VariableReference(drawFrame(mSurfaceTexture, holder.width, holder.height, (mFacing, []), Expression(, [])])    VariableReference(drawFrame(mSurfaceTexture, holder.width, holder.height, (mFacing, [])    Expression(, [])  MethodCall(mPBufferPixels.clear(), [VariableReference(mPBufferPixels, []), Expression(, [])])    VariableReference(mPBufferPixels, [])    Expression(, [])  Statement(0, /*y*/, [])  Statement(0, holder.width, holder.height, GLES20.GL_RGBA, GLES20.GL_UNSIGNED_BYTE, mPBufferPixels), [])  Statement(checkGlError(""glReadPixels""), [])  Statement(try {, [])  AssignmentExpression(=, [VariableReference(int format, []), Expression(LegacyCameraDevice.detectSurfaceType(holder.surface), [])])    VariableReference(int format, [])    Expression(LegacyCameraDevice.detectSurfaceType(holder.surface), [])  MethodCall(LegacyCameraDevice.setSurfaceDimens(holder.surface, holder.width, holder.height), [VariableReference(LegacyCameraDevice, []), Expression(holder.surface, []), Expression(holder.width, []), Expression(holder.height, [])])    VariableReference(LegacyCameraDevice, [])    Expression(holder.surface, [])    Expression(holder.width, [])    Expression(holder.height, [])  MethodCall(LegacyCameraDevice.setNextTimestamp(holder.surface, captureHolder.second), [VariableReference(LegacyCameraDevice, []), Expression(holder.surface, []), Expression(captureHolder.second, [])])    VariableReference(LegacyCameraDevice, [])    Expression(holder.surface, [])    Expression(captureHolder.second, [])  MethodCall(LegacyCameraDevice.produceFrame(holder.surface, mPBufferPixels.array(), holder.width, holder.height, format), [VariableReference(LegacyCameraDevice, []), Expression(holder.surface, []), Expression(mPBufferPixels.array(), []), Expression(holder.width, []), Expression(holder.height, []), Expression(format, [])])    VariableReference(LegacyCameraDevice, [])    Expression(holder.surface, [])    Expression(mPBufferPixels.array(), [])    Expression(holder.width, [])    Expression(holder.height, [])    Expression(format, [])  MethodCall(Log.w(TAG, ""Surface abandoned, dropping frame. "", e), [VariableReference(Log, []), Expression(TAG, []), Expression(""Surface abandoned, []), Expression(dropping frame. "", []), Expression(e, [])])    VariableReference(Log, [])    Expression(TAG, [])    Expression(""Surface abandoned, [])    Expression(dropping frame. "", [])    Expression(e, [])  Statement(}, [])  Statement(}, [])  Statement(}, [])  MethodCall(targetCollector.previewProduced(), [VariableReference(targetCollector, []), Expression(, [])])    VariableReference(targetCollector, [])    Expression(, [])  Statement(if (doTiming) {, [])  Statement(endGlTiming(), [])  Statement(}, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(if ((mSurfaces, []), Expression(, [])]), Statement(return, []), Statement(}, []), AssignmentExpression(=, [VariableReference(boolean doTiming, []), Expression(targetCollector.hasPendingPreviewCaptures(), [])]), Statement(checkGlError(""before updateTexImage""), []), Statement(if (doTiming) {, []), Statement(beginGlTiming(), []), Statement(}, []), MethodCall(mSurfaceTexture.updateTexImage(), [VariableReference(mSurfaceTexture, []), Expression(, [])]), AssignmentExpression(=, [VariableReference(long timestamp, []), Expression(mSurfaceTexture.getTimestamp(), [])]), AssignmentExpression(=, [VariableReference(Pair<RequestHolder, Long> captureHolder, []), Expression(targetCollector.previewCaptured(timestamp), [])]), Statement(// No preview request queued, drop frame., []), AssignmentExpression(=, [VariableReference(if (captureHolder, []), Expression(, [])]), Statement(if (DEBUG) {, []), MethodCall(Log.d(TAG, ""Dropping preview frame.""), [VariableReference(Log, []), Expression(TAG, []), Expression(""Dropping preview frame."", [])]), Statement(}, []), Statement(if (doTiming) {, []), Statement(endGlTiming(), []), Statement(}, []), Statement(return, []), Statement(}, []), AssignmentExpression(=, [VariableReference(RequestHolder request, []), Expression(captureHolder.first, [])]), AssignmentExpression(=, [VariableReference(Collection<Surface> targetSurfaces, []), Expression(request.getHolderTargets(), [])]), Statement(if (doTiming) {, []), Statement(addGlTimestamp(timestamp), []), Statement(}, []), AssignmentExpression(=, [VariableReference(List<Long> targetSurfaceIds, []), Expression(new ArrayList(), [])]), Statement(try {, []), AssignmentExpression(=, [VariableReference(targetSurfaceIds, []), Expression(LegacyCameraDevice.getSurfaceIds(targetSurfaces), [])]), MethodCall(Log.w(TAG, ""Surface abandoned, dropping frame. "", e), [VariableReference(Log, []), Expression(TAG, []), Expression(""Surface abandoned, []), Expression(dropping frame. "", []), Expression(e, [])]), MethodCall(request.setOutputAbandoned(), [VariableReference(request, []), Expression(, [])]), Statement(}, []), Statement(for (EGLSurfaceHolder holder : mSurfaces) {, []), MethodCall(if (LegacyCameraDevice.containsSurfaceId(holder.surface, targetSurfaceIds)), [VariableReference(if (LegacyCameraDevice, []), Expression(holder.surface, []), Expression(targetSurfaceIds), [])]), Statement(try {, []), MethodCall(LegacyCameraDevice.setSurfaceDimens(holder.surface, holder.width, holder.height), [VariableReference(LegacyCameraDevice, []), Expression(holder.surface, []), Expression(holder.width, []), Expression(holder.height, [])]), MethodCall(LegacyCameraDevice.setNextTimestamp(holder.surface, captureHolder.second), [VariableReference(LegacyCameraDevice, []), Expression(holder.surface, []), Expression(captureHolder.second, [])]), AssignmentExpression(=, [VariableReference(drawFrame(mSurfaceTexture, holder.width, holder.height, (mFacing, []), Expression(, [])]), MethodCall(Log.w(TAG, ""Surface abandoned, dropping frame. "", e), [VariableReference(Log, []), Expression(TAG, []), Expression(""Surface abandoned, []), Expression(dropping frame. "", []), Expression(e, [])]), MethodCall(request.setOutputAbandoned(), [VariableReference(request, []), Expression(, [])]), Statement(}, []), Statement(}, []), Statement(}, []), Statement(for (EGLSurfaceHolder holder : mConversionSurfaces) {, []), MethodCall(if (LegacyCameraDevice.containsSurfaceId(holder.surface, targetSurfaceIds)), [VariableReference(if (LegacyCameraDevice, []), Expression(holder.surface, []), Expression(targetSurfaceIds), [])]), Statement(// glReadPixels reads from the bottom of the buffer, so add an extra vertical flip, []), AssignmentExpression(=, [VariableReference(drawFrame(mSurfaceTexture, holder.width, holder.height, (mFacing, []), Expression(, [])]), MethodCall(mPBufferPixels.clear(), [VariableReference(mPBufferPixels, []), Expression(, [])]), Statement(0, /*y*/, []), Statement(0, holder.width, holder.height, GLES20.GL_RGBA, GLES20.GL_UNSIGNED_BYTE, mPBufferPixels), []), Statement(checkGlError(""glReadPixels""), []), Statement(try {, []), AssignmentExpression(=, [VariableReference(int format, []), Expression(LegacyCameraDevice.detectSurfaceType(holder.surface), [])]), MethodCall(LegacyCameraDevice.setSurfaceDimens(holder.surface, holder.width, holder.height), [VariableReference(LegacyCameraDevice, []), Expression(holder.surface, []), Expression(holder.width, []), Expression(holder.height, [])]), MethodCall(LegacyCameraDevice.setNextTimestamp(holder.surface, captureHolder.second), [VariableReference(LegacyCameraDevice, []), Expression(holder.surface, []), Expression(captureHolder.second, [])]), MethodCall(LegacyCameraDevice.produceFrame(holder.surface, mPBufferPixels.array(), holder.width, holder.height, format), [VariableReference(LegacyCameraDevice, []), Expression(holder.surface, []), Expression(mPBufferPixels.array(), []), Expression(holder.width, []), Expression(holder.height, []), Expression(format, [])]), MethodCall(Log.w(TAG, ""Surface abandoned, dropping frame. "", e), [VariableReference(Log, []), Expression(TAG, []), Expression(""Surface abandoned, []), Expression(dropping frame. "", []), Expression(e, [])]), MethodCall(request.setOutputAbandoned(), [VariableReference(request, []), Expression(, [])]), Statement(}, []), Statement(}, []), Statement(}, []), MethodCall(targetCollector.previewProduced(), [VariableReference(targetCollector, []), Expression(, [])]), Statement(if (doTiming) {, []), Statement(endGlTiming(), []), Statement(}, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(if ((mSurfaces, []), Expression(, [])])    VariableReference(if ((mSurfaces, [])    Expression(, [])  Statement(return, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(boolean doTiming, []), Expression(targetCollector.hasPendingPreviewCaptures(), [])])    VariableReference(boolean doTiming, [])    Expression(targetCollector.hasPendingPreviewCaptures(), [])  Statement(checkGlError(""before updateTexImage""), [])  Statement(if (doTiming) {, [])  Statement(beginGlTiming(), [])  Statement(}, [])  MethodCall(mSurfaceTexture.updateTexImage(), [VariableReference(mSurfaceTexture, []), Expression(, [])])    VariableReference(mSurfaceTexture, [])    Expression(, [])  AssignmentExpression(=, [VariableReference(long timestamp, []), Expression(mSurfaceTexture.getTimestamp(), [])])    VariableReference(long timestamp, [])    Expression(mSurfaceTexture.getTimestamp(), [])  AssignmentExpression(=, [VariableReference(Pair<RequestHolder, Long> captureHolder, []), Expression(targetCollector.previewCaptured(timestamp), [])])    VariableReference(Pair<RequestHolder, Long> captureHolder, [])    Expression(targetCollector.previewCaptured(timestamp), [])  Statement(// No preview request queued, drop frame., [])  AssignmentExpression(=, [VariableReference(if (captureHolder, []), Expression(, [])])    VariableReference(if (captureHolder, [])    Expression(, [])  Statement(if (DEBUG) {, [])  MethodCall(Log.d(TAG, ""Dropping preview frame.""), [VariableReference(Log, []), Expression(TAG, []), Expression(""Dropping preview frame."", [])])    VariableReference(Log, [])    Expression(TAG, [])    Expression(""Dropping preview frame."", [])  Statement(}, [])  Statement(if (doTiming) {, [])  Statement(endGlTiming(), [])  Statement(}, [])  Statement(return, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(RequestHolder request, []), Expression(captureHolder.first, [])])    VariableReference(RequestHolder request, [])    Expression(captureHolder.first, [])  AssignmentExpression(=, [VariableReference(Collection<Surface> targetSurfaces, []), Expression(request.getHolderTargets(), [])])    VariableReference(Collection<Surface> targetSurfaces, [])    Expression(request.getHolderTargets(), [])  Statement(if (doTiming) {, [])  Statement(addGlTimestamp(timestamp), [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(List<Long> targetSurfaceIds, []), Expression(new ArrayList(), [])])    VariableReference(List<Long> targetSurfaceIds, [])    Expression(new ArrayList(), [])  Statement(try {, [])  AssignmentExpression(=, [VariableReference(targetSurfaceIds, []), Expression(LegacyCameraDevice.getSurfaceIds(targetSurfaces), [])])    VariableReference(targetSurfaceIds, [])    Expression(LegacyCameraDevice.getSurfaceIds(targetSurfaces), [])  MethodCall(Log.w(TAG, ""Surface abandoned, dropping frame. "", e), [VariableReference(Log, []), Expression(TAG, []), Expression(""Surface abandoned, []), Expression(dropping frame. "", []), Expression(e, [])])    VariableReference(Log, [])    Expression(TAG, [])    Expression(""Surface abandoned, [])    Expression(dropping frame. "", [])    Expression(e, [])  MethodCall(request.setOutputAbandoned(), [VariableReference(request, []), Expression(, [])])    VariableReference(request, [])    Expression(, [])  Statement(}, [])  Statement(for (EGLSurfaceHolder holder : mSurfaces) {, [])  MethodCall(if (LegacyCameraDevice.containsSurfaceId(holder.surface, targetSurfaceIds)), [VariableReference(if (LegacyCameraDevice, []), Expression(holder.surface, []), Expression(targetSurfaceIds), [])])    VariableReference(if (LegacyCameraDevice, [])    Expression(holder.surface, [])    Expression(targetSurfaceIds), [])  Statement(try {, [])  MethodCall(LegacyCameraDevice.setSurfaceDimens(holder.surface, holder.width, holder.height), [VariableReference(LegacyCameraDevice, []), Expression(holder.surface, []), Expression(holder.width, []), Expression(holder.height, [])])    VariableReference(LegacyCameraDevice, [])    Expression(holder.surface, [])    Expression(holder.width, [])    Expression(holder.height, [])  MethodCall(LegacyCameraDevice.setNextTimestamp(holder.surface, captureHolder.second), [VariableReference(LegacyCameraDevice, []), Expression(holder.surface, []), Expression(captureHolder.second, [])])    VariableReference(LegacyCameraDevice, [])    Expression(holder.surface, [])    Expression(captureHolder.second, [])  AssignmentExpression(=, [VariableReference(drawFrame(mSurfaceTexture, holder.width, holder.height, (mFacing, []), Expression(, [])])    VariableReference(drawFrame(mSurfaceTexture, holder.width, holder.height, (mFacing, [])    Expression(, [])  MethodCall(Log.w(TAG, ""Surface abandoned, dropping frame. "", e), [VariableReference(Log, []), Expression(TAG, []), Expression(""Surface abandoned, []), Expression(dropping frame. "", []), Expression(e, [])])    VariableReference(Log, [])    Expression(TAG, [])    Expression(""Surface abandoned, [])    Expression(dropping frame. "", [])    Expression(e, [])  MethodCall(request.setOutputAbandoned(), [VariableReference(request, []), Expression(, [])])    VariableReference(request, [])    Expression(, [])  Statement(}, [])  Statement(}, [])  Statement(}, [])  Statement(for (EGLSurfaceHolder holder : mConversionSurfaces) {, [])  MethodCall(if (LegacyCameraDevice.containsSurfaceId(holder.surface, targetSurfaceIds)), [VariableReference(if (LegacyCameraDevice, []), Expression(holder.surface, []), Expression(targetSurfaceIds), [])])    VariableReference(if (LegacyCameraDevice, [])    Expression(holder.surface, [])    Expression(targetSurfaceIds), [])  Statement(// glReadPixels reads from the bottom of the buffer, so add an extra vertical flip, [])  AssignmentExpression(=, [VariableReference(drawFrame(mSurfaceTexture, holder.width, holder.height, (mFacing, []), Expression(, [])])    VariableReference(drawFrame(mSurfaceTexture, holder.width, holder.height, (mFacing, [])    Expression(, [])  MethodCall(mPBufferPixels.clear(), [VariableReference(mPBufferPixels, []), Expression(, [])])    VariableReference(mPBufferPixels, [])    Expression(, [])  Statement(0, /*y*/, [])  Statement(0, holder.width, holder.height, GLES20.GL_RGBA, GLES20.GL_UNSIGNED_BYTE, mPBufferPixels), [])  Statement(checkGlError(""glReadPixels""), [])  Statement(try {, [])  AssignmentExpression(=, [VariableReference(int format, []), Expression(LegacyCameraDevice.detectSurfaceType(holder.surface), [])])    VariableReference(int format, [])    Expression(LegacyCameraDevice.detectSurfaceType(holder.surface), [])  MethodCall(LegacyCameraDevice.setSurfaceDimens(holder.surface, holder.width, holder.height), [VariableReference(LegacyCameraDevice, []), Expression(holder.surface, []), Expression(holder.width, []), Expression(holder.height, [])])    VariableReference(LegacyCameraDevice, [])    Expression(holder.surface, [])    Expression(holder.width, [])    Expression(holder.height, [])  MethodCall(LegacyCameraDevice.setNextTimestamp(holder.surface, captureHolder.second), [VariableReference(LegacyCameraDevice, []), Expression(holder.surface, []), Expression(captureHolder.second, [])])    VariableReference(LegacyCameraDevice, [])    Expression(holder.surface, [])    Expression(captureHolder.second, [])  MethodCall(LegacyCameraDevice.produceFrame(holder.surface, mPBufferPixels.array(), holder.width, holder.height, format), [VariableReference(LegacyCameraDevice, []), Expression(holder.surface, []), Expression(mPBufferPixels.array(), []), Expression(holder.width, []), Expression(holder.height, []), Expression(format, [])])    VariableReference(LegacyCameraDevice, [])    Expression(holder.surface, [])    Expression(mPBufferPixels.array(), [])    Expression(holder.width, [])    Expression(holder.height, [])    Expression(format, [])  MethodCall(Log.w(TAG, ""Surface abandoned, dropping frame. "", e), [VariableReference(Log, []), Expression(TAG, []), Expression(""Surface abandoned, []), Expression(dropping frame. "", []), Expression(e, [])])    VariableReference(Log, [])    Expression(TAG, [])    Expression(""Surface abandoned, [])    Expression(dropping frame. "", [])    Expression(e, [])  MethodCall(request.setOutputAbandoned(), [VariableReference(request, []), Expression(, [])])    VariableReference(request, [])    Expression(, [])  Statement(}, [])  Statement(}, [])  Statement(}, [])  MethodCall(targetCollector.previewProduced(), [VariableReference(targetCollector, []), Expression(, [])])    VariableReference(targetCollector, [])    Expression(, [])  Statement(if (doTiming) {, [])  Statement(endGlTiming(), [])  Statement(}, [])  Statement(}, [])",1,"/**
 * Draw the current buffer in the {@link SurfaceTexture} returned from
 * {@link #getSurfaceTexture()} into the set of target {@link Surface}s
 * in the next request from the given {@link CaptureCollector}, or drop
 * the frame if none is available.
 *
 * <p>
 * Any {@link Surface}s targeted must be a subset of the {@link Surface}s
 * set in the last {@link #configureSurfaces(java.util.Collection)} call.
 * </p>
 *
 * @param targetCollector the surfaces to draw to.
 */
","/**
 * Draw the current buffer in the {@link SurfaceTexture} returned from
 * {@link #getSurfaceTexture()} into the set of target {@link Surface}s
 * in the next request from the given {@link CaptureCollector}, or drop
 * the frame if none is available.
 *
 * <p>
 * Any {@link Surface}s targeted must be a subset of the {@link Surface}s
 * set in the last {@link #configureSurfaces(java.util.Collection)} call.
 * </p>
 *
 * @param targetCollector the surfaces to draw to.
 */
",0,,,0,,,0,"1,2","2,4,5",2,"3,4",0,"The list targetSurfaceIds is initialized and populated inside a try block in the late version, whereas it was directly initialized with the result of LegacyCameraDevice.getSurfaceIds(targetSurfaces) in the early version. Additionally, the request surface is marked as ""abandoned"" in a catch block when an exception is thrown inside the try block in the late version. These represent changes to control dependencies and other statements.","The control flow changes and other statements introduced do not seem to impact the return values or consistently lead to differing exception throws that alter the method's externally observable behaviors directly. Instead, these changes appear to be improvement/refactor within the method's operations and improve how exceptions are handled; therefore, no Compatibility Issues arise."
173,<android.widget.TabWidget: void setRightStripDrawable(Drawable)>,23,24,<android.widget.TabWidget: void setRightStripDrawable(Drawable)>,<android.widget.TabWidget: void setRightStripDrawable(Drawable)>,0,"MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(mRightStrip, []), Expression(drawable, [])]), Statement(requestLayout(), []), Statement(invalidate(), []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(mRightStrip, []), Expression(drawable, [])])    VariableReference(mRightStrip, [])    Expression(drawable, [])  Statement(requestLayout(), [])  Statement(invalidate(), [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(mRightStrip, []), Expression(drawable, [])]), Statement(requestLayout(), []), Statement(invalidate(), []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(mRightStrip, []), Expression(drawable, [])])    VariableReference(mRightStrip, [])    Expression(drawable, [])  Statement(requestLayout(), [])  Statement(invalidate(), [])  Statement(}, [])",0,"/**
 * Sets the drawable to use as the right part of the strip below the
 * tab indicators.
 * @param drawable the right strip drawable
 */
","/**
 * Sets the drawable to use as the right part of the strip below the tab
 * indicators.
 *
 * @param drawable the right strip drawable
 * @see #getRightStripDrawable()
 * @attr ref android.R.styleable#TabWidget_tabStripRight
 */
",1,,,0,,,0,0,0,0,0,0,The implementations in both the early and late versions are identical.,There is no compatibility issue as there is no change in the implementation of the method between the two versions.
174,<android.app.Dialog: void onActionModeStarted(ActionMode)>,23,24,<android.app.Dialog: void onActionModeStarted(ActionMode)>,<android.app.Dialog: void onActionModeStarted(ActionMode)>,0,"MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(mActionMode, []), Expression(mode, [])]), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(mActionMode, []), Expression(mode, [])])    VariableReference(mActionMode, [])    Expression(mode, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(mActionMode, []), Expression(mode, [])]), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(mActionMode, []), Expression(mode, [])])    VariableReference(mActionMode, [])    Expression(mode, [])  Statement(}, [])",0,"/**
 * {@inheritDoc}
 *
 * Note that if you override this method you should always call through
 * to the superclass implementation by calling super.onActionModeStarted(mode).
 */
","/**
 * {@inheritDoc}
 *
 * Note that if you override this method you should always call through
 * to the superclass implementation by calling super.onActionModeStarted(mode).
 */
",0,[@CallSuper],"[@Override, @CallSuper]",1,,,0,0,0,0,0,0,"There is no change in the method implementation, only the annotations have been changed (added @Override) which does not affect the methods behavior. Therefore, the code change type is 0.","Since there are no changes in the method implementation that could lead to different behavior, there is no Compatibility Issue. Thus, the CI type is 0."
175,<android.service.notification.ZenModeConfig.ZenRule: int hashCode()>,24,25,<android.service.notification.ZenModeConfig.ZenRule: int hashCode()>,<android.service.notification.ZenModeConfig.ZenRule: int hashCode()>,0,"MethodDeclaration(method_body, [Statement({, []), MethodCall(return Objects.hash(enabled, snoozing, name, zenMode, conditionId, condition, component, id, creationTime), [VariableReference(return Objects, []), Expression(enabled, []), Expression(snoozing, []), Expression(name, []), Expression(zenMode, []), Expression(conditionId, []), Expression(condition, []), Expression(component, []), Expression(id, []), Expression(creationTime, [])]), Statement(}, [])])  Statement({, [])  MethodCall(return Objects.hash(enabled, snoozing, name, zenMode, conditionId, condition, component, id, creationTime), [VariableReference(return Objects, []), Expression(enabled, []), Expression(snoozing, []), Expression(name, []), Expression(zenMode, []), Expression(conditionId, []), Expression(condition, []), Expression(component, []), Expression(id, []), Expression(creationTime, [])])    VariableReference(return Objects, [])    Expression(enabled, [])    Expression(snoozing, [])    Expression(name, [])    Expression(zenMode, [])    Expression(conditionId, [])    Expression(condition, [])    Expression(component, [])    Expression(id, [])    Expression(creationTime, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), MethodCall(return Objects.hash(enabled, snoozing, name, zenMode, conditionId, condition, component, id, creationTime, enabler), [VariableReference(return Objects, []), Expression(enabled, []), Expression(snoozing, []), Expression(name, []), Expression(zenMode, []), Expression(conditionId, []), Expression(condition, []), Expression(component, []), Expression(id, []), Expression(creationTime, []), Expression(enabler, [])]), Statement(}, [])])  Statement({, [])  MethodCall(return Objects.hash(enabled, snoozing, name, zenMode, conditionId, condition, component, id, creationTime, enabler), [VariableReference(return Objects, []), Expression(enabled, []), Expression(snoozing, []), Expression(name, []), Expression(zenMode, []), Expression(conditionId, []), Expression(condition, []), Expression(component, []), Expression(id, []), Expression(creationTime, []), Expression(enabler, [])])    VariableReference(return Objects, [])    Expression(enabled, [])    Expression(snoozing, [])    Expression(name, [])    Expression(zenMode, [])    Expression(conditionId, [])    Expression(condition, [])    Expression(component, [])    Expression(id, [])    Expression(creationTime, [])    Expression(enabler, [])  Statement(}, [])",1,,,0,[@Override],[@Override],0,,,0,"1,2","1,5",1,1,1,"A new parameter `enabler` has been added to the `Objects.hash` method call in the late implementation, which changes the computation of the hash code. So the code change type is 1.","The change in the parameters passed to `Objects.hash` will lead to a different hash code being returned in the late version, thus causing a potential CI. Therefore, the CI type is 1."
176,<android.view.DragEvent: ClipDescription getClipDescription()>,24,25,<android.view.DragEvent: ClipDescription getClipDescription()>,<android.view.DragEvent: ClipDescription getClipDescription()>,0,"MethodDeclaration(method_body, [Statement({, []), Statement(return mClipDescription, []), Statement(}, [])])  Statement({, [])  Statement(return mClipDescription, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(return mClipDescription, []), Statement(}, [])])  Statement({, [])  Statement(return mClipDescription, [])  Statement(}, [])",0,"/**
 * Returns the {@link android.content.ClipDescription} object contained in the
 * {@link android.content.ClipData} object sent to the system as part of the call to
 * {@link android.view.View#startDrag(ClipData,View.DragShadowBuilder,Object,int) startDrag()}.
 * The drag handler or listener for a View can use the metadata in this object to decide if the
 * View can accept the dragged View object's data.
 * <p>
 * This method returns valid data for all event actions.
 * @return The ClipDescription that was part of the ClipData sent to the system by startDrag().
 */
","/**
 * Returns the {@link android.content.ClipDescription} object contained in the
 * {@link android.content.ClipData} object sent to the system as part of the call to
 * {@link android.view.View#startDrag(ClipData,View.DragShadowBuilder,Object,int) startDrag()}.
 * The drag handler or listener for a View can use the metadata in this object to decide if the
 * View can accept the dragged View object's data.
 * <p>
 * This method returns valid data for all event actions except for {@link #ACTION_DRAG_ENDED}.
 * @return The ClipDescription that was part of the ClipData sent to the system by startDrag().
 */
",1,,,0,,,0,0,0,0,0,0,There are no changes in the method implementation. Both early and late versions of the code are identical.,"Since there are no changes in the method implementation, no Compatibility Issues exist."
177,<android.hardware.camera2.legacy.SurfaceTextureRenderer: void drawIntoSurfaces(CaptureCollector)>,25,26,<android.hardware.camera2.legacy.SurfaceTextureRenderer: void drawIntoSurfaces(CaptureCollector)>,<android.hardware.camera2.legacy.SurfaceTextureRenderer: void drawIntoSurfaces(CaptureCollector)>,0,"MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(if ((mSurfaces, []), Expression(, [])]), Statement(return, []), Statement(}, []), AssignmentExpression(=, [VariableReference(boolean doTiming, []), Expression(targetCollector.hasPendingPreviewCaptures(), [])]), Statement(checkGlError(""before updateTexImage""), []), Statement(if (doTiming) {, []), Statement(beginGlTiming(), []), Statement(}, []), MethodCall(mSurfaceTexture.updateTexImage(), [VariableReference(mSurfaceTexture, []), Expression(, [])]), AssignmentExpression(=, [VariableReference(long timestamp, []), Expression(mSurfaceTexture.getTimestamp(), [])]), AssignmentExpression(=, [VariableReference(Pair<RequestHolder, Long> captureHolder, []), Expression(targetCollector.previewCaptured(timestamp), [])]), Statement(// No preview request queued, drop frame., []), AssignmentExpression(=, [VariableReference(if (captureHolder, []), Expression(, [])]), Statement(if (DEBUG) {, []), MethodCall(Log.d(TAG, ""Dropping preview frame.""), [VariableReference(Log, []), Expression(TAG, []), Expression(""Dropping preview frame."", [])]), Statement(}, []), Statement(if (doTiming) {, []), Statement(endGlTiming(), []), Statement(}, []), Statement(return, []), Statement(}, []), AssignmentExpression(=, [VariableReference(RequestHolder request, []), Expression(captureHolder.first, [])]), AssignmentExpression(=, [VariableReference(Collection<Surface> targetSurfaces, []), Expression(request.getHolderTargets(), [])]), Statement(if (doTiming) {, []), Statement(addGlTimestamp(timestamp), []), Statement(}, []), AssignmentExpression(=, [VariableReference(List<Long> targetSurfaceIds, []), Expression(new ArrayList(), [])]), Statement(try {, []), AssignmentExpression(=, [VariableReference(targetSurfaceIds, []), Expression(LegacyCameraDevice.getSurfaceIds(targetSurfaces), [])]), MethodCall(Log.w(TAG, ""Surface abandoned, dropping frame. "", e), [VariableReference(Log, []), Expression(TAG, []), Expression(""Surface abandoned, []), Expression(dropping frame. "", []), Expression(e, [])]), MethodCall(request.setOutputAbandoned(), [VariableReference(request, []), Expression(, [])]), Statement(}, []), Statement(for (EGLSurfaceHolder holder : mSurfaces) {, []), MethodCall(if (LegacyCameraDevice.containsSurfaceId(holder.surface, targetSurfaceIds)), [VariableReference(if (LegacyCameraDevice, []), Expression(holder.surface, []), Expression(targetSurfaceIds), [])]), Statement(try {, []), MethodCall(LegacyCameraDevice.setSurfaceDimens(holder.surface, holder.width, holder.height), [VariableReference(LegacyCameraDevice, []), Expression(holder.surface, []), Expression(holder.width, []), Expression(holder.height, [])]), MethodCall(LegacyCameraDevice.setNextTimestamp(holder.surface, captureHolder.second), [VariableReference(LegacyCameraDevice, []), Expression(holder.surface, []), Expression(captureHolder.second, [])]), AssignmentExpression(=, [VariableReference(drawFrame(mSurfaceTexture, holder.width, holder.height, (mFacing, []), Expression(, [])]), MethodCall(Log.w(TAG, ""Surface abandoned, dropping frame. "", e), [VariableReference(Log, []), Expression(TAG, []), Expression(""Surface abandoned, []), Expression(dropping frame. "", []), Expression(e, [])]), MethodCall(request.setOutputAbandoned(), [VariableReference(request, []), Expression(, [])]), Statement(}, []), Statement(}, []), Statement(}, []), Statement(for (EGLSurfaceHolder holder : mConversionSurfaces) {, []), MethodCall(if (LegacyCameraDevice.containsSurfaceId(holder.surface, targetSurfaceIds)), [VariableReference(if (LegacyCameraDevice, []), Expression(holder.surface, []), Expression(targetSurfaceIds), [])]), Statement(// glReadPixels reads from the bottom of the buffer, so add an extra vertical flip, []), AssignmentExpression(=, [VariableReference(drawFrame(mSurfaceTexture, holder.width, holder.height, (mFacing, []), Expression(, [])]), MethodCall(mPBufferPixels.clear(), [VariableReference(mPBufferPixels, []), Expression(, [])]), Statement(0, /*y*/, []), Statement(0, holder.width, holder.height, GLES20.GL_RGBA, GLES20.GL_UNSIGNED_BYTE, mPBufferPixels), []), Statement(checkGlError(""glReadPixels""), []), Statement(try {, []), AssignmentExpression(=, [VariableReference(int format, []), Expression(LegacyCameraDevice.detectSurfaceType(holder.surface), [])]), MethodCall(LegacyCameraDevice.setSurfaceDimens(holder.surface, holder.width, holder.height), [VariableReference(LegacyCameraDevice, []), Expression(holder.surface, []), Expression(holder.width, []), Expression(holder.height, [])]), MethodCall(LegacyCameraDevice.setNextTimestamp(holder.surface, captureHolder.second), [VariableReference(LegacyCameraDevice, []), Expression(holder.surface, []), Expression(captureHolder.second, [])]), MethodCall(LegacyCameraDevice.produceFrame(holder.surface, mPBufferPixels.array(), holder.width, holder.height, format), [VariableReference(LegacyCameraDevice, []), Expression(holder.surface, []), Expression(mPBufferPixels.array(), []), Expression(holder.width, []), Expression(holder.height, []), Expression(format, [])]), MethodCall(Log.w(TAG, ""Surface abandoned, dropping frame. "", e), [VariableReference(Log, []), Expression(TAG, []), Expression(""Surface abandoned, []), Expression(dropping frame. "", []), Expression(e, [])]), MethodCall(request.setOutputAbandoned(), [VariableReference(request, []), Expression(, [])]), Statement(}, []), Statement(}, []), Statement(}, []), MethodCall(targetCollector.previewProduced(), [VariableReference(targetCollector, []), Expression(, [])]), Statement(if (doTiming) {, []), Statement(endGlTiming(), []), Statement(}, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(if ((mSurfaces, []), Expression(, [])])    VariableReference(if ((mSurfaces, [])    Expression(, [])  Statement(return, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(boolean doTiming, []), Expression(targetCollector.hasPendingPreviewCaptures(), [])])    VariableReference(boolean doTiming, [])    Expression(targetCollector.hasPendingPreviewCaptures(), [])  Statement(checkGlError(""before updateTexImage""), [])  Statement(if (doTiming) {, [])  Statement(beginGlTiming(), [])  Statement(}, [])  MethodCall(mSurfaceTexture.updateTexImage(), [VariableReference(mSurfaceTexture, []), Expression(, [])])    VariableReference(mSurfaceTexture, [])    Expression(, [])  AssignmentExpression(=, [VariableReference(long timestamp, []), Expression(mSurfaceTexture.getTimestamp(), [])])    VariableReference(long timestamp, [])    Expression(mSurfaceTexture.getTimestamp(), [])  AssignmentExpression(=, [VariableReference(Pair<RequestHolder, Long> captureHolder, []), Expression(targetCollector.previewCaptured(timestamp), [])])    VariableReference(Pair<RequestHolder, Long> captureHolder, [])    Expression(targetCollector.previewCaptured(timestamp), [])  Statement(// No preview request queued, drop frame., [])  AssignmentExpression(=, [VariableReference(if (captureHolder, []), Expression(, [])])    VariableReference(if (captureHolder, [])    Expression(, [])  Statement(if (DEBUG) {, [])  MethodCall(Log.d(TAG, ""Dropping preview frame.""), [VariableReference(Log, []), Expression(TAG, []), Expression(""Dropping preview frame."", [])])    VariableReference(Log, [])    Expression(TAG, [])    Expression(""Dropping preview frame."", [])  Statement(}, [])  Statement(if (doTiming) {, [])  Statement(endGlTiming(), [])  Statement(}, [])  Statement(return, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(RequestHolder request, []), Expression(captureHolder.first, [])])    VariableReference(RequestHolder request, [])    Expression(captureHolder.first, [])  AssignmentExpression(=, [VariableReference(Collection<Surface> targetSurfaces, []), Expression(request.getHolderTargets(), [])])    VariableReference(Collection<Surface> targetSurfaces, [])    Expression(request.getHolderTargets(), [])  Statement(if (doTiming) {, [])  Statement(addGlTimestamp(timestamp), [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(List<Long> targetSurfaceIds, []), Expression(new ArrayList(), [])])    VariableReference(List<Long> targetSurfaceIds, [])    Expression(new ArrayList(), [])  Statement(try {, [])  AssignmentExpression(=, [VariableReference(targetSurfaceIds, []), Expression(LegacyCameraDevice.getSurfaceIds(targetSurfaces), [])])    VariableReference(targetSurfaceIds, [])    Expression(LegacyCameraDevice.getSurfaceIds(targetSurfaces), [])  MethodCall(Log.w(TAG, ""Surface abandoned, dropping frame. "", e), [VariableReference(Log, []), Expression(TAG, []), Expression(""Surface abandoned, []), Expression(dropping frame. "", []), Expression(e, [])])    VariableReference(Log, [])    Expression(TAG, [])    Expression(""Surface abandoned, [])    Expression(dropping frame. "", [])    Expression(e, [])  MethodCall(request.setOutputAbandoned(), [VariableReference(request, []), Expression(, [])])    VariableReference(request, [])    Expression(, [])  Statement(}, [])  Statement(for (EGLSurfaceHolder holder : mSurfaces) {, [])  MethodCall(if (LegacyCameraDevice.containsSurfaceId(holder.surface, targetSurfaceIds)), [VariableReference(if (LegacyCameraDevice, []), Expression(holder.surface, []), Expression(targetSurfaceIds), [])])    VariableReference(if (LegacyCameraDevice, [])    Expression(holder.surface, [])    Expression(targetSurfaceIds), [])  Statement(try {, [])  MethodCall(LegacyCameraDevice.setSurfaceDimens(holder.surface, holder.width, holder.height), [VariableReference(LegacyCameraDevice, []), Expression(holder.surface, []), Expression(holder.width, []), Expression(holder.height, [])])    VariableReference(LegacyCameraDevice, [])    Expression(holder.surface, [])    Expression(holder.width, [])    Expression(holder.height, [])  MethodCall(LegacyCameraDevice.setNextTimestamp(holder.surface, captureHolder.second), [VariableReference(LegacyCameraDevice, []), Expression(holder.surface, []), Expression(captureHolder.second, [])])    VariableReference(LegacyCameraDevice, [])    Expression(holder.surface, [])    Expression(captureHolder.second, [])  AssignmentExpression(=, [VariableReference(drawFrame(mSurfaceTexture, holder.width, holder.height, (mFacing, []), Expression(, [])])    VariableReference(drawFrame(mSurfaceTexture, holder.width, holder.height, (mFacing, [])    Expression(, [])  MethodCall(Log.w(TAG, ""Surface abandoned, dropping frame. "", e), [VariableReference(Log, []), Expression(TAG, []), Expression(""Surface abandoned, []), Expression(dropping frame. "", []), Expression(e, [])])    VariableReference(Log, [])    Expression(TAG, [])    Expression(""Surface abandoned, [])    Expression(dropping frame. "", [])    Expression(e, [])  MethodCall(request.setOutputAbandoned(), [VariableReference(request, []), Expression(, [])])    VariableReference(request, [])    Expression(, [])  Statement(}, [])  Statement(}, [])  Statement(}, [])  Statement(for (EGLSurfaceHolder holder : mConversionSurfaces) {, [])  MethodCall(if (LegacyCameraDevice.containsSurfaceId(holder.surface, targetSurfaceIds)), [VariableReference(if (LegacyCameraDevice, []), Expression(holder.surface, []), Expression(targetSurfaceIds), [])])    VariableReference(if (LegacyCameraDevice, [])    Expression(holder.surface, [])    Expression(targetSurfaceIds), [])  Statement(// glReadPixels reads from the bottom of the buffer, so add an extra vertical flip, [])  AssignmentExpression(=, [VariableReference(drawFrame(mSurfaceTexture, holder.width, holder.height, (mFacing, []), Expression(, [])])    VariableReference(drawFrame(mSurfaceTexture, holder.width, holder.height, (mFacing, [])    Expression(, [])  MethodCall(mPBufferPixels.clear(), [VariableReference(mPBufferPixels, []), Expression(, [])])    VariableReference(mPBufferPixels, [])    Expression(, [])  Statement(0, /*y*/, [])  Statement(0, holder.width, holder.height, GLES20.GL_RGBA, GLES20.GL_UNSIGNED_BYTE, mPBufferPixels), [])  Statement(checkGlError(""glReadPixels""), [])  Statement(try {, [])  AssignmentExpression(=, [VariableReference(int format, []), Expression(LegacyCameraDevice.detectSurfaceType(holder.surface), [])])    VariableReference(int format, [])    Expression(LegacyCameraDevice.detectSurfaceType(holder.surface), [])  MethodCall(LegacyCameraDevice.setSurfaceDimens(holder.surface, holder.width, holder.height), [VariableReference(LegacyCameraDevice, []), Expression(holder.surface, []), Expression(holder.width, []), Expression(holder.height, [])])    VariableReference(LegacyCameraDevice, [])    Expression(holder.surface, [])    Expression(holder.width, [])    Expression(holder.height, [])  MethodCall(LegacyCameraDevice.setNextTimestamp(holder.surface, captureHolder.second), [VariableReference(LegacyCameraDevice, []), Expression(holder.surface, []), Expression(captureHolder.second, [])])    VariableReference(LegacyCameraDevice, [])    Expression(holder.surface, [])    Expression(captureHolder.second, [])  MethodCall(LegacyCameraDevice.produceFrame(holder.surface, mPBufferPixels.array(), holder.width, holder.height, format), [VariableReference(LegacyCameraDevice, []), Expression(holder.surface, []), Expression(mPBufferPixels.array(), []), Expression(holder.width, []), Expression(holder.height, []), Expression(format, [])])    VariableReference(LegacyCameraDevice, [])    Expression(holder.surface, [])    Expression(mPBufferPixels.array(), [])    Expression(holder.width, [])    Expression(holder.height, [])    Expression(format, [])  MethodCall(Log.w(TAG, ""Surface abandoned, dropping frame. "", e), [VariableReference(Log, []), Expression(TAG, []), Expression(""Surface abandoned, []), Expression(dropping frame. "", []), Expression(e, [])])    VariableReference(Log, [])    Expression(TAG, [])    Expression(""Surface abandoned, [])    Expression(dropping frame. "", [])    Expression(e, [])  MethodCall(request.setOutputAbandoned(), [VariableReference(request, []), Expression(, [])])    VariableReference(request, [])    Expression(, [])  Statement(}, [])  Statement(}, [])  Statement(}, [])  MethodCall(targetCollector.previewProduced(), [VariableReference(targetCollector, []), Expression(, [])])    VariableReference(targetCollector, [])    Expression(, [])  Statement(if (doTiming) {, [])  Statement(endGlTiming(), [])  Statement(}, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(if ((mSurfaces, []), Expression(, [])]), Statement(return, []), Statement(}, []), AssignmentExpression(=, [VariableReference(boolean doTiming, []), Expression(targetCollector.hasPendingPreviewCaptures(), [])]), Statement(checkGlError(""before updateTexImage""), []), Statement(if (doTiming) {, []), Statement(beginGlTiming(), []), Statement(}, []), MethodCall(mSurfaceTexture.updateTexImage(), [VariableReference(mSurfaceTexture, []), Expression(, [])]), AssignmentExpression(=, [VariableReference(long timestamp, []), Expression(mSurfaceTexture.getTimestamp(), [])]), AssignmentExpression(=, [VariableReference(Pair<RequestHolder, Long> captureHolder, []), Expression(targetCollector.previewCaptured(timestamp), [])]), Statement(// No preview request queued, drop frame., []), AssignmentExpression(=, [VariableReference(if (captureHolder, []), Expression(, [])]), Statement(if (DEBUG) {, []), MethodCall(Log.d(TAG, ""Dropping preview frame.""), [VariableReference(Log, []), Expression(TAG, []), Expression(""Dropping preview frame."", [])]), Statement(}, []), Statement(if (doTiming) {, []), Statement(endGlTiming(), []), Statement(}, []), Statement(return, []), Statement(}, []), AssignmentExpression(=, [VariableReference(RequestHolder request, []), Expression(captureHolder.first, [])]), AssignmentExpression(=, [VariableReference(Collection<Surface> targetSurfaces, []), Expression(request.getHolderTargets(), [])]), Statement(if (doTiming) {, []), Statement(addGlTimestamp(timestamp), []), Statement(}, []), AssignmentExpression(=, [VariableReference(List<Long> targetSurfaceIds, []), Expression(new ArrayList(), [])]), Statement(try {, []), AssignmentExpression(=, [VariableReference(targetSurfaceIds, []), Expression(LegacyCameraDevice.getSurfaceIds(targetSurfaces), [])]), MethodCall(Log.w(TAG, ""Surface abandoned, dropping frame. "", e), [VariableReference(Log, []), Expression(TAG, []), Expression(""Surface abandoned, []), Expression(dropping frame. "", []), Expression(e, [])]), MethodCall(request.setOutputAbandoned(), [VariableReference(request, []), Expression(, [])]), Statement(}, []), Statement(for (EGLSurfaceHolder holder : mSurfaces) {, []), MethodCall(if (LegacyCameraDevice.containsSurfaceId(holder.surface, targetSurfaceIds)), [VariableReference(if (LegacyCameraDevice, []), Expression(holder.surface, []), Expression(targetSurfaceIds), [])]), Statement(try {, []), MethodCall(LegacyCameraDevice.setSurfaceDimens(holder.surface, holder.width, holder.height), [VariableReference(LegacyCameraDevice, []), Expression(holder.surface, []), Expression(holder.width, []), Expression(holder.height, [])]), MethodCall(LegacyCameraDevice.setNextTimestamp(holder.surface, captureHolder.second), [VariableReference(LegacyCameraDevice, []), Expression(holder.surface, []), Expression(captureHolder.second, [])]), AssignmentExpression(=, [VariableReference(drawFrame(mSurfaceTexture, holder.width, holder.height, (mFacing, []), Expression(, [])]), MethodCall(Log.w(TAG, ""Surface abandoned, dropping frame. "", e), [VariableReference(Log, []), Expression(TAG, []), Expression(""Surface abandoned, []), Expression(dropping frame. "", []), Expression(e, [])]), MethodCall(request.setOutputAbandoned(), [VariableReference(request, []), Expression(, [])]), Statement(}, []), Statement(}, []), Statement(}, []), Statement(for (EGLSurfaceHolder holder : mConversionSurfaces) {, []), MethodCall(if (LegacyCameraDevice.containsSurfaceId(holder.surface, targetSurfaceIds)), [VariableReference(if (LegacyCameraDevice, []), Expression(holder.surface, []), Expression(targetSurfaceIds), [])]), Statement(// glReadPixels reads from the bottom of the buffer, so add an extra vertical flip, []), Statement(try {, []), AssignmentExpression(=, [VariableReference(drawFrame(mSurfaceTexture, holder.width, holder.height, (mFacing, []), Expression(, [])]), Statement(// Should never hit this., []), Statement(}, []), MethodCall(mPBufferPixels.clear(), [VariableReference(mPBufferPixels, []), Expression(, [])]), Statement(0, /*y*/, []), Statement(0, holder.width, holder.height, GLES20.GL_RGBA, GLES20.GL_UNSIGNED_BYTE, mPBufferPixels), []), Statement(checkGlError(""glReadPixels""), []), Statement(try {, []), AssignmentExpression(=, [VariableReference(int format, []), Expression(LegacyCameraDevice.detectSurfaceType(holder.surface), [])]), MethodCall(LegacyCameraDevice.setSurfaceDimens(holder.surface, holder.width, holder.height), [VariableReference(LegacyCameraDevice, []), Expression(holder.surface, []), Expression(holder.width, []), Expression(holder.height, [])]), MethodCall(LegacyCameraDevice.setNextTimestamp(holder.surface, captureHolder.second), [VariableReference(LegacyCameraDevice, []), Expression(holder.surface, []), Expression(captureHolder.second, [])]), MethodCall(LegacyCameraDevice.produceFrame(holder.surface, mPBufferPixels.array(), holder.width, holder.height, format), [VariableReference(LegacyCameraDevice, []), Expression(holder.surface, []), Expression(mPBufferPixels.array(), []), Expression(holder.width, []), Expression(holder.height, []), Expression(format, [])]), MethodCall(Log.w(TAG, ""Surface abandoned, dropping frame. "", e), [VariableReference(Log, []), Expression(TAG, []), Expression(""Surface abandoned, []), Expression(dropping frame. "", []), Expression(e, [])]), MethodCall(request.setOutputAbandoned(), [VariableReference(request, []), Expression(, [])]), Statement(}, []), Statement(}, []), Statement(}, []), MethodCall(targetCollector.previewProduced(), [VariableReference(targetCollector, []), Expression(, [])]), Statement(if (doTiming) {, []), Statement(endGlTiming(), []), Statement(}, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(if ((mSurfaces, []), Expression(, [])])    VariableReference(if ((mSurfaces, [])    Expression(, [])  Statement(return, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(boolean doTiming, []), Expression(targetCollector.hasPendingPreviewCaptures(), [])])    VariableReference(boolean doTiming, [])    Expression(targetCollector.hasPendingPreviewCaptures(), [])  Statement(checkGlError(""before updateTexImage""), [])  Statement(if (doTiming) {, [])  Statement(beginGlTiming(), [])  Statement(}, [])  MethodCall(mSurfaceTexture.updateTexImage(), [VariableReference(mSurfaceTexture, []), Expression(, [])])    VariableReference(mSurfaceTexture, [])    Expression(, [])  AssignmentExpression(=, [VariableReference(long timestamp, []), Expression(mSurfaceTexture.getTimestamp(), [])])    VariableReference(long timestamp, [])    Expression(mSurfaceTexture.getTimestamp(), [])  AssignmentExpression(=, [VariableReference(Pair<RequestHolder, Long> captureHolder, []), Expression(targetCollector.previewCaptured(timestamp), [])])    VariableReference(Pair<RequestHolder, Long> captureHolder, [])    Expression(targetCollector.previewCaptured(timestamp), [])  Statement(// No preview request queued, drop frame., [])  AssignmentExpression(=, [VariableReference(if (captureHolder, []), Expression(, [])])    VariableReference(if (captureHolder, [])    Expression(, [])  Statement(if (DEBUG) {, [])  MethodCall(Log.d(TAG, ""Dropping preview frame.""), [VariableReference(Log, []), Expression(TAG, []), Expression(""Dropping preview frame."", [])])    VariableReference(Log, [])    Expression(TAG, [])    Expression(""Dropping preview frame."", [])  Statement(}, [])  Statement(if (doTiming) {, [])  Statement(endGlTiming(), [])  Statement(}, [])  Statement(return, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(RequestHolder request, []), Expression(captureHolder.first, [])])    VariableReference(RequestHolder request, [])    Expression(captureHolder.first, [])  AssignmentExpression(=, [VariableReference(Collection<Surface> targetSurfaces, []), Expression(request.getHolderTargets(), [])])    VariableReference(Collection<Surface> targetSurfaces, [])    Expression(request.getHolderTargets(), [])  Statement(if (doTiming) {, [])  Statement(addGlTimestamp(timestamp), [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(List<Long> targetSurfaceIds, []), Expression(new ArrayList(), [])])    VariableReference(List<Long> targetSurfaceIds, [])    Expression(new ArrayList(), [])  Statement(try {, [])  AssignmentExpression(=, [VariableReference(targetSurfaceIds, []), Expression(LegacyCameraDevice.getSurfaceIds(targetSurfaces), [])])    VariableReference(targetSurfaceIds, [])    Expression(LegacyCameraDevice.getSurfaceIds(targetSurfaces), [])  MethodCall(Log.w(TAG, ""Surface abandoned, dropping frame. "", e), [VariableReference(Log, []), Expression(TAG, []), Expression(""Surface abandoned, []), Expression(dropping frame. "", []), Expression(e, [])])    VariableReference(Log, [])    Expression(TAG, [])    Expression(""Surface abandoned, [])    Expression(dropping frame. "", [])    Expression(e, [])  MethodCall(request.setOutputAbandoned(), [VariableReference(request, []), Expression(, [])])    VariableReference(request, [])    Expression(, [])  Statement(}, [])  Statement(for (EGLSurfaceHolder holder : mSurfaces) {, [])  MethodCall(if (LegacyCameraDevice.containsSurfaceId(holder.surface, targetSurfaceIds)), [VariableReference(if (LegacyCameraDevice, []), Expression(holder.surface, []), Expression(targetSurfaceIds), [])])    VariableReference(if (LegacyCameraDevice, [])    Expression(holder.surface, [])    Expression(targetSurfaceIds), [])  Statement(try {, [])  MethodCall(LegacyCameraDevice.setSurfaceDimens(holder.surface, holder.width, holder.height), [VariableReference(LegacyCameraDevice, []), Expression(holder.surface, []), Expression(holder.width, []), Expression(holder.height, [])])    VariableReference(LegacyCameraDevice, [])    Expression(holder.surface, [])    Expression(holder.width, [])    Expression(holder.height, [])  MethodCall(LegacyCameraDevice.setNextTimestamp(holder.surface, captureHolder.second), [VariableReference(LegacyCameraDevice, []), Expression(holder.surface, []), Expression(captureHolder.second, [])])    VariableReference(LegacyCameraDevice, [])    Expression(holder.surface, [])    Expression(captureHolder.second, [])  AssignmentExpression(=, [VariableReference(drawFrame(mSurfaceTexture, holder.width, holder.height, (mFacing, []), Expression(, [])])    VariableReference(drawFrame(mSurfaceTexture, holder.width, holder.height, (mFacing, [])    Expression(, [])  MethodCall(Log.w(TAG, ""Surface abandoned, dropping frame. "", e), [VariableReference(Log, []), Expression(TAG, []), Expression(""Surface abandoned, []), Expression(dropping frame. "", []), Expression(e, [])])    VariableReference(Log, [])    Expression(TAG, [])    Expression(""Surface abandoned, [])    Expression(dropping frame. "", [])    Expression(e, [])  MethodCall(request.setOutputAbandoned(), [VariableReference(request, []), Expression(, [])])    VariableReference(request, [])    Expression(, [])  Statement(}, [])  Statement(}, [])  Statement(}, [])  Statement(for (EGLSurfaceHolder holder : mConversionSurfaces) {, [])  MethodCall(if (LegacyCameraDevice.containsSurfaceId(holder.surface, targetSurfaceIds)), [VariableReference(if (LegacyCameraDevice, []), Expression(holder.surface, []), Expression(targetSurfaceIds), [])])    VariableReference(if (LegacyCameraDevice, [])    Expression(holder.surface, [])    Expression(targetSurfaceIds), [])  Statement(// glReadPixels reads from the bottom of the buffer, so add an extra vertical flip, [])  Statement(try {, [])  AssignmentExpression(=, [VariableReference(drawFrame(mSurfaceTexture, holder.width, holder.height, (mFacing, []), Expression(, [])])    VariableReference(drawFrame(mSurfaceTexture, holder.width, holder.height, (mFacing, [])    Expression(, [])  Statement(// Should never hit this., [])  Statement(}, [])  MethodCall(mPBufferPixels.clear(), [VariableReference(mPBufferPixels, []), Expression(, [])])    VariableReference(mPBufferPixels, [])    Expression(, [])  Statement(0, /*y*/, [])  Statement(0, holder.width, holder.height, GLES20.GL_RGBA, GLES20.GL_UNSIGNED_BYTE, mPBufferPixels), [])  Statement(checkGlError(""glReadPixels""), [])  Statement(try {, [])  AssignmentExpression(=, [VariableReference(int format, []), Expression(LegacyCameraDevice.detectSurfaceType(holder.surface), [])])    VariableReference(int format, [])    Expression(LegacyCameraDevice.detectSurfaceType(holder.surface), [])  MethodCall(LegacyCameraDevice.setSurfaceDimens(holder.surface, holder.width, holder.height), [VariableReference(LegacyCameraDevice, []), Expression(holder.surface, []), Expression(holder.width, []), Expression(holder.height, [])])    VariableReference(LegacyCameraDevice, [])    Expression(holder.surface, [])    Expression(holder.width, [])    Expression(holder.height, [])  MethodCall(LegacyCameraDevice.setNextTimestamp(holder.surface, captureHolder.second), [VariableReference(LegacyCameraDevice, []), Expression(holder.surface, []), Expression(captureHolder.second, [])])    VariableReference(LegacyCameraDevice, [])    Expression(holder.surface, [])    Expression(captureHolder.second, [])  MethodCall(LegacyCameraDevice.produceFrame(holder.surface, mPBufferPixels.array(), holder.width, holder.height, format), [VariableReference(LegacyCameraDevice, []), Expression(holder.surface, []), Expression(mPBufferPixels.array(), []), Expression(holder.width, []), Expression(holder.height, []), Expression(format, [])])    VariableReference(LegacyCameraDevice, [])    Expression(holder.surface, [])    Expression(mPBufferPixels.array(), [])    Expression(holder.width, [])    Expression(holder.height, [])    Expression(format, [])  MethodCall(Log.w(TAG, ""Surface abandoned, dropping frame. "", e), [VariableReference(Log, []), Expression(TAG, []), Expression(""Surface abandoned, []), Expression(dropping frame. "", []), Expression(e, [])])    VariableReference(Log, [])    Expression(TAG, [])    Expression(""Surface abandoned, [])    Expression(dropping frame. "", [])    Expression(e, [])  MethodCall(request.setOutputAbandoned(), [VariableReference(request, []), Expression(, [])])    VariableReference(request, [])    Expression(, [])  Statement(}, [])  Statement(}, [])  Statement(}, [])  MethodCall(targetCollector.previewProduced(), [VariableReference(targetCollector, []), Expression(, [])])    VariableReference(targetCollector, [])    Expression(, [])  Statement(if (doTiming) {, [])  Statement(endGlTiming(), [])  Statement(}, [])  Statement(}, [])",1,"/**
 * Draw the current buffer in the {@link SurfaceTexture} returned from
 * {@link #getSurfaceTexture()} into the set of target {@link Surface}s
 * in the next request from the given {@link CaptureCollector}, or drop
 * the frame if none is available.
 *
 * <p>
 * Any {@link Surface}s targeted must be a subset of the {@link Surface}s
 * set in the last {@link #configureSurfaces(java.util.Collection)} call.
 * </p>
 *
 * @param targetCollector the surfaces to draw to.
 */
","/**
 * Draw the current buffer in the {@link SurfaceTexture} returned from
 * {@link #getSurfaceTexture()} into the set of target {@link Surface}s
 * in the next request from the given {@link CaptureCollector}, or drop
 * the frame if none is available.
 *
 * <p>
 * Any {@link Surface}s targeted must be a subset of the {@link Surface}s
 * set in the last {@link #configureSurfaces(java.util.Collection)} call.
 * </p>
 *
 * @param targetCollector the surfaces to draw to.
 */
",0,,,0,,,0,"1,2",2,2,"2,3",2,"The late version removed the handling of exceptions related to surface dropping, which will now throw an exception and not log a warning. Also, there are changes related to control dependency, particularly around handling errors while processing surfaces.","The altered control dependencies and removed exception handling code will lead to different behavior, especially in how exceptions are thrown and handled. This can potentially cause the API to throw different exceptions, indicating CI type 2."
178,<android.net.Uri: Uri normalizeScheme()>,25,26,<android.net.Uri: Uri normalizeScheme()>,<android.net.Uri: Uri normalizeScheme()>,0,"MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(String scheme, []), Expression(getScheme(), [])]), Statement(// give up, []), AssignmentExpression(=, [VariableReference(if (scheme, []), Expression(, [])]), Statement(return this, []), AssignmentExpression(=, [VariableReference(String lowerScheme, []), Expression(scheme.toLowerCase(Locale.ROOT), [])]), Statement(// no change, []), MethodCall(if (scheme.equals(lowerScheme)), [VariableReference(if (scheme, []), Expression(lowerScheme), [])]), Statement(return this, []), MethodCall(return buildUpon().scheme(lowerScheme).build(), [VariableReference(return buildUpon(), []), Expression(lowerScheme).build(, [])]), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(String scheme, []), Expression(getScheme(), [])])    VariableReference(String scheme, [])    Expression(getScheme(), [])  Statement(// give up, [])  AssignmentExpression(=, [VariableReference(if (scheme, []), Expression(, [])])    VariableReference(if (scheme, [])    Expression(, [])  Statement(return this, [])  AssignmentExpression(=, [VariableReference(String lowerScheme, []), Expression(scheme.toLowerCase(Locale.ROOT), [])])    VariableReference(String lowerScheme, [])    Expression(scheme.toLowerCase(Locale.ROOT), [])  Statement(// no change, [])  MethodCall(if (scheme.equals(lowerScheme)), [VariableReference(if (scheme, []), Expression(lowerScheme), [])])    VariableReference(if (scheme, [])    Expression(lowerScheme), [])  Statement(return this, [])  MethodCall(return buildUpon().scheme(lowerScheme).build(), [VariableReference(return buildUpon(), []), Expression(lowerScheme).build(, [])])    VariableReference(return buildUpon(), [])    Expression(lowerScheme).build(, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(String scheme, []), Expression(getScheme(), [])]), Statement(// give up, []), AssignmentExpression(=, [VariableReference(if (scheme, []), Expression(, [])]), Statement(return this, []), AssignmentExpression(=, [VariableReference(String lowerScheme, []), Expression(scheme.toLowerCase(Locale.ROOT), [])]), Statement(// no change, []), MethodCall(if (scheme.equals(lowerScheme)), [VariableReference(if (scheme, []), Expression(lowerScheme), [])]), Statement(return this, []), MethodCall(return buildUpon().scheme(lowerScheme).build(), [VariableReference(return buildUpon(), []), Expression(lowerScheme).build(, [])]), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(String scheme, []), Expression(getScheme(), [])])    VariableReference(String scheme, [])    Expression(getScheme(), [])  Statement(// give up, [])  AssignmentExpression(=, [VariableReference(if (scheme, []), Expression(, [])])    VariableReference(if (scheme, [])    Expression(, [])  Statement(return this, [])  AssignmentExpression(=, [VariableReference(String lowerScheme, []), Expression(scheme.toLowerCase(Locale.ROOT), [])])    VariableReference(String lowerScheme, [])    Expression(scheme.toLowerCase(Locale.ROOT), [])  Statement(// no change, [])  MethodCall(if (scheme.equals(lowerScheme)), [VariableReference(if (scheme, []), Expression(lowerScheme), [])])    VariableReference(if (scheme, [])    Expression(lowerScheme), [])  Statement(return this, [])  MethodCall(return buildUpon().scheme(lowerScheme).build(), [VariableReference(return buildUpon(), []), Expression(lowerScheme).build(, [])])    VariableReference(return buildUpon(), [])    Expression(lowerScheme).build(, [])  Statement(}, [])",0,"/**
 * Return an equivalent URI with a lowercase scheme component.
 * This aligns the Uri with Android best practices for
 * intent filtering.
 *
 * <p>For example, ""HTTP://www.android.com"" becomes
 * ""http://www.android.com""
 *
 * <p>All URIs received from outside Android (such as user input,
 * or external sources like Bluetooth, NFC, or the Internet) should
 * be normalized before they are used to create an Intent.
 *
 * <p class=""note"">This method does <em>not</em> validate bad URI's,
 * or 'fix' poorly formatted URI's - so do not use it for input validation.
 * A Uri will always be returned, even if the Uri is badly formatted to
 * begin with and a scheme component cannot be found.
 *
 * @return normalized Uri (never null)
 * @see {@link android.content.Intent#setData}
 * @see {@link android.content.Intent#setDataAndNormalize}
 */
","/**
 * Return an equivalent URI with a lowercase scheme component.
 * This aligns the Uri with Android best practices for
 * intent filtering.
 *
 * <p>For example, ""HTTP://www.android.com"" becomes
 * ""http://www.android.com""
 *
 * <p>All URIs received from outside Android (such as user input,
 * or external sources like Bluetooth, NFC, or the Internet) should
 * be normalized before they are used to create an Intent.
 *
 * <p class=""note"">This method does <em>not</em> validate bad URI's,
 * or 'fix' poorly formatted URI's - so do not use it for input validation.
 * A Uri will always be returned, even if the Uri is badly formatted to
 * begin with and a scheme component cannot be found.
 *
 * @return normalized Uri (never null)
 * @see android.content.Intent#setData
 * @see android.content.Intent#setDataAndNormalize
 */
",1,,,0,,,0,0,0,0,0,0,"There is no change in the implementation, comments, or annotations between the early and late versions so the code change type is 0.","Since there are no changes between the early and late versions, there are no compatibility issues, so the CI type is 0."
179,<android.widget.GridView: void setRemoteViewsAdapter(Intent)>,25,26,<android.widget.GridView: void setRemoteViewsAdapter(Intent)>,<android.widget.GridView: void setRemoteViewsAdapter(Intent)>,0,"MethodDeclaration(method_body, [Statement({, []), MethodCall(super.setRemoteViewsAdapter(intent), [VariableReference(super, []), Expression(intent, [])]), Statement(}, [])])  Statement({, [])  MethodCall(super.setRemoteViewsAdapter(intent), [VariableReference(super, []), Expression(intent, [])])    VariableReference(super, [])    Expression(intent, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), MethodCall(super.setRemoteViewsAdapter(intent), [VariableReference(super, []), Expression(intent, [])]), Statement(}, [])])  Statement({, [])  MethodCall(super.setRemoteViewsAdapter(intent), [VariableReference(super, []), Expression(intent, [])])    VariableReference(super, [])    Expression(intent, [])  Statement(}, [])",0,"/**
 * Sets up this AbsListView to use a remote views adapter which connects to a RemoteViewsService
 * through the specified intent.
 * @param intent the intent used to identify the RemoteViewsService for the adapter to connect to.
 */
","/**
 * Sets up this AbsListView to use a remote views adapter which connects to a RemoteViewsService
 * through the specified intent.
 * @param intent the intent used to identify the RemoteViewsService for the adapter to connect to.
 */
",0,[@android.view.RemotableViewMethod],[@android.view.RemotableViewMethod(asyncImpl = "setRemoteViewsAdapterAsync")],1,,,0,0,0,0,5,0,"The annotation has been modified to include an additional parameter (asyncImpl = ""setRemoteViewsAdapterAsync""). Therefore, the code change type is 5.","The annotation change does not affect the behaviour of the method in terms of return values or exception handling in this context, so no compatibility issue exists. The CI type is 0."
180,<android.os.MemoryFile.MemoryInputStream: int available()>,26,27,<android.os.MemoryFile.MemoryInputStream: int available()>,<android.os.MemoryFile.MemoryInputStream: int available()>,0,"MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(if (mOffset >, []), Expression(mLength) {, [])]), Statement(return 0, []), Statement(}, []), Statement(return mLength - mOffset, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(if (mOffset >, []), Expression(mLength) {, [])])    VariableReference(if (mOffset >, [])    Expression(mLength) {, [])  Statement(return 0, [])  Statement(}, [])  Statement(return mLength - mOffset, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(if (mOffset >, []), Expression(mSharedMemory.getSize()) {, [])]), Statement(return 0, []), Statement(}, []), MethodCall(return mSharedMemory.getSize(), [VariableReference(return mSharedMemory, []), Expression(, [])]), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(if (mOffset >, []), Expression(mSharedMemory.getSize()) {, [])])    VariableReference(if (mOffset >, [])    Expression(mSharedMemory.getSize()) {, [])  Statement(return 0, [])  Statement(}, [])  MethodCall(return mSharedMemory.getSize(), [VariableReference(return mSharedMemory, []), Expression(, [])])    VariableReference(return mSharedMemory, [])    Expression(, [])  Statement(}, [])",1,,,0,[@Override],[@Override],0,,,0,"1,2","1,3,4",1,1,1,"The return statement changed from `return mLength - mOffset` to `return mSharedMemory.getSize() - mOffset`, so the code change type is 1.","The change in the return value calculation from `mLength` to `mSharedMemory.getSize()` can lead to different values being returned by the API, so the CI type is 1."
182,<android.view.textclassifier.TextClassification: String getText()>,26,27,<android.view.textclassifier.TextClassification: String getText()>,<android.view.textclassifier.TextClassification: String getText()>,0,"MethodDeclaration(method_body, [Statement({, []), Statement(return mText, []), Statement(}, [])])  Statement({, [])  Statement(return mText, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(return mText, []), Statement(}, [])])  Statement({, [])  Statement(return mText, [])  Statement(}, [])",0,"/**
 * Gets the classified text.
 */
","/**
 * Gets the classified text.
 */
",0,[@NonNull],[@Nullable],1,,,0,0,0,0,0,0,There is no change in the method implementation between the early version and the late version.,"Since there is no change in the method implementation, no Compatibility Issue exists."
183,<android.os.MemoryFile.MemoryInputStream: int available()>,26,27,<android.os.MemoryFile.MemoryInputStream: int available()>,<android.os.MemoryFile.MemoryInputStream: int available()>,0,"MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(if (mOffset >, []), Expression(mLength) {, [])]), Statement(return 0, []), Statement(}, []), Statement(return mLength - mOffset, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(if (mOffset >, []), Expression(mLength) {, [])])    VariableReference(if (mOffset >, [])    Expression(mLength) {, [])  Statement(return 0, [])  Statement(}, [])  Statement(return mLength - mOffset, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(if (mOffset >, []), Expression(mSharedMemory.getSize()) {, [])]), Statement(return 0, []), Statement(}, []), MethodCall(return mSharedMemory.getSize(), [VariableReference(return mSharedMemory, []), Expression(, [])]), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(if (mOffset >, []), Expression(mSharedMemory.getSize()) {, [])])    VariableReference(if (mOffset >, [])    Expression(mSharedMemory.getSize()) {, [])  Statement(return 0, [])  Statement(}, [])  MethodCall(return mSharedMemory.getSize(), [VariableReference(return mSharedMemory, []), Expression(, [])])    VariableReference(return mSharedMemory, [])    Expression(, [])  Statement(}, [])",1,,,0,[@Override],[@Override],0,,,0,"1,2","1,3,4",1,1,1,"The return statement has changed from `return mLength - mOffset` to `return mSharedMemory.getSize() - mOffset`, so the code change type is 1.","The change of return statement can potentially lead to different return values because the method now depends on `mSharedMemory.getSize()` instead of `mLength`. Thus, the CI type is 1."
185,<android.view.textclassifier.TextClassification: String getText()>,27,28,<android.view.textclassifier.TextClassification: String getText()>,<android.view.textclassifier.TextClassification: String getText()>,0,"MethodDeclaration(method_body, [Statement({, []), Statement(return mText, []), Statement(}, [])])  Statement({, [])  Statement(return mText, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(return mText, []), Statement(}, [])])  Statement({, [])  Statement(return mText, [])  Statement(}, [])",0,"/**
 * Gets the classified text.
 */
","/**
 * Gets the classified text.
 */
",0,[@NonNull],[@Nullable],1,,,0,0,0,0,4,1,"The annotation has changed from @NonNull to @Nullable, so the change type is 4.",The change in the annotation to @Nullable indicates that the method can potentially return null in the late version. This change can lead to different return values and CI type is 1.
186,"<android.view.textclassifier.TextSelection.Builder: Builder setEntityType(String,float)>",27,28,"<android.view.textclassifier.TextSelection.Builder: Builder setEntityType(String,float)>","<android.view.textclassifier.TextSelection.Builder: Builder setEntityType(String,float)>",0,"MethodDeclaration(method_body, [Statement({, []), MethodCall(mEntityConfidence.setEntityType(type, confidenceScore), [VariableReference(mEntityConfidence, []), Expression(type, []), Expression(confidenceScore, [])]), Statement(return this, []), Statement(}, [])])  Statement({, [])  MethodCall(mEntityConfidence.setEntityType(type, confidenceScore), [VariableReference(mEntityConfidence, []), Expression(type, []), Expression(confidenceScore, [])])    VariableReference(mEntityConfidence, [])    Expression(type, [])    Expression(confidenceScore, [])  Statement(return this, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), MethodCall(Preconditions.checkNotNull(type), [VariableReference(Preconditions, []), Expression(type, [])]), MethodCall(mEntityConfidence.put(type, confidenceScore), [VariableReference(mEntityConfidence, []), Expression(type, []), Expression(confidenceScore, [])]), Statement(return this, []), Statement(}, [])])  Statement({, [])  MethodCall(Preconditions.checkNotNull(type), [VariableReference(Preconditions, []), Expression(type, [])])    VariableReference(Preconditions, [])    Expression(type, [])  MethodCall(mEntityConfidence.put(type, confidenceScore), [VariableReference(mEntityConfidence, []), Expression(type, []), Expression(confidenceScore, [])])    VariableReference(mEntityConfidence, [])    Expression(type, [])    Expression(confidenceScore, [])  Statement(return this, [])  Statement(}, [])",1,"/**
 * Sets an entity type for the classified text and assigns a confidence score.
 *
 * @param confidenceScore a value from 0 (low confidence) to 1 (high confidence).
 * 0 implies the entity does not exist for the classified text.
 * Values greater than 1 are clamped to 1.
 */
","/**
 * Sets an entity type for the classified text and assigns a confidence score.
 *
 * @param confidenceScore a value from 0 (low confidence) to 1 (high confidence).
 * 0 implies the entity does not exist for the classified text.
 * Values greater than 1 are clamped to 1.
 */
",0,,[@NonNull],1,,,0,"1,2","1,4,5",1,"2,3,4",2,"In the late version, a new exception handling statement (Preconditions.checkNotNull(type)) has been added, and the method call has been changed from mEntityConfidence.setEntityType(type, confidenceScore) to mEntityConfidence.put(type, confidenceScore). Therefore, the code change type includes 2, 3, and 4.","The addition of Preconditions.checkNotNull(type) introduces potential different exception handling behavior when 'type' is null. Hence, the CI type is 2."
187,"<android.bluetooth.BluetoothDevice: BluetoothGatt connectGatt(Context,boolean,BluetoothGattCallback)>",27,28,"<android.bluetooth.BluetoothDevice: BluetoothGatt connectGatt(Context,boolean,BluetoothGattCallback)>","<android.bluetooth.BluetoothDevice: BluetoothGatt connectGatt(Context,boolean,BluetoothGattCallback)>",0,"MethodDeclaration(method_body, [Statement({, []), Statement(return (connectGatt(context, autoConnect, callback, TRANSPORT_AUTO)), []), Statement(}, [])])  Statement({, [])  Statement(return (connectGatt(context, autoConnect, callback, TRANSPORT_AUTO)), [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(return (connectGatt(context, autoConnect, callback, TRANSPORT_AUTO)), []), Statement(}, [])])  Statement({, [])  Statement(return (connectGatt(context, autoConnect, callback, TRANSPORT_AUTO)), [])  Statement(}, [])",0,"/**
 * Connect to GATT Server hosted by this device. Caller acts as GATT client.
 * The callback is used to deliver results to Caller, such as connection status as well
 * as any further GATT client operations.
 * The method returns a BluetoothGatt instance. You can use BluetoothGatt to conduct
 * GATT client operations.
 * @param callback GATT callback handler that will receive asynchronous callbacks.
 * @param autoConnect Whether to directly connect to the remote device (false)
 * or to automatically connect as soon as the remote
 * device becomes available (true).
 * @throws IllegalArgumentException if callback is null
 */
","/**
 * Connect to GATT Server hosted by this device. Caller acts as GATT client.
 * The callback is used to deliver results to Caller, such as connection status as well
 * as any further GATT client operations.
 * The method returns a BluetoothGatt instance. You can use BluetoothGatt to conduct
 * GATT client operations.
 *
 * @param callback GATT callback handler that will receive asynchronous callbacks.
 * @param autoConnect Whether to directly connect to the remote device (false) or to
 * automatically connect as soon as the remote device becomes available (true).
 * @throws IllegalArgumentException if callback is null
 */
",1,,,0,,,0,0,0,0,0,0,There is no change in the method implementation or annotations between the two versions. The only minor difference is a cosmetic change in the comment format.,"No Compatibility Issue exists since there is no actual change in the API's implementation, annotations, or logic. The API will behave the same in both versions."
188,<android.inputmethodservice.IInputMethodWrapper: void bindInput(InputBinding)>,27,28,<android.inputmethodservice.IInputMethodWrapper: void bindInput(InputBinding)>,<android.inputmethodservice.IInputMethodWrapper: void bindInput(InputBinding)>,0,"MethodDeclaration(method_body, [Statement({, []), Statement(// This IInputContext is guaranteed to implement all the methods., []), AssignmentExpression(=, [VariableReference(final int missingMethodFlags, []), Expression(0, [])]), AssignmentExpression(=, [VariableReference(InputConnection ic, []), Expression(new InputConnectionWrapper(mTarget, IInputContext.Stub.asInterface(binding.getConnectionToken()), missingMethodFlags), [])]), AssignmentExpression(=, [VariableReference(InputBinding nu, []), Expression(new InputBinding(ic, binding), [])]), MethodCall(mCaller.executeOrSendMessage(mCaller.obtainMessageO(DO_SET_INPUT_CONTEXT, nu)), [VariableReference(mCaller, []), Expression(mCaller.obtainMessageO(DO_SET_INPUT_CONTEXT, []), Expression(nu), [])]), Statement(}, [])])  Statement({, [])  Statement(// This IInputContext is guaranteed to implement all the methods., [])  AssignmentExpression(=, [VariableReference(final int missingMethodFlags, []), Expression(0, [])])    VariableReference(final int missingMethodFlags, [])    Expression(0, [])  AssignmentExpression(=, [VariableReference(InputConnection ic, []), Expression(new InputConnectionWrapper(mTarget, IInputContext.Stub.asInterface(binding.getConnectionToken()), missingMethodFlags), [])])    VariableReference(InputConnection ic, [])    Expression(new InputConnectionWrapper(mTarget, IInputContext.Stub.asInterface(binding.getConnectionToken()), missingMethodFlags), [])  AssignmentExpression(=, [VariableReference(InputBinding nu, []), Expression(new InputBinding(ic, binding), [])])    VariableReference(InputBinding nu, [])    Expression(new InputBinding(ic, binding), [])  MethodCall(mCaller.executeOrSendMessage(mCaller.obtainMessageO(DO_SET_INPUT_CONTEXT, nu)), [VariableReference(mCaller, []), Expression(mCaller.obtainMessageO(DO_SET_INPUT_CONTEXT, []), Expression(nu), [])])    VariableReference(mCaller, [])    Expression(mCaller.obtainMessageO(DO_SET_INPUT_CONTEXT, [])    Expression(nu), [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(if (mIsUnbindIssued !, []), Expression(null) {, [])]), MethodCall(Log.e(TAG, ""bindInput must be paired with unbindInput.""), [VariableReference(Log, []), Expression(TAG, []), Expression(""bindInput must be paired with unbindInput."", [])]), Statement(}, []), AssignmentExpression(=, [VariableReference(mIsUnbindIssued, []), Expression(new AtomicBoolean(), [])]), Statement(// This IInputContext is guaranteed to implement all the methods., []), AssignmentExpression(=, [VariableReference(final int missingMethodFlags, []), Expression(0, [])]), AssignmentExpression(=, [VariableReference(InputConnection ic, []), Expression(new InputConnectionWrapper(mTarget, IInputContext.Stub.asInterface(binding.getConnectionToken()), missingMethodFlags, mIsUnbindIssued), [])]), AssignmentExpression(=, [VariableReference(InputBinding nu, []), Expression(new InputBinding(ic, binding), [])]), MethodCall(mCaller.executeOrSendMessage(mCaller.obtainMessageO(DO_SET_INPUT_CONTEXT, nu)), [VariableReference(mCaller, []), Expression(mCaller.obtainMessageO(DO_SET_INPUT_CONTEXT, []), Expression(nu), [])]), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(if (mIsUnbindIssued !, []), Expression(null) {, [])])    VariableReference(if (mIsUnbindIssued !, [])    Expression(null) {, [])  MethodCall(Log.e(TAG, ""bindInput must be paired with unbindInput.""), [VariableReference(Log, []), Expression(TAG, []), Expression(""bindInput must be paired with unbindInput."", [])])    VariableReference(Log, [])    Expression(TAG, [])    Expression(""bindInput must be paired with unbindInput."", [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(mIsUnbindIssued, []), Expression(new AtomicBoolean(), [])])    VariableReference(mIsUnbindIssued, [])    Expression(new AtomicBoolean(), [])  Statement(// This IInputContext is guaranteed to implement all the methods., [])  AssignmentExpression(=, [VariableReference(final int missingMethodFlags, []), Expression(0, [])])    VariableReference(final int missingMethodFlags, [])    Expression(0, [])  AssignmentExpression(=, [VariableReference(InputConnection ic, []), Expression(new InputConnectionWrapper(mTarget, IInputContext.Stub.asInterface(binding.getConnectionToken()), missingMethodFlags, mIsUnbindIssued), [])])    VariableReference(InputConnection ic, [])    Expression(new InputConnectionWrapper(mTarget, IInputContext.Stub.asInterface(binding.getConnectionToken()), missingMethodFlags, mIsUnbindIssued), [])  AssignmentExpression(=, [VariableReference(InputBinding nu, []), Expression(new InputBinding(ic, binding), [])])    VariableReference(InputBinding nu, [])    Expression(new InputBinding(ic, binding), [])  MethodCall(mCaller.executeOrSendMessage(mCaller.obtainMessageO(DO_SET_INPUT_CONTEXT, nu)), [VariableReference(mCaller, []), Expression(mCaller.obtainMessageO(DO_SET_INPUT_CONTEXT, []), Expression(nu), [])])    VariableReference(mCaller, [])    Expression(mCaller.obtainMessageO(DO_SET_INPUT_CONTEXT, [])    Expression(nu), [])  Statement(}, [])",1,,,0,[@Override],"[@BinderThread, @Override]",1,,,0,"1,2","3,4,5",0,"2,3,4",2,There are several changes between the early and late implementations: ,- The construction of the `InputConnectionWrapper` now has an additional parameter `mIsUnbindIssued`.
189,<android.os.MemoryFile.MemoryInputStream: int available()>,28,29,<android.os.MemoryFile.MemoryInputStream: int available()>,<android.os.MemoryFile.MemoryInputStream: int available()>,0,"MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(if (mOffset >, []), Expression(mLength) {, [])]), Statement(return 0, []), Statement(}, []), Statement(return mLength - mOffset, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(if (mOffset >, []), Expression(mLength) {, [])])    VariableReference(if (mOffset >, [])    Expression(mLength) {, [])  Statement(return 0, [])  Statement(}, [])  Statement(return mLength - mOffset, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(if (mOffset >, []), Expression(mSharedMemory.getSize()) {, [])]), Statement(return 0, []), Statement(}, []), MethodCall(return mSharedMemory.getSize(), [VariableReference(return mSharedMemory, []), Expression(, [])]), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(if (mOffset >, []), Expression(mSharedMemory.getSize()) {, [])])    VariableReference(if (mOffset >, [])    Expression(mSharedMemory.getSize()) {, [])  Statement(return 0, [])  Statement(}, [])  MethodCall(return mSharedMemory.getSize(), [VariableReference(return mSharedMemory, []), Expression(, [])])    VariableReference(return mSharedMemory, [])    Expression(, [])  Statement(}, [])",1,,,0,[@Override],[@Override],0,,,0,"1,2","1,3",1,"1,5",1,"The first `return` statement has changed from `return mLength - mOffset` to `return mSharedMemory.getSize()`. Additionally, the invocation of the dependent API `mSharedMemory.getSize()` has been introduced, which also changes the control dependency. Therefore, the code change type is 1,5.","The change will potentially cause the method to return a different value, thus leading to a compatibility issue. Therefore, the CI type is 1."
191,<android.view.textclassifier.TextClassification: String getText()>,28,29,<android.view.textclassifier.TextClassification: String getText()>,<android.view.textclassifier.TextClassification: String getText()>,0,"MethodDeclaration(method_body, [Statement({, []), Statement(return mText, []), Statement(}, [])])  Statement({, [])  Statement(return mText, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(return mText, []), Statement(}, [])])  Statement({, [])  Statement(return mText, [])  Statement(}, [])",0,"/**
 * Gets the classified text.
 */
","/**
 * Gets the classified text.
 */
",0,[@NonNull],[@Nullable],1,,,0,0,0,0,4,1,"The annotation has changed from `@NonNull` to `@Nullable`, indicating that this API can now potentially return `null`, classified as code change type 4.","Since the API's return type can now potentially include additional return values (`null`), it may lead to different behaviors, hence the CI type is 1."
192,"<android.view.textclassifier.TextSelection.Builder: Builder setEntityType(String,float)>",28,29,"<android.view.textclassifier.TextSelection.Builder: Builder setEntityType(String,float)>","<android.view.textclassifier.TextSelection.Builder: Builder setEntityType(String,float)>",0,"MethodDeclaration(method_body, [Statement({, []), MethodCall(mEntityConfidence.setEntityType(type, confidenceScore), [VariableReference(mEntityConfidence, []), Expression(type, []), Expression(confidenceScore, [])]), Statement(return this, []), Statement(}, [])])  Statement({, [])  MethodCall(mEntityConfidence.setEntityType(type, confidenceScore), [VariableReference(mEntityConfidence, []), Expression(type, []), Expression(confidenceScore, [])])    VariableReference(mEntityConfidence, [])    Expression(type, [])    Expression(confidenceScore, [])  Statement(return this, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), MethodCall(Preconditions.checkNotNull(type), [VariableReference(Preconditions, []), Expression(type, [])]), MethodCall(mEntityConfidence.put(type, confidenceScore), [VariableReference(mEntityConfidence, []), Expression(type, []), Expression(confidenceScore, [])]), Statement(return this, []), Statement(}, [])])  Statement({, [])  MethodCall(Preconditions.checkNotNull(type), [VariableReference(Preconditions, []), Expression(type, [])])    VariableReference(Preconditions, [])    Expression(type, [])  MethodCall(mEntityConfidence.put(type, confidenceScore), [VariableReference(mEntityConfidence, []), Expression(type, []), Expression(confidenceScore, [])])    VariableReference(mEntityConfidence, [])    Expression(type, [])    Expression(confidenceScore, [])  Statement(return this, [])  Statement(}, [])",1,"/**
 * Sets an entity type for the classified text and assigns a confidence score.
 *
 * @param confidenceScore a value from 0 (low confidence) to 1 (high confidence).
 * 0 implies the entity does not exist for the classified text.
 * Values greater than 1 are clamped to 1.
 */
","/**
 * Sets an entity type for the classified text and assigns a confidence score.
 *
 * @param confidenceScore a value from 0 (low confidence) to 1 (high confidence).
 * 0 implies the entity does not exist for the classified text.
 * Values greater than 1 are clamped to 1.
 */
",0,,[@NonNull],1,,,0,"1,2","1,4,5",1,"2,3,4",2,"The code introduces a new method call `Preconditions.checkNotNull(type)`, an existing method call is changed from `mEntityConfidence.setEntityType(type, confidenceScore)` to `mEntityConfidence.put(type, confidenceScore)`, and `mEntityConfidence` had a change in its dependent method from `setEntityType` to `put`. Therefore, the code change types are 2, 3, and 4.","The new method call `Preconditions.checkNotNull(type)` can lead to `NullPointerException` being thrown when `type` is null, which means the exception handling can behave differently, resulting in a CI type of 2."
193,"<android.bluetooth.BluetoothDevice: BluetoothGatt connectGatt(Context,boolean,BluetoothGattCallback)>",28,29,"<android.bluetooth.BluetoothDevice: BluetoothGatt connectGatt(Context,boolean,BluetoothGattCallback)>","<android.bluetooth.BluetoothDevice: BluetoothGatt connectGatt(Context,boolean,BluetoothGattCallback)>",0,"MethodDeclaration(method_body, [Statement({, []), Statement(return (connectGatt(context, autoConnect, callback, TRANSPORT_AUTO)), []), Statement(}, [])])  Statement({, [])  Statement(return (connectGatt(context, autoConnect, callback, TRANSPORT_AUTO)), [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(return (connectGatt(context, autoConnect, callback, TRANSPORT_AUTO)), []), Statement(}, [])])  Statement({, [])  Statement(return (connectGatt(context, autoConnect, callback, TRANSPORT_AUTO)), [])  Statement(}, [])",0,"/**
 * Connect to GATT Server hosted by this device. Caller acts as GATT client.
 * The callback is used to deliver results to Caller, such as connection status as well
 * as any further GATT client operations.
 * The method returns a BluetoothGatt instance. You can use BluetoothGatt to conduct
 * GATT client operations.
 * @param callback GATT callback handler that will receive asynchronous callbacks.
 * @param autoConnect Whether to directly connect to the remote device (false)
 * or to automatically connect as soon as the remote
 * device becomes available (true).
 * @throws IllegalArgumentException if callback is null
 */
","/**
 * Connect to GATT Server hosted by this device. Caller acts as GATT client.
 * The callback is used to deliver results to Caller, such as connection status as well
 * as any further GATT client operations.
 * The method returns a BluetoothGatt instance. You can use BluetoothGatt to conduct
 * GATT client operations.
 *
 * @param callback GATT callback handler that will receive asynchronous callbacks.
 * @param autoConnect Whether to directly connect to the remote device (false) or to
 * automatically connect as soon as the remote device becomes available (true).
 * @throws IllegalArgumentException if callback is null
 */
",1,,,0,,,0,0,0,0,0,0,"There are no changes in the method body, comments, or annotations between the early and late versions.",No Compatibility Issue exists as there are no code changes.
194,<android.inputmethodservice.IInputMethodWrapper: void bindInput(InputBinding)>,28,29,<android.inputmethodservice.IInputMethodWrapper: void bindInput(InputBinding)>,<android.inputmethodservice.IInputMethodWrapper: void bindInput(InputBinding)>,0,"MethodDeclaration(method_body, [Statement({, []), Statement(// This IInputContext is guaranteed to implement all the methods., []), AssignmentExpression(=, [VariableReference(final int missingMethodFlags, []), Expression(0, [])]), AssignmentExpression(=, [VariableReference(InputConnection ic, []), Expression(new InputConnectionWrapper(mTarget, IInputContext.Stub.asInterface(binding.getConnectionToken()), missingMethodFlags), [])]), AssignmentExpression(=, [VariableReference(InputBinding nu, []), Expression(new InputBinding(ic, binding), [])]), MethodCall(mCaller.executeOrSendMessage(mCaller.obtainMessageO(DO_SET_INPUT_CONTEXT, nu)), [VariableReference(mCaller, []), Expression(mCaller.obtainMessageO(DO_SET_INPUT_CONTEXT, []), Expression(nu), [])]), Statement(}, [])])  Statement({, [])  Statement(// This IInputContext is guaranteed to implement all the methods., [])  AssignmentExpression(=, [VariableReference(final int missingMethodFlags, []), Expression(0, [])])    VariableReference(final int missingMethodFlags, [])    Expression(0, [])  AssignmentExpression(=, [VariableReference(InputConnection ic, []), Expression(new InputConnectionWrapper(mTarget, IInputContext.Stub.asInterface(binding.getConnectionToken()), missingMethodFlags), [])])    VariableReference(InputConnection ic, [])    Expression(new InputConnectionWrapper(mTarget, IInputContext.Stub.asInterface(binding.getConnectionToken()), missingMethodFlags), [])  AssignmentExpression(=, [VariableReference(InputBinding nu, []), Expression(new InputBinding(ic, binding), [])])    VariableReference(InputBinding nu, [])    Expression(new InputBinding(ic, binding), [])  MethodCall(mCaller.executeOrSendMessage(mCaller.obtainMessageO(DO_SET_INPUT_CONTEXT, nu)), [VariableReference(mCaller, []), Expression(mCaller.obtainMessageO(DO_SET_INPUT_CONTEXT, []), Expression(nu), [])])    VariableReference(mCaller, [])    Expression(mCaller.obtainMessageO(DO_SET_INPUT_CONTEXT, [])    Expression(nu), [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(if (mIsUnbindIssued !, []), Expression(null) {, [])]), MethodCall(Log.e(TAG, ""bindInput must be paired with unbindInput.""), [VariableReference(Log, []), Expression(TAG, []), Expression(""bindInput must be paired with unbindInput."", [])]), Statement(}, []), AssignmentExpression(=, [VariableReference(mIsUnbindIssued, []), Expression(new AtomicBoolean(), [])]), Statement(// This IInputContext is guaranteed to implement all the methods., []), AssignmentExpression(=, [VariableReference(final int missingMethodFlags, []), Expression(0, [])]), AssignmentExpression(=, [VariableReference(InputConnection ic, []), Expression(new InputConnectionWrapper(mTarget, IInputContext.Stub.asInterface(binding.getConnectionToken()), missingMethodFlags, mIsUnbindIssued), [])]), AssignmentExpression(=, [VariableReference(InputBinding nu, []), Expression(new InputBinding(ic, binding), [])]), MethodCall(mCaller.executeOrSendMessage(mCaller.obtainMessageO(DO_SET_INPUT_CONTEXT, nu)), [VariableReference(mCaller, []), Expression(mCaller.obtainMessageO(DO_SET_INPUT_CONTEXT, []), Expression(nu), [])]), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(if (mIsUnbindIssued !, []), Expression(null) {, [])])    VariableReference(if (mIsUnbindIssued !, [])    Expression(null) {, [])  MethodCall(Log.e(TAG, ""bindInput must be paired with unbindInput.""), [VariableReference(Log, []), Expression(TAG, []), Expression(""bindInput must be paired with unbindInput."", [])])    VariableReference(Log, [])    Expression(TAG, [])    Expression(""bindInput must be paired with unbindInput."", [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(mIsUnbindIssued, []), Expression(new AtomicBoolean(), [])])    VariableReference(mIsUnbindIssued, [])    Expression(new AtomicBoolean(), [])  Statement(// This IInputContext is guaranteed to implement all the methods., [])  AssignmentExpression(=, [VariableReference(final int missingMethodFlags, []), Expression(0, [])])    VariableReference(final int missingMethodFlags, [])    Expression(0, [])  AssignmentExpression(=, [VariableReference(InputConnection ic, []), Expression(new InputConnectionWrapper(mTarget, IInputContext.Stub.asInterface(binding.getConnectionToken()), missingMethodFlags, mIsUnbindIssued), [])])    VariableReference(InputConnection ic, [])    Expression(new InputConnectionWrapper(mTarget, IInputContext.Stub.asInterface(binding.getConnectionToken()), missingMethodFlags, mIsUnbindIssued), [])  AssignmentExpression(=, [VariableReference(InputBinding nu, []), Expression(new InputBinding(ic, binding), [])])    VariableReference(InputBinding nu, [])    Expression(new InputBinding(ic, binding), [])  MethodCall(mCaller.executeOrSendMessage(mCaller.obtainMessageO(DO_SET_INPUT_CONTEXT, nu)), [VariableReference(mCaller, []), Expression(mCaller.obtainMessageO(DO_SET_INPUT_CONTEXT, []), Expression(nu), [])])    VariableReference(mCaller, [])    Expression(mCaller.obtainMessageO(DO_SET_INPUT_CONTEXT, [])    Expression(nu), [])  Statement(}, [])",1,,,0,[@Override],"[@BinderThread, @Override]",1,,,0,"1,2","3,4,5",0,"2,3",2,"There are significant changes including the introduction of a new if statement with logging and an additional parameter (`mIsUnbindIssued`) to the `InputConnectionWrapper`. These changes encompass exception handling statement changes (throwing a log error), and control dependency changes as neue control statement(s) are added/modified.","The introduction of log errors and additional control dependencies (if statements) potentially throw exceptions differently. Hence, the CI type is 2."
195,<android.widget.CheckedTextView: Mode getCheckMarkTintMode()>,28,29,<android.widget.CheckedTextView: Mode getCheckMarkTintMode()>,<android.widget.CheckedTextView: Mode getCheckMarkTintMode()>,0,"MethodDeclaration(method_body, [Statement({, []), Statement(return mCheckMarkTintMode, []), Statement(}, [])])  Statement({, [])  Statement(return mCheckMarkTintMode, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(return mCheckMarkBlendMode !, []), Expression(null ? BlendMode.blendModeToPorterDuffMode(mCheckMarkBlendMode) : null, [])]), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(return mCheckMarkBlendMode !, []), Expression(null ? BlendMode.blendModeToPorterDuffMode(mCheckMarkBlendMode) : null, [])])    VariableReference(return mCheckMarkBlendMode !, [])    Expression(null ? BlendMode.blendModeToPorterDuffMode(mCheckMarkBlendMode) : null, [])  Statement(}, [])",1,"/**
 * Returns the blending mode used to apply the tint to the check mark
 * drawable, if specified.
 *
 * @return the blending mode used to apply the tint to the check mark
 * drawable
 * @attr ref android.R.styleable#CheckedTextView_checkMarkTintMode
 * @see #setCheckMarkTintMode(PorterDuff.Mode)
 */
","/**
 * Returns the blending mode used to apply the tint to the check mark
 * drawable, if specified.
 *
 * @return the blending mode used to apply the tint to the check mark
 * drawable
 * @attr ref android.R.styleable#CheckedTextView_checkMarkTintMode
 * @see #setCheckMarkTintMode(PorterDuff.Mode)
 */
",0,[@Nullable],"[@InspectableProperty, @Nullable]",1,,,0,"1,2","1,4",1,"1,4,5",1,"The return statement in the method body changed from `return mCheckMarkTintMode` to an assignment involving a ternary expression. Additionally, an extra logic transformation related to `BlendMode.blendModeToPorterDuffMode` is added, and the dependent variable `mCheckMarkBlendMode` is used in late version. Lastly, new annotations `@InspectableProperty` was added. Thus, the change types are 1,4,5.","Due to the changes in the return statement and the addition of a ternary expression involving `BlendMode.blendModeToPorterDuffMode`, the method could potentially return different values in the two versions. Therefore, the CI type is 1."
196,<android.accessibilityservice.AccessibilityService.SoftKeyboardController: boolean setShowMode(int)>,28,29,<android.accessibilityservice.AccessibilityService.SoftKeyboardController: boolean setShowMode(int)>,<android.accessibilityservice.AccessibilityService.SoftKeyboardController: boolean setShowMode(int)>,0,"MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(final IAccessibilityServiceConnection connection, []), Expression(AccessibilityInteractionClient.getInstance().getConnection(mService.mConnectionId), [])]), AssignmentExpression(=, [VariableReference(if (connection !, []), Expression(null) {, [])]), Statement(try {, []), MethodCall(return connection.setSoftKeyboardShowMode(showMode), [VariableReference(return connection, []), Expression(showMode, [])]), Statement(} catch (RemoteException re) {, []), MethodCall(Log.w(LOG_TAG, ""Failed to set soft keyboard behavior"", re), [VariableReference(Log, []), Expression(LOG_TAG, []), Expression(""Failed to set soft keyboard behavior"", []), Expression(re, [])]), MethodCall(re.rethrowFromSystemServer(), [VariableReference(re, []), Expression(, [])]), Statement(}, []), Statement(}, []), Statement(return false, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(final IAccessibilityServiceConnection connection, []), Expression(AccessibilityInteractionClient.getInstance().getConnection(mService.mConnectionId), [])])    VariableReference(final IAccessibilityServiceConnection connection, [])    Expression(AccessibilityInteractionClient.getInstance().getConnection(mService.mConnectionId), [])  AssignmentExpression(=, [VariableReference(if (connection !, []), Expression(null) {, [])])    VariableReference(if (connection !, [])    Expression(null) {, [])  Statement(try {, [])  MethodCall(return connection.setSoftKeyboardShowMode(showMode), [VariableReference(return connection, []), Expression(showMode, [])])    VariableReference(return connection, [])    Expression(showMode, [])  Statement(} catch (RemoteException re) {, [])  MethodCall(Log.w(LOG_TAG, ""Failed to set soft keyboard behavior"", re), [VariableReference(Log, []), Expression(LOG_TAG, []), Expression(""Failed to set soft keyboard behavior"", []), Expression(re, [])])    VariableReference(Log, [])    Expression(LOG_TAG, [])    Expression(""Failed to set soft keyboard behavior"", [])    Expression(re, [])  MethodCall(re.rethrowFromSystemServer(), [VariableReference(re, []), Expression(, [])])    VariableReference(re, [])    Expression(, [])  Statement(}, [])  Statement(}, [])  Statement(return false, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(final IAccessibilityServiceConnection connection, []), Expression(AccessibilityInteractionClient.getInstance().getConnection(mService.mConnectionId), [])]), AssignmentExpression(=, [VariableReference(if (connection !, []), Expression(null) {, [])]), Statement(try {, []), MethodCall(return connection.setSoftKeyboardShowMode(showMode), [VariableReference(return connection, []), Expression(showMode, [])]), Statement(} catch (RemoteException re) {, []), MethodCall(Log.w(LOG_TAG, ""Failed to set soft keyboard behavior"", re), [VariableReference(Log, []), Expression(LOG_TAG, []), Expression(""Failed to set soft keyboard behavior"", []), Expression(re, [])]), MethodCall(re.rethrowFromSystemServer(), [VariableReference(re, []), Expression(, [])]), Statement(}, []), Statement(}, []), Statement(return false, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(final IAccessibilityServiceConnection connection, []), Expression(AccessibilityInteractionClient.getInstance().getConnection(mService.mConnectionId), [])])    VariableReference(final IAccessibilityServiceConnection connection, [])    Expression(AccessibilityInteractionClient.getInstance().getConnection(mService.mConnectionId), [])  AssignmentExpression(=, [VariableReference(if (connection !, []), Expression(null) {, [])])    VariableReference(if (connection !, [])    Expression(null) {, [])  Statement(try {, [])  MethodCall(return connection.setSoftKeyboardShowMode(showMode), [VariableReference(return connection, []), Expression(showMode, [])])    VariableReference(return connection, [])    Expression(showMode, [])  Statement(} catch (RemoteException re) {, [])  MethodCall(Log.w(LOG_TAG, ""Failed to set soft keyboard behavior"", re), [VariableReference(Log, []), Expression(LOG_TAG, []), Expression(""Failed to set soft keyboard behavior"", []), Expression(re, [])])    VariableReference(Log, [])    Expression(LOG_TAG, [])    Expression(""Failed to set soft keyboard behavior"", [])    Expression(re, [])  MethodCall(re.rethrowFromSystemServer(), [VariableReference(re, []), Expression(, [])])    VariableReference(re, [])    Expression(, [])  Statement(}, [])  Statement(}, [])  Statement(return false, [])  Statement(}, [])",0,"/**
 * Sets the soft keyboard show mode. The default show mode is
 * {@code SHOW_MODE_AUTO}, where the soft keyboard is shown when a text input field is
 * focused. An AccessibilityService can also request the show mode
 * {@code SHOW_MODE_HIDDEN}, where the soft keyboard is never shown. The
 * The lastto this method will be honored, regardless of any previous calls (including those
 * made by other AccessibilityServices).
 * <p>
 * <strong>Note:</strong> If the service is not yet connected (e.g.
 * {@link AccessibilityService#onServiceConnected()} has not yet been called) or the
 * service has been disconnected, this method will have no effect and return {@code false}.
 *
 * @param showMode the new show mode for the soft keyboard
 * @return {@code true} on success
 */
","/**
 * Sets the soft keyboard show mode.
 * <p>
 * <strong>Note:</strong> If the service is not yet connected (e.g.
 * {@link AccessibilityService#onServiceConnected()} has not yet been called) or the
 * service has been disconnected, this method will have no effect and return {@code false}.
 *
 * @param showMode the new show mode for the soft keyboard
 * @return {@code true} on success
 *
 * @see AccessibilityService#SHOW_MODE_AUTO
 * @see AccessibilityService#SHOW_MODE_HIDDEN
 * @see AccessibilityService#SHOW_MODE_IGNORE_HARD_KEYBOARD
 */
",1,,,0,,,0,0,0,0,0,0,"There is no significant change in the implementation between the two versions, including the AST node representations and the functionality.","Since there are no code changes, there are no compatibility issues."
197,"<android.view.textclassifier.TextSelection.Builder: Builder setEntityType(String,float)>",29,30,"<android.view.textclassifier.TextSelection.Builder: Builder setEntityType(String,float)>","<android.view.textclassifier.TextSelection.Builder: Builder setEntityType(String,float)>",0,"MethodDeclaration(method_body, [Statement({, []), MethodCall(Preconditions.checkNotNull(type), [VariableReference(Preconditions, []), Expression(type, [])]), MethodCall(mEntityConfidence.put(type, confidenceScore), [VariableReference(mEntityConfidence, []), Expression(type, []), Expression(confidenceScore, [])]), Statement(return this, []), Statement(}, [])])  Statement({, [])  MethodCall(Preconditions.checkNotNull(type), [VariableReference(Preconditions, []), Expression(type, [])])    VariableReference(Preconditions, [])    Expression(type, [])  MethodCall(mEntityConfidence.put(type, confidenceScore), [VariableReference(mEntityConfidence, []), Expression(type, []), Expression(confidenceScore, [])])    VariableReference(mEntityConfidence, [])    Expression(type, [])    Expression(confidenceScore, [])  Statement(return this, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), MethodCall(Objects.requireNonNull(type), [VariableReference(Objects, []), Expression(type, [])]), MethodCall(mEntityConfidence.put(type, confidenceScore), [VariableReference(mEntityConfidence, []), Expression(type, []), Expression(confidenceScore, [])]), Statement(return this, []), Statement(}, [])])  Statement({, [])  MethodCall(Objects.requireNonNull(type), [VariableReference(Objects, []), Expression(type, [])])    VariableReference(Objects, [])    Expression(type, [])  MethodCall(mEntityConfidence.put(type, confidenceScore), [VariableReference(mEntityConfidence, []), Expression(type, []), Expression(confidenceScore, [])])    VariableReference(mEntityConfidence, [])    Expression(type, [])    Expression(confidenceScore, [])  Statement(return this, [])  Statement(}, [])",1,"/**
 * Sets an entity type for the classified text and assigns a confidence score.
 *
 * @param confidenceScore a value from 0 (low confidence) to 1 (high confidence).
 * 0 implies the entity does not exist for the classified text.
 * Values greater than 1 are clamped to 1.
 */
","/**
 * Sets an entity type for the classified text and assigns a confidence score.
 *
 * @param confidenceScore a value from 0 (low confidence) to 1 (high confidence).
 * 0 implies the entity does not exist for the classified text.
 * Values greater than 1 are clamped to 1.
 */
",0,[@NonNull],[@NonNull],0,,,0,"1,2",5,0,4,0,The method now calls `Objects.requireNonNull(type)` instead of `Preconditions.checkNotNull(type)` to ensure the type argument is not null. This change falls under other statement changes (4).,"Switching from `Preconditions.checkNotNull` to `Objects.requireNonNull` does not alter the behavior concerning return values or exceptions significantly; hence, no Compatibility Issue exists."
198,"<android.net.ConnectivityManager.NetworkCallback: void onLinkPropertiesChanged(Network,LinkProperties)>",29,30,"<android.net.ConnectivityManager.NetworkCallback: void onLinkPropertiesChanged(Network,LinkProperties)>","<android.net.ConnectivityManager.NetworkCallback: void onLinkPropertiesChanged(Network,LinkProperties)>",0,"MethodDeclaration(method_body, [Statement({, []), Statement(}, [])])  Statement({, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(}, [])])  Statement({, [])  Statement(}, [])",0,"/**
 * Called when the network the framework connected to for this request
 * changes {@link LinkProperties}.
 *
 * @param network The {@link Network} whose link properties have changed.
 * @param linkProperties The new {@link LinkProperties} for this network.
 */
","/**
 * Called when the network corresponding to this request changes {@link LinkProperties}.
 *
 * <p>Starting with {@link android.os.Build.VERSION_CODES#O} this method is guaranteed
 * to be called immediately after {@link #onAvailable}.
 *
 * <p>Do NOT call {@link #getNetworkCapabilities(Network)} or other synchronous
 * ConnectivityManager methods in this callback as this is prone to race conditions :
 * calling these methods while in a callback may return an outdated or even a null object.
 *
 * @param network The {@link Network} whose link properties have changed.
 * @param linkProperties The new {@link LinkProperties} for this network.
 */
",1,,,0,,,0,0,0,0,0,0,"There are no code changes between the early and late versions based on the given AST nodes. Only the comments have been updated, but these do not affect the code's behavior.","Since there are no changes in the implementation, there is no potential for compatibility issues. Thus, the CI type is 0."
199,<android.hardware.radio.RadioManager.ModuleProperties: String toString()>,29,30,<android.hardware.radio.RadioManager.ModuleProperties: String toString()>,<android.hardware.radio.RadioManager.ModuleProperties: String toString()>,0,"MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(return ""ModuleProperties [mId, []), Expression("" + mId + "", mServiceName, [])]), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(return ""ModuleProperties [mId, []), Expression("" + mId + "", mServiceName, [])])    VariableReference(return ""ModuleProperties [mId, [])    Expression("" + mId + "", mServiceName, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(return ""ModuleProperties [mId, []), Expression("" + mId + "", mServiceName, [])]), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(return ""ModuleProperties [mId, []), Expression("" + mId + "", mServiceName, [])])    VariableReference(return ""ModuleProperties [mId, [])    Expression("" + mId + "", mServiceName, [])  Statement(}, [])",0,,,0,[@Override],"[@NonNull, @Override]",1,,,0,0,0,0,0,0,"There is no change in the implementation of the method between the early and late versions. The only difference is an addition of annotations which do not affect the logic or behavior of the method itself. Therefore, the code change type is 0.","Since there are no changes in the method implementation that could lead to different return values or exceptions, no Compatibility Issue exists. The addition of annotations does not impact the behavior of the method. Thus, the CI type is 0."
200,"<android.app.admin.DeviceAdminReceiver: void onUserSwitched(Context,Intent,UserHandle)>",30,31,"<android.app.admin.DeviceAdminReceiver: void onUserSwitched(Context,Intent,UserHandle)>","<android.app.admin.DeviceAdminReceiver: void onUserSwitched(Context,Intent,UserHandle)>",0,"MethodDeclaration(method_body, [Statement({, []), Statement(}, [])])  Statement({, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(if (LOCAL_LOGV) {, []), MethodCall(Log.v(TAG, getClass().getName() + "".onUserSwitched() on user "" + context.getUserId()), [VariableReference(Log, []), Expression(TAG, []), Expression(getClass().getName() + "".onUserSwitched() on user "" + context.getUserId(), [])]), Statement(}, []), Statement(}, [])])  Statement({, [])  Statement(if (LOCAL_LOGV) {, [])  MethodCall(Log.v(TAG, getClass().getName() + "".onUserSwitched() on user "" + context.getUserId()), [VariableReference(Log, []), Expression(TAG, []), Expression(getClass().getName() + "".onUserSwitched() on user "" + context.getUserId(), [])])    VariableReference(Log, [])    Expression(TAG, [])    Expression(getClass().getName() + "".onUserSwitched() on user "" + context.getUserId(), [])  Statement(}, [])  Statement(}, [])",1,"/**
 * Called when a user or profile is switched to.
 *
 * <p>This callback is only applicable to device owners.
 *
 * @param context The running context as per {@link #onReceive}.
 * @param intent The received intent as per {@link #onReceive}.
 * @param switchedUser The {@link UserHandle} of the user that has just been switched to.
 */
","/**
 * Called when a user or profile is switched to.
 *
 * <p>This callback is only applicable to device owners.
 *
 * @param context The running context as per {@link #onReceive}.
 * @param intent The received intent as per {@link #onReceive}.
 * @param switchedUser The {@link UserHandle} of the user that has just been switched to.
 */
",0,,,0,,,0,"1,2","3,4",0,"3,4",0,"A new control dependency statement `if (LOCAL_LOGV)` and a logging statement `Log.v(TAG, getClass().getName() + "".onUserSwitched() on user "" + context.getUserId())` have been added, so the code change types are 3 and 4.","The new control dependency and logging statement do not affect the return values or exception handling; therefore, no compatibility issues exist, and the CI type is 0."
201,<android.bluetooth.BluetoothGattServer: List<BluetoothGattService> getServices()>,30,31,<android.bluetooth.BluetoothGattServer: List<BluetoothGattService> getServices()>,<android.bluetooth.BluetoothGattServer: List<BluetoothGattService> getServices()>,0,"MethodDeclaration(method_body, [Statement({, []), Statement(return mServices, []), Statement(}, [])])  Statement({, [])  Statement(return mServices, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(return mServices, []), Statement(}, [])])  Statement({, [])  Statement(return mServices, [])  Statement(}, [])",0,"/**
 * Returns a list of GATT services offered by this device.
 *
 * <p>An application must call {@link #addService} to add a serice to the
 * list of services offered by this device.
 *
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH} permission.
 *
 * @return List of services. Returns an empty list if no services have been added yet.
 */
","/**
 * Returns a list of GATT services offered by this device.
 *
 * <p>An application must call {@link #addService} to add a serice to the
 * list of services offered by this device.
 *
 * @return List of services. Returns an empty list if no services have been added yet.
 */
",1,,"[@RequiresLegacyBluetoothPermission, @RequiresNoPermission]",1,,,0,0,0,0,0,0,There is no change in the implementation code between the early and late versions.,"Since there are no changes in the implementation code, there are no potential different return values or exception handling behaviours. Therefore, no Compatibility Issue exists."
202,<android.app.Application: void dispatchActivityPostStarted(Activity)>,30,31,<android.app.Application: void dispatchActivityPostStarted(Activity)>,<android.app.Application: void dispatchActivityPostStarted(Activity)>,0,"MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(Object[] callbacks, []), Expression(collectActivityLifecycleCallbacks(), [])]), AssignmentExpression(=, [VariableReference(if (callbacks !, []), Expression(null) {, [])]), AssignmentExpression(=, [VariableReference(for (int i, []), Expression(0, [])]), Statement(i < callbacks.length, []), Statement(i++) {, []), MethodCall(((ActivityLifecycleCallbacks) callbacks[i]).onActivityPostStarted(activity), [VariableReference(((ActivityLifecycleCallbacks) callbacks[i]), []), Expression(activity, [])]), Statement(}, []), Statement(}, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(Object[] callbacks, []), Expression(collectActivityLifecycleCallbacks(), [])])    VariableReference(Object[] callbacks, [])    Expression(collectActivityLifecycleCallbacks(), [])  AssignmentExpression(=, [VariableReference(if (callbacks !, []), Expression(null) {, [])])    VariableReference(if (callbacks !, [])    Expression(null) {, [])  AssignmentExpression(=, [VariableReference(for (int i, []), Expression(0, [])])    VariableReference(for (int i, [])    Expression(0, [])  Statement(i < callbacks.length, [])  Statement(i++) {, [])  MethodCall(((ActivityLifecycleCallbacks) callbacks[i]).onActivityPostStarted(activity), [VariableReference(((ActivityLifecycleCallbacks) callbacks[i]), []), Expression(activity, [])])    VariableReference(((ActivityLifecycleCallbacks) callbacks[i]), [])    Expression(activity, [])  Statement(}, [])  Statement(}, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(Object[] callbacks, []), Expression(collectActivityLifecycleCallbacks(), [])]), AssignmentExpression(=, [VariableReference(if (callbacks !, []), Expression(null) {, [])]), AssignmentExpression(=, [VariableReference(for (int i, []), Expression(0, [])]), Statement(i < callbacks.length, []), Statement(i++) {, []), MethodCall(((ActivityLifecycleCallbacks) callbacks[i]).onActivityPostStarted(activity), [VariableReference(((ActivityLifecycleCallbacks) callbacks[i]), []), Expression(activity, [])]), Statement(}, []), Statement(}, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(Object[] callbacks, []), Expression(collectActivityLifecycleCallbacks(), [])])    VariableReference(Object[] callbacks, [])    Expression(collectActivityLifecycleCallbacks(), [])  AssignmentExpression(=, [VariableReference(if (callbacks !, []), Expression(null) {, [])])    VariableReference(if (callbacks !, [])    Expression(null) {, [])  AssignmentExpression(=, [VariableReference(for (int i, []), Expression(0, [])])    VariableReference(for (int i, [])    Expression(0, [])  Statement(i < callbacks.length, [])  Statement(i++) {, [])  MethodCall(((ActivityLifecycleCallbacks) callbacks[i]).onActivityPostStarted(activity), [VariableReference(((ActivityLifecycleCallbacks) callbacks[i]), []), Expression(activity, [])])    VariableReference(((ActivityLifecycleCallbacks) callbacks[i]), [])    Expression(activity, [])  Statement(}, [])  Statement(}, [])  Statement(}, [])",0,,,0,[@UnsupportedAppUsage],"[@UnsupportedAppUsage(maxTargetSdk = Build.VERSION_CODES.R, trackingBug = 170729553)]",1,,,0,0,0,0,4,0,"The only change is the modification of the `@UnsupportedAppUsage` annotation, where a `maxTargetSdk` attribute and `trackingBug` attribute are added. This does not affect the method logic, so the code change type is 4.","The change in the `@UnsupportedAppUsage` annotation does not affect the behavior of the API. It does not lead to different return values or exception handling, thus no compatibility issue (CI type is 0)."
203,"<android.hardware.camera2.impl.CameraMetadataNative: void set(Key<T>,T)>",31,32,"<android.hardware.camera2.impl.CameraMetadataNative: void set(Key<T>,T)>","<android.hardware.camera2.impl.CameraMetadataNative: void set(Key<T>,T)>",0,"MethodDeclaration(method_body, [Statement({, []), MethodCall(set(key.getNativeKey(), value), [VariableReference(set(key, []), Expression(), []), Expression(value, [])]), Statement(}, [])])  Statement({, [])  MethodCall(set(key.getNativeKey(), value), [VariableReference(set(key, []), Expression(), []), Expression(value, [])])    VariableReference(set(key, [])    Expression(), [])    Expression(value, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(SetCommand s, []), Expression(sSetCommandMap.get(key), [])]), AssignmentExpression(=, [VariableReference(if (s !, []), Expression(null) {, [])]), MethodCall(s.setValue(this, value), [VariableReference(s, []), Expression(this, []), Expression(value, [])]), Statement(return, []), Statement(}, []), Statement(setBase(key, value), []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(SetCommand s, []), Expression(sSetCommandMap.get(key), [])])    VariableReference(SetCommand s, [])    Expression(sSetCommandMap.get(key), [])  AssignmentExpression(=, [VariableReference(if (s !, []), Expression(null) {, [])])    VariableReference(if (s !, [])    Expression(null) {, [])  MethodCall(s.setValue(this, value), [VariableReference(s, []), Expression(this, []), Expression(value, [])])    VariableReference(s, [])    Expression(this, [])    Expression(value, [])  Statement(return, [])  Statement(}, [])  Statement(setBase(key, value), [])  Statement(}, [])",1,,"/**
 * Set a camera metadata field to a value. The field definitions can be
 * found in {@link CameraCharacteristics}, {@link CaptureResult}, and
 * {@link CaptureRequest}.
 *
 * @param key The metadata field to write.
 * @param value The value to set the field to, which must be of a matching
 * type to the key.
 */
",1,,,0,,,0,"1,2","1,3,4,5",1,"1,4",1,"The early implementation uses a simple method call set(key.getNativeKey(), value). The late implementation introduces new logic including an assignment (`SetCommand s = sSetCommandMap.get(key)`), a conditional check, a method call (`s.setValue(this, value)`), and additional statements (`return` and `setBase(key, value)`). Hence, the code change types are 1,4.","The added complexity and new logic in the late version could lead to different return behaviors and functionalities of the method, causing it to potentially return different values or types. Thus, the CI type is 1."
204,<android.view.accessibility.AccessibilityEvent: void setEventType(int)>,31,32,<android.view.accessibility.AccessibilityEvent: void setEventType(int)>,<android.view.accessibility.AccessibilityEvent: void setEventType(int)>,0,"MethodDeclaration(method_body, [Statement({, []), Statement(enforceNotSealed(), []), AssignmentExpression(=, [VariableReference(mEventType, []), Expression(eventType, [])]), Statement(}, [])])  Statement({, [])  Statement(enforceNotSealed(), [])  AssignmentExpression(=, [VariableReference(mEventType, []), Expression(eventType, [])])    VariableReference(mEventType, [])    Expression(eventType, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(enforceNotSealed(), []), AssignmentExpression(=, [VariableReference(mEventType, []), Expression(eventType, [])]), Statement(}, [])])  Statement({, [])  Statement(enforceNotSealed(), [])  AssignmentExpression(=, [VariableReference(mEventType, []), Expression(eventType, [])])    VariableReference(mEventType, [])    Expression(eventType, [])  Statement(}, [])",0,"/**
 * Sets the event type.
 *
 * @param eventType The event type.
 *
 * @throws IllegalStateException If called from an AccessibilityService.
 */
","/**
 * Sets the event type.
 *
 * <b>Note: An event must represent a single event type.</b>
 * @param eventType The event type.
 *
 * @throws IllegalStateException If called from an AccessibilityService.
 */
",1,,,0,,,0,0,0,0,0,0,There is no code change between the early and late implementations based on the provided AST nodes.,"Since there are no changes in the code, there are no potential compatibility issues."
205,<android.accessibilityservice.AccessibilityService: Context createDisplayContext(Display)>,31,32,<android.accessibilityservice.AccessibilityService: Context createDisplayContext(Display)>,<android.accessibilityservice.AccessibilityService: Context createDisplayContext(Display)>,0,"MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(final Context context, []), Expression(super.createDisplayContext(display), [])]), AssignmentExpression(=, [VariableReference(final int displayId, []), Expression(display.getDisplayId(), [])]), Statement(setDefaultTokenInternal(context, displayId), []), Statement(return context, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(final Context context, []), Expression(super.createDisplayContext(display), [])])    VariableReference(final Context context, [])    Expression(super.createDisplayContext(display), [])  AssignmentExpression(=, [VariableReference(final int displayId, []), Expression(display.getDisplayId(), [])])    VariableReference(final int displayId, [])    Expression(display.getDisplayId(), [])  Statement(setDefaultTokenInternal(context, displayId), [])  Statement(return context, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), MethodCall(return new AccessibilityContext(super.createDisplayContext(display), mConnectionId), [VariableReference(return new AccessibilityContext(super, []), Expression(display), []), Expression(mConnectionId, [])]), Statement(}, [])])  Statement({, [])  MethodCall(return new AccessibilityContext(super.createDisplayContext(display), mConnectionId), [VariableReference(return new AccessibilityContext(super, []), Expression(display), []), Expression(mConnectionId, [])])    VariableReference(return new AccessibilityContext(super, [])    Expression(display), [])    Expression(mConnectionId, [])  Statement(}, [])",1,,,0,[@Override],"[@NonNull, @Override]",1,,,0,"1,2","1,4",1,"1,4",1,The implementation has changed from returning a `Context` object directly to returning a new `AccessibilityContext` object. This impacts the return type and the variable being returned. So the code change types are 1 (return statement changed) and 4 (other statement changed).,"The change in return type and the object being returned could result in different behavior for the API, potentially returning a different type (even though `AccessibilityContext` is a specialized form of `Context`). Hence, the CI type is 1."
206,<android.os.UserManager: Bundle getUserRestrictions()>,32,33,<android.os.UserManager: Bundle getUserRestrictions()>,<android.os.UserManager: Bundle getUserRestrictions()>,0,"MethodDeclaration(method_body, [Statement({, []), MethodCall(return getUserRestrictions(Process.myUserHandle()), [VariableReference(return getUserRestrictions(Process, []), Expression(), [])]), Statement(}, [])])  Statement({, [])  MethodCall(return getUserRestrictions(Process.myUserHandle()), [VariableReference(return getUserRestrictions(Process, []), Expression(), [])])    VariableReference(return getUserRestrictions(Process, [])    Expression(), [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(try {, []), MethodCall(return mService.getUserRestrictions(getContextUserIfAppropriate()), [VariableReference(return mService, []), Expression(getContextUserIfAppropriate(), [])]), Statement(} catch (RemoteException re) {, []), MethodCall(throw re.rethrowFromSystemServer(), [VariableReference(throw re, []), Expression(, [])]), Statement(}, []), Statement(}, [])])  Statement({, [])  Statement(try {, [])  MethodCall(return mService.getUserRestrictions(getContextUserIfAppropriate()), [VariableReference(return mService, []), Expression(getContextUserIfAppropriate(), [])])    VariableReference(return mService, [])    Expression(getContextUserIfAppropriate(), [])  Statement(} catch (RemoteException re) {, [])  MethodCall(throw re.rethrowFromSystemServer(), [VariableReference(throw re, []), Expression(, [])])    VariableReference(throw re, [])    Expression(, [])  Statement(}, [])  Statement(}, [])",1,"/**
 * Returns the user-wide restrictions imposed on this user.
 * @return a Bundle containing all the restrictions.
 */
","/**
 * Returns the user-wide restrictions imposed on the context user.
 * @return a Bundle containing all the restrictions.
 */
",1,,"[@UserHandleAware(enabledSinceTargetSdkVersion = Build.VERSION_CODES.TIRAMISU, requiresAnyOfPermissionsIfNotCallerProfileGroup = { android.Manifest.permission.MANAGE_USERS, android.Manifest.permission.INTERACT_ACROSS_USERS })]",1,,,0,"1,2","1,2,5","1,2","1,2,3,5","1,2",The implementation of the method has undergone several changes:,3. The control dependency has been modified by adding a `try-catch` block.
207,<android.service.dreams.DreamService: boolean isScreenBright()>,32,33,<android.service.dreams.DreamService: boolean isScreenBright()>,<android.service.dreams.DreamService: boolean isScreenBright()>,0,"MethodDeclaration(method_body, [Statement({, []), Statement(}, [])])  Statement({, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(}, [])])  Statement({, [])  Statement(}, [])",0,"/**
 * Returns whether or not this dream keeps the screen bright while dreaming.
 * Defaults to false, allowing the screen to dim if necessary.
 *
 * @see #setScreenBright(boolean)
 */
","/**
 * Returns whether this dream keeps the screen bright while dreaming.
 * Defaults to false, allowing the screen to dim if necessary.
 *
 * @see #setScreenBright(boolean)
 */
",1,,,0,,,0,0,0,0,0,0,No change detected between the early and late versions of the implementation.,"Since there is no change in the implementation, there are no compatibility issues."
208,<android.os.Parcel: Parcelable[] readParcelableArray(ClassLoader)>,32,33,<android.os.Parcel: Parcelable[] readParcelableArray(ClassLoader)>,<android.os.Parcel: Parcelable[] readParcelableArray(ClassLoader)>,0,"MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(int N, []), Expression(readInt(), [])]), Statement(if (N < 0) {, []), Statement(return null, []), Statement(}, []), AssignmentExpression(=, [VariableReference(Parcelable[] p, []), Expression(new Parcelable[N], [])]), AssignmentExpression(=, [VariableReference(for (int i, []), Expression(0, [])]), Statement(i < N, []), Statement(i++) {, []), AssignmentExpression(=, [VariableReference(p[i], []), Expression(readParcelable(loader), [])]), Statement(}, []), Statement(return p, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(int N, []), Expression(readInt(), [])])    VariableReference(int N, [])    Expression(readInt(), [])  Statement(if (N < 0) {, [])  Statement(return null, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(Parcelable[] p, []), Expression(new Parcelable[N], [])])    VariableReference(Parcelable[] p, [])    Expression(new Parcelable[N], [])  AssignmentExpression(=, [VariableReference(for (int i, []), Expression(0, [])])    VariableReference(for (int i, [])    Expression(0, [])  Statement(i < N, [])  Statement(i++) {, [])  AssignmentExpression(=, [VariableReference(p[i], []), Expression(readParcelable(loader), [])])    VariableReference(p[i], [])    Expression(readParcelable(loader), [])  Statement(}, [])  Statement(return p, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(return readParcelableArrayInternal(loader, /* clazz */, []), Statement(null), []), Statement(}, [])])  Statement({, [])  Statement(return readParcelableArrayInternal(loader, /* clazz */, [])  Statement(null), [])  Statement(}, [])",1,"/**
 * Read and return a new Parcelable array from the parcel.
 * The given class loader will be used to load any enclosed
 * Parcelables.
 * @return the Parcelable array, or null if the array is null
 */
","/**
 * Read and return a new Parcelable array from the parcel.
 * The given class loader will be used to load any enclosed
 * Parcelables.
 * @return the Parcelable array, or null if the array is null
 *
 * @deprecated Use the type-safer version {@link #readParcelableArray(ClassLoader, Class)}
 * starting from Android {@link Build.VERSION_CODES#TIRAMISU}. Also consider changing the
 * format to use {@link #createTypedArray(Parcelable.Creator)} if possible (eg. if the
 * items' class is final) since this is also more performant. Note that changing to the
 * latter also requires changing the writes.
 */
",1,[@Nullable],"[@Deprecated, @Nullable]",1,,,0,"1,2","1,2,5","1,2","1,5",1,"The method body in the late version has changed significantly to use `readParcelableArrayInternal(loader, /* clazz */)`, substituting the entire previous logic. This falls under both return statement change due to the introduction of a new return statement and dependent API change as it now depends on the new `readParcelableArrayInternal` method.","The change involves a new method `readParcelableArrayInternal` which might return different values or types, thus leading to different return values compared to the early implementation. Therefore, the CI type is 1."
502,"<android.os.image.DynamicSystemClient.DynSystemServiceConnection: void onServiceConnected(ComponentName,IBinder)>",30,31,"<android.os.image.DynamicSystemClient.DynSystemServiceConnection: void onServiceConnected(ComponentName,IBinder)>","<android.os.image.DynamicSystemClient.DynSystemServiceConnection: void onServiceConnected(ComponentName,IBinder)>",0,"MethodDeclaration(method_body, [Statement({, []), MethodCall(Slog.v(TAG, ""DynSystemService connected""), [VariableReference(Slog, []), Expression(TAG, []), Expression(""DynSystemService connected"", [])]), AssignmentExpression(=, [VariableReference(mService, []), Expression(new Messenger(service), [])]), Statement(try {, []), AssignmentExpression(=, [VariableReference(Message msg, []), Expression(Message.obtain(null, MSG_REGISTER_LISTENER), [])]), AssignmentExpression(=, [VariableReference(msg.replyTo, []), Expression(mMessenger, [])]), MethodCall(mService.send(msg), [VariableReference(mService, []), Expression(msg, [])]), Statement(} catch (RemoteException e) {, []), MethodCall(Slog.e(TAG, ""Unable to get status from installation service""), [VariableReference(Slog, []), Expression(TAG, []), Expression(""Unable to get status from installation service"", [])]), AssignmentExpression(=, [VariableReference(if (mExecutor !, []), Expression(null) {, [])]), MethodCall(mExecutor.execute((), [VariableReference(mExecutor, []), Expression((, [])]), MethodCall(mListener.onStatusChanged(STATUS_UNKNOWN, CAUSE_ERROR_IPC, 0, e), [VariableReference(mListener, []), Expression(STATUS_UNKNOWN, []), Expression(CAUSE_ERROR_IPC, []), Expression(0, []), Expression(e, [])]), Statement(}), []), Statement(} else {, []), MethodCall(mListener.onStatusChanged(STATUS_UNKNOWN, CAUSE_ERROR_IPC, 0, e), [VariableReference(mListener, []), Expression(STATUS_UNKNOWN, []), Expression(CAUSE_ERROR_IPC, []), Expression(0, []), Expression(e, [])]), Statement(}, []), Statement(}, []), Statement(}, [])])  Statement({, [])  MethodCall(Slog.v(TAG, ""DynSystemService connected""), [VariableReference(Slog, []), Expression(TAG, []), Expression(""DynSystemService connected"", [])])    VariableReference(Slog, [])    Expression(TAG, [])    Expression(""DynSystemService connected"", [])  AssignmentExpression(=, [VariableReference(mService, []), Expression(new Messenger(service), [])])    VariableReference(mService, [])    Expression(new Messenger(service), [])  Statement(try {, [])  AssignmentExpression(=, [VariableReference(Message msg, []), Expression(Message.obtain(null, MSG_REGISTER_LISTENER), [])])    VariableReference(Message msg, [])    Expression(Message.obtain(null, MSG_REGISTER_LISTENER), [])  AssignmentExpression(=, [VariableReference(msg.replyTo, []), Expression(mMessenger, [])])    VariableReference(msg.replyTo, [])    Expression(mMessenger, [])  MethodCall(mService.send(msg), [VariableReference(mService, []), Expression(msg, [])])    VariableReference(mService, [])    Expression(msg, [])  Statement(} catch (RemoteException e) {, [])  MethodCall(Slog.e(TAG, ""Unable to get status from installation service""), [VariableReference(Slog, []), Expression(TAG, []), Expression(""Unable to get status from installation service"", [])])    VariableReference(Slog, [])    Expression(TAG, [])    Expression(""Unable to get status from installation service"", [])  AssignmentExpression(=, [VariableReference(if (mExecutor !, []), Expression(null) {, [])])    VariableReference(if (mExecutor !, [])    Expression(null) {, [])  MethodCall(mExecutor.execute((), [VariableReference(mExecutor, []), Expression((, [])])    VariableReference(mExecutor, [])    Expression((, [])  MethodCall(mListener.onStatusChanged(STATUS_UNKNOWN, CAUSE_ERROR_IPC, 0, e), [VariableReference(mListener, []), Expression(STATUS_UNKNOWN, []), Expression(CAUSE_ERROR_IPC, []), Expression(0, []), Expression(e, [])])    VariableReference(mListener, [])    Expression(STATUS_UNKNOWN, [])    Expression(CAUSE_ERROR_IPC, [])    Expression(0, [])    Expression(e, [])  Statement(}), [])  Statement(} else {, [])  MethodCall(mListener.onStatusChanged(STATUS_UNKNOWN, CAUSE_ERROR_IPC, 0, e), [VariableReference(mListener, []), Expression(STATUS_UNKNOWN, []), Expression(CAUSE_ERROR_IPC, []), Expression(0, []), Expression(e, [])])    VariableReference(mListener, [])    Expression(STATUS_UNKNOWN, [])    Expression(CAUSE_ERROR_IPC, [])    Expression(0, [])    Expression(e, [])  Statement(}, [])  Statement(}, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), MethodCall(Slog.v(TAG, ""onServiceConnected: "" + className), [VariableReference(Slog, []), Expression(TAG, []), Expression(""onServiceConnected: "" + className, [])]), AssignmentExpression(=, [VariableReference(mService, []), Expression(new Messenger(service), [])]), Statement(try {, []), AssignmentExpression(=, [VariableReference(Message msg, []), Expression(Message.obtain(null, MSG_REGISTER_LISTENER), [])]), AssignmentExpression(=, [VariableReference(msg.replyTo, []), Expression(mMessenger, [])]), MethodCall(mService.send(msg), [VariableReference(mService, []), Expression(msg, [])]), Statement(} catch (RemoteException e) {, []), MethodCall(Slog.e(TAG, ""Unable to get status from installation service""), [VariableReference(Slog, []), Expression(TAG, []), Expression(""Unable to get status from installation service"", [])]), Statement(notifyOnStatusChangedListener(STATUS_UNKNOWN, CAUSE_ERROR_IPC, 0, e), []), Statement(}, []), Statement(}, [])])  Statement({, [])  MethodCall(Slog.v(TAG, ""onServiceConnected: "" + className), [VariableReference(Slog, []), Expression(TAG, []), Expression(""onServiceConnected: "" + className, [])])    VariableReference(Slog, [])    Expression(TAG, [])    Expression(""onServiceConnected: "" + className, [])  AssignmentExpression(=, [VariableReference(mService, []), Expression(new Messenger(service), [])])    VariableReference(mService, [])    Expression(new Messenger(service), [])  Statement(try {, [])  AssignmentExpression(=, [VariableReference(Message msg, []), Expression(Message.obtain(null, MSG_REGISTER_LISTENER), [])])    VariableReference(Message msg, [])    Expression(Message.obtain(null, MSG_REGISTER_LISTENER), [])  AssignmentExpression(=, [VariableReference(msg.replyTo, []), Expression(mMessenger, [])])    VariableReference(msg.replyTo, [])    Expression(mMessenger, [])  MethodCall(mService.send(msg), [VariableReference(mService, []), Expression(msg, [])])    VariableReference(mService, [])    Expression(msg, [])  Statement(} catch (RemoteException e) {, [])  MethodCall(Slog.e(TAG, ""Unable to get status from installation service""), [VariableReference(Slog, []), Expression(TAG, []), Expression(""Unable to get status from installation service"", [])])    VariableReference(Slog, [])    Expression(TAG, [])    Expression(""Unable to get status from installation service"", [])  Statement(notifyOnStatusChangedListener(STATUS_UNKNOWN, CAUSE_ERROR_IPC, 0, e), [])  Statement(}, [])  Statement(}, [])",1,,,-1,,,-1,-1,-1,-1,-1,"2,3,4",0,"2,4",2,"The logging statement has been updated to include the className, but the primary changes involve exception handling. Instead of directly calling `mListener.onStatusChanged()`, the new version calls `notifyOnStatusChangedListener()`, a method that presumably encapsulates the onStatusChanged operations. The assignment statement 'if (mExecutor !' is removed. Therefore, the code change types are 2 and 4.","The change in exception handling can lead to different behaviors, specifically in how exceptions are logged and possibly handled. The removal of the assignment statement 'if (mExecutor !' further solidifies the potential difference in how exceptions are processed, and therefore, the CI type is 2."
168,<android.hardware.display.DisplayManagerInternal.DisplayPowerRequest: boolean equals(DisplayPowerRequest)>,29,30,<android.hardware.display.DisplayManagerInternal.DisplayPowerRequest: boolean equals(DisplayPowerRequest)>,<android.hardware.display.DisplayManagerInternal.DisplayPowerRequest: boolean equals(DisplayPowerRequest)>,0,"MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(return other !, []), Expression(null && policy, [])]), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(return other !, []), Expression(null && policy, [])])    VariableReference(return other !, [])    Expression(null && policy, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(return other !, []), Expression(null && policy, [])]), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(return other !, []), Expression(null && policy, [])])    VariableReference(return other !, [])    Expression(null && policy, [])  Statement(}, [])",1,,,-1,,,-1,-1,-1,-1,-1,"1,4",0,0,0,"There is no discernible difference between the early and late implementations based on the provided AST nodes. Thus, the change type is 0.","Since there are no changes between the two versions, there are no compatibility issues. Thus, the CI type is 0."
223,<android.text.TextUtils: int getLayoutDirectionFromLocale(Locale)>,18,19,<android.text.TextUtils: int getLayoutDirectionFromLocale(Locale)>,<android.text.TextUtils: int getLayoutDirectionFromLocale(Locale)>,0,"MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(if (locale !, []), Expression(null && !locale.equals(Locale.ROOT)) {, [])]), AssignmentExpression(=, [VariableReference(final String scriptSubtag, []), Expression(ICU.getScript(ICU.addLikelySubtags(locale.toString())), [])]), AssignmentExpression(=, [VariableReference(if (scriptSubtag, []), Expression(, [])]), Statement(return getLayoutDirectionFromFirstChar(locale), []), MethodCall(if (scriptSubtag.equalsIgnoreCase(ARAB_SCRIPT_SUBTAG) || scriptSubtag.equalsIgnoreCase(HEBR_SCRIPT_SUBTAG)), [VariableReference(if (scriptSubtag, []), Expression(ARAB_SCRIPT_SUBTAG) || scriptSubtag.equalsIgnoreCase(HEBR_SCRIPT_SUBTAG), [])]), Statement(return View.LAYOUT_DIRECTION_RTL, []), Statement(}, []), Statement(}, []), Statement(return View.LAYOUT_DIRECTION_LTR, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(if (locale !, []), Expression(null && !locale.equals(Locale.ROOT)) {, [])])    VariableReference(if (locale !, [])    Expression(null && !locale.equals(Locale.ROOT)) {, [])  AssignmentExpression(=, [VariableReference(final String scriptSubtag, []), Expression(ICU.getScript(ICU.addLikelySubtags(locale.toString())), [])])    VariableReference(final String scriptSubtag, [])    Expression(ICU.getScript(ICU.addLikelySubtags(locale.toString())), [])  AssignmentExpression(=, [VariableReference(if (scriptSubtag, []), Expression(, [])])    VariableReference(if (scriptSubtag, [])    Expression(, [])  Statement(return getLayoutDirectionFromFirstChar(locale), [])  MethodCall(if (scriptSubtag.equalsIgnoreCase(ARAB_SCRIPT_SUBTAG) || scriptSubtag.equalsIgnoreCase(HEBR_SCRIPT_SUBTAG)), [VariableReference(if (scriptSubtag, []), Expression(ARAB_SCRIPT_SUBTAG) || scriptSubtag.equalsIgnoreCase(HEBR_SCRIPT_SUBTAG), [])])    VariableReference(if (scriptSubtag, [])    Expression(ARAB_SCRIPT_SUBTAG) || scriptSubtag.equalsIgnoreCase(HEBR_SCRIPT_SUBTAG), [])  Statement(return View.LAYOUT_DIRECTION_RTL, [])  Statement(}, [])  Statement(}, [])  Statement(return View.LAYOUT_DIRECTION_LTR, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(if (locale !, []), Expression(null && !locale.equals(Locale.ROOT)) {, [])]), AssignmentExpression(=, [VariableReference(final String scriptSubtag, []), Expression(ICU.getScript(ICU.addLikelySubtags(locale.toString())), [])]), AssignmentExpression(=, [VariableReference(if (scriptSubtag, []), Expression(, [])]), Statement(return getLayoutDirectionFromFirstChar(locale), []), MethodCall(if (scriptSubtag.equalsIgnoreCase(ARAB_SCRIPT_SUBTAG) || scriptSubtag.equalsIgnoreCase(HEBR_SCRIPT_SUBTAG)), [VariableReference(if (scriptSubtag, []), Expression(ARAB_SCRIPT_SUBTAG) || scriptSubtag.equalsIgnoreCase(HEBR_SCRIPT_SUBTAG), [])]), Statement(return View.LAYOUT_DIRECTION_RTL, []), Statement(}, []), Statement(}, []), Statement(// If forcing into RTL layout mode, return RTL as default, else LTR, []), MethodCall(return SystemProperties.getBoolean(Settings.Global.DEVELOPMENT_FORCE_RTL, false), [VariableReference(return SystemProperties, []), Expression(Settings.Global.DEVELOPMENT_FORCE_RTL, []), Expression(false, [])]), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(if (locale !, []), Expression(null && !locale.equals(Locale.ROOT)) {, [])])    VariableReference(if (locale !, [])    Expression(null && !locale.equals(Locale.ROOT)) {, [])  AssignmentExpression(=, [VariableReference(final String scriptSubtag, []), Expression(ICU.getScript(ICU.addLikelySubtags(locale.toString())), [])])    VariableReference(final String scriptSubtag, [])    Expression(ICU.getScript(ICU.addLikelySubtags(locale.toString())), [])  AssignmentExpression(=, [VariableReference(if (scriptSubtag, []), Expression(, [])])    VariableReference(if (scriptSubtag, [])    Expression(, [])  Statement(return getLayoutDirectionFromFirstChar(locale), [])  MethodCall(if (scriptSubtag.equalsIgnoreCase(ARAB_SCRIPT_SUBTAG) || scriptSubtag.equalsIgnoreCase(HEBR_SCRIPT_SUBTAG)), [VariableReference(if (scriptSubtag, []), Expression(ARAB_SCRIPT_SUBTAG) || scriptSubtag.equalsIgnoreCase(HEBR_SCRIPT_SUBTAG), [])])    VariableReference(if (scriptSubtag, [])    Expression(ARAB_SCRIPT_SUBTAG) || scriptSubtag.equalsIgnoreCase(HEBR_SCRIPT_SUBTAG), [])  Statement(return View.LAYOUT_DIRECTION_RTL, [])  Statement(}, [])  Statement(}, [])  Statement(// If forcing into RTL layout mode, return RTL as default, else LTR, [])  MethodCall(return SystemProperties.getBoolean(Settings.Global.DEVELOPMENT_FORCE_RTL, false), [VariableReference(return SystemProperties, []), Expression(Settings.Global.DEVELOPMENT_FORCE_RTL, []), Expression(false, [])])    VariableReference(return SystemProperties, [])    Expression(Settings.Global.DEVELOPMENT_FORCE_RTL, [])    Expression(false, [])  Statement(}, [])",1,"/**
 * Return the layout direction for a given Locale
 *
 * @param locale the Locale for which we want the layout direction. Can be null.
 * @return the layout direction. This may be one of:
 * {@link android.view.View#LAYOUT_DIRECTION_LTR} or
 * {@link android.view.View#LAYOUT_DIRECTION_RTL}.
 *
 * Be careful: this code will need to be updated when vertical scripts will be supported
 */
","/**
 * Return the layout direction for a given Locale
 *
 * @param locale the Locale for which we want the layout direction. Can be null.
 * @return the layout direction. This may be one of:
 * {@link android.view.View#LAYOUT_DIRECTION_LTR} or
 * {@link android.view.View#LAYOUT_DIRECTION_RTL}.
 *
 * Be careful: this code will need to be updated when vertical scripts will be supported
 */
",-1,,,-1,-1,-1,-1,-1,"1,3,4",1,"3,4",1,"A new condition involving SystemProperties.getBoolean(Settings.Global.DEVELOPMENT_FORCE_RTL, false) has been introduced. This adds a control dependency and an additional statement to return the layout direction based on the value of this system setting.","The new control dependency on SystemProperties and the additional return statement may cause the method to return different values depending on the system setting, leading to potential differences in return values. Therefore, the CI type is 1."
234,"<android.hardware.camera2.impl.CameraDeviceImpl: void createConstrainedHighSpeedCaptureSession(List<Surface>,StateCallback,Handler)>",25,26,"<android.hardware.camera2.impl.CameraDeviceImpl: void createConstrainedHighSpeedCaptureSession(List<Surface>,StateCallback,Handler)>","<android.hardware.camera2.impl.CameraDeviceImpl: void createConstrainedHighSpeedCaptureSession(List<Surface>,StateCallback,Handler)>",0,"MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(if (outputs, []), Expression(, [])]), Statement(throw new IllegalArgumentException(""Output surface list must not be null and the size must be no more than 2""), []), Statement(}, []), AssignmentExpression(=, [VariableReference(StreamConfigurationMap config, []), Expression(getCharacteristics().get(CameraCharacteristics.SCALER_STREAM_CONFIGURATION_MAP), [])]), Statement(null, config), []), AssignmentExpression(=, [VariableReference(List<OutputConfiguration> outConfigurations, []), Expression(new ArrayList<>(outputs.size()), [])]), Statement(for (Surface surface : outputs) {, []), MethodCall(outConfigurations.add(new OutputConfiguration(surface)), [VariableReference(outConfigurations, []), Expression(new OutputConfiguration(surface), [])]), Statement(}, []), Statement(createCaptureSessionInternal(null, outConfigurations, callback, handler, /*isConstrainedHighSpeed*/, []), Statement(true), []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(if (outputs, []), Expression(, [])])    VariableReference(if (outputs, [])    Expression(, [])  Statement(throw new IllegalArgumentException(""Output surface list must not be null and the size must be no more than 2""), [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(StreamConfigurationMap config, []), Expression(getCharacteristics().get(CameraCharacteristics.SCALER_STREAM_CONFIGURATION_MAP), [])])    VariableReference(StreamConfigurationMap config, [])    Expression(getCharacteristics().get(CameraCharacteristics.SCALER_STREAM_CONFIGURATION_MAP), [])  Statement(null, config), [])  AssignmentExpression(=, [VariableReference(List<OutputConfiguration> outConfigurations, []), Expression(new ArrayList<>(outputs.size()), [])])    VariableReference(List<OutputConfiguration> outConfigurations, [])    Expression(new ArrayList<>(outputs.size()), [])  Statement(for (Surface surface : outputs) {, [])  MethodCall(outConfigurations.add(new OutputConfiguration(surface)), [VariableReference(outConfigurations, []), Expression(new OutputConfiguration(surface), [])])    VariableReference(outConfigurations, [])    Expression(new OutputConfiguration(surface), [])  Statement(}, [])  Statement(createCaptureSessionInternal(null, outConfigurations, callback, handler, /*isConstrainedHighSpeed*/, [])  Statement(true), [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(if (outputs, []), Expression(, [])]), Statement(throw new IllegalArgumentException(""Output surface list must not be null and the size must be no more than 2""), []), Statement(}, []), AssignmentExpression(=, [VariableReference(StreamConfigurationMap config, []), Expression(getCharacteristics().get(CameraCharacteristics.SCALER_STREAM_CONFIGURATION_MAP), [])]), Statement(null, config), []), AssignmentExpression(=, [VariableReference(List<OutputConfiguration> outConfigurations, []), Expression(new ArrayList<>(outputs.size()), [])]), Statement(for (Surface surface : outputs) {, []), MethodCall(outConfigurations.add(new OutputConfiguration(surface)), [VariableReference(outConfigurations, []), Expression(new OutputConfiguration(surface), [])]), Statement(}, []), Statement(createCaptureSessionInternal(null, outConfigurations, callback, handler, /*operatingMode*/, []), Statement(ICameraDeviceUser.CONSTRAINED_HIGH_SPEED_MODE), []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(if (outputs, []), Expression(, [])])    VariableReference(if (outputs, [])    Expression(, [])  Statement(throw new IllegalArgumentException(""Output surface list must not be null and the size must be no more than 2""), [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(StreamConfigurationMap config, []), Expression(getCharacteristics().get(CameraCharacteristics.SCALER_STREAM_CONFIGURATION_MAP), [])])    VariableReference(StreamConfigurationMap config, [])    Expression(getCharacteristics().get(CameraCharacteristics.SCALER_STREAM_CONFIGURATION_MAP), [])  Statement(null, config), [])  AssignmentExpression(=, [VariableReference(List<OutputConfiguration> outConfigurations, []), Expression(new ArrayList<>(outputs.size()), [])])    VariableReference(List<OutputConfiguration> outConfigurations, [])    Expression(new ArrayList<>(outputs.size()), [])  Statement(for (Surface surface : outputs) {, [])  MethodCall(outConfigurations.add(new OutputConfiguration(surface)), [VariableReference(outConfigurations, []), Expression(new OutputConfiguration(surface), [])])    VariableReference(outConfigurations, [])    Expression(new OutputConfiguration(surface), [])  Statement(}, [])  Statement(createCaptureSessionInternal(null, outConfigurations, callback, handler, /*operatingMode*/, [])  Statement(ICameraDeviceUser.CONSTRAINED_HIGH_SPEED_MODE), [])  Statement(}, [])",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,4,1,"4,5",0,"The parameter passed to the method `createCaptureSessionInternal` has changed from `true` to `ICameraDeviceUser.CONSTRAINED_HIGH_SPEED_MODE`. This is likely referring to a defined constant but is changing the behavior of the method call. Thus the change type is 4,5.","The change does not seem to result in different return values or exception handling in the given context. Thus, no Compatibility Issue exists."
695,<android.content.ContentValues: Long getAsLong(String)>,28,29,<android.content.ContentValues: Long getAsLong(String)>,<android.content.ContentValues: Long getAsLong(String)>,0,"MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(Object value, []), Expression(mValues.get(key), [])]), Statement(try {, []), AssignmentExpression(=, [VariableReference(return value !, []), Expression(null ? ((Number) value).longValue() : null, [])]), Statement(} catch (ClassCastException e) {, []), Statement(if (value instanceof CharSequence) {, []), Statement(try {, []), MethodCall(return Long.valueOf(value.toString()), [VariableReference(return Long, []), Expression(value.toString(), [])]), Statement(} catch (NumberFormatException e2) {, []), MethodCall(Log.e(TAG, ""Cannot parse Long value for "" + value + "" at key "" + key), [VariableReference(Log, []), Expression(TAG, []), Expression(""Cannot parse Long value for "" + value + "" at key "" + key, [])]), Statement(return null, []), Statement(}, []), Statement(} else {, []), MethodCall(Log.e(TAG, ""Cannot cast value for "" + key + "" to a Long: "" + value, e), [VariableReference(Log, []), Expression(TAG, []), Expression(""Cannot cast value for "" + key + "" to a Long: "" + value, []), Expression(e, [])]), Statement(return null, []), Statement(}, []), Statement(}, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(Object value, []), Expression(mValues.get(key), [])])    VariableReference(Object value, [])    Expression(mValues.get(key), [])  Statement(try {, [])  AssignmentExpression(=, [VariableReference(return value !, []), Expression(null ? ((Number) value).longValue() : null, [])])    VariableReference(return value !, [])    Expression(null ? ((Number) value).longValue() : null, [])  Statement(} catch (ClassCastException e) {, [])  Statement(if (value instanceof CharSequence) {, [])  Statement(try {, [])  MethodCall(return Long.valueOf(value.toString()), [VariableReference(return Long, []), Expression(value.toString(), [])])    VariableReference(return Long, [])    Expression(value.toString(), [])  Statement(} catch (NumberFormatException e2) {, [])  MethodCall(Log.e(TAG, ""Cannot parse Long value for "" + value + "" at key "" + key), [VariableReference(Log, []), Expression(TAG, []), Expression(""Cannot parse Long value for "" + value + "" at key "" + key, [])])    VariableReference(Log, [])    Expression(TAG, [])    Expression(""Cannot parse Long value for "" + value + "" at key "" + key, [])  Statement(return null, [])  Statement(}, [])  Statement(} else {, [])  MethodCall(Log.e(TAG, ""Cannot cast value for "" + key + "" to a Long: "" + value, e), [VariableReference(Log, []), Expression(TAG, []), Expression(""Cannot cast value for "" + key + "" to a Long: "" + value, []), Expression(e, [])])    VariableReference(Log, [])    Expression(TAG, [])    Expression(""Cannot cast value for "" + key + "" to a Long: "" + value, [])    Expression(e, [])  Statement(return null, [])  Statement(}, [])  Statement(}, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(Object value, []), Expression(mMap.get(key), [])]), Statement(try {, []), AssignmentExpression(=, [VariableReference(return value !, []), Expression(null ? ((Number) value).longValue() : null, [])]), Statement(} catch (ClassCastException e) {, []), Statement(if (value instanceof CharSequence) {, []), Statement(try {, []), MethodCall(return Long.valueOf(value.toString()), [VariableReference(return Long, []), Expression(value.toString(), [])]), Statement(} catch (NumberFormatException e2) {, []), MethodCall(Log.e(TAG, ""Cannot parse Long value for "" + value + "" at key "" + key), [VariableReference(Log, []), Expression(TAG, []), Expression(""Cannot parse Long value for "" + value + "" at key "" + key, [])]), Statement(return null, []), Statement(}, []), Statement(} else {, []), MethodCall(Log.e(TAG, ""Cannot cast value for "" + key + "" to a Long: "" + value, e), [VariableReference(Log, []), Expression(TAG, []), Expression(""Cannot cast value for "" + key + "" to a Long: "" + value, []), Expression(e, [])]), Statement(return null, []), Statement(}, []), Statement(}, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(Object value, []), Expression(mMap.get(key), [])])    VariableReference(Object value, [])    Expression(mMap.get(key), [])  Statement(try {, [])  AssignmentExpression(=, [VariableReference(return value !, []), Expression(null ? ((Number) value).longValue() : null, [])])    VariableReference(return value !, [])    Expression(null ? ((Number) value).longValue() : null, [])  Statement(} catch (ClassCastException e) {, [])  Statement(if (value instanceof CharSequence) {, [])  Statement(try {, [])  MethodCall(return Long.valueOf(value.toString()), [VariableReference(return Long, []), Expression(value.toString(), [])])    VariableReference(return Long, [])    Expression(value.toString(), [])  Statement(} catch (NumberFormatException e2) {, [])  MethodCall(Log.e(TAG, ""Cannot parse Long value for "" + value + "" at key "" + key), [VariableReference(Log, []), Expression(TAG, []), Expression(""Cannot parse Long value for "" + value + "" at key "" + key, [])])    VariableReference(Log, [])    Expression(TAG, [])    Expression(""Cannot parse Long value for "" + value + "" at key "" + key, [])  Statement(return null, [])  Statement(}, [])  Statement(} else {, [])  MethodCall(Log.e(TAG, ""Cannot cast value for "" + key + "" to a Long: "" + value, e), [VariableReference(Log, []), Expression(TAG, []), Expression(""Cannot cast value for "" + key + "" to a Long: "" + value, []), Expression(e, [])])    VariableReference(Log, [])    Expression(TAG, [])    Expression(""Cannot cast value for "" + key + "" to a Long: "" + value, [])    Expression(e, [])  Statement(return null, [])  Statement(}, [])  Statement(}, [])  Statement(}, [])",1,"/**
 * Gets a value and converts it to a Long.
 *
 * @param key the value to get
 * @return the Long value, or {@code null} if the value is missing or cannot be converted
 */
","/**
 * Gets a value and converts it to a Long.
 *
 * @param key the value to get
 * @return the Long value, or {@code null} if the value is missing or cannot be converted
 */
",-1,,,-1,-1,-1,-1,-1,4,0,5,0,"The dependent API `mValues.get(key)` has been changed to `mMap.get(key)`, so the code change type is 5.","The change only involves switching the dependent API from `mValues.get(key)` to `mMap.get(key)` which presumably has identical functionality; thus, no compatibility issue exists."
863,<android.widget.RemoteViews.AsyncApplyTask: ViewTree doInBackground(Void)>,30,31,<android.widget.RemoteViews.AsyncApplyTask: ViewTree doInBackground(Void)>,<android.widget.RemoteViews.AsyncApplyTask: ViewTree doInBackground(Void)>,0,"MethodDeclaration(method_body, [Statement({, []), Statement(try {, []), AssignmentExpression(=, [VariableReference(if (mResult, []), Expression(, [])]), AssignmentExpression(=, [VariableReference(mResult, []), Expression(inflateView(mContext, mRV, mParent), [])]), Statement(}, []), AssignmentExpression(=, [VariableReference(mTree, []), Expression(new ViewTree(mResult), [])]), AssignmentExpression(=, [VariableReference(if (mRV.mActions !, []), Expression(null) {, [])]), AssignmentExpression(=, [VariableReference(int count, []), Expression(mRV.mActions.size(), [])]), AssignmentExpression(=, [VariableReference(mActions, []), Expression(new Action[count], [])]), AssignmentExpression(=, [VariableReference(for (int i, []), Expression(0, [])]), Statement(i < count && !isCancelled(), []), Statement(i++) {, []), Statement(// TODO: check if isCancelled in nested views., []), AssignmentExpression(=, [VariableReference(mActions[i], []), Expression(mRV.mActions.get(i).initActionAsync(mTree, mParent, mHandler), [])]), Statement(}, []), Statement(} else {, []), AssignmentExpression(=, [VariableReference(mActions, []), Expression(null, [])]), Statement(}, []), Statement(return mTree, []), Statement(} catch (Exception e) {, []), AssignmentExpression(=, [VariableReference(mError, []), Expression(e, [])]), Statement(return null, []), Statement(}, []), Statement(}, [])])  Statement({, [])  Statement(try {, [])  AssignmentExpression(=, [VariableReference(if (mResult, []), Expression(, [])])    VariableReference(if (mResult, [])    Expression(, [])  AssignmentExpression(=, [VariableReference(mResult, []), Expression(inflateView(mContext, mRV, mParent), [])])    VariableReference(mResult, [])    Expression(inflateView(mContext, mRV, mParent), [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(mTree, []), Expression(new ViewTree(mResult), [])])    VariableReference(mTree, [])    Expression(new ViewTree(mResult), [])  AssignmentExpression(=, [VariableReference(if (mRV.mActions !, []), Expression(null) {, [])])    VariableReference(if (mRV.mActions !, [])    Expression(null) {, [])  AssignmentExpression(=, [VariableReference(int count, []), Expression(mRV.mActions.size(), [])])    VariableReference(int count, [])    Expression(mRV.mActions.size(), [])  AssignmentExpression(=, [VariableReference(mActions, []), Expression(new Action[count], [])])    VariableReference(mActions, [])    Expression(new Action[count], [])  AssignmentExpression(=, [VariableReference(for (int i, []), Expression(0, [])])    VariableReference(for (int i, [])    Expression(0, [])  Statement(i < count && !isCancelled(), [])  Statement(i++) {, [])  Statement(// TODO: check if isCancelled in nested views., [])  AssignmentExpression(=, [VariableReference(mActions[i], []), Expression(mRV.mActions.get(i).initActionAsync(mTree, mParent, mHandler), [])])    VariableReference(mActions[i], [])    Expression(mRV.mActions.get(i).initActionAsync(mTree, mParent, mHandler), [])  Statement(}, [])  Statement(} else {, [])  AssignmentExpression(=, [VariableReference(mActions, []), Expression(null, [])])    VariableReference(mActions, [])    Expression(null, [])  Statement(}, [])  Statement(return mTree, [])  Statement(} catch (Exception e) {, [])  AssignmentExpression(=, [VariableReference(mError, []), Expression(e, [])])    VariableReference(mError, [])    Expression(e, [])  Statement(return null, [])  Statement(}, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(try {, []), AssignmentExpression(=, [VariableReference(if (mResult, []), Expression(, [])]), AssignmentExpression(=, [VariableReference(mResult, []), Expression(inflateView(mContext, mRV, mParent, 0, mColorResources), [])]), Statement(}, []), AssignmentExpression(=, [VariableReference(mTree, []), Expression(new ViewTree(mResult), [])]), AssignmentExpression(=, [VariableReference(if (mRV.mActions !, []), Expression(null) {, [])]), AssignmentExpression(=, [VariableReference(int count, []), Expression(mRV.mActions.size(), [])]), AssignmentExpression(=, [VariableReference(mActions, []), Expression(new Action[count], [])]), AssignmentExpression(=, [VariableReference(for (int i, []), Expression(0, [])]), Statement(i < count && !isCancelled(), []), Statement(i++) {, []), Statement(// TODO: check if isCancelled in nested views., []), AssignmentExpression(=, [VariableReference(mActions[i], []), Expression(mRV.mActions.get(i).initActionAsync(mTree, mParent, mHandler, mColorResources), [])]), Statement(}, []), Statement(} else {, []), AssignmentExpression(=, [VariableReference(mActions, []), Expression(null, [])]), Statement(}, []), Statement(return mTree, []), Statement(} catch (Exception e) {, []), AssignmentExpression(=, [VariableReference(mError, []), Expression(e, [])]), Statement(return null, []), Statement(}, []), Statement(}, [])])  Statement({, [])  Statement(try {, [])  AssignmentExpression(=, [VariableReference(if (mResult, []), Expression(, [])])    VariableReference(if (mResult, [])    Expression(, [])  AssignmentExpression(=, [VariableReference(mResult, []), Expression(inflateView(mContext, mRV, mParent, 0, mColorResources), [])])    VariableReference(mResult, [])    Expression(inflateView(mContext, mRV, mParent, 0, mColorResources), [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(mTree, []), Expression(new ViewTree(mResult), [])])    VariableReference(mTree, [])    Expression(new ViewTree(mResult), [])  AssignmentExpression(=, [VariableReference(if (mRV.mActions !, []), Expression(null) {, [])])    VariableReference(if (mRV.mActions !, [])    Expression(null) {, [])  AssignmentExpression(=, [VariableReference(int count, []), Expression(mRV.mActions.size(), [])])    VariableReference(int count, [])    Expression(mRV.mActions.size(), [])  AssignmentExpression(=, [VariableReference(mActions, []), Expression(new Action[count], [])])    VariableReference(mActions, [])    Expression(new Action[count], [])  AssignmentExpression(=, [VariableReference(for (int i, []), Expression(0, [])])    VariableReference(for (int i, [])    Expression(0, [])  Statement(i < count && !isCancelled(), [])  Statement(i++) {, [])  Statement(// TODO: check if isCancelled in nested views., [])  AssignmentExpression(=, [VariableReference(mActions[i], []), Expression(mRV.mActions.get(i).initActionAsync(mTree, mParent, mHandler, mColorResources), [])])    VariableReference(mActions[i], [])    Expression(mRV.mActions.get(i).initActionAsync(mTree, mParent, mHandler, mColorResources), [])  Statement(}, [])  Statement(} else {, [])  AssignmentExpression(=, [VariableReference(mActions, []), Expression(null, [])])    VariableReference(mActions, [])    Expression(null, [])  Statement(}, [])  Statement(return mTree, [])  Statement(} catch (Exception e) {, [])  AssignmentExpression(=, [VariableReference(mError, []), Expression(e, [])])    VariableReference(mError, [])    Expression(e, [])  Statement(return null, [])  Statement(}, [])  Statement(}, [])",1,,,-1,[@Override],"[@Nullable, @Override]",-1,-1,-1,-1,-1,5,0,"1,3,5",1,Several elements have changed between the early and late implementations:,3. These changes have occurred within control structures (if and for statements).
117,<android.hardware.camera2.impl.CameraDeviceImpl: void createExtensionSession(ExtensionSessionConfiguration)>,32,33,,,,"MethodDeclaration(method_body, [Statement({, []), Statement(try {, []), MethodCall(if (CameraExtensionCharacteristics.areAdvancedExtensionsSupported()), [VariableReference(if (CameraExtensionCharacteristics, []), Expression(), [])]), AssignmentExpression(=, [VariableReference(mCurrentAdvancedExtensionSession, []), Expression(CameraAdvancedExtensionSessionImpl.createCameraAdvancedExtensionSession(this, mContext, extensionConfiguration), [])]), Statement(} else {, []), AssignmentExpression(=, [VariableReference(mCurrentExtensionSession, []), Expression(CameraExtensionSessionImpl.createCameraExtensionSession(this, mContext, extensionConfiguration), [])]), Statement(}, []), Statement(} catch (RemoteException e) {, []), Statement(}, []), Statement(}, [])])  Statement({, [])  Statement(try {, [])  MethodCall(if (CameraExtensionCharacteristics.areAdvancedExtensionsSupported()), [VariableReference(if (CameraExtensionCharacteristics, []), Expression(), [])])    VariableReference(if (CameraExtensionCharacteristics, [])    Expression(), [])  AssignmentExpression(=, [VariableReference(mCurrentAdvancedExtensionSession, []), Expression(CameraAdvancedExtensionSessionImpl.createCameraAdvancedExtensionSession(this, mContext, extensionConfiguration), [])])    VariableReference(mCurrentAdvancedExtensionSession, [])    Expression(CameraAdvancedExtensionSessionImpl.createCameraAdvancedExtensionSession(this, mContext, extensionConfiguration), [])  Statement(} else {, [])  AssignmentExpression(=, [VariableReference(mCurrentExtensionSession, []), Expression(CameraExtensionSessionImpl.createCameraExtensionSession(this, mContext, extensionConfiguration), [])])    VariableReference(mCurrentExtensionSession, [])    Expression(CameraExtensionSessionImpl.createCameraExtensionSession(this, mContext, extensionConfiguration), [])  Statement(}, [])  Statement(} catch (RemoteException e) {, [])  Statement(}, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(try {, []), MethodCall(if (CameraExtensionCharacteristics.areAdvancedExtensionsSupported()), [VariableReference(if (CameraExtensionCharacteristics, []), Expression(), [])]), AssignmentExpression(=, [VariableReference(mCurrentAdvancedExtensionSession, []), Expression(CameraAdvancedExtensionSessionImpl.createCameraAdvancedExtensionSession(this, mContext, extensionConfiguration, mNextSessionId++), [])]), Statement(} else {, []), AssignmentExpression(=, [VariableReference(mCurrentExtensionSession, []), Expression(CameraExtensionSessionImpl.createCameraExtensionSession(this, mContext, extensionConfiguration, mNextSessionId++), [])]), Statement(}, []), Statement(} catch (RemoteException e) {, []), Statement(}, []), Statement(}, [])])  Statement({, [])  Statement(try {, [])  MethodCall(if (CameraExtensionCharacteristics.areAdvancedExtensionsSupported()), [VariableReference(if (CameraExtensionCharacteristics, []), Expression(), [])])    VariableReference(if (CameraExtensionCharacteristics, [])    Expression(), [])  AssignmentExpression(=, [VariableReference(mCurrentAdvancedExtensionSession, []), Expression(CameraAdvancedExtensionSessionImpl.createCameraAdvancedExtensionSession(this, mContext, extensionConfiguration, mNextSessionId++), [])])    VariableReference(mCurrentAdvancedExtensionSession, [])    Expression(CameraAdvancedExtensionSessionImpl.createCameraAdvancedExtensionSession(this, mContext, extensionConfiguration, mNextSessionId++), [])  Statement(} else {, [])  AssignmentExpression(=, [VariableReference(mCurrentExtensionSession, []), Expression(CameraExtensionSessionImpl.createCameraExtensionSession(this, mContext, extensionConfiguration, mNextSessionId++), [])])    VariableReference(mCurrentExtensionSession, [])    Expression(CameraExtensionSessionImpl.createCameraExtensionSession(this, mContext, extensionConfiguration, mNextSessionId++), [])  Statement(}, [])  Statement(} catch (RemoteException e) {, [])  Statement(}, [])  Statement(}, [])",1,,,0,[@Override],[@Override],0,,,,,5,0,"4,5 ",0,"The changes include passing an additional parameter (`mNextSessionId++`) to the dependent API calls (`CameraAdvancedExtensionSessionImpl.createCameraAdvancedExtensionSession` and `CameraExtensionSessionImpl.createCameraExtensionSession`). Therefore, the code change type is 4,5.","Although there are changes to the parameters of the dependent API calls, these changes do not directly suggest different return values or exception handling that could lead to compatibility issues. Thus, the CI type is 0."
9,<android.webkit.WebView: void onDraw(Canvas)>,6,7,<android.webkit.WebView: void onDraw(Canvas)>,<android.webkit.WebView: void onDraw(Canvas)>,0,"MethodDeclaration(method_body, [Statement({, []), Statement(// if mNativeClass is 0, the WebView has been destroyed. Do nothing., []), AssignmentExpression(=, [VariableReference(if (mNativeClass, []), Expression(, [])]), Statement(return, []), Statement(}, []), AssignmentExpression(=, [VariableReference(int saveCount, []), Expression(canvas.save(), [])]), AssignmentExpression(=, [VariableReference(if (mTitleBar !, []), Expression(null) {, [])]), MethodCall(canvas.translate(0, (int) mTitleBar.getHeight()), [VariableReference(canvas, []), Expression(0, []), Expression((int) mTitleBar.getHeight(), [])]), Statement(}, []), Statement(// Update the buttons in the picture, so when we draw the picture, []), Statement(// to the screen, they are in the correct state., []), Statement(// Tell the native side if user is a) touching the screen,, []), Statement(// b) pressing the trackball down, or c) pressing the enter key, []), Statement(// If the cursor is on a button, we need to draw it in the pressed, []), Statement(// state., []), Statement(// If mNativeClass is 0, we should not reach here, so we do not, []), Statement(// need to check it again., []), AssignmentExpression(=, [VariableReference(nativeRecordButtons(hasFocus() && hasWindowFocus(), mTouchMode, []), Expression(, [])]), Statement(drawCoreAndCursorRing(canvas, mBackgroundColor, mDrawCursorRing), []), MethodCall(canvas.restoreToCount(saveCount), [VariableReference(canvas, []), Expression(saveCount, [])]), Statement(// Now draw the shadow., []), AssignmentExpression(=, [VariableReference(if (mTitleBar !, []), Expression(null) {, [])]), AssignmentExpression(=, [VariableReference(int y, []), Expression(mScrollY + getVisibleTitleHeight(), [])]), AssignmentExpression(=, [VariableReference(int height, []), Expression((int) (5f * getContext().getResources().getDisplayMetrics().density), [])]), MethodCall(mTitleShadow.setBounds(mScrollX, y, mScrollX + getWidth(), y + height), [VariableReference(mTitleShadow, []), Expression(mScrollX, []), Expression(y, []), Expression(mScrollX + getWidth(), []), Expression(y + height, [])]), MethodCall(mTitleShadow.draw(canvas), [VariableReference(mTitleShadow, []), Expression(canvas, [])]), Statement(}, []), Statement(if (AUTO_REDRAW_HACK && mAutoRedraw) {, []), Statement(invalidate(), []), Statement(}, []), Statement(}, [])])  Statement({, [])  Statement(// if mNativeClass is 0, the WebView has been destroyed. Do nothing., [])  AssignmentExpression(=, [VariableReference(if (mNativeClass, []), Expression(, [])])    VariableReference(if (mNativeClass, [])    Expression(, [])  Statement(return, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(int saveCount, []), Expression(canvas.save(), [])])    VariableReference(int saveCount, [])    Expression(canvas.save(), [])  AssignmentExpression(=, [VariableReference(if (mTitleBar !, []), Expression(null) {, [])])    VariableReference(if (mTitleBar !, [])    Expression(null) {, [])  MethodCall(canvas.translate(0, (int) mTitleBar.getHeight()), [VariableReference(canvas, []), Expression(0, []), Expression((int) mTitleBar.getHeight(), [])])    VariableReference(canvas, [])    Expression(0, [])    Expression((int) mTitleBar.getHeight(), [])  Statement(}, [])  Statement(// Update the buttons in the picture, so when we draw the picture, [])  Statement(// to the screen, they are in the correct state., [])  Statement(// Tell the native side if user is a) touching the screen,, [])  Statement(// b) pressing the trackball down, or c) pressing the enter key, [])  Statement(// If the cursor is on a button, we need to draw it in the pressed, [])  Statement(// state., [])  Statement(// If mNativeClass is 0, we should not reach here, so we do not, [])  Statement(// need to check it again., [])  AssignmentExpression(=, [VariableReference(nativeRecordButtons(hasFocus() && hasWindowFocus(), mTouchMode, []), Expression(, [])])    VariableReference(nativeRecordButtons(hasFocus() && hasWindowFocus(), mTouchMode, [])    Expression(, [])  Statement(drawCoreAndCursorRing(canvas, mBackgroundColor, mDrawCursorRing), [])  MethodCall(canvas.restoreToCount(saveCount), [VariableReference(canvas, []), Expression(saveCount, [])])    VariableReference(canvas, [])    Expression(saveCount, [])  Statement(// Now draw the shadow., [])  AssignmentExpression(=, [VariableReference(if (mTitleBar !, []), Expression(null) {, [])])    VariableReference(if (mTitleBar !, [])    Expression(null) {, [])  AssignmentExpression(=, [VariableReference(int y, []), Expression(mScrollY + getVisibleTitleHeight(), [])])    VariableReference(int y, [])    Expression(mScrollY + getVisibleTitleHeight(), [])  AssignmentExpression(=, [VariableReference(int height, []), Expression((int) (5f * getContext().getResources().getDisplayMetrics().density), [])])    VariableReference(int height, [])    Expression((int) (5f * getContext().getResources().getDisplayMetrics().density), [])  MethodCall(mTitleShadow.setBounds(mScrollX, y, mScrollX + getWidth(), y + height), [VariableReference(mTitleShadow, []), Expression(mScrollX, []), Expression(y, []), Expression(mScrollX + getWidth(), []), Expression(y + height, [])])    VariableReference(mTitleShadow, [])    Expression(mScrollX, [])    Expression(y, [])    Expression(mScrollX + getWidth(), [])    Expression(y + height, [])  MethodCall(mTitleShadow.draw(canvas), [VariableReference(mTitleShadow, []), Expression(canvas, [])])    VariableReference(mTitleShadow, [])    Expression(canvas, [])  Statement(}, [])  Statement(if (AUTO_REDRAW_HACK && mAutoRedraw) {, [])  Statement(invalidate(), [])  Statement(}, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(// if mNativeClass is 0, the WebView has been destroyed. Do nothing., []), AssignmentExpression(=, [VariableReference(if (mNativeClass, []), Expression(, [])]), Statement(return, []), Statement(}, []), AssignmentExpression(=, [VariableReference(int saveCount, []), Expression(canvas.save(), [])]), AssignmentExpression(=, [VariableReference(if (mTitleBar !, []), Expression(null) {, [])]), MethodCall(canvas.translate(0, (int) mTitleBar.getHeight()), [VariableReference(canvas, []), Expression(0, []), Expression((int) mTitleBar.getHeight(), [])]), Statement(}, []), AssignmentExpression(=, [VariableReference(if (mDragTrackerHandler, []), Expression(, [])]), Statement(drawContent(canvas), []), Statement(}, []), MethodCall(canvas.restoreToCount(saveCount), [VariableReference(canvas, []), Expression(saveCount, [])]), Statement(// Now draw the shadow., []), AssignmentExpression(=, [VariableReference(if (mTitleBar !, []), Expression(null) {, [])]), AssignmentExpression(=, [VariableReference(int y, []), Expression(mScrollY + getVisibleTitleHeight(), [])]), AssignmentExpression(=, [VariableReference(int height, []), Expression((int) (5f * getContext().getResources().getDisplayMetrics().density), [])]), MethodCall(mTitleShadow.setBounds(mScrollX, y, mScrollX + getWidth(), y + height), [VariableReference(mTitleShadow, []), Expression(mScrollX, []), Expression(y, []), Expression(mScrollX + getWidth(), []), Expression(y + height, [])]), MethodCall(mTitleShadow.draw(canvas), [VariableReference(mTitleShadow, []), Expression(canvas, [])]), Statement(}, []), Statement(if (AUTO_REDRAW_HACK && mAutoRedraw) {, []), Statement(invalidate(), []), Statement(}, []), Statement(}, [])])  Statement({, [])  Statement(// if mNativeClass is 0, the WebView has been destroyed. Do nothing., [])  AssignmentExpression(=, [VariableReference(if (mNativeClass, []), Expression(, [])])    VariableReference(if (mNativeClass, [])    Expression(, [])  Statement(return, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(int saveCount, []), Expression(canvas.save(), [])])    VariableReference(int saveCount, [])    Expression(canvas.save(), [])  AssignmentExpression(=, [VariableReference(if (mTitleBar !, []), Expression(null) {, [])])    VariableReference(if (mTitleBar !, [])    Expression(null) {, [])  MethodCall(canvas.translate(0, (int) mTitleBar.getHeight()), [VariableReference(canvas, []), Expression(0, []), Expression((int) mTitleBar.getHeight(), [])])    VariableReference(canvas, [])    Expression(0, [])    Expression((int) mTitleBar.getHeight(), [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(if (mDragTrackerHandler, []), Expression(, [])])    VariableReference(if (mDragTrackerHandler, [])    Expression(, [])  Statement(drawContent(canvas), [])  Statement(}, [])  MethodCall(canvas.restoreToCount(saveCount), [VariableReference(canvas, []), Expression(saveCount, [])])    VariableReference(canvas, [])    Expression(saveCount, [])  Statement(// Now draw the shadow., [])  AssignmentExpression(=, [VariableReference(if (mTitleBar !, []), Expression(null) {, [])])    VariableReference(if (mTitleBar !, [])    Expression(null) {, [])  AssignmentExpression(=, [VariableReference(int y, []), Expression(mScrollY + getVisibleTitleHeight(), [])])    VariableReference(int y, [])    Expression(mScrollY + getVisibleTitleHeight(), [])  AssignmentExpression(=, [VariableReference(int height, []), Expression((int) (5f * getContext().getResources().getDisplayMetrics().density), [])])    VariableReference(int height, [])    Expression((int) (5f * getContext().getResources().getDisplayMetrics().density), [])  MethodCall(mTitleShadow.setBounds(mScrollX, y, mScrollX + getWidth(), y + height), [VariableReference(mTitleShadow, []), Expression(mScrollX, []), Expression(y, []), Expression(mScrollX + getWidth(), []), Expression(y + height, [])])    VariableReference(mTitleShadow, [])    Expression(mScrollX, [])    Expression(y, [])    Expression(mScrollX + getWidth(), [])    Expression(y + height, [])  MethodCall(mTitleShadow.draw(canvas), [VariableReference(mTitleShadow, []), Expression(canvas, [])])    VariableReference(mTitleShadow, [])    Expression(canvas, [])  Statement(}, [])  Statement(if (AUTO_REDRAW_HACK && mAutoRedraw) {, [])  Statement(invalidate(), [])  Statement(}, [])  Statement(}, [])",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,"3,4",0,3,1,"The statement `AssignmentExpression(=, [VariableReference(if (mDragTrackerHandler, []), Expression(, [])])` and `Statement(drawContent(canvas), [])` have been introduced, while the statements related to `nativeRecordButtons()` and `drawCoreAndCursorRing()` were removed in the late implementation. Only control statements, such as 'if' and 'method call', are changed. Thus the code change type is 3.","Due to the control dependency changes, the flow of the function has been altered and this could lead to different drawing operations which can potentially affect the return value of the function in terms of visual representation. Thus, the CI type is 1."
583,<android.app.ActivityThread.PackageInfo: ClassLoader getClassLoader()>,7,8,<android.app.ActivityThread.PackageInfo: ClassLoader getClassLoader()>,<android.app.ActivityThread.PackageInfo: ClassLoader getClassLoader()>,0,"MethodDeclaration(method_body, [Statement({, []), Statement(synchronized (this) {, []), AssignmentExpression(=, [VariableReference(if (mClassLoader !, []), Expression(null) {, [])]), Statement(return mClassLoader, []), Statement(}, []), MethodCall(if (mIncludeCode && !mPackageName.equals(""android"")), [VariableReference(if (mIncludeCode && !mPackageName, []), Expression(""android""), [])]), AssignmentExpression(=, [VariableReference(String zip, []), Expression(mAppDir, [])]), Statement(/*, []), Statement(* The following is a bit of a hack to inject, []), Statement(* instrumentation into the system: If the app, []), Statement(* being started matches one of the instrumentation names,, []), Statement(* then we combine both the ""instrumentation"" and, []), Statement(* ""instrumented"" app into the path, along with the, []), Statement(* concatenation of both apps' shared library lists., []), Statement(*/, []), AssignmentExpression(=, [VariableReference(String instrumentationAppDir, []), Expression(mActivityThread.mInstrumentationAppDir, [])]), AssignmentExpression(=, [VariableReference(String instrumentationAppPackage, []), Expression(mActivityThread.mInstrumentationAppPackage, [])]), AssignmentExpression(=, [VariableReference(String instrumentedAppDir, []), Expression(mActivityThread.mInstrumentedAppDir, [])]), AssignmentExpression(=, [VariableReference(String[] instrumentationLibs, []), Expression(null, [])]), MethodCall(if (mAppDir.equals(instrumentationAppDir) || mAppDir.equals(instrumentedAppDir)), [VariableReference(if (mAppDir, []), Expression(instrumentationAppDir) || mAppDir.equals(instrumentedAppDir), [])]), AssignmentExpression(=, [VariableReference(zip, []), Expression(instrumentationAppDir + "":"" + instrumentedAppDir, [])]), MethodCall(if (!instrumentedAppDir.equals(instrumentationAppDir)), [VariableReference(if (!instrumentedAppDir, []), Expression(instrumentationAppDir), [])]), AssignmentExpression(=, [VariableReference(instrumentationLibs, []), Expression(getLibrariesFor(instrumentationAppPackage), [])]), Statement(}, []), Statement(}, []), AssignmentExpression(=, [VariableReference(if ((mSharedLibraries !, []), Expression(null) || (instrumentationLibs !, [])]), AssignmentExpression(=, [VariableReference(zip, []), Expression(combineLibs(mSharedLibraries, instrumentationLibs) + ':' + zip, [])]), Statement(}, []), Statement(if (localLOGV), []), MethodCall(Log.v(TAG, ""Class path: "" + zip), [VariableReference(Log, []), Expression(TAG, []), Expression(""Class path: "" + zip, [])]), AssignmentExpression(=, [VariableReference(mClassLoader, []), Expression(ApplicationLoaders.getDefault().getClassLoader(zip, mDataDir, mBaseClassLoader), [])]), Statement(} else {, []), AssignmentExpression(=, [VariableReference(if (mBaseClassLoader, []), Expression(, [])]), AssignmentExpression(=, [VariableReference(mClassLoader, []), Expression(ClassLoader.getSystemClassLoader(), [])]), Statement(} else {, []), AssignmentExpression(=, [VariableReference(mClassLoader, []), Expression(mBaseClassLoader, [])]), Statement(}, []), Statement(}, []), Statement(return mClassLoader, []), Statement(}, []), Statement(}, [])])  Statement({, [])  Statement(synchronized (this) {, [])  AssignmentExpression(=, [VariableReference(if (mClassLoader !, []), Expression(null) {, [])])    VariableReference(if (mClassLoader !, [])    Expression(null) {, [])  Statement(return mClassLoader, [])  Statement(}, [])  MethodCall(if (mIncludeCode && !mPackageName.equals(""android"")), [VariableReference(if (mIncludeCode && !mPackageName, []), Expression(""android""), [])])    VariableReference(if (mIncludeCode && !mPackageName, [])    Expression(""android""), [])  AssignmentExpression(=, [VariableReference(String zip, []), Expression(mAppDir, [])])    VariableReference(String zip, [])    Expression(mAppDir, [])  Statement(/*, [])  Statement(* The following is a bit of a hack to inject, [])  Statement(* instrumentation into the system: If the app, [])  Statement(* being started matches one of the instrumentation names,, [])  Statement(* then we combine both the ""instrumentation"" and, [])  Statement(* ""instrumented"" app into the path, along with the, [])  Statement(* concatenation of both apps' shared library lists., [])  Statement(*/, [])  AssignmentExpression(=, [VariableReference(String instrumentationAppDir, []), Expression(mActivityThread.mInstrumentationAppDir, [])])    VariableReference(String instrumentationAppDir, [])    Expression(mActivityThread.mInstrumentationAppDir, [])  AssignmentExpression(=, [VariableReference(String instrumentationAppPackage, []), Expression(mActivityThread.mInstrumentationAppPackage, [])])    VariableReference(String instrumentationAppPackage, [])    Expression(mActivityThread.mInstrumentationAppPackage, [])  AssignmentExpression(=, [VariableReference(String instrumentedAppDir, []), Expression(mActivityThread.mInstrumentedAppDir, [])])    VariableReference(String instrumentedAppDir, [])    Expression(mActivityThread.mInstrumentedAppDir, [])  AssignmentExpression(=, [VariableReference(String[] instrumentationLibs, []), Expression(null, [])])    VariableReference(String[] instrumentationLibs, [])    Expression(null, [])  MethodCall(if (mAppDir.equals(instrumentationAppDir) || mAppDir.equals(instrumentedAppDir)), [VariableReference(if (mAppDir, []), Expression(instrumentationAppDir) || mAppDir.equals(instrumentedAppDir), [])])    VariableReference(if (mAppDir, [])    Expression(instrumentationAppDir) || mAppDir.equals(instrumentedAppDir), [])  AssignmentExpression(=, [VariableReference(zip, []), Expression(instrumentationAppDir + "":"" + instrumentedAppDir, [])])    VariableReference(zip, [])    Expression(instrumentationAppDir + "":"" + instrumentedAppDir, [])  MethodCall(if (!instrumentedAppDir.equals(instrumentationAppDir)), [VariableReference(if (!instrumentedAppDir, []), Expression(instrumentationAppDir), [])])    VariableReference(if (!instrumentedAppDir, [])    Expression(instrumentationAppDir), [])  AssignmentExpression(=, [VariableReference(instrumentationLibs, []), Expression(getLibrariesFor(instrumentationAppPackage), [])])    VariableReference(instrumentationLibs, [])    Expression(getLibrariesFor(instrumentationAppPackage), [])  Statement(}, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(if ((mSharedLibraries !, []), Expression(null) || (instrumentationLibs !, [])])    VariableReference(if ((mSharedLibraries !, [])    Expression(null) || (instrumentationLibs !, [])  AssignmentExpression(=, [VariableReference(zip, []), Expression(combineLibs(mSharedLibraries, instrumentationLibs) + ':' + zip, [])])    VariableReference(zip, [])    Expression(combineLibs(mSharedLibraries, instrumentationLibs) + ':' + zip, [])  Statement(}, [])  Statement(if (localLOGV), [])  MethodCall(Log.v(TAG, ""Class path: "" + zip), [VariableReference(Log, []), Expression(TAG, []), Expression(""Class path: "" + zip, [])])    VariableReference(Log, [])    Expression(TAG, [])    Expression(""Class path: "" + zip, [])  AssignmentExpression(=, [VariableReference(mClassLoader, []), Expression(ApplicationLoaders.getDefault().getClassLoader(zip, mDataDir, mBaseClassLoader), [])])    VariableReference(mClassLoader, [])    Expression(ApplicationLoaders.getDefault().getClassLoader(zip, mDataDir, mBaseClassLoader), [])  Statement(} else {, [])  AssignmentExpression(=, [VariableReference(if (mBaseClassLoader, []), Expression(, [])])    VariableReference(if (mBaseClassLoader, [])    Expression(, [])  AssignmentExpression(=, [VariableReference(mClassLoader, []), Expression(ClassLoader.getSystemClassLoader(), [])])    VariableReference(mClassLoader, [])    Expression(ClassLoader.getSystemClassLoader(), [])  Statement(} else {, [])  AssignmentExpression(=, [VariableReference(mClassLoader, []), Expression(mBaseClassLoader, [])])    VariableReference(mClassLoader, [])    Expression(mBaseClassLoader, [])  Statement(}, [])  Statement(}, [])  Statement(return mClassLoader, [])  Statement(}, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(synchronized (this) {, []), AssignmentExpression(=, [VariableReference(if (mClassLoader !, []), Expression(null) {, [])]), Statement(return mClassLoader, []), Statement(}, []), MethodCall(if (mIncludeCode && !mPackageName.equals(""android"")), [VariableReference(if (mIncludeCode && !mPackageName, []), Expression(""android""), [])]), AssignmentExpression(=, [VariableReference(String zip, []), Expression(mAppDir, [])]), Statement(/*, []), Statement(* The following is a bit of a hack to inject, []), Statement(* instrumentation into the system: If the app, []), Statement(* being started matches one of the instrumentation names,, []), Statement(* then we combine both the ""instrumentation"" and, []), Statement(* ""instrumented"" app into the path, along with the, []), Statement(* concatenation of both apps' shared library lists., []), Statement(*/, []), AssignmentExpression(=, [VariableReference(String instrumentationAppDir, []), Expression(mActivityThread.mInstrumentationAppDir, [])]), AssignmentExpression(=, [VariableReference(String instrumentationAppPackage, []), Expression(mActivityThread.mInstrumentationAppPackage, [])]), AssignmentExpression(=, [VariableReference(String instrumentedAppDir, []), Expression(mActivityThread.mInstrumentedAppDir, [])]), AssignmentExpression(=, [VariableReference(String[] instrumentationLibs, []), Expression(null, [])]), MethodCall(if (mAppDir.equals(instrumentationAppDir) || mAppDir.equals(instrumentedAppDir)), [VariableReference(if (mAppDir, []), Expression(instrumentationAppDir) || mAppDir.equals(instrumentedAppDir), [])]), AssignmentExpression(=, [VariableReference(zip, []), Expression(instrumentationAppDir + "":"" + instrumentedAppDir, [])]), MethodCall(if (!instrumentedAppDir.equals(instrumentationAppDir)), [VariableReference(if (!instrumentedAppDir, []), Expression(instrumentationAppDir), [])]), AssignmentExpression(=, [VariableReference(instrumentationLibs, []), Expression(getLibrariesFor(instrumentationAppPackage), [])]), Statement(}, []), Statement(}, []), AssignmentExpression(=, [VariableReference(if ((mSharedLibraries !, []), Expression(null) || (instrumentationLibs !, [])]), AssignmentExpression(=, [VariableReference(zip, []), Expression(combineLibs(mSharedLibraries, instrumentationLibs) + ':' + zip, [])]), Statement(}, []), Statement(if (localLOGV), []), MethodCall(Slog.v(TAG, ""Class path: "" + zip), [VariableReference(Slog, []), Expression(TAG, []), Expression(""Class path: "" + zip, [])]), AssignmentExpression(=, [VariableReference(mClassLoader, []), Expression(ApplicationLoaders.getDefault().getClassLoader(zip, mDataDir, mBaseClassLoader), [])]), Statement(initializeJavaContextClassLoader(), []), Statement(} else {, []), AssignmentExpression(=, [VariableReference(if (mBaseClassLoader, []), Expression(, [])]), AssignmentExpression(=, [VariableReference(mClassLoader, []), Expression(ClassLoader.getSystemClassLoader(), [])]), Statement(} else {, []), AssignmentExpression(=, [VariableReference(mClassLoader, []), Expression(mBaseClassLoader, [])]), Statement(}, []), Statement(}, []), Statement(return mClassLoader, []), Statement(}, []), Statement(}, [])])  Statement({, [])  Statement(synchronized (this) {, [])  AssignmentExpression(=, [VariableReference(if (mClassLoader !, []), Expression(null) {, [])])    VariableReference(if (mClassLoader !, [])    Expression(null) {, [])  Statement(return mClassLoader, [])  Statement(}, [])  MethodCall(if (mIncludeCode && !mPackageName.equals(""android"")), [VariableReference(if (mIncludeCode && !mPackageName, []), Expression(""android""), [])])    VariableReference(if (mIncludeCode && !mPackageName, [])    Expression(""android""), [])  AssignmentExpression(=, [VariableReference(String zip, []), Expression(mAppDir, [])])    VariableReference(String zip, [])    Expression(mAppDir, [])  Statement(/*, [])  Statement(* The following is a bit of a hack to inject, [])  Statement(* instrumentation into the system: If the app, [])  Statement(* being started matches one of the instrumentation names,, [])  Statement(* then we combine both the ""instrumentation"" and, [])  Statement(* ""instrumented"" app into the path, along with the, [])  Statement(* concatenation of both apps' shared library lists., [])  Statement(*/, [])  AssignmentExpression(=, [VariableReference(String instrumentationAppDir, []), Expression(mActivityThread.mInstrumentationAppDir, [])])    VariableReference(String instrumentationAppDir, [])    Expression(mActivityThread.mInstrumentationAppDir, [])  AssignmentExpression(=, [VariableReference(String instrumentationAppPackage, []), Expression(mActivityThread.mInstrumentationAppPackage, [])])    VariableReference(String instrumentationAppPackage, [])    Expression(mActivityThread.mInstrumentationAppPackage, [])  AssignmentExpression(=, [VariableReference(String instrumentedAppDir, []), Expression(mActivityThread.mInstrumentedAppDir, [])])    VariableReference(String instrumentedAppDir, [])    Expression(mActivityThread.mInstrumentedAppDir, [])  AssignmentExpression(=, [VariableReference(String[] instrumentationLibs, []), Expression(null, [])])    VariableReference(String[] instrumentationLibs, [])    Expression(null, [])  MethodCall(if (mAppDir.equals(instrumentationAppDir) || mAppDir.equals(instrumentedAppDir)), [VariableReference(if (mAppDir, []), Expression(instrumentationAppDir) || mAppDir.equals(instrumentedAppDir), [])])    VariableReference(if (mAppDir, [])    Expression(instrumentationAppDir) || mAppDir.equals(instrumentedAppDir), [])  AssignmentExpression(=, [VariableReference(zip, []), Expression(instrumentationAppDir + "":"" + instrumentedAppDir, [])])    VariableReference(zip, [])    Expression(instrumentationAppDir + "":"" + instrumentedAppDir, [])  MethodCall(if (!instrumentedAppDir.equals(instrumentationAppDir)), [VariableReference(if (!instrumentedAppDir, []), Expression(instrumentationAppDir), [])])    VariableReference(if (!instrumentedAppDir, [])    Expression(instrumentationAppDir), [])  AssignmentExpression(=, [VariableReference(instrumentationLibs, []), Expression(getLibrariesFor(instrumentationAppPackage), [])])    VariableReference(instrumentationLibs, [])    Expression(getLibrariesFor(instrumentationAppPackage), [])  Statement(}, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(if ((mSharedLibraries !, []), Expression(null) || (instrumentationLibs !, [])])    VariableReference(if ((mSharedLibraries !, [])    Expression(null) || (instrumentationLibs !, [])  AssignmentExpression(=, [VariableReference(zip, []), Expression(combineLibs(mSharedLibraries, instrumentationLibs) + ':' + zip, [])])    VariableReference(zip, [])    Expression(combineLibs(mSharedLibraries, instrumentationLibs) + ':' + zip, [])  Statement(}, [])  Statement(if (localLOGV), [])  MethodCall(Slog.v(TAG, ""Class path: "" + zip), [VariableReference(Slog, []), Expression(TAG, []), Expression(""Class path: "" + zip, [])])    VariableReference(Slog, [])    Expression(TAG, [])    Expression(""Class path: "" + zip, [])  AssignmentExpression(=, [VariableReference(mClassLoader, []), Expression(ApplicationLoaders.getDefault().getClassLoader(zip, mDataDir, mBaseClassLoader), [])])    VariableReference(mClassLoader, [])    Expression(ApplicationLoaders.getDefault().getClassLoader(zip, mDataDir, mBaseClassLoader), [])  Statement(initializeJavaContextClassLoader(), [])  Statement(} else {, [])  AssignmentExpression(=, [VariableReference(if (mBaseClassLoader, []), Expression(, [])])    VariableReference(if (mBaseClassLoader, [])    Expression(, [])  AssignmentExpression(=, [VariableReference(mClassLoader, []), Expression(ClassLoader.getSystemClassLoader(), [])])    VariableReference(mClassLoader, [])    Expression(ClassLoader.getSystemClassLoader(), [])  Statement(} else {, [])  AssignmentExpression(=, [VariableReference(mClassLoader, []), Expression(mBaseClassLoader, [])])    VariableReference(mClassLoader, [])    Expression(mBaseClassLoader, [])  Statement(}, [])  Statement(}, [])  Statement(return mClassLoader, [])  Statement(}, [])  Statement(}, [])",1,,,-1,,,-1,-1,-1,-1,-1,4,1,4,0,"The method call `initializeJavaContextClassLoader()` has been added before returning `mClassLoader` in the late implementation, which is categorized as other statement changed (type 4).","The added `initializeJavaContextClassLoader()` method call doesn't appear to impact the returning of `mClassLoader` directly or the exception handling. Therefore, no compatibility issue exists (CI type 0)."
1032,<android.animation.AnimatorSet: void setStartDelay(long)>,25,26,<android.animation.AnimatorSet: void setStartDelay(long)>,<android.animation.AnimatorSet: void setStartDelay(long)>,0,"MethodDeclaration(method_body, [Statement({, []), Statement(// Clamp start delay to non-negative range., []), Statement(if (startDelay < 0) {, []), MethodCall(Log.w(TAG, ""Start delay should always be non-negative""), [VariableReference(Log, []), Expression(TAG, []), Expression(""Start delay should always be non-negative"", [])]), AssignmentExpression(=, [VariableReference(startDelay, []), Expression(0, [])]), Statement(}, []), AssignmentExpression(=, [VariableReference(long delta, []), Expression(startDelay - mStartDelay, [])]), AssignmentExpression(=, [VariableReference(if (delta, []), Expression(, [])]), Statement(return, []), Statement(}, []), AssignmentExpression(=, [VariableReference(mStartDelay, []), Expression(startDelay, [])]), Statement(if (mStartDelay > 0) {, []), AssignmentExpression(=, [VariableReference(mReversible, []), Expression(false, [])]), Statement(}, []), Statement(if (!mDependencyDirty) {, []), Statement(// Dependency graph already constructed, update all the nodes' start/end time, []), AssignmentExpression(=, [VariableReference(int size, []), Expression(mNodes.size(), [])]), AssignmentExpression(=, [VariableReference(for (int i, []), Expression(0, [])]), Statement(i < size, []), Statement(i++) {, []), AssignmentExpression(=, [VariableReference(Node node, []), Expression(mNodes.get(i), [])]), AssignmentExpression(=, [VariableReference(if (node, []), Expression(, [])]), AssignmentExpression(=, [VariableReference(node.mEndTime, []), Expression(mStartDelay, [])]), Statement(} else {, []), AssignmentExpression(=, [VariableReference(node.mStartTime, []), Expression(node.mStartTime, [])]), AssignmentExpression(=, [VariableReference(node.mEndTime, []), Expression(node.mEndTime, [])]), Statement(}, []), Statement(}, []), Statement(// Update total duration, if necessary., []), AssignmentExpression(=, [VariableReference(if (mTotalDuration !, []), Expression(DURATION_INFINITE) {, [])]), AssignmentExpression(=, [VariableReference(mTotalDuration +, []), Expression(delta, [])]), Statement(}, []), Statement(}, []), Statement(}, [])])  Statement({, [])  Statement(// Clamp start delay to non-negative range., [])  Statement(if (startDelay < 0) {, [])  MethodCall(Log.w(TAG, ""Start delay should always be non-negative""), [VariableReference(Log, []), Expression(TAG, []), Expression(""Start delay should always be non-negative"", [])])    VariableReference(Log, [])    Expression(TAG, [])    Expression(""Start delay should always be non-negative"", [])  AssignmentExpression(=, [VariableReference(startDelay, []), Expression(0, [])])    VariableReference(startDelay, [])    Expression(0, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(long delta, []), Expression(startDelay - mStartDelay, [])])    VariableReference(long delta, [])    Expression(startDelay - mStartDelay, [])  AssignmentExpression(=, [VariableReference(if (delta, []), Expression(, [])])    VariableReference(if (delta, [])    Expression(, [])  Statement(return, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(mStartDelay, []), Expression(startDelay, [])])    VariableReference(mStartDelay, [])    Expression(startDelay, [])  Statement(if (mStartDelay > 0) {, [])  AssignmentExpression(=, [VariableReference(mReversible, []), Expression(false, [])])    VariableReference(mReversible, [])    Expression(false, [])  Statement(}, [])  Statement(if (!mDependencyDirty) {, [])  Statement(// Dependency graph already constructed, update all the nodes' start/end time, [])  AssignmentExpression(=, [VariableReference(int size, []), Expression(mNodes.size(), [])])    VariableReference(int size, [])    Expression(mNodes.size(), [])  AssignmentExpression(=, [VariableReference(for (int i, []), Expression(0, [])])    VariableReference(for (int i, [])    Expression(0, [])  Statement(i < size, [])  Statement(i++) {, [])  AssignmentExpression(=, [VariableReference(Node node, []), Expression(mNodes.get(i), [])])    VariableReference(Node node, [])    Expression(mNodes.get(i), [])  AssignmentExpression(=, [VariableReference(if (node, []), Expression(, [])])    VariableReference(if (node, [])    Expression(, [])  AssignmentExpression(=, [VariableReference(node.mEndTime, []), Expression(mStartDelay, [])])    VariableReference(node.mEndTime, [])    Expression(mStartDelay, [])  Statement(} else {, [])  AssignmentExpression(=, [VariableReference(node.mStartTime, []), Expression(node.mStartTime, [])])    VariableReference(node.mStartTime, [])    Expression(node.mStartTime, [])  AssignmentExpression(=, [VariableReference(node.mEndTime, []), Expression(node.mEndTime, [])])    VariableReference(node.mEndTime, [])    Expression(node.mEndTime, [])  Statement(}, [])  Statement(}, [])  Statement(// Update total duration, if necessary., [])  AssignmentExpression(=, [VariableReference(if (mTotalDuration !, []), Expression(DURATION_INFINITE) {, [])])    VariableReference(if (mTotalDuration !, [])    Expression(DURATION_INFINITE) {, [])  AssignmentExpression(=, [VariableReference(mTotalDuration +, []), Expression(delta, [])])    VariableReference(mTotalDuration +, [])    Expression(delta, [])  Statement(}, [])  Statement(}, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(// Clamp start delay to non-negative range., []), Statement(if (startDelay < 0) {, []), MethodCall(Log.w(TAG, ""Start delay should always be non-negative""), [VariableReference(Log, []), Expression(TAG, []), Expression(""Start delay should always be non-negative"", [])]), AssignmentExpression(=, [VariableReference(startDelay, []), Expression(0, [])]), Statement(}, []), AssignmentExpression(=, [VariableReference(long delta, []), Expression(startDelay - mStartDelay, [])]), AssignmentExpression(=, [VariableReference(if (delta, []), Expression(, [])]), Statement(return, []), Statement(}, []), AssignmentExpression(=, [VariableReference(mStartDelay, []), Expression(startDelay, [])]), Statement(if (!mDependencyDirty) {, []), Statement(// Dependency graph already constructed, update all the nodes' start/end time, []), AssignmentExpression(=, [VariableReference(int size, []), Expression(mNodes.size(), [])]), AssignmentExpression(=, [VariableReference(for (int i, []), Expression(0, [])]), Statement(i < size, []), Statement(i++) {, []), AssignmentExpression(=, [VariableReference(Node node, []), Expression(mNodes.get(i), [])]), AssignmentExpression(=, [VariableReference(if (node, []), Expression(, [])]), AssignmentExpression(=, [VariableReference(node.mEndTime, []), Expression(mStartDelay, [])]), Statement(} else {, []), AssignmentExpression(=, [VariableReference(node.mStartTime, []), Expression(node.mStartTime, [])]), AssignmentExpression(=, [VariableReference(node.mEndTime, []), Expression(node.mEndTime, [])]), Statement(}, []), Statement(}, []), Statement(// Update total duration, if necessary., []), AssignmentExpression(=, [VariableReference(if (mTotalDuration !, []), Expression(DURATION_INFINITE) {, [])]), AssignmentExpression(=, [VariableReference(mTotalDuration +, []), Expression(delta, [])]), Statement(}, []), Statement(}, []), Statement(}, [])])  Statement({, [])  Statement(// Clamp start delay to non-negative range., [])  Statement(if (startDelay < 0) {, [])  MethodCall(Log.w(TAG, ""Start delay should always be non-negative""), [VariableReference(Log, []), Expression(TAG, []), Expression(""Start delay should always be non-negative"", [])])    VariableReference(Log, [])    Expression(TAG, [])    Expression(""Start delay should always be non-negative"", [])  AssignmentExpression(=, [VariableReference(startDelay, []), Expression(0, [])])    VariableReference(startDelay, [])    Expression(0, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(long delta, []), Expression(startDelay - mStartDelay, [])])    VariableReference(long delta, [])    Expression(startDelay - mStartDelay, [])  AssignmentExpression(=, [VariableReference(if (delta, []), Expression(, [])])    VariableReference(if (delta, [])    Expression(, [])  Statement(return, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(mStartDelay, []), Expression(startDelay, [])])    VariableReference(mStartDelay, [])    Expression(startDelay, [])  Statement(if (!mDependencyDirty) {, [])  Statement(// Dependency graph already constructed, update all the nodes' start/end time, [])  AssignmentExpression(=, [VariableReference(int size, []), Expression(mNodes.size(), [])])    VariableReference(int size, [])    Expression(mNodes.size(), [])  AssignmentExpression(=, [VariableReference(for (int i, []), Expression(0, [])])    VariableReference(for (int i, [])    Expression(0, [])  Statement(i < size, [])  Statement(i++) {, [])  AssignmentExpression(=, [VariableReference(Node node, []), Expression(mNodes.get(i), [])])    VariableReference(Node node, [])    Expression(mNodes.get(i), [])  AssignmentExpression(=, [VariableReference(if (node, []), Expression(, [])])    VariableReference(if (node, [])    Expression(, [])  AssignmentExpression(=, [VariableReference(node.mEndTime, []), Expression(mStartDelay, [])])    VariableReference(node.mEndTime, [])    Expression(mStartDelay, [])  Statement(} else {, [])  AssignmentExpression(=, [VariableReference(node.mStartTime, []), Expression(node.mStartTime, [])])    VariableReference(node.mStartTime, [])    Expression(node.mStartTime, [])  AssignmentExpression(=, [VariableReference(node.mEndTime, []), Expression(node.mEndTime, [])])    VariableReference(node.mEndTime, [])    Expression(node.mEndTime, [])  Statement(}, [])  Statement(}, [])  Statement(// Update total duration, if necessary., [])  AssignmentExpression(=, [VariableReference(if (mTotalDuration !, []), Expression(DURATION_INFINITE) {, [])])    VariableReference(if (mTotalDuration !, [])    Expression(DURATION_INFINITE) {, [])  AssignmentExpression(=, [VariableReference(mTotalDuration +, []), Expression(delta, [])])    VariableReference(mTotalDuration +, [])    Expression(delta, [])  Statement(}, [])  Statement(}, [])  Statement(}, [])",1,"/**
 * The amount of time, in milliseconds, to delay starting the animation after
 * {@link #start()} is called. Note that the start delay should always be non-negative. Any
 * negative start delay will be clamped to 0 on N and above.
 *
 * @param startDelay The amount of the delay, in milliseconds
 */
","/**
 * The amount of time, in milliseconds, to delay starting the animation after
 * {@link #start()} is called. Note that the start delay should always be non-negative. Any
 * negative start delay will be clamped to 0 on N and above.
 *
 * @param startDelay The amount of the delay, in milliseconds
 */
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,3,0,3,0,The 'mDependencyDirty' check clause and the contained statements within have been removed from the late implementation. This change falls under control dependency changes (3).,"The removal of the 'mDependencyDirty' check and the associated updates to the nodes' timings and total duration affects internal behavior but does not lead to different return values or different exceptions being thrown. Therefore, no compatibility issue exists."
193,<android.pim.vcard.VCardComposer.HandlerForOutputStream: boolean onInit(Context)>,8,9,<android.pim.vcard.VCardComposer.HandlerForOutputStream: boolean onInit(Context)>,<android.pim.vcard.VCardComposer.HandlerForOutputStream: boolean onInit(Context)>,0,"MethodDeclaration(method_body, [Statement({, []), Statement(try {, []), AssignmentExpression(=, [VariableReference(mWriter, []), Expression(new BufferedWriter(new OutputStreamWriter(mOutputStream, mCharsetString)), [])]), Statement(} catch (UnsupportedEncodingException e1) {, []), MethodCall(Log.e(LOG_TAG, ""Unsupported charset: "" + mCharsetString), [VariableReference(Log, []), Expression(LOG_TAG, []), Expression(""Unsupported charset: "" + mCharsetString, [])]), AssignmentExpression(=, [VariableReference(mErrorReason, []), Expression(""Encoding is not supported (usually this does not happen!): "" + mCharsetString, [])]), Statement(return false, []), Statement(}, []), Statement(if (mIsDoCoMo) {, []), Statement(try {, []), Statement(// Create one empty entry., []), MethodCall(mWriter.write(createOneEntryInternal(""-1"", null)), [VariableReference(mWriter, []), Expression(createOneEntryInternal(""-1"", []), Expression(null), [])]), Statement(} catch (VCardException e) {, []), MethodCall(Log.e(LOG_TAG, ""VCardException has been thrown during on Init(): "" + e.getMessage()), [VariableReference(Log, []), Expression(LOG_TAG, []), Expression(""VCardException has been thrown during on Init(): "" + e.getMessage(), [])]), Statement(return false, []), Statement(} catch (IOException e) {, []), MethodCall(Log.e(LOG_TAG, ""IOException occurred during exportOneContactData: "" + e.getMessage()), [VariableReference(Log, []), Expression(LOG_TAG, []), Expression(""IOException occurred during exportOneContactData: "" + e.getMessage(), [])]), AssignmentExpression(=, [VariableReference(mErrorReason, []), Expression(""IOException occurred: "" + e.getMessage(), [])]), Statement(return false, []), Statement(}, []), Statement(}, []), Statement(return true, []), Statement(}, [])])  Statement({, [])  Statement(try {, [])  AssignmentExpression(=, [VariableReference(mWriter, []), Expression(new BufferedWriter(new OutputStreamWriter(mOutputStream, mCharsetString)), [])])    VariableReference(mWriter, [])    Expression(new BufferedWriter(new OutputStreamWriter(mOutputStream, mCharsetString)), [])  Statement(} catch (UnsupportedEncodingException e1) {, [])  MethodCall(Log.e(LOG_TAG, ""Unsupported charset: "" + mCharsetString), [VariableReference(Log, []), Expression(LOG_TAG, []), Expression(""Unsupported charset: "" + mCharsetString, [])])    VariableReference(Log, [])    Expression(LOG_TAG, [])    Expression(""Unsupported charset: "" + mCharsetString, [])  AssignmentExpression(=, [VariableReference(mErrorReason, []), Expression(""Encoding is not supported (usually this does not happen!): "" + mCharsetString, [])])    VariableReference(mErrorReason, [])    Expression(""Encoding is not supported (usually this does not happen!): "" + mCharsetString, [])  Statement(return false, [])  Statement(}, [])  Statement(if (mIsDoCoMo) {, [])  Statement(try {, [])  Statement(// Create one empty entry., [])  MethodCall(mWriter.write(createOneEntryInternal(""-1"", null)), [VariableReference(mWriter, []), Expression(createOneEntryInternal(""-1"", []), Expression(null), [])])    VariableReference(mWriter, [])    Expression(createOneEntryInternal(""-1"", [])    Expression(null), [])  Statement(} catch (VCardException e) {, [])  MethodCall(Log.e(LOG_TAG, ""VCardException has been thrown during on Init(): "" + e.getMessage()), [VariableReference(Log, []), Expression(LOG_TAG, []), Expression(""VCardException has been thrown during on Init(): "" + e.getMessage(), [])])    VariableReference(Log, [])    Expression(LOG_TAG, [])    Expression(""VCardException has been thrown during on Init(): "" + e.getMessage(), [])  Statement(return false, [])  Statement(} catch (IOException e) {, [])  MethodCall(Log.e(LOG_TAG, ""IOException occurred during exportOneContactData: "" + e.getMessage()), [VariableReference(Log, []), Expression(LOG_TAG, []), Expression(""IOException occurred during exportOneContactData: "" + e.getMessage(), [])])    VariableReference(Log, [])    Expression(LOG_TAG, [])    Expression(""IOException occurred during exportOneContactData: "" + e.getMessage(), [])  AssignmentExpression(=, [VariableReference(mErrorReason, []), Expression(""IOException occurred: "" + e.getMessage(), [])])    VariableReference(mErrorReason, [])    Expression(""IOException occurred: "" + e.getMessage(), [])  Statement(return false, [])  Statement(}, [])  Statement(}, [])  Statement(return true, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(try {, []), AssignmentExpression(=, [VariableReference(mWriter, []), Expression(new BufferedWriter(new OutputStreamWriter(mOutputStream, mCharset)), [])]), Statement(} catch (UnsupportedEncodingException e1) {, []), MethodCall(Log.e(LOG_TAG, ""Unsupported charset: "" + mCharset), [VariableReference(Log, []), Expression(LOG_TAG, []), Expression(""Unsupported charset: "" + mCharset, [])]), AssignmentExpression(=, [VariableReference(mErrorReason, []), Expression(""Encoding is not supported (usually this does not happen!): "" + mCharset, [])]), Statement(return false, []), Statement(}, []), Statement(if (mIsDoCoMo) {, []), Statement(try {, []), Statement(// Create one empty entry., []), MethodCall(mWriter.write(createOneEntryInternal(""-1"", null)), [VariableReference(mWriter, []), Expression(createOneEntryInternal(""-1"", []), Expression(null), [])]), Statement(} catch (VCardException e) {, []), MethodCall(Log.e(LOG_TAG, ""VCardException has been thrown during on Init(): "" + e.getMessage()), [VariableReference(Log, []), Expression(LOG_TAG, []), Expression(""VCardException has been thrown during on Init(): "" + e.getMessage(), [])]), Statement(return false, []), Statement(} catch (IOException e) {, []), MethodCall(Log.e(LOG_TAG, ""IOException occurred during exportOneContactData: "" + e.getMessage()), [VariableReference(Log, []), Expression(LOG_TAG, []), Expression(""IOException occurred during exportOneContactData: "" + e.getMessage(), [])]), AssignmentExpression(=, [VariableReference(mErrorReason, []), Expression(""IOException occurred: "" + e.getMessage(), [])]), Statement(return false, []), Statement(}, []), Statement(}, []), Statement(return true, []), Statement(}, [])])  Statement({, [])  Statement(try {, [])  AssignmentExpression(=, [VariableReference(mWriter, []), Expression(new BufferedWriter(new OutputStreamWriter(mOutputStream, mCharset)), [])])    VariableReference(mWriter, [])    Expression(new BufferedWriter(new OutputStreamWriter(mOutputStream, mCharset)), [])  Statement(} catch (UnsupportedEncodingException e1) {, [])  MethodCall(Log.e(LOG_TAG, ""Unsupported charset: "" + mCharset), [VariableReference(Log, []), Expression(LOG_TAG, []), Expression(""Unsupported charset: "" + mCharset, [])])    VariableReference(Log, [])    Expression(LOG_TAG, [])    Expression(""Unsupported charset: "" + mCharset, [])  AssignmentExpression(=, [VariableReference(mErrorReason, []), Expression(""Encoding is not supported (usually this does not happen!): "" + mCharset, [])])    VariableReference(mErrorReason, [])    Expression(""Encoding is not supported (usually this does not happen!): "" + mCharset, [])  Statement(return false, [])  Statement(}, [])  Statement(if (mIsDoCoMo) {, [])  Statement(try {, [])  Statement(// Create one empty entry., [])  MethodCall(mWriter.write(createOneEntryInternal(""-1"", null)), [VariableReference(mWriter, []), Expression(createOneEntryInternal(""-1"", []), Expression(null), [])])    VariableReference(mWriter, [])    Expression(createOneEntryInternal(""-1"", [])    Expression(null), [])  Statement(} catch (VCardException e) {, [])  MethodCall(Log.e(LOG_TAG, ""VCardException has been thrown during on Init(): "" + e.getMessage()), [VariableReference(Log, []), Expression(LOG_TAG, []), Expression(""VCardException has been thrown during on Init(): "" + e.getMessage(), [])])    VariableReference(Log, [])    Expression(LOG_TAG, [])    Expression(""VCardException has been thrown during on Init(): "" + e.getMessage(), [])  Statement(return false, [])  Statement(} catch (IOException e) {, [])  MethodCall(Log.e(LOG_TAG, ""IOException occurred during exportOneContactData: "" + e.getMessage()), [VariableReference(Log, []), Expression(LOG_TAG, []), Expression(""IOException occurred during exportOneContactData: "" + e.getMessage(), [])])    VariableReference(Log, [])    Expression(LOG_TAG, [])    Expression(""IOException occurred during exportOneContactData: "" + e.getMessage(), [])  AssignmentExpression(=, [VariableReference(mErrorReason, []), Expression(""IOException occurred: "" + e.getMessage(), [])])    VariableReference(mErrorReason, [])    Expression(""IOException occurred: "" + e.getMessage(), [])  Statement(return false, [])  Statement(}, [])  Statement(}, [])  Statement(return true, [])  Statement(}, [])",1,,,-1,,,-1,-1,-1,-1,-1,4,0,4,0,The variable `mCharset` has replaced `mCharsetString` in the late version. This falls under 'Other statement changed' as only the name of the variable used in method calls has changed.,"The change from `mCharsetString` to `mCharset` would not lead to different return values or exception handling modifications for this API, thus no compatibility issue (CI) exists."
888,"<android.inputmethodservice.InputMethodService: void doStartInput(InputConnection,EditorInfo,boolean)>",29,30,"<android.inputmethodservice.InputMethodService: void doStartInput(InputConnection,EditorInfo,boolean)>","<android.inputmethodservice.InputMethodService: void doStartInput(InputConnection,EditorInfo,boolean)>",0,"MethodDeclaration(method_body, [Statement({, []), Statement(if (!restarting) {, []), Statement(doFinishInput(), []), Statement(}, []), AssignmentExpression(=, [VariableReference(mInputStarted, []), Expression(true, [])]), AssignmentExpression(=, [VariableReference(mStartedInputConnection, []), Expression(ic, [])]), AssignmentExpression(=, [VariableReference(mInputEditorInfo, []), Expression(attribute, [])]), Statement(initialize(), []), Statement(if (DEBUG), []), MethodCall(Log.v(TAG, ""CALL: onStartInput""), [VariableReference(Log, []), Expression(TAG, []), Expression(""CALL: onStartInput"", [])]), Statement(onStartInput(attribute, restarting), []), Statement(if (mDecorViewVisible) {, []), Statement(if (mShowInputRequested) {, []), Statement(if (DEBUG), []), MethodCall(Log.v(TAG, ""CALL: onStartInputView""), [VariableReference(Log, []), Expression(TAG, []), Expression(""CALL: onStartInputView"", [])]), AssignmentExpression(=, [VariableReference(mInputViewStarted, []), Expression(true, [])]), Statement(onStartInputView(mInputEditorInfo, restarting), []), Statement(startExtractingText(true), []), AssignmentExpression(=, [VariableReference(} else if (mCandidatesVisibility, []), Expression(, [])]), Statement(if (DEBUG), []), MethodCall(Log.v(TAG, ""CALL: onStartCandidatesView""), [VariableReference(Log, []), Expression(TAG, []), Expression(""CALL: onStartCandidatesView"", [])]), AssignmentExpression(=, [VariableReference(mCandidatesViewStarted, []), Expression(true, [])]), Statement(onStartCandidatesView(mInputEditorInfo, restarting), []), Statement(}, []), AssignmentExpression(=, [VariableReference(} else if (mCanPreRender && mInputEditorInfo !, []), Expression(null && mStartedInputConnection !, [])]), Statement(// pre-render IME window and keep it invisible., []), Statement(if (DEBUG), []), MethodCall(Log.v(TAG, ""Pre-Render IME for "" + mInputEditorInfo.fieldName), [VariableReference(Log, []), Expression(TAG, []), Expression(""Pre-Render IME for "" + mInputEditorInfo.fieldName, [])]), Statement(if (mInShowWindow) {, []), MethodCall(Log.w(TAG, ""Re-entrance in to showWindow""), [VariableReference(Log, []), Expression(TAG, []), Expression(""Re-entrance in to showWindow"", [])]), Statement(return, []), Statement(}, []), AssignmentExpression(=, [VariableReference(mDecorViewWasVisible, []), Expression(mDecorViewVisible, [])]), AssignmentExpression(=, [VariableReference(mInShowWindow, []), Expression(true, [])]), Statement(startViews(prepareWindow(true)), []), Statement(// compute visibility, []), AssignmentExpression(=, [VariableReference(mIsPreRendered, []), Expression(true, [])]), Statement(onPreRenderedWindowVisibilityChanged(false), []), Statement(// When IME is not pre-rendered, this will actually show the IME., []), Statement(if (DEBUG), []), MethodCall(Log.v(TAG, ""showWindow: draw decorView!""), [VariableReference(Log, []), Expression(TAG, []), Expression(""showWindow: draw decorView!"", [])]), MethodCall(mWindow.show(), [VariableReference(mWindow, []), Expression(, [])]), Statement(maybeNotifyPreRendered(), []), AssignmentExpression(=, [VariableReference(mDecorViewWasVisible, []), Expression(true, [])]), AssignmentExpression(=, [VariableReference(mInShowWindow, []), Expression(false, [])]), Statement(} else {, []), AssignmentExpression(=, [VariableReference(mIsPreRendered, []), Expression(false, [])]), Statement(}, []), Statement(}, [])])  Statement({, [])  Statement(if (!restarting) {, [])  Statement(doFinishInput(), [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(mInputStarted, []), Expression(true, [])])    VariableReference(mInputStarted, [])    Expression(true, [])  AssignmentExpression(=, [VariableReference(mStartedInputConnection, []), Expression(ic, [])])    VariableReference(mStartedInputConnection, [])    Expression(ic, [])  AssignmentExpression(=, [VariableReference(mInputEditorInfo, []), Expression(attribute, [])])    VariableReference(mInputEditorInfo, [])    Expression(attribute, [])  Statement(initialize(), [])  Statement(if (DEBUG), [])  MethodCall(Log.v(TAG, ""CALL: onStartInput""), [VariableReference(Log, []), Expression(TAG, []), Expression(""CALL: onStartInput"", [])])    VariableReference(Log, [])    Expression(TAG, [])    Expression(""CALL: onStartInput"", [])  Statement(onStartInput(attribute, restarting), [])  Statement(if (mDecorViewVisible) {, [])  Statement(if (mShowInputRequested) {, [])  Statement(if (DEBUG), [])  MethodCall(Log.v(TAG, ""CALL: onStartInputView""), [VariableReference(Log, []), Expression(TAG, []), Expression(""CALL: onStartInputView"", [])])    VariableReference(Log, [])    Expression(TAG, [])    Expression(""CALL: onStartInputView"", [])  AssignmentExpression(=, [VariableReference(mInputViewStarted, []), Expression(true, [])])    VariableReference(mInputViewStarted, [])    Expression(true, [])  Statement(onStartInputView(mInputEditorInfo, restarting), [])  Statement(startExtractingText(true), [])  AssignmentExpression(=, [VariableReference(} else if (mCandidatesVisibility, []), Expression(, [])])    VariableReference(} else if (mCandidatesVisibility, [])    Expression(, [])  Statement(if (DEBUG), [])  MethodCall(Log.v(TAG, ""CALL: onStartCandidatesView""), [VariableReference(Log, []), Expression(TAG, []), Expression(""CALL: onStartCandidatesView"", [])])    VariableReference(Log, [])    Expression(TAG, [])    Expression(""CALL: onStartCandidatesView"", [])  AssignmentExpression(=, [VariableReference(mCandidatesViewStarted, []), Expression(true, [])])    VariableReference(mCandidatesViewStarted, [])    Expression(true, [])  Statement(onStartCandidatesView(mInputEditorInfo, restarting), [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(} else if (mCanPreRender && mInputEditorInfo !, []), Expression(null && mStartedInputConnection !, [])])    VariableReference(} else if (mCanPreRender && mInputEditorInfo !, [])    Expression(null && mStartedInputConnection !, [])  Statement(// pre-render IME window and keep it invisible., [])  Statement(if (DEBUG), [])  MethodCall(Log.v(TAG, ""Pre-Render IME for "" + mInputEditorInfo.fieldName), [VariableReference(Log, []), Expression(TAG, []), Expression(""Pre-Render IME for "" + mInputEditorInfo.fieldName, [])])    VariableReference(Log, [])    Expression(TAG, [])    Expression(""Pre-Render IME for "" + mInputEditorInfo.fieldName, [])  Statement(if (mInShowWindow) {, [])  MethodCall(Log.w(TAG, ""Re-entrance in to showWindow""), [VariableReference(Log, []), Expression(TAG, []), Expression(""Re-entrance in to showWindow"", [])])    VariableReference(Log, [])    Expression(TAG, [])    Expression(""Re-entrance in to showWindow"", [])  Statement(return, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(mDecorViewWasVisible, []), Expression(mDecorViewVisible, [])])    VariableReference(mDecorViewWasVisible, [])    Expression(mDecorViewVisible, [])  AssignmentExpression(=, [VariableReference(mInShowWindow, []), Expression(true, [])])    VariableReference(mInShowWindow, [])    Expression(true, [])  Statement(startViews(prepareWindow(true)), [])  Statement(// compute visibility, [])  AssignmentExpression(=, [VariableReference(mIsPreRendered, []), Expression(true, [])])    VariableReference(mIsPreRendered, [])    Expression(true, [])  Statement(onPreRenderedWindowVisibilityChanged(false), [])  Statement(// When IME is not pre-rendered, this will actually show the IME., [])  Statement(if (DEBUG), [])  MethodCall(Log.v(TAG, ""showWindow: draw decorView!""), [VariableReference(Log, []), Expression(TAG, []), Expression(""showWindow: draw decorView!"", [])])    VariableReference(Log, [])    Expression(TAG, [])    Expression(""showWindow: draw decorView!"", [])  MethodCall(mWindow.show(), [VariableReference(mWindow, []), Expression(, [])])    VariableReference(mWindow, [])    Expression(, [])  Statement(maybeNotifyPreRendered(), [])  AssignmentExpression(=, [VariableReference(mDecorViewWasVisible, []), Expression(true, [])])    VariableReference(mDecorViewWasVisible, [])    Expression(true, [])  AssignmentExpression(=, [VariableReference(mInShowWindow, []), Expression(false, [])])    VariableReference(mInShowWindow, [])    Expression(false, [])  Statement(} else {, [])  AssignmentExpression(=, [VariableReference(mIsPreRendered, []), Expression(false, [])])    VariableReference(mIsPreRendered, [])    Expression(false, [])  Statement(}, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(if (!restarting) {, []), Statement(doFinishInput(), []), Statement(}, []), AssignmentExpression(=, [VariableReference(mInputStarted, []), Expression(true, [])]), AssignmentExpression(=, [VariableReference(mStartedInputConnection, []), Expression(ic, [])]), AssignmentExpression(=, [VariableReference(mInputEditorInfo, []), Expression(attribute, [])]), Statement(initialize(), []), AssignmentExpression(=, [VariableReference(mInlineSuggestionSessionController.notifyOnStartInput(attribute, []), Expression(, [])]), Statement(if (DEBUG), []), MethodCall(Log.v(TAG, ""CALL: onStartInput""), [VariableReference(Log, []), Expression(TAG, []), Expression(""CALL: onStartInput"", [])]), Statement(onStartInput(attribute, restarting), []), Statement(if (mDecorViewVisible) {, []), Statement(if (mShowInputRequested) {, []), Statement(if (DEBUG), []), MethodCall(Log.v(TAG, ""CALL: onStartInputView""), [VariableReference(Log, []), Expression(TAG, []), Expression(""CALL: onStartInputView"", [])]), AssignmentExpression(=, [VariableReference(mInputViewStarted, []), Expression(true, [])]), MethodCall(mInlineSuggestionSessionController.notifyOnStartInputView(), [VariableReference(mInlineSuggestionSessionController, []), Expression(, [])]), Statement(onStartInputView(mInputEditorInfo, restarting), []), Statement(startExtractingText(true), []), AssignmentExpression(=, [VariableReference(} else if (mCandidatesVisibility, []), Expression(, [])]), Statement(if (DEBUG), []), MethodCall(Log.v(TAG, ""CALL: onStartCandidatesView""), [VariableReference(Log, []), Expression(TAG, []), Expression(""CALL: onStartCandidatesView"", [])]), AssignmentExpression(=, [VariableReference(mCandidatesViewStarted, []), Expression(true, [])]), Statement(onStartCandidatesView(mInputEditorInfo, restarting), []), Statement(}, []), AssignmentExpression(=, [VariableReference(} else if (mCanPreRender && mInputEditorInfo !, []), Expression(null && mStartedInputConnection !, [])]), Statement(// pre-render IME window and keep it invisible., []), Statement(if (DEBUG), []), MethodCall(Log.v(TAG, ""Pre-Render IME for "" + mInputEditorInfo.fieldName), [VariableReference(Log, []), Expression(TAG, []), Expression(""Pre-Render IME for "" + mInputEditorInfo.fieldName, [])]), Statement(if (mInShowWindow) {, []), MethodCall(Log.w(TAG, ""Re-entrance in to showWindow""), [VariableReference(Log, []), Expression(TAG, []), Expression(""Re-entrance in to showWindow"", [])]), Statement(return, []), Statement(}, []), AssignmentExpression(=, [VariableReference(mDecorViewWasVisible, []), Expression(mDecorViewVisible, [])]), AssignmentExpression(=, [VariableReference(mInShowWindow, []), Expression(true, [])]), Statement(startViews(prepareWindow(true)), []), Statement(// compute visibility, []), AssignmentExpression(=, [VariableReference(mIsPreRendered, []), Expression(true, [])]), Statement(onPreRenderedWindowVisibilityChanged(false), []), Statement(// When IME is not pre-rendered, this will actually show the IME., []), Statement(if (DEBUG), []), MethodCall(Log.v(TAG, ""showWindow: draw decorView!""), [VariableReference(Log, []), Expression(TAG, []), Expression(""showWindow: draw decorView!"", [])]), MethodCall(mWindow.show(), [VariableReference(mWindow, []), Expression(, [])]), Statement(maybeNotifyPreRendered(), []), AssignmentExpression(=, [VariableReference(mDecorViewWasVisible, []), Expression(true, [])]), AssignmentExpression(=, [VariableReference(mInShowWindow, []), Expression(false, [])]), Statement(} else {, []), AssignmentExpression(=, [VariableReference(mIsPreRendered, []), Expression(false, [])]), Statement(}, []), Statement(}, [])])  Statement({, [])  Statement(if (!restarting) {, [])  Statement(doFinishInput(), [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(mInputStarted, []), Expression(true, [])])    VariableReference(mInputStarted, [])    Expression(true, [])  AssignmentExpression(=, [VariableReference(mStartedInputConnection, []), Expression(ic, [])])    VariableReference(mStartedInputConnection, [])    Expression(ic, [])  AssignmentExpression(=, [VariableReference(mInputEditorInfo, []), Expression(attribute, [])])    VariableReference(mInputEditorInfo, [])    Expression(attribute, [])  Statement(initialize(), [])  AssignmentExpression(=, [VariableReference(mInlineSuggestionSessionController.notifyOnStartInput(attribute, []), Expression(, [])])    VariableReference(mInlineSuggestionSessionController.notifyOnStartInput(attribute, [])    Expression(, [])  Statement(if (DEBUG), [])  MethodCall(Log.v(TAG, ""CALL: onStartInput""), [VariableReference(Log, []), Expression(TAG, []), Expression(""CALL: onStartInput"", [])])    VariableReference(Log, [])    Expression(TAG, [])    Expression(""CALL: onStartInput"", [])  Statement(onStartInput(attribute, restarting), [])  Statement(if (mDecorViewVisible) {, [])  Statement(if (mShowInputRequested) {, [])  Statement(if (DEBUG), [])  MethodCall(Log.v(TAG, ""CALL: onStartInputView""), [VariableReference(Log, []), Expression(TAG, []), Expression(""CALL: onStartInputView"", [])])    VariableReference(Log, [])    Expression(TAG, [])    Expression(""CALL: onStartInputView"", [])  AssignmentExpression(=, [VariableReference(mInputViewStarted, []), Expression(true, [])])    VariableReference(mInputViewStarted, [])    Expression(true, [])  MethodCall(mInlineSuggestionSessionController.notifyOnStartInputView(), [VariableReference(mInlineSuggestionSessionController, []), Expression(, [])])    VariableReference(mInlineSuggestionSessionController, [])    Expression(, [])  Statement(onStartInputView(mInputEditorInfo, restarting), [])  Statement(startExtractingText(true), [])  AssignmentExpression(=, [VariableReference(} else if (mCandidatesVisibility, []), Expression(, [])])    VariableReference(} else if (mCandidatesVisibility, [])    Expression(, [])  Statement(if (DEBUG), [])  MethodCall(Log.v(TAG, ""CALL: onStartCandidatesView""), [VariableReference(Log, []), Expression(TAG, []), Expression(""CALL: onStartCandidatesView"", [])])    VariableReference(Log, [])    Expression(TAG, [])    Expression(""CALL: onStartCandidatesView"", [])  AssignmentExpression(=, [VariableReference(mCandidatesViewStarted, []), Expression(true, [])])    VariableReference(mCandidatesViewStarted, [])    Expression(true, [])  Statement(onStartCandidatesView(mInputEditorInfo, restarting), [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(} else if (mCanPreRender && mInputEditorInfo !, []), Expression(null && mStartedInputConnection !, [])])    VariableReference(} else if (mCanPreRender && mInputEditorInfo !, [])    Expression(null && mStartedInputConnection !, [])  Statement(// pre-render IME window and keep it invisible., [])  Statement(if (DEBUG), [])  MethodCall(Log.v(TAG, ""Pre-Render IME for "" + mInputEditorInfo.fieldName), [VariableReference(Log, []), Expression(TAG, []), Expression(""Pre-Render IME for "" + mInputEditorInfo.fieldName, [])])    VariableReference(Log, [])    Expression(TAG, [])    Expression(""Pre-Render IME for "" + mInputEditorInfo.fieldName, [])  Statement(if (mInShowWindow) {, [])  MethodCall(Log.w(TAG, ""Re-entrance in to showWindow""), [VariableReference(Log, []), Expression(TAG, []), Expression(""Re-entrance in to showWindow"", [])])    VariableReference(Log, [])    Expression(TAG, [])    Expression(""Re-entrance in to showWindow"", [])  Statement(return, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(mDecorViewWasVisible, []), Expression(mDecorViewVisible, [])])    VariableReference(mDecorViewWasVisible, [])    Expression(mDecorViewVisible, [])  AssignmentExpression(=, [VariableReference(mInShowWindow, []), Expression(true, [])])    VariableReference(mInShowWindow, [])    Expression(true, [])  Statement(startViews(prepareWindow(true)), [])  Statement(// compute visibility, [])  AssignmentExpression(=, [VariableReference(mIsPreRendered, []), Expression(true, [])])    VariableReference(mIsPreRendered, [])    Expression(true, [])  Statement(onPreRenderedWindowVisibilityChanged(false), [])  Statement(// When IME is not pre-rendered, this will actually show the IME., [])  Statement(if (DEBUG), [])  MethodCall(Log.v(TAG, ""showWindow: draw decorView!""), [VariableReference(Log, []), Expression(TAG, []), Expression(""showWindow: draw decorView!"", [])])    VariableReference(Log, [])    Expression(TAG, [])    Expression(""showWindow: draw decorView!"", [])  MethodCall(mWindow.show(), [VariableReference(mWindow, []), Expression(, [])])    VariableReference(mWindow, [])    Expression(, [])  Statement(maybeNotifyPreRendered(), [])  AssignmentExpression(=, [VariableReference(mDecorViewWasVisible, []), Expression(true, [])])    VariableReference(mDecorViewWasVisible, [])    Expression(true, [])  AssignmentExpression(=, [VariableReference(mInShowWindow, []), Expression(false, [])])    VariableReference(mInShowWindow, [])    Expression(false, [])  Statement(} else {, [])  AssignmentExpression(=, [VariableReference(mIsPreRendered, []), Expression(false, [])])    VariableReference(mIsPreRendered, [])    Expression(false, [])  Statement(}, [])  Statement(}, [])",1,,,-1,,,-1,-1,-1,-1,-1,4,0,4,0,"A new statement `mInlineSuggestionSessionController.notifyOnStartInput(attribute)` has been added, which falls under other statement changes type.","The new statement does not affect the return value or exception handling of the method, thus no Compatibility Issue exists."
48,<android.animation.Keyframe.FloatKeyframe: FloatKeyframe clone()>,20,21,<android.animation.Keyframe.FloatKeyframe: FloatKeyframe clone()>,<android.animation.Keyframe.FloatKeyframe: FloatKeyframe clone()>,0,"MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(FloatKeyframe kfClone, []), Expression(mHasValue ? new FloatKeyframe(getFraction(), mValue) : new FloatKeyframe(getFraction()), [])]), MethodCall(kfClone.setInterpolator(getInterpolator()), [VariableReference(kfClone, []), Expression(getInterpolator(), [])]), Statement(return kfClone, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(FloatKeyframe kfClone, []), Expression(mHasValue ? new FloatKeyframe(getFraction(), mValue) : new FloatKeyframe(getFraction()), [])])    VariableReference(FloatKeyframe kfClone, [])    Expression(mHasValue ? new FloatKeyframe(getFraction(), mValue) : new FloatKeyframe(getFraction()), [])  MethodCall(kfClone.setInterpolator(getInterpolator()), [VariableReference(kfClone, []), Expression(getInterpolator(), [])])    VariableReference(kfClone, [])    Expression(getInterpolator(), [])  Statement(return kfClone, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(FloatKeyframe kfClone, []), Expression(mHasValue ? new FloatKeyframe(getFraction(), mValue) : new FloatKeyframe(getFraction()), [])]), MethodCall(kfClone.setInterpolator(getInterpolator()), [VariableReference(kfClone, []), Expression(getInterpolator(), [])]), AssignmentExpression(=, [VariableReference(kfClone.mValueWasSetOnStart, []), Expression(mValueWasSetOnStart, [])]), Statement(return kfClone, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(FloatKeyframe kfClone, []), Expression(mHasValue ? new FloatKeyframe(getFraction(), mValue) : new FloatKeyframe(getFraction()), [])])    VariableReference(FloatKeyframe kfClone, [])    Expression(mHasValue ? new FloatKeyframe(getFraction(), mValue) : new FloatKeyframe(getFraction()), [])  MethodCall(kfClone.setInterpolator(getInterpolator()), [VariableReference(kfClone, []), Expression(getInterpolator(), [])])    VariableReference(kfClone, [])    Expression(getInterpolator(), [])  AssignmentExpression(=, [VariableReference(kfClone.mValueWasSetOnStart, []), Expression(mValueWasSetOnStart, [])])    VariableReference(kfClone.mValueWasSetOnStart, [])    Expression(mValueWasSetOnStart, [])  Statement(return kfClone, [])  Statement(}, [])",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,4,0,4,0,"A new assignment statement `kfClone.mValueWasSetOnStart = mValueWasSetOnStart` has been introduced, so the code change type is 4.","The introduction of new assignment statement does not change the return value or exception handling of the API, so the CI type is 0."
212,<android.webkit.WebView: void requestImageRef(Message)>,15,16,<android.webkit.WebView: void requestImageRef(Message)>,<android.webkit.WebView: void requestImageRef(Message)>,0,"MethodDeclaration(method_body, [Statement({, []), Statement(checkThread(), []), Statement(// client isn't initialized, []), AssignmentExpression(=, [VariableReference(if (0, []), Expression(, [])]), Statement(return, []), AssignmentExpression(=, [VariableReference(int contentX, []), Expression(viewToContentX(mLastTouchX + mScrollX), [])]), AssignmentExpression(=, [VariableReference(int contentY, []), Expression(viewToContentY(mLastTouchY + mScrollY), [])]), AssignmentExpression(=, [VariableReference(String ref, []), Expression(nativeImageURI(contentX, contentY), [])]), AssignmentExpression(=, [VariableReference(Bundle data, []), Expression(msg.getData(), [])]), MethodCall(data.putString(""url"", ref), [VariableReference(data, []), Expression(""url"", []), Expression(ref, [])]), MethodCall(msg.setData(data), [VariableReference(msg, []), Expression(data, [])]), MethodCall(msg.sendToTarget(), [VariableReference(msg, []), Expression(, [])]), Statement(}, [])])  Statement({, [])  Statement(checkThread(), [])  Statement(// client isn't initialized, [])  AssignmentExpression(=, [VariableReference(if (0, []), Expression(, [])])    VariableReference(if (0, [])    Expression(, [])  Statement(return, [])  AssignmentExpression(=, [VariableReference(int contentX, []), Expression(viewToContentX(mLastTouchX + mScrollX), [])])    VariableReference(int contentX, [])    Expression(viewToContentX(mLastTouchX + mScrollX), [])  AssignmentExpression(=, [VariableReference(int contentY, []), Expression(viewToContentY(mLastTouchY + mScrollY), [])])    VariableReference(int contentY, [])    Expression(viewToContentY(mLastTouchY + mScrollY), [])  AssignmentExpression(=, [VariableReference(String ref, []), Expression(nativeImageURI(contentX, contentY), [])])    VariableReference(String ref, [])    Expression(nativeImageURI(contentX, contentY), [])  AssignmentExpression(=, [VariableReference(Bundle data, []), Expression(msg.getData(), [])])    VariableReference(Bundle data, [])    Expression(msg.getData(), [])  MethodCall(data.putString(""url"", ref), [VariableReference(data, []), Expression(""url"", []), Expression(ref, [])])    VariableReference(data, [])    Expression(""url"", [])    Expression(ref, [])  MethodCall(msg.setData(data), [VariableReference(msg, []), Expression(data, [])])    VariableReference(msg, [])    Expression(data, [])  MethodCall(msg.sendToTarget(), [VariableReference(msg, []), Expression(, [])])    VariableReference(msg, [])    Expression(, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(checkThread(), []), MethodCall(mProvider.requestImageRef(msg), [VariableReference(mProvider, []), Expression(msg, [])]), Statement(}, [])])  Statement({, [])  Statement(checkThread(), [])  MethodCall(mProvider.requestImageRef(msg), [VariableReference(mProvider, []), Expression(msg, [])])    VariableReference(mProvider, [])    Expression(msg, [])  Statement(}, [])",1,"/**
 * Request the url of the image last touched by the user. msg will be sent
 * to its target with a String representing the url as its object.
 *
 * @param msg This message will be dispatched with the result of the request
 * as the data member with ""url"" as key. The result can be null.
 */
","/**
 * Requests the URL of the image last touched by the user. msg will be sent
 * to its target with a String representing the URL as its object.
 *
 * @param msg the message to be dispatched with the result of the request
 * as the data member with ""url"" as key. The result can be null.
 */
",-1,,,-1,-1,-1,-1,-1,"1,3,4",1,"4,5",0,"The main logic of the method has changed from computing and setting the URL directly within the method body to delegating the request to `mProvider.requestImageRef(msg)`. This indicates the use of a dependent API, so the code change type is 4,5.","The high-level functionality remains the same, as it still processes the message and sends the result. We assume that `mProvider.requestImageRef(msg)` behaves correctly and returns the same result. Therefore, no Compatibility Issue exists, and the CI type is 0."
171,<android.app.ActivityManager: int getLockTaskModeState()>,23,24,<android.app.ActivityManager: int getLockTaskModeState()>,<android.app.ActivityManager: int getLockTaskModeState()>,0,"MethodDeclaration(method_body, [Statement({, []), Statement(try {, []), MethodCall(return ActivityManagerNative.getDefault().getLockTaskModeState(), [VariableReference(return ActivityManagerNative, []), Expression().getLockTaskModeState(, [])]), Statement(} catch (RemoteException e) {, []), Statement(return ActivityManager.LOCK_TASK_MODE_NONE, []), Statement(}, []), Statement(}, [])])  Statement({, [])  Statement(try {, [])  MethodCall(return ActivityManagerNative.getDefault().getLockTaskModeState(), [VariableReference(return ActivityManagerNative, []), Expression().getLockTaskModeState(, [])])    VariableReference(return ActivityManagerNative, [])    Expression().getLockTaskModeState(, [])  Statement(} catch (RemoteException e) {, [])  Statement(return ActivityManager.LOCK_TASK_MODE_NONE, [])  Statement(}, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(try {, []), MethodCall(return ActivityManagerNative.getDefault().getLockTaskModeState(), [VariableReference(return ActivityManagerNative, []), Expression().getLockTaskModeState(, [])]), Statement(} catch (RemoteException e) {, []), MethodCall(throw e.rethrowFromSystemServer(), [VariableReference(throw e, []), Expression(, [])]), Statement(}, []), Statement(}, [])])  Statement({, [])  Statement(try {, [])  MethodCall(return ActivityManagerNative.getDefault().getLockTaskModeState(), [VariableReference(return ActivityManagerNative, []), Expression().getLockTaskModeState(, [])])    VariableReference(return ActivityManagerNative, [])    Expression().getLockTaskModeState(, [])  Statement(} catch (RemoteException e) {, [])  MethodCall(throw e.rethrowFromSystemServer(), [VariableReference(throw e, []), Expression(, [])])    VariableReference(throw e, [])    Expression(, [])  Statement(}, [])  Statement(}, [])",1,"/**
 * Return the current state of task locking. The three possible outcomes
 * are {@link #LOCK_TASK_MODE_NONE}, {@link #LOCK_TASK_MODE_LOCKED}
 * and {@link #LOCK_TASK_MODE_PINNED}.
 *
 * @see Activity#startLockTask()
 */
","/**
 * Return the current state of task locking. The three possible outcomes
 * are {@link #LOCK_TASK_MODE_NONE}, {@link #LOCK_TASK_MODE_LOCKED}
 * and {@link #LOCK_TASK_MODE_PINNED}.
 *
 * @see Activity#startLockTask()
 */
",-1,,,-1,-1,-1,-1,-1,"1,2",2,"1,2","1,2","In the late version, if `RemoteException` occurs, the function will now throw the exception using `throw e.rethrowFromSystemServer()` instead of returning `ActivityManager.LOCK_TASK_MODE_NONE`. Thus, a return statement has been removed and an exception handling statement has been added. The change type is 1,2.","The early version returns `ActivityManager.LOCK_TASK_MODE_NONE` in case of `RemoteException`, while the late version throws an exception. This can lead to differences in both the return value and exception handling, thus the CI type is 1,2."
785,"<android.app.admin.DevicePolicyManager: void setCameraDisabled(ComponentName,boolean)>",23,24,"<android.app.admin.DevicePolicyManager: void setCameraDisabled(ComponentName,boolean)>","<android.app.admin.DevicePolicyManager: void setCameraDisabled(ComponentName,boolean)>",0,"MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(if (mService !, []), Expression(null) {, [])]), Statement(try {, []), MethodCall(mService.setCameraDisabled(admin, disabled), [VariableReference(mService, []), Expression(admin, []), Expression(disabled, [])]), Statement(} catch (RemoteException e) {, []), MethodCall(Log.w(TAG, ""Failed talking with device policy service"", e), [VariableReference(Log, []), Expression(TAG, []), Expression(""Failed talking with device policy service"", []), Expression(e, [])]), Statement(}, []), Statement(}, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(if (mService !, []), Expression(null) {, [])])    VariableReference(if (mService !, [])    Expression(null) {, [])  Statement(try {, [])  MethodCall(mService.setCameraDisabled(admin, disabled), [VariableReference(mService, []), Expression(admin, []), Expression(disabled, [])])    VariableReference(mService, [])    Expression(admin, [])    Expression(disabled, [])  Statement(} catch (RemoteException e) {, [])  MethodCall(Log.w(TAG, ""Failed talking with device policy service"", e), [VariableReference(Log, []), Expression(TAG, []), Expression(""Failed talking with device policy service"", []), Expression(e, [])])    VariableReference(Log, [])    Expression(TAG, [])    Expression(""Failed talking with device policy service"", [])    Expression(e, [])  Statement(}, [])  Statement(}, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(throwIfParentInstance(""setCameraDisabled""), []), AssignmentExpression(=, [VariableReference(if (mService !, []), Expression(null) {, [])]), Statement(try {, []), MethodCall(mService.setCameraDisabled(admin, disabled), [VariableReference(mService, []), Expression(admin, []), Expression(disabled, [])]), Statement(} catch (RemoteException e) {, []), MethodCall(throw e.rethrowFromSystemServer(), [VariableReference(throw e, []), Expression(, [])]), Statement(}, []), Statement(}, []), Statement(}, [])])  Statement({, [])  Statement(throwIfParentInstance(""setCameraDisabled""), [])  AssignmentExpression(=, [VariableReference(if (mService !, []), Expression(null) {, [])])    VariableReference(if (mService !, [])    Expression(null) {, [])  Statement(try {, [])  MethodCall(mService.setCameraDisabled(admin, disabled), [VariableReference(mService, []), Expression(admin, []), Expression(disabled, [])])    VariableReference(mService, [])    Expression(admin, [])    Expression(disabled, [])  Statement(} catch (RemoteException e) {, [])  MethodCall(throw e.rethrowFromSystemServer(), [VariableReference(throw e, []), Expression(, [])])    VariableReference(throw e, [])    Expression(, [])  Statement(}, [])  Statement(}, [])  Statement(}, [])",1,"/**
 * Called by an application that is administering the device to disable all cameras
 * on the device, for this user. After setting this, no applications running as this user
 * will be able to access any cameras on the device.
 *
 * <p>The calling device admin must have requested
 * {@link DeviceAdminInfo#USES_POLICY_DISABLE_CAMERA} to be able to call
 * this method; if it has not, a security exception will be thrown.
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated with.
 * @param disabled Whether or not the camera should be disabled.
 */
","/**
 * Called by an application that is administering the device to disable all cameras on the
 * device, for this user. After setting this, no applications running as this user will be able
 * to access any cameras on the device.
 * <p>
 * If the caller is device owner, then the restriction will be applied to all users.
 * <p>
 * The calling device admin must have requested
 * {@link DeviceAdminInfo#USES_POLICY_DISABLE_CAMERA} to be able to call this method; if it has
 * not, a security exception will be thrown.
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated with.
 * @param disabled Whether or not the camera should be disabled.
 * @throws SecurityException if {@code admin} is not an active administrator or does not use
 * {@link DeviceAdminInfo#USES_POLICY_DISABLE_CAMERA}.
 */
",-1,,,-1,-1,-1,-1,-1,"2,4",2,"2,3",2,"The late version introduces a call to `throwIfParentInstance(""setCameraDisabled"")` and modifies the exception handling by replacing the `catch` block's `Log.w` with `throw e.rethrowFromSystemServer()`, therefore change types are 2 and 3.","The change in exception handling (`throw e.rethrowFromSystemServer()`) means the method may now throw a different exception compared to the early version, potentially altering its behavior. Hence, the CI type is 2."
202,"<android.content.ContentResolver: void requestSync(Account,String,Bundle)>",18,19,"<android.content.ContentResolver: void requestSync(Account,String,Bundle)>","<android.content.ContentResolver: void requestSync(Account,String,Bundle)>",0,"MethodDeclaration(method_body, [Statement({, []), Statement(validateSyncExtrasBundle(extras), []), Statement(try {, []), MethodCall(getContentService().requestSync(account, authority, extras), [VariableReference(getContentService(), []), Expression(account, []), Expression(authority, []), Expression(extras, [])]), Statement(} catch (RemoteException e) {, []), Statement(}, []), Statement(}, [])])  Statement({, [])  Statement(validateSyncExtrasBundle(extras), [])  Statement(try {, [])  MethodCall(getContentService().requestSync(account, authority, extras), [VariableReference(getContentService(), []), Expression(account, []), Expression(authority, []), Expression(extras, [])])    VariableReference(getContentService(), [])    Expression(account, [])    Expression(authority, [])    Expression(extras, [])  Statement(} catch (RemoteException e) {, [])  Statement(}, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(if (extras, []), Expression(, [])]), Statement(}, []), AssignmentExpression(=, [VariableReference(SyncRequest request, []), Expression(new SyncRequest.Builder().setSyncAdapter(account, authority).setExtras(extras).syncOnce().build(), [])]), Statement(requestSync(request), []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(if (extras, []), Expression(, [])])    VariableReference(if (extras, [])    Expression(, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(SyncRequest request, []), Expression(new SyncRequest.Builder().setSyncAdapter(account, authority).setExtras(extras).syncOnce().build(), [])])    VariableReference(SyncRequest request, [])    Expression(new SyncRequest.Builder().setSyncAdapter(account, authority).setExtras(extras).syncOnce().build(), [])  Statement(requestSync(request), [])  Statement(}, [])",1,"/**
 * Start an asynchronous sync operation. If you want to monitor the progress
 * of the sync you may register a SyncObserver. Only values of the following
 * types may be used in the extras bundle:
 * <ul>
 * <li>Integer</li>
 * <li>Long</li>
 * <li>Boolean</li>
 * <li>Float</li>
 * <li>Double</li>
 * <li>String</li>
 * </ul>
 *
 * @param account which account should be synced
 * @param authority which authority should be synced
 * @param extras any extras to pass to the SyncAdapter.
 */
","/**
 * Start an asynchronous sync operation. If you want to monitor the progress
 * of the sync you may register a SyncObserver. Only values of the following
 * types may be used in the extras bundle:
 * <ul>
 * <li>Integer</li>
 * <li>Long</li>
 * <li>Boolean</li>
 * <li>Float</li>
 * <li>Double</li>
 * <li>String</li>
 * <li>Account</li>
 * <li>null</li>
 * </ul>
 *
 * @param account which account should be synced
 * @param authority which authority should be synced
 * @param extras any extras to pass to the SyncAdapter.
 */
",-1,,,-1,-1,-1,-1,-1,"2,3,4",2,"2,3,4",2,"The implementation has undergone multiple changes. The early version validates the `extras` Bundle and directly calls `getContentService().requestSync(account, authority, extras)`. The late version creates a `SyncRequest` using a `SyncRequest.Builder` and then calls `requestSync(request)`. These changes involve control dependency (due to new conditional statement), and the usage of different `requestSync()` methods. Thus, the change types are 2,3,4.","The changes in exception handling could result in different exceptions being thrown in the late version, leading to potential different exception handling behavior. Therefore, the CI type is 2. Additionally, method calls and the logic have changed significantly, which could introduce different exceptions or flows, reinforcing the CI type 2."
498,"<android.view.Choreographer.FrameDisplayEventReceiver: void onVsync(long,int,int)>",20,21,"<android.view.Choreographer.FrameDisplayEventReceiver: void onVsync(long,int,int)>","<android.view.Choreographer.FrameDisplayEventReceiver: void onVsync(long,int,int)>",0,"MethodDeclaration(method_body, [Statement({, []), Statement(// that we need to fix this., []), AssignmentExpression(=, [VariableReference(if (builtInDisplayId !, []), Expression(SurfaceControl.BUILT_IN_DISPLAY_ID_MAIN) {, [])]), MethodCall(Log.d(TAG, ""Received vsync from secondary display, but we don't support "" + ""this case yet.  Choreographer needs a way to explicitly request "" + ""vsync for a specific display to ensure it doesn't lose track "" + ""of its scheduled vsync.""), [VariableReference(Log, []), Expression(TAG, []), Expression(""Received vsync from secondary display, []), Expression(but we don't support "" + ""this case yet.  Choreographer needs a way to explicitly request "" + ""vsync for a specific display to ensure it doesn't lose track "" + ""of its scheduled vsync."", [])]), Statement(scheduleVsync(), []), Statement(return, []), Statement(}, []), Statement(// Post the vsync event to the Handler., []), Statement(// The idea is to prevent incoming vsync events from completely starving, []), Statement(// the message queue.  If there are no messages in the queue with timestamps, []), Statement(// earlier than the frame time, then the vsync event will be processed immediately., []), Statement(// Otherwise, messages that predate the vsync event will be handled first., []), AssignmentExpression(=, [VariableReference(long now, []), Expression(System.nanoTime(), [])]), Statement(if (timestampNanos > now) {, []), MethodCall(Log.w(TAG, ""Frame time is "" + ((timestampNanos - now) * 0.000001f) + "" ms in the future!  Check that graphics HAL is generating vsync "" + ""timestamps using the correct timebase.""), [VariableReference(Log, []), Expression(TAG, []), Expression(""Frame time is "" + ((timestampNanos - now) * 0.000001f) + "" ms in the future!  Check that graphics HAL is generating vsync "" + ""timestamps using the correct timebase."", [])]), AssignmentExpression(=, [VariableReference(timestampNanos, []), Expression(now, [])]), Statement(}, []), Statement(if (mHavePendingVsync) {, []), MethodCall(Log.w(TAG, ""Already have a pending vsync event.  There should only be "" + ""one at a time.""), [VariableReference(Log, []), Expression(TAG, []), Expression(""Already have a pending vsync event.  There should only be "" + ""one at a time."", [])]), Statement(} else {, []), AssignmentExpression(=, [VariableReference(mHavePendingVsync, []), Expression(true, [])]), Statement(}, []), AssignmentExpression(=, [VariableReference(mTimestampNanos, []), Expression(timestampNanos, [])]), AssignmentExpression(=, [VariableReference(mFrame, []), Expression(frame, [])]), AssignmentExpression(=, [VariableReference(Message msg, []), Expression(Message.obtain(mHandler, this), [])]), MethodCall(msg.setAsynchronous(true), [VariableReference(msg, []), Expression(true, [])]), MethodCall(mHandler.sendMessageAtTime(msg, timestampNanos / NANOS_PER_MS), [VariableReference(mHandler, []), Expression(msg, []), Expression(timestampNanos / NANOS_PER_MS, [])]), Statement(}, [])])  Statement({, [])  Statement(// that we need to fix this., [])  AssignmentExpression(=, [VariableReference(if (builtInDisplayId !, []), Expression(SurfaceControl.BUILT_IN_DISPLAY_ID_MAIN) {, [])])    VariableReference(if (builtInDisplayId !, [])    Expression(SurfaceControl.BUILT_IN_DISPLAY_ID_MAIN) {, [])  MethodCall(Log.d(TAG, ""Received vsync from secondary display, but we don't support "" + ""this case yet.  Choreographer needs a way to explicitly request "" + ""vsync for a specific display to ensure it doesn't lose track "" + ""of its scheduled vsync.""), [VariableReference(Log, []), Expression(TAG, []), Expression(""Received vsync from secondary display, []), Expression(but we don't support "" + ""this case yet.  Choreographer needs a way to explicitly request "" + ""vsync for a specific display to ensure it doesn't lose track "" + ""of its scheduled vsync."", [])])    VariableReference(Log, [])    Expression(TAG, [])    Expression(""Received vsync from secondary display, [])    Expression(but we don't support "" + ""this case yet.  Choreographer needs a way to explicitly request "" + ""vsync for a specific display to ensure it doesn't lose track "" + ""of its scheduled vsync."", [])  Statement(scheduleVsync(), [])  Statement(return, [])  Statement(}, [])  Statement(// Post the vsync event to the Handler., [])  Statement(// The idea is to prevent incoming vsync events from completely starving, [])  Statement(// the message queue.  If there are no messages in the queue with timestamps, [])  Statement(// earlier than the frame time, then the vsync event will be processed immediately., [])  Statement(// Otherwise, messages that predate the vsync event will be handled first., [])  AssignmentExpression(=, [VariableReference(long now, []), Expression(System.nanoTime(), [])])    VariableReference(long now, [])    Expression(System.nanoTime(), [])  Statement(if (timestampNanos > now) {, [])  MethodCall(Log.w(TAG, ""Frame time is "" + ((timestampNanos - now) * 0.000001f) + "" ms in the future!  Check that graphics HAL is generating vsync "" + ""timestamps using the correct timebase.""), [VariableReference(Log, []), Expression(TAG, []), Expression(""Frame time is "" + ((timestampNanos - now) * 0.000001f) + "" ms in the future!  Check that graphics HAL is generating vsync "" + ""timestamps using the correct timebase."", [])])    VariableReference(Log, [])    Expression(TAG, [])    Expression(""Frame time is "" + ((timestampNanos - now) * 0.000001f) + "" ms in the future!  Check that graphics HAL is generating vsync "" + ""timestamps using the correct timebase."", [])  AssignmentExpression(=, [VariableReference(timestampNanos, []), Expression(now, [])])    VariableReference(timestampNanos, [])    Expression(now, [])  Statement(}, [])  Statement(if (mHavePendingVsync) {, [])  MethodCall(Log.w(TAG, ""Already have a pending vsync event.  There should only be "" + ""one at a time.""), [VariableReference(Log, []), Expression(TAG, []), Expression(""Already have a pending vsync event.  There should only be "" + ""one at a time."", [])])    VariableReference(Log, [])    Expression(TAG, [])    Expression(""Already have a pending vsync event.  There should only be "" + ""one at a time."", [])  Statement(} else {, [])  AssignmentExpression(=, [VariableReference(mHavePendingVsync, []), Expression(true, [])])    VariableReference(mHavePendingVsync, [])    Expression(true, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(mTimestampNanos, []), Expression(timestampNanos, [])])    VariableReference(mTimestampNanos, [])    Expression(timestampNanos, [])  AssignmentExpression(=, [VariableReference(mFrame, []), Expression(frame, [])])    VariableReference(mFrame, [])    Expression(frame, [])  AssignmentExpression(=, [VariableReference(Message msg, []), Expression(Message.obtain(mHandler, this), [])])    VariableReference(Message msg, [])    Expression(Message.obtain(mHandler, this), [])  MethodCall(msg.setAsynchronous(true), [VariableReference(msg, []), Expression(true, [])])    VariableReference(msg, [])    Expression(true, [])  MethodCall(mHandler.sendMessageAtTime(msg, timestampNanos / NANOS_PER_MS), [VariableReference(mHandler, []), Expression(msg, []), Expression(timestampNanos / NANOS_PER_MS, [])])    VariableReference(mHandler, [])    Expression(msg, [])    Expression(timestampNanos / NANOS_PER_MS, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(// that we need to fix this., []), AssignmentExpression(=, [VariableReference(if (builtInDisplayId !, []), Expression(SurfaceControl.BUILT_IN_DISPLAY_ID_MAIN) {, [])]), MethodCall(Log.d(TAG, ""Received vsync from secondary display, but we don't support "" + ""this case yet.  Choreographer needs a way to explicitly request "" + ""vsync for a specific display to ensure it doesn't lose track "" + ""of its scheduled vsync.""), [VariableReference(Log, []), Expression(TAG, []), Expression(""Received vsync from secondary display, []), Expression(but we don't support "" + ""this case yet.  Choreographer needs a way to explicitly request "" + ""vsync for a specific display to ensure it doesn't lose track "" + ""of its scheduled vsync."", [])]), Statement(scheduleVsync(), []), Statement(return, []), Statement(}, []), Statement(// Post the vsync event to the Handler., []), Statement(// The idea is to prevent incoming vsync events from completely starving, []), Statement(// the message queue.  If there are no messages in the queue with timestamps, []), Statement(// earlier than the frame time, then the vsync event will be processed immediately., []), Statement(// Otherwise, messages that predate the vsync event will be handled first., []), AssignmentExpression(=, [VariableReference(long now, []), Expression(System.nanoTime(), [])]), Statement(if (timestampNanos > now) {, []), MethodCall(Log.w(TAG, ""Frame time is "" + ((timestampNanos - now) * 0.000001f) + "" ms in the future!  Check that graphics HAL is generating vsync "" + ""timestamps using the correct timebase.""), [VariableReference(Log, []), Expression(TAG, []), Expression(""Frame time is "" + ((timestampNanos - now) * 0.000001f) + "" ms in the future!  Check that graphics HAL is generating vsync "" + ""timestamps using the correct timebase."", [])]), AssignmentExpression(=, [VariableReference(timestampNanos, []), Expression(now, [])]), Statement(}, []), Statement(if (mHavePendingVsync) {, []), MethodCall(Log.w(TAG, ""Already have a pending vsync event.  There should only be "" + ""one at a time.""), [VariableReference(Log, []), Expression(TAG, []), Expression(""Already have a pending vsync event.  There should only be "" + ""one at a time."", [])]), Statement(} else {, []), AssignmentExpression(=, [VariableReference(mHavePendingVsync, []), Expression(true, [])]), Statement(}, []), AssignmentExpression(=, [VariableReference(mTimestampNanos, []), Expression(timestampNanos, [])]), AssignmentExpression(=, [VariableReference(mFrame, []), Expression(frame, [])]), AssignmentExpression(=, [VariableReference(Message msg, []), Expression(Message.obtain(mHandler, this), [])]), MethodCall(msg.setAsynchronous(true), [VariableReference(msg, []), Expression(true, [])]), MethodCall(mHandler.sendMessageAtTime(msg, timestampNanos / TimeUtils.NANOS_PER_MS), [VariableReference(mHandler, []), Expression(msg, []), Expression(timestampNanos / TimeUtils.NANOS_PER_MS, [])]), Statement(}, [])])  Statement({, [])  Statement(// that we need to fix this., [])  AssignmentExpression(=, [VariableReference(if (builtInDisplayId !, []), Expression(SurfaceControl.BUILT_IN_DISPLAY_ID_MAIN) {, [])])    VariableReference(if (builtInDisplayId !, [])    Expression(SurfaceControl.BUILT_IN_DISPLAY_ID_MAIN) {, [])  MethodCall(Log.d(TAG, ""Received vsync from secondary display, but we don't support "" + ""this case yet.  Choreographer needs a way to explicitly request "" + ""vsync for a specific display to ensure it doesn't lose track "" + ""of its scheduled vsync.""), [VariableReference(Log, []), Expression(TAG, []), Expression(""Received vsync from secondary display, []), Expression(but we don't support "" + ""this case yet.  Choreographer needs a way to explicitly request "" + ""vsync for a specific display to ensure it doesn't lose track "" + ""of its scheduled vsync."", [])])    VariableReference(Log, [])    Expression(TAG, [])    Expression(""Received vsync from secondary display, [])    Expression(but we don't support "" + ""this case yet.  Choreographer needs a way to explicitly request "" + ""vsync for a specific display to ensure it doesn't lose track "" + ""of its scheduled vsync."", [])  Statement(scheduleVsync(), [])  Statement(return, [])  Statement(}, [])  Statement(// Post the vsync event to the Handler., [])  Statement(// The idea is to prevent incoming vsync events from completely starving, [])  Statement(// the message queue.  If there are no messages in the queue with timestamps, [])  Statement(// earlier than the frame time, then the vsync event will be processed immediately., [])  Statement(// Otherwise, messages that predate the vsync event will be handled first., [])  AssignmentExpression(=, [VariableReference(long now, []), Expression(System.nanoTime(), [])])    VariableReference(long now, [])    Expression(System.nanoTime(), [])  Statement(if (timestampNanos > now) {, [])  MethodCall(Log.w(TAG, ""Frame time is "" + ((timestampNanos - now) * 0.000001f) + "" ms in the future!  Check that graphics HAL is generating vsync "" + ""timestamps using the correct timebase.""), [VariableReference(Log, []), Expression(TAG, []), Expression(""Frame time is "" + ((timestampNanos - now) * 0.000001f) + "" ms in the future!  Check that graphics HAL is generating vsync "" + ""timestamps using the correct timebase."", [])])    VariableReference(Log, [])    Expression(TAG, [])    Expression(""Frame time is "" + ((timestampNanos - now) * 0.000001f) + "" ms in the future!  Check that graphics HAL is generating vsync "" + ""timestamps using the correct timebase."", [])  AssignmentExpression(=, [VariableReference(timestampNanos, []), Expression(now, [])])    VariableReference(timestampNanos, [])    Expression(now, [])  Statement(}, [])  Statement(if (mHavePendingVsync) {, [])  MethodCall(Log.w(TAG, ""Already have a pending vsync event.  There should only be "" + ""one at a time.""), [VariableReference(Log, []), Expression(TAG, []), Expression(""Already have a pending vsync event.  There should only be "" + ""one at a time."", [])])    VariableReference(Log, [])    Expression(TAG, [])    Expression(""Already have a pending vsync event.  There should only be "" + ""one at a time."", [])  Statement(} else {, [])  AssignmentExpression(=, [VariableReference(mHavePendingVsync, []), Expression(true, [])])    VariableReference(mHavePendingVsync, [])    Expression(true, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(mTimestampNanos, []), Expression(timestampNanos, [])])    VariableReference(mTimestampNanos, [])    Expression(timestampNanos, [])  AssignmentExpression(=, [VariableReference(mFrame, []), Expression(frame, [])])    VariableReference(mFrame, [])    Expression(frame, [])  AssignmentExpression(=, [VariableReference(Message msg, []), Expression(Message.obtain(mHandler, this), [])])    VariableReference(Message msg, [])    Expression(Message.obtain(mHandler, this), [])  MethodCall(msg.setAsynchronous(true), [VariableReference(msg, []), Expression(true, [])])    VariableReference(msg, [])    Expression(true, [])  MethodCall(mHandler.sendMessageAtTime(msg, timestampNanos / TimeUtils.NANOS_PER_MS), [VariableReference(mHandler, []), Expression(msg, []), Expression(timestampNanos / TimeUtils.NANOS_PER_MS, [])])    VariableReference(mHandler, [])    Expression(msg, [])    Expression(timestampNanos / TimeUtils.NANOS_PER_MS, [])  Statement(}, [])",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,5,0,5,0,The only change between the early and late version in this context is that the division expression `NANOS_PER_MS` was qualified with `TimeUtils` in version 21. This indicates that `NANOS_PER_MS` was likely moved to be a static member of the `TimeUtils` class. This qualifies the change as "Dependent API changed" since it now depends on a static field from another class.,"The change in the dependent API reference does not affect the method's behavior in terms of return values or exception handling, hence no Compatibility Issues exist."
530,<android.view.View: AccessibilityNodeInfo createAccessibilityNodeInfo()>,17,18,<android.view.View: AccessibilityNodeInfo createAccessibilityNodeInfo()>,<android.view.View: AccessibilityNodeInfo createAccessibilityNodeInfo()>,0,"MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(AccessibilityNodeProvider provider, []), Expression(getAccessibilityNodeProvider(), [])]), AssignmentExpression(=, [VariableReference(if (provider !, []), Expression(null) {, [])]), MethodCall(return provider.createAccessibilityNodeInfo(View.NO_ID), [VariableReference(return provider, []), Expression(View.NO_ID, [])]), Statement(} else {, []), AssignmentExpression(=, [VariableReference(AccessibilityNodeInfo info, []), Expression(AccessibilityNodeInfo.obtain(this), [])]), Statement(onInitializeAccessibilityNodeInfo(info), []), Statement(return info, []), Statement(}, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(AccessibilityNodeProvider provider, []), Expression(getAccessibilityNodeProvider(), [])])    VariableReference(AccessibilityNodeProvider provider, [])    Expression(getAccessibilityNodeProvider(), [])  AssignmentExpression(=, [VariableReference(if (provider !, []), Expression(null) {, [])])    VariableReference(if (provider !, [])    Expression(null) {, [])  MethodCall(return provider.createAccessibilityNodeInfo(View.NO_ID), [VariableReference(return provider, []), Expression(View.NO_ID, [])])    VariableReference(return provider, [])    Expression(View.NO_ID, [])  Statement(} else {, [])  AssignmentExpression(=, [VariableReference(AccessibilityNodeInfo info, []), Expression(AccessibilityNodeInfo.obtain(this), [])])    VariableReference(AccessibilityNodeInfo info, [])    Expression(AccessibilityNodeInfo.obtain(this), [])  Statement(onInitializeAccessibilityNodeInfo(info), [])  Statement(return info, [])  Statement(}, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(if (mAccessibilityDelegate !, []), Expression(null) {, [])]), MethodCall(return mAccessibilityDelegate.createAccessibilityNodeInfo(this), [VariableReference(return mAccessibilityDelegate, []), Expression(this, [])]), Statement(} else {, []), Statement(return createAccessibilityNodeInfoInternal(), []), Statement(}, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(if (mAccessibilityDelegate !, []), Expression(null) {, [])])    VariableReference(if (mAccessibilityDelegate !, [])    Expression(null) {, [])  MethodCall(return mAccessibilityDelegate.createAccessibilityNodeInfo(this), [VariableReference(return mAccessibilityDelegate, []), Expression(this, [])])    VariableReference(return mAccessibilityDelegate, [])    Expression(this, [])  Statement(} else {, [])  Statement(return createAccessibilityNodeInfoInternal(), [])  Statement(}, [])  Statement(}, [])",1,"/**
 * Returns an {@link AccessibilityNodeInfo} representing this view from the
 * point of view of an {@link android.accessibilityservice.AccessibilityService}.
 * This method is responsible for obtaining an accessibility node info from a
 * pool of reusable instances and calling
 * {@link #onInitializeAccessibilityNodeInfo(AccessibilityNodeInfo)} on this view to
 * initialize the former.
 * <p>
 * Note: The client is responsible for recycling the obtained instance by calling
 * {@link AccessibilityNodeInfo#recycle()} to minimize object creation.
 * </p>
 *
 * @return A populated {@link AccessibilityNodeInfo}.
 *
 * @see AccessibilityNodeInfo
 */
","/**
 * Returns an {@link AccessibilityNodeInfo} representing this view from the
 * point of view of an {@link android.accessibilityservice.AccessibilityService}.
 * This method is responsible for obtaining an accessibility node info from a
 * pool of reusable instances and calling
 * {@link #onInitializeAccessibilityNodeInfo(AccessibilityNodeInfo)} on this view to
 * initialize the former.
 * <p>
 * Note: The client is responsible for recycling the obtained instance by calling
 * {@link AccessibilityNodeInfo#recycle()} to minimize object creation.
 * </p>
 *
 * @return A populated {@link AccessibilityNodeInfo}.
 *
 * @see AccessibilityNodeInfo
 */
",-1,,,-1,-1,-1,-1,-1,"1,3,4,5",1,"1,3,5",1,"The changes between the early and late versions include a change from using `getAccessibilityNodeProvider()` to `mAccessibilityDelegate`, and the introduction of a call to `createAccessibilityNodeInfoInternal()`. These changes affect both the control dependency and the return statement since they determine what method is called and what value is ultimately returned.","The modifications potentially affect the returned `AccessibilityNodeInfo`. Depending on whether `mAccessibilityDelegate` is non-null, the method may return a different instance than in the early version, leading to a Compatibility Issue. Thus, the CI type is 1."
1403,<android.app.WallpaperManager: Drawable peekDrawable()>,23,24,<android.app.WallpaperManager: Drawable peekDrawable()>,<android.app.WallpaperManager: Drawable peekDrawable()>,0,"MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(Bitmap bm, []), Expression(sGlobals.peekWallpaperBitmap(mContext, false), [])]), AssignmentExpression(=, [VariableReference(if (bm !, []), Expression(null) {, [])]), AssignmentExpression(=, [VariableReference(Drawable dr, []), Expression(new BitmapDrawable(mContext.getResources(), bm), [])]), MethodCall(dr.setDither(false), [VariableReference(dr, []), Expression(false, [])]), Statement(return dr, []), Statement(}, []), Statement(return null, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(Bitmap bm, []), Expression(sGlobals.peekWallpaperBitmap(mContext, false), [])])    VariableReference(Bitmap bm, [])    Expression(sGlobals.peekWallpaperBitmap(mContext, false), [])  AssignmentExpression(=, [VariableReference(if (bm !, []), Expression(null) {, [])])    VariableReference(if (bm !, [])    Expression(null) {, [])  AssignmentExpression(=, [VariableReference(Drawable dr, []), Expression(new BitmapDrawable(mContext.getResources(), bm), [])])    VariableReference(Drawable dr, [])    Expression(new BitmapDrawable(mContext.getResources(), bm), [])  MethodCall(dr.setDither(false), [VariableReference(dr, []), Expression(false, [])])    VariableReference(dr, [])    Expression(false, [])  Statement(return dr, [])  Statement(}, [])  Statement(return null, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(Bitmap bm, []), Expression(sGlobals.peekWallpaperBitmap(mContext, false, FLAG_SYSTEM), [])]), AssignmentExpression(=, [VariableReference(if (bm !, []), Expression(null) {, [])]), AssignmentExpression(=, [VariableReference(Drawable dr, []), Expression(new BitmapDrawable(mContext.getResources(), bm), [])]), MethodCall(dr.setDither(false), [VariableReference(dr, []), Expression(false, [])]), Statement(return dr, []), Statement(}, []), Statement(return null, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(Bitmap bm, []), Expression(sGlobals.peekWallpaperBitmap(mContext, false, FLAG_SYSTEM), [])])    VariableReference(Bitmap bm, [])    Expression(sGlobals.peekWallpaperBitmap(mContext, false, FLAG_SYSTEM), [])  AssignmentExpression(=, [VariableReference(if (bm !, []), Expression(null) {, [])])    VariableReference(if (bm !, [])    Expression(null) {, [])  AssignmentExpression(=, [VariableReference(Drawable dr, []), Expression(new BitmapDrawable(mContext.getResources(), bm), [])])    VariableReference(Drawable dr, [])    Expression(new BitmapDrawable(mContext.getResources(), bm), [])  MethodCall(dr.setDither(false), [VariableReference(dr, []), Expression(false, [])])    VariableReference(dr, [])    Expression(false, [])  Statement(return dr, [])  Statement(}, [])  Statement(return null, [])  Statement(}, [])",1,"/**
 * Retrieve the current system wallpaper; if there is no wallpaper set,
 * a null pointer is returned. This is returned as an
 * abstract Drawable that you can install in a View to display whatever
 * wallpaper the user has currently set.
 *
 * @return Returns a Drawable object that will draw the wallpaper or a
 * null pointer if these is none.
 */
","/**
 * Retrieve the current system wallpaper; if there is no wallpaper set,
 * a null pointer is returned. This is returned as an
 * abstract Drawable that you can install in a View to display whatever
 * wallpaper the user has currently set.
 *
 * @return Returns a Drawable object that will draw the wallpaper or a
 * null pointer if these is none.
 */
",-1,,,-1,-1,-1,-1,-1,5,0,"4,5",0,"The key change in the late implementation is the addition of `FLAG_SYSTEM` as a parameter to the call `sGlobals.peekWallpaperBitmap(mContext, false)`. This modifies the call to `sGlobals.peekWallpaperBitmap(mContext, false, FLAG_SYSTEM)`. Therefore, the code change falls into both ""Other statement changed"" and ""Dependent API changed"" categories, hence the change type is 4,5.","The addition of the `FLAG_SYSTEM` parameter in the `peekWallpaperBitmap` method call does not inherently lead to a different return value or a different exception being thrown based on the provided context. Therefore, the code change does not result in a Compatibility Issue, hence the CI type is 0."
65,<android.app.VoiceInteractor: boolean unregisterOnDestroyedCallback(Runnable)>,29,30,<android.app.VoiceInteractor: boolean unregisterOnDestroyedCallback(Runnable)>,<android.app.VoiceInteractor: boolean unregisterOnDestroyedCallback(Runnable)>,0,"MethodDeclaration(method_body, [Statement({, []), MethodCall(Preconditions.checkNotNull(callback), [VariableReference(Preconditions, []), Expression(callback, [])]), Statement(if (isDestroyed()) {, []), MethodCall(Log.w(TAG, ""Cannot interact with a destroyed voice interactor""), [VariableReference(Log, []), Expression(TAG, []), Expression(""Cannot interact with a destroyed voice interactor"", [])]), Statement(return false, []), Statement(}, []), AssignmentExpression(=, [VariableReference(return mOnDestroyCallbacks.remove(callback) !, []), Expression(null, [])]), Statement(}, [])])  Statement({, [])  MethodCall(Preconditions.checkNotNull(callback), [VariableReference(Preconditions, []), Expression(callback, [])])    VariableReference(Preconditions, [])    Expression(callback, [])  Statement(if (isDestroyed()) {, [])  MethodCall(Log.w(TAG, ""Cannot interact with a destroyed voice interactor""), [VariableReference(Log, []), Expression(TAG, []), Expression(""Cannot interact with a destroyed voice interactor"", [])])    VariableReference(Log, [])    Expression(TAG, [])    Expression(""Cannot interact with a destroyed voice interactor"", [])  Statement(return false, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(return mOnDestroyCallbacks.remove(callback) !, []), Expression(null, [])])    VariableReference(return mOnDestroyCallbacks.remove(callback) !, [])    Expression(null, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), MethodCall(Objects.requireNonNull(callback), [VariableReference(Objects, []), Expression(callback, [])]), Statement(if (isDestroyed()) {, []), MethodCall(Log.w(TAG, ""Cannot interact with a destroyed voice interactor""), [VariableReference(Log, []), Expression(TAG, []), Expression(""Cannot interact with a destroyed voice interactor"", [])]), Statement(return false, []), Statement(}, []), AssignmentExpression(=, [VariableReference(return mOnDestroyCallbacks.remove(callback) !, []), Expression(null, [])]), Statement(}, [])])  Statement({, [])  MethodCall(Objects.requireNonNull(callback), [VariableReference(Objects, []), Expression(callback, [])])    VariableReference(Objects, [])    Expression(callback, [])  Statement(if (isDestroyed()) {, [])  MethodCall(Log.w(TAG, ""Cannot interact with a destroyed voice interactor""), [VariableReference(Log, []), Expression(TAG, []), Expression(""Cannot interact with a destroyed voice interactor"", [])])    VariableReference(Log, [])    Expression(TAG, [])    Expression(""Cannot interact with a destroyed voice interactor"", [])  Statement(return false, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(return mOnDestroyCallbacks.remove(callback) !, []), Expression(null, [])])    VariableReference(return mOnDestroyCallbacks.remove(callback) !, [])    Expression(null, [])  Statement(}, [])",1,"/**
 * Unregisters a previously registered onDestroy callback
 *
 * @param callback The callback to remove.
 * @return whether the callback was unregistered.
 */
","/**
 * Unregisters a previously registered onDestroy callback
 *
 * @param callback The callback to remove.
 * @return whether the callback was unregistered.
 */
",-1,,,-1,-1,-1,-1,-1,4,0,"4,5",0,"The only change in the method implementation is the replacement of Preconditions.checkNotNull(callback) with Objects.requireNonNull(callback), so the change type is 4,5.","As the functionality of the method is not affected by replacing Preconditions with Objects for the null check, no compatibility issue exists."
736,"<android.hardware.display.DisplayManager: VirtualDisplay createVirtualDisplay(String,int,int,int,Surface,int)>",20,21,"<android.hardware.display.DisplayManager: VirtualDisplay createVirtualDisplay(String,int,int,int,Surface,int)>","<android.hardware.display.DisplayManager: VirtualDisplay createVirtualDisplay(String,int,int,int,Surface,int)>",0,"MethodDeclaration(method_body, [Statement({, []), MethodCall(return mGlobal.createVirtualDisplay(mContext, name, width, height, densityDpi, surface, flags), [VariableReference(return mGlobal, []), Expression(mContext, []), Expression(name, []), Expression(width, []), Expression(height, []), Expression(densityDpi, []), Expression(surface, []), Expression(flags, [])]), Statement(}, [])])  Statement({, [])  MethodCall(return mGlobal.createVirtualDisplay(mContext, name, width, height, densityDpi, surface, flags), [VariableReference(return mGlobal, []), Expression(mContext, []), Expression(name, []), Expression(width, []), Expression(height, []), Expression(densityDpi, []), Expression(surface, []), Expression(flags, [])])    VariableReference(return mGlobal, [])    Expression(mContext, [])    Expression(name, [])    Expression(width, [])    Expression(height, [])    Expression(densityDpi, [])    Expression(surface, [])    Expression(flags, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(return createVirtualDisplay(name, width, height, densityDpi, surface, flags, null, null), []), Statement(}, [])])  Statement({, [])  Statement(return createVirtualDisplay(name, width, height, densityDpi, surface, flags, null, null), [])  Statement(}, [])",1,"/**
 * Creates a virtual display.
 * <p>
 * The content of a virtual display is rendered to a {@link Surface} provided
 * by the application.
 * </p><p>
 * The virtual display should be {@link VirtualDisplay#release released}
 * when no longer needed.  Because a virtual display renders to a surface
 * provided by the application, it will be released automatically when the
 * process terminates and all remaining windows on it will be forcibly removed.
 * </p><p>
 * The behavior of the virtual display depends on the flags that are provided
 * to this method.  By default, virtual displays are created to be private,
 * non-presentation and unsecure.  Permissions may be required to use certain flags.
 * </p>
 *
 * @param name The name of the virtual display, must be non-empty.
 * @param width The width of the virtual display in pixels, must be greater than 0.
 * @param height The height of the virtual display in pixels, must be greater than 0.
 * @param densityDpi The density of the virtual display in dpi, must be greater than 0.
 * @param surface The surface to which the content of the virtual display should
 * be rendered, must be non-null.
 * @param flags A combination of virtual display flags:
 * {@link #VIRTUAL_DISPLAY_FLAG_PUBLIC}, {@link #VIRTUAL_DISPLAY_FLAG_PRESENTATION}
 * or {@link #VIRTUAL_DISPLAY_FLAG_SECURE}.
 * @return The newly created virtual display, or null if the application could
 * not create the virtual display.
 *
 * @throws SecurityException if the caller does not have permission to create
 * a virtual display with the specified flags.
 */
","/**
 * Creates a virtual display.
 *
 * @see #createVirtualDisplay(String, int, int, int, Surface, int, VirtualDisplay.Callback)
 */
",-1,,,-1,-1,-1,-1,-1,"1,4",1,5,1,"In the early version, the method calls `mGlobal.createVirtualDisplay(mContext, name, width, height, densityDpi, surface, flags)` while in the late version, it calls `createVirtualDisplay(name, width, height, densityDpi, surface, flags, null, null)` with added parameters and method names. This indicates a change in the dependent API.","The change in the dependent API call can potentially alter the behavior of the method, possibly returning different values or types, leading to a compatibility issue. Thus, CI type is 1."
138,<android.view.View: boolean hasFocusable()>,20,21,<android.view.View: boolean hasFocusable()>,<android.view.View: boolean hasFocusable()>,0,"MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(return (mViewFlags & VISIBILITY_MASK), []), Expression(, [])]), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(return (mViewFlags & VISIBILITY_MASK), []), Expression(, [])])    VariableReference(return (mViewFlags & VISIBILITY_MASK), [])    Expression(, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(if (!isFocusableInTouchMode()) {, []), AssignmentExpression(=, [VariableReference(for (ViewParent p, []), Expression(mParent, [])]), Statement(p instanceof ViewGroup, []), AssignmentExpression(=, [VariableReference(p, []), Expression(p.getParent()) {, [])]), AssignmentExpression(=, [VariableReference(final ViewGroup g, []), Expression((ViewGroup) p, [])]), MethodCall(if (g.shouldBlockFocusForTouchscreen()), [VariableReference(if (g, []), Expression(), [])]), Statement(return false, []), Statement(}, []), Statement(}, []), Statement(}, []), AssignmentExpression(=, [VariableReference(return (mViewFlags & VISIBILITY_MASK), []), Expression(, [])]), Statement(}, [])])  Statement({, [])  Statement(if (!isFocusableInTouchMode()) {, [])  AssignmentExpression(=, [VariableReference(for (ViewParent p, []), Expression(mParent, [])])    VariableReference(for (ViewParent p, [])    Expression(mParent, [])  Statement(p instanceof ViewGroup, [])  AssignmentExpression(=, [VariableReference(p, []), Expression(p.getParent()) {, [])])    VariableReference(p, [])    Expression(p.getParent()) {, [])  AssignmentExpression(=, [VariableReference(final ViewGroup g, []), Expression((ViewGroup) p, [])])    VariableReference(final ViewGroup g, [])    Expression((ViewGroup) p, [])  MethodCall(if (g.shouldBlockFocusForTouchscreen()), [VariableReference(if (g, []), Expression(), [])])    VariableReference(if (g, [])    Expression(), [])  Statement(return false, [])  Statement(}, [])  Statement(}, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(return (mViewFlags & VISIBILITY_MASK), []), Expression(, [])])    VariableReference(return (mViewFlags & VISIBILITY_MASK), [])    Expression(, [])  Statement(}, [])",1,"/**
 * Returns true if this view is focusable or if it contains a reachable View
 * for which {@link #hasFocusable()} returns true. A ""reachable hasFocusable()""
 * is a View whose parents do not block descendants focus.
 *
 * Only {@link #VISIBLE} views are considered focusable.
 *
 * @return True if the view is focusable or if the view contains a focusable
 * View, false otherwise.
 *
 * @see ViewGroup#FOCUS_BLOCK_DESCENDANTS
 */
","/**
 * Returns true if this view is focusable or if it contains a reachable View
 * for which {@link #hasFocusable()} returns true. A ""reachable hasFocusable()""
 * is a View whose parents do not block descendants focus.
 *
 * Only {@link #VISIBLE} views are considered focusable.
 *
 * @return True if the view is focusable or if the view contains a focusable
 * View, false otherwise.
 *
 * @see ViewGroup#FOCUS_BLOCK_DESCENDANTS
 * @see ViewGroup#getTouchscreenBlocksFocus()
 */
",-1,,,-1,-1,-1,-1,-1,"1,3",1,3,1,"The version 21 adds additional control statements, specifically an `if` statement checking for `!isFocusableInTouchMode()`, a nested `for` loop, and further conditions within these control statements. This change alters the control flow of the method, making the method implementation different, so the change type is 3.","The introduction of new control statements and condition checks can result in different return values based on new conditions. Specifically, the new code can return `false` early if certain conditions are met, which wasn't the case in the earlier version. This change can lead to different method behavior, thus the CI type is 1."
352,<android.preference.PreferenceActivity: void switchToHeader(Header)>,20,21,<android.preference.PreferenceActivity: void switchToHeader(Header)>,<android.preference.PreferenceActivity: void switchToHeader(Header)>,0,"MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(if (mCurHeader, []), Expression(, [])]), Statement(// This is the header we are currently displaying.  Just make sure, []), Statement(// to pop the stack up to its root state., []), MethodCall(getFragmentManager().popBackStack(BACK_STACK_PREFS, FragmentManager.POP_BACK_STACK_INCLUSIVE), [VariableReference(getFragmentManager(), []), Expression(BACK_STACK_PREFS, []), Expression(FragmentManager.POP_BACK_STACK_INCLUSIVE, [])]), Statement(} else {, []), AssignmentExpression(=, [VariableReference(if (header.fragment, []), Expression(, [])]), Statement(throw new IllegalStateException(""can't switch to header that has no fragment""), []), Statement(}, []), AssignmentExpression(=, [VariableReference(int direction, []), Expression(mHeaders.indexOf(header) - mHeaders.indexOf(mCurHeader), [])]), Statement(setSelectedHeader(header), []), Statement(}, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(if (mCurHeader, []), Expression(, [])])    VariableReference(if (mCurHeader, [])    Expression(, [])  Statement(// This is the header we are currently displaying.  Just make sure, [])  Statement(// to pop the stack up to its root state., [])  MethodCall(getFragmentManager().popBackStack(BACK_STACK_PREFS, FragmentManager.POP_BACK_STACK_INCLUSIVE), [VariableReference(getFragmentManager(), []), Expression(BACK_STACK_PREFS, []), Expression(FragmentManager.POP_BACK_STACK_INCLUSIVE, [])])    VariableReference(getFragmentManager(), [])    Expression(BACK_STACK_PREFS, [])    Expression(FragmentManager.POP_BACK_STACK_INCLUSIVE, [])  Statement(} else {, [])  AssignmentExpression(=, [VariableReference(if (header.fragment, []), Expression(, [])])    VariableReference(if (header.fragment, [])    Expression(, [])  Statement(throw new IllegalStateException(""can't switch to header that has no fragment""), [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(int direction, []), Expression(mHeaders.indexOf(header) - mHeaders.indexOf(mCurHeader), [])])    VariableReference(int direction, [])    Expression(mHeaders.indexOf(header) - mHeaders.indexOf(mCurHeader), [])  Statement(setSelectedHeader(header), [])  Statement(}, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(if (mCurHeader, []), Expression(, [])]), Statement(// This is the header we are currently displaying.  Just make sure, []), Statement(// to pop the stack up to its root state., []), MethodCall(getFragmentManager().popBackStack(BACK_STACK_PREFS, FragmentManager.POP_BACK_STACK_INCLUSIVE), [VariableReference(getFragmentManager(), []), Expression(BACK_STACK_PREFS, []), Expression(FragmentManager.POP_BACK_STACK_INCLUSIVE, [])]), Statement(} else {, []), AssignmentExpression(=, [VariableReference(if (header.fragment, []), Expression(, [])]), Statement(throw new IllegalStateException(""can't switch to header that has no fragment""), []), Statement(}, []), Statement(setSelectedHeader(header), []), Statement(}, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(if (mCurHeader, []), Expression(, [])])    VariableReference(if (mCurHeader, [])    Expression(, [])  Statement(// This is the header we are currently displaying.  Just make sure, [])  Statement(// to pop the stack up to its root state., [])  MethodCall(getFragmentManager().popBackStack(BACK_STACK_PREFS, FragmentManager.POP_BACK_STACK_INCLUSIVE), [VariableReference(getFragmentManager(), []), Expression(BACK_STACK_PREFS, []), Expression(FragmentManager.POP_BACK_STACK_INCLUSIVE, [])])    VariableReference(getFragmentManager(), [])    Expression(BACK_STACK_PREFS, [])    Expression(FragmentManager.POP_BACK_STACK_INCLUSIVE, [])  Statement(} else {, [])  AssignmentExpression(=, [VariableReference(if (header.fragment, []), Expression(, [])])    VariableReference(if (header.fragment, [])    Expression(, [])  Statement(throw new IllegalStateException(""can't switch to header that has no fragment""), [])  Statement(}, [])  Statement(setSelectedHeader(header), [])  Statement(}, [])  Statement(}, [])",1,"/**
 * When in two-pane mode, switch to the fragment pane to show the given
 * preference fragment.
 *
 * @param header The new header to display.
 */
","/**
 * When in two-pane mode, switch to the fragment pane to show the given
 * preference fragment.
 *
 * @param header The new header to display.
 */
",-1,,,-1,-1,-1,-1,-1,4,0,4,0,"The only notable change is the removal of the assignment statement for the variable `direction` in the late implementation. No other control dependencies, return statements, or exception handling have changed, so the change type is 4.","The removal of the assignment statement to the variable `direction` does not impact the behavior of the API concerning its return value or exception handling. Therefore, there is no compatibility issue, and the CI type is 0."
551,<android.view.View: void setAutofillId(AutofillId)>,28,29,<android.view.View: void setAutofillId(AutofillId)>,<android.view.View: void setAutofillId(AutofillId)>,0,"MethodDeclaration(method_body, [Statement({, []), Statement(// TODO(b/37566627): add unit / CTS test for all possible combinations below, []), MethodCall(Log.v(VIEW_LOG_TAG, ""setAutofill(): from "" + mAutofillId + "" to "" + id), [VariableReference(Log, []), Expression(VIEW_LOG_TAG, []), Expression(""setAutofill(): from "" + mAutofillId + "" to "" + id, [])]), Statement(}, []), Statement(if (isAttachedToWindow()) {, []), Statement(throw new IllegalStateException(""Cannot set autofill id when view is attached""), []), Statement(}, []), AssignmentExpression(=, [VariableReference(if (id !, []), Expression(null && id.isVirtual()) {, [])]), Statement(throw new IllegalStateException(""Cannot set autofill id assigned to virtual views""), []), Statement(}, []), AssignmentExpression(=, [VariableReference(if (id, []), Expression(, [])]), Statement(// Ignore reset because it was never explicitly set before., []), Statement(return, []), Statement(}, []), AssignmentExpression(=, [VariableReference(mAutofillId, []), Expression(id, [])]), AssignmentExpression(=, [VariableReference(if (id !, []), Expression(null) {, [])]), AssignmentExpression(=, [VariableReference(mAutofillViewId, []), Expression(id.getViewId(), [])]), AssignmentExpression(=, [VariableReference(mPrivateFlags3 |, []), Expression(PFLAG3_AUTOFILLID_EXPLICITLY_SET, [])]), Statement(} else {, []), AssignmentExpression(=, [VariableReference(mAutofillViewId, []), Expression(NO_ID, [])]), AssignmentExpression(=, [VariableReference(mPrivateFlags3 &, []), Expression(~PFLAG3_AUTOFILLID_EXPLICITLY_SET, [])]), Statement(}, []), Statement(}, [])])  Statement({, [])  Statement(// TODO(b/37566627): add unit / CTS test for all possible combinations below, [])  MethodCall(Log.v(VIEW_LOG_TAG, ""setAutofill(): from "" + mAutofillId + "" to "" + id), [VariableReference(Log, []), Expression(VIEW_LOG_TAG, []), Expression(""setAutofill(): from "" + mAutofillId + "" to "" + id, [])])    VariableReference(Log, [])    Expression(VIEW_LOG_TAG, [])    Expression(""setAutofill(): from "" + mAutofillId + "" to "" + id, [])  Statement(}, [])  Statement(if (isAttachedToWindow()) {, [])  Statement(throw new IllegalStateException(""Cannot set autofill id when view is attached""), [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(if (id !, []), Expression(null && id.isVirtual()) {, [])])    VariableReference(if (id !, [])    Expression(null && id.isVirtual()) {, [])  Statement(throw new IllegalStateException(""Cannot set autofill id assigned to virtual views""), [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(if (id, []), Expression(, [])])    VariableReference(if (id, [])    Expression(, [])  Statement(// Ignore reset because it was never explicitly set before., [])  Statement(return, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(mAutofillId, []), Expression(id, [])])    VariableReference(mAutofillId, [])    Expression(id, [])  AssignmentExpression(=, [VariableReference(if (id !, []), Expression(null) {, [])])    VariableReference(if (id !, [])    Expression(null) {, [])  AssignmentExpression(=, [VariableReference(mAutofillViewId, []), Expression(id.getViewId(), [])])    VariableReference(mAutofillViewId, [])    Expression(id.getViewId(), [])  AssignmentExpression(=, [VariableReference(mPrivateFlags3 |, []), Expression(PFLAG3_AUTOFILLID_EXPLICITLY_SET, [])])    VariableReference(mPrivateFlags3 |, [])    Expression(PFLAG3_AUTOFILLID_EXPLICITLY_SET, [])  Statement(} else {, [])  AssignmentExpression(=, [VariableReference(mAutofillViewId, []), Expression(NO_ID, [])])    VariableReference(mAutofillViewId, [])    Expression(NO_ID, [])  AssignmentExpression(=, [VariableReference(mPrivateFlags3 &, []), Expression(~PFLAG3_AUTOFILLID_EXPLICITLY_SET, [])])    VariableReference(mPrivateFlags3 &, [])    Expression(~PFLAG3_AUTOFILLID_EXPLICITLY_SET, [])  Statement(}, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(// TODO(b/37566627): add unit / CTS test for all possible combinations below, []), MethodCall(if (Log.isLoggable(AUTOFILL_LOG_TAG, Log.VERBOSE)), [VariableReference(if (Log, []), Expression(AUTOFILL_LOG_TAG, []), Expression(Log.VERBOSE), [])]), MethodCall(Log.v(AUTOFILL_LOG_TAG, ""setAutofill(): from "" + mAutofillId + "" to "" + id), [VariableReference(Log, []), Expression(AUTOFILL_LOG_TAG, []), Expression(""setAutofill(): from "" + mAutofillId + "" to "" + id, [])]), Statement(}, []), Statement(if (isAttachedToWindow()) {, []), Statement(throw new IllegalStateException(""Cannot set autofill id when view is attached""), []), Statement(}, []), AssignmentExpression(=, [VariableReference(if (id !, []), Expression(null && !id.isNonVirtual()) {, [])]), Statement(throw new IllegalStateException(""Cannot set autofill id assigned to virtual views""), []), Statement(}, []), AssignmentExpression(=, [VariableReference(if (id, []), Expression(, [])]), Statement(// Ignore reset because it was never explicitly set before., []), Statement(return, []), Statement(}, []), AssignmentExpression(=, [VariableReference(mAutofillId, []), Expression(id, [])]), AssignmentExpression(=, [VariableReference(if (id !, []), Expression(null) {, [])]), AssignmentExpression(=, [VariableReference(mAutofillViewId, []), Expression(id.getViewId(), [])]), AssignmentExpression(=, [VariableReference(mPrivateFlags3 |, []), Expression(PFLAG3_AUTOFILLID_EXPLICITLY_SET, [])]), Statement(} else {, []), AssignmentExpression(=, [VariableReference(mAutofillViewId, []), Expression(NO_ID, [])]), AssignmentExpression(=, [VariableReference(mPrivateFlags3 &, []), Expression(~PFLAG3_AUTOFILLID_EXPLICITLY_SET, [])]), Statement(}, []), Statement(}, [])])  Statement({, [])  Statement(// TODO(b/37566627): add unit / CTS test for all possible combinations below, [])  MethodCall(if (Log.isLoggable(AUTOFILL_LOG_TAG, Log.VERBOSE)), [VariableReference(if (Log, []), Expression(AUTOFILL_LOG_TAG, []), Expression(Log.VERBOSE), [])])    VariableReference(if (Log, [])    Expression(AUTOFILL_LOG_TAG, [])    Expression(Log.VERBOSE), [])  MethodCall(Log.v(AUTOFILL_LOG_TAG, ""setAutofill(): from "" + mAutofillId + "" to "" + id), [VariableReference(Log, []), Expression(AUTOFILL_LOG_TAG, []), Expression(""setAutofill(): from "" + mAutofillId + "" to "" + id, [])])    VariableReference(Log, [])    Expression(AUTOFILL_LOG_TAG, [])    Expression(""setAutofill(): from "" + mAutofillId + "" to "" + id, [])  Statement(}, [])  Statement(if (isAttachedToWindow()) {, [])  Statement(throw new IllegalStateException(""Cannot set autofill id when view is attached""), [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(if (id !, []), Expression(null && !id.isNonVirtual()) {, [])])    VariableReference(if (id !, [])    Expression(null && !id.isNonVirtual()) {, [])  Statement(throw new IllegalStateException(""Cannot set autofill id assigned to virtual views""), [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(if (id, []), Expression(, [])])    VariableReference(if (id, [])    Expression(, [])  Statement(// Ignore reset because it was never explicitly set before., [])  Statement(return, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(mAutofillId, []), Expression(id, [])])    VariableReference(mAutofillId, [])    Expression(id, [])  AssignmentExpression(=, [VariableReference(if (id !, []), Expression(null) {, [])])    VariableReference(if (id !, [])    Expression(null) {, [])  AssignmentExpression(=, [VariableReference(mAutofillViewId, []), Expression(id.getViewId(), [])])    VariableReference(mAutofillViewId, [])    Expression(id.getViewId(), [])  AssignmentExpression(=, [VariableReference(mPrivateFlags3 |, []), Expression(PFLAG3_AUTOFILLID_EXPLICITLY_SET, [])])    VariableReference(mPrivateFlags3 |, [])    Expression(PFLAG3_AUTOFILLID_EXPLICITLY_SET, [])  Statement(} else {, [])  AssignmentExpression(=, [VariableReference(mAutofillViewId, []), Expression(NO_ID, [])])    VariableReference(mAutofillViewId, [])    Expression(NO_ID, [])  AssignmentExpression(=, [VariableReference(mPrivateFlags3 &, []), Expression(~PFLAG3_AUTOFILLID_EXPLICITLY_SET, [])])    VariableReference(mPrivateFlags3 &, [])    Expression(~PFLAG3_AUTOFILLID_EXPLICITLY_SET, [])  Statement(}, [])  Statement(}, [])",1,"/**
 * Sets the unique, logical identifier of this view in the activity, for autofill purposes.
 *
 * <p>The autofill id is created on demand, and this method should only be called when a view is
 * reused after {@link #dispatchProvideAutofillStructure(ViewStructure, int)} is called, as
 * that method creates a snapshot of the view that is passed along to the autofill service.
 *
 * <p>This method is typically used when view subtrees are recycled to represent different
 * content* &mdash;in this case, the autofill id can be saved before the view content is swapped
 * out, and restored later when it's swapped back in. For example:
 *
 * <pre>
 * EditText reusableView = ...;
 * ViewGroup parentView = ...;
 * AutofillManager afm = ...;
 *
 * // Swap out the view and change its contents
 * AutofillId oldId = reusableView.getAutofillId();
 * CharSequence oldText = reusableView.getText();
 * parentView.removeView(reusableView);
 * AutofillId newId = afm.getNextAutofillId();
 * reusableView.setText(""New I am"");
 * reusableView.setAutofillId(newId);
 * parentView.addView(reusableView);
 *
 * // Later, swap the old content back in
 * parentView.removeView(reusableView);
 * reusableView.setAutofillId(oldId);
 * reusableView.setText(oldText);
 * parentView.addView(reusableView);
 * </pre>
 *
 * @param id an autofill ID that is unique in the {@link android.app.Activity} hosting the view,
 * or {@code null} to reset it. Usually it's an id previously allocated to another view (and
 * obtained through {@link #getAutofillId()}), or a new value obtained through
 * {@link AutofillManager#getNextAutofillId()}.
 *
 * @throws IllegalStateException if the view is already {@link #isAttachedToWindow() attached to
 * a window}.
 *
 * @throws IllegalArgumentException if the id is an autofill id associated with a virtual view.
 */
","/**
 * Sets the unique, logical identifier of this view in the activity, for autofill purposes.
 *
 * <p>The autofill id is created on demand, and this method should only be called when a view is
 * reused after {@link #dispatchProvideAutofillStructure(ViewStructure, int)} is called, as
 * that method creates a snapshot of the view that is passed along to the autofill service.
 *
 * <p>This method is typically used when view subtrees are recycled to represent different
 * content* &mdash;in this case, the autofill id can be saved before the view content is swapped
 * out, and restored later when it's swapped back in. For example:
 *
 * <pre>
 * EditText reusableView = ...;
 * ViewGroup parentView = ...;
 * AutofillManager afm = ...;
 *
 * // Swap out the view and change its contents
 * AutofillId oldId = reusableView.getAutofillId();
 * CharSequence oldText = reusableView.getText();
 * parentView.removeView(reusableView);
 * AutofillId newId = afm.getNextAutofillId();
 * reusableView.setText(""New I am"");
 * reusableView.setAutofillId(newId);
 * parentView.addView(reusableView);
 *
 * // Later, swap the old content back in
 * parentView.removeView(reusableView);
 * reusableView.setAutofillId(oldId);
 * reusableView.setText(oldText);
 * parentView.addView(reusableView);
 * </pre>
 *
 * @param id an autofill ID that is unique in the {@link android.app.Activity} hosting the view,
 * or {@code null} to reset it. Usually it's an id previously allocated to another view (and
 * obtained through {@link #getAutofillId()}), or a new value obtained through
 * {@link AutofillManager#getNextAutofillId()}.
 *
 * @throws IllegalStateException if the view is already {@link #isAttachedToWindow() attached to
 * a window}.
 *
 * @throws IllegalArgumentException if the id is an autofill id associated with a virtual view.
 */
",-1,,,-1,-1,-1,-1,-1,"2,3,4",2,"2,3,4",2,"The log statement was updated to include a conditional log check if (Log.isLoggable(AUTOFILL_LOG_TAG, Log.VERBOSE)), and the `id.isVirtual()` check has been changed to `id.isNonVirtual()`. The change in the log statement and additional condition check are classified as 4 (other statement changed). The control dependency altered due to difference in the condition check, thus classified as 3. They also involve changes related to validation and expectation, classified as 2 (exception handling).","The change in the condition checking is essentially related to exception handling when setting the autofill ID. This could potentially lead to the API throwing different exceptions based on different conditions, hence the CI type is 2."
363,"<android.app.ContextImpl: void sendOrderedBroadcast(Intent,String)>",16,17,"<android.app.ContextImpl: void sendOrderedBroadcast(Intent,String)>","<android.app.ContextImpl: void sendOrderedBroadcast(Intent,String)>",0,"MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(String resolvedType, []), Expression(intent.resolveTypeIfNeeded(getContentResolver()), [])]), Statement(try {, []), MethodCall(intent.setAllowFds(false), [VariableReference(intent, []), Expression(false, [])]), MethodCall(ActivityManagerNative.getDefault().broadcastIntent(mMainThread.getApplicationThread(), intent, resolvedType, null, Activity.RESULT_OK, null, null, receiverPermission, true, false, Binder.getOrigCallingUser()), [VariableReference(ActivityManagerNative, []), Expression().broadcastIntent(mMainThread.getApplicationThread(), []), Expression(intent, []), Expression(resolvedType, []), Expression(null, []), Expression(Activity.RESULT_OK, []), Expression(null, []), Expression(null, []), Expression(receiverPermission, []), Expression(true, []), Expression(false, []), Expression(Binder.getOrigCallingUser(), [])]), Statement(} catch (RemoteException e) {, []), Statement(}, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(String resolvedType, []), Expression(intent.resolveTypeIfNeeded(getContentResolver()), [])])    VariableReference(String resolvedType, [])    Expression(intent.resolveTypeIfNeeded(getContentResolver()), [])  Statement(try {, [])  MethodCall(intent.setAllowFds(false), [VariableReference(intent, []), Expression(false, [])])    VariableReference(intent, [])    Expression(false, [])  MethodCall(ActivityManagerNative.getDefault().broadcastIntent(mMainThread.getApplicationThread(), intent, resolvedType, null, Activity.RESULT_OK, null, null, receiverPermission, true, false, Binder.getOrigCallingUser()), [VariableReference(ActivityManagerNative, []), Expression().broadcastIntent(mMainThread.getApplicationThread(), []), Expression(intent, []), Expression(resolvedType, []), Expression(null, []), Expression(Activity.RESULT_OK, []), Expression(null, []), Expression(null, []), Expression(receiverPermission, []), Expression(true, []), Expression(false, []), Expression(Binder.getOrigCallingUser(), [])])    VariableReference(ActivityManagerNative, [])    Expression().broadcastIntent(mMainThread.getApplicationThread(), [])    Expression(intent, [])    Expression(resolvedType, [])    Expression(null, [])    Expression(Activity.RESULT_OK, [])    Expression(null, [])    Expression(null, [])    Expression(receiverPermission, [])    Expression(true, [])    Expression(false, [])    Expression(Binder.getOrigCallingUser(), [])  Statement(} catch (RemoteException e) {, [])  Statement(}, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(warnIfCallingFromSystemProcess(), []), AssignmentExpression(=, [VariableReference(String resolvedType, []), Expression(intent.resolveTypeIfNeeded(getContentResolver()), [])]), Statement(try {, []), MethodCall(intent.setAllowFds(false), [VariableReference(intent, []), Expression(false, [])]), MethodCall(ActivityManagerNative.getDefault().broadcastIntent(mMainThread.getApplicationThread(), intent, resolvedType, null, Activity.RESULT_OK, null, null, receiverPermission, true, false, getUserId()), [VariableReference(ActivityManagerNative, []), Expression().broadcastIntent(mMainThread.getApplicationThread(), []), Expression(intent, []), Expression(resolvedType, []), Expression(null, []), Expression(Activity.RESULT_OK, []), Expression(null, []), Expression(null, []), Expression(receiverPermission, []), Expression(true, []), Expression(false, []), Expression(getUserId(), [])]), Statement(} catch (RemoteException e) {, []), Statement(}, []), Statement(}, [])])  Statement({, [])  Statement(warnIfCallingFromSystemProcess(), [])  AssignmentExpression(=, [VariableReference(String resolvedType, []), Expression(intent.resolveTypeIfNeeded(getContentResolver()), [])])    VariableReference(String resolvedType, [])    Expression(intent.resolveTypeIfNeeded(getContentResolver()), [])  Statement(try {, [])  MethodCall(intent.setAllowFds(false), [VariableReference(intent, []), Expression(false, [])])    VariableReference(intent, [])    Expression(false, [])  MethodCall(ActivityManagerNative.getDefault().broadcastIntent(mMainThread.getApplicationThread(), intent, resolvedType, null, Activity.RESULT_OK, null, null, receiverPermission, true, false, getUserId()), [VariableReference(ActivityManagerNative, []), Expression().broadcastIntent(mMainThread.getApplicationThread(), []), Expression(intent, []), Expression(resolvedType, []), Expression(null, []), Expression(Activity.RESULT_OK, []), Expression(null, []), Expression(null, []), Expression(receiverPermission, []), Expression(true, []), Expression(false, []), Expression(getUserId(), [])])    VariableReference(ActivityManagerNative, [])    Expression().broadcastIntent(mMainThread.getApplicationThread(), [])    Expression(intent, [])    Expression(resolvedType, [])    Expression(null, [])    Expression(Activity.RESULT_OK, [])    Expression(null, [])    Expression(null, [])    Expression(receiverPermission, [])    Expression(true, [])    Expression(false, [])    Expression(getUserId(), [])  Statement(} catch (RemoteException e) {, [])  Statement(}, [])  Statement(}, [])",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,"4,5",1,"3,4",0,"The late version introduces a new statement `warnIfCallingFromSystemProcess()` at the beginning of the method and changes the parameter in the `broadcastIntent` method call from `Binder.getOrigCallingUser()` to `getUserId()`, so the change type is 3,4.","The changes do not alter the return type or the exception handling of the method, so there is no Compatibility Issue (CI) triggered by this change."
729,<android.widget.AdapterView: int getPositionForView(View)>,22,23,<android.widget.AdapterView: int getPositionForView(View)>,<android.widget.AdapterView: int getPositionForView(View)>,0,"MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(View listItem, []), Expression(view, [])]), Statement(try {, []), Statement(View v, []), AssignmentExpression(=, [VariableReference(while (!(v, []), Expression((View) listItem.getParent()).equals(this)) {, [])]), AssignmentExpression(=, [VariableReference(listItem, []), Expression(v, [])]), Statement(}, []), Statement(} catch (ClassCastException e) {, []), Statement(// We made it up to the window without find this list view, []), Statement(return INVALID_POSITION, []), Statement(}, []), Statement(// Search the children for the list item, []), AssignmentExpression(=, [VariableReference(final int childCount, []), Expression(getChildCount(), [])]), AssignmentExpression(=, [VariableReference(for (int i, []), Expression(0, [])]), Statement(i < childCount, []), Statement(i++) {, []), MethodCall(if (getChildAt(i).equals(listItem)), [VariableReference(if (getChildAt(i), []), Expression(listItem), [])]), Statement(return mFirstPosition + i, []), Statement(}, []), Statement(}, []), Statement(// Child not found!, []), Statement(return INVALID_POSITION, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(View listItem, []), Expression(view, [])])    VariableReference(View listItem, [])    Expression(view, [])  Statement(try {, [])  Statement(View v, [])  AssignmentExpression(=, [VariableReference(while (!(v, []), Expression((View) listItem.getParent()).equals(this)) {, [])])    VariableReference(while (!(v, [])    Expression((View) listItem.getParent()).equals(this)) {, [])  AssignmentExpression(=, [VariableReference(listItem, []), Expression(v, [])])    VariableReference(listItem, [])    Expression(v, [])  Statement(}, [])  Statement(} catch (ClassCastException e) {, [])  Statement(// We made it up to the window without find this list view, [])  Statement(return INVALID_POSITION, [])  Statement(}, [])  Statement(// Search the children for the list item, [])  AssignmentExpression(=, [VariableReference(final int childCount, []), Expression(getChildCount(), [])])    VariableReference(final int childCount, [])    Expression(getChildCount(), [])  AssignmentExpression(=, [VariableReference(for (int i, []), Expression(0, [])])    VariableReference(for (int i, [])    Expression(0, [])  Statement(i < childCount, [])  Statement(i++) {, [])  MethodCall(if (getChildAt(i).equals(listItem)), [VariableReference(if (getChildAt(i), []), Expression(listItem), [])])    VariableReference(if (getChildAt(i), [])    Expression(listItem), [])  Statement(return mFirstPosition + i, [])  Statement(}, [])  Statement(}, [])  Statement(// Child not found!, [])  Statement(return INVALID_POSITION, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(View listItem, []), Expression(view, [])]), Statement(try {, []), Statement(View v, []), AssignmentExpression(=, [VariableReference(while ((v, []), Expression((View) listItem.getParent()) !, [])]), AssignmentExpression(=, [VariableReference(listItem, []), Expression(v, [])]), Statement(}, []), Statement(} catch (ClassCastException e) {, []), Statement(// We made it up to the window without find this list view, []), Statement(return INVALID_POSITION, []), Statement(}, []), AssignmentExpression(=, [VariableReference(if (listItem !, []), Expression(null) {, [])]), Statement(// Search the children for the list item, []), AssignmentExpression(=, [VariableReference(final int childCount, []), Expression(getChildCount(), [])]), AssignmentExpression(=, [VariableReference(for (int i, []), Expression(0, [])]), Statement(i < childCount, []), Statement(i++) {, []), MethodCall(if (getChildAt(i).equals(listItem)), [VariableReference(if (getChildAt(i), []), Expression(listItem), [])]), Statement(return mFirstPosition + i, []), Statement(}, []), Statement(}, []), Statement(}, []), Statement(// Child not found!, []), Statement(return INVALID_POSITION, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(View listItem, []), Expression(view, [])])    VariableReference(View listItem, [])    Expression(view, [])  Statement(try {, [])  Statement(View v, [])  AssignmentExpression(=, [VariableReference(while ((v, []), Expression((View) listItem.getParent()) !, [])])    VariableReference(while ((v, [])    Expression((View) listItem.getParent()) !, [])  AssignmentExpression(=, [VariableReference(listItem, []), Expression(v, [])])    VariableReference(listItem, [])    Expression(v, [])  Statement(}, [])  Statement(} catch (ClassCastException e) {, [])  Statement(// We made it up to the window without find this list view, [])  Statement(return INVALID_POSITION, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(if (listItem !, []), Expression(null) {, [])])    VariableReference(if (listItem !, [])    Expression(null) {, [])  Statement(// Search the children for the list item, [])  AssignmentExpression(=, [VariableReference(final int childCount, []), Expression(getChildCount(), [])])    VariableReference(final int childCount, [])    Expression(getChildCount(), [])  AssignmentExpression(=, [VariableReference(for (int i, []), Expression(0, [])])    VariableReference(for (int i, [])    Expression(0, [])  Statement(i < childCount, [])  Statement(i++) {, [])  MethodCall(if (getChildAt(i).equals(listItem)), [VariableReference(if (getChildAt(i), []), Expression(listItem), [])])    VariableReference(if (getChildAt(i), [])    Expression(listItem), [])  Statement(return mFirstPosition + i, [])  Statement(}, [])  Statement(}, [])  Statement(}, [])  Statement(// Child not found!, [])  Statement(return INVALID_POSITION, [])  Statement(}, [])",1,"/**
 * Get the position within the adapter's data set for the view, where view is a an adapter item
 * or a descendant of an adapter item.
 *
 * @param view an adapter item, or a descendant of an adapter item. This must be visible in this
 * AdapterView at the time of the call.
 * @return the position within the adapter's data set of the view, or {@link #INVALID_POSITION}
 * if the view does not correspond to a list item (or it is not currently visible).
 */
","/**
 * Get the position within the adapter's data set for the view, where view is a an adapter item
 * or a descendant of an adapter item.
 *
 * @param view an adapter item, or a descendant of an adapter item. This must be visible in this
 * AdapterView at the time of the call.
 * @return the position within the adapter's data set of the view, or {@link #INVALID_POSITION}
 * if the view does not correspond to a list item (or it is not currently visible).
 */
",-1,,,-1,-1,-1,-1,-1,3,1,"3,4",0,"Several statements have changed, including the condition statement in the while loop and the addition of a null check on the listItem before searching its parent. This can be classified as changes in both control dependencies (3) and other statements (4).","Even though there are structural changes in the control flow and some additional checks, these changes do not affect the return type or introduce new exceptions. The core behavior of determining the position within the adapter's data set for a given view remains functionally consistent, so the CI type is 0."
800,<android.app.DialogFragment: void onActivityCreated(Bundle)>,23,24,<android.app.DialogFragment: void onActivityCreated(Bundle)>,<android.app.DialogFragment: void onActivityCreated(Bundle)>,0,"MethodDeclaration(method_body, [Statement({, []), MethodCall(super.onActivityCreated(savedInstanceState), [VariableReference(super, []), Expression(savedInstanceState, [])]), Statement(if (!mShowsDialog) {, []), Statement(return, []), Statement(}, []), AssignmentExpression(=, [VariableReference(View view, []), Expression(getView(), [])]), AssignmentExpression(=, [VariableReference(if (view !, []), Expression(null) {, [])]), AssignmentExpression(=, [VariableReference(if (view.getParent() !, []), Expression(null) {, [])]), Statement(throw new IllegalStateException(""DialogFragment can not be attached to a container view""), []), Statement(}, []), MethodCall(mDialog.setContentView(view), [VariableReference(mDialog, []), Expression(view, [])]), Statement(}, []), MethodCall(mDialog.setOwnerActivity(getActivity()), [VariableReference(mDialog, []), Expression(getActivity(), [])]), MethodCall(mDialog.setCancelable(mCancelable), [VariableReference(mDialog, []), Expression(mCancelable, [])]), MethodCall(if (!mDialog.takeCancelAndDismissListeners(""DialogFragment"", this, this)), [VariableReference(if (!mDialog, []), Expression(""DialogFragment"", []), Expression(this, []), Expression(this), [])]), Statement(throw new IllegalStateException(""You can not set Dialog's OnCancelListener or OnDismissListener""), []), Statement(}, []), AssignmentExpression(=, [VariableReference(if (savedInstanceState !, []), Expression(null) {, [])]), AssignmentExpression(=, [VariableReference(Bundle dialogState, []), Expression(savedInstanceState.getBundle(SAVED_DIALOG_STATE_TAG), [])]), AssignmentExpression(=, [VariableReference(if (dialogState !, []), Expression(null) {, [])]), MethodCall(mDialog.onRestoreInstanceState(dialogState), [VariableReference(mDialog, []), Expression(dialogState, [])]), Statement(}, []), Statement(}, []), Statement(}, [])])  Statement({, [])  MethodCall(super.onActivityCreated(savedInstanceState), [VariableReference(super, []), Expression(savedInstanceState, [])])    VariableReference(super, [])    Expression(savedInstanceState, [])  Statement(if (!mShowsDialog) {, [])  Statement(return, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(View view, []), Expression(getView(), [])])    VariableReference(View view, [])    Expression(getView(), [])  AssignmentExpression(=, [VariableReference(if (view !, []), Expression(null) {, [])])    VariableReference(if (view !, [])    Expression(null) {, [])  AssignmentExpression(=, [VariableReference(if (view.getParent() !, []), Expression(null) {, [])])    VariableReference(if (view.getParent() !, [])    Expression(null) {, [])  Statement(throw new IllegalStateException(""DialogFragment can not be attached to a container view""), [])  Statement(}, [])  MethodCall(mDialog.setContentView(view), [VariableReference(mDialog, []), Expression(view, [])])    VariableReference(mDialog, [])    Expression(view, [])  Statement(}, [])  MethodCall(mDialog.setOwnerActivity(getActivity()), [VariableReference(mDialog, []), Expression(getActivity(), [])])    VariableReference(mDialog, [])    Expression(getActivity(), [])  MethodCall(mDialog.setCancelable(mCancelable), [VariableReference(mDialog, []), Expression(mCancelable, [])])    VariableReference(mDialog, [])    Expression(mCancelable, [])  MethodCall(if (!mDialog.takeCancelAndDismissListeners(""DialogFragment"", this, this)), [VariableReference(if (!mDialog, []), Expression(""DialogFragment"", []), Expression(this, []), Expression(this), [])])    VariableReference(if (!mDialog, [])    Expression(""DialogFragment"", [])    Expression(this, [])    Expression(this), [])  Statement(throw new IllegalStateException(""You can not set Dialog's OnCancelListener or OnDismissListener""), [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(if (savedInstanceState !, []), Expression(null) {, [])])    VariableReference(if (savedInstanceState !, [])    Expression(null) {, [])  AssignmentExpression(=, [VariableReference(Bundle dialogState, []), Expression(savedInstanceState.getBundle(SAVED_DIALOG_STATE_TAG), [])])    VariableReference(Bundle dialogState, [])    Expression(savedInstanceState.getBundle(SAVED_DIALOG_STATE_TAG), [])  AssignmentExpression(=, [VariableReference(if (dialogState !, []), Expression(null) {, [])])    VariableReference(if (dialogState !, [])    Expression(null) {, [])  MethodCall(mDialog.onRestoreInstanceState(dialogState), [VariableReference(mDialog, []), Expression(dialogState, [])])    VariableReference(mDialog, [])    Expression(dialogState, [])  Statement(}, [])  Statement(}, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), MethodCall(super.onActivityCreated(savedInstanceState), [VariableReference(super, []), Expression(savedInstanceState, [])]), Statement(if (!mShowsDialog) {, []), Statement(return, []), Statement(}, []), AssignmentExpression(=, [VariableReference(View view, []), Expression(getView(), [])]), AssignmentExpression(=, [VariableReference(if (view !, []), Expression(null) {, [])]), AssignmentExpression(=, [VariableReference(if (view.getParent() !, []), Expression(null) {, [])]), Statement(throw new IllegalStateException(""DialogFragment can not be attached to a container view""), []), Statement(}, []), MethodCall(mDialog.setContentView(view), [VariableReference(mDialog, []), Expression(view, [])]), Statement(}, []), AssignmentExpression(=, [VariableReference(final Activity activity, []), Expression(getActivity(), [])]), AssignmentExpression(=, [VariableReference(if (activity !, []), Expression(null) {, [])]), MethodCall(mDialog.setOwnerActivity(activity), [VariableReference(mDialog, []), Expression(activity, [])]), Statement(}, []), MethodCall(mDialog.setCancelable(mCancelable), [VariableReference(mDialog, []), Expression(mCancelable, [])]), MethodCall(if (!mDialog.takeCancelAndDismissListeners(""DialogFragment"", this, this)), [VariableReference(if (!mDialog, []), Expression(""DialogFragment"", []), Expression(this, []), Expression(this), [])]), Statement(throw new IllegalStateException(""You can not set Dialog's OnCancelListener or OnDismissListener""), []), Statement(}, []), AssignmentExpression(=, [VariableReference(if (savedInstanceState !, []), Expression(null) {, [])]), AssignmentExpression(=, [VariableReference(Bundle dialogState, []), Expression(savedInstanceState.getBundle(SAVED_DIALOG_STATE_TAG), [])]), AssignmentExpression(=, [VariableReference(if (dialogState !, []), Expression(null) {, [])]), MethodCall(mDialog.onRestoreInstanceState(dialogState), [VariableReference(mDialog, []), Expression(dialogState, [])]), Statement(}, []), Statement(}, []), Statement(}, [])])  Statement({, [])  MethodCall(super.onActivityCreated(savedInstanceState), [VariableReference(super, []), Expression(savedInstanceState, [])])    VariableReference(super, [])    Expression(savedInstanceState, [])  Statement(if (!mShowsDialog) {, [])  Statement(return, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(View view, []), Expression(getView(), [])])    VariableReference(View view, [])    Expression(getView(), [])  AssignmentExpression(=, [VariableReference(if (view !, []), Expression(null) {, [])])    VariableReference(if (view !, [])    Expression(null) {, [])  AssignmentExpression(=, [VariableReference(if (view.getParent() !, []), Expression(null) {, [])])    VariableReference(if (view.getParent() !, [])    Expression(null) {, [])  Statement(throw new IllegalStateException(""DialogFragment can not be attached to a container view""), [])  Statement(}, [])  MethodCall(mDialog.setContentView(view), [VariableReference(mDialog, []), Expression(view, [])])    VariableReference(mDialog, [])    Expression(view, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(final Activity activity, []), Expression(getActivity(), [])])    VariableReference(final Activity activity, [])    Expression(getActivity(), [])  AssignmentExpression(=, [VariableReference(if (activity !, []), Expression(null) {, [])])    VariableReference(if (activity !, [])    Expression(null) {, [])  MethodCall(mDialog.setOwnerActivity(activity), [VariableReference(mDialog, []), Expression(activity, [])])    VariableReference(mDialog, [])    Expression(activity, [])  Statement(}, [])  MethodCall(mDialog.setCancelable(mCancelable), [VariableReference(mDialog, []), Expression(mCancelable, [])])    VariableReference(mDialog, [])    Expression(mCancelable, [])  MethodCall(if (!mDialog.takeCancelAndDismissListeners(""DialogFragment"", this, this)), [VariableReference(if (!mDialog, []), Expression(""DialogFragment"", []), Expression(this, []), Expression(this), [])])    VariableReference(if (!mDialog, [])    Expression(""DialogFragment"", [])    Expression(this, [])    Expression(this), [])  Statement(throw new IllegalStateException(""You can not set Dialog's OnCancelListener or OnDismissListener""), [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(if (savedInstanceState !, []), Expression(null) {, [])])    VariableReference(if (savedInstanceState !, [])    Expression(null) {, [])  AssignmentExpression(=, [VariableReference(Bundle dialogState, []), Expression(savedInstanceState.getBundle(SAVED_DIALOG_STATE_TAG), [])])    VariableReference(Bundle dialogState, [])    Expression(savedInstanceState.getBundle(SAVED_DIALOG_STATE_TAG), [])  AssignmentExpression(=, [VariableReference(if (dialogState !, []), Expression(null) {, [])])    VariableReference(if (dialogState !, [])    Expression(null) {, [])  MethodCall(mDialog.onRestoreInstanceState(dialogState), [VariableReference(mDialog, []), Expression(dialogState, [])])    VariableReference(mDialog, [])    Expression(dialogState, [])  Statement(}, [])  Statement(}, [])  Statement(}, [])",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,"3,4",0,3,0,"A minor adjustment was made in the control dependency. Specifically, the way of assigning `getActivity()` to a new final `Activity activity` variable, and checking if `activity` is not null before calling `mDialog.setOwnerActivity(activity)` was introduced in the late version. However, these changes do not affect the return value or exception handling.","The changes do not lead to a potential difference in return values or exception handling, hence no compatibility issue exists."
768,<android.hardware.radio.RadioManager.ProgramInfo: boolean equals(Object)>,27,28,<android.hardware.radio.RadioManager.ProgramInfo: boolean equals(Object)>,<android.hardware.radio.RadioManager.ProgramInfo: boolean equals(Object)>,0,"MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(if (this, []), Expression(, [])]), Statement(return true, []), Statement(if (!(obj instanceof ProgramInfo)), []), Statement(return false, []), AssignmentExpression(=, [VariableReference(ProgramInfo other, []), Expression((ProgramInfo) obj, [])]), MethodCall(if (!mSelector.equals(other.getSelector())), [VariableReference(if (!mSelector, []), Expression(other.getSelector()), [])]), Statement(return false, []), AssignmentExpression(=, [VariableReference(if (mTuned !, []), Expression(other.isTuned()), [])]), Statement(return false, []), AssignmentExpression(=, [VariableReference(if (mStereo !, []), Expression(other.isStereo()), [])]), Statement(return false, []), AssignmentExpression(=, [VariableReference(if (mDigital !, []), Expression(other.isDigital()), [])]), Statement(return false, []), AssignmentExpression(=, [VariableReference(if (mFlags !, []), Expression(other.mFlags), [])]), Statement(return false, []), AssignmentExpression(=, [VariableReference(if (mSignalStrength !, []), Expression(other.getSignalStrength()), [])]), Statement(return false, []), AssignmentExpression(=, [VariableReference(if (mMetadata, []), Expression(, [])]), AssignmentExpression(=, [VariableReference(if (other.getMetadata() !, []), Expression(null), [])]), Statement(return false, []), MethodCall(} else if (!mMetadata.equals(other.getMetadata())), [VariableReference(} else if (!mMetadata, []), Expression(other.getMetadata()), [])]), Statement(return false, []), MethodCall(if (!mVendorInfo.equals(other.mVendorInfo)), [VariableReference(if (!mVendorInfo, []), Expression(other.mVendorInfo), [])]), Statement(return false, []), Statement(return true, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(if (this, []), Expression(, [])])    VariableReference(if (this, [])    Expression(, [])  Statement(return true, [])  Statement(if (!(obj instanceof ProgramInfo)), [])  Statement(return false, [])  AssignmentExpression(=, [VariableReference(ProgramInfo other, []), Expression((ProgramInfo) obj, [])])    VariableReference(ProgramInfo other, [])    Expression((ProgramInfo) obj, [])  MethodCall(if (!mSelector.equals(other.getSelector())), [VariableReference(if (!mSelector, []), Expression(other.getSelector()), [])])    VariableReference(if (!mSelector, [])    Expression(other.getSelector()), [])  Statement(return false, [])  AssignmentExpression(=, [VariableReference(if (mTuned !, []), Expression(other.isTuned()), [])])    VariableReference(if (mTuned !, [])    Expression(other.isTuned()), [])  Statement(return false, [])  AssignmentExpression(=, [VariableReference(if (mStereo !, []), Expression(other.isStereo()), [])])    VariableReference(if (mStereo !, [])    Expression(other.isStereo()), [])  Statement(return false, [])  AssignmentExpression(=, [VariableReference(if (mDigital !, []), Expression(other.isDigital()), [])])    VariableReference(if (mDigital !, [])    Expression(other.isDigital()), [])  Statement(return false, [])  AssignmentExpression(=, [VariableReference(if (mFlags !, []), Expression(other.mFlags), [])])    VariableReference(if (mFlags !, [])    Expression(other.mFlags), [])  Statement(return false, [])  AssignmentExpression(=, [VariableReference(if (mSignalStrength !, []), Expression(other.getSignalStrength()), [])])    VariableReference(if (mSignalStrength !, [])    Expression(other.getSignalStrength()), [])  Statement(return false, [])  AssignmentExpression(=, [VariableReference(if (mMetadata, []), Expression(, [])])    VariableReference(if (mMetadata, [])    Expression(, [])  AssignmentExpression(=, [VariableReference(if (other.getMetadata() !, []), Expression(null), [])])    VariableReference(if (other.getMetadata() !, [])    Expression(null), [])  Statement(return false, [])  MethodCall(} else if (!mMetadata.equals(other.getMetadata())), [VariableReference(} else if (!mMetadata, []), Expression(other.getMetadata()), [])])    VariableReference(} else if (!mMetadata, [])    Expression(other.getMetadata()), [])  Statement(return false, [])  MethodCall(if (!mVendorInfo.equals(other.mVendorInfo)), [VariableReference(if (!mVendorInfo, []), Expression(other.mVendorInfo), [])])    VariableReference(if (!mVendorInfo, [])    Expression(other.mVendorInfo), [])  Statement(return false, [])  Statement(return true, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(if (this, []), Expression(, [])]), Statement(return true, []), Statement(if (!(obj instanceof ProgramInfo)), []), Statement(return false, []), AssignmentExpression(=, [VariableReference(ProgramInfo other, []), Expression((ProgramInfo) obj, [])]), MethodCall(if (!Objects.equals(mSelector, other.mSelector)), [VariableReference(if (!Objects, []), Expression(mSelector, []), Expression(other.mSelector), [])]), Statement(return false, []), MethodCall(if (!Objects.equals(mLogicallyTunedTo, other.mLogicallyTunedTo)), [VariableReference(if (!Objects, []), Expression(mLogicallyTunedTo, []), Expression(other.mLogicallyTunedTo), [])]), Statement(return false, []), MethodCall(if (!Objects.equals(mPhysicallyTunedTo, other.mPhysicallyTunedTo)), [VariableReference(if (!Objects, []), Expression(mPhysicallyTunedTo, []), Expression(other.mPhysicallyTunedTo), [])]), Statement(return false, []), MethodCall(if (!Objects.equals(mRelatedContent, other.mRelatedContent)), [VariableReference(if (!Objects, []), Expression(mRelatedContent, []), Expression(other.mRelatedContent), [])]), Statement(return false, []), AssignmentExpression(=, [VariableReference(if (mInfoFlags !, []), Expression(other.mInfoFlags), [])]), Statement(return false, []), AssignmentExpression(=, [VariableReference(if (mSignalQuality !, []), Expression(other.mSignalQuality), [])]), Statement(return false, []), MethodCall(if (!Objects.equals(mMetadata, other.mMetadata)), [VariableReference(if (!Objects, []), Expression(mMetadata, []), Expression(other.mMetadata), [])]), Statement(return false, []), MethodCall(if (!Objects.equals(mVendorInfo, other.mVendorInfo)), [VariableReference(if (!Objects, []), Expression(mVendorInfo, []), Expression(other.mVendorInfo), [])]), Statement(return false, []), Statement(return true, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(if (this, []), Expression(, [])])    VariableReference(if (this, [])    Expression(, [])  Statement(return true, [])  Statement(if (!(obj instanceof ProgramInfo)), [])  Statement(return false, [])  AssignmentExpression(=, [VariableReference(ProgramInfo other, []), Expression((ProgramInfo) obj, [])])    VariableReference(ProgramInfo other, [])    Expression((ProgramInfo) obj, [])  MethodCall(if (!Objects.equals(mSelector, other.mSelector)), [VariableReference(if (!Objects, []), Expression(mSelector, []), Expression(other.mSelector), [])])    VariableReference(if (!Objects, [])    Expression(mSelector, [])    Expression(other.mSelector), [])  Statement(return false, [])  MethodCall(if (!Objects.equals(mLogicallyTunedTo, other.mLogicallyTunedTo)), [VariableReference(if (!Objects, []), Expression(mLogicallyTunedTo, []), Expression(other.mLogicallyTunedTo), [])])    VariableReference(if (!Objects, [])    Expression(mLogicallyTunedTo, [])    Expression(other.mLogicallyTunedTo), [])  Statement(return false, [])  MethodCall(if (!Objects.equals(mPhysicallyTunedTo, other.mPhysicallyTunedTo)), [VariableReference(if (!Objects, []), Expression(mPhysicallyTunedTo, []), Expression(other.mPhysicallyTunedTo), [])])    VariableReference(if (!Objects, [])    Expression(mPhysicallyTunedTo, [])    Expression(other.mPhysicallyTunedTo), [])  Statement(return false, [])  MethodCall(if (!Objects.equals(mRelatedContent, other.mRelatedContent)), [VariableReference(if (!Objects, []), Expression(mRelatedContent, []), Expression(other.mRelatedContent), [])])    VariableReference(if (!Objects, [])    Expression(mRelatedContent, [])    Expression(other.mRelatedContent), [])  Statement(return false, [])  AssignmentExpression(=, [VariableReference(if (mInfoFlags !, []), Expression(other.mInfoFlags), [])])    VariableReference(if (mInfoFlags !, [])    Expression(other.mInfoFlags), [])  Statement(return false, [])  AssignmentExpression(=, [VariableReference(if (mSignalQuality !, []), Expression(other.mSignalQuality), [])])    VariableReference(if (mSignalQuality !, [])    Expression(other.mSignalQuality), [])  Statement(return false, [])  MethodCall(if (!Objects.equals(mMetadata, other.mMetadata)), [VariableReference(if (!Objects, []), Expression(mMetadata, []), Expression(other.mMetadata), [])])    VariableReference(if (!Objects, [])    Expression(mMetadata, [])    Expression(other.mMetadata), [])  Statement(return false, [])  MethodCall(if (!Objects.equals(mVendorInfo, other.mVendorInfo)), [VariableReference(if (!Objects, []), Expression(mVendorInfo, []), Expression(other.mVendorInfo), [])])    VariableReference(if (!Objects, [])    Expression(mVendorInfo, [])    Expression(other.mVendorInfo), [])  Statement(return false, [])  Statement(return true, [])  Statement(}, [])",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,"1,3,4",1,4,0,"The early version uses specific methods for comparison (e.g., `mSelector.equals(other.getSelector())`), while the late version utilizes `Objects.equals()` for comparison. Although the comparison methods differ, they perform the same logical operation. Hence, the code change type is 4.","There are no significant changes in the behavior regarding the returned values or thrown exceptions. Therefore, no compatibility issue exists, and the CI type is 0."
264,<android.app.ContextImpl: int checkSelfPermission(String)>,30,31,<android.app.ContextImpl: int checkSelfPermission(String)>,<android.app.ContextImpl: int checkSelfPermission(String)>,0,"MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(if (permission, []), Expression(, [])]), Statement(throw new IllegalArgumentException(""permission is null""), []), Statement(}, []), MethodCall(return checkPermission(permission, Process.myPid(), Process.myUid()), [VariableReference(return checkPermission(permission, Process, []), Expression(), []), Expression(Process.myUid(), [])]), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(if (permission, []), Expression(, [])])    VariableReference(if (permission, [])    Expression(, [])  Statement(throw new IllegalArgumentException(""permission is null""), [])  Statement(}, [])  MethodCall(return checkPermission(permission, Process.myPid(), Process.myUid()), [VariableReference(return checkPermission(permission, Process, []), Expression(), []), Expression(Process.myUid(), [])])    VariableReference(return checkPermission(permission, Process, [])    Expression(), [])    Expression(Process.myUid(), [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(if (permission, []), Expression(, [])]), Statement(throw new IllegalArgumentException(""permission is null""), []), Statement(}, []), MethodCall(if (mParams.isRenouncedPermission(permission)), [VariableReference(if (mParams, []), Expression(permission), [])]), MethodCall(Log.v(TAG, ""Treating renounced permission "" + permission + "" as denied""), [VariableReference(Log, []), Expression(TAG, []), Expression(""Treating renounced permission "" + permission + "" as denied"", [])]), Statement(return PERMISSION_DENIED, []), Statement(}, []), MethodCall(return checkPermission(permission, Process.myPid(), Process.myUid()), [VariableReference(return checkPermission(permission, Process, []), Expression(), []), Expression(Process.myUid(), [])]), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(if (permission, []), Expression(, [])])    VariableReference(if (permission, [])    Expression(, [])  Statement(throw new IllegalArgumentException(""permission is null""), [])  Statement(}, [])  MethodCall(if (mParams.isRenouncedPermission(permission)), [VariableReference(if (mParams, []), Expression(permission), [])])    VariableReference(if (mParams, [])    Expression(permission), [])  MethodCall(Log.v(TAG, ""Treating renounced permission "" + permission + "" as denied""), [VariableReference(Log, []), Expression(TAG, []), Expression(""Treating renounced permission "" + permission + "" as denied"", [])])    VariableReference(Log, [])    Expression(TAG, [])    Expression(""Treating renounced permission "" + permission + "" as denied"", [])  Statement(return PERMISSION_DENIED, [])  Statement(}, [])  MethodCall(return checkPermission(permission, Process.myPid(), Process.myUid()), [VariableReference(return checkPermission(permission, Process, []), Expression(), []), Expression(Process.myUid(), [])])    VariableReference(return checkPermission(permission, Process, [])    Expression(), [])    Expression(Process.myUid(), [])  Statement(}, [])",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,"1,3,4",1,"1,3,4",1,"In the late version, new control dependency statements and other statements have been added. Specifically:",
1068,"<android.os.Vibrator: void vibrate(long[],int,AudioAttributes)>",25,26,"<android.os.Vibrator: void vibrate(long[],int,AudioAttributes)>","<android.os.Vibrator: void vibrate(long[],int,AudioAttributes)>",0,"MethodDeclaration(method_body, [Statement({, []), MethodCall(vibrate(Process.myUid(), mPackageName, pattern, repeat, attributes), [VariableReference(vibrate(Process, []), Expression(), []), Expression(mPackageName, []), Expression(pattern, []), Expression(repeat, []), Expression(attributes, [])]), Statement(}, [])])  Statement({, [])  MethodCall(vibrate(Process.myUid(), mPackageName, pattern, repeat, attributes), [VariableReference(vibrate(Process, []), Expression(), []), Expression(mPackageName, []), Expression(pattern, []), Expression(repeat, []), Expression(attributes, [])])    VariableReference(vibrate(Process, [])    Expression(), [])    Expression(mPackageName, [])    Expression(pattern, [])    Expression(repeat, [])    Expression(attributes, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(// exceptions for compatibility purposes, []), AssignmentExpression(=, [VariableReference(if (repeat < -1 || repeat >, []), Expression(pattern.length) {, [])]), AssignmentExpression(=, [VariableReference(Log.e(TAG, ""vibrate called with repeat index out of bounds"" + "" (pattern.length, []), Expression("" + pattern.length + "", index, [])]), Statement(throw new ArrayIndexOutOfBoundsException(), []), Statement(}, []), Statement(try {, []), MethodCall(vibrate(VibrationEffect.createWaveform(pattern, repeat), attributes), [VariableReference(vibrate(VibrationEffect, []), Expression(pattern, []), Expression(repeat), []), Expression(attributes, [])]), Statement(} catch (IllegalArgumentException iae) {, []), MethodCall(Log.e(TAG, ""Failed to create VibrationEffect"", iae), [VariableReference(Log, []), Expression(TAG, []), Expression(""Failed to create VibrationEffect"", []), Expression(iae, [])]), Statement(}, []), Statement(}, [])])  Statement({, [])  Statement(// exceptions for compatibility purposes, [])  AssignmentExpression(=, [VariableReference(if (repeat < -1 || repeat >, []), Expression(pattern.length) {, [])])    VariableReference(if (repeat < -1 || repeat >, [])    Expression(pattern.length) {, [])  AssignmentExpression(=, [VariableReference(Log.e(TAG, ""vibrate called with repeat index out of bounds"" + "" (pattern.length, []), Expression("" + pattern.length + "", index, [])])    VariableReference(Log.e(TAG, ""vibrate called with repeat index out of bounds"" + "" (pattern.length, [])    Expression("" + pattern.length + "", index, [])  Statement(throw new ArrayIndexOutOfBoundsException(), [])  Statement(}, [])  Statement(try {, [])  MethodCall(vibrate(VibrationEffect.createWaveform(pattern, repeat), attributes), [VariableReference(vibrate(VibrationEffect, []), Expression(pattern, []), Expression(repeat), []), Expression(attributes, [])])    VariableReference(vibrate(VibrationEffect, [])    Expression(pattern, [])    Expression(repeat), [])    Expression(attributes, [])  Statement(} catch (IllegalArgumentException iae) {, [])  MethodCall(Log.e(TAG, ""Failed to create VibrationEffect"", iae), [VariableReference(Log, []), Expression(TAG, []), Expression(""Failed to create VibrationEffect"", []), Expression(iae, [])])    VariableReference(Log, [])    Expression(TAG, [])    Expression(""Failed to create VibrationEffect"", [])    Expression(iae, [])  Statement(}, [])  Statement(}, [])",1,"/**
 * Vibrate with a given pattern.
 *
 * <p>
 * Pass in an array of ints that are the durations for which to turn on or off
 * the vibrator in milliseconds.  The first value indicates the number of milliseconds
 * to wait before turning the vibrator on.  The next value indicates the number of milliseconds
 * for which to keep the vibrator on before turning it off.  Subsequent values alternate
 * between durations in milliseconds to turn the vibrator off or to turn the vibrator on.
 * </p><p>
 * To cause the pattern to repeat, pass the index into the pattern array at which
 * to start the repeat, or -1 to disable repeating.
 * </p>
 * <p>This method requires the caller to hold the permission
 * {@link android.Manifest.permission#VIBRATE}.
 *
 * @param pattern an array of longs of times for which to turn the vibrator on or off.
 * @param repeat the index into pattern at which to repeat, or -1 if
 * you don't want to repeat.
 * @param attributes {@link AudioAttributes} corresponding to the vibration. For example,
 * specify {@link AudioAttributes#USAGE_ALARM} for alarm vibrations or
 * {@link AudioAttributes#USAGE_NOTIFICATION_RINGTONE} for
 * vibrations associated with incoming calls.
 */
","/**
 * Vibrate with a given pattern.
 *
 * <p>
 * Pass in an array of ints that are the durations for which to turn on or off
 * the vibrator in milliseconds.  The first value indicates the number of milliseconds
 * to wait before turning the vibrator on.  The next value indicates the number of milliseconds
 * for which to keep the vibrator on before turning it off.  Subsequent values alternate
 * between durations in milliseconds to turn the vibrator off or to turn the vibrator on.
 * </p><p>
 * To cause the pattern to repeat, pass the index into the pattern array at which
 * to start the repeat, or -1 to disable repeating.
 * </p>
 *
 * @param pattern an array of longs of times for which to turn the vibrator on or off.
 * @param repeat the index into pattern at which to repeat, or -1 if
 * you don't want to repeat.
 * @param attributes {@link AudioAttributes} corresponding to the vibration. For example,
 * specify {@link AudioAttributes#USAGE_ALARM} for alarm vibrations or
 * {@link AudioAttributes#USAGE_NOTIFICATION_RINGTONE} for
 * vibrations associated with incoming calls.
 *
 * @deprecated Use {@link #vibrate(VibrationEffect, AudioAttributes)} instead.
 */
",-1,,"[@Deprecated, @RequiresPermission(android.Manifest.permission.VIBRATE)]",-1,-1,-1,-1,-1,"2,3,4,5",2,"2,3,4","1,2",There are multiple changes: ,"3. The method call `vibrate(Process.myUid(), mPackageName, pattern, repeat, attributes);` has been replaced by `vibrate(VibrationEffect.createWaveform(pattern, repeat), attributes);`"
216,<android.app.UiAutomation: void setRunAsMonkey(boolean)>,30,31,<android.app.UiAutomation: void setRunAsMonkey(boolean)>,<android.app.UiAutomation: void setRunAsMonkey(boolean)>,0,"MethodDeclaration(method_body, [Statement({, []), Statement(synchronized (mLock) {, []), Statement(throwIfNotConnectedLocked(), []), Statement(}, []), Statement(try {, []), MethodCall(ActivityManager.getService().setUserIsMonkey(enable), [VariableReference(ActivityManager, []), Expression().setUserIsMonkey(enable, [])]), Statement(} catch (RemoteException re) {, []), MethodCall(Log.e(LOG_TAG, ""Error while setting run as monkey!"", re), [VariableReference(Log, []), Expression(LOG_TAG, []), Expression(""Error while setting run as monkey!"", []), Expression(re, [])]), Statement(}, []), Statement(}, [])])  Statement({, [])  Statement(synchronized (mLock) {, [])  Statement(throwIfNotConnectedLocked(), [])  Statement(}, [])  Statement(try {, [])  MethodCall(ActivityManager.getService().setUserIsMonkey(enable), [VariableReference(ActivityManager, []), Expression().setUserIsMonkey(enable, [])])    VariableReference(ActivityManager, [])    Expression().setUserIsMonkey(enable, [])  Statement(} catch (RemoteException re) {, [])  MethodCall(Log.e(LOG_TAG, ""Error while setting run as monkey!"", re), [VariableReference(Log, []), Expression(LOG_TAG, []), Expression(""Error while setting run as monkey!"", []), Expression(re, [])])    VariableReference(Log, [])    Expression(LOG_TAG, [])    Expression(""Error while setting run as monkey!"", [])    Expression(re, [])  Statement(}, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(try {, []), MethodCall(ActivityManager.getService().setUserIsMonkey(enable), [VariableReference(ActivityManager, []), Expression().setUserIsMonkey(enable, [])]), Statement(} catch (RemoteException re) {, []), MethodCall(Log.e(LOG_TAG, ""Error while setting run as monkey!"", re), [VariableReference(Log, []), Expression(LOG_TAG, []), Expression(""Error while setting run as monkey!"", []), Expression(re, [])]), Statement(}, []), Statement(}, [])])  Statement({, [])  Statement(try {, [])  MethodCall(ActivityManager.getService().setUserIsMonkey(enable), [VariableReference(ActivityManager, []), Expression().setUserIsMonkey(enable, [])])    VariableReference(ActivityManager, [])    Expression().setUserIsMonkey(enable, [])  Statement(} catch (RemoteException re) {, [])  MethodCall(Log.e(LOG_TAG, ""Error while setting run as monkey!"", re), [VariableReference(Log, []), Expression(LOG_TAG, []), Expression(""Error while setting run as monkey!"", []), Expression(re, [])])    VariableReference(Log, [])    Expression(LOG_TAG, [])    Expression(""Error while setting run as monkey!"", [])    Expression(re, [])  Statement(}, [])  Statement(}, [])",1,"/**
 * Sets whether this UiAutomation to run in a ""monkey"" mode. Applications can query whether
 * they are executed in a ""monkey"" mode, i.e. run by a test framework, and avoid doing
 * potentially undesirable actions such as calling 911 or posting on public forums etc.
 *
 * @param enable whether to run in a ""monkey"" mode or not. Default is not.
 * @see ActivityManager#isUserAMonkey()
 */
","/**
 * Sets whether this UiAutomation to run in a ""monkey"" mode. Applications can query whether
 * they are executed in a ""monkey"" mode, i.e. run by a test framework, and avoid doing
 * potentially undesirable actions such as calling 911 or posting on public forums etc.
 *
 * @param enable whether to run in a ""monkey"" mode or not. Default is not.
 * @see ActivityManager#isUserAMonkey()
 */
",-1,,,-1,-1,-1,-1,-1,4,0,3,0,"The synchronized block containing mLock and the call to throwIfNotConnectedLocked() has been removed in the late version, which results in a control dependency change.","Although there is a change in the control dependency by removing the synchronized block and throwIfNotConnectedLocked() call, it does not lead to a change in return values or exception handling. The behaviour impacting the output of the method remains the same, as it properly catches and logs RemoteException in both implementations. Therefore, no compatibility issue exists."
776,<android.os.PowerManager: boolean isPowerSaveMode()>,29,30,<android.os.PowerManager: boolean isPowerSaveMode()>,<android.os.PowerManager: boolean isPowerSaveMode()>,0,"MethodDeclaration(method_body, [Statement({, []), Statement(try {, []), MethodCall(return mService.isPowerSaveMode(), [VariableReference(return mService, []), Expression(, [])]), Statement(} catch (RemoteException e) {, []), MethodCall(throw e.rethrowFromSystemServer(), [VariableReference(throw e, []), Expression(, [])]), Statement(}, []), Statement(}, [])])  Statement({, [])  Statement(try {, [])  MethodCall(return mService.isPowerSaveMode(), [VariableReference(return mService, []), Expression(, [])])    VariableReference(return mService, [])    Expression(, [])  Statement(} catch (RemoteException e) {, [])  MethodCall(throw e.rethrowFromSystemServer(), [VariableReference(throw e, []), Expression(, [])])    VariableReference(throw e, [])    Expression(, [])  Statement(}, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), MethodCall(return mPowerSaveModeCache.query(null), [VariableReference(return mPowerSaveModeCache, []), Expression(null, [])]), Statement(}, [])])  Statement({, [])  MethodCall(return mPowerSaveModeCache.query(null), [VariableReference(return mPowerSaveModeCache, []), Expression(null, [])])    VariableReference(return mPowerSaveModeCache, [])    Expression(null, [])  Statement(}, [])",1,"/**
 * Returns true if the device is currently in power save mode.  When in this mode,
 * applications should reduce their functionality in order to conserve battery as
 * much as possible.  You can monitor for changes to this state with
 * {@link #ACTION_POWER_SAVE_MODE_CHANGED}.
 *
 * @return Returns true if currently in low power mode, else false.
 */
","/**
 * Returns true if the device is currently in power save mode.  When in this mode,
 * applications should reduce their functionality in order to conserve battery as
 * much as possible.  You can monitor for changes to this state with
 * {@link #ACTION_POWER_SAVE_MODE_CHANGED}.
 *
 * @return Returns true if currently in low power mode, else false.
 */
",-1,,,-1,-1,-1,-1,-1,"1,2,4","1,2","1,5",1,"The method implementation has changed from using `mService.isPowerSaveMode()` in a try-catch block to using `mPowerSaveModeCache.query(null)`. This indicates a change in the method call dependencies, so the code change is categorized as 1,5.","The change in the method call from `mService.isPowerSaveMode()` to `mPowerSaveModeCache.query(null)` could alter the return value, leading to different behavior in terms of determining the power save mode status. Therefore, the CI type is 1."
961,<android.webkit.WebSettings: void setUseWebViewBackgroundForOverscrollBackground(boolean)>,15,16,<android.webkit.WebSettings: void setUseWebViewBackgroundForOverscrollBackground(boolean)>,<android.webkit.WebSettings: void setUseWebViewBackgroundForOverscrollBackground(boolean)>,0,"MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(mUseWebViewBackgroundForOverscroll, []), Expression(view, [])]), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(mUseWebViewBackgroundForOverscroll, []), Expression(view, [])])    VariableReference(mUseWebViewBackgroundForOverscroll, [])    Expression(view, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(throw new MustOverrideException(), []), Statement(}, [])])  Statement({, [])  Statement(throw new MustOverrideException(), [])  Statement(}, [])",1,"/**
 * Set whether the WebView uses its background for over scroll background.
 * If true, it will use the WebView's background. If false, it will use an
 * internal pattern. Default is true.
 * @deprecated This method is now obsolete.
 */
","/**
 * Sets whether the WebView uses its background for over scroll background.
 * If true, it will use the WebView's background. If false, it will use an
 * internal pattern. Default is true.
 *
 * @deprecated This method is now obsolete.
 */
",-1,[@Deprecated],[@Deprecated],-1,-1,-1,-1,-1,2,2,2,2,"The late version introduces a new exception handling statement (throw new MustOverrideException()), so the code change type is 2.","The new exception handling statement in the late version could cause different exceptions to be thrown compared to the early version, leading to a potential different behaviour. Therefore, the CI type is 2."
535,<android.text.StaticLayout: int getLineDescent(int)>,23,24,<android.text.StaticLayout: int getLineDescent(int)>,<android.text.StaticLayout: int getLineDescent(int)>,0,"MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(int descent, []), Expression(mLines[mColumns * line + DESCENT], [])]), Statement(if (// -1 intended, []), AssignmentExpression(=, [VariableReference(mMaximumVisibleLineCount > 0 && line >, []), Expression(mMaximumVisibleLineCount - 1 && line !, [])]), AssignmentExpression(=, [VariableReference(descent +, []), Expression(getBottomPadding(), [])]), Statement(}, []), Statement(return descent, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(int descent, []), Expression(mLines[mColumns * line + DESCENT], [])])    VariableReference(int descent, [])    Expression(mLines[mColumns * line + DESCENT], [])  Statement(if (// -1 intended, [])  AssignmentExpression(=, [VariableReference(mMaximumVisibleLineCount > 0 && line >, []), Expression(mMaximumVisibleLineCount - 1 && line !, [])])    VariableReference(mMaximumVisibleLineCount > 0 && line >, [])    Expression(mMaximumVisibleLineCount - 1 && line !, [])  AssignmentExpression(=, [VariableReference(descent +, []), Expression(getBottomPadding(), [])])    VariableReference(descent +, [])    Expression(getBottomPadding(), [])  Statement(}, [])  Statement(return descent, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(return mLines[mColumns * line + DESCENT], []), Statement(}, [])])  Statement({, [])  Statement(return mLines[mColumns * line + DESCENT], [])  Statement(}, [])",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,"1,3",1,"1,3",1,"The early implementation has a more complex control flow including assignments and an `if` statement, while the late implementation simply returns a value from the array. This alters the control dependency and the return logic, so the change type is 1,3.","Since the return statement logic has changed, the method could potentially return different values between the two versions, leading to a compatibility issue. Thus, the CI type is 1."
464,<android.app.ContextImpl: void sendBroadcast(Intent)>,30,31,<android.app.ContextImpl: void sendBroadcast(Intent)>,<android.app.ContextImpl: void sendBroadcast(Intent)>,0,"MethodDeclaration(method_body, [Statement({, []), Statement(warnIfCallingFromSystemProcess(), []), AssignmentExpression(=, [VariableReference(String resolvedType, []), Expression(intent.resolveTypeIfNeeded(getContentResolver()), [])]), Statement(try {, []), MethodCall(intent.prepareToLeaveProcess(this), [VariableReference(intent, []), Expression(this, [])]), MethodCall(ActivityManager.getService().broadcastIntentWithFeature(mMainThread.getApplicationThread(), getAttributionTag(), intent, resolvedType, null, Activity.RESULT_OK, null, null, null, AppOpsManager.OP_NONE, null, false, false, getUserId()), [VariableReference(ActivityManager, []), Expression().broadcastIntentWithFeature(mMainThread.getApplicationThread(), []), Expression(getAttributionTag(), []), Expression(intent, []), Expression(resolvedType, []), Expression(null, []), Expression(Activity.RESULT_OK, []), Expression(null, []), Expression(null, []), Expression(null, []), Expression(AppOpsManager.OP_NONE, []), Expression(null, []), Expression(false, []), Expression(false, []), Expression(getUserId(), [])]), Statement(} catch (RemoteException e) {, []), MethodCall(throw e.rethrowFromSystemServer(), [VariableReference(throw e, []), Expression(, [])]), Statement(}, []), Statement(}, [])])  Statement({, [])  Statement(warnIfCallingFromSystemProcess(), [])  AssignmentExpression(=, [VariableReference(String resolvedType, []), Expression(intent.resolveTypeIfNeeded(getContentResolver()), [])])    VariableReference(String resolvedType, [])    Expression(intent.resolveTypeIfNeeded(getContentResolver()), [])  Statement(try {, [])  MethodCall(intent.prepareToLeaveProcess(this), [VariableReference(intent, []), Expression(this, [])])    VariableReference(intent, [])    Expression(this, [])  MethodCall(ActivityManager.getService().broadcastIntentWithFeature(mMainThread.getApplicationThread(), getAttributionTag(), intent, resolvedType, null, Activity.RESULT_OK, null, null, null, AppOpsManager.OP_NONE, null, false, false, getUserId()), [VariableReference(ActivityManager, []), Expression().broadcastIntentWithFeature(mMainThread.getApplicationThread(), []), Expression(getAttributionTag(), []), Expression(intent, []), Expression(resolvedType, []), Expression(null, []), Expression(Activity.RESULT_OK, []), Expression(null, []), Expression(null, []), Expression(null, []), Expression(AppOpsManager.OP_NONE, []), Expression(null, []), Expression(false, []), Expression(false, []), Expression(getUserId(), [])])    VariableReference(ActivityManager, [])    Expression().broadcastIntentWithFeature(mMainThread.getApplicationThread(), [])    Expression(getAttributionTag(), [])    Expression(intent, [])    Expression(resolvedType, [])    Expression(null, [])    Expression(Activity.RESULT_OK, [])    Expression(null, [])    Expression(null, [])    Expression(null, [])    Expression(AppOpsManager.OP_NONE, [])    Expression(null, [])    Expression(false, [])    Expression(false, [])    Expression(getUserId(), [])  Statement(} catch (RemoteException e) {, [])  MethodCall(throw e.rethrowFromSystemServer(), [VariableReference(throw e, []), Expression(, [])])    VariableReference(throw e, [])    Expression(, [])  Statement(}, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(warnIfCallingFromSystemProcess(), []), AssignmentExpression(=, [VariableReference(String resolvedType, []), Expression(intent.resolveTypeIfNeeded(getContentResolver()), [])]), Statement(try {, []), MethodCall(intent.prepareToLeaveProcess(this), [VariableReference(intent, []), Expression(this, [])]), AssignmentExpression(=, [VariableReference(ActivityManager.getService().broadcastIntentWithFeature(mMainThread.getApplicationThread(), getAttributionTag(), intent, resolvedType, null, Activity.RESULT_OK, null, null, null, null, /*excludedPermissions, []), Expression(*/, [])]), Statement(} catch (RemoteException e) {, []), MethodCall(throw e.rethrowFromSystemServer(), [VariableReference(throw e, []), Expression(, [])]), Statement(}, []), Statement(}, [])])  Statement({, [])  Statement(warnIfCallingFromSystemProcess(), [])  AssignmentExpression(=, [VariableReference(String resolvedType, []), Expression(intent.resolveTypeIfNeeded(getContentResolver()), [])])    VariableReference(String resolvedType, [])    Expression(intent.resolveTypeIfNeeded(getContentResolver()), [])  Statement(try {, [])  MethodCall(intent.prepareToLeaveProcess(this), [VariableReference(intent, []), Expression(this, [])])    VariableReference(intent, [])    Expression(this, [])  AssignmentExpression(=, [VariableReference(ActivityManager.getService().broadcastIntentWithFeature(mMainThread.getApplicationThread(), getAttributionTag(), intent, resolvedType, null, Activity.RESULT_OK, null, null, null, null, /*excludedPermissions, []), Expression(*/, [])])    VariableReference(ActivityManager.getService().broadcastIntentWithFeature(mMainThread.getApplicationThread(), getAttributionTag(), intent, resolvedType, null, Activity.RESULT_OK, null, null, null, null, /*excludedPermissions, [])    Expression(*/, [])  Statement(} catch (RemoteException e) {, [])  MethodCall(throw e.rethrowFromSystemServer(), [VariableReference(throw e, []), Expression(, [])])    VariableReference(throw e, [])    Expression(, [])  Statement(}, [])  Statement(}, [])",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,5,0,"3,5",0,"The AST for the method invocation `ActivityManager.getService().broadcastIntentWithFeature` has been updated with the commented out exclusion of `excludedPermissions`. This constitutes a change in the control dependency and a change in the implementation of the dependent API call, so the change type is 3,5.","While the control dependency and specific invocation type have changed, there is no indication these changes would potentially lead to different behaviors, such as different return values or exceptions thrown. Therefore, no compatibility issue exists, and the CI type is 0."
292,<android.widget.TimePicker: void setIs24HourView(Boolean)>,18,19,<android.widget.TimePicker: void setIs24HourView(Boolean)>,<android.widget.TimePicker: void setIs24HourView(Boolean)>,0,"MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(if (mIs24HourView, []), Expression(, [])]), Statement(return, []), Statement(}, []), AssignmentExpression(=, [VariableReference(mIs24HourView, []), Expression(is24HourView, [])]), Statement(// cache the current hour since spinner range changes, []), AssignmentExpression(=, [VariableReference(int currentHour, []), Expression(getCurrentHour(), [])]), Statement(updateHourControl(), []), Statement(// set value after spinner range is updated, []), Statement(setCurrentHour(currentHour), []), Statement(updateAmPmControl(), []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(if (mIs24HourView, []), Expression(, [])])    VariableReference(if (mIs24HourView, [])    Expression(, [])  Statement(return, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(mIs24HourView, []), Expression(is24HourView, [])])    VariableReference(mIs24HourView, [])    Expression(is24HourView, [])  Statement(// cache the current hour since spinner range changes, [])  AssignmentExpression(=, [VariableReference(int currentHour, []), Expression(getCurrentHour(), [])])    VariableReference(int currentHour, [])    Expression(getCurrentHour(), [])  Statement(updateHourControl(), [])  Statement(// set value after spinner range is updated, [])  Statement(setCurrentHour(currentHour), [])  Statement(updateAmPmControl(), [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(if (mIs24HourView, []), Expression(, [])]), Statement(return, []), Statement(}, []), Statement(// cache the current hour since spinner range changes and BEFORE changing mIs24HourView!!, []), AssignmentExpression(=, [VariableReference(int currentHour, []), Expression(getCurrentHour(), [])]), Statement(// Order is important here., []), AssignmentExpression(=, [VariableReference(mIs24HourView, []), Expression(is24HourView, [])]), Statement(getHourFormatData(), []), Statement(updateHourControl(), []), Statement(// set value after spinner range is updated - be aware that because mIs24HourView has, []), Statement(// changed then getCurrentHour() is not equal to the currentHour we cached before so, []), Statement(// explicitly ask for *not* propagating any onTimeChanged(), []), Statement(setCurrentHour(currentHour, false), []), Statement(updateMinuteControl(), []), Statement(updateAmPmControl(), []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(if (mIs24HourView, []), Expression(, [])])    VariableReference(if (mIs24HourView, [])    Expression(, [])  Statement(return, [])  Statement(}, [])  Statement(// cache the current hour since spinner range changes and BEFORE changing mIs24HourView!!, [])  AssignmentExpression(=, [VariableReference(int currentHour, []), Expression(getCurrentHour(), [])])    VariableReference(int currentHour, [])    Expression(getCurrentHour(), [])  Statement(// Order is important here., [])  AssignmentExpression(=, [VariableReference(mIs24HourView, []), Expression(is24HourView, [])])    VariableReference(mIs24HourView, [])    Expression(is24HourView, [])  Statement(getHourFormatData(), [])  Statement(updateHourControl(), [])  Statement(// set value after spinner range is updated - be aware that because mIs24HourView has, [])  Statement(// changed then getCurrentHour() is not equal to the currentHour we cached before so, [])  Statement(// explicitly ask for *not* propagating any onTimeChanged(), [])  Statement(setCurrentHour(currentHour, false), [])  Statement(updateMinuteControl(), [])  Statement(updateAmPmControl(), [])  Statement(}, [])",1,"/**
 * Set whether in 24 hour or AM/PM mode.
 *
 * @param is24HourView True = 24 hour mode. False = AM/PM.
 */
","/**
 * Set whether in 24 hour or AM/PM mode.
 *
 * @param is24HourView True = 24 hour mode. False = AM/PM.
 */
",-1,,,-1,-1,-1,-1,-1,"4,5",0,"1,3,4",1,"The sequence of assignments and method calls has changed. Specifically, Statements are added (`getHourFormatData()`, `updateMinuteControl()`), the order of some existing statements like the assignment to `mIs24HourView` has changed, and the parameter passed to `setCurrentHour` has changed from `currentHour` to `currentHour, false`. So, the code change types are 1,3,4.","The change in order and the added calls can potentially alter the behavior of the method, leading to different return values or states. This qualifies as a CI type 1."
344,"<android.provider.Settings.NameValueCache: boolean putStringForUser(ContentResolver,String,String,int)>",17,18,"<android.provider.Settings.NameValueCache: boolean putStringForUser(ContentResolver,String,String,int)>","<android.provider.Settings.NameValueCache: boolean putStringForUser(ContentResolver,String,String,int)>",0,"MethodDeclaration(method_body, [Statement({, []), Statement(try {, []), AssignmentExpression(=, [VariableReference(Bundle arg, []), Expression(new Bundle(), [])]), MethodCall(arg.putString(Settings.NameValueTable.VALUE, value), [VariableReference(arg, []), Expression(Settings.NameValueTable.VALUE, []), Expression(value, [])]), MethodCall(arg.putInt(CALL_METHOD_USER_KEY, userHandle), [VariableReference(arg, []), Expression(CALL_METHOD_USER_KEY, []), Expression(userHandle, [])]), AssignmentExpression(=, [VariableReference(IContentProvider cp, []), Expression(lazyGetProvider(cr), [])]), MethodCall(cp.call(mCallSetCommand, name, arg), [VariableReference(cp, []), Expression(mCallSetCommand, []), Expression(name, []), Expression(arg, [])]), Statement(} catch (RemoteException e) {, []), MethodCall(Log.w(TAG, ""Can't set key "" + name + "" in "" + mUri, e), [VariableReference(Log, []), Expression(TAG, []), Expression(""Can't set key "" + name + "" in "" + mUri, []), Expression(e, [])]), Statement(return false, []), Statement(}, []), Statement(return true, []), Statement(}, [])])  Statement({, [])  Statement(try {, [])  AssignmentExpression(=, [VariableReference(Bundle arg, []), Expression(new Bundle(), [])])    VariableReference(Bundle arg, [])    Expression(new Bundle(), [])  MethodCall(arg.putString(Settings.NameValueTable.VALUE, value), [VariableReference(arg, []), Expression(Settings.NameValueTable.VALUE, []), Expression(value, [])])    VariableReference(arg, [])    Expression(Settings.NameValueTable.VALUE, [])    Expression(value, [])  MethodCall(arg.putInt(CALL_METHOD_USER_KEY, userHandle), [VariableReference(arg, []), Expression(CALL_METHOD_USER_KEY, []), Expression(userHandle, [])])    VariableReference(arg, [])    Expression(CALL_METHOD_USER_KEY, [])    Expression(userHandle, [])  AssignmentExpression(=, [VariableReference(IContentProvider cp, []), Expression(lazyGetProvider(cr), [])])    VariableReference(IContentProvider cp, [])    Expression(lazyGetProvider(cr), [])  MethodCall(cp.call(mCallSetCommand, name, arg), [VariableReference(cp, []), Expression(mCallSetCommand, []), Expression(name, []), Expression(arg, [])])    VariableReference(cp, [])    Expression(mCallSetCommand, [])    Expression(name, [])    Expression(arg, [])  Statement(} catch (RemoteException e) {, [])  MethodCall(Log.w(TAG, ""Can't set key "" + name + "" in "" + mUri, e), [VariableReference(Log, []), Expression(TAG, []), Expression(""Can't set key "" + name + "" in "" + mUri, []), Expression(e, [])])    VariableReference(Log, [])    Expression(TAG, [])    Expression(""Can't set key "" + name + "" in "" + mUri, [])    Expression(e, [])  Statement(return false, [])  Statement(}, [])  Statement(return true, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(try {, []), AssignmentExpression(=, [VariableReference(Bundle arg, []), Expression(new Bundle(), [])]), MethodCall(arg.putString(Settings.NameValueTable.VALUE, value), [VariableReference(arg, []), Expression(Settings.NameValueTable.VALUE, []), Expression(value, [])]), MethodCall(arg.putInt(CALL_METHOD_USER_KEY, userHandle), [VariableReference(arg, []), Expression(CALL_METHOD_USER_KEY, []), Expression(userHandle, [])]), AssignmentExpression(=, [VariableReference(IContentProvider cp, []), Expression(lazyGetProvider(cr), [])]), MethodCall(cp.call(cr.getPackageName(), mCallSetCommand, name, arg), [VariableReference(cp, []), Expression(cr.getPackageName(), []), Expression(mCallSetCommand, []), Expression(name, []), Expression(arg, [])]), Statement(} catch (RemoteException e) {, []), MethodCall(Log.w(TAG, ""Can't set key "" + name + "" in "" + mUri, e), [VariableReference(Log, []), Expression(TAG, []), Expression(""Can't set key "" + name + "" in "" + mUri, []), Expression(e, [])]), Statement(return false, []), Statement(}, []), Statement(return true, []), Statement(}, [])])  Statement({, [])  Statement(try {, [])  AssignmentExpression(=, [VariableReference(Bundle arg, []), Expression(new Bundle(), [])])    VariableReference(Bundle arg, [])    Expression(new Bundle(), [])  MethodCall(arg.putString(Settings.NameValueTable.VALUE, value), [VariableReference(arg, []), Expression(Settings.NameValueTable.VALUE, []), Expression(value, [])])    VariableReference(arg, [])    Expression(Settings.NameValueTable.VALUE, [])    Expression(value, [])  MethodCall(arg.putInt(CALL_METHOD_USER_KEY, userHandle), [VariableReference(arg, []), Expression(CALL_METHOD_USER_KEY, []), Expression(userHandle, [])])    VariableReference(arg, [])    Expression(CALL_METHOD_USER_KEY, [])    Expression(userHandle, [])  AssignmentExpression(=, [VariableReference(IContentProvider cp, []), Expression(lazyGetProvider(cr), [])])    VariableReference(IContentProvider cp, [])    Expression(lazyGetProvider(cr), [])  MethodCall(cp.call(cr.getPackageName(), mCallSetCommand, name, arg), [VariableReference(cp, []), Expression(cr.getPackageName(), []), Expression(mCallSetCommand, []), Expression(name, []), Expression(arg, [])])    VariableReference(cp, [])    Expression(cr.getPackageName(), [])    Expression(mCallSetCommand, [])    Expression(name, [])    Expression(arg, [])  Statement(} catch (RemoteException e) {, [])  MethodCall(Log.w(TAG, ""Can't set key "" + name + "" in "" + mUri, e), [VariableReference(Log, []), Expression(TAG, []), Expression(""Can't set key "" + name + "" in "" + mUri, []), Expression(e, [])])    VariableReference(Log, [])    Expression(TAG, [])    Expression(""Can't set key "" + name + "" in "" + mUri, [])    Expression(e, [])  Statement(return false, [])  Statement(}, [])  Statement(return true, [])  Statement(}, [])",1,,,-1,,,-1,-1,-1,-1,-1,"4,5",0,4,0,"The method call `(cp.call(mCallSetCommand, name, arg))` in the early version has been changed to `(cp.call(cr.getPackageName(), mCallSetCommand, name, arg))` in the late version, which is a change not directly affecting return statements, control dependency or exception handling. It qualifies as another statement change.","The change in method call parameters does not impact the potential return values or exception handling behaviors; thus, there is no compatibility issue."
120,<android.hardware.camera2.CameraManager: CameraCharacteristics getCameraCharacteristics(String)>,29,30,<android.hardware.camera2.CameraManager: CameraCharacteristics getCameraCharacteristics(String)>,<android.hardware.camera2.CameraManager: CameraCharacteristics getCameraCharacteristics(String)>,0,"MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(CameraCharacteristics characteristics, []), Expression(null, [])]), Statement(throw new IllegalArgumentException(""No cameras available on device""), []), Statement(}, []), Statement(synchronized (mLock) {, []), Statement(/*, []), Statement(* Get the camera characteristics from the camera service directly if it supports it,, []), Statement(* otherwise get them from the legacy shim instead., []), Statement(*/, []), AssignmentExpression(=, [VariableReference(ICameraService cameraService, []), Expression(CameraManagerGlobal.get().getCameraService(), [])]), AssignmentExpression(=, [VariableReference(if (cameraService, []), Expression(, [])]), Statement(}, []), Statement(try {, []), AssignmentExpression(=, [VariableReference(Size displaySize, []), Expression(getDisplaySize(), [])]), Statement(// exception in case cameraId is a hidden physical camera., []), Statement(if (!isHiddenPhysicalCamera(cameraId) && !supportsCamera2ApiLocked(cameraId)) {, []), Statement(// Legacy backwards compatibility path, []), Statement(build static info from the camera, []), Statement(// parameters, []), AssignmentExpression(=, [VariableReference(int id, []), Expression(Integer.parseInt(cameraId), [])]), AssignmentExpression(=, [VariableReference(String parameters, []), Expression(cameraService.getLegacyParameters(id), [])]), AssignmentExpression(=, [VariableReference(CameraInfo info, []), Expression(cameraService.getCameraInfo(id), [])]), AssignmentExpression(=, [VariableReference(characteristics, []), Expression(LegacyMetadataMapper.createCharacteristics(parameters, info, id, displaySize), [])]), Statement(} else {, []), Statement(// Normal path: Get the camera characteristics directly from the camera service, []), AssignmentExpression(=, [VariableReference(CameraMetadataNative info, []), Expression(cameraService.getCameraCharacteristics(cameraId), [])]), Statement(try {, []), MethodCall(info.setCameraId(Integer.parseInt(cameraId)), [VariableReference(info, []), Expression(Integer.parseInt(cameraId), [])]), Statement(} catch (NumberFormatException e) {, []), MethodCall(Log.e(TAG, ""Failed to parse camera Id "" + cameraId + "" to integer""), [VariableReference(Log, []), Expression(TAG, []), Expression(""Failed to parse camera Id "" + cameraId + "" to integer"", [])]), Statement(}, []), MethodCall(info.setDisplaySize(displaySize), [VariableReference(info, []), Expression(displaySize, [])]), AssignmentExpression(=, [VariableReference(characteristics, []), Expression(new CameraCharacteristics(info), [])]), Statement(}, []), Statement(} catch (ServiceSpecificException e) {, []), Statement(throwAsPublicException(e), []), Statement(} catch (RemoteException e) {, []), Statement(// Camera service died - act as if the camera was disconnected, []), Statement(}, []), Statement(}, []), Statement(return characteristics, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(CameraCharacteristics characteristics, []), Expression(null, [])])    VariableReference(CameraCharacteristics characteristics, [])    Expression(null, [])  Statement(throw new IllegalArgumentException(""No cameras available on device""), [])  Statement(}, [])  Statement(synchronized (mLock) {, [])  Statement(/*, [])  Statement(* Get the camera characteristics from the camera service directly if it supports it,, [])  Statement(* otherwise get them from the legacy shim instead., [])  Statement(*/, [])  AssignmentExpression(=, [VariableReference(ICameraService cameraService, []), Expression(CameraManagerGlobal.get().getCameraService(), [])])    VariableReference(ICameraService cameraService, [])    Expression(CameraManagerGlobal.get().getCameraService(), [])  AssignmentExpression(=, [VariableReference(if (cameraService, []), Expression(, [])])    VariableReference(if (cameraService, [])    Expression(, [])  Statement(}, [])  Statement(try {, [])  AssignmentExpression(=, [VariableReference(Size displaySize, []), Expression(getDisplaySize(), [])])    VariableReference(Size displaySize, [])    Expression(getDisplaySize(), [])  Statement(// exception in case cameraId is a hidden physical camera., [])  Statement(if (!isHiddenPhysicalCamera(cameraId) && !supportsCamera2ApiLocked(cameraId)) {, [])  Statement(// Legacy backwards compatibility path, [])  Statement(build static info from the camera, [])  Statement(// parameters, [])  AssignmentExpression(=, [VariableReference(int id, []), Expression(Integer.parseInt(cameraId), [])])    VariableReference(int id, [])    Expression(Integer.parseInt(cameraId), [])  AssignmentExpression(=, [VariableReference(String parameters, []), Expression(cameraService.getLegacyParameters(id), [])])    VariableReference(String parameters, [])    Expression(cameraService.getLegacyParameters(id), [])  AssignmentExpression(=, [VariableReference(CameraInfo info, []), Expression(cameraService.getCameraInfo(id), [])])    VariableReference(CameraInfo info, [])    Expression(cameraService.getCameraInfo(id), [])  AssignmentExpression(=, [VariableReference(characteristics, []), Expression(LegacyMetadataMapper.createCharacteristics(parameters, info, id, displaySize), [])])    VariableReference(characteristics, [])    Expression(LegacyMetadataMapper.createCharacteristics(parameters, info, id, displaySize), [])  Statement(} else {, [])  Statement(// Normal path: Get the camera characteristics directly from the camera service, [])  AssignmentExpression(=, [VariableReference(CameraMetadataNative info, []), Expression(cameraService.getCameraCharacteristics(cameraId), [])])    VariableReference(CameraMetadataNative info, [])    Expression(cameraService.getCameraCharacteristics(cameraId), [])  Statement(try {, [])  MethodCall(info.setCameraId(Integer.parseInt(cameraId)), [VariableReference(info, []), Expression(Integer.parseInt(cameraId), [])])    VariableReference(info, [])    Expression(Integer.parseInt(cameraId), [])  Statement(} catch (NumberFormatException e) {, [])  MethodCall(Log.e(TAG, ""Failed to parse camera Id "" + cameraId + "" to integer""), [VariableReference(Log, []), Expression(TAG, []), Expression(""Failed to parse camera Id "" + cameraId + "" to integer"", [])])    VariableReference(Log, [])    Expression(TAG, [])    Expression(""Failed to parse camera Id "" + cameraId + "" to integer"", [])  Statement(}, [])  MethodCall(info.setDisplaySize(displaySize), [VariableReference(info, []), Expression(displaySize, [])])    VariableReference(info, [])    Expression(displaySize, [])  AssignmentExpression(=, [VariableReference(characteristics, []), Expression(new CameraCharacteristics(info), [])])    VariableReference(characteristics, [])    Expression(new CameraCharacteristics(info), [])  Statement(}, [])  Statement(} catch (ServiceSpecificException e) {, [])  Statement(throwAsPublicException(e), [])  Statement(} catch (RemoteException e) {, [])  Statement(// Camera service died - act as if the camera was disconnected, [])  Statement(}, [])  Statement(}, [])  Statement(return characteristics, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(CameraCharacteristics characteristics, []), Expression(null, [])]), Statement(throw new IllegalArgumentException(""No cameras available on device""), []), Statement(}, []), Statement(synchronized (mLock) {, []), Statement(/*, []), Statement(* Get the camera characteristics from the camera service directly if it supports it,, []), Statement(* otherwise get them from the legacy shim instead., []), Statement(*/, []), AssignmentExpression(=, [VariableReference(ICameraService cameraService, []), Expression(CameraManagerGlobal.get().getCameraService(), [])]), AssignmentExpression(=, [VariableReference(if (cameraService, []), Expression(, [])]), Statement(}, []), Statement(try {, []), AssignmentExpression(=, [VariableReference(Size displaySize, []), Expression(getDisplaySize(), [])]), Statement(// exception in case cameraId is a hidden physical camera., []), Statement(if (!isHiddenPhysicalCamera(cameraId) && !supportsCamera2ApiLocked(cameraId)) {, []), Statement(// Legacy backwards compatibility path, []), Statement(build static info from the camera, []), Statement(// parameters, []), AssignmentExpression(=, [VariableReference(int id, []), Expression(Integer.parseInt(cameraId), [])]), AssignmentExpression(=, [VariableReference(String parameters, []), Expression(cameraService.getLegacyParameters(id), [])]), AssignmentExpression(=, [VariableReference(CameraInfo info, []), Expression(cameraService.getCameraInfo(id), [])]), AssignmentExpression(=, [VariableReference(characteristics, []), Expression(LegacyMetadataMapper.createCharacteristics(parameters, info, id, displaySize), [])]), Statement(} else {, []), Statement(// Normal path: Get the camera characteristics directly from the camera service, []), AssignmentExpression(=, [VariableReference(CameraMetadataNative info, []), Expression(cameraService.getCameraCharacteristics(cameraId), [])]), Statement(try {, []), MethodCall(info.setCameraId(Integer.parseInt(cameraId)), [VariableReference(info, []), Expression(Integer.parseInt(cameraId), [])]), Statement(} catch (NumberFormatException e) {, []), Statement(// For external camera, reaching here is expected., []), MethodCall(Log.v(TAG, ""Failed to parse camera Id "" + cameraId + "" to integer""), [VariableReference(Log, []), Expression(TAG, []), Expression(""Failed to parse camera Id "" + cameraId + "" to integer"", [])]), Statement(}, []), AssignmentExpression(=, [VariableReference(boolean hasConcurrentStreams, []), Expression(CameraManagerGlobal.get().cameraIdHasConcurrentStreamsLocked(cameraId), [])]), MethodCall(info.setHasMandatoryConcurrentStreams(hasConcurrentStreams), [VariableReference(info, []), Expression(hasConcurrentStreams, [])]), MethodCall(info.setDisplaySize(displaySize), [VariableReference(info, []), Expression(displaySize, [])]), AssignmentExpression(=, [VariableReference(characteristics, []), Expression(new CameraCharacteristics(info), [])]), Statement(}, []), Statement(} catch (ServiceSpecificException e) {, []), Statement(throwAsPublicException(e), []), Statement(} catch (RemoteException e) {, []), Statement(// Camera service died - act as if the camera was disconnected, []), Statement(}, []), Statement(}, []), Statement(return characteristics, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(CameraCharacteristics characteristics, []), Expression(null, [])])    VariableReference(CameraCharacteristics characteristics, [])    Expression(null, [])  Statement(throw new IllegalArgumentException(""No cameras available on device""), [])  Statement(}, [])  Statement(synchronized (mLock) {, [])  Statement(/*, [])  Statement(* Get the camera characteristics from the camera service directly if it supports it,, [])  Statement(* otherwise get them from the legacy shim instead., [])  Statement(*/, [])  AssignmentExpression(=, [VariableReference(ICameraService cameraService, []), Expression(CameraManagerGlobal.get().getCameraService(), [])])    VariableReference(ICameraService cameraService, [])    Expression(CameraManagerGlobal.get().getCameraService(), [])  AssignmentExpression(=, [VariableReference(if (cameraService, []), Expression(, [])])    VariableReference(if (cameraService, [])    Expression(, [])  Statement(}, [])  Statement(try {, [])  AssignmentExpression(=, [VariableReference(Size displaySize, []), Expression(getDisplaySize(), [])])    VariableReference(Size displaySize, [])    Expression(getDisplaySize(), [])  Statement(// exception in case cameraId is a hidden physical camera., [])  Statement(if (!isHiddenPhysicalCamera(cameraId) && !supportsCamera2ApiLocked(cameraId)) {, [])  Statement(// Legacy backwards compatibility path, [])  Statement(build static info from the camera, [])  Statement(// parameters, [])  AssignmentExpression(=, [VariableReference(int id, []), Expression(Integer.parseInt(cameraId), [])])    VariableReference(int id, [])    Expression(Integer.parseInt(cameraId), [])  AssignmentExpression(=, [VariableReference(String parameters, []), Expression(cameraService.getLegacyParameters(id), [])])    VariableReference(String parameters, [])    Expression(cameraService.getLegacyParameters(id), [])  AssignmentExpression(=, [VariableReference(CameraInfo info, []), Expression(cameraService.getCameraInfo(id), [])])    VariableReference(CameraInfo info, [])    Expression(cameraService.getCameraInfo(id), [])  AssignmentExpression(=, [VariableReference(characteristics, []), Expression(LegacyMetadataMapper.createCharacteristics(parameters, info, id, displaySize), [])])    VariableReference(characteristics, [])    Expression(LegacyMetadataMapper.createCharacteristics(parameters, info, id, displaySize), [])  Statement(} else {, [])  Statement(// Normal path: Get the camera characteristics directly from the camera service, [])  AssignmentExpression(=, [VariableReference(CameraMetadataNative info, []), Expression(cameraService.getCameraCharacteristics(cameraId), [])])    VariableReference(CameraMetadataNative info, [])    Expression(cameraService.getCameraCharacteristics(cameraId), [])  Statement(try {, [])  MethodCall(info.setCameraId(Integer.parseInt(cameraId)), [VariableReference(info, []), Expression(Integer.parseInt(cameraId), [])])    VariableReference(info, [])    Expression(Integer.parseInt(cameraId), [])  Statement(} catch (NumberFormatException e) {, [])  Statement(// For external camera, reaching here is expected., [])  MethodCall(Log.v(TAG, ""Failed to parse camera Id "" + cameraId + "" to integer""), [VariableReference(Log, []), Expression(TAG, []), Expression(""Failed to parse camera Id "" + cameraId + "" to integer"", [])])    VariableReference(Log, [])    Expression(TAG, [])    Expression(""Failed to parse camera Id "" + cameraId + "" to integer"", [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(boolean hasConcurrentStreams, []), Expression(CameraManagerGlobal.get().cameraIdHasConcurrentStreamsLocked(cameraId), [])])    VariableReference(boolean hasConcurrentStreams, [])    Expression(CameraManagerGlobal.get().cameraIdHasConcurrentStreamsLocked(cameraId), [])  MethodCall(info.setHasMandatoryConcurrentStreams(hasConcurrentStreams), [VariableReference(info, []), Expression(hasConcurrentStreams, [])])    VariableReference(info, [])    Expression(hasConcurrentStreams, [])  MethodCall(info.setDisplaySize(displaySize), [VariableReference(info, []), Expression(displaySize, [])])    VariableReference(info, [])    Expression(displaySize, [])  AssignmentExpression(=, [VariableReference(characteristics, []), Expression(new CameraCharacteristics(info), [])])    VariableReference(characteristics, [])    Expression(new CameraCharacteristics(info), [])  Statement(}, [])  Statement(} catch (ServiceSpecificException e) {, [])  Statement(throwAsPublicException(e), [])  Statement(} catch (RemoteException e) {, [])  Statement(// Camera service died - act as if the camera was disconnected, [])  Statement(}, [])  Statement(}, [])  Statement(return characteristics, [])  Statement(}, [])",1,"/**
 * <p>Query the capabilities of a camera device. These capabilities are
 * immutable for a given camera.</p>
 *
 * <p>From API level 29, this function can also be used to query the capabilities of physical
 * cameras that can only be used as part of logical multi-camera. These cameras cannot be
 * opened directly via {@link #openCamera}</p>
 *
 * @param cameraId The id of the camera device to query. This could be either a standalone
 * camera ID which can be directly opened by {@link #openCamera}, or a physical camera ID that
 * can only used as part of a logical multi-camera.
 * @return The properties of the given camera
 *
 * @throws IllegalArgumentException if the cameraId does not match any
 * known camera device.
 * @throws CameraAccessException if the camera device has been disconnected.
 *
 * @see #getCameraIdList
 * @see android.app.admin.DevicePolicyManager#setCameraDisabled
 */
","/**
 * <p>Query the capabilities of a camera device. These capabilities are
 * immutable for a given camera.</p>
 *
 * <p>From API level 29, this function can also be used to query the capabilities of physical
 * cameras that can only be used as part of logical multi-camera. These cameras cannot be
 * opened directly via {@link #openCamera}</p>
 *
 * <p>Also starting with API level 29, while most basic camera information is still available
 * even without the CAMERA permission, some values are not available to apps that do not hold
 * that permission. The keys not available are listed by
 * {@link CameraCharacteristics#getKeysNeedingPermission}.</p>
 *
 * @param cameraId The id of the camera device to query. This could be either a standalone
 * camera ID which can be directly opened by {@link #openCamera}, or a physical camera ID that
 * can only used as part of a logical multi-camera.
 * @return The properties of the given camera
 *
 * @throws IllegalArgumentException if the cameraId does not match any
 * known camera device.
 * @throws CameraAccessException if the camera device has been disconnected.
 *
 * @see #getCameraIdList
 * @see android.app.admin.DevicePolicyManager#setCameraDisabled
 */
",-1,[@NonNull],[@NonNull],-1,-1,-1,-1,-1,4,0,"2,3,4",2,The following changes can be observed:,
851,<android.accounts.AccountManager: AuthenticatorDescription[] getAuthenticatorTypes()>,29,30,<android.accounts.AccountManager: AuthenticatorDescription[] getAuthenticatorTypes()>,<android.accounts.AccountManager: AuthenticatorDescription[] getAuthenticatorTypes()>,0,"MethodDeclaration(method_body, [Statement({, []), Statement(try {, []), MethodCall(return mService.getAuthenticatorTypes(UserHandle.getCallingUserId()), [VariableReference(return mService, []), Expression(UserHandle.getCallingUserId(), [])]), Statement(} catch (RemoteException e) {, []), MethodCall(throw e.rethrowFromSystemServer(), [VariableReference(throw e, []), Expression(, [])]), Statement(}, []), Statement(}, [])])  Statement({, [])  Statement(try {, [])  MethodCall(return mService.getAuthenticatorTypes(UserHandle.getCallingUserId()), [VariableReference(return mService, []), Expression(UserHandle.getCallingUserId(), [])])    VariableReference(return mService, [])    Expression(UserHandle.getCallingUserId(), [])  Statement(} catch (RemoteException e) {, [])  MethodCall(throw e.rethrowFromSystemServer(), [VariableReference(throw e, []), Expression(, [])])    VariableReference(throw e, [])    Expression(, [])  Statement(}, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), MethodCall(return getAuthenticatorTypesAsUser(mContext.getUserId()), [VariableReference(return getAuthenticatorTypesAsUser(mContext, []), Expression(), [])]), Statement(}, [])])  Statement({, [])  MethodCall(return getAuthenticatorTypesAsUser(mContext.getUserId()), [VariableReference(return getAuthenticatorTypesAsUser(mContext, []), Expression(), [])])    VariableReference(return getAuthenticatorTypesAsUser(mContext, [])    Expression(), [])  Statement(}, [])",1,"/**
 * Lists the currently registered authenticators.
 *
 * <p>It is safe to call this method from the main thread.
 *
 * <p>No permission is required to call this method.
 *
 * @return An array of {@link AuthenticatorDescription} for every
 * authenticator known to the AccountManager service.  Empty (never
 * null) if no authenticators are known.
 */
","/**
 * Lists the currently registered authenticators.
 *
 * <p>It is safe to call this method from the main thread.
 *
 * <p>No permission is required to call this method.
 *
 * @return An array of {@link AuthenticatorDescription} for every
 * authenticator known to the AccountManager service.  Empty (never
 * null) if no authenticators are known.
 */
",-1,,[@UserHandleAware],-1,-1,-1,-1,-1,"1,2,4,5","1,2","1,3,5",1,"The return statement has changed from `return mService.getAuthenticatorTypes(UserHandle.getCallingUserId())` to `return getAuthenticatorTypesAsUser(mContext.getUserId())`. This indicates that in addition to the internal control logic, the dependent API being called has also changed, so the code change type is 1,3,5.","The change in the return statement, including the invocation of a different dependent API, could lead to the API returning different values. Therefore, the CI type is 1."
541,<android.widget.TextView: int getImeActionId()>,15,16,<android.widget.TextView: int getImeActionId()>,<android.widget.TextView: int getImeActionId()>,0,"MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(return mInputContentType !, []), Expression(null ? mInputContentType.imeActionId : 0, [])]), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(return mInputContentType !, []), Expression(null ? mInputContentType.imeActionId : 0, [])])    VariableReference(return mInputContentType !, [])    Expression(null ? mInputContentType.imeActionId : 0, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(return mEditor !, []), Expression(null && mEditor.mInputContentType !, [])]), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(return mEditor !, []), Expression(null && mEditor.mInputContentType !, [])])    VariableReference(return mEditor !, [])    Expression(null && mEditor.mInputContentType !, [])  Statement(}, [])",1,"/**
 * Get the IME action ID previous set with {@link #setImeActionLabel}.
 *
 * @see #setImeActionLabel
 * @see android.view.inputmethod.EditorInfo
 */
","/**
 * Get the IME action ID previous set with {@link #setImeActionLabel}.
 *
 * @see #setImeActionLabel
 * @see android.view.inputmethod.EditorInfo
 */
",-1,,,-1,-1,-1,-1,-1,"1,3",1,"1,3",1,"The code changes from `return mInputContentType != null ? mInputContentType.imeActionId : 0` to `return (mEditor != null && mEditor.mInputContentType != null) ? mEditor.mInputContentType.imeActionId : 0`. This change involves the condition check and the returned value, so the changes type is 1,3.","Due to the changed condition and return statement, the method may return a different value if `mEditor` or `mEditor.mInputContentType` is `null`. This leads to the potential for different return values in the new version, hence the CI type is 1."
137,<android.permission.PermissionManager.SplitPermissionInfo: int getTargetSdk()>,29,30,<android.permission.PermissionManager.SplitPermissionInfo: int getTargetSdk()>,<android.permission.PermissionManager.SplitPermissionInfo: int getTargetSdk()>,0,"MethodDeclaration(method_body, [Statement({, []), Statement(return mTargetSdk, []), Statement(}, [])])  Statement({, [])  Statement(return mTargetSdk, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), MethodCall(return mSplitPermissionInfoParcelable.getTargetSdk(), [VariableReference(return mSplitPermissionInfoParcelable, []), Expression(, [])]), Statement(}, [])])  Statement({, [])  MethodCall(return mSplitPermissionInfoParcelable.getTargetSdk(), [VariableReference(return mSplitPermissionInfoParcelable, []), Expression(, [])])    VariableReference(return mSplitPermissionInfoParcelable, [])    Expression(, [])  Statement(}, [])",1,"/**
 * Get the target API level when the permission was split.
 */
","/**
 * Get the target API level when the permission was split.
 */
",-1,,,-1,-1,-1,-1,-1,"1,4",1,"1,5",1,"The return statement has changed from returning the field `mTargetSdk` to calling the method `mSplitPermissionInfoParcelable.getTargetSdk()`, indicating both a different return statement and a dependent API change. Therefore, the change types are 1 and 5.","As the API now depends on `mSplitPermissionInfoParcelable.getTargetSdk()` instead of directly using `mTargetSdk`, the method could potentially return a different value, leading to a CI type of 1."
323,<android.bluetooth.BluetoothAdapter: String getName()>,16,17,<android.bluetooth.BluetoothAdapter: String getName()>,<android.bluetooth.BluetoothAdapter: String getName()>,0,"MethodDeclaration(method_body, [Statement({, []), Statement(try {, []), MethodCall(return mService.getName(), [VariableReference(return mService, []), Expression(, [])]), Statement(} catch (RemoteException e) {, []), MethodCall(Log.e(TAG, """", e), [VariableReference(Log, []), Expression(TAG, []), Expression("""", []), Expression(e, [])]), Statement(}, []), Statement(return null, []), Statement(}, [])])  Statement({, [])  Statement(try {, [])  MethodCall(return mService.getName(), [VariableReference(return mService, []), Expression(, [])])    VariableReference(return mService, [])    Expression(, [])  Statement(} catch (RemoteException e) {, [])  MethodCall(Log.e(TAG, """", e), [VariableReference(Log, []), Expression(TAG, []), Expression("""", []), Expression(e, [])])    VariableReference(Log, [])    Expression(TAG, [])    Expression("""", [])    Expression(e, [])  Statement(}, [])  Statement(return null, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(try {, []), MethodCall(return mManagerService.getName(), [VariableReference(return mManagerService, []), Expression(, [])]), Statement(} catch (RemoteException e) {, []), MethodCall(Log.e(TAG, """", e), [VariableReference(Log, []), Expression(TAG, []), Expression("""", []), Expression(e, [])]), Statement(}, []), Statement(return null, []), Statement(}, [])])  Statement({, [])  Statement(try {, [])  MethodCall(return mManagerService.getName(), [VariableReference(return mManagerService, []), Expression(, [])])    VariableReference(return mManagerService, [])    Expression(, [])  Statement(} catch (RemoteException e) {, [])  MethodCall(Log.e(TAG, """", e), [VariableReference(Log, []), Expression(TAG, []), Expression("""", []), Expression(e, [])])    VariableReference(Log, [])    Expression(TAG, [])    Expression("""", [])    Expression(e, [])  Statement(}, [])  Statement(return null, [])  Statement(}, [])",1,"/**
 * Get the friendly Bluetooth name of the local Bluetooth adapter.
 * <p>This name is visible to remote Bluetooth devices.
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH}
 *
 * @return the Bluetooth name, or null on error
 */
","/**
 * Get the friendly Bluetooth name of the local Bluetooth adapter.
 * <p>This name is visible to remote Bluetooth devices.
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH}
 *
 * @return the Bluetooth name, or null on error
 */
",-1,,,-1,-1,-1,-1,-1,"1,5",1,"1,5",1,"The method call has changed from mService.getName() to mManagerService.getName(), indicating a change in the dependent API. Additionally, this change affects the return statement, hence the code change type is 1,5.","The change from mService to mManagerService could potentially result in different return values from the `getName()` method, thus causing a Compatibility Issue type 1."
683,<android.app.admin.DevicePolicyManager: boolean getCameraDisabled(ComponentName)>,23,24,<android.app.admin.DevicePolicyManager: boolean getCameraDisabled(ComponentName)>,<android.app.admin.DevicePolicyManager: boolean getCameraDisabled(ComponentName)>,0,"MethodDeclaration(method_body, [Statement({, []), MethodCall(return getCameraDisabled(admin, UserHandle.myUserId()), [VariableReference(return getCameraDisabled(admin, UserHandle, []), Expression(), [])]), Statement(}, [])])  Statement({, [])  MethodCall(return getCameraDisabled(admin, UserHandle.myUserId()), [VariableReference(return getCameraDisabled(admin, UserHandle, []), Expression(), [])])    VariableReference(return getCameraDisabled(admin, UserHandle, [])    Expression(), [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(throwIfParentInstance(""getCameraDisabled""), []), Statement(return getCameraDisabled(admin, myUserId()), []), Statement(}, [])])  Statement({, [])  Statement(throwIfParentInstance(""getCameraDisabled""), [])  Statement(return getCameraDisabled(admin, myUserId()), [])  Statement(}, [])",1,"/**
 * Determine whether or not the device's cameras have been disabled for this user,
 * either by the current admin, if specified, or all admins.
 * @param admin The name of the admin component to check, or {@code null} to check whether any admins
 * have disabled the camera
 */
","/**
 * Determine whether or not the device's cameras have been disabled for this user,
 * either by the calling admin, if specified, or all admins.
 * @param admin The name of the admin component to check, or {@code null} to check whether any admins
 * have disabled the camera
 */
",-1,,,-1,-1,-1,-1,-1,"2,4,5",2,"2,3",2,"A new exception handling statement (throwIfParentInstance(""getCameraDisabled"")) has been introduced, and there is a change in control dependency due to this added exception handling statement. So, the code change type is 2,3.","The introduced exception handling statement (throwIfParentInstance(""getCameraDisabled"")) could throw a different exception, which can lead to different behaviors in the late version. Thus, the CI type is 2."
1288,"<android.app.ContextImpl: void revokeUriPermission(Uri,int)>",23,24,"<android.app.ContextImpl: void revokeUriPermission(Uri,int)>","<android.app.ContextImpl: void revokeUriPermission(Uri,int)>",0,"MethodDeclaration(method_body, [Statement({, []), Statement(try {, []), MethodCall(ActivityManagerNative.getDefault().revokeUriPermission(mMainThread.getApplicationThread(), ContentProvider.getUriWithoutUserId(uri), modeFlags, resolveUserId(uri)), [VariableReference(ActivityManagerNative, []), Expression().revokeUriPermission(mMainThread.getApplicationThread(), []), Expression(ContentProvider.getUriWithoutUserId(uri), []), Expression(modeFlags, []), Expression(resolveUserId(uri), [])]), Statement(} catch (RemoteException e) {, []), Statement(}, []), Statement(}, [])])  Statement({, [])  Statement(try {, [])  MethodCall(ActivityManagerNative.getDefault().revokeUriPermission(mMainThread.getApplicationThread(), ContentProvider.getUriWithoutUserId(uri), modeFlags, resolveUserId(uri)), [VariableReference(ActivityManagerNative, []), Expression().revokeUriPermission(mMainThread.getApplicationThread(), []), Expression(ContentProvider.getUriWithoutUserId(uri), []), Expression(modeFlags, []), Expression(resolveUserId(uri), [])])    VariableReference(ActivityManagerNative, [])    Expression().revokeUriPermission(mMainThread.getApplicationThread(), [])    Expression(ContentProvider.getUriWithoutUserId(uri), [])    Expression(modeFlags, [])    Expression(resolveUserId(uri), [])  Statement(} catch (RemoteException e) {, [])  Statement(}, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(try {, []), MethodCall(ActivityManagerNative.getDefault().revokeUriPermission(mMainThread.getApplicationThread(), ContentProvider.getUriWithoutUserId(uri), modeFlags, resolveUserId(uri)), [VariableReference(ActivityManagerNative, []), Expression().revokeUriPermission(mMainThread.getApplicationThread(), []), Expression(ContentProvider.getUriWithoutUserId(uri), []), Expression(modeFlags, []), Expression(resolveUserId(uri), [])]), Statement(} catch (RemoteException e) {, []), MethodCall(throw e.rethrowFromSystemServer(), [VariableReference(throw e, []), Expression(, [])]), Statement(}, []), Statement(}, [])])  Statement({, [])  Statement(try {, [])  MethodCall(ActivityManagerNative.getDefault().revokeUriPermission(mMainThread.getApplicationThread(), ContentProvider.getUriWithoutUserId(uri), modeFlags, resolveUserId(uri)), [VariableReference(ActivityManagerNative, []), Expression().revokeUriPermission(mMainThread.getApplicationThread(), []), Expression(ContentProvider.getUriWithoutUserId(uri), []), Expression(modeFlags, []), Expression(resolveUserId(uri), [])])    VariableReference(ActivityManagerNative, [])    Expression().revokeUriPermission(mMainThread.getApplicationThread(), [])    Expression(ContentProvider.getUriWithoutUserId(uri), [])    Expression(modeFlags, [])    Expression(resolveUserId(uri), [])  Statement(} catch (RemoteException e) {, [])  MethodCall(throw e.rethrowFromSystemServer(), [VariableReference(throw e, []), Expression(, [])])    VariableReference(throw e, [])    Expression(, [])  Statement(}, [])  Statement(}, [])",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,2,2,2,2,"In the late version, a new exception handling statement 'throw e.rethrowFromSystemServer()' is introduced within the 'catch' block handling `RemoteException`. This changes the way exceptions are managed, so the code change type is 2.","Introducing the new exception handling statement 'throw e.rethrowFromSystemServer()' will cause the API to handle exceptions differently, leading to potential different exception handling behavior. Therefore, the CI type is 2."
348,<android.webkit.LoadListener: boolean handleSslErrorRequest(SslError)>,4,5,<android.webkit.LoadListener: boolean handleSslErrorRequest(SslError)>,<android.webkit.LoadListener: boolean handleSslErrorRequest(SslError)>,0,"MethodDeclaration(method_body, [Statement({, []), MethodCall(Log.v(LOGTAG, ""LoadListener.handleSslErrorRequest(): url:"" + url() + "" primary error: "" + error.getPrimaryError() + "" certificate: "" + error.getCertificate()), [VariableReference(Log, []), Expression(LOGTAG, []), Expression(""LoadListener.handleSslErrorRequest(): url:"" + url() + "" primary error: "" + error.getPrimaryError() + "" certificate: "" + error.getCertificate(), [])]), Statement(}, []), Statement(sendMessageInternal(obtainMessage(MSG_SSL_ERROR, error)), []), Statement(// to unblock the network thread., []), Statement(if (!mCancelled) {, []), AssignmentExpression(=, [VariableReference(mSslErrorRequestHandle, []), Expression(mRequestHandle, [])]), Statement(}, []), Statement(return !mCancelled, []), Statement(}, [])])  Statement({, [])  MethodCall(Log.v(LOGTAG, ""LoadListener.handleSslErrorRequest(): url:"" + url() + "" primary error: "" + error.getPrimaryError() + "" certificate: "" + error.getCertificate()), [VariableReference(Log, []), Expression(LOGTAG, []), Expression(""LoadListener.handleSslErrorRequest(): url:"" + url() + "" primary error: "" + error.getPrimaryError() + "" certificate: "" + error.getCertificate(), [])])    VariableReference(Log, [])    Expression(LOGTAG, [])    Expression(""LoadListener.handleSslErrorRequest(): url:"" + url() + "" primary error: "" + error.getPrimaryError() + "" certificate: "" + error.getCertificate(), [])  Statement(}, [])  Statement(sendMessageInternal(obtainMessage(MSG_SSL_ERROR, error)), [])  Statement(// to unblock the network thread., [])  Statement(if (!mCancelled) {, [])  AssignmentExpression(=, [VariableReference(mSslErrorRequestHandle, []), Expression(mRequestHandle, [])])    VariableReference(mSslErrorRequestHandle, [])    Expression(mRequestHandle, [])  Statement(}, [])  Statement(return !mCancelled, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), MethodCall(Log.v(LOGTAG, ""LoadListener.handleSslErrorRequest(): url:"" + url() + "" primary error: "" + error.getPrimaryError() + "" certificate: "" + error.getCertificate()), [VariableReference(Log, []), Expression(LOGTAG, []), Expression(""LoadListener.handleSslErrorRequest(): url:"" + url() + "" primary error: "" + error.getPrimaryError() + "" certificate: "" + error.getCertificate(), [])]), Statement(}, []), Statement(// will prevent waiting for an already available answer., []), MethodCall(if (Network.getInstance(mContext).checkSslPrefTable(this, error)), [VariableReference(if (Network, []), Expression(mContext).checkSslPrefTable(this, []), Expression(error), [])]), Statement(return true, []), Statement(}, []), Statement(// deadlock. Just bail on the request., []), Statement(if (isSynchronous()) {, []), MethodCall(mRequestHandle.handleSslErrorResponse(false), [VariableReference(mRequestHandle, []), Expression(false, [])]), Statement(return true, []), Statement(}, []), Statement(sendMessageInternal(obtainMessage(MSG_SSL_ERROR, error)), []), Statement(// to unblock the network thread., []), Statement(if (!mCancelled) {, []), AssignmentExpression(=, [VariableReference(mSslErrorRequestHandle, []), Expression(mRequestHandle, [])]), Statement(}, []), Statement(return !mCancelled, []), Statement(}, [])])  Statement({, [])  MethodCall(Log.v(LOGTAG, ""LoadListener.handleSslErrorRequest(): url:"" + url() + "" primary error: "" + error.getPrimaryError() + "" certificate: "" + error.getCertificate()), [VariableReference(Log, []), Expression(LOGTAG, []), Expression(""LoadListener.handleSslErrorRequest(): url:"" + url() + "" primary error: "" + error.getPrimaryError() + "" certificate: "" + error.getCertificate(), [])])    VariableReference(Log, [])    Expression(LOGTAG, [])    Expression(""LoadListener.handleSslErrorRequest(): url:"" + url() + "" primary error: "" + error.getPrimaryError() + "" certificate: "" + error.getCertificate(), [])  Statement(}, [])  Statement(// will prevent waiting for an already available answer., [])  MethodCall(if (Network.getInstance(mContext).checkSslPrefTable(this, error)), [VariableReference(if (Network, []), Expression(mContext).checkSslPrefTable(this, []), Expression(error), [])])    VariableReference(if (Network, [])    Expression(mContext).checkSslPrefTable(this, [])    Expression(error), [])  Statement(return true, [])  Statement(}, [])  Statement(// deadlock. Just bail on the request., [])  Statement(if (isSynchronous()) {, [])  MethodCall(mRequestHandle.handleSslErrorResponse(false), [VariableReference(mRequestHandle, []), Expression(false, [])])    VariableReference(mRequestHandle, [])    Expression(false, [])  Statement(return true, [])  Statement(}, [])  Statement(sendMessageInternal(obtainMessage(MSG_SSL_ERROR, error)), [])  Statement(// to unblock the network thread., [])  Statement(if (!mCancelled) {, [])  AssignmentExpression(=, [VariableReference(mSslErrorRequestHandle, []), Expression(mRequestHandle, [])])    VariableReference(mSslErrorRequestHandle, [])    Expression(mRequestHandle, [])  Statement(}, [])  Statement(return !mCancelled, [])  Statement(}, [])",1,"/**
 * SSL certificate error callback. Handles SSL error(s) on the way up
 * to the user.
 * IMPORTANT: as this is called from network thread, can't call native
 * directly
 */
","/**
 * SSL certificate error callback. Handles SSL error(s) on the way up
 * to the user.
 * IMPORTANT: as this is called from network thread, can't call native
 * directly
 */
",-1,,,-1,-1,-1,-1,-1,"3,4",1,"1,2,3,4,5","1,2",The late implementation includes several changes:,3. Various new comments indicating the reasons for these changes have been added.
297,"<android.pim.vcard.VCardUtils: String constructNameFromElements(int,String,String,String,String,String)>",7,8,"<android.pim.vcard.VCardUtils: String constructNameFromElements(int,String,String,String,String,String)>","<android.pim.vcard.VCardUtils: String constructNameFromElements(int,String,String,String,String,String)>",0,"MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(StringBuilder builder, []), Expression(new StringBuilder(), [])]), AssignmentExpression(=, [VariableReference(String[] nameList, []), Expression(sortNameElements(nameOrderType, familyName, middleName, givenName), [])]), AssignmentExpression(=, [VariableReference(boolean first, []), Expression(true, [])]), MethodCall(if (!TextUtils.isEmpty(prefix)), [VariableReference(if (!TextUtils, []), Expression(prefix), [])]), AssignmentExpression(=, [VariableReference(first, []), Expression(false, [])]), MethodCall(builder.append(prefix), [VariableReference(builder, []), Expression(prefix, [])]), Statement(}, []), Statement(for (String namePart : nameList) {, []), MethodCall(if (!TextUtils.isEmpty(namePart)), [VariableReference(if (!TextUtils, []), Expression(namePart), [])]), Statement(if (first) {, []), AssignmentExpression(=, [VariableReference(first, []), Expression(false, [])]), Statement(} else {, []), MethodCall(builder.append(' '), [VariableReference(builder, []), Expression(' ', [])]), Statement(}, []), MethodCall(builder.append(namePart), [VariableReference(builder, []), Expression(namePart, [])]), Statement(}, []), Statement(}, []), MethodCall(if (!TextUtils.isEmpty(suffix)), [VariableReference(if (!TextUtils, []), Expression(suffix), [])]), Statement(if (!first) {, []), MethodCall(builder.append(' '), [VariableReference(builder, []), Expression(' ', [])]), Statement(}, []), MethodCall(builder.append(suffix), [VariableReference(builder, []), Expression(suffix, [])]), Statement(}, []), MethodCall(return builder.toString(), [VariableReference(return builder, []), Expression(, [])]), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(StringBuilder builder, []), Expression(new StringBuilder(), [])])    VariableReference(StringBuilder builder, [])    Expression(new StringBuilder(), [])  AssignmentExpression(=, [VariableReference(String[] nameList, []), Expression(sortNameElements(nameOrderType, familyName, middleName, givenName), [])])    VariableReference(String[] nameList, [])    Expression(sortNameElements(nameOrderType, familyName, middleName, givenName), [])  AssignmentExpression(=, [VariableReference(boolean first, []), Expression(true, [])])    VariableReference(boolean first, [])    Expression(true, [])  MethodCall(if (!TextUtils.isEmpty(prefix)), [VariableReference(if (!TextUtils, []), Expression(prefix), [])])    VariableReference(if (!TextUtils, [])    Expression(prefix), [])  AssignmentExpression(=, [VariableReference(first, []), Expression(false, [])])    VariableReference(first, [])    Expression(false, [])  MethodCall(builder.append(prefix), [VariableReference(builder, []), Expression(prefix, [])])    VariableReference(builder, [])    Expression(prefix, [])  Statement(}, [])  Statement(for (String namePart : nameList) {, [])  MethodCall(if (!TextUtils.isEmpty(namePart)), [VariableReference(if (!TextUtils, []), Expression(namePart), [])])    VariableReference(if (!TextUtils, [])    Expression(namePart), [])  Statement(if (first) {, [])  AssignmentExpression(=, [VariableReference(first, []), Expression(false, [])])    VariableReference(first, [])    Expression(false, [])  Statement(} else {, [])  MethodCall(builder.append(' '), [VariableReference(builder, []), Expression(' ', [])])    VariableReference(builder, [])    Expression(' ', [])  Statement(}, [])  MethodCall(builder.append(namePart), [VariableReference(builder, []), Expression(namePart, [])])    VariableReference(builder, [])    Expression(namePart, [])  Statement(}, [])  Statement(}, [])  MethodCall(if (!TextUtils.isEmpty(suffix)), [VariableReference(if (!TextUtils, []), Expression(suffix), [])])    VariableReference(if (!TextUtils, [])    Expression(suffix), [])  Statement(if (!first) {, [])  MethodCall(builder.append(' '), [VariableReference(builder, []), Expression(' ', [])])    VariableReference(builder, [])    Expression(' ', [])  Statement(}, [])  MethodCall(builder.append(suffix), [VariableReference(builder, []), Expression(suffix, [])])    VariableReference(builder, [])    Expression(suffix, [])  Statement(}, [])  MethodCall(return builder.toString(), [VariableReference(return builder, []), Expression(, [])])    VariableReference(return builder, [])    Expression(, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(final StringBuilder builder, []), Expression(new StringBuilder(), [])]), AssignmentExpression(=, [VariableReference(final String[] nameList, []), Expression(sortNameElements(vcardType, familyName, middleName, givenName), [])]), AssignmentExpression(=, [VariableReference(boolean first, []), Expression(true, [])]), MethodCall(if (!TextUtils.isEmpty(prefix)), [VariableReference(if (!TextUtils, []), Expression(prefix), [])]), AssignmentExpression(=, [VariableReference(first, []), Expression(false, [])]), MethodCall(builder.append(prefix), [VariableReference(builder, []), Expression(prefix, [])]), Statement(}, []), Statement(for (final String namePart : nameList) {, []), MethodCall(if (!TextUtils.isEmpty(namePart)), [VariableReference(if (!TextUtils, []), Expression(namePart), [])]), Statement(if (first) {, []), AssignmentExpression(=, [VariableReference(first, []), Expression(false, [])]), Statement(} else {, []), MethodCall(builder.append(' '), [VariableReference(builder, []), Expression(' ', [])]), Statement(}, []), MethodCall(builder.append(namePart), [VariableReference(builder, []), Expression(namePart, [])]), Statement(}, []), Statement(}, []), MethodCall(if (!TextUtils.isEmpty(suffix)), [VariableReference(if (!TextUtils, []), Expression(suffix), [])]), Statement(if (!first) {, []), MethodCall(builder.append(' '), [VariableReference(builder, []), Expression(' ', [])]), Statement(}, []), MethodCall(builder.append(suffix), [VariableReference(builder, []), Expression(suffix, [])]), Statement(}, []), MethodCall(return builder.toString(), [VariableReference(return builder, []), Expression(, [])]), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(final StringBuilder builder, []), Expression(new StringBuilder(), [])])    VariableReference(final StringBuilder builder, [])    Expression(new StringBuilder(), [])  AssignmentExpression(=, [VariableReference(final String[] nameList, []), Expression(sortNameElements(vcardType, familyName, middleName, givenName), [])])    VariableReference(final String[] nameList, [])    Expression(sortNameElements(vcardType, familyName, middleName, givenName), [])  AssignmentExpression(=, [VariableReference(boolean first, []), Expression(true, [])])    VariableReference(boolean first, [])    Expression(true, [])  MethodCall(if (!TextUtils.isEmpty(prefix)), [VariableReference(if (!TextUtils, []), Expression(prefix), [])])    VariableReference(if (!TextUtils, [])    Expression(prefix), [])  AssignmentExpression(=, [VariableReference(first, []), Expression(false, [])])    VariableReference(first, [])    Expression(false, [])  MethodCall(builder.append(prefix), [VariableReference(builder, []), Expression(prefix, [])])    VariableReference(builder, [])    Expression(prefix, [])  Statement(}, [])  Statement(for (final String namePart : nameList) {, [])  MethodCall(if (!TextUtils.isEmpty(namePart)), [VariableReference(if (!TextUtils, []), Expression(namePart), [])])    VariableReference(if (!TextUtils, [])    Expression(namePart), [])  Statement(if (first) {, [])  AssignmentExpression(=, [VariableReference(first, []), Expression(false, [])])    VariableReference(first, [])    Expression(false, [])  Statement(} else {, [])  MethodCall(builder.append(' '), [VariableReference(builder, []), Expression(' ', [])])    VariableReference(builder, [])    Expression(' ', [])  Statement(}, [])  MethodCall(builder.append(namePart), [VariableReference(builder, []), Expression(namePart, [])])    VariableReference(builder, [])    Expression(namePart, [])  Statement(}, [])  Statement(}, [])  MethodCall(if (!TextUtils.isEmpty(suffix)), [VariableReference(if (!TextUtils, []), Expression(suffix), [])])    VariableReference(if (!TextUtils, [])    Expression(suffix), [])  Statement(if (!first) {, [])  MethodCall(builder.append(' '), [VariableReference(builder, []), Expression(' ', [])])    VariableReference(builder, [])    Expression(' ', [])  Statement(}, [])  MethodCall(builder.append(suffix), [VariableReference(builder, []), Expression(suffix, [])])    VariableReference(builder, [])    Expression(suffix, [])  Statement(}, [])  MethodCall(return builder.toString(), [VariableReference(return builder, []), Expression(, [])])    VariableReference(return builder, [])    Expression(, [])  Statement(}, [])",1,,,-1,,,-1,-1,-1,-1,-1,"4,5",1,5,0,"The main change is that the parameter name for the API `sortNameElements` has modified from `nameOrderType` to `vcardType`. This is a change in the dependent API call, thus the code change type is 5.","This change does not affect the return value or exception behavior of the method. Therefore, no Compatibility Issue exists, and the CI type is 0."
147,<android.widget.TextView: float getLeftFadingEdgeStrength()>,18,19,<android.widget.TextView: float getLeftFadingEdgeStrength()>,<android.widget.TextView: float getLeftFadingEdgeStrength()>,0,"MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(if (mEllipsize, []), Expression(, [])]), AssignmentExpression(=, [VariableReference(if (mMarquee !, []), Expression(null && !mMarquee.isStopped()) {, [])]), AssignmentExpression(=, [VariableReference(final Marquee marquee, []), Expression(mMarquee, [])]), MethodCall(if (marquee.shouldDrawLeftFade()), [VariableReference(if (marquee, []), Expression(), [])]), AssignmentExpression(=, [VariableReference(final float scroll, []), Expression(marquee.getScroll(), [])]), Statement(return scroll / getHorizontalFadingEdgeLength(), []), Statement(} else {, []), Statement(return 0.0f, []), Statement(}, []), AssignmentExpression(=, [VariableReference(} else if (getLineCount(), []), Expression(, [])]), AssignmentExpression(=, [VariableReference(final int layoutDirection, []), Expression(getLayoutDirection(), [])]), AssignmentExpression(=, [VariableReference(final int absoluteGravity, []), Expression(Gravity.getAbsoluteGravity(mGravity, layoutDirection), [])]), Statement(case Gravity.LEFT:, []), Statement(return 0.0f, []), Statement(case Gravity.RIGHT:, []), MethodCall(return (mLayout.getLineRight(0) - (mRight - mLeft) - getCompoundPaddingLeft() - getCompoundPaddingRight() - mLayout.getLineLeft(0)) / getHorizontalFadingEdgeLength(), [VariableReference(return (mLayout, []), Expression(0) - (mRight - mLeft) - getCompoundPaddingLeft() - getCompoundPaddingRight() - mLayout.getLineLeft(0)) / getHorizontalFadingEdgeLength(, [])]), Statement(case Gravity.CENTER_HORIZONTAL:, []), Statement(return 0.0f, []), Statement(}, []), Statement(}, []), Statement(}, []), MethodCall(return super.getLeftFadingEdgeStrength(), [VariableReference(return super, []), Expression(, [])]), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(if (mEllipsize, []), Expression(, [])])    VariableReference(if (mEllipsize, [])    Expression(, [])  AssignmentExpression(=, [VariableReference(if (mMarquee !, []), Expression(null && !mMarquee.isStopped()) {, [])])    VariableReference(if (mMarquee !, [])    Expression(null && !mMarquee.isStopped()) {, [])  AssignmentExpression(=, [VariableReference(final Marquee marquee, []), Expression(mMarquee, [])])    VariableReference(final Marquee marquee, [])    Expression(mMarquee, [])  MethodCall(if (marquee.shouldDrawLeftFade()), [VariableReference(if (marquee, []), Expression(), [])])    VariableReference(if (marquee, [])    Expression(), [])  AssignmentExpression(=, [VariableReference(final float scroll, []), Expression(marquee.getScroll(), [])])    VariableReference(final float scroll, [])    Expression(marquee.getScroll(), [])  Statement(return scroll / getHorizontalFadingEdgeLength(), [])  Statement(} else {, [])  Statement(return 0.0f, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(} else if (getLineCount(), []), Expression(, [])])    VariableReference(} else if (getLineCount(), [])    Expression(, [])  AssignmentExpression(=, [VariableReference(final int layoutDirection, []), Expression(getLayoutDirection(), [])])    VariableReference(final int layoutDirection, [])    Expression(getLayoutDirection(), [])  AssignmentExpression(=, [VariableReference(final int absoluteGravity, []), Expression(Gravity.getAbsoluteGravity(mGravity, layoutDirection), [])])    VariableReference(final int absoluteGravity, [])    Expression(Gravity.getAbsoluteGravity(mGravity, layoutDirection), [])  Statement(case Gravity.LEFT:, [])  Statement(return 0.0f, [])  Statement(case Gravity.RIGHT:, [])  MethodCall(return (mLayout.getLineRight(0) - (mRight - mLeft) - getCompoundPaddingLeft() - getCompoundPaddingRight() - mLayout.getLineLeft(0)) / getHorizontalFadingEdgeLength(), [VariableReference(return (mLayout, []), Expression(0) - (mRight - mLeft) - getCompoundPaddingLeft() - getCompoundPaddingRight() - mLayout.getLineLeft(0)) / getHorizontalFadingEdgeLength(, [])])    VariableReference(return (mLayout, [])    Expression(0) - (mRight - mLeft) - getCompoundPaddingLeft() - getCompoundPaddingRight() - mLayout.getLineLeft(0)) / getHorizontalFadingEdgeLength(, [])  Statement(case Gravity.CENTER_HORIZONTAL:, [])  Statement(return 0.0f, [])  Statement(}, [])  Statement(}, [])  Statement(}, [])  MethodCall(return super.getLeftFadingEdgeStrength(), [VariableReference(return super, []), Expression(, [])])    VariableReference(return super, [])    Expression(, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(if (mEllipsize, []), Expression(, [])]), AssignmentExpression(=, [VariableReference(if (mMarquee !, []), Expression(null && !mMarquee.isStopped()) {, [])]), AssignmentExpression(=, [VariableReference(final Marquee marquee, []), Expression(mMarquee, [])]), MethodCall(if (marquee.shouldDrawLeftFade()), [VariableReference(if (marquee, []), Expression(), [])]), AssignmentExpression(=, [VariableReference(final float scroll, []), Expression(marquee.getScroll(), [])]), Statement(return scroll / getHorizontalFadingEdgeLength(), []), Statement(} else {, []), Statement(return 0.0f, []), Statement(}, []), AssignmentExpression(=, [VariableReference(} else if (getLineCount(), []), Expression(, [])]), AssignmentExpression(=, [VariableReference(final int layoutDirection, []), Expression(getLayoutDirection(), [])]), AssignmentExpression(=, [VariableReference(final int absoluteGravity, []), Expression(Gravity.getAbsoluteGravity(mGravity, layoutDirection), [])]), Statement(case Gravity.LEFT:, []), Statement(return 0.0f, []), Statement(case Gravity.RIGHT:, []), MethodCall(return (mLayout.getLineRight(0) - (mRight - mLeft) - getCompoundPaddingLeft() - getCompoundPaddingRight() - mLayout.getLineLeft(0)) / getHorizontalFadingEdgeLength(), [VariableReference(return (mLayout, []), Expression(0) - (mRight - mLeft) - getCompoundPaddingLeft() - getCompoundPaddingRight() - mLayout.getLineLeft(0)) / getHorizontalFadingEdgeLength(, [])]), Statement(case Gravity.CENTER_HORIZONTAL:, []), Statement(case Gravity.FILL_HORIZONTAL:, []), AssignmentExpression(=, [VariableReference(final int textDirection, []), Expression(mLayout.getParagraphDirection(0), [])]), AssignmentExpression(=, [VariableReference(if (textDirection, []), Expression(, [])]), Statement(return 0.0f, []), Statement(} else {, []), MethodCall(return (mLayout.getLineRight(0) - (mRight - mLeft) - getCompoundPaddingLeft() - getCompoundPaddingRight() - mLayout.getLineLeft(0)) / getHorizontalFadingEdgeLength(), [VariableReference(return (mLayout, []), Expression(0) - (mRight - mLeft) - getCompoundPaddingLeft() - getCompoundPaddingRight() - mLayout.getLineLeft(0)) / getHorizontalFadingEdgeLength(, [])]), Statement(}, []), Statement(}, []), Statement(}, []), Statement(}, []), MethodCall(return super.getLeftFadingEdgeStrength(), [VariableReference(return super, []), Expression(, [])]), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(if (mEllipsize, []), Expression(, [])])    VariableReference(if (mEllipsize, [])    Expression(, [])  AssignmentExpression(=, [VariableReference(if (mMarquee !, []), Expression(null && !mMarquee.isStopped()) {, [])])    VariableReference(if (mMarquee !, [])    Expression(null && !mMarquee.isStopped()) {, [])  AssignmentExpression(=, [VariableReference(final Marquee marquee, []), Expression(mMarquee, [])])    VariableReference(final Marquee marquee, [])    Expression(mMarquee, [])  MethodCall(if (marquee.shouldDrawLeftFade()), [VariableReference(if (marquee, []), Expression(), [])])    VariableReference(if (marquee, [])    Expression(), [])  AssignmentExpression(=, [VariableReference(final float scroll, []), Expression(marquee.getScroll(), [])])    VariableReference(final float scroll, [])    Expression(marquee.getScroll(), [])  Statement(return scroll / getHorizontalFadingEdgeLength(), [])  Statement(} else {, [])  Statement(return 0.0f, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(} else if (getLineCount(), []), Expression(, [])])    VariableReference(} else if (getLineCount(), [])    Expression(, [])  AssignmentExpression(=, [VariableReference(final int layoutDirection, []), Expression(getLayoutDirection(), [])])    VariableReference(final int layoutDirection, [])    Expression(getLayoutDirection(), [])  AssignmentExpression(=, [VariableReference(final int absoluteGravity, []), Expression(Gravity.getAbsoluteGravity(mGravity, layoutDirection), [])])    VariableReference(final int absoluteGravity, [])    Expression(Gravity.getAbsoluteGravity(mGravity, layoutDirection), [])  Statement(case Gravity.LEFT:, [])  Statement(return 0.0f, [])  Statement(case Gravity.RIGHT:, [])  MethodCall(return (mLayout.getLineRight(0) - (mRight - mLeft) - getCompoundPaddingLeft() - getCompoundPaddingRight() - mLayout.getLineLeft(0)) / getHorizontalFadingEdgeLength(), [VariableReference(return (mLayout, []), Expression(0) - (mRight - mLeft) - getCompoundPaddingLeft() - getCompoundPaddingRight() - mLayout.getLineLeft(0)) / getHorizontalFadingEdgeLength(, [])])    VariableReference(return (mLayout, [])    Expression(0) - (mRight - mLeft) - getCompoundPaddingLeft() - getCompoundPaddingRight() - mLayout.getLineLeft(0)) / getHorizontalFadingEdgeLength(, [])  Statement(case Gravity.CENTER_HORIZONTAL:, [])  Statement(case Gravity.FILL_HORIZONTAL:, [])  AssignmentExpression(=, [VariableReference(final int textDirection, []), Expression(mLayout.getParagraphDirection(0), [])])    VariableReference(final int textDirection, [])    Expression(mLayout.getParagraphDirection(0), [])  AssignmentExpression(=, [VariableReference(if (textDirection, []), Expression(, [])])    VariableReference(if (textDirection, [])    Expression(, [])  Statement(return 0.0f, [])  Statement(} else {, [])  MethodCall(return (mLayout.getLineRight(0) - (mRight - mLeft) - getCompoundPaddingLeft() - getCompoundPaddingRight() - mLayout.getLineLeft(0)) / getHorizontalFadingEdgeLength(), [VariableReference(return (mLayout, []), Expression(0) - (mRight - mLeft) - getCompoundPaddingLeft() - getCompoundPaddingRight() - mLayout.getLineLeft(0)) / getHorizontalFadingEdgeLength(, [])])    VariableReference(return (mLayout, [])    Expression(0) - (mRight - mLeft) - getCompoundPaddingLeft() - getCompoundPaddingRight() - mLayout.getLineLeft(0)) / getHorizontalFadingEdgeLength(, [])  Statement(}, [])  Statement(}, [])  Statement(}, [])  Statement(}, [])  MethodCall(return super.getLeftFadingEdgeStrength(), [VariableReference(return super, []), Expression(, [])])    VariableReference(return super, [])    Expression(, [])  Statement(}, [])",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,"1,3,4",1,"3,4",0,"The changes include an introduction of the 'case Gravity.FILL_HORIZONTAL' case and the 'textDirection' variable along with its conditional check and assignment. These changes fall under both control dependency changes and other statement changes (case statement, variable assignment). ","None of the changes in control flow or other statements will impact the return value directly or modify exception handling behavior, hence no Compatibility Issue exists."
615,"<android.webkit.CallbackProxy: void onTooManyRedirects(Message,Message)>",7,8,"<android.webkit.CallbackProxy: void onTooManyRedirects(Message,Message)>","<android.webkit.CallbackProxy: void onTooManyRedirects(Message,Message)>",0,"MethodDeclaration(method_body, [Statement({, []), Statement(// been set., []), AssignmentExpression(=, [VariableReference(if (mWebViewClient, []), Expression(, [])]), MethodCall(cancelMsg.sendToTarget(), [VariableReference(cancelMsg, []), Expression(, [])]), Statement(return, []), Statement(}, []), AssignmentExpression(=, [VariableReference(Message msg, []), Expression(obtainMessage(TOO_MANY_REDIRECTS), [])]), AssignmentExpression(=, [VariableReference(Bundle bundle, []), Expression(msg.getData(), [])]), MethodCall(bundle.putParcelable(""cancelMsg"", cancelMsg), [VariableReference(bundle, []), Expression(""cancelMsg"", []), Expression(cancelMsg, [])]), MethodCall(bundle.putParcelable(""continueMsg"", continueMsg), [VariableReference(bundle, []), Expression(""continueMsg"", []), Expression(continueMsg, [])]), Statement(sendMessage(msg), []), Statement(}, [])])  Statement({, [])  Statement(// been set., [])  AssignmentExpression(=, [VariableReference(if (mWebViewClient, []), Expression(, [])])    VariableReference(if (mWebViewClient, [])    Expression(, [])  MethodCall(cancelMsg.sendToTarget(), [VariableReference(cancelMsg, []), Expression(, [])])    VariableReference(cancelMsg, [])    Expression(, [])  Statement(return, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(Message msg, []), Expression(obtainMessage(TOO_MANY_REDIRECTS), [])])    VariableReference(Message msg, [])    Expression(obtainMessage(TOO_MANY_REDIRECTS), [])  AssignmentExpression(=, [VariableReference(Bundle bundle, []), Expression(msg.getData(), [])])    VariableReference(Bundle bundle, [])    Expression(msg.getData(), [])  MethodCall(bundle.putParcelable(""cancelMsg"", cancelMsg), [VariableReference(bundle, []), Expression(""cancelMsg"", []), Expression(cancelMsg, [])])    VariableReference(bundle, [])    Expression(""cancelMsg"", [])    Expression(cancelMsg, [])  MethodCall(bundle.putParcelable(""continueMsg"", continueMsg), [VariableReference(bundle, []), Expression(""continueMsg"", []), Expression(continueMsg, [])])    VariableReference(bundle, [])    Expression(""continueMsg"", [])    Expression(continueMsg, [])  Statement(sendMessage(msg), [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(// deprecated., []), Statement(}, [])])  Statement({, [])  Statement(// deprecated., [])  Statement(}, [])",1,,"// party of the public classes, we cannot remove this method.
",-1,,,-1,-1,-1,-1,-1,4,1,1,1,"The entire method body has changed. The early version had multiple statements for handling too many redirects, while the late version marked it as deprecated with no functional code. The change type is 1.","Since the method in the late version no longer executes the same logic as in the early version, it could potentially return different results (in this case, it performs no actions). This constitutes a CI of type 1."
209,<android.content.Intent: String toUri(int)>,21,22,<android.content.Intent: String toUri(int)>,<android.content.Intent: String toUri(int)>,0,"MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(StringBuilder uri, []), Expression(new StringBuilder(128), [])]), AssignmentExpression(=, [VariableReference(String scheme, []), Expression(null, [])]), AssignmentExpression(=, [VariableReference(if (mData !, []), Expression(null) {, [])]), AssignmentExpression(=, [VariableReference(String data, []), Expression(mData.toString(), [])]), AssignmentExpression(=, [VariableReference(if ((flags & URI_INTENT_SCHEME) !, []), Expression(0) {, [])]), AssignmentExpression(=, [VariableReference(final int N, []), Expression(data.length(), [])]), AssignmentExpression(=, [VariableReference(for (int i, []), Expression(0, [])]), Statement(i < N, []), Statement(i++) {, []), AssignmentExpression(=, [VariableReference(char c, []), Expression(data.charAt(i), [])]), AssignmentExpression(=, [VariableReference(if ((c >, []), Expression('a' && c <, [])]), Statement(continue, []), Statement(}, []), AssignmentExpression(=, [VariableReference(if (c, []), Expression(, [])]), Statement(// Valid scheme., []), AssignmentExpression(=, [VariableReference(scheme, []), Expression(data.substring(0, i), [])]), MethodCall(uri.append(""intent:""), [VariableReference(uri, []), Expression(""intent:"", [])]), AssignmentExpression(=, [VariableReference(data, []), Expression(data.substring(i + 1), [])]), Statement(break, []), Statement(}, []), Statement(// No scheme., []), Statement(break, []), Statement(}, []), Statement(}, []), MethodCall(uri.append(data), [VariableReference(uri, []), Expression(data, [])]), AssignmentExpression(=, [VariableReference(} else if ((flags & URI_INTENT_SCHEME) !, []), Expression(0) {, [])]), MethodCall(uri.append(""intent:""), [VariableReference(uri, []), Expression(""intent:"", [])]), Statement(}, []), Statement(""), []), Statement(toUriInner(uri, scheme, flags), []), AssignmentExpression(=, [VariableReference(if (mSelector !, []), Expression(null) {, [])]), Statement(""), []), Statement(// Note that for now we are not going to try to handle the, []), Statement(// data part, []), Statement(not clear how to represent this as a URI, and, []), Statement(// not much utility in it., []), MethodCall(mSelector.toUriInner(uri, null, flags), [VariableReference(mSelector, []), Expression(uri, []), Expression(null, []), Expression(flags, [])]), Statement(}, []), MethodCall(uri.append(""end""), [VariableReference(uri, []), Expression(""end"", [])]), MethodCall(return uri.toString(), [VariableReference(return uri, []), Expression(, [])]), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(StringBuilder uri, []), Expression(new StringBuilder(128), [])])    VariableReference(StringBuilder uri, [])    Expression(new StringBuilder(128), [])  AssignmentExpression(=, [VariableReference(String scheme, []), Expression(null, [])])    VariableReference(String scheme, [])    Expression(null, [])  AssignmentExpression(=, [VariableReference(if (mData !, []), Expression(null) {, [])])    VariableReference(if (mData !, [])    Expression(null) {, [])  AssignmentExpression(=, [VariableReference(String data, []), Expression(mData.toString(), [])])    VariableReference(String data, [])    Expression(mData.toString(), [])  AssignmentExpression(=, [VariableReference(if ((flags & URI_INTENT_SCHEME) !, []), Expression(0) {, [])])    VariableReference(if ((flags & URI_INTENT_SCHEME) !, [])    Expression(0) {, [])  AssignmentExpression(=, [VariableReference(final int N, []), Expression(data.length(), [])])    VariableReference(final int N, [])    Expression(data.length(), [])  AssignmentExpression(=, [VariableReference(for (int i, []), Expression(0, [])])    VariableReference(for (int i, [])    Expression(0, [])  Statement(i < N, [])  Statement(i++) {, [])  AssignmentExpression(=, [VariableReference(char c, []), Expression(data.charAt(i), [])])    VariableReference(char c, [])    Expression(data.charAt(i), [])  AssignmentExpression(=, [VariableReference(if ((c >, []), Expression('a' && c <, [])])    VariableReference(if ((c >, [])    Expression('a' && c <, [])  Statement(continue, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(if (c, []), Expression(, [])])    VariableReference(if (c, [])    Expression(, [])  Statement(// Valid scheme., [])  AssignmentExpression(=, [VariableReference(scheme, []), Expression(data.substring(0, i), [])])    VariableReference(scheme, [])    Expression(data.substring(0, i), [])  MethodCall(uri.append(""intent:""), [VariableReference(uri, []), Expression(""intent:"", [])])    VariableReference(uri, [])    Expression(""intent:"", [])  AssignmentExpression(=, [VariableReference(data, []), Expression(data.substring(i + 1), [])])    VariableReference(data, [])    Expression(data.substring(i + 1), [])  Statement(break, [])  Statement(}, [])  Statement(// No scheme., [])  Statement(break, [])  Statement(}, [])  Statement(}, [])  MethodCall(uri.append(data), [VariableReference(uri, []), Expression(data, [])])    VariableReference(uri, [])    Expression(data, [])  AssignmentExpression(=, [VariableReference(} else if ((flags & URI_INTENT_SCHEME) !, []), Expression(0) {, [])])    VariableReference(} else if ((flags & URI_INTENT_SCHEME) !, [])    Expression(0) {, [])  MethodCall(uri.append(""intent:""), [VariableReference(uri, []), Expression(""intent:"", [])])    VariableReference(uri, [])    Expression(""intent:"", [])  Statement(}, [])  Statement(""), [])  Statement(toUriInner(uri, scheme, flags), [])  AssignmentExpression(=, [VariableReference(if (mSelector !, []), Expression(null) {, [])])    VariableReference(if (mSelector !, [])    Expression(null) {, [])  Statement(""), [])  Statement(// Note that for now we are not going to try to handle the, [])  Statement(// data part, [])  Statement(not clear how to represent this as a URI, and, [])  Statement(// not much utility in it., [])  MethodCall(mSelector.toUriInner(uri, null, flags), [VariableReference(mSelector, []), Expression(uri, []), Expression(null, []), Expression(flags, [])])    VariableReference(mSelector, [])    Expression(uri, [])    Expression(null, [])    Expression(flags, [])  Statement(}, [])  MethodCall(uri.append(""end""), [VariableReference(uri, []), Expression(""end"", [])])    VariableReference(uri, [])    Expression(""end"", [])  MethodCall(return uri.toString(), [VariableReference(return uri, []), Expression(, [])])    VariableReference(return uri, [])    Expression(, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(StringBuilder uri, []), Expression(new StringBuilder(128), [])]), AssignmentExpression(=, [VariableReference(if ((flags & URI_ANDROID_APP_SCHEME) !, []), Expression(0) {, [])]), AssignmentExpression(=, [VariableReference(if (mPackage, []), Expression(, [])]), Statement(throw new IllegalArgumentException(""Intent must include an explicit package name to build an android-app: "" + this), []), Statement(}, []), MethodCall(uri.append(""android-app://""), [VariableReference(uri, []), Expression(""android-app://"", [])]), MethodCall(uri.append(mPackage), [VariableReference(uri, []), Expression(mPackage, [])]), AssignmentExpression(=, [VariableReference(String scheme, []), Expression(null, [])]), AssignmentExpression(=, [VariableReference(if (mData !, []), Expression(null) {, [])]), AssignmentExpression(=, [VariableReference(scheme, []), Expression(mData.getScheme(), [])]), AssignmentExpression(=, [VariableReference(if (scheme !, []), Expression(null) {, [])]), MethodCall(uri.append('/'), [VariableReference(uri, []), Expression('/', [])]), MethodCall(uri.append(scheme), [VariableReference(uri, []), Expression(scheme, [])]), AssignmentExpression(=, [VariableReference(String authority, []), Expression(mData.getEncodedAuthority(), [])]), AssignmentExpression(=, [VariableReference(if (authority !, []), Expression(null) {, [])]), MethodCall(uri.append('/'), [VariableReference(uri, []), Expression('/', [])]), MethodCall(uri.append(authority), [VariableReference(uri, []), Expression(authority, [])]), AssignmentExpression(=, [VariableReference(String path, []), Expression(mData.getEncodedPath(), [])]), AssignmentExpression(=, [VariableReference(if (path !, []), Expression(null) {, [])]), MethodCall(uri.append(path), [VariableReference(uri, []), Expression(path, [])]), Statement(}, []), AssignmentExpression(=, [VariableReference(String queryParams, []), Expression(mData.getEncodedQuery(), [])]), AssignmentExpression(=, [VariableReference(if (queryParams !, []), Expression(null) {, [])]), MethodCall(uri.append('?'), [VariableReference(uri, []), Expression('?', [])]), MethodCall(uri.append(queryParams), [VariableReference(uri, []), Expression(queryParams, [])]), Statement(}, []), AssignmentExpression(=, [VariableReference(String fragment, []), Expression(mData.getEncodedFragment(), [])]), AssignmentExpression(=, [VariableReference(if (fragment !, []), Expression(null) {, [])]), MethodCall(uri.append('#'), [VariableReference(uri, []), Expression('#', [])]), MethodCall(uri.append(fragment), [VariableReference(uri, []), Expression(fragment, [])]), Statement(}, []), Statement(}, []), Statement(}, []), Statement(}, []), AssignmentExpression(=, [VariableReference(toUriFragment(uri, null, scheme, []), Expression(, [])]), MethodCall(return uri.toString(), [VariableReference(return uri, []), Expression(, [])]), Statement(}, []), AssignmentExpression(=, [VariableReference(String scheme, []), Expression(null, [])]), AssignmentExpression(=, [VariableReference(if (mData !, []), Expression(null) {, [])]), AssignmentExpression(=, [VariableReference(String data, []), Expression(mData.toString(), [])]), AssignmentExpression(=, [VariableReference(if ((flags & URI_INTENT_SCHEME) !, []), Expression(0) {, [])]), AssignmentExpression(=, [VariableReference(final int N, []), Expression(data.length(), [])]), AssignmentExpression(=, [VariableReference(for (int i, []), Expression(0, [])]), Statement(i < N, []), Statement(i++) {, []), AssignmentExpression(=, [VariableReference(char c, []), Expression(data.charAt(i), [])]), AssignmentExpression(=, [VariableReference(if ((c >, []), Expression('a' && c <, [])]), Statement(continue, []), Statement(}, []), AssignmentExpression(=, [VariableReference(if (c, []), Expression(, [])]), Statement(// Valid scheme., []), AssignmentExpression(=, [VariableReference(scheme, []), Expression(data.substring(0, i), [])]), MethodCall(uri.append(""intent:""), [VariableReference(uri, []), Expression(""intent:"", [])]), AssignmentExpression(=, [VariableReference(data, []), Expression(data.substring(i + 1), [])]), Statement(break, []), Statement(}, []), Statement(// No scheme., []), Statement(break, []), Statement(}, []), Statement(}, []), MethodCall(uri.append(data), [VariableReference(uri, []), Expression(data, [])]), AssignmentExpression(=, [VariableReference(} else if ((flags & URI_INTENT_SCHEME) !, []), Expression(0) {, [])]), MethodCall(uri.append(""intent:""), [VariableReference(uri, []), Expression(""intent:"", [])]), Statement(}, []), MethodCall(return uri.toString(), [VariableReference(return uri, []), Expression(, [])]), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(StringBuilder uri, []), Expression(new StringBuilder(128), [])])    VariableReference(StringBuilder uri, [])    Expression(new StringBuilder(128), [])  AssignmentExpression(=, [VariableReference(if ((flags & URI_ANDROID_APP_SCHEME) !, []), Expression(0) {, [])])    VariableReference(if ((flags & URI_ANDROID_APP_SCHEME) !, [])    Expression(0) {, [])  AssignmentExpression(=, [VariableReference(if (mPackage, []), Expression(, [])])    VariableReference(if (mPackage, [])    Expression(, [])  Statement(throw new IllegalArgumentException(""Intent must include an explicit package name to build an android-app: "" + this), [])  Statement(}, [])  MethodCall(uri.append(""android-app://""), [VariableReference(uri, []), Expression(""android-app://"", [])])    VariableReference(uri, [])    Expression(""android-app://"", [])  MethodCall(uri.append(mPackage), [VariableReference(uri, []), Expression(mPackage, [])])    VariableReference(uri, [])    Expression(mPackage, [])  AssignmentExpression(=, [VariableReference(String scheme, []), Expression(null, [])])    VariableReference(String scheme, [])    Expression(null, [])  AssignmentExpression(=, [VariableReference(if (mData !, []), Expression(null) {, [])])    VariableReference(if (mData !, [])    Expression(null) {, [])  AssignmentExpression(=, [VariableReference(scheme, []), Expression(mData.getScheme(), [])])    VariableReference(scheme, [])    Expression(mData.getScheme(), [])  AssignmentExpression(=, [VariableReference(if (scheme !, []), Expression(null) {, [])])    VariableReference(if (scheme !, [])    Expression(null) {, [])  MethodCall(uri.append('/'), [VariableReference(uri, []), Expression('/', [])])    VariableReference(uri, [])    Expression('/', [])  MethodCall(uri.append(scheme), [VariableReference(uri, []), Expression(scheme, [])])    VariableReference(uri, [])    Expression(scheme, [])  AssignmentExpression(=, [VariableReference(String authority, []), Expression(mData.getEncodedAuthority(), [])])    VariableReference(String authority, [])    Expression(mData.getEncodedAuthority(), [])  AssignmentExpression(=, [VariableReference(if (authority !, []), Expression(null) {, [])])    VariableReference(if (authority !, [])    Expression(null) {, [])  MethodCall(uri.append('/'), [VariableReference(uri, []), Expression('/', [])])    VariableReference(uri, [])    Expression('/', [])  MethodCall(uri.append(authority), [VariableReference(uri, []), Expression(authority, [])])    VariableReference(uri, [])    Expression(authority, [])  AssignmentExpression(=, [VariableReference(String path, []), Expression(mData.getEncodedPath(), [])])    VariableReference(String path, [])    Expression(mData.getEncodedPath(), [])  AssignmentExpression(=, [VariableReference(if (path !, []), Expression(null) {, [])])    VariableReference(if (path !, [])    Expression(null) {, [])  MethodCall(uri.append(path), [VariableReference(uri, []), Expression(path, [])])    VariableReference(uri, [])    Expression(path, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(String queryParams, []), Expression(mData.getEncodedQuery(), [])])    VariableReference(String queryParams, [])    Expression(mData.getEncodedQuery(), [])  AssignmentExpression(=, [VariableReference(if (queryParams !, []), Expression(null) {, [])])    VariableReference(if (queryParams !, [])    Expression(null) {, [])  MethodCall(uri.append('?'), [VariableReference(uri, []), Expression('?', [])])    VariableReference(uri, [])    Expression('?', [])  MethodCall(uri.append(queryParams), [VariableReference(uri, []), Expression(queryParams, [])])    VariableReference(uri, [])    Expression(queryParams, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(String fragment, []), Expression(mData.getEncodedFragment(), [])])    VariableReference(String fragment, [])    Expression(mData.getEncodedFragment(), [])  AssignmentExpression(=, [VariableReference(if (fragment !, []), Expression(null) {, [])])    VariableReference(if (fragment !, [])    Expression(null) {, [])  MethodCall(uri.append('#'), [VariableReference(uri, []), Expression('#', [])])    VariableReference(uri, [])    Expression('#', [])  MethodCall(uri.append(fragment), [VariableReference(uri, []), Expression(fragment, [])])    VariableReference(uri, [])    Expression(fragment, [])  Statement(}, [])  Statement(}, [])  Statement(}, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(toUriFragment(uri, null, scheme, []), Expression(, [])])    VariableReference(toUriFragment(uri, null, scheme, [])    Expression(, [])  MethodCall(return uri.toString(), [VariableReference(return uri, []), Expression(, [])])    VariableReference(return uri, [])    Expression(, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(String scheme, []), Expression(null, [])])    VariableReference(String scheme, [])    Expression(null, [])  AssignmentExpression(=, [VariableReference(if (mData !, []), Expression(null) {, [])])    VariableReference(if (mData !, [])    Expression(null) {, [])  AssignmentExpression(=, [VariableReference(String data, []), Expression(mData.toString(), [])])    VariableReference(String data, [])    Expression(mData.toString(), [])  AssignmentExpression(=, [VariableReference(if ((flags & URI_INTENT_SCHEME) !, []), Expression(0) {, [])])    VariableReference(if ((flags & URI_INTENT_SCHEME) !, [])    Expression(0) {, [])  AssignmentExpression(=, [VariableReference(final int N, []), Expression(data.length(), [])])    VariableReference(final int N, [])    Expression(data.length(), [])  AssignmentExpression(=, [VariableReference(for (int i, []), Expression(0, [])])    VariableReference(for (int i, [])    Expression(0, [])  Statement(i < N, [])  Statement(i++) {, [])  AssignmentExpression(=, [VariableReference(char c, []), Expression(data.charAt(i), [])])    VariableReference(char c, [])    Expression(data.charAt(i), [])  AssignmentExpression(=, [VariableReference(if ((c >, []), Expression('a' && c <, [])])    VariableReference(if ((c >, [])    Expression('a' && c <, [])  Statement(continue, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(if (c, []), Expression(, [])])    VariableReference(if (c, [])    Expression(, [])  Statement(// Valid scheme., [])  AssignmentExpression(=, [VariableReference(scheme, []), Expression(data.substring(0, i), [])])    VariableReference(scheme, [])    Expression(data.substring(0, i), [])  MethodCall(uri.append(""intent:""), [VariableReference(uri, []), Expression(""intent:"", [])])    VariableReference(uri, [])    Expression(""intent:"", [])  AssignmentExpression(=, [VariableReference(data, []), Expression(data.substring(i + 1), [])])    VariableReference(data, [])    Expression(data.substring(i + 1), [])  Statement(break, [])  Statement(}, [])  Statement(// No scheme., [])  Statement(break, [])  Statement(}, [])  Statement(}, [])  MethodCall(uri.append(data), [VariableReference(uri, []), Expression(data, [])])    VariableReference(uri, [])    Expression(data, [])  AssignmentExpression(=, [VariableReference(} else if ((flags & URI_INTENT_SCHEME) !, []), Expression(0) {, [])])    VariableReference(} else if ((flags & URI_INTENT_SCHEME) !, [])    Expression(0) {, [])  MethodCall(uri.append(""intent:""), [VariableReference(uri, []), Expression(""intent:"", [])])    VariableReference(uri, [])    Expression(""intent:"", [])  Statement(}, [])  MethodCall(return uri.toString(), [VariableReference(return uri, []), Expression(, [])])    VariableReference(return uri, [])    Expression(, [])  Statement(}, [])",1,"/**
 * Convert this Intent into a String holding a URI representation of it.
 * The returned URI string has been properly URI encoded, so it can be
 * used with {@link Uri#parse Uri.parse(String)}.  The URI contains the
 * Intent's data as the base URI, with an additional fragment describing
 * the action, categories, type, flags, package, component, and extras.
 *
 * <p>You can convert the returned string back to an Intent with
 * {@link #getIntent}.
 *
 * @param flags Additional operating flags.  Either 0 or
 * {@link #URI_INTENT_SCHEME}.
 *
 * @return Returns a URI encoding URI string describing the entire contents
 * of the Intent.
 */
","/**
 * Convert this Intent into a String holding a URI representation of it.
 * The returned URI string has been properly URI encoded, so it can be
 * used with {@link Uri#parse Uri.parse(String)}.  The URI contains the
 * Intent's data as the base URI, with an additional fragment describing
 * the action, categories, type, flags, package, component, and extras.
 *
 * <p>You can convert the returned string back to an Intent with
 * {@link #getIntent}.
 *
 * @param flags Additional operating flags.  Either 0,
 * {@link #URI_INTENT_SCHEME}, or {@link #URI_ANDROID_APP_SCHEME}.
 *
 * @return Returns a URI encoding URI string describing the entire contents
 * of the Intent.
 */
",-1,,,-1,-1,-1,-1,-1,"1,3,4",1,3,"1,2","The control dependency changes, specifically with new checks on `flags` containing `URI_ANDROID_APP_SCHEME` and `mPackage` being non-null, thus introducing a new illegal argument exception and modifying the URI structure; so the code change type is 3.","Different handling paths and new exception (IllegalArgumentException) introduced with the added `if` check logic can cause different return values and exception handling. Hence, the CI type is 1,2."
178,"<android.hardware.Sensor: int getMaxLengthValuesArray(Sensor,int)>",18,19,"<android.hardware.Sensor: int getMaxLengthValuesArray(Sensor,int)>","<android.hardware.Sensor: int getMaxLengthValuesArray(Sensor,int)>",0,"MethodDeclaration(method_body, [Statement({, []), Statement(// mType starts from offset 1., []), AssignmentExpression(=, [VariableReference(int len, []), Expression(sMaxLengthValuesArray[sensor.mType - 1], [])]), Statement(// Set it to 3 for backward compatibility., []), AssignmentExpression(=, [VariableReference(if (sensor.getType(), []), Expression(, [])]), AssignmentExpression(=, [VariableReference(len, []), Expression(3, [])]), Statement(}, []), Statement(return len, []), Statement(}, [])])  Statement({, [])  Statement(// mType starts from offset 1., [])  AssignmentExpression(=, [VariableReference(int len, []), Expression(sMaxLengthValuesArray[sensor.mType - 1], [])])    VariableReference(int len, [])    Expression(sMaxLengthValuesArray[sensor.mType - 1], [])  Statement(// Set it to 3 for backward compatibility., [])  AssignmentExpression(=, [VariableReference(if (sensor.getType(), []), Expression(, [])])    VariableReference(if (sensor.getType(), [])    Expression(, [])  AssignmentExpression(=, [VariableReference(len, []), Expression(3, [])])    VariableReference(len, [])    Expression(3, [])  Statement(}, [])  Statement(return len, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(int type, []), Expression(sensor.mType, [])]), Statement(// Set it to 3 for backward compatibility., []), AssignmentExpression(=, [VariableReference(if (type, []), Expression(, [])]), Statement(return 3, []), Statement(}, []), AssignmentExpression(=, [VariableReference(int offset, []), Expression(type * 2 + 1, [])]), AssignmentExpression(=, [VariableReference(if (offset >, []), Expression(sSensorReportingModes.length) {, [])]), Statement(// sensor, []), Statement(return 16, []), Statement(}, []), Statement(return sSensorReportingModes[offset], []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(int type, []), Expression(sensor.mType, [])])    VariableReference(int type, [])    Expression(sensor.mType, [])  Statement(// Set it to 3 for backward compatibility., [])  AssignmentExpression(=, [VariableReference(if (type, []), Expression(, [])])    VariableReference(if (type, [])    Expression(, [])  Statement(return 3, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(int offset, []), Expression(type * 2 + 1, [])])    VariableReference(int offset, [])    Expression(type * 2 + 1, [])  AssignmentExpression(=, [VariableReference(if (offset >, []), Expression(sSensorReportingModes.length) {, [])])    VariableReference(if (offset >, [])    Expression(sSensorReportingModes.length) {, [])  Statement(// sensor, [])  Statement(return 16, [])  Statement(}, [])  Statement(return sSensorReportingModes[offset], [])  Statement(}, [])",1,,,-1,,,-1,-1,-1,-1,-1,"1,3,4",1,"1,3,4",1,Multiple changes are observed:,"3. Intermediates like `type`, `offset`, as well as their assignments and uses, are completely new, indicating other statement changes not explicitly covered by the other categories."
666,<android.view.ScaleGestureDetector: float getCurrentSpanX()>,16,17,<android.view.ScaleGestureDetector: float getCurrentSpanX()>,<android.view.ScaleGestureDetector: float getCurrentSpanX()>,0,"MethodDeclaration(method_body, [Statement({, []), Statement(return mCurrFingerDiffX, []), Statement(}, [])])  Statement({, [])  Statement(return mCurrFingerDiffX, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(return mCurrSpanX, []), Statement(}, [])])  Statement({, [])  Statement(return mCurrSpanX, [])  Statement(}, [])",1,"/**
 * Return the current x distance between the two pointers forming the
 * gesture in progress.
 *
 * @return Distance between pointers in pixels.
 */
","/**
 * Return the average X distance between each of the pointers forming the
 * gesture in progress through the focal point.
 *
 * @return Distance between pointers in pixels.
 */
",-1,,,-1,-1,-1,-1,-1,"1,4",1,1,1,"The return statement has changed from returning `mCurrFingerDiffX` to returning `mCurrSpanX`, so the code change type is 1.","The change in the return statement means that the method could now potentially return a different value, causing a different behavior in the consuming code. Therefore, the CI type is 1."
1077,<android.hardware.camera2.legacy.LegacyCameraDevice: int detectSurfaceType(Surface)>,25,26,<android.hardware.camera2.legacy.LegacyCameraDevice: int detectSurfaceType(Surface)>,<android.hardware.camera2.legacy.LegacyCameraDevice: int detectSurfaceType(Surface)>,0,"MethodDeclaration(method_body, [Statement({, []), Statement(checkNotNull(surface), []), MethodCall(return LegacyExceptionUtils.throwOnError(nativeDetectSurfaceType(surface)), [VariableReference(return LegacyExceptionUtils, []), Expression(nativeDetectSurfaceType(surface), [])]), Statement(}, [])])  Statement({, [])  Statement(checkNotNull(surface), [])  MethodCall(return LegacyExceptionUtils.throwOnError(nativeDetectSurfaceType(surface)), [VariableReference(return LegacyExceptionUtils, []), Expression(nativeDetectSurfaceType(surface), [])])    VariableReference(return LegacyExceptionUtils, [])    Expression(nativeDetectSurfaceType(surface), [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(checkNotNull(surface), []), AssignmentExpression(=, [VariableReference(int surfaceType, []), Expression(nativeDetectSurfaceType(surface), [])]), Statement(// ImageFormat.PRIVATE. b/9487482, []), AssignmentExpression(=, [VariableReference(if ((surfaceType >, []), Expression(LegacyMetadataMapper.HAL_PIXEL_FORMAT_RGBA_8888 && surfaceType <, [])]), AssignmentExpression(=, [VariableReference(surfaceType, []), Expression(ImageFormat.PRIVATE, [])]), Statement(}, []), MethodCall(return LegacyExceptionUtils.throwOnError(surfaceType), [VariableReference(return LegacyExceptionUtils, []), Expression(surfaceType, [])]), Statement(}, [])])  Statement({, [])  Statement(checkNotNull(surface), [])  AssignmentExpression(=, [VariableReference(int surfaceType, []), Expression(nativeDetectSurfaceType(surface), [])])    VariableReference(int surfaceType, [])    Expression(nativeDetectSurfaceType(surface), [])  Statement(// ImageFormat.PRIVATE. b/9487482, [])  AssignmentExpression(=, [VariableReference(if ((surfaceType >, []), Expression(LegacyMetadataMapper.HAL_PIXEL_FORMAT_RGBA_8888 && surfaceType <, [])])    VariableReference(if ((surfaceType >, [])    Expression(LegacyMetadataMapper.HAL_PIXEL_FORMAT_RGBA_8888 && surfaceType <, [])  AssignmentExpression(=, [VariableReference(surfaceType, []), Expression(ImageFormat.PRIVATE, [])])    VariableReference(surfaceType, [])    Expression(ImageFormat.PRIVATE, [])  Statement(}, [])  MethodCall(return LegacyExceptionUtils.throwOnError(surfaceType), [VariableReference(return LegacyExceptionUtils, []), Expression(surfaceType, [])])    VariableReference(return LegacyExceptionUtils, [])    Expression(surfaceType, [])  Statement(}, [])",1,"/**
 * Query the surface for its currently configured format
 */
","/**
 * Query the surface for its currently configured format
 */
",-1,,,-1,-1,-1,-1,-1,"1,3,4",1,"1,3,4",1,"In the late implementation, the code introduces a new local variable `surfaceType`, assigns the result of `nativeDetectSurfaceType(surface)` to it, adds a conditional statement with an assignment inside it, and changes the return statement to use `surfaceType` directly rather than nested inside a method call.","The introduction of a conditional statement that potentially alters the value of `surfaceType` can cause the return value to differ from the early implementation, making the CI type 1."
668,"<android.app.PendingIntent: PendingIntent getService(Context,int,Intent,int)>",16,17,"<android.app.PendingIntent: PendingIntent getService(Context,int,Intent,int)>","<android.app.PendingIntent: PendingIntent getService(Context,int,Intent,int)>",0,"MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(String packageName, []), Expression(context.getPackageName(), [])]), AssignmentExpression(=, [VariableReference(String resolvedType, []), Expression(intent !, [])]), Statement(try {, []), MethodCall(intent.setAllowFds(false), [VariableReference(intent, []), Expression(false, [])]), AssignmentExpression(=, [VariableReference(IIntentSender target, []), Expression(ActivityManagerNative.getDefault().getIntentSender(ActivityManager.INTENT_SENDER_SERVICE, packageName, null, null, requestCode, new Intent[] { intent }, resolvedType !, [])]), AssignmentExpression(=, [VariableReference(return target !, []), Expression(null ? new PendingIntent(target) : null, [])]), Statement(} catch (RemoteException e) {, []), Statement(}, []), Statement(return null, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(String packageName, []), Expression(context.getPackageName(), [])])    VariableReference(String packageName, [])    Expression(context.getPackageName(), [])  AssignmentExpression(=, [VariableReference(String resolvedType, []), Expression(intent !, [])])    VariableReference(String resolvedType, [])    Expression(intent !, [])  Statement(try {, [])  MethodCall(intent.setAllowFds(false), [VariableReference(intent, []), Expression(false, [])])    VariableReference(intent, [])    Expression(false, [])  AssignmentExpression(=, [VariableReference(IIntentSender target, []), Expression(ActivityManagerNative.getDefault().getIntentSender(ActivityManager.INTENT_SENDER_SERVICE, packageName, null, null, requestCode, new Intent[] { intent }, resolvedType !, [])])    VariableReference(IIntentSender target, [])    Expression(ActivityManagerNative.getDefault().getIntentSender(ActivityManager.INTENT_SENDER_SERVICE, packageName, null, null, requestCode, new Intent[] { intent }, resolvedType !, [])  AssignmentExpression(=, [VariableReference(return target !, []), Expression(null ? new PendingIntent(target) : null, [])])    VariableReference(return target !, [])    Expression(null ? new PendingIntent(target) : null, [])  Statement(} catch (RemoteException e) {, [])  Statement(}, [])  Statement(return null, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(String packageName, []), Expression(context.getPackageName(), [])]), AssignmentExpression(=, [VariableReference(String resolvedType, []), Expression(intent !, [])]), Statement(try {, []), MethodCall(intent.setAllowFds(false), [VariableReference(intent, []), Expression(false, [])]), AssignmentExpression(=, [VariableReference(IIntentSender target, []), Expression(ActivityManagerNative.getDefault().getIntentSender(ActivityManager.INTENT_SENDER_SERVICE, packageName, null, null, requestCode, new Intent[] { intent }, resolvedType !, [])]), AssignmentExpression(=, [VariableReference(return target !, []), Expression(null ? new PendingIntent(target) : null, [])]), Statement(} catch (RemoteException e) {, []), Statement(}, []), Statement(return null, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(String packageName, []), Expression(context.getPackageName(), [])])    VariableReference(String packageName, [])    Expression(context.getPackageName(), [])  AssignmentExpression(=, [VariableReference(String resolvedType, []), Expression(intent !, [])])    VariableReference(String resolvedType, [])    Expression(intent !, [])  Statement(try {, [])  MethodCall(intent.setAllowFds(false), [VariableReference(intent, []), Expression(false, [])])    VariableReference(intent, [])    Expression(false, [])  AssignmentExpression(=, [VariableReference(IIntentSender target, []), Expression(ActivityManagerNative.getDefault().getIntentSender(ActivityManager.INTENT_SENDER_SERVICE, packageName, null, null, requestCode, new Intent[] { intent }, resolvedType !, [])])    VariableReference(IIntentSender target, [])    Expression(ActivityManagerNative.getDefault().getIntentSender(ActivityManager.INTENT_SENDER_SERVICE, packageName, null, null, requestCode, new Intent[] { intent }, resolvedType !, [])  AssignmentExpression(=, [VariableReference(return target !, []), Expression(null ? new PendingIntent(target) : null, [])])    VariableReference(return target !, [])    Expression(null ? new PendingIntent(target) : null, [])  Statement(} catch (RemoteException e) {, [])  Statement(}, [])  Statement(return null, [])  Statement(}, [])",1,"/**
 * Retrieve a PendingIntent that will start a service, like calling
 * {@link Context#startService Context.startService()}.  The start
 * arguments given to the service will come from the extras of the Intent.
 *
 * @param context The Context in which this PendingIntent should start
 * the service.
 * @param requestCode Private request code for the sender (currently
 * not used).
 * @param intent An Intent describing the service to be started.
 * @param flags May be {@link #FLAG_ONE_SHOT}, {@link #FLAG_NO_CREATE},
 * {@link #FLAG_CANCEL_CURRENT}, {@link #FLAG_UPDATE_CURRENT},
 * or any of the flags as supported by
 * {@link Intent#fillIn Intent.fillIn()} to control which unspecified parts
 * of the intent that can be supplied when the actual send happens.
 *
 * @return Returns an existing or new PendingIntent matching the given
 * parameters.  May return null only if {@link #FLAG_NO_CREATE} has been
 * supplied.
 */
","/**
 * Retrieve a PendingIntent that will start a service, like calling
 * {@link Context#startService Context.startService()}.  The start
 * arguments given to the service will come from the extras of the Intent.
 *
 * @param context The Context in which this PendingIntent should start
 * the service.
 * @param requestCode Private request code for the sender (currently
 * not used).
 * @param intent An Intent describing the service to be started.
 * @param flags May be {@link #FLAG_ONE_SHOT}, {@link #FLAG_NO_CREATE},
 * {@link #FLAG_CANCEL_CURRENT}, {@link #FLAG_UPDATE_CURRENT},
 * or any of the flags as supported by
 * {@link Intent#fillIn Intent.fillIn()} to control which unspecified parts
 * of the intent that can be supplied when the actual send happens.
 *
 * @return Returns an existing or new PendingIntent matching the given
 * parameters.  May return null only if {@link #FLAG_NO_CREATE} has been
 * supplied.
 */
",-1,,,-1,-1,-1,-1,-1,"4,5",1,0,0,There is no change in the implementation between early and late versions based on the given Abstract Syntax Tree (AST) nodes and other information. ,No compatibility issue exists as there is no change in the implementation.
67,<android.os.VibrationAttributes: int hashCode()>,30,31,<android.os.VibrationAttributes: int hashCode()>,<android.os.VibrationAttributes: int hashCode()>,0,"MethodDeclaration(method_body, [Statement({, []), MethodCall(return Objects.hash(mUsage, mFlags), [VariableReference(return Objects, []), Expression(mUsage, []), Expression(mFlags, [])]), Statement(}, [])])  Statement({, [])  MethodCall(return Objects.hash(mUsage, mFlags), [VariableReference(return Objects, []), Expression(mUsage, []), Expression(mFlags, [])])    VariableReference(return Objects, [])    Expression(mUsage, [])    Expression(mFlags, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), MethodCall(return Objects.hash(mUsage, mOriginalAudioUsage, mFlags), [VariableReference(return Objects, []), Expression(mUsage, []), Expression(mOriginalAudioUsage, []), Expression(mFlags, [])]), Statement(}, [])])  Statement({, [])  MethodCall(return Objects.hash(mUsage, mOriginalAudioUsage, mFlags), [VariableReference(return Objects, []), Expression(mUsage, []), Expression(mOriginalAudioUsage, []), Expression(mFlags, [])])    VariableReference(return Objects, [])    Expression(mUsage, [])    Expression(mOriginalAudioUsage, [])    Expression(mFlags, [])  Statement(}, [])",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,"1,4,5",1,1,1,"The return statement has changed by adding a new variable `mOriginalAudioUsage` into the Objects.hash() method call, so the code change type is 1.","The change in the return statement introduces a new variable to the hash calculation, potentially causing the API to return a different hash code. This could lead to different behavior in the API, thus the CI type is 1."
192,<android.widget.TextView: int getCompoundPaddingRight()>,22,23,<android.widget.TextView: int getCompoundPaddingRight()>,<android.widget.TextView: int getCompoundPaddingRight()>,0,"MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(final Drawables dr, []), Expression(mDrawables, [])]), AssignmentExpression(=, [VariableReference(if (dr, []), Expression(, [])]), Statement(return mPaddingRight, []), Statement(} else {, []), Statement(return mPaddingRight + dr.mDrawablePadding + dr.mDrawableSizeRight, []), Statement(}, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(final Drawables dr, []), Expression(mDrawables, [])])    VariableReference(final Drawables dr, [])    Expression(mDrawables, [])  AssignmentExpression(=, [VariableReference(if (dr, []), Expression(, [])])    VariableReference(if (dr, [])    Expression(, [])  Statement(return mPaddingRight, [])  Statement(} else {, [])  Statement(return mPaddingRight + dr.mDrawablePadding + dr.mDrawableSizeRight, [])  Statement(}, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(final Drawables dr, []), Expression(mDrawables, [])]), AssignmentExpression(=, [VariableReference(if (dr, []), Expression(, [])]), Statement(return mPaddingRight, []), Statement(} else {, []), Statement(return mPaddingRight + dr.mDrawablePadding + dr.mDrawableSizeRight, []), Statement(}, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(final Drawables dr, []), Expression(mDrawables, [])])    VariableReference(final Drawables dr, [])    Expression(mDrawables, [])  AssignmentExpression(=, [VariableReference(if (dr, []), Expression(, [])])    VariableReference(if (dr, [])    Expression(, [])  Statement(return mPaddingRight, [])  Statement(} else {, [])  Statement(return mPaddingRight + dr.mDrawablePadding + dr.mDrawableSizeRight, [])  Statement(}, [])  Statement(}, [])",1,"/**
 * Returns the right padding of the view, plus space for the right
 * Drawable if any.
 */
","/**
 * Returns the right padding of the view, plus space for the right
 * Drawable if any.
 */
",-1,,,-1,-1,-1,-1,-1,4,0,0,0,There are no changes between the early and late versions of the method. Both implementations are identical.,"Since there are no changes in the method implementation between the two versions, no compatibility issue exists."
980,<android.os.PowerManager: boolean isPowerSaveMode()>,23,24,<android.os.PowerManager: boolean isPowerSaveMode()>,<android.os.PowerManager: boolean isPowerSaveMode()>,0,"MethodDeclaration(method_body, [Statement({, []), Statement(try {, []), MethodCall(return mService.isPowerSaveMode(), [VariableReference(return mService, []), Expression(, [])]), Statement(} catch (RemoteException e) {, []), Statement(return false, []), Statement(}, []), Statement(}, [])])  Statement({, [])  Statement(try {, [])  MethodCall(return mService.isPowerSaveMode(), [VariableReference(return mService, []), Expression(, [])])    VariableReference(return mService, [])    Expression(, [])  Statement(} catch (RemoteException e) {, [])  Statement(return false, [])  Statement(}, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(try {, []), MethodCall(return mService.isPowerSaveMode(), [VariableReference(return mService, []), Expression(, [])]), Statement(} catch (RemoteException e) {, []), MethodCall(throw e.rethrowFromSystemServer(), [VariableReference(throw e, []), Expression(, [])]), Statement(}, []), Statement(}, [])])  Statement({, [])  Statement(try {, [])  MethodCall(return mService.isPowerSaveMode(), [VariableReference(return mService, []), Expression(, [])])    VariableReference(return mService, [])    Expression(, [])  Statement(} catch (RemoteException e) {, [])  MethodCall(throw e.rethrowFromSystemServer(), [VariableReference(throw e, []), Expression(, [])])    VariableReference(throw e, [])    Expression(, [])  Statement(}, [])  Statement(}, [])",1,"/**
 * Returns true if the device is currently in power save mode.  When in this mode,
 * applications should reduce their functionality in order to conserve battery as
 * much as possible.  You can monitor for changes to this state with
 * {@link #ACTION_POWER_SAVE_MODE_CHANGED}.
 *
 * @return Returns true if currently in low power mode, else false.
 */
","/**
 * Returns true if the device is currently in power save mode.  When in this mode,
 * applications should reduce their functionality in order to conserve battery as
 * much as possible.  You can monitor for changes to this state with
 * {@link #ACTION_POWER_SAVE_MODE_CHANGED}.
 *
 * @return Returns true if currently in low power mode, else false.
 */
",-1,,,-1,-1,-1,-1,-1,2,2,"1,2","1,2",A return statement (return false) has been replaced by an exception handling statement (throw e.rethrowFromSystemServer()). The code change type is both 1 and 2.,"The modification results in the API potentially returning a different value when an exception is thrown (previously it returned false, now it throws an exception). This introduces a potential difference in return values and exception handling, leading to both types of Compatibility Issues (1,2)."
269,"<android.hardware.usb.UsbDeviceConnection: int controlTransfer(int,int,int,int,byte[],int,int)>",17,18,"<android.hardware.usb.UsbDeviceConnection: int controlTransfer(int,int,int,int,byte[],int,int)>","<android.hardware.usb.UsbDeviceConnection: int controlTransfer(int,int,int,int,byte[],int,int)>",0,"MethodDeclaration(method_body, [Statement({, []), Statement(return native_control_request(requestType, request, value, index, buffer, length, timeout), []), Statement(}, [])])  Statement({, [])  Statement(return native_control_request(requestType, request, value, index, buffer, length, timeout), [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(return controlTransfer(requestType, request, value, index, buffer, 0, length, timeout), []), Statement(}, [])])  Statement({, [])  Statement(return controlTransfer(requestType, request, value, index, buffer, 0, length, timeout), [])  Statement(}, [])",1,"/**
 * Performs a control transaction on endpoint zero for this device.
 * The direction of the transfer is determined by the request type.
 * If requestType & {@link UsbConstants#USB_ENDPOINT_DIR_MASK} is
 * {@link UsbConstants#USB_DIR_OUT}, then the transfer is a write,
 * and if it is {@link UsbConstants#USB_DIR_IN}, then the transfer
 * is a read.
 *
 * @param requestType request type for this transaction
 * @param request request ID for this transaction
 * @param value value field for this transaction
 * @param index index field for this transaction
 * @param buffer buffer for data portion of transaction,
 * or null if no data needs to be sent or received
 * @param length the length of the data to send or receive
 * @param timeout in milliseconds
 * @return length of data transferred (or zero) for success,
 * or negative value for failure
 */
","/**
 * Performs a control transaction on endpoint zero for this device.
 * The direction of the transfer is determined by the request type.
 * If requestType & {@link UsbConstants#USB_ENDPOINT_DIR_MASK} is
 * {@link UsbConstants#USB_DIR_OUT}, then the transfer is a write,
 * and if it is {@link UsbConstants#USB_DIR_IN}, then the transfer
 * is a read.
 * <p>
 * This method transfers data starting from index 0 in the buffer.
 * To specify a different offset, use
 * {@link #controlTransfer(int, int, int, int, byte[], int, int, int)}.
 * </p>
 *
 * @param requestType request type for this transaction
 * @param request request ID for this transaction
 * @param value value field for this transaction
 * @param index index field for this transaction
 * @param buffer buffer for data portion of transaction,
 * or null if no data needs to be sent or received
 * @param length the length of the data to send or receive
 * @param timeout in milliseconds
 * @return length of data transferred (or zero) for success,
 * or negative value for failure
 */
",-1,,,-1,-1,-1,-1,-1,"1,4",1,"1,5",1,"The return statement has changed from `native_control_request` to `controlTransfer`, indicating that the underlying method invoked changed, so the code change type is 1,5.","The change in the underlying method used can potentially lead to different return values. Therefore, the CI type is 1."
213,"<android.content.ContentResolver: void takePersistableUriPermission(Uri,int)>",27,28,"<android.content.ContentResolver: void takePersistableUriPermission(Uri,int)>","<android.content.ContentResolver: void takePersistableUriPermission(Uri,int)>",0,"MethodDeclaration(method_body, [Statement({, []), MethodCall(Preconditions.checkNotNull(uri, ""uri""), [VariableReference(Preconditions, []), Expression(uri, []), Expression(""uri"", [])]), Statement(try {, []), MethodCall(ActivityManager.getService().takePersistableUriPermission(ContentProvider.getUriWithoutUserId(uri), modeFlags, resolveUserId(uri)), [VariableReference(ActivityManager, []), Expression().takePersistableUriPermission(ContentProvider.getUriWithoutUserId(uri), []), Expression(modeFlags, []), Expression(resolveUserId(uri), [])]), Statement(} catch (RemoteException e) {, []), Statement(}, []), Statement(}, [])])  Statement({, [])  MethodCall(Preconditions.checkNotNull(uri, ""uri""), [VariableReference(Preconditions, []), Expression(uri, []), Expression(""uri"", [])])    VariableReference(Preconditions, [])    Expression(uri, [])    Expression(""uri"", [])  Statement(try {, [])  MethodCall(ActivityManager.getService().takePersistableUriPermission(ContentProvider.getUriWithoutUserId(uri), modeFlags, resolveUserId(uri)), [VariableReference(ActivityManager, []), Expression().takePersistableUriPermission(ContentProvider.getUriWithoutUserId(uri), []), Expression(modeFlags, []), Expression(resolveUserId(uri), [])])    VariableReference(ActivityManager, [])    Expression().takePersistableUriPermission(ContentProvider.getUriWithoutUserId(uri), [])    Expression(modeFlags, [])    Expression(resolveUserId(uri), [])  Statement(} catch (RemoteException e) {, [])  Statement(}, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), MethodCall(Preconditions.checkNotNull(uri, ""uri""), [VariableReference(Preconditions, []), Expression(uri, []), Expression(""uri"", [])]), Statement(try {, []), AssignmentExpression(=, [VariableReference(ActivityManager.getService().takePersistableUriPermission(ContentProvider.getUriWithoutUserId(uri), modeFlags, /* toPackage, []), Expression(*/, [])]), Statement(null, resolveUserId(uri)), []), Statement(} catch (RemoteException e) {, []), MethodCall(throw e.rethrowFromSystemServer(), [VariableReference(throw e, []), Expression(, [])]), Statement(}, []), Statement(}, [])])  Statement({, [])  MethodCall(Preconditions.checkNotNull(uri, ""uri""), [VariableReference(Preconditions, []), Expression(uri, []), Expression(""uri"", [])])    VariableReference(Preconditions, [])    Expression(uri, [])    Expression(""uri"", [])  Statement(try {, [])  AssignmentExpression(=, [VariableReference(ActivityManager.getService().takePersistableUriPermission(ContentProvider.getUriWithoutUserId(uri), modeFlags, /* toPackage, []), Expression(*/, [])])    VariableReference(ActivityManager.getService().takePersistableUriPermission(ContentProvider.getUriWithoutUserId(uri), modeFlags, /* toPackage, [])    Expression(*/, [])  Statement(null, resolveUserId(uri)), [])  Statement(} catch (RemoteException e) {, [])  MethodCall(throw e.rethrowFromSystemServer(), [VariableReference(throw e, []), Expression(, [])])    VariableReference(throw e, [])    Expression(, [])  Statement(}, [])  Statement(}, [])",1,"/**
 * Take a persistable URI permission grant that has been offered. Once
 * taken, the permission grant will be remembered across device reboots.
 * Only URI permissions granted with
 * {@link Intent#FLAG_GRANT_PERSISTABLE_URI_PERMISSION} can be persisted. If
 * the grant has already been persisted, taking it again will touch
 * {@link UriPermission#getPersistedTime()}.
 *
 * @see #getPersistedUriPermissions()
 */
","/**
 * Take a persistable URI permission grant that has been offered. Once
 * taken, the permission grant will be remembered across device reboots.
 * Only URI permissions granted with
 * {@link Intent#FLAG_GRANT_PERSISTABLE_URI_PERMISSION} can be persisted. If
 * the grant has already been persisted, taking it again will touch
 * {@link UriPermission#getPersistedTime()}.
 *
 * @see #getPersistedUriPermissions()
 */
",-1,,,-1,-1,-1,-1,-1,"2,4,5",2,"1,2,4","1,2","In the late version, the `takePersistableUriPermission` method uses an assignment expression instead of a method call for `takePersistableUriPermission` and introduces the try-catch with `throw e.rethrowFromSystemServer()`. These changes can potentially affect the return type/values and exception handling. Therefore, the change type is 1,2,4.","The changes potentially cause different behaviors in terms of the exceptions thrown (`throw e.rethrowFromSystemServer()` replaces a log message) and possibly the return values due to the change in how the `takePersistableUriPermission` is called, hence causing Compatibility Issues of type 1 and 2."
218,<android.widget.Switch: Mode getThumbTintMode()>,28,29,<android.widget.Switch: Mode getThumbTintMode()>,<android.widget.Switch: Mode getThumbTintMode()>,0,"MethodDeclaration(method_body, [Statement({, []), Statement(return mThumbTintMode, []), Statement(}, [])])  Statement({, [])  Statement(return mThumbTintMode, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(BlendMode mode, []), Expression(getThumbTintBlendMode(), [])]), AssignmentExpression(=, [VariableReference(return mode !, []), Expression(null ? BlendMode.blendModeToPorterDuffMode(mode) : null, [])]), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(BlendMode mode, []), Expression(getThumbTintBlendMode(), [])])    VariableReference(BlendMode mode, [])    Expression(getThumbTintBlendMode(), [])  AssignmentExpression(=, [VariableReference(return mode !, []), Expression(null ? BlendMode.blendModeToPorterDuffMode(mode) : null, [])])    VariableReference(return mode !, [])    Expression(null ? BlendMode.blendModeToPorterDuffMode(mode) : null, [])  Statement(}, [])",1,"/**
 * @return the blending mode used to apply the tint to the thumb
 * drawable
 * @attr ref android.R.styleable#Switch_thumbTintMode
 * @see #setThumbTintMode(PorterDuff.Mode)
 */
","/**
 * @return the blending mode used to apply the tint to the thumb
 * drawable
 * @attr ref android.R.styleable#Switch_thumbTintMode
 * @see #setThumbTintMode(PorterDuff.Mode)
 */
",-1,[@Nullable],"[@InspectableProperty, @Nullable]",-1,-1,-1,-1,-1,"1,4",1,"1,4",1,"The return statement in the early version is `return mThumbTintMode;` whereas, in the late version, the return statement is an assignment-based conditional expression, potentially transforming the returned value: `return mode != null ? BlendMode.blendModeToPorterDuffMode(mode) : null;`. This means that the logic for determining the returned value has changed. This comprises both a return statement change and other statement changes (assignment statements).","The change in the return statement will potentially result in different return values between the early and late versions of the API. Thus, a compatibility issue exists due to different potential return values, so the CI type is 1."
533,"<android.speech.tts.PlaybackSynthesisCallback: int start(int,int,int)>",23,24,"<android.speech.tts.PlaybackSynthesisCallback: int start(int,int,int)>","<android.speech.tts.PlaybackSynthesisCallback: int start(int,int,int)>",0,"MethodDeclaration(method_body, [Statement({, []), Statement(if (DBG), []), MethodCall(Log.d(TAG, ""start("" + sampleRateInHz + "", "" + audioFormat + "", "" + channelCount + "")""), [VariableReference(Log, []), Expression(TAG, []), Expression(""start("" + sampleRateInHz + "", []), Expression("" + audioFormat + "", []), Expression("" + channelCount + "")"", [])]), AssignmentExpression(=, [VariableReference(int channelConfig, []), Expression(BlockingAudioTrack.getChannelConfig(channelCount), [])]), Statement(synchronized (mStateLock) {, []), AssignmentExpression(=, [VariableReference(if (channelConfig, []), Expression(, [])]), MethodCall(Log.e(TAG, ""Unsupported number of channels :"" + channelCount), [VariableReference(Log, []), Expression(TAG, []), Expression(""Unsupported number of channels :"" + channelCount, [])]), AssignmentExpression(=, [VariableReference(mStatusCode, []), Expression(TextToSpeech.ERROR_OUTPUT, [])]), Statement(return TextToSpeech.ERROR, []), Statement(}, []), AssignmentExpression(=, [VariableReference(if (mStatusCode, []), Expression(, [])]), Statement(if (DBG), []), MethodCall(Log.d(TAG, ""stop() called before start(), returning.""), [VariableReference(Log, []), Expression(TAG, []), Expression(""stop() called before start(), []), Expression(returning."", [])]), Statement(return errorCodeOnStop(), []), Statement(}, []), AssignmentExpression(=, [VariableReference(if (mStatusCode !, []), Expression(TextToSpeech.SUCCESS) {, [])]), Statement(if (DBG), []), MethodCall(Log.d(TAG, ""Error was raised""), [VariableReference(Log, []), Expression(TAG, []), Expression(""Error was raised"", [])]), Statement(return TextToSpeech.ERROR, []), Statement(}, []), AssignmentExpression(=, [VariableReference(if (mItem !, []), Expression(null) {, [])]), MethodCall(Log.e(TAG, ""Start called twice""), [VariableReference(Log, []), Expression(TAG, []), Expression(""Start called twice"", [])]), Statement(return TextToSpeech.ERROR, []), Statement(}, []), AssignmentExpression(=, [VariableReference(SynthesisPlaybackQueueItem item, []), Expression(new SynthesisPlaybackQueueItem(mAudioParams, sampleRateInHz, audioFormat, channelCount, mDispatcher, mCallerIdentity, mLogger), [])]), MethodCall(mAudioTrackHandler.enqueue(item), [VariableReference(mAudioTrackHandler, []), Expression(item, [])]), AssignmentExpression(=, [VariableReference(mItem, []), Expression(item, [])]), Statement(}, []), Statement(return TextToSpeech.SUCCESS, []), Statement(}, [])])  Statement({, [])  Statement(if (DBG), [])  MethodCall(Log.d(TAG, ""start("" + sampleRateInHz + "", "" + audioFormat + "", "" + channelCount + "")""), [VariableReference(Log, []), Expression(TAG, []), Expression(""start("" + sampleRateInHz + "", []), Expression("" + audioFormat + "", []), Expression("" + channelCount + "")"", [])])    VariableReference(Log, [])    Expression(TAG, [])    Expression(""start("" + sampleRateInHz + "", [])    Expression("" + audioFormat + "", [])    Expression("" + channelCount + "")"", [])  AssignmentExpression(=, [VariableReference(int channelConfig, []), Expression(BlockingAudioTrack.getChannelConfig(channelCount), [])])    VariableReference(int channelConfig, [])    Expression(BlockingAudioTrack.getChannelConfig(channelCount), [])  Statement(synchronized (mStateLock) {, [])  AssignmentExpression(=, [VariableReference(if (channelConfig, []), Expression(, [])])    VariableReference(if (channelConfig, [])    Expression(, [])  MethodCall(Log.e(TAG, ""Unsupported number of channels :"" + channelCount), [VariableReference(Log, []), Expression(TAG, []), Expression(""Unsupported number of channels :"" + channelCount, [])])    VariableReference(Log, [])    Expression(TAG, [])    Expression(""Unsupported number of channels :"" + channelCount, [])  AssignmentExpression(=, [VariableReference(mStatusCode, []), Expression(TextToSpeech.ERROR_OUTPUT, [])])    VariableReference(mStatusCode, [])    Expression(TextToSpeech.ERROR_OUTPUT, [])  Statement(return TextToSpeech.ERROR, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(if (mStatusCode, []), Expression(, [])])    VariableReference(if (mStatusCode, [])    Expression(, [])  Statement(if (DBG), [])  MethodCall(Log.d(TAG, ""stop() called before start(), returning.""), [VariableReference(Log, []), Expression(TAG, []), Expression(""stop() called before start(), []), Expression(returning."", [])])    VariableReference(Log, [])    Expression(TAG, [])    Expression(""stop() called before start(), [])    Expression(returning."", [])  Statement(return errorCodeOnStop(), [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(if (mStatusCode !, []), Expression(TextToSpeech.SUCCESS) {, [])])    VariableReference(if (mStatusCode !, [])    Expression(TextToSpeech.SUCCESS) {, [])  Statement(if (DBG), [])  MethodCall(Log.d(TAG, ""Error was raised""), [VariableReference(Log, []), Expression(TAG, []), Expression(""Error was raised"", [])])    VariableReference(Log, [])    Expression(TAG, [])    Expression(""Error was raised"", [])  Statement(return TextToSpeech.ERROR, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(if (mItem !, []), Expression(null) {, [])])    VariableReference(if (mItem !, [])    Expression(null) {, [])  MethodCall(Log.e(TAG, ""Start called twice""), [VariableReference(Log, []), Expression(TAG, []), Expression(""Start called twice"", [])])    VariableReference(Log, [])    Expression(TAG, [])    Expression(""Start called twice"", [])  Statement(return TextToSpeech.ERROR, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(SynthesisPlaybackQueueItem item, []), Expression(new SynthesisPlaybackQueueItem(mAudioParams, sampleRateInHz, audioFormat, channelCount, mDispatcher, mCallerIdentity, mLogger), [])])    VariableReference(SynthesisPlaybackQueueItem item, [])    Expression(new SynthesisPlaybackQueueItem(mAudioParams, sampleRateInHz, audioFormat, channelCount, mDispatcher, mCallerIdentity, mLogger), [])  MethodCall(mAudioTrackHandler.enqueue(item), [VariableReference(mAudioTrackHandler, []), Expression(item, [])])    VariableReference(mAudioTrackHandler, [])    Expression(item, [])  AssignmentExpression(=, [VariableReference(mItem, []), Expression(item, [])])    VariableReference(mItem, [])    Expression(item, [])  Statement(}, [])  Statement(return TextToSpeech.SUCCESS, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(if (DBG), []), MethodCall(Log.d(TAG, ""start("" + sampleRateInHz + "", "" + audioFormat + "", "" + channelCount + "")""), [VariableReference(Log, []), Expression(TAG, []), Expression(""start("" + sampleRateInHz + "", []), Expression("" + audioFormat + "", []), Expression("" + channelCount + "")"", [])]), AssignmentExpression(=, [VariableReference(if (audioFormat !, []), Expression(AudioFormat.ENCODING_PCM_8BIT && audioFormat !, [])]), MethodCall(Log.w(TAG, ""Audio format encoding "" + audioFormat + "" not supported. Please use one "" + ""of AudioFormat.ENCODING_PCM_8BIT, AudioFormat.ENCODING_PCM_16BIT or "" + ""AudioFormat.ENCODING_PCM_FLOAT""), [VariableReference(Log, []), Expression(TAG, []), Expression(""Audio format encoding "" + audioFormat + "" not supported. Please use one "" + ""of AudioFormat.ENCODING_PCM_8BIT, []), Expression(AudioFormat.ENCODING_PCM_16BIT or "" + ""AudioFormat.ENCODING_PCM_FLOAT"", [])]), Statement(}, []), MethodCall(mDispatcher.dispatchOnBeginSynthesis(sampleRateInHz, audioFormat, channelCount), [VariableReference(mDispatcher, []), Expression(sampleRateInHz, []), Expression(audioFormat, []), Expression(channelCount, [])]), AssignmentExpression(=, [VariableReference(int channelConfig, []), Expression(BlockingAudioTrack.getChannelConfig(channelCount), [])]), Statement(synchronized (mStateLock) {, []), AssignmentExpression(=, [VariableReference(if (channelConfig, []), Expression(, [])]), MethodCall(Log.e(TAG, ""Unsupported number of channels :"" + channelCount), [VariableReference(Log, []), Expression(TAG, []), Expression(""Unsupported number of channels :"" + channelCount, [])]), AssignmentExpression(=, [VariableReference(mStatusCode, []), Expression(TextToSpeech.ERROR_OUTPUT, [])]), Statement(return TextToSpeech.ERROR, []), Statement(}, []), AssignmentExpression(=, [VariableReference(if (mStatusCode, []), Expression(, [])]), Statement(if (DBG), []), MethodCall(Log.d(TAG, ""stop() called before start(), returning.""), [VariableReference(Log, []), Expression(TAG, []), Expression(""stop() called before start(), []), Expression(returning."", [])]), Statement(return errorCodeOnStop(), []), Statement(}, []), AssignmentExpression(=, [VariableReference(if (mStatusCode !, []), Expression(TextToSpeech.SUCCESS) {, [])]), Statement(if (DBG), []), MethodCall(Log.d(TAG, ""Error was raised""), [VariableReference(Log, []), Expression(TAG, []), Expression(""Error was raised"", [])]), Statement(return TextToSpeech.ERROR, []), Statement(}, []), AssignmentExpression(=, [VariableReference(if (mItem !, []), Expression(null) {, [])]), MethodCall(Log.e(TAG, ""Start called twice""), [VariableReference(Log, []), Expression(TAG, []), Expression(""Start called twice"", [])]), Statement(return TextToSpeech.ERROR, []), Statement(}, []), AssignmentExpression(=, [VariableReference(SynthesisPlaybackQueueItem item, []), Expression(new SynthesisPlaybackQueueItem(mAudioParams, sampleRateInHz, audioFormat, channelCount, mDispatcher, mCallerIdentity, mLogger), [])]), MethodCall(mAudioTrackHandler.enqueue(item), [VariableReference(mAudioTrackHandler, []), Expression(item, [])]), AssignmentExpression(=, [VariableReference(mItem, []), Expression(item, [])]), Statement(}, []), Statement(return TextToSpeech.SUCCESS, []), Statement(}, [])])  Statement({, [])  Statement(if (DBG), [])  MethodCall(Log.d(TAG, ""start("" + sampleRateInHz + "", "" + audioFormat + "", "" + channelCount + "")""), [VariableReference(Log, []), Expression(TAG, []), Expression(""start("" + sampleRateInHz + "", []), Expression("" + audioFormat + "", []), Expression("" + channelCount + "")"", [])])    VariableReference(Log, [])    Expression(TAG, [])    Expression(""start("" + sampleRateInHz + "", [])    Expression("" + audioFormat + "", [])    Expression("" + channelCount + "")"", [])  AssignmentExpression(=, [VariableReference(if (audioFormat !, []), Expression(AudioFormat.ENCODING_PCM_8BIT && audioFormat !, [])])    VariableReference(if (audioFormat !, [])    Expression(AudioFormat.ENCODING_PCM_8BIT && audioFormat !, [])  MethodCall(Log.w(TAG, ""Audio format encoding "" + audioFormat + "" not supported. Please use one "" + ""of AudioFormat.ENCODING_PCM_8BIT, AudioFormat.ENCODING_PCM_16BIT or "" + ""AudioFormat.ENCODING_PCM_FLOAT""), [VariableReference(Log, []), Expression(TAG, []), Expression(""Audio format encoding "" + audioFormat + "" not supported. Please use one "" + ""of AudioFormat.ENCODING_PCM_8BIT, []), Expression(AudioFormat.ENCODING_PCM_16BIT or "" + ""AudioFormat.ENCODING_PCM_FLOAT"", [])])    VariableReference(Log, [])    Expression(TAG, [])    Expression(""Audio format encoding "" + audioFormat + "" not supported. Please use one "" + ""of AudioFormat.ENCODING_PCM_8BIT, [])    Expression(AudioFormat.ENCODING_PCM_16BIT or "" + ""AudioFormat.ENCODING_PCM_FLOAT"", [])  Statement(}, [])  MethodCall(mDispatcher.dispatchOnBeginSynthesis(sampleRateInHz, audioFormat, channelCount), [VariableReference(mDispatcher, []), Expression(sampleRateInHz, []), Expression(audioFormat, []), Expression(channelCount, [])])    VariableReference(mDispatcher, [])    Expression(sampleRateInHz, [])    Expression(audioFormat, [])    Expression(channelCount, [])  AssignmentExpression(=, [VariableReference(int channelConfig, []), Expression(BlockingAudioTrack.getChannelConfig(channelCount), [])])    VariableReference(int channelConfig, [])    Expression(BlockingAudioTrack.getChannelConfig(channelCount), [])  Statement(synchronized (mStateLock) {, [])  AssignmentExpression(=, [VariableReference(if (channelConfig, []), Expression(, [])])    VariableReference(if (channelConfig, [])    Expression(, [])  MethodCall(Log.e(TAG, ""Unsupported number of channels :"" + channelCount), [VariableReference(Log, []), Expression(TAG, []), Expression(""Unsupported number of channels :"" + channelCount, [])])    VariableReference(Log, [])    Expression(TAG, [])    Expression(""Unsupported number of channels :"" + channelCount, [])  AssignmentExpression(=, [VariableReference(mStatusCode, []), Expression(TextToSpeech.ERROR_OUTPUT, [])])    VariableReference(mStatusCode, [])    Expression(TextToSpeech.ERROR_OUTPUT, [])  Statement(return TextToSpeech.ERROR, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(if (mStatusCode, []), Expression(, [])])    VariableReference(if (mStatusCode, [])    Expression(, [])  Statement(if (DBG), [])  MethodCall(Log.d(TAG, ""stop() called before start(), returning.""), [VariableReference(Log, []), Expression(TAG, []), Expression(""stop() called before start(), []), Expression(returning."", [])])    VariableReference(Log, [])    Expression(TAG, [])    Expression(""stop() called before start(), [])    Expression(returning."", [])  Statement(return errorCodeOnStop(), [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(if (mStatusCode !, []), Expression(TextToSpeech.SUCCESS) {, [])])    VariableReference(if (mStatusCode !, [])    Expression(TextToSpeech.SUCCESS) {, [])  Statement(if (DBG), [])  MethodCall(Log.d(TAG, ""Error was raised""), [VariableReference(Log, []), Expression(TAG, []), Expression(""Error was raised"", [])])    VariableReference(Log, [])    Expression(TAG, [])    Expression(""Error was raised"", [])  Statement(return TextToSpeech.ERROR, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(if (mItem !, []), Expression(null) {, [])])    VariableReference(if (mItem !, [])    Expression(null) {, [])  MethodCall(Log.e(TAG, ""Start called twice""), [VariableReference(Log, []), Expression(TAG, []), Expression(""Start called twice"", [])])    VariableReference(Log, [])    Expression(TAG, [])    Expression(""Start called twice"", [])  Statement(return TextToSpeech.ERROR, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(SynthesisPlaybackQueueItem item, []), Expression(new SynthesisPlaybackQueueItem(mAudioParams, sampleRateInHz, audioFormat, channelCount, mDispatcher, mCallerIdentity, mLogger), [])])    VariableReference(SynthesisPlaybackQueueItem item, [])    Expression(new SynthesisPlaybackQueueItem(mAudioParams, sampleRateInHz, audioFormat, channelCount, mDispatcher, mCallerIdentity, mLogger), [])  MethodCall(mAudioTrackHandler.enqueue(item), [VariableReference(mAudioTrackHandler, []), Expression(item, [])])    VariableReference(mAudioTrackHandler, [])    Expression(item, [])  AssignmentExpression(=, [VariableReference(mItem, []), Expression(item, [])])    VariableReference(mItem, [])    Expression(item, [])  Statement(}, [])  Statement(return TextToSpeech.SUCCESS, [])  Statement(}, [])",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,"3,4",1,"2,3,4","1,2","A new `if` statement was added to check the audio format and potentially log a warning (`Log.w(...)`). There was also additional `mDispatcher.dispatchOnBeginSynthesis(...)` method call introduced in the late version. These involve exception handling and control dependency changes. Thus, the code change types are 2, 3, and 4.","The newly introduced `if` statement and the `dispatchOnBeginSynthesis` call may change the return values or throw different exceptions at runtime. Therefore, the Compatibility Issue types are 1 and 2."
949,<android.accounts.AccountManager: AuthenticatorDescription[] getAuthenticatorTypes()>,20,21,<android.accounts.AccountManager: AuthenticatorDescription[] getAuthenticatorTypes()>,<android.accounts.AccountManager: AuthenticatorDescription[] getAuthenticatorTypes()>,0,"MethodDeclaration(method_body, [Statement({, []), Statement(try {, []), MethodCall(return mService.getAuthenticatorTypes(), [VariableReference(return mService, []), Expression(, [])]), Statement(} catch (RemoteException e) {, []), Statement(// will never happen, []), Statement(throw new RuntimeException(e), []), Statement(}, []), Statement(}, [])])  Statement({, [])  Statement(try {, [])  MethodCall(return mService.getAuthenticatorTypes(), [VariableReference(return mService, []), Expression(, [])])    VariableReference(return mService, [])    Expression(, [])  Statement(} catch (RemoteException e) {, [])  Statement(// will never happen, [])  Statement(throw new RuntimeException(e), [])  Statement(}, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(try {, []), MethodCall(return mService.getAuthenticatorTypes(UserHandle.getCallingUserId()), [VariableReference(return mService, []), Expression(UserHandle.getCallingUserId(), [])]), Statement(} catch (RemoteException e) {, []), Statement(// will never happen, []), Statement(throw new RuntimeException(e), []), Statement(}, []), Statement(}, [])])  Statement({, [])  Statement(try {, [])  MethodCall(return mService.getAuthenticatorTypes(UserHandle.getCallingUserId()), [VariableReference(return mService, []), Expression(UserHandle.getCallingUserId(), [])])    VariableReference(return mService, [])    Expression(UserHandle.getCallingUserId(), [])  Statement(} catch (RemoteException e) {, [])  Statement(// will never happen, [])  Statement(throw new RuntimeException(e), [])  Statement(}, [])  Statement(}, [])",1,"/**
 * Lists the currently registered authenticators.
 *
 * <p>It is safe to call this method from the main thread.
 *
 * <p>No permission is required to call this method.
 *
 * @return An array of {@link AuthenticatorDescription} for every
 * authenticator known to the AccountManager service.  Empty (never
 * null) if no authenticators are known.
 */
","/**
 * Lists the currently registered authenticators.
 *
 * <p>It is safe to call this method from the main thread.
 *
 * <p>No permission is required to call this method.
 *
 * @return An array of {@link AuthenticatorDescription} for every
 * authenticator known to the AccountManager service.  Empty (never
 * null) if no authenticators are known.
 */
",-1,,,-1,-1,-1,-1,-1,"1,4,5",0,"1,5",1,"The method call `mService.getAuthenticatorTypes()` has changed to `mService.getAuthenticatorTypes(UserHandle.getCallingUserId())`, which adds a parameter. This change type falls under 1 (Return statement changed) and 5 (Dependent API changed).","The introduction of the `UserHandle.getCallingUserId()` parameter in the return statement could lead to different return values depending on the user handle. Therefore, the CI type is 1."
17,"<android.view.GLES20Canvas: boolean quickReject(Path,EdgeType)>",15,16,"<android.view.GLES20Canvas: boolean quickReject(Path,EdgeType)>","<android.view.GLES20Canvas: boolean quickReject(Path,EdgeType)>",0,"MethodDeclaration(method_body, [Statement({, []), Statement(throw new UnsupportedOperationException(), []), Statement(}, [])])  Statement({, [])  Statement(throw new UnsupportedOperationException(), [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), MethodCall(path.computeBounds(mPathBounds, true), [VariableReference(path, []), Expression(mPathBounds, []), Expression(true, [])]), Statement(}, [])])  Statement({, [])  MethodCall(path.computeBounds(mPathBounds, true), [VariableReference(path, []), Expression(mPathBounds, []), Expression(true, [])])    VariableReference(path, [])    Expression(mPathBounds, [])    Expression(true, [])  Statement(}, [])",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,"1,2","1,2","1,3",1,"The method in the early version throws an UnsupportedOperationException, but in the late version, it calls path.computeBounds(mPathBounds, true) and no longer throws an exception. Therefore, the types of change are 1 (the different return handling) and 3 (control dependency changed due to removing the exception throw and adding a method call).",The change in the method implementation can lead to different behaviours because the early version throws an exception while the late version doesn't. This results in a CI type 1 due to potential different return values.
129,"<android.util.Log: int v(String,String)>",7,8,"<android.util.Log: int v(String,String)>","<android.util.Log: int v(String,String)>",0,"MethodDeclaration(method_body, [Statement({, []), Statement(return println(VERBOSE, tag, msg), []), Statement(}, [])])  Statement({, [])  Statement(return println(VERBOSE, tag, msg), [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(return println_native(LOG_ID_MAIN, VERBOSE, tag, msg), []), Statement(}, [])])  Statement({, [])  Statement(return println_native(LOG_ID_MAIN, VERBOSE, tag, msg), [])  Statement(}, [])",1,"/**
 * Send a {@link #VERBOSE} log message.
 * @param tag Used to identify the source of a log message.  It usually identifies
 * the class or activity where the log call occurs.
 * @param msg The message you would like logged.
 */
","/**
 * Send a {@link #VERBOSE} log message.
 * @param tag Used to identify the source of a log message.  It usually identifies
 * the class or activity where the log call occurs.
 * @param msg The message you would like logged.
 */
",-1,,,-1,-1,-1,-1,-1,"1,4",1,5,0,"The early version uses the method `println(VERBOSE, tag, msg)` while the late version uses `println_native(LOG_ID_MAIN, VERBOSE, tag, msg)`. This indicates that the dependent API has changed, so the change type is 5.","Despite the change in the dependent API, there is no evidence suggesting different return values or exception handling. Therefore, the CI type is 0."
424,<android.view.autofill.AutofillId: int hashCode()>,28,29,<android.view.autofill.AutofillId: int hashCode()>,<android.view.autofill.AutofillId: int hashCode()>,0,"MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(final int prime, []), Expression(31, [])]), AssignmentExpression(=, [VariableReference(int result, []), Expression(1, [])]), AssignmentExpression(=, [VariableReference(result, []), Expression(prime * result + mViewId, [])]), AssignmentExpression(=, [VariableReference(result, []), Expression(prime * result + mVirtualId, [])]), Statement(return result, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(final int prime, []), Expression(31, [])])    VariableReference(final int prime, [])    Expression(31, [])  AssignmentExpression(=, [VariableReference(int result, []), Expression(1, [])])    VariableReference(int result, [])    Expression(1, [])  AssignmentExpression(=, [VariableReference(result, []), Expression(prime * result + mViewId, [])])    VariableReference(result, [])    Expression(prime * result + mViewId, [])  AssignmentExpression(=, [VariableReference(result, []), Expression(prime * result + mVirtualId, [])])    VariableReference(result, [])    Expression(prime * result + mVirtualId, [])  Statement(return result, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(final int prime, []), Expression(31, [])]), AssignmentExpression(=, [VariableReference(int result, []), Expression(1, [])]), AssignmentExpression(=, [VariableReference(result, []), Expression(prime * result + mViewId, [])]), AssignmentExpression(=, [VariableReference(result, []), Expression(prime * result + mVirtualIntId, [])]), AssignmentExpression(=, [VariableReference(result, []), Expression(prime * result + (int) (mVirtualLongId ^ (mVirtualLongId >>> 32)), [])]), AssignmentExpression(=, [VariableReference(result, []), Expression(prime * result + mSessionId, [])]), Statement(return result, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(final int prime, []), Expression(31, [])])    VariableReference(final int prime, [])    Expression(31, [])  AssignmentExpression(=, [VariableReference(int result, []), Expression(1, [])])    VariableReference(int result, [])    Expression(1, [])  AssignmentExpression(=, [VariableReference(result, []), Expression(prime * result + mViewId, [])])    VariableReference(result, [])    Expression(prime * result + mViewId, [])  AssignmentExpression(=, [VariableReference(result, []), Expression(prime * result + mVirtualIntId, [])])    VariableReference(result, [])    Expression(prime * result + mVirtualIntId, [])  AssignmentExpression(=, [VariableReference(result, []), Expression(prime * result + (int) (mVirtualLongId ^ (mVirtualLongId >>> 32)), [])])    VariableReference(result, [])    Expression(prime * result + (int) (mVirtualLongId ^ (mVirtualLongId >>> 32)), [])  AssignmentExpression(=, [VariableReference(result, []), Expression(prime * result + mSessionId, [])])    VariableReference(result, [])    Expression(prime * result + mSessionId, [])  Statement(return result, [])  Statement(}, [])",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,"1,4",1,"1,4",1,"Additional assignment expressions and computations are introduced in the late implementation. Specifically, extra parameters `mVirtualIntId`, `mVirtualLongId`, and `mSessionId` are added in the hash code computation, so the code change type is 1,4.","The changes in the computations and the addition of new parameters will potentially result in different return values for the `hashCode()` method between the two versions, leading to a CI type of 1."
741,"<android.bluetooth.BluetoothHidDevice: boolean reportError(BluetoothDevice,byte)>",28,29,"<android.bluetooth.BluetoothHidDevice: boolean reportError(BluetoothDevice,byte)>","<android.bluetooth.BluetoothHidDevice: boolean reportError(BluetoothDevice,byte)>",0,"MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(boolean result, []), Expression(false, [])]), AssignmentExpression(=, [VariableReference(final IBluetoothHidDevice service, []), Expression(mService, [])]), AssignmentExpression(=, [VariableReference(if (service !, []), Expression(null) {, [])]), Statement(try {, []), AssignmentExpression(=, [VariableReference(result, []), Expression(service.reportError(device, error), [])]), Statement(} catch (RemoteException e) {, []), MethodCall(Log.e(TAG, e.toString()), [VariableReference(Log, []), Expression(TAG, []), Expression(e.toString(), [])]), Statement(}, []), Statement(} else {, []), MethodCall(Log.w(TAG, ""Proxy not attached to service""), [VariableReference(Log, []), Expression(TAG, []), Expression(""Proxy not attached to service"", [])]), Statement(}, []), Statement(return result, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(boolean result, []), Expression(false, [])])    VariableReference(boolean result, [])    Expression(false, [])  AssignmentExpression(=, [VariableReference(final IBluetoothHidDevice service, []), Expression(mService, [])])    VariableReference(final IBluetoothHidDevice service, [])    Expression(mService, [])  AssignmentExpression(=, [VariableReference(if (service !, []), Expression(null) {, [])])    VariableReference(if (service !, [])    Expression(null) {, [])  Statement(try {, [])  AssignmentExpression(=, [VariableReference(result, []), Expression(service.reportError(device, error), [])])    VariableReference(result, [])    Expression(service.reportError(device, error), [])  Statement(} catch (RemoteException e) {, [])  MethodCall(Log.e(TAG, e.toString()), [VariableReference(Log, []), Expression(TAG, []), Expression(e.toString(), [])])    VariableReference(Log, [])    Expression(TAG, [])    Expression(e.toString(), [])  Statement(}, [])  Statement(} else {, [])  MethodCall(Log.w(TAG, ""Proxy not attached to service""), [VariableReference(Log, []), Expression(TAG, []), Expression(""Proxy not attached to service"", [])])    VariableReference(Log, [])    Expression(TAG, [])    Expression(""Proxy not attached to service"", [])  Statement(}, [])  Statement(return result, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(boolean result, []), Expression(false, [])]), AssignmentExpression(=, [VariableReference(final IBluetoothHidDevice service, []), Expression(getService(), [])]), AssignmentExpression(=, [VariableReference(if (service !, []), Expression(null) {, [])]), Statement(try {, []), AssignmentExpression(=, [VariableReference(result, []), Expression(service.reportError(device, error), [])]), Statement(} catch (RemoteException e) {, []), MethodCall(Log.e(TAG, e.toString()), [VariableReference(Log, []), Expression(TAG, []), Expression(e.toString(), [])]), Statement(}, []), Statement(} else {, []), MethodCall(Log.w(TAG, ""Proxy not attached to service""), [VariableReference(Log, []), Expression(TAG, []), Expression(""Proxy not attached to service"", [])]), Statement(}, []), Statement(return result, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(boolean result, []), Expression(false, [])])    VariableReference(boolean result, [])    Expression(false, [])  AssignmentExpression(=, [VariableReference(final IBluetoothHidDevice service, []), Expression(getService(), [])])    VariableReference(final IBluetoothHidDevice service, [])    Expression(getService(), [])  AssignmentExpression(=, [VariableReference(if (service !, []), Expression(null) {, [])])    VariableReference(if (service !, [])    Expression(null) {, [])  Statement(try {, [])  AssignmentExpression(=, [VariableReference(result, []), Expression(service.reportError(device, error), [])])    VariableReference(result, [])    Expression(service.reportError(device, error), [])  Statement(} catch (RemoteException e) {, [])  MethodCall(Log.e(TAG, e.toString()), [VariableReference(Log, []), Expression(TAG, []), Expression(e.toString(), [])])    VariableReference(Log, [])    Expression(TAG, [])    Expression(e.toString(), [])  Statement(}, [])  Statement(} else {, [])  MethodCall(Log.w(TAG, ""Proxy not attached to service""), [VariableReference(Log, []), Expression(TAG, []), Expression(""Proxy not attached to service"", [])])    VariableReference(Log, [])    Expression(TAG, [])    Expression(""Proxy not attached to service"", [])  Statement(}, [])  Statement(return result, [])  Statement(}, [])",1,"/**
 * Sends error handshake message as reply for invalid SET_REPORT request from {@link
 * Callback#onSetReport(BluetoothDevice, byte, byte, byte[])}.
 *
 * @param error Error to be sent for SET_REPORT via HANDSHAKE.
 * @return true if the command is successfully sent; otherwise false.
 */
","/**
 * Sends error handshake message as reply for invalid SET_REPORT request from {@link
 * Callback#onSetReport(BluetoothDevice, byte, byte, byte[])}.
 *
 * @param error Error to be sent for SET_REPORT via HANDSHAKE.
 * @return true if the command is successfully sent; otherwise false.
 */
",-1,,,-1,-1,-1,-1,-1,4,0,5,0,"The method for obtaining the service has changed from `mService` to `getService()`, indicating a possible change in the dependent API. Therefore, the code change type is 5.","The change in the method for obtaining the service does not necessarily lead to a compatibility issue with return values or exception handling. Therefore, the CI type is 0."
350,"<android.database.sqlite.SQLiteDatabase: SQLiteDatabase openDatabase(String,CursorFactory,int,DatabaseErrorHandler)>",27,28,"<android.database.sqlite.SQLiteDatabase: SQLiteDatabase openDatabase(String,CursorFactory,int,DatabaseErrorHandler)>","<android.database.sqlite.SQLiteDatabase: SQLiteDatabase openDatabase(String,CursorFactory,int,DatabaseErrorHandler)>",0,"MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(SQLiteDatabase db, []), Expression(new SQLiteDatabase(path, flags, factory, errorHandler, -1, -1, -1), [])]), MethodCall(db.open(), [VariableReference(db, []), Expression(, [])]), Statement(return db, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(SQLiteDatabase db, []), Expression(new SQLiteDatabase(path, flags, factory, errorHandler, -1, -1, -1), [])])    VariableReference(SQLiteDatabase db, [])    Expression(new SQLiteDatabase(path, flags, factory, errorHandler, -1, -1, -1), [])  MethodCall(db.open(), [VariableReference(db, []), Expression(, [])])    VariableReference(db, [])    Expression(, [])  Statement(return db, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(SQLiteDatabase db, []), Expression(new SQLiteDatabase(path, flags, factory, errorHandler, -1, -1, -1, null, null), [])]), MethodCall(db.open(), [VariableReference(db, []), Expression(, [])]), Statement(return db, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(SQLiteDatabase db, []), Expression(new SQLiteDatabase(path, flags, factory, errorHandler, -1, -1, -1, null, null), [])])    VariableReference(SQLiteDatabase db, [])    Expression(new SQLiteDatabase(path, flags, factory, errorHandler, -1, -1, -1, null, null), [])  MethodCall(db.open(), [VariableReference(db, []), Expression(, [])])    VariableReference(db, [])    Expression(, [])  Statement(return db, [])  Statement(}, [])",1,"/**
 * Open the database according to the flags {@link #OPEN_READWRITE}
 * {@link #OPEN_READONLY} {@link #CREATE_IF_NECESSARY} and/or {@link #NO_LOCALIZED_COLLATORS}.
 *
 * <p>Sets the locale of the database to the  the system's current locale.
 * Call {@link #setLocale} if you would like something else.</p>
 *
 * <p>Accepts input param: a concrete instance of {@link DatabaseErrorHandler} to be
 * used to handle corruption when sqlite reports database corruption.</p>
 *
 * @param path to database file to open and/or create
 * @param factory an optional factory class that is called to instantiate a
 * cursor when query is called, or null for default
 * @param flags to control database access mode
 * @param errorHandler the {@link DatabaseErrorHandler} obj to be used to handle corruption
 * when sqlite reports database corruption
 * @return the newly opened database
 * @throws SQLiteException if the database cannot be opened
 */
","/**
 * Open the database according to the flags {@link #OPEN_READWRITE}
 * {@link #OPEN_READONLY} {@link #CREATE_IF_NECESSARY} and/or {@link #NO_LOCALIZED_COLLATORS}.
 *
 * <p>Sets the locale of the database to the  the system's current locale.
 * Call {@link #setLocale} if you would like something else.</p>
 *
 * <p>Accepts input param: a concrete instance of {@link DatabaseErrorHandler} to be
 * used to handle corruption when sqlite reports database corruption.</p>
 *
 * @param path to database file to open and/or create
 * @param factory an optional factory class that is called to instantiate a
 * cursor when query is called, or null for default
 * @param flags to control database access mode
 * @param errorHandler the {@link DatabaseErrorHandler} obj to be used to handle corruption
 * when sqlite reports database corruption
 * @return the newly opened database
 * @throws SQLiteException if the database cannot be opened
 */
",-1,,,-1,-1,-1,-1,-1,5,0,4,0,"In the late implementation, the instantiation of `SQLiteDatabase` has added two `null` parameters. This counts as an other statement change.","The addition of `null` parameters to the `SQLiteDatabase` instantiation does not, in itself, likely cause a difference in return values or exception handling directly observable to API users, given the rest of the method logic remains unchanged. Therefore, the CI type is 0."
571,<android.animation.PropertyValuesHolder.IntPropertyValuesHolder: IntPropertyValuesHolder clone()>,20,21,<android.animation.PropertyValuesHolder.IntPropertyValuesHolder: IntPropertyValuesHolder clone()>,<android.animation.PropertyValuesHolder.IntPropertyValuesHolder: IntPropertyValuesHolder clone()>,0,"MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(IntPropertyValuesHolder newPVH, []), Expression((IntPropertyValuesHolder) super.clone(), [])]), AssignmentExpression(=, [VariableReference(newPVH.mIntKeyframeSet, []), Expression((IntKeyframeSet) newPVH.mKeyframeSet, [])]), Statement(return newPVH, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(IntPropertyValuesHolder newPVH, []), Expression((IntPropertyValuesHolder) super.clone(), [])])    VariableReference(IntPropertyValuesHolder newPVH, [])    Expression((IntPropertyValuesHolder) super.clone(), [])  AssignmentExpression(=, [VariableReference(newPVH.mIntKeyframeSet, []), Expression((IntKeyframeSet) newPVH.mKeyframeSet, [])])    VariableReference(newPVH.mIntKeyframeSet, [])    Expression((IntKeyframeSet) newPVH.mKeyframeSet, [])  Statement(return newPVH, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(IntPropertyValuesHolder newPVH, []), Expression((IntPropertyValuesHolder) super.clone(), [])]), AssignmentExpression(=, [VariableReference(newPVH.mIntKeyframes, []), Expression((Keyframes.IntKeyframes) newPVH.mKeyframes, [])]), Statement(return newPVH, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(IntPropertyValuesHolder newPVH, []), Expression((IntPropertyValuesHolder) super.clone(), [])])    VariableReference(IntPropertyValuesHolder newPVH, [])    Expression((IntPropertyValuesHolder) super.clone(), [])  AssignmentExpression(=, [VariableReference(newPVH.mIntKeyframes, []), Expression((Keyframes.IntKeyframes) newPVH.mKeyframes, [])])    VariableReference(newPVH.mIntKeyframes, [])    Expression((Keyframes.IntKeyframes) newPVH.mKeyframes, [])  Statement(return newPVH, [])  Statement(}, [])",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,4,0,4,0,"The assignment expression has changed from `newPVH.mIntKeyframeSet = (IntKeyframeSet) newPVH.mKeyframeSet` to `newPVH.mIntKeyframes = (Keyframes.IntKeyframes) newPVH.mKeyframes`. This change does not affect the return value or exception handling behavior, so the change type is 4. ","The code change does not lead to a potential difference in return values or exception handling; therefore, there is no compatibility issue. The CI type is 0."
206,<android.app.SharedPreferencesImpl.EditorImpl: Editor remove(String)>,25,26,<android.app.SharedPreferencesImpl.EditorImpl: Editor remove(String)>,<android.app.SharedPreferencesImpl.EditorImpl: Editor remove(String)>,0,"MethodDeclaration(method_body, [Statement({, []), Statement(synchronized (this) {, []), MethodCall(mModified.put(key, this), [VariableReference(mModified, []), Expression(key, []), Expression(this, [])]), Statement(return this, []), Statement(}, []), Statement(}, [])])  Statement({, [])  Statement(synchronized (this) {, [])  MethodCall(mModified.put(key, this), [VariableReference(mModified, []), Expression(key, []), Expression(this, [])])    VariableReference(mModified, [])    Expression(key, [])    Expression(this, [])  Statement(return this, [])  Statement(}, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(synchronized (mLock) {, []), MethodCall(mModified.put(key, this), [VariableReference(mModified, []), Expression(key, []), Expression(this, [])]), Statement(return this, []), Statement(}, []), Statement(}, [])])  Statement({, [])  Statement(synchronized (mLock) {, [])  MethodCall(mModified.put(key, this), [VariableReference(mModified, []), Expression(key, []), Expression(this, [])])    VariableReference(mModified, [])    Expression(key, [])    Expression(this, [])  Statement(return this, [])  Statement(}, [])  Statement(}, [])",1,,,-1,,,-1,-1,-1,-1,-1,4,0,3,0,"The synchronized block has changed from synchronizing on 'this' to synchronizing on 'mLock', so the change type is 3.","Changing the object the method synchronizes on does not directly lead to any CI as it does not affect the return value or exception handling of the method. Hence, no compatibility issue exists, so the CI type is 0."
126,<android.animation.ValueAnimator: void resume()>,23,24,<android.animation.ValueAnimator: void resume()>,<android.animation.ValueAnimator: void resume()>,0,"MethodDeclaration(method_body, [Statement({, []), Statement(if (mPaused) {, []), AssignmentExpression(=, [VariableReference(mResumed, []), Expression(true, [])]), Statement(}, []), MethodCall(super.resume(), [VariableReference(super, []), Expression(, [])]), Statement(}, [])])  Statement({, [])  Statement(if (mPaused) {, [])  AssignmentExpression(=, [VariableReference(mResumed, []), Expression(true, [])])    VariableReference(mResumed, [])    Expression(true, [])  Statement(}, [])  MethodCall(super.resume(), [VariableReference(super, []), Expression(, [])])    VariableReference(super, [])    Expression(, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(if (Looper.myLooper(), []), Expression(, [])]), Statement(throw new AndroidRuntimeException(""Animators may only be resumed from the same "" + ""thread that the animator was started on""), []), Statement(}, []), Statement(if (mPaused && !mResumed) {, []), AssignmentExpression(=, [VariableReference(mResumed, []), Expression(true, [])]), Statement(if (mPauseTime > 0) {, []), AssignmentExpression(=, [VariableReference(AnimationHandler handler, []), Expression(AnimationHandler.getInstance(), [])]), MethodCall(handler.addAnimationFrameCallback(this, 0), [VariableReference(handler, []), Expression(this, []), Expression(0, [])]), Statement(}, []), Statement(}, []), MethodCall(super.resume(), [VariableReference(super, []), Expression(, [])]), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(if (Looper.myLooper(), []), Expression(, [])])    VariableReference(if (Looper.myLooper(), [])    Expression(, [])  Statement(throw new AndroidRuntimeException(""Animators may only be resumed from the same "" + ""thread that the animator was started on""), [])  Statement(}, [])  Statement(if (mPaused && !mResumed) {, [])  AssignmentExpression(=, [VariableReference(mResumed, []), Expression(true, [])])    VariableReference(mResumed, [])    Expression(true, [])  Statement(if (mPauseTime > 0) {, [])  AssignmentExpression(=, [VariableReference(AnimationHandler handler, []), Expression(AnimationHandler.getInstance(), [])])    VariableReference(AnimationHandler handler, [])    Expression(AnimationHandler.getInstance(), [])  MethodCall(handler.addAnimationFrameCallback(this, 0), [VariableReference(handler, []), Expression(this, []), Expression(0, [])])    VariableReference(handler, [])    Expression(this, [])    Expression(0, [])  Statement(}, [])  Statement(}, [])  MethodCall(super.resume(), [VariableReference(super, []), Expression(, [])])    VariableReference(super, [])    Expression(, [])  Statement(}, [])",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,"2,3,4","1,2","2,3,4",2,The late version introduces several changes:,"3. New statements inside the conditionals (such as getting an instance of `AnimationHandler` and calling `handler.addAnimationFrameCallback(this, 0)`)."
1096,<android.speech.SpeechRecognizer: void destroy()>,20,21,<android.speech.SpeechRecognizer: void destroy()>,<android.speech.SpeechRecognizer: void destroy()>,0,"MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(if (mConnection !, []), Expression(null) {, [])]), MethodCall(mContext.unbindService(mConnection), [VariableReference(mContext, []), Expression(mConnection, [])]), Statement(}, []), MethodCall(mPendingTasks.clear(), [VariableReference(mPendingTasks, []), Expression(, [])]), AssignmentExpression(=, [VariableReference(mService, []), Expression(null, [])]), AssignmentExpression(=, [VariableReference(mConnection, []), Expression(null, [])]), AssignmentExpression(=, [VariableReference(mListener.mInternalListener, []), Expression(null, [])]), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(if (mConnection !, []), Expression(null) {, [])])    VariableReference(if (mConnection !, [])    Expression(null) {, [])  MethodCall(mContext.unbindService(mConnection), [VariableReference(mContext, []), Expression(mConnection, [])])    VariableReference(mContext, [])    Expression(mConnection, [])  Statement(}, [])  MethodCall(mPendingTasks.clear(), [VariableReference(mPendingTasks, []), Expression(, [])])    VariableReference(mPendingTasks, [])    Expression(, [])  AssignmentExpression(=, [VariableReference(mService, []), Expression(null, [])])    VariableReference(mService, [])    Expression(null, [])  AssignmentExpression(=, [VariableReference(mConnection, []), Expression(null, [])])    VariableReference(mConnection, [])    Expression(null, [])  AssignmentExpression(=, [VariableReference(mListener.mInternalListener, []), Expression(null, [])])    VariableReference(mListener.mInternalListener, [])    Expression(null, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(if (mService !, []), Expression(null) {, [])]), Statement(try {, []), MethodCall(mService.cancel(mListener), [VariableReference(mService, []), Expression(mListener, [])]), Statement(} catch (final RemoteException e) {, []), Statement(// Not important, []), Statement(}, []), Statement(}, []), AssignmentExpression(=, [VariableReference(if (mConnection !, []), Expression(null) {, [])]), MethodCall(mContext.unbindService(mConnection), [VariableReference(mContext, []), Expression(mConnection, [])]), Statement(}, []), MethodCall(mPendingTasks.clear(), [VariableReference(mPendingTasks, []), Expression(, [])]), AssignmentExpression(=, [VariableReference(mService, []), Expression(null, [])]), AssignmentExpression(=, [VariableReference(mConnection, []), Expression(null, [])]), AssignmentExpression(=, [VariableReference(mListener.mInternalListener, []), Expression(null, [])]), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(if (mService !, []), Expression(null) {, [])])    VariableReference(if (mService !, [])    Expression(null) {, [])  Statement(try {, [])  MethodCall(mService.cancel(mListener), [VariableReference(mService, []), Expression(mListener, [])])    VariableReference(mService, [])    Expression(mListener, [])  Statement(} catch (final RemoteException e) {, [])  Statement(// Not important, [])  Statement(}, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(if (mConnection !, []), Expression(null) {, [])])    VariableReference(if (mConnection !, [])    Expression(null) {, [])  MethodCall(mContext.unbindService(mConnection), [VariableReference(mContext, []), Expression(mConnection, [])])    VariableReference(mContext, [])    Expression(mConnection, [])  Statement(}, [])  MethodCall(mPendingTasks.clear(), [VariableReference(mPendingTasks, []), Expression(, [])])    VariableReference(mPendingTasks, [])    Expression(, [])  AssignmentExpression(=, [VariableReference(mService, []), Expression(null, [])])    VariableReference(mService, [])    Expression(null, [])  AssignmentExpression(=, [VariableReference(mConnection, []), Expression(null, [])])    VariableReference(mConnection, [])    Expression(null, [])  AssignmentExpression(=, [VariableReference(mListener.mInternalListener, []), Expression(null, [])])    VariableReference(mListener.mInternalListener, [])    Expression(null, [])  Statement(}, [])",1,"/**
 * Destroys the {@code SpeechRecognizer} object.
 */
","/**
 * Destroys the {@code SpeechRecognizer} object.
 */
",-1,,,-1,-1,-1,-1,-1,"2,3,4",2,"2,3",2,"A try-catch statement handling `RemoteException` has been introduced in the late version. The presence of the new exception handling means the code change type is 2. Additionally, control statements are modified to include if (mService != null) and try-catch, thus the code change type is also 3.","The introduction of exception handling with `RemoteException` potentially leads to different behavior in exception handling, so the CI type is 2."
90,<android.widget.RemoteViewsAdapter.FixedSizeRemoteViewsCache: RemoteViewsIndexMetaData getMetaDataAt(int)>,23,24,<android.widget.RemoteViewsAdapter.FixedSizeRemoteViewsCache: RemoteViewsIndexMetaData getMetaDataAt(int)>,<android.widget.RemoteViewsAdapter.FixedSizeRemoteViewsCache: RemoteViewsIndexMetaData getMetaDataAt(int)>,0,"MethodDeclaration(method_body, [Statement({, []), MethodCall(if (mIndexMetaData.containsKey(position)), [VariableReference(if (mIndexMetaData, []), Expression(position), [])]), MethodCall(return mIndexMetaData.get(position), [VariableReference(return mIndexMetaData, []), Expression(position, [])]), Statement(}, []), Statement(return null, []), Statement(}, [])])  Statement({, [])  MethodCall(if (mIndexMetaData.containsKey(position)), [VariableReference(if (mIndexMetaData, []), Expression(position), [])])    VariableReference(if (mIndexMetaData, [])    Expression(position), [])  MethodCall(return mIndexMetaData.get(position), [VariableReference(return mIndexMetaData, []), Expression(position, [])])    VariableReference(return mIndexMetaData, [])    Expression(position, [])  Statement(}, [])  Statement(return null, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), MethodCall(return mIndexMetaData.get(position), [VariableReference(return mIndexMetaData, []), Expression(position, [])]), Statement(}, [])])  Statement({, [])  MethodCall(return mIndexMetaData.get(position), [VariableReference(return mIndexMetaData, []), Expression(position, [])])    VariableReference(return mIndexMetaData, [])    Expression(position, [])  Statement(}, [])",1,,,-1,,,-1,-1,-1,-1,-1,"1,3",1,3,1,"The control dependency has changed. In the early version, the method checks if `mIndexMetaData` contains the key `position` before returning the value or returning `null` if the key is not present. In the late version, this check is removed, and it directly attempts to get the value associated with `position`.","The removal of the control dependency (the `if` check) can lead to different behavior. In the late version, if `position` is not a key in `mIndexMetaData`, it might return `null` or potentially cause an exception if the `get` method's contract changes. Therefore, the CI type is 1."
497,"<android.view.GLES20Canvas: void drawHardwareLayer(HardwareLayer,float,float,Paint)>",16,17,"<android.view.GLES20Canvas: void drawHardwareLayer(HardwareLayer,float,float,Paint)>","<android.view.GLES20Canvas: void drawHardwareLayer(HardwareLayer,float,float,Paint)>",0,"MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(final GLES20Layer glLayer, []), Expression((GLES20Layer) layer, [])]), AssignmentExpression(=, [VariableReference(int modifier, []), Expression(paint !, [])]), Statement(try {, []), AssignmentExpression(=, [VariableReference(final int nativePaint, []), Expression(paint, [])]), MethodCall(nDrawLayer(mRenderer, glLayer.getLayer(), x, y, nativePaint), [VariableReference(nDrawLayer(mRenderer, glLayer, []), Expression(), []), Expression(x, []), Expression(y, []), Expression(nativePaint, [])]), Statement(} finally {, []), AssignmentExpression(=, [VariableReference(if (modifier !, []), Expression(MODIFIER_NONE), [])]), Statement(nResetModifiers(mRenderer, modifier), []), Statement(}, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(final GLES20Layer glLayer, []), Expression((GLES20Layer) layer, [])])    VariableReference(final GLES20Layer glLayer, [])    Expression((GLES20Layer) layer, [])  AssignmentExpression(=, [VariableReference(int modifier, []), Expression(paint !, [])])    VariableReference(int modifier, [])    Expression(paint !, [])  Statement(try {, [])  AssignmentExpression(=, [VariableReference(final int nativePaint, []), Expression(paint, [])])    VariableReference(final int nativePaint, [])    Expression(paint, [])  MethodCall(nDrawLayer(mRenderer, glLayer.getLayer(), x, y, nativePaint), [VariableReference(nDrawLayer(mRenderer, glLayer, []), Expression(), []), Expression(x, []), Expression(y, []), Expression(nativePaint, [])])    VariableReference(nDrawLayer(mRenderer, glLayer, [])    Expression(), [])    Expression(x, [])    Expression(y, [])    Expression(nativePaint, [])  Statement(} finally {, [])  AssignmentExpression(=, [VariableReference(if (modifier !, []), Expression(MODIFIER_NONE), [])])    VariableReference(if (modifier !, [])    Expression(MODIFIER_NONE), [])  Statement(nResetModifiers(mRenderer, modifier), [])  Statement(}, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(final GLES20Layer glLayer, []), Expression((GLES20Layer) layer, [])]), AssignmentExpression(=, [VariableReference(final int nativePaint, []), Expression(paint, [])]), MethodCall(nDrawLayer(mRenderer, glLayer.getLayer(), x, y, nativePaint), [VariableReference(nDrawLayer(mRenderer, glLayer, []), Expression(), []), Expression(x, []), Expression(y, []), Expression(nativePaint, [])]), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(final GLES20Layer glLayer, []), Expression((GLES20Layer) layer, [])])    VariableReference(final GLES20Layer glLayer, [])    Expression((GLES20Layer) layer, [])  AssignmentExpression(=, [VariableReference(final int nativePaint, []), Expression(paint, [])])    VariableReference(final int nativePaint, [])    Expression(paint, [])  MethodCall(nDrawLayer(mRenderer, glLayer.getLayer(), x, y, nativePaint), [VariableReference(nDrawLayer(mRenderer, glLayer, []), Expression(), []), Expression(x, []), Expression(y, []), Expression(nativePaint, [])])    VariableReference(nDrawLayer(mRenderer, glLayer, [])    Expression(), [])    Expression(x, [])    Expression(y, [])    Expression(nativePaint, [])  Statement(}, [])",1,,,-1,,,-1,-1,-1,-1,-1,"2,3,4",0,"3,4",0,"The late version removes the `try-finally` block and the assignments of `modifier` and the call to `nResetModifiers(mRenderer, modifier)`. This is a change in control dependency (removing exception handling) and other statements.","These changes do not affect the method's return type or introduce/remove any exceptions that alter the external behavior of the method. Therefore, no Compatibility Issue exists for the API."
288,"<android.speech.tts.PlaybackSynthesisCallback: int audioAvailable(byte[],int,int)>",15,16,"<android.speech.tts.PlaybackSynthesisCallback: int audioAvailable(byte[],int,int)>","<android.speech.tts.PlaybackSynthesisCallback: int audioAvailable(byte[],int,int)>",0,"MethodDeclaration(method_body, [Statement({, []), Statement(if (DBG) {, []), MethodCall(Log.d(TAG, ""audioAvailable(byte["" + buffer.length + ""], "" + offset + "", "" + length + "")""), [VariableReference(Log, []), Expression(TAG, []), Expression(""audioAvailable(byte["" + buffer.length + ""], []), Expression("" + offset + "", []), Expression("" + length + "")"", [])]), Statement(}, []), AssignmentExpression(=, [VariableReference(if (length > getMaxBufferSize() || length <, []), Expression(0) {, [])]), Statement(throw new IllegalArgumentException(""buffer is too large or of zero length ("" + +length + "" bytes)""), []), Statement(}, []), AssignmentExpression(=, [VariableReference(SynthesisMessageParams token, []), Expression(null, [])]), Statement(synchronized (mStateLock) {, []), AssignmentExpression(=, [VariableReference(if (mToken, []), Expression(, [])]), Statement(return TextToSpeech.ERROR, []), Statement(}, []), AssignmentExpression(=, [VariableReference(token, []), Expression(mToken, [])]), Statement(}, []), Statement(// Sigh, another copy., []), AssignmentExpression(=, [VariableReference(final byte[] bufferCopy, []), Expression(new byte[length], [])]), MethodCall(System.arraycopy(buffer, offset, bufferCopy, 0, length), [VariableReference(System, []), Expression(buffer, []), Expression(offset, []), Expression(bufferCopy, []), Expression(0, []), Expression(length, [])]), Statement(// Might block on mToken.this, if there are too many buffers waiting to, []), Statement(// be consumed., []), MethodCall(token.addBuffer(bufferCopy), [VariableReference(token, []), Expression(bufferCopy, [])]), MethodCall(mAudioTrackHandler.enqueueSynthesisDataAvailable(token), [VariableReference(mAudioTrackHandler, []), Expression(token, [])]), MethodCall(mLogger.onEngineDataReceived(), [VariableReference(mLogger, []), Expression(, [])]), Statement(return TextToSpeech.SUCCESS, []), Statement(}, [])])  Statement({, [])  Statement(if (DBG) {, [])  MethodCall(Log.d(TAG, ""audioAvailable(byte["" + buffer.length + ""], "" + offset + "", "" + length + "")""), [VariableReference(Log, []), Expression(TAG, []), Expression(""audioAvailable(byte["" + buffer.length + ""], []), Expression("" + offset + "", []), Expression("" + length + "")"", [])])    VariableReference(Log, [])    Expression(TAG, [])    Expression(""audioAvailable(byte["" + buffer.length + ""], [])    Expression("" + offset + "", [])    Expression("" + length + "")"", [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(if (length > getMaxBufferSize() || length <, []), Expression(0) {, [])])    VariableReference(if (length > getMaxBufferSize() || length <, [])    Expression(0) {, [])  Statement(throw new IllegalArgumentException(""buffer is too large or of zero length ("" + +length + "" bytes)""), [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(SynthesisMessageParams token, []), Expression(null, [])])    VariableReference(SynthesisMessageParams token, [])    Expression(null, [])  Statement(synchronized (mStateLock) {, [])  AssignmentExpression(=, [VariableReference(if (mToken, []), Expression(, [])])    VariableReference(if (mToken, [])    Expression(, [])  Statement(return TextToSpeech.ERROR, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(token, []), Expression(mToken, [])])    VariableReference(token, [])    Expression(mToken, [])  Statement(}, [])  Statement(// Sigh, another copy., [])  AssignmentExpression(=, [VariableReference(final byte[] bufferCopy, []), Expression(new byte[length], [])])    VariableReference(final byte[] bufferCopy, [])    Expression(new byte[length], [])  MethodCall(System.arraycopy(buffer, offset, bufferCopy, 0, length), [VariableReference(System, []), Expression(buffer, []), Expression(offset, []), Expression(bufferCopy, []), Expression(0, []), Expression(length, [])])    VariableReference(System, [])    Expression(buffer, [])    Expression(offset, [])    Expression(bufferCopy, [])    Expression(0, [])    Expression(length, [])  Statement(// Might block on mToken.this, if there are too many buffers waiting to, [])  Statement(// be consumed., [])  MethodCall(token.addBuffer(bufferCopy), [VariableReference(token, []), Expression(bufferCopy, [])])    VariableReference(token, [])    Expression(bufferCopy, [])  MethodCall(mAudioTrackHandler.enqueueSynthesisDataAvailable(token), [VariableReference(mAudioTrackHandler, []), Expression(token, [])])    VariableReference(mAudioTrackHandler, [])    Expression(token, [])  MethodCall(mLogger.onEngineDataReceived(), [VariableReference(mLogger, []), Expression(, [])])    VariableReference(mLogger, [])    Expression(, [])  Statement(return TextToSpeech.SUCCESS, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(if (DBG) {, []), MethodCall(Log.d(TAG, ""audioAvailable(byte["" + buffer.length + ""], "" + offset + "", "" + length + "")""), [VariableReference(Log, []), Expression(TAG, []), Expression(""audioAvailable(byte["" + buffer.length + ""], []), Expression("" + offset + "", []), Expression("" + length + "")"", [])]), Statement(}, []), AssignmentExpression(=, [VariableReference(if (length > getMaxBufferSize() || length <, []), Expression(0) {, [])]), Statement(throw new IllegalArgumentException(""buffer is too large or of zero length ("" + +length + "" bytes)""), []), Statement(}, []), AssignmentExpression(=, [VariableReference(SynthesisPlaybackQueueItem item, []), Expression(null, [])]), Statement(synchronized (mStateLock) {, []), AssignmentExpression(=, [VariableReference(if (mItem, []), Expression(, [])]), Statement(return TextToSpeech.ERROR, []), Statement(}, []), AssignmentExpression(=, [VariableReference(item, []), Expression(mItem, [])]), Statement(}, []), Statement(// Sigh, another copy., []), AssignmentExpression(=, [VariableReference(final byte[] bufferCopy, []), Expression(new byte[length], [])]), MethodCall(System.arraycopy(buffer, offset, bufferCopy, 0, length), [VariableReference(System, []), Expression(buffer, []), Expression(offset, []), Expression(bufferCopy, []), Expression(0, []), Expression(length, [])]), Statement(// be consumed., []), Statement(try {, []), MethodCall(item.put(bufferCopy), [VariableReference(item, []), Expression(bufferCopy, [])]), Statement(} catch (InterruptedException ie) {, []), Statement(return TextToSpeech.ERROR, []), Statement(}, []), MethodCall(mLogger.onEngineDataReceived(), [VariableReference(mLogger, []), Expression(, [])]), Statement(return TextToSpeech.SUCCESS, []), Statement(}, [])])  Statement({, [])  Statement(if (DBG) {, [])  MethodCall(Log.d(TAG, ""audioAvailable(byte["" + buffer.length + ""], "" + offset + "", "" + length + "")""), [VariableReference(Log, []), Expression(TAG, []), Expression(""audioAvailable(byte["" + buffer.length + ""], []), Expression("" + offset + "", []), Expression("" + length + "")"", [])])    VariableReference(Log, [])    Expression(TAG, [])    Expression(""audioAvailable(byte["" + buffer.length + ""], [])    Expression("" + offset + "", [])    Expression("" + length + "")"", [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(if (length > getMaxBufferSize() || length <, []), Expression(0) {, [])])    VariableReference(if (length > getMaxBufferSize() || length <, [])    Expression(0) {, [])  Statement(throw new IllegalArgumentException(""buffer is too large or of zero length ("" + +length + "" bytes)""), [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(SynthesisPlaybackQueueItem item, []), Expression(null, [])])    VariableReference(SynthesisPlaybackQueueItem item, [])    Expression(null, [])  Statement(synchronized (mStateLock) {, [])  AssignmentExpression(=, [VariableReference(if (mItem, []), Expression(, [])])    VariableReference(if (mItem, [])    Expression(, [])  Statement(return TextToSpeech.ERROR, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(item, []), Expression(mItem, [])])    VariableReference(item, [])    Expression(mItem, [])  Statement(}, [])  Statement(// Sigh, another copy., [])  AssignmentExpression(=, [VariableReference(final byte[] bufferCopy, []), Expression(new byte[length], [])])    VariableReference(final byte[] bufferCopy, [])    Expression(new byte[length], [])  MethodCall(System.arraycopy(buffer, offset, bufferCopy, 0, length), [VariableReference(System, []), Expression(buffer, []), Expression(offset, []), Expression(bufferCopy, []), Expression(0, []), Expression(length, [])])    VariableReference(System, [])    Expression(buffer, [])    Expression(offset, [])    Expression(bufferCopy, [])    Expression(0, [])    Expression(length, [])  Statement(// be consumed., [])  Statement(try {, [])  MethodCall(item.put(bufferCopy), [VariableReference(item, []), Expression(bufferCopy, [])])    VariableReference(item, [])    Expression(bufferCopy, [])  Statement(} catch (InterruptedException ie) {, [])  Statement(return TextToSpeech.ERROR, [])  Statement(}, [])  MethodCall(mLogger.onEngineDataReceived(), [VariableReference(mLogger, []), Expression(, [])])    VariableReference(mLogger, [])    Expression(, [])  Statement(return TextToSpeech.SUCCESS, [])  Statement(}, [])",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,"1,2,4","1,2","2,3",2,The code changes include replacing the `SynthesisMessageParams token` with `SynthesisPlaybackQueueItem item` and the additional try-catch block to handle potential `InterruptedException`. This results in changes to exception handling statements and control dependency in the if (mItem != null) block as follows:,
317,<android.view.inputmethod.BaseInputConnection: boolean finishComposingText()>,30,31,<android.view.inputmethod.BaseInputConnection: boolean finishComposingText()>,<android.view.inputmethod.BaseInputConnection: boolean finishComposingText()>,0,"MethodDeclaration(method_body, [Statement({, []), Statement(if (DEBUG), []), MethodCall(Log.v(TAG, ""finishComposingText""), [VariableReference(Log, []), Expression(TAG, []), Expression(""finishComposingText"", [])]), AssignmentExpression(=, [VariableReference(final Editable content, []), Expression(getEditable(), [])]), AssignmentExpression(=, [VariableReference(if (content !, []), Expression(null) {, [])]), Statement(beginBatchEdit(), []), Statement(removeComposingSpans(content), []), Statement(// Note: sendCurrentText does nothing unless mDummyMode is set, []), Statement(sendCurrentText(), []), Statement(endBatchEdit(), []), Statement(}, []), Statement(return true, []), Statement(}, [])])  Statement({, [])  Statement(if (DEBUG), [])  MethodCall(Log.v(TAG, ""finishComposingText""), [VariableReference(Log, []), Expression(TAG, []), Expression(""finishComposingText"", [])])    VariableReference(Log, [])    Expression(TAG, [])    Expression(""finishComposingText"", [])  AssignmentExpression(=, [VariableReference(final Editable content, []), Expression(getEditable(), [])])    VariableReference(final Editable content, [])    Expression(getEditable(), [])  AssignmentExpression(=, [VariableReference(if (content !, []), Expression(null) {, [])])    VariableReference(if (content !, [])    Expression(null) {, [])  Statement(beginBatchEdit(), [])  Statement(removeComposingSpans(content), [])  Statement(// Note: sendCurrentText does nothing unless mDummyMode is set, [])  Statement(sendCurrentText(), [])  Statement(endBatchEdit(), [])  Statement(}, [])  Statement(return true, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(if (DEBUG), []), MethodCall(Log.v(TAG, ""finishComposingText""), [VariableReference(Log, []), Expression(TAG, []), Expression(""finishComposingText"", [])]), AssignmentExpression(=, [VariableReference(final Editable content, []), Expression(getEditable(), [])]), AssignmentExpression(=, [VariableReference(if (content !, []), Expression(null) {, [])]), Statement(beginBatchEdit(), []), Statement(removeComposingSpans(content), []), Statement(// Note: sendCurrentText does nothing unless mFallbackMode is set, []), Statement(sendCurrentText(), []), Statement(endBatchEdit(), []), Statement(endComposingRegionEditInternal(), []), Statement(}, []), Statement(return true, []), Statement(}, [])])  Statement({, [])  Statement(if (DEBUG), [])  MethodCall(Log.v(TAG, ""finishComposingText""), [VariableReference(Log, []), Expression(TAG, []), Expression(""finishComposingText"", [])])    VariableReference(Log, [])    Expression(TAG, [])    Expression(""finishComposingText"", [])  AssignmentExpression(=, [VariableReference(final Editable content, []), Expression(getEditable(), [])])    VariableReference(final Editable content, [])    Expression(getEditable(), [])  AssignmentExpression(=, [VariableReference(if (content !, []), Expression(null) {, [])])    VariableReference(if (content !, [])    Expression(null) {, [])  Statement(beginBatchEdit(), [])  Statement(removeComposingSpans(content), [])  Statement(// Note: sendCurrentText does nothing unless mFallbackMode is set, [])  Statement(sendCurrentText(), [])  Statement(endBatchEdit(), [])  Statement(endComposingRegionEditInternal(), [])  Statement(}, [])  Statement(return true, [])  Statement(}, [])",1,"/**
 * The default implementation removes the composing state from the
 * current editable text.  In addition, only if dummy mode, a key event is
 * sent for the new text and the current editable buffer cleared.
 */
","/**
 * The default implementation removes the composing state from the
 * current editable text.  In addition, only if fallback mode, a key event is
 * sent for the new text and the current editable buffer cleared.
 */
",-1,,,-1,-1,-1,-1,-1,4,0,"3,4",0,"The implementation has been modified: the comment inside the method has changed from `mDummyMode` to `mFallbackMode`, and a new method call `endComposingRegionEditInternal()` has been added before the final return statement. These changes fall into control dependency change and other statement change categories.","The changes do not affect the return value or the exception handling of the method. Hence, no compatibility issues exist."
650,"<android.view.View: boolean awakenScrollBars(int,boolean)>",22,23,"<android.view.View: boolean awakenScrollBars(int,boolean)>","<android.view.View: boolean awakenScrollBars(int,boolean)>",0,"MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(final ScrollabilityCache scrollCache, []), Expression(mScrollCache, [])]), AssignmentExpression(=, [VariableReference(if (scrollCache, []), Expression(, [])]), Statement(return false, []), Statement(}, []), AssignmentExpression(=, [VariableReference(if (scrollCache.scrollBar, []), Expression(, [])]), AssignmentExpression(=, [VariableReference(scrollCache.scrollBar, []), Expression(new ScrollBarDrawable(), [])]), Statement(}, []), Statement(if (isHorizontalScrollBarEnabled() || isVerticalScrollBarEnabled()) {, []), Statement(if (invalidate) {, []), Statement(// Invalidate to show the scrollbars, []), Statement(postInvalidateOnAnimation(), []), Statement(}, []), AssignmentExpression(=, [VariableReference(if (scrollCache.state, []), Expression(, [])]), Statement(// FIXME: this is copied from WindowManagerService., []), Statement(// We should get this value from the system when it, []), Statement(// is possible to do so., []), AssignmentExpression(=, [VariableReference(final int KEY_REPEAT_FIRST_DELAY, []), Expression(750, [])]), AssignmentExpression(=, [VariableReference(startDelay, []), Expression(Math.max(KEY_REPEAT_FIRST_DELAY, startDelay), [])]), Statement(}, []), Statement(// Tell mScrollCache when we should start fading. This may, []), Statement(// extend the fade start time if one was already scheduled, []), AssignmentExpression(=, [VariableReference(long fadeStartTime, []), Expression(AnimationUtils.currentAnimationTimeMillis() + startDelay, [])]), AssignmentExpression(=, [VariableReference(scrollCache.fadeStartTime, []), Expression(fadeStartTime, [])]), AssignmentExpression(=, [VariableReference(scrollCache.state, []), Expression(ScrollabilityCache.ON, [])]), Statement(// Schedule our fader to run, unscheduling any old ones first, []), AssignmentExpression(=, [VariableReference(if (mAttachInfo !, []), Expression(null) {, [])]), Statement(}, []), Statement(return true, []), Statement(}, []), Statement(return false, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(final ScrollabilityCache scrollCache, []), Expression(mScrollCache, [])])    VariableReference(final ScrollabilityCache scrollCache, [])    Expression(mScrollCache, [])  AssignmentExpression(=, [VariableReference(if (scrollCache, []), Expression(, [])])    VariableReference(if (scrollCache, [])    Expression(, [])  Statement(return false, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(if (scrollCache.scrollBar, []), Expression(, [])])    VariableReference(if (scrollCache.scrollBar, [])    Expression(, [])  AssignmentExpression(=, [VariableReference(scrollCache.scrollBar, []), Expression(new ScrollBarDrawable(), [])])    VariableReference(scrollCache.scrollBar, [])    Expression(new ScrollBarDrawable(), [])  Statement(}, [])  Statement(if (isHorizontalScrollBarEnabled() || isVerticalScrollBarEnabled()) {, [])  Statement(if (invalidate) {, [])  Statement(// Invalidate to show the scrollbars, [])  Statement(postInvalidateOnAnimation(), [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(if (scrollCache.state, []), Expression(, [])])    VariableReference(if (scrollCache.state, [])    Expression(, [])  Statement(// FIXME: this is copied from WindowManagerService., [])  Statement(// We should get this value from the system when it, [])  Statement(// is possible to do so., [])  AssignmentExpression(=, [VariableReference(final int KEY_REPEAT_FIRST_DELAY, []), Expression(750, [])])    VariableReference(final int KEY_REPEAT_FIRST_DELAY, [])    Expression(750, [])  AssignmentExpression(=, [VariableReference(startDelay, []), Expression(Math.max(KEY_REPEAT_FIRST_DELAY, startDelay), [])])    VariableReference(startDelay, [])    Expression(Math.max(KEY_REPEAT_FIRST_DELAY, startDelay), [])  Statement(}, [])  Statement(// Tell mScrollCache when we should start fading. This may, [])  Statement(// extend the fade start time if one was already scheduled, [])  AssignmentExpression(=, [VariableReference(long fadeStartTime, []), Expression(AnimationUtils.currentAnimationTimeMillis() + startDelay, [])])    VariableReference(long fadeStartTime, [])    Expression(AnimationUtils.currentAnimationTimeMillis() + startDelay, [])  AssignmentExpression(=, [VariableReference(scrollCache.fadeStartTime, []), Expression(fadeStartTime, [])])    VariableReference(scrollCache.fadeStartTime, [])    Expression(fadeStartTime, [])  AssignmentExpression(=, [VariableReference(scrollCache.state, []), Expression(ScrollabilityCache.ON, [])])    VariableReference(scrollCache.state, [])    Expression(ScrollabilityCache.ON, [])  Statement(// Schedule our fader to run, unscheduling any old ones first, [])  AssignmentExpression(=, [VariableReference(if (mAttachInfo !, []), Expression(null) {, [])])    VariableReference(if (mAttachInfo !, [])    Expression(null) {, [])  Statement(}, [])  Statement(return true, [])  Statement(}, [])  Statement(return false, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(final ScrollabilityCache scrollCache, []), Expression(mScrollCache, [])]), AssignmentExpression(=, [VariableReference(if (scrollCache, []), Expression(, [])]), Statement(return false, []), Statement(}, []), AssignmentExpression(=, [VariableReference(if (scrollCache.scrollBar, []), Expression(, [])]), AssignmentExpression(=, [VariableReference(scrollCache.scrollBar, []), Expression(new ScrollBarDrawable(), [])]), Statement(}, []), Statement(if (isHorizontalScrollBarEnabled() || isVerticalScrollBarEnabled()) {, []), Statement(if (invalidate) {, []), Statement(// Invalidate to show the scrollbars, []), Statement(postInvalidateOnAnimation(), []), Statement(}, []), AssignmentExpression(=, [VariableReference(if (scrollCache.state, []), Expression(, [])]), Statement(// FIXME: this is copied from WindowManagerService., []), Statement(// We should get this value from the system when it, []), Statement(// is possible to do so., []), AssignmentExpression(=, [VariableReference(final int KEY_REPEAT_FIRST_DELAY, []), Expression(750, [])]), AssignmentExpression(=, [VariableReference(startDelay, []), Expression(Math.max(KEY_REPEAT_FIRST_DELAY, startDelay), [])]), Statement(}, []), Statement(// Tell mScrollCache when we should start fading. This may, []), Statement(// extend the fade start time if one was already scheduled, []), AssignmentExpression(=, [VariableReference(long fadeStartTime, []), Expression(AnimationUtils.currentAnimationTimeMillis() + startDelay, [])]), AssignmentExpression(=, [VariableReference(scrollCache.fadeStartTime, []), Expression(fadeStartTime, [])]), AssignmentExpression(=, [VariableReference(scrollCache.state, []), Expression(ScrollabilityCache.ON, [])]), Statement(// Schedule our fader to run, unscheduling any old ones first, []), AssignmentExpression(=, [VariableReference(if (mAttachInfo !, []), Expression(null) {, [])]), Statement(}, []), Statement(return true, []), Statement(}, []), Statement(return false, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(final ScrollabilityCache scrollCache, []), Expression(mScrollCache, [])])    VariableReference(final ScrollabilityCache scrollCache, [])    Expression(mScrollCache, [])  AssignmentExpression(=, [VariableReference(if (scrollCache, []), Expression(, [])])    VariableReference(if (scrollCache, [])    Expression(, [])  Statement(return false, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(if (scrollCache.scrollBar, []), Expression(, [])])    VariableReference(if (scrollCache.scrollBar, [])    Expression(, [])  AssignmentExpression(=, [VariableReference(scrollCache.scrollBar, []), Expression(new ScrollBarDrawable(), [])])    VariableReference(scrollCache.scrollBar, [])    Expression(new ScrollBarDrawable(), [])  Statement(}, [])  Statement(if (isHorizontalScrollBarEnabled() || isVerticalScrollBarEnabled()) {, [])  Statement(if (invalidate) {, [])  Statement(// Invalidate to show the scrollbars, [])  Statement(postInvalidateOnAnimation(), [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(if (scrollCache.state, []), Expression(, [])])    VariableReference(if (scrollCache.state, [])    Expression(, [])  Statement(// FIXME: this is copied from WindowManagerService., [])  Statement(// We should get this value from the system when it, [])  Statement(// is possible to do so., [])  AssignmentExpression(=, [VariableReference(final int KEY_REPEAT_FIRST_DELAY, []), Expression(750, [])])    VariableReference(final int KEY_REPEAT_FIRST_DELAY, [])    Expression(750, [])  AssignmentExpression(=, [VariableReference(startDelay, []), Expression(Math.max(KEY_REPEAT_FIRST_DELAY, startDelay), [])])    VariableReference(startDelay, [])    Expression(Math.max(KEY_REPEAT_FIRST_DELAY, startDelay), [])  Statement(}, [])  Statement(// Tell mScrollCache when we should start fading. This may, [])  Statement(// extend the fade start time if one was already scheduled, [])  AssignmentExpression(=, [VariableReference(long fadeStartTime, []), Expression(AnimationUtils.currentAnimationTimeMillis() + startDelay, [])])    VariableReference(long fadeStartTime, [])    Expression(AnimationUtils.currentAnimationTimeMillis() + startDelay, [])  AssignmentExpression(=, [VariableReference(scrollCache.fadeStartTime, []), Expression(fadeStartTime, [])])    VariableReference(scrollCache.fadeStartTime, [])    Expression(fadeStartTime, [])  AssignmentExpression(=, [VariableReference(scrollCache.state, []), Expression(ScrollabilityCache.ON, [])])    VariableReference(scrollCache.state, [])    Expression(ScrollabilityCache.ON, [])  Statement(// Schedule our fader to run, unscheduling any old ones first, [])  AssignmentExpression(=, [VariableReference(if (mAttachInfo !, []), Expression(null) {, [])])    VariableReference(if (mAttachInfo !, [])    Expression(null) {, [])  Statement(}, [])  Statement(return true, [])  Statement(}, [])  Statement(return false, [])  Statement(}, [])",1,"/**
 * <p>
 * Trigger the scrollbars to draw. When invoked this method starts an
 * animation to fade the scrollbars out after a fixed delay. If a subclass
 * provides animated scrolling, the start delay should equal the duration of
 * the scrolling animation.
 * </p>
 *
 * <p>
 * The animation starts only if at least one of the scrollbars is enabled,
 * as specified by {@link #isHorizontalScrollBarEnabled()} and
 * {@link #isVerticalScrollBarEnabled()}. When the animation is started,
 * this method returns true, and false otherwise. If the animation is
 * started, this method calls {@link #invalidate()} if the invalidate parameter
 * is set to true; in that case the caller
 * should not call {@link #invalidate()}.
 * </p>
 *
 * <p>
 * This method should be invoked everytime a subclass directly updates the
 * scroll parameters.
 * </p>
 *
 * @param startDelay the delay, in milliseconds, after which the animation
 * should start; when the delay is 0, the animation starts
 * immediately
 *
 * @param invalidate Wheter this method should call invalidate
 *
 * @return true if the animation is played, false otherwise
 *
 * @see #scrollBy(int, int)
 * @see #scrollTo(int, int)
 * @see #isHorizontalScrollBarEnabled()
 * @see #isVerticalScrollBarEnabled()
 * @see #setHorizontalScrollBarEnabled(boolean)
 * @see #setVerticalScrollBarEnabled(boolean)
 */
","/**
 * <p>
 * Trigger the scrollbars to draw. When invoked this method starts an
 * animation to fade the scrollbars out after a fixed delay. If a subclass
 * provides animated scrolling, the start delay should equal the duration of
 * the scrolling animation.
 * </p>
 *
 * <p>
 * The animation starts only if at least one of the scrollbars is enabled,
 * as specified by {@link #isHorizontalScrollBarEnabled()} and
 * {@link #isVerticalScrollBarEnabled()}. When the animation is started,
 * this method returns true, and false otherwise. If the animation is
 * started, this method calls {@link #invalidate()} if the invalidate parameter
 * is set to true; in that case the caller
 * should not call {@link #invalidate()}.
 * </p>
 *
 * <p>
 * This method should be invoked every time a subclass directly updates the
 * scroll parameters.
 * </p>
 *
 * @param startDelay the delay, in milliseconds, after which the animation
 * should start; when the delay is 0, the animation starts
 * immediately
 *
 * @param invalidate Whether this method should call invalidate
 *
 * @return true if the animation is played, false otherwise
 *
 * @see #scrollBy(int, int)
 * @see #scrollTo(int, int)
 * @see #isHorizontalScrollBarEnabled()
 * @see #isVerticalScrollBarEnabled()
 * @see #setHorizontalScrollBarEnabled(boolean)
 * @see #setVerticalScrollBarEnabled(boolean)
 */
",-1,,,-1,-1,-1,-1,-1,4,0,0,0,"Based on the provided AST node representations of the early and late implementations, there are no changes in the method's implementation. The code and comments are identical between the two versions.","Since there is no change in the implementation, there are no compatibility issues."
475,<android.preference.Preference: int compareTo(Preference)>,18,19,<android.preference.Preference: int compareTo(Preference)>,<android.preference.Preference: int compareTo(Preference)>,0,"MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(if (mOrder !, []), Expression(DEFAULT_ORDER || (mOrder, [])]), Statement(// Do order comparison, []), Statement(return mOrder - another.mOrder, []), AssignmentExpression(=, [VariableReference(} else if (mTitle, []), Expression(, [])]), Statement(return 1, []), AssignmentExpression(=, [VariableReference(} else if (another.mTitle, []), Expression(, [])]), Statement(return -1, []), Statement(} else {, []), Statement(// Do name comparison, []), MethodCall(return CharSequences.compareToIgnoreCase(mTitle, another.mTitle), [VariableReference(return CharSequences, []), Expression(mTitle, []), Expression(another.mTitle, [])]), Statement(}, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(if (mOrder !, []), Expression(DEFAULT_ORDER || (mOrder, [])])    VariableReference(if (mOrder !, [])    Expression(DEFAULT_ORDER || (mOrder, [])  Statement(// Do order comparison, [])  Statement(return mOrder - another.mOrder, [])  AssignmentExpression(=, [VariableReference(} else if (mTitle, []), Expression(, [])])    VariableReference(} else if (mTitle, [])    Expression(, [])  Statement(return 1, [])  AssignmentExpression(=, [VariableReference(} else if (another.mTitle, []), Expression(, [])])    VariableReference(} else if (another.mTitle, [])    Expression(, [])  Statement(return -1, [])  Statement(} else {, [])  Statement(// Do name comparison, [])  MethodCall(return CharSequences.compareToIgnoreCase(mTitle, another.mTitle), [VariableReference(return CharSequences, []), Expression(mTitle, []), Expression(another.mTitle, [])])    VariableReference(return CharSequences, [])    Expression(mTitle, [])    Expression(another.mTitle, [])  Statement(}, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(if (mOrder !, []), Expression(DEFAULT_ORDER || (mOrder, [])]), Statement(// Do order comparison, []), Statement(return mOrder - another.mOrder, []), AssignmentExpression(=, [VariableReference(} else if (mTitle, []), Expression(, [])]), Statement(// If titles are null or share same object comparison, []), Statement(return 0, []), AssignmentExpression(=, [VariableReference(} else if (mTitle, []), Expression(, [])]), Statement(return 1, []), AssignmentExpression(=, [VariableReference(} else if (another.mTitle, []), Expression(, [])]), Statement(return -1, []), Statement(} else {, []), Statement(// Do name comparison, []), MethodCall(return CharSequences.compareToIgnoreCase(mTitle, another.mTitle), [VariableReference(return CharSequences, []), Expression(mTitle, []), Expression(another.mTitle, [])]), Statement(}, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(if (mOrder !, []), Expression(DEFAULT_ORDER || (mOrder, [])])    VariableReference(if (mOrder !, [])    Expression(DEFAULT_ORDER || (mOrder, [])  Statement(// Do order comparison, [])  Statement(return mOrder - another.mOrder, [])  AssignmentExpression(=, [VariableReference(} else if (mTitle, []), Expression(, [])])    VariableReference(} else if (mTitle, [])    Expression(, [])  Statement(// If titles are null or share same object comparison, [])  Statement(return 0, [])  AssignmentExpression(=, [VariableReference(} else if (mTitle, []), Expression(, [])])    VariableReference(} else if (mTitle, [])    Expression(, [])  Statement(return 1, [])  AssignmentExpression(=, [VariableReference(} else if (another.mTitle, []), Expression(, [])])    VariableReference(} else if (another.mTitle, [])    Expression(, [])  Statement(return -1, [])  Statement(} else {, [])  Statement(// Do name comparison, [])  MethodCall(return CharSequences.compareToIgnoreCase(mTitle, another.mTitle), [VariableReference(return CharSequences, []), Expression(mTitle, []), Expression(another.mTitle, [])])    VariableReference(return CharSequences, [])    Expression(mTitle, [])    Expression(another.mTitle, [])  Statement(}, [])  Statement(}, [])",1,"/**
 * Compares Preference objects based on order (if set), otherwise alphabetically on the titles.
 *
 * @param another The Preference to compare to this one.
 * @return 0 if the same; less than 0 if this Preference sorts ahead of <var>another</var>;
 * greater than 0 if this Preference sorts after <var>another</var>.
 */
","/**
 * Compares Preference objects based on order (if set), otherwise alphabetically on the titles.
 *
 * @param another The Preference to compare to this one.
 * @return 0 if the same; less than 0 if this Preference sorts ahead of <var>another</var>;
 * greater than 0 if this Preference sorts after <var>another</var>.
 */
",-1,,,-1,-1,-1,-1,-1,"1,3",1,"1,3",1,"A conditional statement (else if) has been added to handle cases where both titles are null or point to the same object (returning 0 in such a scenario), representing a control dependency change. Additionally, this new condition introduces a new return statement with value 0, indicating a return statement change.","The new conditional check and return statement can cause the method to return a different value in cases where both titles are null or the same object, leading to potential compatibility issues. So, the CI type is 1 (Compatibility Issue caused by potential different return values or types)."
47,<android.text.PrecomputedText.Params.Builder: Params build()>,32,33,,,,"MethodDeclaration(method_body, [Statement({, []), Statement(return new Params(mPaint, mTextDir, mBreakStrategy, mHyphenationFrequency), []), Statement(}, [])])  Statement({, [])  Statement(return new Params(mPaint, mTextDir, mBreakStrategy, mHyphenationFrequency), [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(return new Params(mPaint, mLineBreakConfig, mTextDir, mBreakStrategy, mHyphenationFrequency), []), Statement(}, [])])  Statement({, [])  Statement(return new Params(mPaint, mLineBreakConfig, mTextDir, mBreakStrategy, mHyphenationFrequency), [])  Statement(}, [])",1,"/**
 * Build the {@link Params}.
 *
 * @return the layout parameter
 */
","/**
 * Build the {@link Params}.
 *
 * @return the layout parameter
 */
",0,[@NonNull],[@NonNull],0,,,,,"1,5",1,"1,4",1,"The return statement has changed due to the addition of a new parameter `mLineBreakConfig` in the constructor of `Params`. Therefore, the change type is 1,4.","The addition of `mLineBreakConfig` as a parameter in the return statement's constructor (`Params`) may result in a different object being returned, leading to potential different behaviors. Hence, the CI type is 1."
1019,<android.webkit.WebSettings: String getDatabasePath()>,15,16,<android.webkit.WebSettings: String getDatabasePath()>,<android.webkit.WebSettings: String getDatabasePath()>,0,"MethodDeclaration(method_body, [Statement({, []), Statement(return mDatabasePath, []), Statement(}, [])])  Statement({, [])  Statement(return mDatabasePath, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(throw new MustOverrideException(), []), Statement(}, [])])  Statement({, [])  Statement(throw new MustOverrideException(), [])  Statement(}, [])",1,"/**
 * Return the path to where database storage API databases are saved for
 * the current WebView.
 * @return the String path to the database storage API databases.
 */
","/**
 * Gets the path to where database storage API databases are saved for
 * the current WebView.
 *
 * @return the String path to the database storage API databases
 */
",-1,,,-1,-1,-1,-1,-1,"1,2","1,2","1,2","1,2","The early version returns the value of `mDatabasePath`, while the late version throws a `MustOverrideException`. This change involves the return and exception handling, so the change type is 1,2.","The late version will always throw an exception instead of returning a path, whereas the early version returns the path to the database storage API. Therefore, it can lead to potential different return values or types and different exception handling, so the CI type is 1,2."
210,<android.hardware.camera2.legacy.LegacyCameraDevice: void finalize()>,23,24,<android.hardware.camera2.legacy.LegacyCameraDevice: void finalize()>,<android.hardware.camera2.legacy.LegacyCameraDevice: void finalize()>,0,"MethodDeclaration(method_body, [Statement({, []), Statement(try {, []), Statement(close(), []), Statement(} catch (CameraRuntimeException e) {, []), MethodCall(Log.e(TAG, ""Got error while trying to finalize, ignoring: "" + e.getMessage()), [VariableReference(Log, []), Expression(TAG, []), Expression(""Got error while trying to finalize, []), Expression(ignoring: "" + e.getMessage(), [])]), Statement(} finally {, []), MethodCall(super.finalize(), [VariableReference(super, []), Expression(, [])]), Statement(}, []), Statement(}, [])])  Statement({, [])  Statement(try {, [])  Statement(close(), [])  Statement(} catch (CameraRuntimeException e) {, [])  MethodCall(Log.e(TAG, ""Got error while trying to finalize, ignoring: "" + e.getMessage()), [VariableReference(Log, []), Expression(TAG, []), Expression(""Got error while trying to finalize, []), Expression(ignoring: "" + e.getMessage(), [])])    VariableReference(Log, [])    Expression(TAG, [])    Expression(""Got error while trying to finalize, [])    Expression(ignoring: "" + e.getMessage(), [])  Statement(} finally {, [])  MethodCall(super.finalize(), [VariableReference(super, []), Expression(, [])])    VariableReference(super, [])    Expression(, [])  Statement(}, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(try {, []), Statement(close(), []), Statement(} catch (ServiceSpecificException e) {, []), MethodCall(Log.e(TAG, ""Got error while trying to finalize, ignoring: "" + e.getMessage()), [VariableReference(Log, []), Expression(TAG, []), Expression(""Got error while trying to finalize, []), Expression(ignoring: "" + e.getMessage(), [])]), Statement(} finally {, []), MethodCall(super.finalize(), [VariableReference(super, []), Expression(, [])]), Statement(}, []), Statement(}, [])])  Statement({, [])  Statement(try {, [])  Statement(close(), [])  Statement(} catch (ServiceSpecificException e) {, [])  MethodCall(Log.e(TAG, ""Got error while trying to finalize, ignoring: "" + e.getMessage()), [VariableReference(Log, []), Expression(TAG, []), Expression(""Got error while trying to finalize, []), Expression(ignoring: "" + e.getMessage(), [])])    VariableReference(Log, [])    Expression(TAG, [])    Expression(""Got error while trying to finalize, [])    Expression(ignoring: "" + e.getMessage(), [])  Statement(} finally {, [])  MethodCall(super.finalize(), [VariableReference(super, []), Expression(, [])])    VariableReference(super, [])    Expression(, [])  Statement(}, [])  Statement(}, [])",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,"2,4",2,2,2,"The exception handling statement has changed from catching `CameraRuntimeException` to catching `ServiceSpecificException`, so the change type is 2.","The change in the type of exception caught can lead to different handling of exceptions, potentially resulting in different behaviors of the API, thereby causing a compatibility issue. Hence, the CI type is 2."
849,<android.widget.NumberPicker: void onDraw(Canvas)>,15,16,<android.widget.NumberPicker: void onDraw(Canvas)>,<android.widget.NumberPicker: void onDraw(Canvas)>,0,"MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(if (mSelectorWheelState, []), Expression(, [])]), Statement(return, []), Statement(}, []), AssignmentExpression(=, [VariableReference(float x, []), Expression((mRight - mLeft) / 2, [])]), AssignmentExpression(=, [VariableReference(float y, []), Expression(mCurrentScrollOffset, [])]), AssignmentExpression(=, [VariableReference(final int restoreCount, []), Expression(canvas.save(), [])]), AssignmentExpression(=, [VariableReference(if (mSelectorWheelState, []), Expression(, [])]), AssignmentExpression(=, [VariableReference(Rect clipBounds, []), Expression(canvas.getClipBounds(), [])]), MethodCall(clipBounds.inset(0, mSelectorElementHeight), [VariableReference(clipBounds, []), Expression(0, []), Expression(mSelectorElementHeight, [])]), MethodCall(canvas.clipRect(clipBounds), [VariableReference(canvas, []), Expression(clipBounds, [])]), Statement(}, []), Statement(// draw the selector wheel, []), AssignmentExpression(=, [VariableReference(int[] selectorIndices, []), Expression(mSelectorIndices, [])]), AssignmentExpression(=, [VariableReference(for (int i, []), Expression(0, [])]), Statement(i < selectorIndices.length, []), Statement(i++) {, []), AssignmentExpression(=, [VariableReference(int selectorIndex, []), Expression(selectorIndices[i], [])]), AssignmentExpression(=, [VariableReference(String scrollSelectorValue, []), Expression(mSelectorIndexToStringCache.get(selectorIndex), [])]), Statement(// value intermixed with the new one., []), AssignmentExpression(=, [VariableReference(if (i !, []), Expression(SELECTOR_MIDDLE_ITEM_INDEX || mInputText.getVisibility() !, [])]), MethodCall(canvas.drawText(scrollSelectorValue, x, y, mSelectorWheelPaint), [VariableReference(canvas, []), Expression(scrollSelectorValue, []), Expression(x, []), Expression(y, []), Expression(mSelectorWheelPaint, [])]), Statement(}, []), AssignmentExpression(=, [VariableReference(y +, []), Expression(mSelectorElementHeight, [])]), Statement(}, []), Statement(// draw the selection dividers (only if scrolling and drawable specified), []), AssignmentExpression(=, [VariableReference(if (mSelectionDivider !, []), Expression(null) {, [])]), Statement(// draw the top divider, []), AssignmentExpression(=, [VariableReference(int topOfTopDivider, []), Expression((getHeight() - mSelectorElementHeight - mSelectionDividerHeight) / 2, [])]), AssignmentExpression(=, [VariableReference(int bottomOfTopDivider, []), Expression(topOfTopDivider + mSelectionDividerHeight, [])]), MethodCall(mSelectionDivider.setBounds(0, topOfTopDivider, mRight, bottomOfTopDivider), [VariableReference(mSelectionDivider, []), Expression(0, []), Expression(topOfTopDivider, []), Expression(mRight, []), Expression(bottomOfTopDivider, [])]), MethodCall(mSelectionDivider.draw(canvas), [VariableReference(mSelectionDivider, []), Expression(canvas, [])]), Statement(// draw the bottom divider, []), AssignmentExpression(=, [VariableReference(int topOfBottomDivider, []), Expression(topOfTopDivider + mSelectorElementHeight, [])]), AssignmentExpression(=, [VariableReference(int bottomOfBottomDivider, []), Expression(bottomOfTopDivider + mSelectorElementHeight, [])]), MethodCall(mSelectionDivider.setBounds(0, topOfBottomDivider, mRight, bottomOfBottomDivider), [VariableReference(mSelectionDivider, []), Expression(0, []), Expression(topOfBottomDivider, []), Expression(mRight, []), Expression(bottomOfBottomDivider, [])]), MethodCall(mSelectionDivider.draw(canvas), [VariableReference(mSelectionDivider, []), Expression(canvas, [])]), Statement(}, []), MethodCall(canvas.restoreToCount(restoreCount), [VariableReference(canvas, []), Expression(restoreCount, [])]), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(if (mSelectorWheelState, []), Expression(, [])])    VariableReference(if (mSelectorWheelState, [])    Expression(, [])  Statement(return, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(float x, []), Expression((mRight - mLeft) / 2, [])])    VariableReference(float x, [])    Expression((mRight - mLeft) / 2, [])  AssignmentExpression(=, [VariableReference(float y, []), Expression(mCurrentScrollOffset, [])])    VariableReference(float y, [])    Expression(mCurrentScrollOffset, [])  AssignmentExpression(=, [VariableReference(final int restoreCount, []), Expression(canvas.save(), [])])    VariableReference(final int restoreCount, [])    Expression(canvas.save(), [])  AssignmentExpression(=, [VariableReference(if (mSelectorWheelState, []), Expression(, [])])    VariableReference(if (mSelectorWheelState, [])    Expression(, [])  AssignmentExpression(=, [VariableReference(Rect clipBounds, []), Expression(canvas.getClipBounds(), [])])    VariableReference(Rect clipBounds, [])    Expression(canvas.getClipBounds(), [])  MethodCall(clipBounds.inset(0, mSelectorElementHeight), [VariableReference(clipBounds, []), Expression(0, []), Expression(mSelectorElementHeight, [])])    VariableReference(clipBounds, [])    Expression(0, [])    Expression(mSelectorElementHeight, [])  MethodCall(canvas.clipRect(clipBounds), [VariableReference(canvas, []), Expression(clipBounds, [])])    VariableReference(canvas, [])    Expression(clipBounds, [])  Statement(}, [])  Statement(// draw the selector wheel, [])  AssignmentExpression(=, [VariableReference(int[] selectorIndices, []), Expression(mSelectorIndices, [])])    VariableReference(int[] selectorIndices, [])    Expression(mSelectorIndices, [])  AssignmentExpression(=, [VariableReference(for (int i, []), Expression(0, [])])    VariableReference(for (int i, [])    Expression(0, [])  Statement(i < selectorIndices.length, [])  Statement(i++) {, [])  AssignmentExpression(=, [VariableReference(int selectorIndex, []), Expression(selectorIndices[i], [])])    VariableReference(int selectorIndex, [])    Expression(selectorIndices[i], [])  AssignmentExpression(=, [VariableReference(String scrollSelectorValue, []), Expression(mSelectorIndexToStringCache.get(selectorIndex), [])])    VariableReference(String scrollSelectorValue, [])    Expression(mSelectorIndexToStringCache.get(selectorIndex), [])  Statement(// value intermixed with the new one., [])  AssignmentExpression(=, [VariableReference(if (i !, []), Expression(SELECTOR_MIDDLE_ITEM_INDEX || mInputText.getVisibility() !, [])])    VariableReference(if (i !, [])    Expression(SELECTOR_MIDDLE_ITEM_INDEX || mInputText.getVisibility() !, [])  MethodCall(canvas.drawText(scrollSelectorValue, x, y, mSelectorWheelPaint), [VariableReference(canvas, []), Expression(scrollSelectorValue, []), Expression(x, []), Expression(y, []), Expression(mSelectorWheelPaint, [])])    VariableReference(canvas, [])    Expression(scrollSelectorValue, [])    Expression(x, [])    Expression(y, [])    Expression(mSelectorWheelPaint, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(y +, []), Expression(mSelectorElementHeight, [])])    VariableReference(y +, [])    Expression(mSelectorElementHeight, [])  Statement(}, [])  Statement(// draw the selection dividers (only if scrolling and drawable specified), [])  AssignmentExpression(=, [VariableReference(if (mSelectionDivider !, []), Expression(null) {, [])])    VariableReference(if (mSelectionDivider !, [])    Expression(null) {, [])  Statement(// draw the top divider, [])  AssignmentExpression(=, [VariableReference(int topOfTopDivider, []), Expression((getHeight() - mSelectorElementHeight - mSelectionDividerHeight) / 2, [])])    VariableReference(int topOfTopDivider, [])    Expression((getHeight() - mSelectorElementHeight - mSelectionDividerHeight) / 2, [])  AssignmentExpression(=, [VariableReference(int bottomOfTopDivider, []), Expression(topOfTopDivider + mSelectionDividerHeight, [])])    VariableReference(int bottomOfTopDivider, [])    Expression(topOfTopDivider + mSelectionDividerHeight, [])  MethodCall(mSelectionDivider.setBounds(0, topOfTopDivider, mRight, bottomOfTopDivider), [VariableReference(mSelectionDivider, []), Expression(0, []), Expression(topOfTopDivider, []), Expression(mRight, []), Expression(bottomOfTopDivider, [])])    VariableReference(mSelectionDivider, [])    Expression(0, [])    Expression(topOfTopDivider, [])    Expression(mRight, [])    Expression(bottomOfTopDivider, [])  MethodCall(mSelectionDivider.draw(canvas), [VariableReference(mSelectionDivider, []), Expression(canvas, [])])    VariableReference(mSelectionDivider, [])    Expression(canvas, [])  Statement(// draw the bottom divider, [])  AssignmentExpression(=, [VariableReference(int topOfBottomDivider, []), Expression(topOfTopDivider + mSelectorElementHeight, [])])    VariableReference(int topOfBottomDivider, [])    Expression(topOfTopDivider + mSelectorElementHeight, [])  AssignmentExpression(=, [VariableReference(int bottomOfBottomDivider, []), Expression(bottomOfTopDivider + mSelectorElementHeight, [])])    VariableReference(int bottomOfBottomDivider, [])    Expression(bottomOfTopDivider + mSelectorElementHeight, [])  MethodCall(mSelectionDivider.setBounds(0, topOfBottomDivider, mRight, bottomOfBottomDivider), [VariableReference(mSelectionDivider, []), Expression(0, []), Expression(topOfBottomDivider, []), Expression(mRight, []), Expression(bottomOfBottomDivider, [])])    VariableReference(mSelectionDivider, [])    Expression(0, [])    Expression(topOfBottomDivider, [])    Expression(mRight, [])    Expression(bottomOfBottomDivider, [])  MethodCall(mSelectionDivider.draw(canvas), [VariableReference(mSelectionDivider, []), Expression(canvas, [])])    VariableReference(mSelectionDivider, [])    Expression(canvas, [])  Statement(}, [])  MethodCall(canvas.restoreToCount(restoreCount), [VariableReference(canvas, []), Expression(restoreCount, [])])    VariableReference(canvas, [])    Expression(restoreCount, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(if (!mHasSelectorWheel) {, []), MethodCall(super.onDraw(canvas), [VariableReference(super, []), Expression(canvas, [])]), Statement(return, []), Statement(}, []), AssignmentExpression(=, [VariableReference(float x, []), Expression((mRight - mLeft) / 2, [])]), AssignmentExpression(=, [VariableReference(float y, []), Expression(mCurrentScrollOffset, [])]), Statement(// draw the virtual buttons pressed state if needed, []), AssignmentExpression(=, [VariableReference(if (mVirtualButtonPressedDrawable !, []), Expression(null && mScrollState, [])]), Statement(if (mDecrementVirtualButtonPressed) {, []), MethodCall(mVirtualButtonPressedDrawable.setState(PRESSED_STATE_SET), [VariableReference(mVirtualButtonPressedDrawable, []), Expression(PRESSED_STATE_SET, [])]), MethodCall(mVirtualButtonPressedDrawable.setBounds(0, 0, mRight, mTopSelectionDividerTop), [VariableReference(mVirtualButtonPressedDrawable, []), Expression(0, []), Expression(0, []), Expression(mRight, []), Expression(mTopSelectionDividerTop, [])]), MethodCall(mVirtualButtonPressedDrawable.draw(canvas), [VariableReference(mVirtualButtonPressedDrawable, []), Expression(canvas, [])]), Statement(}, []), Statement(if (mIncrementVirtualButtonPressed) {, []), MethodCall(mVirtualButtonPressedDrawable.setState(PRESSED_STATE_SET), [VariableReference(mVirtualButtonPressedDrawable, []), Expression(PRESSED_STATE_SET, [])]), MethodCall(mVirtualButtonPressedDrawable.setBounds(0, mBottomSelectionDividerBottom, mRight, mBottom), [VariableReference(mVirtualButtonPressedDrawable, []), Expression(0, []), Expression(mBottomSelectionDividerBottom, []), Expression(mRight, []), Expression(mBottom, [])]), MethodCall(mVirtualButtonPressedDrawable.draw(canvas), [VariableReference(mVirtualButtonPressedDrawable, []), Expression(canvas, [])]), Statement(}, []), Statement(}, []), Statement(// draw the selector wheel, []), AssignmentExpression(=, [VariableReference(int[] selectorIndices, []), Expression(mSelectorIndices, [])]), AssignmentExpression(=, [VariableReference(for (int i, []), Expression(0, [])]), Statement(i < selectorIndices.length, []), Statement(i++) {, []), AssignmentExpression(=, [VariableReference(int selectorIndex, []), Expression(selectorIndices[i], [])]), AssignmentExpression(=, [VariableReference(String scrollSelectorValue, []), Expression(mSelectorIndexToStringCache.get(selectorIndex), [])]), Statement(// with the new one., []), AssignmentExpression(=, [VariableReference(if (i !, []), Expression(SELECTOR_MIDDLE_ITEM_INDEX || mInputText.getVisibility() !, [])]), MethodCall(canvas.drawText(scrollSelectorValue, x, y, mSelectorWheelPaint), [VariableReference(canvas, []), Expression(scrollSelectorValue, []), Expression(x, []), Expression(y, []), Expression(mSelectorWheelPaint, [])]), Statement(}, []), AssignmentExpression(=, [VariableReference(y +, []), Expression(mSelectorElementHeight, [])]), Statement(}, []), Statement(// draw the selection dividers, []), AssignmentExpression(=, [VariableReference(if (mSelectionDivider !, []), Expression(null) {, [])]), Statement(// draw the top divider, []), AssignmentExpression(=, [VariableReference(int topOfTopDivider, []), Expression(mTopSelectionDividerTop, [])]), AssignmentExpression(=, [VariableReference(int bottomOfTopDivider, []), Expression(topOfTopDivider + mSelectionDividerHeight, [])]), MethodCall(mSelectionDivider.setBounds(0, topOfTopDivider, mRight, bottomOfTopDivider), [VariableReference(mSelectionDivider, []), Expression(0, []), Expression(topOfTopDivider, []), Expression(mRight, []), Expression(bottomOfTopDivider, [])]), MethodCall(mSelectionDivider.draw(canvas), [VariableReference(mSelectionDivider, []), Expression(canvas, [])]), Statement(// draw the bottom divider, []), AssignmentExpression(=, [VariableReference(int bottomOfBottomDivider, []), Expression(mBottomSelectionDividerBottom, [])]), AssignmentExpression(=, [VariableReference(int topOfBottomDivider, []), Expression(bottomOfBottomDivider - mSelectionDividerHeight, [])]), MethodCall(mSelectionDivider.setBounds(0, topOfBottomDivider, mRight, bottomOfBottomDivider), [VariableReference(mSelectionDivider, []), Expression(0, []), Expression(topOfBottomDivider, []), Expression(mRight, []), Expression(bottomOfBottomDivider, [])]), MethodCall(mSelectionDivider.draw(canvas), [VariableReference(mSelectionDivider, []), Expression(canvas, [])]), Statement(}, []), Statement(}, [])])  Statement({, [])  Statement(if (!mHasSelectorWheel) {, [])  MethodCall(super.onDraw(canvas), [VariableReference(super, []), Expression(canvas, [])])    VariableReference(super, [])    Expression(canvas, [])  Statement(return, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(float x, []), Expression((mRight - mLeft) / 2, [])])    VariableReference(float x, [])    Expression((mRight - mLeft) / 2, [])  AssignmentExpression(=, [VariableReference(float y, []), Expression(mCurrentScrollOffset, [])])    VariableReference(float y, [])    Expression(mCurrentScrollOffset, [])  Statement(// draw the virtual buttons pressed state if needed, [])  AssignmentExpression(=, [VariableReference(if (mVirtualButtonPressedDrawable !, []), Expression(null && mScrollState, [])])    VariableReference(if (mVirtualButtonPressedDrawable !, [])    Expression(null && mScrollState, [])  Statement(if (mDecrementVirtualButtonPressed) {, [])  MethodCall(mVirtualButtonPressedDrawable.setState(PRESSED_STATE_SET), [VariableReference(mVirtualButtonPressedDrawable, []), Expression(PRESSED_STATE_SET, [])])    VariableReference(mVirtualButtonPressedDrawable, [])    Expression(PRESSED_STATE_SET, [])  MethodCall(mVirtualButtonPressedDrawable.setBounds(0, 0, mRight, mTopSelectionDividerTop), [VariableReference(mVirtualButtonPressedDrawable, []), Expression(0, []), Expression(0, []), Expression(mRight, []), Expression(mTopSelectionDividerTop, [])])    VariableReference(mVirtualButtonPressedDrawable, [])    Expression(0, [])    Expression(0, [])    Expression(mRight, [])    Expression(mTopSelectionDividerTop, [])  MethodCall(mVirtualButtonPressedDrawable.draw(canvas), [VariableReference(mVirtualButtonPressedDrawable, []), Expression(canvas, [])])    VariableReference(mVirtualButtonPressedDrawable, [])    Expression(canvas, [])  Statement(}, [])  Statement(if (mIncrementVirtualButtonPressed) {, [])  MethodCall(mVirtualButtonPressedDrawable.setState(PRESSED_STATE_SET), [VariableReference(mVirtualButtonPressedDrawable, []), Expression(PRESSED_STATE_SET, [])])    VariableReference(mVirtualButtonPressedDrawable, [])    Expression(PRESSED_STATE_SET, [])  MethodCall(mVirtualButtonPressedDrawable.setBounds(0, mBottomSelectionDividerBottom, mRight, mBottom), [VariableReference(mVirtualButtonPressedDrawable, []), Expression(0, []), Expression(mBottomSelectionDividerBottom, []), Expression(mRight, []), Expression(mBottom, [])])    VariableReference(mVirtualButtonPressedDrawable, [])    Expression(0, [])    Expression(mBottomSelectionDividerBottom, [])    Expression(mRight, [])    Expression(mBottom, [])  MethodCall(mVirtualButtonPressedDrawable.draw(canvas), [VariableReference(mVirtualButtonPressedDrawable, []), Expression(canvas, [])])    VariableReference(mVirtualButtonPressedDrawable, [])    Expression(canvas, [])  Statement(}, [])  Statement(}, [])  Statement(// draw the selector wheel, [])  AssignmentExpression(=, [VariableReference(int[] selectorIndices, []), Expression(mSelectorIndices, [])])    VariableReference(int[] selectorIndices, [])    Expression(mSelectorIndices, [])  AssignmentExpression(=, [VariableReference(for (int i, []), Expression(0, [])])    VariableReference(for (int i, [])    Expression(0, [])  Statement(i < selectorIndices.length, [])  Statement(i++) {, [])  AssignmentExpression(=, [VariableReference(int selectorIndex, []), Expression(selectorIndices[i], [])])    VariableReference(int selectorIndex, [])    Expression(selectorIndices[i], [])  AssignmentExpression(=, [VariableReference(String scrollSelectorValue, []), Expression(mSelectorIndexToStringCache.get(selectorIndex), [])])    VariableReference(String scrollSelectorValue, [])    Expression(mSelectorIndexToStringCache.get(selectorIndex), [])  Statement(// with the new one., [])  AssignmentExpression(=, [VariableReference(if (i !, []), Expression(SELECTOR_MIDDLE_ITEM_INDEX || mInputText.getVisibility() !, [])])    VariableReference(if (i !, [])    Expression(SELECTOR_MIDDLE_ITEM_INDEX || mInputText.getVisibility() !, [])  MethodCall(canvas.drawText(scrollSelectorValue, x, y, mSelectorWheelPaint), [VariableReference(canvas, []), Expression(scrollSelectorValue, []), Expression(x, []), Expression(y, []), Expression(mSelectorWheelPaint, [])])    VariableReference(canvas, [])    Expression(scrollSelectorValue, [])    Expression(x, [])    Expression(y, [])    Expression(mSelectorWheelPaint, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(y +, []), Expression(mSelectorElementHeight, [])])    VariableReference(y +, [])    Expression(mSelectorElementHeight, [])  Statement(}, [])  Statement(// draw the selection dividers, [])  AssignmentExpression(=, [VariableReference(if (mSelectionDivider !, []), Expression(null) {, [])])    VariableReference(if (mSelectionDivider !, [])    Expression(null) {, [])  Statement(// draw the top divider, [])  AssignmentExpression(=, [VariableReference(int topOfTopDivider, []), Expression(mTopSelectionDividerTop, [])])    VariableReference(int topOfTopDivider, [])    Expression(mTopSelectionDividerTop, [])  AssignmentExpression(=, [VariableReference(int bottomOfTopDivider, []), Expression(topOfTopDivider + mSelectionDividerHeight, [])])    VariableReference(int bottomOfTopDivider, [])    Expression(topOfTopDivider + mSelectionDividerHeight, [])  MethodCall(mSelectionDivider.setBounds(0, topOfTopDivider, mRight, bottomOfTopDivider), [VariableReference(mSelectionDivider, []), Expression(0, []), Expression(topOfTopDivider, []), Expression(mRight, []), Expression(bottomOfTopDivider, [])])    VariableReference(mSelectionDivider, [])    Expression(0, [])    Expression(topOfTopDivider, [])    Expression(mRight, [])    Expression(bottomOfTopDivider, [])  MethodCall(mSelectionDivider.draw(canvas), [VariableReference(mSelectionDivider, []), Expression(canvas, [])])    VariableReference(mSelectionDivider, [])    Expression(canvas, [])  Statement(// draw the bottom divider, [])  AssignmentExpression(=, [VariableReference(int bottomOfBottomDivider, []), Expression(mBottomSelectionDividerBottom, [])])    VariableReference(int bottomOfBottomDivider, [])    Expression(mBottomSelectionDividerBottom, [])  AssignmentExpression(=, [VariableReference(int topOfBottomDivider, []), Expression(bottomOfBottomDivider - mSelectionDividerHeight, [])])    VariableReference(int topOfBottomDivider, [])    Expression(bottomOfBottomDivider - mSelectionDividerHeight, [])  MethodCall(mSelectionDivider.setBounds(0, topOfBottomDivider, mRight, bottomOfBottomDivider), [VariableReference(mSelectionDivider, []), Expression(0, []), Expression(topOfBottomDivider, []), Expression(mRight, []), Expression(bottomOfBottomDivider, [])])    VariableReference(mSelectionDivider, [])    Expression(0, [])    Expression(topOfBottomDivider, [])    Expression(mRight, [])    Expression(bottomOfBottomDivider, [])  MethodCall(mSelectionDivider.draw(canvas), [VariableReference(mSelectionDivider, []), Expression(canvas, [])])    VariableReference(mSelectionDivider, [])    Expression(canvas, [])  Statement(}, [])  Statement(}, [])",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,"3,4",0,"3,4",0,"This change involves multiple control dependency changes. In the late version, a new conditional check (`if (!mHasSelectorWheel)`) is added at the beginning of the method, and inside it, `super.onDraw(canvas)` is called followed by `return`. Additionally, several statements related to drawing virtual button pressed states (`if (mVirtualButtonPressedDrawable != null && mScrollState)`, `if (mDecrementVirtualButtonPressed)`, and `if (mIncrementVirtualButtonPressed)`) are introduced. These are under control dependencies, hence code change type is 3,4.","Although the changes to conditional logic and drawing statements are significant, they do not directly affect the return value or throw new exceptions. The method still draws on a canvas, and no new exceptions or return types are introduced. Thus, no CI exists."
1109,<android.hardware.camera2.legacy.CameraDeviceUserShim: int createStream(OutputConfiguration)>,23,24,<android.hardware.camera2.legacy.CameraDeviceUserShim: int createStream(OutputConfiguration)>,<android.hardware.camera2.legacy.CameraDeviceUserShim: int createStream(OutputConfiguration)>,0,"MethodDeclaration(method_body, [Statement({, []), Statement(if (DEBUG) {, []), MethodCall(Log.d(TAG, ""createStream called.""), [VariableReference(Log, []), Expression(TAG, []), Expression(""createStream called."", [])]), Statement(}, []), MethodCall(if (mLegacyDevice.isClosed()), [VariableReference(if (mLegacyDevice, []), Expression(), [])]), MethodCall(Log.e(TAG, ""Cannot create stream, device has been closed.""), [VariableReference(Log, []), Expression(TAG, []), Expression(""Cannot create stream, []), Expression(device has been closed."", [])]), Statement(return CameraBinderDecorator.ENODEV, []), Statement(}, []), Statement(synchronized (mConfigureLock) {, []), Statement(if (!mConfiguring) {, []), MethodCall(Log.e(TAG, ""Cannot create stream, beginConfigure hasn't been called yet.""), [VariableReference(Log, []), Expression(TAG, []), Expression(""Cannot create stream, []), Expression(beginConfigure hasn't been called yet."", [])]), Statement(return CameraBinderDecorator.INVALID_OPERATION, []), Statement(}, []), AssignmentExpression(=, [VariableReference(if (outputConfiguration.getRotation() !, []), Expression(OutputConfiguration.ROTATION_0) {, [])]), MethodCall(Log.e(TAG, ""Cannot create stream, stream rotation is not supported.""), [VariableReference(Log, []), Expression(TAG, []), Expression(""Cannot create stream, []), Expression(stream rotation is not supported."", [])]), Statement(return CameraBinderDecorator.INVALID_OPERATION, []), Statement(}, []), AssignmentExpression(=, [VariableReference(int id, []), Expression(++mSurfaceIdCounter, [])]), MethodCall(mSurfaces.put(id, outputConfiguration.getSurface()), [VariableReference(mSurfaces, []), Expression(id, []), Expression(outputConfiguration.getSurface(), [])]), Statement(return id, []), Statement(}, []), Statement(}, [])])  Statement({, [])  Statement(if (DEBUG) {, [])  MethodCall(Log.d(TAG, ""createStream called.""), [VariableReference(Log, []), Expression(TAG, []), Expression(""createStream called."", [])])    VariableReference(Log, [])    Expression(TAG, [])    Expression(""createStream called."", [])  Statement(}, [])  MethodCall(if (mLegacyDevice.isClosed()), [VariableReference(if (mLegacyDevice, []), Expression(), [])])    VariableReference(if (mLegacyDevice, [])    Expression(), [])  MethodCall(Log.e(TAG, ""Cannot create stream, device has been closed.""), [VariableReference(Log, []), Expression(TAG, []), Expression(""Cannot create stream, []), Expression(device has been closed."", [])])    VariableReference(Log, [])    Expression(TAG, [])    Expression(""Cannot create stream, [])    Expression(device has been closed."", [])  Statement(return CameraBinderDecorator.ENODEV, [])  Statement(}, [])  Statement(synchronized (mConfigureLock) {, [])  Statement(if (!mConfiguring) {, [])  MethodCall(Log.e(TAG, ""Cannot create stream, beginConfigure hasn't been called yet.""), [VariableReference(Log, []), Expression(TAG, []), Expression(""Cannot create stream, []), Expression(beginConfigure hasn't been called yet."", [])])    VariableReference(Log, [])    Expression(TAG, [])    Expression(""Cannot create stream, [])    Expression(beginConfigure hasn't been called yet."", [])  Statement(return CameraBinderDecorator.INVALID_OPERATION, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(if (outputConfiguration.getRotation() !, []), Expression(OutputConfiguration.ROTATION_0) {, [])])    VariableReference(if (outputConfiguration.getRotation() !, [])    Expression(OutputConfiguration.ROTATION_0) {, [])  MethodCall(Log.e(TAG, ""Cannot create stream, stream rotation is not supported.""), [VariableReference(Log, []), Expression(TAG, []), Expression(""Cannot create stream, []), Expression(stream rotation is not supported."", [])])    VariableReference(Log, [])    Expression(TAG, [])    Expression(""Cannot create stream, [])    Expression(stream rotation is not supported."", [])  Statement(return CameraBinderDecorator.INVALID_OPERATION, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(int id, []), Expression(++mSurfaceIdCounter, [])])    VariableReference(int id, [])    Expression(++mSurfaceIdCounter, [])  MethodCall(mSurfaces.put(id, outputConfiguration.getSurface()), [VariableReference(mSurfaces, []), Expression(id, []), Expression(outputConfiguration.getSurface(), [])])    VariableReference(mSurfaces, [])    Expression(id, [])    Expression(outputConfiguration.getSurface(), [])  Statement(return id, [])  Statement(}, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(if (DEBUG) {, []), MethodCall(Log.d(TAG, ""createStream called.""), [VariableReference(Log, []), Expression(TAG, []), Expression(""createStream called."", [])]), Statement(}, []), MethodCall(if (mLegacyDevice.isClosed()), [VariableReference(if (mLegacyDevice, []), Expression(), [])]), AssignmentExpression(=, [VariableReference(String err, []), Expression(""Cannot create stream, device has been closed."", [])]), MethodCall(Log.e(TAG, err), [VariableReference(Log, []), Expression(TAG, []), Expression(err, [])]), Statement(}, []), Statement(synchronized (mConfigureLock) {, []), Statement(if (!mConfiguring) {, []), AssignmentExpression(=, [VariableReference(String err, []), Expression(""Cannot create stream, beginConfigure hasn't been called yet."", [])]), MethodCall(Log.e(TAG, err), [VariableReference(Log, []), Expression(TAG, []), Expression(err, [])]), Statement(}, []), AssignmentExpression(=, [VariableReference(if (outputConfiguration.getRotation() !, []), Expression(OutputConfiguration.ROTATION_0) {, [])]), AssignmentExpression(=, [VariableReference(String err, []), Expression(""Cannot create stream, stream rotation is not supported."", [])]), MethodCall(Log.e(TAG, err), [VariableReference(Log, []), Expression(TAG, []), Expression(err, [])]), Statement(}, []), AssignmentExpression(=, [VariableReference(int id, []), Expression(++mSurfaceIdCounter, [])]), MethodCall(mSurfaces.put(id, outputConfiguration.getSurface()), [VariableReference(mSurfaces, []), Expression(id, []), Expression(outputConfiguration.getSurface(), [])]), Statement(return id, []), Statement(}, []), Statement(}, [])])  Statement({, [])  Statement(if (DEBUG) {, [])  MethodCall(Log.d(TAG, ""createStream called.""), [VariableReference(Log, []), Expression(TAG, []), Expression(""createStream called."", [])])    VariableReference(Log, [])    Expression(TAG, [])    Expression(""createStream called."", [])  Statement(}, [])  MethodCall(if (mLegacyDevice.isClosed()), [VariableReference(if (mLegacyDevice, []), Expression(), [])])    VariableReference(if (mLegacyDevice, [])    Expression(), [])  AssignmentExpression(=, [VariableReference(String err, []), Expression(""Cannot create stream, device has been closed."", [])])    VariableReference(String err, [])    Expression(""Cannot create stream, device has been closed."", [])  MethodCall(Log.e(TAG, err), [VariableReference(Log, []), Expression(TAG, []), Expression(err, [])])    VariableReference(Log, [])    Expression(TAG, [])    Expression(err, [])  Statement(}, [])  Statement(synchronized (mConfigureLock) {, [])  Statement(if (!mConfiguring) {, [])  AssignmentExpression(=, [VariableReference(String err, []), Expression(""Cannot create stream, beginConfigure hasn't been called yet."", [])])    VariableReference(String err, [])    Expression(""Cannot create stream, beginConfigure hasn't been called yet."", [])  MethodCall(Log.e(TAG, err), [VariableReference(Log, []), Expression(TAG, []), Expression(err, [])])    VariableReference(Log, [])    Expression(TAG, [])    Expression(err, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(if (outputConfiguration.getRotation() !, []), Expression(OutputConfiguration.ROTATION_0) {, [])])    VariableReference(if (outputConfiguration.getRotation() !, [])    Expression(OutputConfiguration.ROTATION_0) {, [])  AssignmentExpression(=, [VariableReference(String err, []), Expression(""Cannot create stream, stream rotation is not supported."", [])])    VariableReference(String err, [])    Expression(""Cannot create stream, stream rotation is not supported."", [])  MethodCall(Log.e(TAG, err), [VariableReference(Log, []), Expression(TAG, []), Expression(err, [])])    VariableReference(Log, [])    Expression(TAG, [])    Expression(err, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(int id, []), Expression(++mSurfaceIdCounter, [])])    VariableReference(int id, [])    Expression(++mSurfaceIdCounter, [])  MethodCall(mSurfaces.put(id, outputConfiguration.getSurface()), [VariableReference(mSurfaces, []), Expression(id, []), Expression(outputConfiguration.getSurface(), [])])    VariableReference(mSurfaces, [])    Expression(id, [])    Expression(outputConfiguration.getSurface(), [])  Statement(return id, [])  Statement(}, [])  Statement(}, [])",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,"1,2,4","1,2","2,3",2,"The change involves replacing return statements with exception handling in specific control-flow branches. Specifically, return statements such as 'return CameraBinderDecorator.ENODEV' have been replaced with assigning error messages to 'err' and using Log.e to log the error.","These changes affect how exceptions are thrown since an exception will now be thrown with a message, potentially affecting client code that relies on specific return values. Hence, the CI type is 2."
1148,<android.view.TextureView: HardwareLayer getHardwareLayer()>,20,21,<android.view.TextureView: HardwareLayer getHardwareLayer()>,<android.view.TextureView: HardwareLayer getHardwareLayer()>,0,"MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(mPrivateFlags |, []), Expression(PFLAG_DRAWN | PFLAG_DRAWING_CACHE_VALID, [])]), AssignmentExpression(=, [VariableReference(mPrivateFlags &, []), Expression(~PFLAG_DIRTY_MASK, [])]), AssignmentExpression(=, [VariableReference(if (mLayer, []), Expression(, [])]), AssignmentExpression(=, [VariableReference(if (mAttachInfo, []), Expression(, [])]), Statement(return null, []), Statement(}, []), AssignmentExpression(=, [VariableReference(mLayer, []), Expression(mAttachInfo.mHardwareRenderer.createHardwareLayer(mOpaque), [])]), Statement(if (!mUpdateSurface) {, []), Statement(// Create a new SurfaceTexture for the layer., []), AssignmentExpression(=, [VariableReference(mSurface, []), Expression(mAttachInfo.mHardwareRenderer.createSurfaceTexture(mLayer), [])]), Statement(}, []), MethodCall(mSurface.setDefaultBufferSize(getWidth(), getHeight()), [VariableReference(mSurface, []), Expression(getWidth(), []), Expression(getHeight(), [])]), Statement(nCreateNativeWindow(mSurface), []), AssignmentExpression(=, [VariableReference(mUpdateListener, []), Expression(new SurfaceTexture.OnFrameAvailableListener() {, [])]), Statement(@Override, []), Statement(public void onFrameAvailable(SurfaceTexture surfaceTexture) {, []), Statement(// Per SurfaceTexture's documentation, the callback may be invoked, []), Statement(// from an arbitrary thread, []), Statement(updateLayer(), []), AssignmentExpression(=, [VariableReference(if (Looper.myLooper(), []), Expression(, [])]), Statement(invalidate(), []), Statement(} else {, []), Statement(postInvalidate(), []), Statement(}, []), Statement(}, []), Statement(}, []), MethodCall(mSurface.setOnFrameAvailableListener(mUpdateListener), [VariableReference(mSurface, []), Expression(mUpdateListener, [])]), AssignmentExpression(=, [VariableReference(if (mListener !, []), Expression(null && !mUpdateSurface) {, [])]), MethodCall(mListener.onSurfaceTextureAvailable(mSurface, getWidth(), getHeight()), [VariableReference(mListener, []), Expression(mSurface, []), Expression(getWidth(), []), Expression(getHeight(), [])]), Statement(}, []), MethodCall(mLayer.setLayerPaint(mLayerPaint), [VariableReference(mLayer, []), Expression(mLayerPaint, [])]), Statement(}, []), Statement(if (mUpdateSurface) {, []), Statement(// Someone has requested that we use a specific SurfaceTexture, so, []), Statement(// tell mLayer about it and set the SurfaceTexture to use the, []), Statement(// current view size., []), AssignmentExpression(=, [VariableReference(mUpdateSurface, []), Expression(false, [])]), Statement(// Since we are updating the layer, force an update to ensure its, []), Statement(updateLayer(), []), AssignmentExpression(=, [VariableReference(mMatrixChanged, []), Expression(true, [])]), MethodCall(mSurface.setDefaultBufferSize(getWidth(), getHeight()), [VariableReference(mSurface, []), Expression(getWidth(), []), Expression(getHeight(), [])]), Statement(}, []), Statement(applyUpdate(), []), Statement(applyTransformMatrix(), []), Statement(return mLayer, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(mPrivateFlags |, []), Expression(PFLAG_DRAWN | PFLAG_DRAWING_CACHE_VALID, [])])    VariableReference(mPrivateFlags |, [])    Expression(PFLAG_DRAWN | PFLAG_DRAWING_CACHE_VALID, [])  AssignmentExpression(=, [VariableReference(mPrivateFlags &, []), Expression(~PFLAG_DIRTY_MASK, [])])    VariableReference(mPrivateFlags &, [])    Expression(~PFLAG_DIRTY_MASK, [])  AssignmentExpression(=, [VariableReference(if (mLayer, []), Expression(, [])])    VariableReference(if (mLayer, [])    Expression(, [])  AssignmentExpression(=, [VariableReference(if (mAttachInfo, []), Expression(, [])])    VariableReference(if (mAttachInfo, [])    Expression(, [])  Statement(return null, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(mLayer, []), Expression(mAttachInfo.mHardwareRenderer.createHardwareLayer(mOpaque), [])])    VariableReference(mLayer, [])    Expression(mAttachInfo.mHardwareRenderer.createHardwareLayer(mOpaque), [])  Statement(if (!mUpdateSurface) {, [])  Statement(// Create a new SurfaceTexture for the layer., [])  AssignmentExpression(=, [VariableReference(mSurface, []), Expression(mAttachInfo.mHardwareRenderer.createSurfaceTexture(mLayer), [])])    VariableReference(mSurface, [])    Expression(mAttachInfo.mHardwareRenderer.createSurfaceTexture(mLayer), [])  Statement(}, [])  MethodCall(mSurface.setDefaultBufferSize(getWidth(), getHeight()), [VariableReference(mSurface, []), Expression(getWidth(), []), Expression(getHeight(), [])])    VariableReference(mSurface, [])    Expression(getWidth(), [])    Expression(getHeight(), [])  Statement(nCreateNativeWindow(mSurface), [])  AssignmentExpression(=, [VariableReference(mUpdateListener, []), Expression(new SurfaceTexture.OnFrameAvailableListener() {, [])])    VariableReference(mUpdateListener, [])    Expression(new SurfaceTexture.OnFrameAvailableListener() {, [])  Statement(@Override, [])  Statement(public void onFrameAvailable(SurfaceTexture surfaceTexture) {, [])  Statement(// Per SurfaceTexture's documentation, the callback may be invoked, [])  Statement(// from an arbitrary thread, [])  Statement(updateLayer(), [])  AssignmentExpression(=, [VariableReference(if (Looper.myLooper(), []), Expression(, [])])    VariableReference(if (Looper.myLooper(), [])    Expression(, [])  Statement(invalidate(), [])  Statement(} else {, [])  Statement(postInvalidate(), [])  Statement(}, [])  Statement(}, [])  Statement(}, [])  MethodCall(mSurface.setOnFrameAvailableListener(mUpdateListener), [VariableReference(mSurface, []), Expression(mUpdateListener, [])])    VariableReference(mSurface, [])    Expression(mUpdateListener, [])  AssignmentExpression(=, [VariableReference(if (mListener !, []), Expression(null && !mUpdateSurface) {, [])])    VariableReference(if (mListener !, [])    Expression(null && !mUpdateSurface) {, [])  MethodCall(mListener.onSurfaceTextureAvailable(mSurface, getWidth(), getHeight()), [VariableReference(mListener, []), Expression(mSurface, []), Expression(getWidth(), []), Expression(getHeight(), [])])    VariableReference(mListener, [])    Expression(mSurface, [])    Expression(getWidth(), [])    Expression(getHeight(), [])  Statement(}, [])  MethodCall(mLayer.setLayerPaint(mLayerPaint), [VariableReference(mLayer, []), Expression(mLayerPaint, [])])    VariableReference(mLayer, [])    Expression(mLayerPaint, [])  Statement(}, [])  Statement(if (mUpdateSurface) {, [])  Statement(// Someone has requested that we use a specific SurfaceTexture, so, [])  Statement(// tell mLayer about it and set the SurfaceTexture to use the, [])  Statement(// current view size., [])  AssignmentExpression(=, [VariableReference(mUpdateSurface, []), Expression(false, [])])    VariableReference(mUpdateSurface, [])    Expression(false, [])  Statement(// Since we are updating the layer, force an update to ensure its, [])  Statement(updateLayer(), [])  AssignmentExpression(=, [VariableReference(mMatrixChanged, []), Expression(true, [])])    VariableReference(mMatrixChanged, [])    Expression(true, [])  MethodCall(mSurface.setDefaultBufferSize(getWidth(), getHeight()), [VariableReference(mSurface, []), Expression(getWidth(), []), Expression(getHeight(), [])])    VariableReference(mSurface, [])    Expression(getWidth(), [])    Expression(getHeight(), [])  Statement(}, [])  Statement(applyUpdate(), [])  Statement(applyTransformMatrix(), [])  Statement(return mLayer, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(mPrivateFlags |, []), Expression(PFLAG_DRAWN | PFLAG_DRAWING_CACHE_VALID, [])]), AssignmentExpression(=, [VariableReference(mPrivateFlags &, []), Expression(~PFLAG_DIRTY_MASK, [])]), AssignmentExpression(=, [VariableReference(if (mLayer, []), Expression(, [])]), AssignmentExpression(=, [VariableReference(if (mAttachInfo, []), Expression(, [])]), Statement(return null, []), Statement(}, []), AssignmentExpression(=, [VariableReference(mLayer, []), Expression(mAttachInfo.mHardwareRenderer.createTextureLayer(), [])]), Statement(if (!mUpdateSurface) {, []), Statement(// Create a new SurfaceTexture for the layer., []), AssignmentExpression(=, [VariableReference(mSurface, []), Expression(new SurfaceTexture(false), [])]), MethodCall(mLayer.setSurfaceTexture(mSurface), [VariableReference(mLayer, []), Expression(mSurface, [])]), Statement(}, []), MethodCall(mSurface.setDefaultBufferSize(getWidth(), getHeight()), [VariableReference(mSurface, []), Expression(getWidth(), []), Expression(getHeight(), [])]), Statement(nCreateNativeWindow(mSurface), []), MethodCall(mSurface.setOnFrameAvailableListener(mUpdateListener, mAttachInfo.mHandler), [VariableReference(mSurface, []), Expression(mUpdateListener, []), Expression(mAttachInfo.mHandler, [])]), AssignmentExpression(=, [VariableReference(if (mListener !, []), Expression(null && !mUpdateSurface) {, [])]), MethodCall(mListener.onSurfaceTextureAvailable(mSurface, getWidth(), getHeight()), [VariableReference(mListener, []), Expression(mSurface, []), Expression(getWidth(), []), Expression(getHeight(), [])]), Statement(}, []), MethodCall(mLayer.setLayerPaint(mLayerPaint), [VariableReference(mLayer, []), Expression(mLayerPaint, [])]), Statement(}, []), Statement(if (mUpdateSurface) {, []), Statement(// Someone has requested that we use a specific SurfaceTexture, so, []), Statement(// tell mLayer about it and set the SurfaceTexture to use the, []), Statement(// current view size., []), AssignmentExpression(=, [VariableReference(mUpdateSurface, []), Expression(false, [])]), Statement(// Since we are updating the layer, force an update to ensure its, []), Statement(updateLayer(), []), AssignmentExpression(=, [VariableReference(mMatrixChanged, []), Expression(true, [])]), MethodCall(mLayer.setSurfaceTexture(mSurface), [VariableReference(mLayer, []), Expression(mSurface, [])]), MethodCall(mSurface.setDefaultBufferSize(getWidth(), getHeight()), [VariableReference(mSurface, []), Expression(getWidth(), []), Expression(getHeight(), [])]), Statement(}, []), Statement(applyUpdate(), []), Statement(applyTransformMatrix(), []), Statement(return mLayer, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(mPrivateFlags |, []), Expression(PFLAG_DRAWN | PFLAG_DRAWING_CACHE_VALID, [])])    VariableReference(mPrivateFlags |, [])    Expression(PFLAG_DRAWN | PFLAG_DRAWING_CACHE_VALID, [])  AssignmentExpression(=, [VariableReference(mPrivateFlags &, []), Expression(~PFLAG_DIRTY_MASK, [])])    VariableReference(mPrivateFlags &, [])    Expression(~PFLAG_DIRTY_MASK, [])  AssignmentExpression(=, [VariableReference(if (mLayer, []), Expression(, [])])    VariableReference(if (mLayer, [])    Expression(, [])  AssignmentExpression(=, [VariableReference(if (mAttachInfo, []), Expression(, [])])    VariableReference(if (mAttachInfo, [])    Expression(, [])  Statement(return null, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(mLayer, []), Expression(mAttachInfo.mHardwareRenderer.createTextureLayer(), [])])    VariableReference(mLayer, [])    Expression(mAttachInfo.mHardwareRenderer.createTextureLayer(), [])  Statement(if (!mUpdateSurface) {, [])  Statement(// Create a new SurfaceTexture for the layer., [])  AssignmentExpression(=, [VariableReference(mSurface, []), Expression(new SurfaceTexture(false), [])])    VariableReference(mSurface, [])    Expression(new SurfaceTexture(false), [])  MethodCall(mLayer.setSurfaceTexture(mSurface), [VariableReference(mLayer, []), Expression(mSurface, [])])    VariableReference(mLayer, [])    Expression(mSurface, [])  Statement(}, [])  MethodCall(mSurface.setDefaultBufferSize(getWidth(), getHeight()), [VariableReference(mSurface, []), Expression(getWidth(), []), Expression(getHeight(), [])])    VariableReference(mSurface, [])    Expression(getWidth(), [])    Expression(getHeight(), [])  Statement(nCreateNativeWindow(mSurface), [])  MethodCall(mSurface.setOnFrameAvailableListener(mUpdateListener, mAttachInfo.mHandler), [VariableReference(mSurface, []), Expression(mUpdateListener, []), Expression(mAttachInfo.mHandler, [])])    VariableReference(mSurface, [])    Expression(mUpdateListener, [])    Expression(mAttachInfo.mHandler, [])  AssignmentExpression(=, [VariableReference(if (mListener !, []), Expression(null && !mUpdateSurface) {, [])])    VariableReference(if (mListener !, [])    Expression(null && !mUpdateSurface) {, [])  MethodCall(mListener.onSurfaceTextureAvailable(mSurface, getWidth(), getHeight()), [VariableReference(mListener, []), Expression(mSurface, []), Expression(getWidth(), []), Expression(getHeight(), [])])    VariableReference(mListener, [])    Expression(mSurface, [])    Expression(getWidth(), [])    Expression(getHeight(), [])  Statement(}, [])  MethodCall(mLayer.setLayerPaint(mLayerPaint), [VariableReference(mLayer, []), Expression(mLayerPaint, [])])    VariableReference(mLayer, [])    Expression(mLayerPaint, [])  Statement(}, [])  Statement(if (mUpdateSurface) {, [])  Statement(// Someone has requested that we use a specific SurfaceTexture, so, [])  Statement(// tell mLayer about it and set the SurfaceTexture to use the, [])  Statement(// current view size., [])  AssignmentExpression(=, [VariableReference(mUpdateSurface, []), Expression(false, [])])    VariableReference(mUpdateSurface, [])    Expression(false, [])  Statement(// Since we are updating the layer, force an update to ensure its, [])  Statement(updateLayer(), [])  AssignmentExpression(=, [VariableReference(mMatrixChanged, []), Expression(true, [])])    VariableReference(mMatrixChanged, [])    Expression(true, [])  MethodCall(mLayer.setSurfaceTexture(mSurface), [VariableReference(mLayer, []), Expression(mSurface, [])])    VariableReference(mLayer, [])    Expression(mSurface, [])  MethodCall(mSurface.setDefaultBufferSize(getWidth(), getHeight()), [VariableReference(mSurface, []), Expression(getWidth(), []), Expression(getHeight(), [])])    VariableReference(mSurface, [])    Expression(getWidth(), [])    Expression(getHeight(), [])  Statement(}, [])  Statement(applyUpdate(), [])  Statement(applyTransformMatrix(), [])  Statement(return mLayer, [])  Statement(}, [])",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,"3,4",0,"3,4",0,"The implementation has changes in control dependencies and other statements, specifically, the late version replaces `mAttachInfo.mHardwareRenderer.createHardwareLayer(mOpaque)` with `mAttachInfo.mHardwareRenderer.createTextureLayer()`, and different ways of creating and setting the SurfaceTexture.","Despite these changes, the produced `HardwareLayer` object returned as `mLayer` does not appear to present potential for different return types or values, nor does it lead to changes in exceptions. Thus, no Compatibility Issue (CI) exists."
867,"<android.view.GLES20Canvas: boolean clipRegion(Region,Op)>",15,16,"<android.view.GLES20Canvas: boolean clipRegion(Region,Op)>","<android.view.GLES20Canvas: boolean clipRegion(Region,Op)>",0,"MethodDeclaration(method_body, [Statement({, []), Statement(throw new UnsupportedOperationException(), []), Statement(}, [])])  Statement({, [])  Statement(throw new UnsupportedOperationException(), [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(// TODO: Implement, []), MethodCall(region.getBounds(mClipBounds), [VariableReference(region, []), Expression(mClipBounds, [])]), Statement(}, [])])  Statement({, [])  Statement(// TODO: Implement, [])  MethodCall(region.getBounds(mClipBounds), [VariableReference(region, []), Expression(mClipBounds, [])])    VariableReference(region, [])    Expression(mClipBounds, [])  Statement(}, [])",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,"1,2,4","1,2",4,0,"The implementation has moved from throwing an `UnsupportedOperationException` to including a method call (region.getBounds(mClipBounds)), indicating a new behavior. However, it is marked with a TODO comment suggesting that the full implementation is still pending, so the change type is 4.","Although the method now includes an implementation that suggests further work is pending (because of the TODO comment), it does not fundamentally alter the API's behavior; i.e. it still seems to be a placeholder. Therefore, no Compatibility Issue exists for now."
550,<android.os.RemoteCallbackList: int beginBroadcast()>,18,19,<android.os.RemoteCallbackList: int beginBroadcast()>,<android.os.RemoteCallbackList: int beginBroadcast()>,0,"MethodDeclaration(method_body, [Statement({, []), Statement(synchronized (mCallbacks) {, []), Statement(if (mBroadcastCount > 0) {, []), Statement(throw new IllegalStateException(""beginBroadcast() called while already in a broadcast""), []), Statement(}, []), AssignmentExpression(=, [VariableReference(final int N, []), Expression(mBroadcastCount, [])]), AssignmentExpression(=, [VariableReference(if (N <, []), Expression(0) {, [])]), Statement(return 0, []), Statement(}, []), AssignmentExpression(=, [VariableReference(Object[] active, []), Expression(mActiveBroadcast, [])]), AssignmentExpression(=, [VariableReference(if (active, []), Expression(, [])]), AssignmentExpression(=, [VariableReference(mActiveBroadcast, []), Expression(active, [])]), Statement(}, []), AssignmentExpression(=, [VariableReference(int i, []), Expression(0, [])]), MethodCall(for (Callback cb : mCallbacks.values()), [VariableReference(for (Callback cb : mCallbacks, []), Expression(), [])]), AssignmentExpression(=, [VariableReference(active[i++], []), Expression(cb, [])]), Statement(}, []), Statement(return i, []), Statement(}, []), Statement(}, [])])  Statement({, [])  Statement(synchronized (mCallbacks) {, [])  Statement(if (mBroadcastCount > 0) {, [])  Statement(throw new IllegalStateException(""beginBroadcast() called while already in a broadcast""), [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(final int N, []), Expression(mBroadcastCount, [])])    VariableReference(final int N, [])    Expression(mBroadcastCount, [])  AssignmentExpression(=, [VariableReference(if (N <, []), Expression(0) {, [])])    VariableReference(if (N <, [])    Expression(0) {, [])  Statement(return 0, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(Object[] active, []), Expression(mActiveBroadcast, [])])    VariableReference(Object[] active, [])    Expression(mActiveBroadcast, [])  AssignmentExpression(=, [VariableReference(if (active, []), Expression(, [])])    VariableReference(if (active, [])    Expression(, [])  AssignmentExpression(=, [VariableReference(mActiveBroadcast, []), Expression(active, [])])    VariableReference(mActiveBroadcast, [])    Expression(active, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(int i, []), Expression(0, [])])    VariableReference(int i, [])    Expression(0, [])  MethodCall(for (Callback cb : mCallbacks.values()), [VariableReference(for (Callback cb : mCallbacks, []), Expression(), [])])    VariableReference(for (Callback cb : mCallbacks, [])    Expression(), [])  AssignmentExpression(=, [VariableReference(active[i++], []), Expression(cb, [])])    VariableReference(active[i++], [])    Expression(cb, [])  Statement(}, [])  Statement(return i, [])  Statement(}, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(synchronized (mCallbacks) {, []), Statement(if (mBroadcastCount > 0) {, []), Statement(throw new IllegalStateException(""beginBroadcast() called while already in a broadcast""), []), Statement(}, []), AssignmentExpression(=, [VariableReference(final int N, []), Expression(mBroadcastCount, [])]), AssignmentExpression(=, [VariableReference(if (N <, []), Expression(0) {, [])]), Statement(return 0, []), Statement(}, []), AssignmentExpression(=, [VariableReference(Object[] active, []), Expression(mActiveBroadcast, [])]), AssignmentExpression(=, [VariableReference(if (active, []), Expression(, [])]), AssignmentExpression(=, [VariableReference(mActiveBroadcast, []), Expression(active, [])]), Statement(}, []), AssignmentExpression(=, [VariableReference(for (int i, []), Expression(0, [])]), Statement(i < N, []), Statement(i++) {, []), AssignmentExpression(=, [VariableReference(active[i], []), Expression(mCallbacks.valueAt(i), [])]), Statement(}, []), Statement(return N, []), Statement(}, []), Statement(}, [])])  Statement({, [])  Statement(synchronized (mCallbacks) {, [])  Statement(if (mBroadcastCount > 0) {, [])  Statement(throw new IllegalStateException(""beginBroadcast() called while already in a broadcast""), [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(final int N, []), Expression(mBroadcastCount, [])])    VariableReference(final int N, [])    Expression(mBroadcastCount, [])  AssignmentExpression(=, [VariableReference(if (N <, []), Expression(0) {, [])])    VariableReference(if (N <, [])    Expression(0) {, [])  Statement(return 0, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(Object[] active, []), Expression(mActiveBroadcast, [])])    VariableReference(Object[] active, [])    Expression(mActiveBroadcast, [])  AssignmentExpression(=, [VariableReference(if (active, []), Expression(, [])])    VariableReference(if (active, [])    Expression(, [])  AssignmentExpression(=, [VariableReference(mActiveBroadcast, []), Expression(active, [])])    VariableReference(mActiveBroadcast, [])    Expression(active, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(for (int i, []), Expression(0, [])])    VariableReference(for (int i, [])    Expression(0, [])  Statement(i < N, [])  Statement(i++) {, [])  AssignmentExpression(=, [VariableReference(active[i], []), Expression(mCallbacks.valueAt(i), [])])    VariableReference(active[i], [])    Expression(mCallbacks.valueAt(i), [])  Statement(}, [])  Statement(return N, [])  Statement(}, [])  Statement(}, [])",1,"/**
 * Prepare to start making calls to the currently registered callbacks.
 * This creates a copy of the callback list, which you can retrieve items
 * from using {@link #getBroadcastItem}.  Note that only one broadcast can
 * be active at a time, so you must be sure to always call this from the
 * same thread (usually by scheduling with {@link Handler}) or
 * do your own synchronization.  You must call {@link #finishBroadcast}
 * when done.
 *
 * <p>A typical loop delivering a broadcast looks like this:
 *
 * <pre>
 * int i = callbacks.beginBroadcast();
 * while (i &gt; 0) {
 * i--;
 * try {
 * callbacks.getBroadcastItem(i).somethingHappened();
 * } catch (RemoteException e) {
 * // The RemoteCallbackList will take care of removing
 * // the dead object for us.
 * }
 * }
 * callbacks.finishBroadcast();</pre>
 *
 * @return Returns the number of callbacks in the broadcast, to be used
 * with {@link #getBroadcastItem} to determine the range of indices you
 * can supply.
 *
 * @see #getBroadcastItem
 * @see #finishBroadcast
 */
","/**
 * Prepare to start making calls to the currently registered callbacks.
 * This creates a copy of the callback list, which you can retrieve items
 * from using {@link #getBroadcastItem}.  Note that only one broadcast can
 * be active at a time, so you must be sure to always call this from the
 * same thread (usually by scheduling with {@link Handler}) or
 * do your own synchronization.  You must call {@link #finishBroadcast}
 * when done.
 *
 * <p>A typical loop delivering a broadcast looks like this:
 *
 * <pre>
 * int i = callbacks.beginBroadcast();
 * while (i &gt; 0) {
 * i--;
 * try {
 * callbacks.getBroadcastItem(i).somethingHappened();
 * } catch (RemoteException e) {
 * // The RemoteCallbackList will take care of removing
 * // the dead object for us.
 * }
 * }
 * callbacks.finishBroadcast();</pre>
 *
 * @return Returns the number of callbacks in the broadcast, to be used
 * with {@link #getBroadcastItem} to determine the range of indices you
 * can supply.
 *
 * @see #getBroadcastItem
 * @see #finishBroadcast
 */
",-1,,,-1,-1,-1,-1,-1,"1,4",1,3,0,"The control flow of the `for` loop has changed, including how the loop variable `i` and the array `active` are iterated through and assigned. However, as the same series of operations are being performed on the data and returned, the change type is 3.","Although the control flow has altered, it does not fundamentally change the return values or how exceptions are handled in such a way that might present a CI. Thus, no Compatibility Issue exists (CI type is 0)."
316,"<android.app.AppOpsManager: int unsafeCheckOpRawNoThrow(String,int,String)>",29,30,"<android.app.AppOpsManager: int unsafeCheckOpRawNoThrow(String,int,String)>","<android.app.AppOpsManager: int unsafeCheckOpRawNoThrow(String,int,String)>",0,"MethodDeclaration(method_body, [Statement({, []), Statement(try {, []), MethodCall(return mService.checkOperationRaw(strOpToOp(op), uid, packageName), [VariableReference(return mService, []), Expression(strOpToOp(op), []), Expression(uid, []), Expression(packageName, [])]), Statement(} catch (RemoteException e) {, []), MethodCall(throw e.rethrowFromSystemServer(), [VariableReference(throw e, []), Expression(, [])]), Statement(}, []), Statement(}, [])])  Statement({, [])  Statement(try {, [])  MethodCall(return mService.checkOperationRaw(strOpToOp(op), uid, packageName), [VariableReference(return mService, []), Expression(strOpToOp(op), []), Expression(uid, []), Expression(packageName, [])])    VariableReference(return mService, [])    Expression(strOpToOp(op), [])    Expression(uid, [])    Expression(packageName, [])  Statement(} catch (RemoteException e) {, [])  MethodCall(throw e.rethrowFromSystemServer(), [VariableReference(throw e, []), Expression(, [])])    VariableReference(throw e, [])    Expression(, [])  Statement(}, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(return unsafeCheckOpRawNoThrow(strOpToOp(op), uid, packageName), []), Statement(}, [])])  Statement({, [])  Statement(return unsafeCheckOpRawNoThrow(strOpToOp(op), uid, packageName), [])  Statement(}, [])",1,"/**
 * Like {@link #unsafeCheckOpNoThrow(String, int, String)} but returns the <em>raw</em>
 * mode associated with the op. Does not throw a security exception, does not translate
 * {@link #MODE_FOREGROUND}.
 */
","/**
 * Like {@link #unsafeCheckOpNoThrow(String, int, String)} but returns the <em>raw</em>
 * mode associated with the op. Does not throw a security exception, does not translate
 * {@link #MODE_FOREGROUND}.
 */
",-1,,,-1,-1,-1,-1,-1,4,0,"1,5",1,"The entire method body in the late version has been replaced. Instead of calling `mService.checkOperationRaw` and handling a potential `RemoteException`, the method now simply calls `unsafeCheckOpRawNoThrow`. This means the return value is now directly dependent on `unsafeCheckOpRawNoThrow`, making the code change types 1 and 5.","The change in method invocation and removal of exception handling can lead to a different return value or behavior. Therefore, the CI type is 1."
334,<android.accounts.AccountManager: String getPassword(Account)>,22,23,<android.accounts.AccountManager: String getPassword(Account)>,<android.accounts.AccountManager: String getPassword(Account)>,0,"MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(if (account, []), Expression(, [])]), Statement(throw new IllegalArgumentException(""account is null""), []), Statement(try {, []), MethodCall(return mService.getPassword(account), [VariableReference(return mService, []), Expression(account, [])]), Statement(} catch (RemoteException e) {, []), Statement(// will never happen, []), Statement(throw new RuntimeException(e), []), Statement(}, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(if (account, []), Expression(, [])])    VariableReference(if (account, [])    Expression(, [])  Statement(throw new IllegalArgumentException(""account is null""), [])  Statement(try {, [])  MethodCall(return mService.getPassword(account), [VariableReference(return mService, []), Expression(account, [])])    VariableReference(return mService, [])    Expression(account, [])  Statement(} catch (RemoteException e) {, [])  Statement(// will never happen, [])  Statement(throw new RuntimeException(e), [])  Statement(}, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(if (account, []), Expression(, [])]), Statement(throw new IllegalArgumentException(""account is null""), []), Statement(try {, []), MethodCall(return mService.getPassword(account), [VariableReference(return mService, []), Expression(account, [])]), Statement(} catch (RemoteException e) {, []), Statement(// won't ever happen, []), Statement(throw new RuntimeException(e), []), Statement(}, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(if (account, []), Expression(, [])])    VariableReference(if (account, [])    Expression(, [])  Statement(throw new IllegalArgumentException(""account is null""), [])  Statement(try {, [])  MethodCall(return mService.getPassword(account), [VariableReference(return mService, []), Expression(account, [])])    VariableReference(return mService, [])    Expression(account, [])  Statement(} catch (RemoteException e) {, [])  Statement(// won't ever happen, [])  Statement(throw new RuntimeException(e), [])  Statement(}, [])  Statement(}, [])",1,"/**
 * Gets the saved password associated with the account.
 * This is intended for authenticators and related code; applications
 * should get an auth token instead.
 *
 * <p>It is safe to call this method from the main thread.
 *
 * <p>This method requires the caller to hold the permission
 * {@link android.Manifest.permission#AUTHENTICATE_ACCOUNTS}
 * and to have the same UID as the account's authenticator.
 *
 * @param account The account to query for a password
 * @return The account's password, null if none or if the account doesn't exist
 */
","/**
 * Gets the saved password associated with the account.
 * This is intended for authenticators and related code; applications
 * should get an auth token instead.
 *
 * <p>It is safe to call this method from the main thread.
 *
 * <p>This method requires the caller to have a signature match with the
 * authenticator that owns the specified account.
 *
 * <p><b>NOTE:</b> If targeting your app to work on API level 22 and before,
 * AUTHENTICATE_ACCOUNTS permission is needed for those platforms. See docs for
 * this function in API level 22.
 *
 * @param account The account to query for a password. Must not be {@code null}.
 * @return The account's password, null if none or if the account doesn't exist
 */
",-1,,,-1,-1,-1,-1,-1,0,0,4,0,The only change is a comment text inside the catch block: from "// will never happen" to "// won't ever happen". This change does not alter the logic of the method.,"Since the change does not affect the logic or behavior of the method, there is no Compatibility Issue."
725,<android.app.ActivityManager: void killBackgroundProcesses(String)>,25,26,<android.app.ActivityManager: void killBackgroundProcesses(String)>,<android.app.ActivityManager: void killBackgroundProcesses(String)>,0,"MethodDeclaration(method_body, [Statement({, []), Statement(try {, []), MethodCall(ActivityManagerNative.getDefault().killBackgroundProcesses(packageName, UserHandle.myUserId()), [VariableReference(ActivityManagerNative, []), Expression().killBackgroundProcesses(packageName, []), Expression(UserHandle.myUserId(), [])]), Statement(} catch (RemoteException e) {, []), MethodCall(throw e.rethrowFromSystemServer(), [VariableReference(throw e, []), Expression(, [])]), Statement(}, []), Statement(}, [])])  Statement({, [])  Statement(try {, [])  MethodCall(ActivityManagerNative.getDefault().killBackgroundProcesses(packageName, UserHandle.myUserId()), [VariableReference(ActivityManagerNative, []), Expression().killBackgroundProcesses(packageName, []), Expression(UserHandle.myUserId(), [])])    VariableReference(ActivityManagerNative, [])    Expression().killBackgroundProcesses(packageName, [])    Expression(UserHandle.myUserId(), [])  Statement(} catch (RemoteException e) {, [])  MethodCall(throw e.rethrowFromSystemServer(), [VariableReference(throw e, []), Expression(, [])])    VariableReference(throw e, [])    Expression(, [])  Statement(}, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(try {, []), MethodCall(getService().killBackgroundProcesses(packageName, UserHandle.myUserId()), [VariableReference(getService(), []), Expression(packageName, []), Expression(UserHandle.myUserId(), [])]), Statement(} catch (RemoteException e) {, []), MethodCall(throw e.rethrowFromSystemServer(), [VariableReference(throw e, []), Expression(, [])]), Statement(}, []), Statement(}, [])])  Statement({, [])  Statement(try {, [])  MethodCall(getService().killBackgroundProcesses(packageName, UserHandle.myUserId()), [VariableReference(getService(), []), Expression(packageName, []), Expression(UserHandle.myUserId(), [])])    VariableReference(getService(), [])    Expression(packageName, [])    Expression(UserHandle.myUserId(), [])  Statement(} catch (RemoteException e) {, [])  MethodCall(throw e.rethrowFromSystemServer(), [VariableReference(throw e, []), Expression(, [])])    VariableReference(throw e, [])    Expression(, [])  Statement(}, [])  Statement(}, [])",1,"/**
 * Have the system immediately kill all background processes associated
 * with the given package.  This is the same as the kernel killing those
 * processes to reclaim memory; the system will take care of restarting
 * these processes in the future as needed.
 *
 * <p>You must hold the permission
 * {@link android.Manifest.permission#KILL_BACKGROUND_PROCESSES} to be able to
 * call this method.
 *
 * @param packageName The name of the package whose processes are to
 * be killed.
 */
","/**
 * Have the system immediately kill all background processes associated
 * with the given package.  This is the same as the kernel killing those
 * processes to reclaim memory; the system will take care of restarting
 * these processes in the future as needed.
 *
 * @param packageName The name of the package whose processes are to
 * be killed.
 */
",-1,,[@RequiresPermission(Manifest.permission.KILL_BACKGROUND_PROCESSES)],-1,-1,-1,-1,-1,4,0,5,0,"The method call has changed from `ActivityManagerNative.getDefault().killBackgroundProcesses` to `getService().killBackgroundProcesses`, which indicates a change in the dependent API.","While there is an API dependency change, if `getService()` properly serves as a replacement for `ActivityManagerNative.getDefault()`, then the overall functionality would remain the same. Thus, no CI is detected in this context related to return values or exceptions."
60,<android.view.accessibility.AccessibilityNodeInfo: AccessibilityNodeInfo getChild(int)>,32,33,,,,"MethodDeclaration(method_body, [Statement({, []), Statement(enforceSealed(), []), AssignmentExpression(=, [VariableReference(if (mChildNodeIds, []), Expression(, [])]), Statement(return null, []), Statement(}, []), Statement(if (!canPerformRequestOverConnection(mConnectionId, mWindowId, mSourceNodeId)) {, []), Statement(return null, []), Statement(}, []), AssignmentExpression(=, [VariableReference(final long childId, []), Expression(mChildNodeIds.get(index), [])]), AssignmentExpression(=, [VariableReference(final AccessibilityInteractionClient client, []), Expression(AccessibilityInteractionClient.getInstance(), [])]), AssignmentExpression(=, [VariableReference(if (mLeashedChild !, []), Expression(null && childId, [])]), MethodCall(return client.findAccessibilityNodeInfoByAccessibilityId(mConnectionId, mLeashedChild, ROOT_NODE_ID, false, FLAG_PREFETCH_DESCENDANTS, null), [VariableReference(return client, []), Expression(mConnectionId, []), Expression(mLeashedChild, []), Expression(ROOT_NODE_ID, []), Expression(false, []), Expression(FLAG_PREFETCH_DESCENDANTS, []), Expression(null, [])]), Statement(}, []), MethodCall(return client.findAccessibilityNodeInfoByAccessibilityId(mConnectionId, mWindowId, childId, false, FLAG_PREFETCH_DESCENDANTS, null), [VariableReference(return client, []), Expression(mConnectionId, []), Expression(mWindowId, []), Expression(childId, []), Expression(false, []), Expression(FLAG_PREFETCH_DESCENDANTS, []), Expression(null, [])]), Statement(}, [])])  Statement({, [])  Statement(enforceSealed(), [])  AssignmentExpression(=, [VariableReference(if (mChildNodeIds, []), Expression(, [])])    VariableReference(if (mChildNodeIds, [])    Expression(, [])  Statement(return null, [])  Statement(}, [])  Statement(if (!canPerformRequestOverConnection(mConnectionId, mWindowId, mSourceNodeId)) {, [])  Statement(return null, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(final long childId, []), Expression(mChildNodeIds.get(index), [])])    VariableReference(final long childId, [])    Expression(mChildNodeIds.get(index), [])  AssignmentExpression(=, [VariableReference(final AccessibilityInteractionClient client, []), Expression(AccessibilityInteractionClient.getInstance(), [])])    VariableReference(final AccessibilityInteractionClient client, [])    Expression(AccessibilityInteractionClient.getInstance(), [])  AssignmentExpression(=, [VariableReference(if (mLeashedChild !, []), Expression(null && childId, [])])    VariableReference(if (mLeashedChild !, [])    Expression(null && childId, [])  MethodCall(return client.findAccessibilityNodeInfoByAccessibilityId(mConnectionId, mLeashedChild, ROOT_NODE_ID, false, FLAG_PREFETCH_DESCENDANTS, null), [VariableReference(return client, []), Expression(mConnectionId, []), Expression(mLeashedChild, []), Expression(ROOT_NODE_ID, []), Expression(false, []), Expression(FLAG_PREFETCH_DESCENDANTS, []), Expression(null, [])])    VariableReference(return client, [])    Expression(mConnectionId, [])    Expression(mLeashedChild, [])    Expression(ROOT_NODE_ID, [])    Expression(false, [])    Expression(FLAG_PREFETCH_DESCENDANTS, [])    Expression(null, [])  Statement(}, [])  MethodCall(return client.findAccessibilityNodeInfoByAccessibilityId(mConnectionId, mWindowId, childId, false, FLAG_PREFETCH_DESCENDANTS, null), [VariableReference(return client, []), Expression(mConnectionId, []), Expression(mWindowId, []), Expression(childId, []), Expression(false, []), Expression(FLAG_PREFETCH_DESCENDANTS, []), Expression(null, [])])    VariableReference(return client, [])    Expression(mConnectionId, [])    Expression(mWindowId, [])    Expression(childId, [])    Expression(false, [])    Expression(FLAG_PREFETCH_DESCENDANTS, [])    Expression(null, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(return getChild(index, FLAG_PREFETCH_DESCENDANTS_HYBRID), []), Statement(}, [])])  Statement({, [])  Statement(return getChild(index, FLAG_PREFETCH_DESCENDANTS_HYBRID), [])  Statement(}, [])",1,"/**
 * Get the child at given index.
 * <p>
 * <strong>Note:</strong> It is a client responsibility to recycle the
 * received info by calling {@link AccessibilityNodeInfo#recycle()}
 * to avoid creating of multiple instances.
 * </p>
 *
 * @param index The child index.
 * @return The child node.
 *
 * @throws IllegalStateException If called outside of an AccessibilityService.
 */
","/**
 * Get the child at given index.
 *
 * @param index The child index.
 * @return The child node.
 *
 * @throws IllegalStateException If called outside of an AccessibilityService.
 */
",1,,,0,,,,,"1,3,4",1,"1,4,5",1,"The late version simplifies the method body to return the result of another method `getChild(index, FLAG_PREFETCH_DESCENDANTS_HYBRID)`. Hence, there are changes in the return statement, other statements (due to significant reduction in code), and a dependent API now being called (`getChild(int, int)`), so the change types are 1,4,5.","The change highlights a potential difference in return values due to the call to a different method (`getChild(index, FLAG_PREFETCH_DESCENDANTS_HYBRID)`) which might have different internal logic compared to the elaborate logic present in the earlier version. Hence, the CI type is 1."
302,"<android.app.ContextImpl: void sendStickyBroadcastAsUser(Intent,UserHandle)>",29,30,"<android.app.ContextImpl: void sendStickyBroadcastAsUser(Intent,UserHandle)>","<android.app.ContextImpl: void sendStickyBroadcastAsUser(Intent,UserHandle)>",0,"MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(String resolvedType, []), Expression(intent.resolveTypeIfNeeded(getContentResolver()), [])]), Statement(try {, []), MethodCall(intent.prepareToLeaveProcess(this), [VariableReference(intent, []), Expression(this, [])]), MethodCall(ActivityManager.getService().broadcastIntent(mMainThread.getApplicationThread(), intent, resolvedType, null, Activity.RESULT_OK, null, null, null, AppOpsManager.OP_NONE, null, false, true, user.getIdentifier()), [VariableReference(ActivityManager, []), Expression().broadcastIntent(mMainThread.getApplicationThread(), []), Expression(intent, []), Expression(resolvedType, []), Expression(null, []), Expression(Activity.RESULT_OK, []), Expression(null, []), Expression(null, []), Expression(null, []), Expression(AppOpsManager.OP_NONE, []), Expression(null, []), Expression(false, []), Expression(true, []), Expression(user.getIdentifier(), [])]), Statement(} catch (RemoteException e) {, []), MethodCall(throw e.rethrowFromSystemServer(), [VariableReference(throw e, []), Expression(, [])]), Statement(}, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(String resolvedType, []), Expression(intent.resolveTypeIfNeeded(getContentResolver()), [])])    VariableReference(String resolvedType, [])    Expression(intent.resolveTypeIfNeeded(getContentResolver()), [])  Statement(try {, [])  MethodCall(intent.prepareToLeaveProcess(this), [VariableReference(intent, []), Expression(this, [])])    VariableReference(intent, [])    Expression(this, [])  MethodCall(ActivityManager.getService().broadcastIntent(mMainThread.getApplicationThread(), intent, resolvedType, null, Activity.RESULT_OK, null, null, null, AppOpsManager.OP_NONE, null, false, true, user.getIdentifier()), [VariableReference(ActivityManager, []), Expression().broadcastIntent(mMainThread.getApplicationThread(), []), Expression(intent, []), Expression(resolvedType, []), Expression(null, []), Expression(Activity.RESULT_OK, []), Expression(null, []), Expression(null, []), Expression(null, []), Expression(AppOpsManager.OP_NONE, []), Expression(null, []), Expression(false, []), Expression(true, []), Expression(user.getIdentifier(), [])])    VariableReference(ActivityManager, [])    Expression().broadcastIntent(mMainThread.getApplicationThread(), [])    Expression(intent, [])    Expression(resolvedType, [])    Expression(null, [])    Expression(Activity.RESULT_OK, [])    Expression(null, [])    Expression(null, [])    Expression(null, [])    Expression(AppOpsManager.OP_NONE, [])    Expression(null, [])    Expression(false, [])    Expression(true, [])    Expression(user.getIdentifier(), [])  Statement(} catch (RemoteException e) {, [])  MethodCall(throw e.rethrowFromSystemServer(), [VariableReference(throw e, []), Expression(, [])])    VariableReference(throw e, [])    Expression(, [])  Statement(}, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(String resolvedType, []), Expression(intent.resolveTypeIfNeeded(getContentResolver()), [])]), Statement(try {, []), MethodCall(intent.prepareToLeaveProcess(this), [VariableReference(intent, []), Expression(this, [])]), MethodCall(ActivityManager.getService().broadcastIntentWithFeature(mMainThread.getApplicationThread(), getAttributionTag(), intent, resolvedType, null, Activity.RESULT_OK, null, null, null, AppOpsManager.OP_NONE, null, false, true, user.getIdentifier()), [VariableReference(ActivityManager, []), Expression().broadcastIntentWithFeature(mMainThread.getApplicationThread(), []), Expression(getAttributionTag(), []), Expression(intent, []), Expression(resolvedType, []), Expression(null, []), Expression(Activity.RESULT_OK, []), Expression(null, []), Expression(null, []), Expression(null, []), Expression(AppOpsManager.OP_NONE, []), Expression(null, []), Expression(false, []), Expression(true, []), Expression(user.getIdentifier(), [])]), Statement(} catch (RemoteException e) {, []), MethodCall(throw e.rethrowFromSystemServer(), [VariableReference(throw e, []), Expression(, [])]), Statement(}, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(String resolvedType, []), Expression(intent.resolveTypeIfNeeded(getContentResolver()), [])])    VariableReference(String resolvedType, [])    Expression(intent.resolveTypeIfNeeded(getContentResolver()), [])  Statement(try {, [])  MethodCall(intent.prepareToLeaveProcess(this), [VariableReference(intent, []), Expression(this, [])])    VariableReference(intent, [])    Expression(this, [])  MethodCall(ActivityManager.getService().broadcastIntentWithFeature(mMainThread.getApplicationThread(), getAttributionTag(), intent, resolvedType, null, Activity.RESULT_OK, null, null, null, AppOpsManager.OP_NONE, null, false, true, user.getIdentifier()), [VariableReference(ActivityManager, []), Expression().broadcastIntentWithFeature(mMainThread.getApplicationThread(), []), Expression(getAttributionTag(), []), Expression(intent, []), Expression(resolvedType, []), Expression(null, []), Expression(Activity.RESULT_OK, []), Expression(null, []), Expression(null, []), Expression(null, []), Expression(AppOpsManager.OP_NONE, []), Expression(null, []), Expression(false, []), Expression(true, []), Expression(user.getIdentifier(), [])])    VariableReference(ActivityManager, [])    Expression().broadcastIntentWithFeature(mMainThread.getApplicationThread(), [])    Expression(getAttributionTag(), [])    Expression(intent, [])    Expression(resolvedType, [])    Expression(null, [])    Expression(Activity.RESULT_OK, [])    Expression(null, [])    Expression(null, [])    Expression(null, [])    Expression(AppOpsManager.OP_NONE, [])    Expression(null, [])    Expression(false, [])    Expression(true, [])    Expression(user.getIdentifier(), [])  Statement(} catch (RemoteException e) {, [])  MethodCall(throw e.rethrowFromSystemServer(), [VariableReference(throw e, []), Expression(, [])])    VariableReference(throw e, [])    Expression(, [])  Statement(}, [])  Statement(}, [])",1,,,-1,"[@Override, @Deprecated]","[@Override, @Deprecated]",-1,-1,-1,-1,-1,4,0,"4,5",0,"The method call has changed from `ActivityManager.getService().broadcastIntent` to `ActivityManager.getService().broadcastIntentWithFeature`, and the new method includes an additional parameter `getAttributionTag()`. Although this changes the dependent API, it does not affect the return value or exception handling directly, and thus code change type includes both 4 and 5.","The change does not affect the return value or exception handling of the method. Therefore, no compatibility issue exists, so the CI type is 0."
20,<android.widget.FrameLayout: LayoutParams generateDefaultLayoutParams()>,7,8,<android.widget.FrameLayout: LayoutParams generateDefaultLayoutParams()>,<android.widget.FrameLayout: LayoutParams generateDefaultLayoutParams()>,0,"MethodDeclaration(method_body, [Statement({, []), Statement(}, [])])  Statement({, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(}, [])])  Statement({, [])  Statement(}, [])",1,"/**
 * Returns a set of layout parameters with a width of
 * {@link android.view.ViewGroup.LayoutParams#FILL_PARENT},
 * and a height of {@link android.view.ViewGroup.LayoutParams#FILL_PARENT}.
 */
","/**
 * Returns a set of layout parameters with a width of
 * {@link android.view.ViewGroup.LayoutParams#MATCH_PARENT},
 * and a height of {@link android.view.ViewGroup.LayoutParams#MATCH_PARENT}.
 */
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,"1,4",1,0,0,"There is no actual implementation provided in either the early or late versions based on the given AST nodes. The comments have changed to reflect updated references from `FILL_PARENT` to `MATCH_PARENT`, but these are comments and not part of the executable code.","Since there is no change in the actual code implementation, there are no compatibility issues. The type of the return value or the potential exceptions thrown, if any, are unaffected based on the provided AST node information. Therefore, the CI type is 0."
319,"<android.app.Notification.Builder: Builder setSound(Uri,int)>",25,26,"<android.app.Notification.Builder: Builder setSound(Uri,int)>","<android.app.Notification.Builder: Builder setSound(Uri,int)>",0,"MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(mN.sound, []), Expression(sound, [])]), AssignmentExpression(=, [VariableReference(mN.audioStreamType, []), Expression(streamType, [])]), Statement(return this, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(mN.sound, []), Expression(sound, [])])    VariableReference(mN.sound, [])    Expression(sound, [])  AssignmentExpression(=, [VariableReference(mN.audioStreamType, []), Expression(streamType, [])])    VariableReference(mN.audioStreamType, [])    Expression(streamType, [])  Statement(return this, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), MethodCall(PlayerBase.deprecateStreamTypeForPlayback(streamType, ""Notification"", ""setSound()""), [VariableReference(PlayerBase, []), Expression(streamType, []), Expression(""Notification"", []), Expression(""setSound()"", [])]), AssignmentExpression(=, [VariableReference(mN.sound, []), Expression(sound, [])]), AssignmentExpression(=, [VariableReference(mN.audioStreamType, []), Expression(streamType, [])]), Statement(return this, []), Statement(}, [])])  Statement({, [])  MethodCall(PlayerBase.deprecateStreamTypeForPlayback(streamType, ""Notification"", ""setSound()""), [VariableReference(PlayerBase, []), Expression(streamType, []), Expression(""Notification"", []), Expression(""setSound()"", [])])    VariableReference(PlayerBase, [])    Expression(streamType, [])    Expression(""Notification"", [])    Expression(""setSound()"", [])  AssignmentExpression(=, [VariableReference(mN.sound, []), Expression(sound, [])])    VariableReference(mN.sound, [])    Expression(sound, [])  AssignmentExpression(=, [VariableReference(mN.audioStreamType, []), Expression(streamType, [])])    VariableReference(mN.audioStreamType, [])    Expression(streamType, [])  Statement(return this, [])  Statement(}, [])",1,"/**
 * Set the sound to play, along with a specific stream on which to play it.
 *
 * See {@link android.media.AudioManager} for the <code>STREAM_</code> constants.
 *
 * <p>
 * A notification that is noisy is more likely to be presented as a heads-up notification.
 * </p>
 * @deprecated use {@link #setSound(Uri, AudioAttributes)} instead.
 * @see Notification#sound
 */
","/**
 * Set the sound to play, along with a specific stream on which to play it.
 *
 * See {@link android.media.AudioManager} for the <code>STREAM_</code> constants.
 *
 * @deprecated use {@link NotificationChannel#setSound(Uri, AudioAttributes)}.
 */
",-1,[@Deprecated],[@Deprecated],-1,-1,-1,-1,-1,4,0,"3,4",0,"A new method call `PlayerBase.deprecateStreamTypeForPlayback()` is introduced in the late version before the assignment statements, so the change can be classified as 3 (Control dependency changed) and 4 (Other statement changed).","Although the late version introduces a new method call, the core logic of setting the sound and audio stream type remains unchanged. The return value and exception handling are unaffected. Thus, no Compatibility Issue exists, hence the CI type is 0."
64,<android.app.Activity: void recreate()>,23,24,<android.app.Activity: void recreate()>,<android.app.Activity: void recreate()>,0,"MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(if (mParent !, []), Expression(null) {, [])]), Statement(throw new IllegalStateException(""Can only be called on top-level activity""), []), Statement(}, []), AssignmentExpression(=, [VariableReference(if (Looper.myLooper() !, []), Expression(mMainThread.getLooper()) {, [])]), Statement(throw new IllegalStateException(""Must be called from main thread""), []), Statement(}, []), MethodCall(mMainThread.requestRelaunchActivity(mToken, null, null, 0, false, null, null, false), [VariableReference(mMainThread, []), Expression(mToken, []), Expression(null, []), Expression(null, []), Expression(0, []), Expression(false, []), Expression(null, []), Expression(null, []), Expression(false, [])]), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(if (mParent !, []), Expression(null) {, [])])    VariableReference(if (mParent !, [])    Expression(null) {, [])  Statement(throw new IllegalStateException(""Can only be called on top-level activity""), [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(if (Looper.myLooper() !, []), Expression(mMainThread.getLooper()) {, [])])    VariableReference(if (Looper.myLooper() !, [])    Expression(mMainThread.getLooper()) {, [])  Statement(throw new IllegalStateException(""Must be called from main thread""), [])  Statement(}, [])  MethodCall(mMainThread.requestRelaunchActivity(mToken, null, null, 0, false, null, null, false), [VariableReference(mMainThread, []), Expression(mToken, []), Expression(null, []), Expression(null, []), Expression(0, []), Expression(false, []), Expression(null, []), Expression(null, []), Expression(false, [])])    VariableReference(mMainThread, [])    Expression(mToken, [])    Expression(null, [])    Expression(null, [])    Expression(0, [])    Expression(false, [])    Expression(null, [])    Expression(null, [])    Expression(false, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(if (mParent !, []), Expression(null) {, [])]), Statement(throw new IllegalStateException(""Can only be called on top-level activity""), []), Statement(}, []), AssignmentExpression(=, [VariableReference(if (Looper.myLooper() !, []), Expression(mMainThread.getLooper()) {, [])]), Statement(throw new IllegalStateException(""Must be called from main thread""), []), Statement(}, []), MethodCall(mMainThread.requestRelaunchActivity(mToken, null, null, 0, false, null, null, false, false), [VariableReference(mMainThread, []), Expression(mToken, []), Expression(null, []), Expression(null, []), Expression(0, []), Expression(false, []), Expression(null, []), Expression(null, []), Expression(false, []), Expression(false, [])]), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(if (mParent !, []), Expression(null) {, [])])    VariableReference(if (mParent !, [])    Expression(null) {, [])  Statement(throw new IllegalStateException(""Can only be called on top-level activity""), [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(if (Looper.myLooper() !, []), Expression(mMainThread.getLooper()) {, [])])    VariableReference(if (Looper.myLooper() !, [])    Expression(mMainThread.getLooper()) {, [])  Statement(throw new IllegalStateException(""Must be called from main thread""), [])  Statement(}, [])  MethodCall(mMainThread.requestRelaunchActivity(mToken, null, null, 0, false, null, null, false, false), [VariableReference(mMainThread, []), Expression(mToken, []), Expression(null, []), Expression(null, []), Expression(0, []), Expression(false, []), Expression(null, []), Expression(null, []), Expression(false, []), Expression(false, [])])    VariableReference(mMainThread, [])    Expression(mToken, [])    Expression(null, [])    Expression(null, [])    Expression(0, [])    Expression(false, [])    Expression(null, [])    Expression(null, [])    Expression(false, [])    Expression(false, [])  Statement(}, [])",1,"/**
 * Cause this Activity to be recreated with a new instance.  This results
 * in essentially the same flow as when the Activity is created due to
 * a configuration change -- the current instance will go through its
 * lifecycle to {@link #onDestroy} and a new instance then created after it.
 */
","/**
 * Cause this Activity to be recreated with a new instance.  This results
 * in essentially the same flow as when the Activity is created due to
 * a configuration change -- the current instance will go through its
 * lifecycle to {@link #onDestroy} and a new instance then created after it.
 */
",-1,,,-1,-1,-1,-1,-1,5,0,"4,5",0,"In the late version, an additional parameter `false` has been added to the method call `mMainThread.requestRelaunchActivity()`. This reflects a change in the dependent API, thus categorized as 5. The addition of this parameter doesn't fall under return statement changes, exception handling, or control dependency changes. Thus, it categorizes as other statement changes (4) as well.","The added parameter does not directly affect the return values or exception handling paths of the `recreate()` method itself. Therefore, there is no compatibility issue detected, so the CI is 0."
807,<android.app.Activity: void setActionBar(Toolbar)>,22,23,<android.app.Activity: void setActionBar(Toolbar)>,<android.app.Activity: void setActionBar(Toolbar)>,0,"MethodDeclaration(method_body, [Statement({, []), Statement(if (getActionBar() instanceof WindowDecorActionBar) {, []), Statement(}, []), AssignmentExpression(=, [VariableReference(ToolbarActionBar tbab, []), Expression(new ToolbarActionBar(toolbar, getTitle(), this), [])]), AssignmentExpression(=, [VariableReference(mActionBar, []), Expression(tbab, [])]), MethodCall(mWindow.setCallback(tbab.getWrappedWindowCallback()), [VariableReference(mWindow, []), Expression(tbab.getWrappedWindowCallback(), [])]), MethodCall(mActionBar.invalidateOptionsMenu(), [VariableReference(mActionBar, []), Expression(, [])]), Statement(}, [])])  Statement({, [])  Statement(if (getActionBar() instanceof WindowDecorActionBar) {, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(ToolbarActionBar tbab, []), Expression(new ToolbarActionBar(toolbar, getTitle(), this), [])])    VariableReference(ToolbarActionBar tbab, [])    Expression(new ToolbarActionBar(toolbar, getTitle(), this), [])  AssignmentExpression(=, [VariableReference(mActionBar, []), Expression(tbab, [])])    VariableReference(mActionBar, [])    Expression(tbab, [])  MethodCall(mWindow.setCallback(tbab.getWrappedWindowCallback()), [VariableReference(mWindow, []), Expression(tbab.getWrappedWindowCallback(), [])])    VariableReference(mWindow, [])    Expression(tbab.getWrappedWindowCallback(), [])  MethodCall(mActionBar.invalidateOptionsMenu(), [VariableReference(mActionBar, []), Expression(, [])])    VariableReference(mActionBar, [])    Expression(, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(if (getActionBar() instanceof WindowDecorActionBar) {, []), Statement(}, []), Statement(// Clear out the MenuInflater to make sure that it is valid for the new Action Bar, []), AssignmentExpression(=, [VariableReference(mMenuInflater, []), Expression(null, [])]), AssignmentExpression(=, [VariableReference(ToolbarActionBar tbab, []), Expression(new ToolbarActionBar(toolbar, getTitle(), this), [])]), AssignmentExpression(=, [VariableReference(mActionBar, []), Expression(tbab, [])]), MethodCall(mWindow.setCallback(tbab.getWrappedWindowCallback()), [VariableReference(mWindow, []), Expression(tbab.getWrappedWindowCallback(), [])]), MethodCall(mActionBar.invalidateOptionsMenu(), [VariableReference(mActionBar, []), Expression(, [])]), Statement(}, [])])  Statement({, [])  Statement(if (getActionBar() instanceof WindowDecorActionBar) {, [])  Statement(}, [])  Statement(// Clear out the MenuInflater to make sure that it is valid for the new Action Bar, [])  AssignmentExpression(=, [VariableReference(mMenuInflater, []), Expression(null, [])])    VariableReference(mMenuInflater, [])    Expression(null, [])  AssignmentExpression(=, [VariableReference(ToolbarActionBar tbab, []), Expression(new ToolbarActionBar(toolbar, getTitle(), this), [])])    VariableReference(ToolbarActionBar tbab, [])    Expression(new ToolbarActionBar(toolbar, getTitle(), this), [])  AssignmentExpression(=, [VariableReference(mActionBar, []), Expression(tbab, [])])    VariableReference(mActionBar, [])    Expression(tbab, [])  MethodCall(mWindow.setCallback(tbab.getWrappedWindowCallback()), [VariableReference(mWindow, []), Expression(tbab.getWrappedWindowCallback(), [])])    VariableReference(mWindow, [])    Expression(tbab.getWrappedWindowCallback(), [])  MethodCall(mActionBar.invalidateOptionsMenu(), [VariableReference(mActionBar, []), Expression(, [])])    VariableReference(mActionBar, [])    Expression(, [])  Statement(}, [])",1,"/**
 * Set a {@link android.widget.Toolbar Toolbar} to act as the {@link ActionBar} for this
 * Activity window.
 *
 * <p>When set to a non-null value the {@link #getActionBar()} method will return
 * an {@link ActionBar} object that can be used to control the given toolbar as if it were
 * a traditional window decor action bar. The toolbar's menu will be populated with the
 * Activity's options menu and the navigation button will be wired through the standard
 * {@link android.R.id#home home} menu select action.</p>
 *
 * <p>In order to use a Toolbar within the Activity's window content the application
 * must not request the window feature {@link Window#FEATURE_ACTION_BAR FEATURE_ACTION_BAR}.</p>
 *
 * @param toolbar Toolbar to set as the Activity's action bar
 */
","/**
 * Set a {@link android.widget.Toolbar Toolbar} to act as the {@link ActionBar} for this
 * Activity window.
 *
 * <p>When set to a non-null value the {@link #getActionBar()} method will return
 * an {@link ActionBar} object that can be used to control the given toolbar as if it were
 * a traditional window decor action bar. The toolbar's menu will be populated with the
 * Activity's options menu and the navigation button will be wired through the standard
 * {@link android.R.id#home home} menu select action.</p>
 *
 * <p>In order to use a Toolbar within the Activity's window content the application
 * must not request the window feature {@link Window#FEATURE_ACTION_BAR FEATURE_ACTION_BAR}.</p>
 *
 * @param toolbar Toolbar to set as the Activity's action bar
 */
",-1,,,-1,-1,-1,-1,-1,4,0,4,0,"A new statement `mMenuInflater = null;` has been added which clears out the `mMenuInflater` to make sure it is valid for the new Action Bar. This constitutes an ""Other statement changed"" type, so the code change type is 4.","The added statement doesn't affect the return value or exception handling of the API. Thus, no compatibility issue exists, and the CI type is 0."
1086,<android.print.PrintManager.PrintDocumentAdapterDelegate.MyWriteResultCallback: void onWriteCancelled()>,20,21,<android.print.PrintManager.PrintDocumentAdapterDelegate.MyWriteResultCallback: void onWriteCancelled()>,<android.print.PrintManager.PrintDocumentAdapterDelegate.MyWriteResultCallback: void onWriteCancelled()>,0,"MethodDeclaration(method_body, [Statement({, []), Statement(synchronized (mLock) {, []), Statement(if (mDestroyed) {, []), MethodCall(Log.e(LOG_TAG, ""PrintDocumentAdapter is destroyed. Did you "" + ""finish the printing activity before print completion?""), [VariableReference(Log, []), Expression(LOG_TAG, []), Expression(""PrintDocumentAdapter is destroyed. Did you "" + ""finish the printing activity before print completion?"", [])]), Statement(return, []), Statement(}, []), Statement(clearLocked(), []), Statement(}, []), Statement(}, [])])  Statement({, [])  Statement(synchronized (mLock) {, [])  Statement(if (mDestroyed) {, [])  MethodCall(Log.e(LOG_TAG, ""PrintDocumentAdapter is destroyed. Did you "" + ""finish the printing activity before print completion?""), [VariableReference(Log, []), Expression(LOG_TAG, []), Expression(""PrintDocumentAdapter is destroyed. Did you "" + ""finish the printing activity before print completion?"", [])])    VariableReference(Log, [])    Expression(LOG_TAG, [])    Expression(""PrintDocumentAdapter is destroyed. Did you "" + ""finish the printing activity before print completion?"", [])  Statement(return, [])  Statement(}, [])  Statement(clearLocked(), [])  Statement(}, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(final IWriteResultCallback callback, []), Statement(synchronized (mLock) {, []), AssignmentExpression(=, [VariableReference(callback, []), Expression(mCallback, [])]), Statement(}, []), Statement(// If the callback is null we are destroyed., []), AssignmentExpression(=, [VariableReference(if (callback, []), Expression(, [])]), MethodCall(Log.e(LOG_TAG, ""PrintDocumentAdapter is destroyed. Did you "" + ""finish the printing activity before print completion "" + ""or did you invoke a callback after finish?""), [VariableReference(Log, []), Expression(LOG_TAG, []), Expression(""PrintDocumentAdapter is destroyed. Did you "" + ""finish the printing activity before print completion "" + ""or did you invoke a callback after finish?"", [])]), Statement(return, []), Statement(}, []), Statement(try {, []), MethodCall(callback.onWriteCanceled(mSequence), [VariableReference(callback, []), Expression(mSequence, [])]), Statement(} catch (RemoteException re) {, []), MethodCall(Log.e(LOG_TAG, ""Error calling onWriteCanceled"", re), [VariableReference(Log, []), Expression(LOG_TAG, []), Expression(""Error calling onWriteCanceled"", []), Expression(re, [])]), Statement(} finally {, []), Statement(destroy(), []), Statement(}, []), Statement(}, [])])  Statement({, [])  Statement(final IWriteResultCallback callback, [])  Statement(synchronized (mLock) {, [])  AssignmentExpression(=, [VariableReference(callback, []), Expression(mCallback, [])])    VariableReference(callback, [])    Expression(mCallback, [])  Statement(}, [])  Statement(// If the callback is null we are destroyed., [])  AssignmentExpression(=, [VariableReference(if (callback, []), Expression(, [])])    VariableReference(if (callback, [])    Expression(, [])  MethodCall(Log.e(LOG_TAG, ""PrintDocumentAdapter is destroyed. Did you "" + ""finish the printing activity before print completion "" + ""or did you invoke a callback after finish?""), [VariableReference(Log, []), Expression(LOG_TAG, []), Expression(""PrintDocumentAdapter is destroyed. Did you "" + ""finish the printing activity before print completion "" + ""or did you invoke a callback after finish?"", [])])    VariableReference(Log, [])    Expression(LOG_TAG, [])    Expression(""PrintDocumentAdapter is destroyed. Did you "" + ""finish the printing activity before print completion "" + ""or did you invoke a callback after finish?"", [])  Statement(return, [])  Statement(}, [])  Statement(try {, [])  MethodCall(callback.onWriteCanceled(mSequence), [VariableReference(callback, []), Expression(mSequence, [])])    VariableReference(callback, [])    Expression(mSequence, [])  Statement(} catch (RemoteException re) {, [])  MethodCall(Log.e(LOG_TAG, ""Error calling onWriteCanceled"", re), [VariableReference(Log, []), Expression(LOG_TAG, []), Expression(""Error calling onWriteCanceled"", []), Expression(re, [])])    VariableReference(Log, [])    Expression(LOG_TAG, [])    Expression(""Error calling onWriteCanceled"", [])    Expression(re, [])  Statement(} finally {, [])  Statement(destroy(), [])  Statement(}, [])  Statement(}, [])",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,"1,2,3,4","1,2","1,2,3,4","1,2",The changes between the early version and the late version include:,- Introduced a `try-catch` block to call `callback.onWriteCanceled(mSequence)` and handle a potential `RemoteException`.
267,<android.util.SparseIntArray: int indexOfKey(int)>,18,19,<android.util.SparseIntArray: int indexOfKey(int)>,<android.util.SparseIntArray: int indexOfKey(int)>,0,"MethodDeclaration(method_body, [Statement({, []), Statement(return binarySearch(mKeys, 0, mSize, key), []), Statement(}, [])])  Statement({, [])  Statement(return binarySearch(mKeys, 0, mSize, key), [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), MethodCall(return ContainerHelpers.binarySearch(mKeys, mSize, key), [VariableReference(return ContainerHelpers, []), Expression(mKeys, []), Expression(mSize, []), Expression(key, [])]), Statement(}, [])])  Statement({, [])  MethodCall(return ContainerHelpers.binarySearch(mKeys, mSize, key), [VariableReference(return ContainerHelpers, []), Expression(mKeys, []), Expression(mSize, []), Expression(key, [])])    VariableReference(return ContainerHelpers, [])    Expression(mKeys, [])    Expression(mSize, [])    Expression(key, [])  Statement(}, [])",1,"/**
 * Returns the index for which {@link #keyAt} would return the
 * specified key, or a negative number if the specified
 * key is not mapped.
 */
","/**
 * Returns the index for which {@link #keyAt} would return the
 * specified key, or a negative number if the specified
 * key is not mapped.
 */
",-1,,,-1,-1,-1,-1,-1,"1,5",1,5,0,"The implementation has changed from directly using the binarySearch method to using the binarySearch method of the ContainerHelpers class. This indicates that the code now depends on the ContainerHelpers API for performing the binarySearch operation, so the change type is 5.","There is no compatibility issue as the overall logic of the method remains the same; the method's behavior and return values are not affected. Therefore, the CI type is 0."
339,"<android.view.GLES20Canvas: void drawText(String,int,int,float,float,Paint)>",20,21,"<android.view.GLES20Canvas: void drawText(String,int,int,float,float,Paint)>","<android.view.GLES20Canvas: void drawText(String,int,int,float,float,Paint)>",0,"MethodDeclaration(method_body, [Statement({, []), MethodCall(if ((start | end | (end - start) | (text.length() - end)) < 0), [VariableReference(if ((start | end | (end - start) | (text, []), Expression() - end)) < 0, [])]), Statement(throw new IndexOutOfBoundsException(), []), Statement(}, []), AssignmentExpression(=, [VariableReference(int modifiers, []), Expression(setupModifiers(paint), [])]), Statement(try {, []), Statement(} finally {, []), AssignmentExpression(=, [VariableReference(if (modifiers !, []), Expression(MODIFIER_NONE), [])]), Statement(nResetModifiers(mRenderer, modifiers), []), Statement(}, []), Statement(}, [])])  Statement({, [])  MethodCall(if ((start | end | (end - start) | (text.length() - end)) < 0), [VariableReference(if ((start | end | (end - start) | (text, []), Expression() - end)) < 0, [])])    VariableReference(if ((start | end | (end - start) | (text, [])    Expression() - end)) < 0, [])  Statement(throw new IndexOutOfBoundsException(), [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(int modifiers, []), Expression(setupModifiers(paint), [])])    VariableReference(int modifiers, [])    Expression(setupModifiers(paint), [])  Statement(try {, [])  Statement(} finally {, [])  AssignmentExpression(=, [VariableReference(if (modifiers !, []), Expression(MODIFIER_NONE), [])])    VariableReference(if (modifiers !, [])    Expression(MODIFIER_NONE), [])  Statement(nResetModifiers(mRenderer, modifiers), [])  Statement(}, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), MethodCall(if ((start | end | (end - start) | (text.length() - end)) < 0), [VariableReference(if ((start | end | (end - start) | (text, []), Expression() - end)) < 0, [])]), Statement(throw new IndexOutOfBoundsException(), []), Statement(}, []), Statement(}, [])])  Statement({, [])  MethodCall(if ((start | end | (end - start) | (text.length() - end)) < 0), [VariableReference(if ((start | end | (end - start) | (text, []), Expression() - end)) < 0, [])])    VariableReference(if ((start | end | (end - start) | (text, [])    Expression() - end)) < 0, [])  Statement(throw new IndexOutOfBoundsException(), [])  Statement(}, [])  Statement(}, [])",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,"2,4",2,"3,4",0,"The early implementation contains additional statements involving the setup of modifiers, a `try-finally` block, and resetting modifiers which have been removed in the late version. The removal of the `try-finally` block involves control flow change, and additional statements are removed, so the change type is 3,4.","The removed statements and control flow changes do not affect the return type, values, or thrown exceptions. Therefore, no compatibility issue exists, so the CI type is 0."
685,<android.content.pm.ShortcutInfo.Builder: Builder setActivity(ComponentName)>,29,30,<android.content.pm.ShortcutInfo.Builder: Builder setActivity(ComponentName)>,<android.content.pm.ShortcutInfo.Builder: Builder setActivity(ComponentName)>,0,"MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(mActivity, []), Expression(Preconditions.checkNotNull(activity, ""activity cannot be null""), [])]), Statement(return this, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(mActivity, []), Expression(Preconditions.checkNotNull(activity, ""activity cannot be null""), [])])    VariableReference(mActivity, [])    Expression(Preconditions.checkNotNull(activity, ""activity cannot be null""), [])  Statement(return this, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(mActivity, []), Expression(Objects.requireNonNull(activity, ""activity cannot be null""), [])]), Statement(return this, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(mActivity, []), Expression(Objects.requireNonNull(activity, ""activity cannot be null""), [])])    VariableReference(mActivity, [])    Expression(Objects.requireNonNull(activity, ""activity cannot be null""), [])  Statement(return this, [])  Statement(}, [])",1,"/**
 * Sets the target activity.  A shortcut will be shown along with this activity's icon
 * on the launcher.
 *
 * When selecting a target activity, keep the following in mind:
 * <ul>
 * <li>All dynamic shortcuts must have a target activity.  When a shortcut with no target
 * activity is published using
 * {@link ShortcutManager#addDynamicShortcuts(List)} or
 * {@link ShortcutManager#setDynamicShortcuts(List)},
 * the first main activity defined in the app's <code>AndroidManifest.xml</code>
 * file is used.
 *
 * <li>Only ""main"" activities&mdash;ones that define the {@link Intent#ACTION_MAIN}
 * and {@link Intent#CATEGORY_LAUNCHER} intent filters&mdash;can be target
 * activities.
 *
 * <li>By default, the first main activity defined in the app's manifest is
 * the target activity.
 *
 * <li>A target activity must belong to the publisher app.
 * </ul>
 *
 * @see ShortcutInfo#getActivity()
 */
","/**
 * Sets the target activity.  A shortcut will be shown along with this activity's icon
 * on the launcher.
 *
 * When selecting a target activity, keep the following in mind:
 * <ul>
 * <li>All dynamic shortcuts must have a target activity.  When a shortcut with no target
 * activity is published using
 * {@link ShortcutManager#addDynamicShortcuts(List)} or
 * {@link ShortcutManager#setDynamicShortcuts(List)},
 * the first main activity defined in the app's <code>AndroidManifest.xml</code>
 * file is used.
 *
 * <li>Only ""main"" activities&mdash;ones that define the {@link Intent#ACTION_MAIN}
 * and {@link Intent#CATEGORY_LAUNCHER} intent filters&mdash;can be target
 * activities.
 *
 * <li>By default, the first main activity defined in the app's manifest is
 * the target activity.
 *
 * <li>A target activity must belong to the publisher app.
 * </ul>
 *
 * @see ShortcutInfo#getActivity()
 */
",-1,[@NonNull],[@NonNull],-1,-1,-1,-1,-1,4,0,5,0,"The parameter type of the `checkNotNull` method has changed from `Preconditions.checkNotNull` to `Objects.requireNonNull`. This reflects a change in the dependent API, so the change type is 5.","The change from `Preconditions.checkNotNull` to `Objects.requireNonNull` does not inherently lead to a different return value or exception behavior in this context, so there is no Compatibility Issue."
2,"<android.util.LongSparseArray: void setValueAt(int,E)>",28,29,"<android.util.LongSparseArray: void setValueAt(int,E)>","<android.util.LongSparseArray: void setValueAt(int,E)>",0,"MethodDeclaration(method_body, [Statement({, []), Statement(if (mGarbage) {, []), Statement(gc(), []), Statement(}, []), AssignmentExpression(=, [VariableReference(mValues[index], []), Expression(value, [])]), Statement(}, [])])  Statement({, [])  Statement(if (mGarbage) {, [])  Statement(gc(), [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(mValues[index], []), Expression(value, [])])    VariableReference(mValues[index], [])    Expression(value, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(if (index >, []), Expression(mSize && UtilConfig.sThrowExceptionForUpperArrayOutOfBounds) {, [])]), Statement(// Check if exception should be thrown outside of the critical path., []), Statement(throw new ArrayIndexOutOfBoundsException(index), []), Statement(}, []), Statement(if (mGarbage) {, []), Statement(gc(), []), Statement(}, []), AssignmentExpression(=, [VariableReference(mValues[index], []), Expression(value, [])]), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(if (index >, []), Expression(mSize && UtilConfig.sThrowExceptionForUpperArrayOutOfBounds) {, [])])    VariableReference(if (index >, [])    Expression(mSize && UtilConfig.sThrowExceptionForUpperArrayOutOfBounds) {, [])  Statement(// Check if exception should be thrown outside of the critical path., [])  Statement(throw new ArrayIndexOutOfBoundsException(index), [])  Statement(}, [])  Statement(if (mGarbage) {, [])  Statement(gc(), [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(mValues[index], []), Expression(value, [])])    VariableReference(mValues[index], [])    Expression(value, [])  Statement(}, [])",1,"/**
 * Given an index in the range <code>0...size()-1</code>, sets a new
 * value for the <code>index</code>th key-value mapping that this
 * LongSparseArray stores.
 */
","/**
 * Given an index in the range <code>0...size()-1</code>, sets a new
 * value for the <code>index</code>th key-value mapping that this
 * LongSparseArray stores.
 *
 * <p>For indices outside of the range <code>0...size()-1</code>, the behavior is undefined for
 * apps targeting {@link android.os.Build.VERSION_CODES#P} and earlier, and an
 * {@link ArrayIndexOutOfBoundsException} is thrown for apps targeting
 * {@link android.os.Build.VERSION_CODES#Q} and later.</p>
 */
",-1,,,-1,-1,-1,-1,-1,"2,3,4",2,"2,4",2,"The late version includes a new conditional statement that checks if an exception should be thrown (`if (index > mSize && UtilConfig.sThrowExceptionForUpperArrayOutOfBounds)`). If the condition is met, it throws an `ArrayIndexOutOfBoundsException`. This change introduces both a new exception handling statement and another statement not related to control dependency, so the change type is 2,4.","The introduction of the new conditional check and the potential `ArrayIndexOutOfBoundsException` introduces a new way for the method to throw an exception that did not exist in the early version. This change can lead to different exception handling behaviors, and thus the CI type is 2."
1053,"<android.content.res.AssetManager: XmlBlock openXmlBlockAsset(int,String)>",20,21,"<android.content.res.AssetManager: XmlBlock openXmlBlockAsset(int,String)>","<android.content.res.AssetManager: XmlBlock openXmlBlockAsset(int,String)>",0,"MethodDeclaration(method_body, [Statement({, []), Statement(synchronized (this) {, []), Statement(if (!mOpen) {, []), Statement(throw new RuntimeException(""Assetmanager has been closed""), []), Statement(}, []), AssignmentExpression(=, [VariableReference(int xmlBlock, []), Expression(openXmlAssetNative(cookie, fileName), [])]), AssignmentExpression(=, [VariableReference(if (xmlBlock !, []), Expression(0) {, [])]), AssignmentExpression(=, [VariableReference(XmlBlock res, []), Expression(new XmlBlock(this, xmlBlock), [])]), MethodCall(incRefsLocked(res.hashCode()), [VariableReference(incRefsLocked(res, []), Expression(), [])]), Statement(return res, []), Statement(}, []), Statement(}, []), Statement(throw new FileNotFoundException(""Asset XML file: "" + fileName), []), Statement(}, [])])  Statement({, [])  Statement(synchronized (this) {, [])  Statement(if (!mOpen) {, [])  Statement(throw new RuntimeException(""Assetmanager has been closed""), [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(int xmlBlock, []), Expression(openXmlAssetNative(cookie, fileName), [])])    VariableReference(int xmlBlock, [])    Expression(openXmlAssetNative(cookie, fileName), [])  AssignmentExpression(=, [VariableReference(if (xmlBlock !, []), Expression(0) {, [])])    VariableReference(if (xmlBlock !, [])    Expression(0) {, [])  AssignmentExpression(=, [VariableReference(XmlBlock res, []), Expression(new XmlBlock(this, xmlBlock), [])])    VariableReference(XmlBlock res, [])    Expression(new XmlBlock(this, xmlBlock), [])  MethodCall(incRefsLocked(res.hashCode()), [VariableReference(incRefsLocked(res, []), Expression(), [])])    VariableReference(incRefsLocked(res, [])    Expression(), [])  Statement(return res, [])  Statement(}, [])  Statement(}, [])  Statement(throw new FileNotFoundException(""Asset XML file: "" + fileName), [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(synchronized (this) {, []), Statement(if (!mOpen) {, []), Statement(throw new RuntimeException(""Assetmanager has been closed""), []), Statement(}, []), AssignmentExpression(=, [VariableReference(long xmlBlock, []), Expression(openXmlAssetNative(cookie, fileName), [])]), AssignmentExpression(=, [VariableReference(if (xmlBlock !, []), Expression(0) {, [])]), AssignmentExpression(=, [VariableReference(XmlBlock res, []), Expression(new XmlBlock(this, xmlBlock), [])]), MethodCall(incRefsLocked(res.hashCode()), [VariableReference(incRefsLocked(res, []), Expression(), [])]), Statement(return res, []), Statement(}, []), Statement(}, []), Statement(throw new FileNotFoundException(""Asset XML file: "" + fileName), []), Statement(}, [])])  Statement({, [])  Statement(synchronized (this) {, [])  Statement(if (!mOpen) {, [])  Statement(throw new RuntimeException(""Assetmanager has been closed""), [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(long xmlBlock, []), Expression(openXmlAssetNative(cookie, fileName), [])])    VariableReference(long xmlBlock, [])    Expression(openXmlAssetNative(cookie, fileName), [])  AssignmentExpression(=, [VariableReference(if (xmlBlock !, []), Expression(0) {, [])])    VariableReference(if (xmlBlock !, [])    Expression(0) {, [])  AssignmentExpression(=, [VariableReference(XmlBlock res, []), Expression(new XmlBlock(this, xmlBlock), [])])    VariableReference(XmlBlock res, [])    Expression(new XmlBlock(this, xmlBlock), [])  MethodCall(incRefsLocked(res.hashCode()), [VariableReference(incRefsLocked(res, []), Expression(), [])])    VariableReference(incRefsLocked(res, [])    Expression(), [])  Statement(return res, [])  Statement(}, [])  Statement(}, [])  Statement(throw new FileNotFoundException(""Asset XML file: "" + fileName), [])  Statement(}, [])",1,"/*package*/
","/*package*/
",-1,,,-1,-1,-1,-1,-1,4,0,4,0,The type of the variable `xmlBlock` has changed from `int` to `long`. This constitutes an "Other statement changed" type.,"The change in the type of the variable `xmlBlock` does not affect the return value or exception handling of the API. Therefore, no Compatibility Issue exists."
